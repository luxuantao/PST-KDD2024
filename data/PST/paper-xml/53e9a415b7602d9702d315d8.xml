<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">THE IMPACT OF THE LAMBDA CALCULUS IN LOGIC AND COMPUTER SCIENCE</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Henk</forename><surname>Barendregt</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Erik</forename><surname>Barendsen</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jon</forename><surname>Barwise</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Johan</forename><surname>Van Benthem</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Andreas</forename><surname>Blass</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Olivier</forename><surname>Danvy</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Wil</forename><surname>Dekkers</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Marko</forename><surname>Van Eekelen</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Sol</forename><surname>Feferman</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Andrzej</forename><surname>Filinski</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Twan</forename><surname>Laan</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jan</forename><surname>Kuper</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Pierre</forename><surname>Lescanne</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Hans</forename><surname>Mooij</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Robert</forename><surname>Maron</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Rinus</forename><surname>Plasmeijer</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Randy</forename><surname>Pollack</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Kristoffer</forename><surname>Rose</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Richard</forename><surname>Shore</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Rick</forename><surname>Statman</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Simon</forename><surname>Thompson</surname></persName>
						</author>
						<title level="a" type="main">THE IMPACT OF THE LAMBDA CALCULUS IN LOGIC AND COMPUTER SCIENCE</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">AD6F004666523CA2F44041A2565E8BEB</idno>
					<note type="submission">Received September 12, 1996; revised February 28, 1997.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:54+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>One of the most important contributions of A. Church to logic is his invention of the lambda calculus. We present the genesis of this theory and its two major areas of application: the representation of computations and the resulting functional programming languages on the one hand and the representation of reasoning and the resulting systems of computer mathematics on the other hand.</p><p>Acknowledgment. The following persons provided help in various ways.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The difference with f-conversion is that one has e.g., a =p (Ax.x)a, but a f-/4 (Ax.x)a: there is a direction involved in reduction, while conversion is bidirectional. The reason for the notational convention introduced above can be understood by realizing that e.g., We use a, f, y,... for type variables and A, B, C,... for types. The set of types is denoted by T. A statement is of the form M : A with M E A and A E T; M is called the subject of the statement. A basis is a set of statements with only variables as subjects. F, A,... range over bases. (For more complicated versions of typed lambda calculus, a basis needs to be ordered and then is called a context. This is unfortunately a different notion with the same name as the notion 'context' defined earlier, but that is how it is.) DEFINITION 1.3. We say that from basis F we can prove M : A, notation F -M: A, if it can be derived from the following production system. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>. (i) x: (A -A ---B), y : Axyy : B. (ii) h-Axy.xyy : (A -* A -+ B) --(A -* B).</head><p>This version of the simply typed lambda calculus has implicit types at each abstraction Ax and is studied by <ref type="bibr">[37]</ref>. In <ref type="bibr" target="#b25">[29]</ref> a variant with explicit types at abstractions is introduced. In this theory the rule for introducing abstractions is <ref type="figure">r,x : A -M: B = F -(Ax:A.M) : (A -B</ref>).</p><p>An essential difference between the two approaches is that in the explicit case the unique type of a term always can be found easily. In the implicit case types are not unique. For the simply typed lambda calculus the types can be reconstructed even in the implicit case, but for more complicated systems this is not the case. With this operator one can represent primitive recursive functions. Because of the presence of higher types one can even represent the Ackermann function using R. ?2. Formalizing the notion 'computable'. Church introduced a formal theory, let us call it T, based on the notion of function. This system was intended to be a foundation of mathematics. Predicates were represented as characteristic functions. There were many axioms to deal with logical notions. The system T turned out to be inconsistent, as was shown by Church's students <ref type="bibr" target="#b62">[71]</ref> using a tour de force argument involving all the techniques needed to prove Godel's incompleteness theorem2. Then <ref type="bibr" target="#b24">[28]</ref> isolated the (untyped) lambda calculus from the system T by deleting the part dealing with logic and keeping the essence of the part dealing with functions. This system was proved consistent by <ref type="bibr" target="#b27">[31]</ref>, who showed the confluence of f-reduction. Curry, who also wanted to build a foundation for mathematics based on functions (in his case in the form of combinators that do not mention free or bound variables), found a paradox for a system with a similar aim as T, that is very easy to derive, see e.g., <ref type="bibr" target="#b5">[6,</ref><ref type="bibr">Appendix B3]</ref>.</p><p>Church introduced the notion of lambda definability for functions f Nk --N in order to capture the notion of computability4. At first only very elementary functions like addition and multiplication were proved to be lambda definable. Even for a function as simple as the predecessor (pred(0) = 0, pred(n + 1) = n) lambda definability remained an open problem for a while. From our present knowledge it is tempting to explain this as follows. Although the lambda calculus was conceived as an untyped theory, typeable terms are more intuitive. Now the functions addition and multiplication are definable by typeable terms, while <ref type="bibr" target="#b91">[101]</ref> and <ref type="bibr" target="#b98">[108]</ref> have characterized the lambda definable functions in the (simply) typed lambda calculus and the predecessor is not among them. Be this as it may, Kleene did find a way to lambda define the predecessor function in the untyped lambda calculus, by using an appropriate data type (pairs of integers) as auxiliary device. In <ref type="bibr" target="#b61">[69]</ref>, he described how he found the solution while being anesthetized by laughing gas (N20) for the removal of four wisdom teeth. After Kleene showed the solution to his teacher, Church remarked something like: "But then all intuitively computable functions must be lambda definable. In fact, lambda definability must coincide with intuitive computability." Many years later-it was at the occasion of Robin Gandy's 70-th birthday, I believe-I heard Kleene say: "I would like to be able to say that, at the moment of discovering how to lambda define the predecessor function, I got the idea of Church's Thesis. But I did not, Church did." Later, in <ref type="bibr" target="#b59">[67]</ref>, he gave some important evidence for Church's Thesis by showing that the lambda definable functions coincide with the u-recursive ones.</p><p>2G6del just had given a series of lectures in Princeton at which Kleene and Rosser were present.</p><p>3Consistent theories based on functions for the foundations of mathematics have been described by <ref type="bibr" target="#b80">[89]</ref> (simplified by <ref type="bibr" target="#b88">[98]</ref>). With a similar aim are the theories in <ref type="bibr" target="#b46">[53]</ref> and <ref type="bibr" target="#b66">[75]</ref>. In all these theories the paradoxes have been avoided by having a partial application. <ref type="bibr" target="#b38">[43]</ref>, <ref type="bibr" target="#b39">[44]</ref> and <ref type="bibr" target="#b13">[16]</ref> also discuss formal theories with partial application; they aim at constructive foundations and come close to lambda calculus (partial combinatory algebras). 41 remember a story stating that Church started to work on the problem of trying to show that the sequence of Betti numbers for a given algebraic variety is computable. He did not succeed in this enterprise, but came up with the proposal to capture the notion of intuitive computability. I have not been able to verify this story. Readers who can confirm or refute it are kindly requested to inform the author.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Independently of Church, an alternative formalization (in terms of (Turing) machines) of the notion 'computable' was given in [113]. In [114] it was</head><p>proved that the notions of lambda definability and Turing computability are equivalent, thereby enlarging the credibility of Church's Thesis.</p><p>Church's Thesis is plausible but cannot be proved, nor even stated in (classical) mathematical terms, since it refers to the undefined notion of intuitive computability. On the other hand, Church's Thesis can be refuted. If ever a function will be found that is intuitively computable but (demonstrably) not lambda definable, then Church's Thesis is false. For more than 60 years this has not happened. This failure to find a counterexample is given as an argument in favor of Church's Thesis. I think that it is fair to say that most logicians do believe Church's Thesis. One may wonder why doubting Church's Thesis is not a completely academic question. This becomes clear by realizing that <ref type="bibr" target="#b96">[106]</ref> had introduced the class of primitive recursive functions that for some time was thought to coincide with that of the intuitively computable ones. But then <ref type="bibr" target="#b1">[2]</ref> showed that there is a function that is intuitively computable but not primitive recursive. See also the paper of <ref type="bibr" target="#b41">[46]</ref> for arguments in favor of Church's Thesis and <ref type="bibr" target="#b64">[73,</ref><ref type="bibr" target="#b65">74]</ref> for ones casting some doubts.</p><p>Church's Thesis is actually used for negative computability results: if a function is shown to be not lambda definable (or Turing computable) then, by Church's Thesis, one can state that it is not intuitively computable. Church and Turing gave examples of undecidable predicates, i.e., ones with noncomputable characteristic functions: the questions whether a lambda term has a normal form (the normalization problem) and whether a machine with program p and input x terminates (the halting problem), respectively. Both concluded that provability in arithmetic is undecidable. In fact, the undecidability of many mathematical problems has been established by translating the halting problem into a given problem. A famous example is <ref type="bibr" target="#b73">[82]</ref> result that Hilbert's tenth problem5 is unsolvable.</p><p>Finally it is worth mentioning that in intuitionistic mathematics, say in Heyting's arithmetic HA, one can precisely formulate Church's Thesis as a formal statement; this in contrast to the situation in the classical theory. This statement is called CT and is where (e(x) = y S 3z[T(e, x, z) &amp; U(z) = y] states that the e-th partial recursive function with input x terminates with y as value (T is Kleene's computation predicate and U is the value extracting function, see <ref type="bibr" target="#b60">[68]</ref>). In this form CT states that if P is a decidable predicate (i.e., the excluded middle  <ref type="figure">A -B) -(A -B</ref>) for the same term I. See <ref type="bibr" target="#b7">[8]</ref> for more information about these and other typed lambda calculi. Particularly interesting are the second and higher order calculi l2 and Aco introduced by <ref type="bibr" target="#b43">[49]</ref> (under the names 'system F' and 'system Fco') for applications to proof theory and the calculi with dependent types introduced by <ref type="bibr" target="#b23">[26]</ref> for proof verification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Vx[P(x) V -P(x)] =&gt; 3eVx[[P(x) -?e(x</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Computing on data types. In this subsection we explain how it is</head><p>possible to represent data types in a very direct manner in the various lambda calculi.</p><p>Lambda definability was introduced for functions on the set of natural numbers N. In the resulting mathematical theory of computation (recursion theory) other domains of input or output have been treated as second class citizens by coding them as natural numbers. In more practical computer science, algorithms are also directly defined on other data types like trees or lists.</p><p>Instead of coding such data types as numbers one can treat them as first class citizens by coding them directly as lambda terms while preserving their structure. Indeed, lambda calculus is jstrong enough to do this, as was emphasized in <ref type="bibr" target="#b18">[21]</ref> and <ref type="bibr" target="#b20">[23]</ref>. As a result, a much more efficient representation of algorithms on these data types can be given, than when these types were represented via numbers. This methodology was perfected in two different ways in <ref type="bibr" target="#b19">[22]</ref> and <ref type="bibr" target="#b21">[24]</ref> or <ref type="bibr" target="#b16">[19]</ref>. The first paper does the representation in a way that can be typed; the other papers in an essentially stronger way, but one that cannot be typed. We present the methods of these papers by treating labeled trees as an example.</p><p>Let the (inductive) data-type of labeled trees be defined by the following abstract syntax. tree .= * leaf nat treetree nat = Olsuccnat.</p><p>We see that a label can be either a bud (*) or a leaf with a number written on it. A typical such tree is (leaf 3) + ((leaf 5) + *). This tree together with its mirror image look as follows. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Then one has for example that fmir((leaf 3) + ((leaf 5) + *)) = (( + leaf 5) + leaf 3).</head><p>We will now show in two different ways how trees can be represented as lambda terms and how operations like fmir on these objects become lambda definable. The first method is from <ref type="bibr" target="#b19">[22]</ref>. The resulting data objects and functions can be represented by lambda terms typeable in the second order lambda calculus A2, see <ref type="bibr" target="#b44">[51]</ref> or <ref type="bibr" target="#b7">[8]</ref>. <ref type="bibr">DEFINITION</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">(i) Let b, 1, p be variables (used as mnemonics for bud, leaf and plus).</head><p>Define 0b,'p : treeterm, where term is the collection of untyped lambda terms, as follows. Here rn _ 2fx.fnx is Church's numeral representing n as lambda term.</p><p>(ii) Define i?1: tree --term as follows. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(iii) Similarly, using that vl (t)blp -0(t).</head><p>This proposition states that the trees we considered are representable as lambda terms in such a way that the constructors (*, leaf and +) are lambda definable. In fact, the lambda terms involved can be typed in 22. A nice connection between these terms and proofs in second order logic is given in <ref type="bibr" target="#b70">[79]</ref>. Now we will show that iterative functions over these trees, like fmir, are lambda definable. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PROPOSITION 3.3 (Iteration). Given lambda terms</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Now take H = Xt.FtU2. [This was the trick Kleene found at the dentist.] -H</head><p>Now we will present the method of <ref type="bibr" target="#b21">[24]</ref> and <ref type="bibr" target="#b16">[19]</ref> to represent data types. Again we consider the example of labeled trees. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Functional programming. In this subsection a short history is presented of how lambda calculi (untyped and typed) inspired (either consciously or unconsciously) the creation of functional programming.</head><p>Imperative versusfunctionalprogramming. While Church had captured the notion of computability via the lambda calculus, Turing had done the same via his model of computation based on Turing machines. When in the second world war computational power was needed for military purposes, the first electronic devices were built basically as Turing machines with random access memory. Statements in the instruction set for these machines, like x := x + 1, are directly related to the instructions of a Turing machine. Such statements are much more easily interpreted by hardware than the act of substitution fundamental to the lambda calculus. In the beginning, the hardware of the early computers was modified each time a different computational job had to be done. Then von Neumann, who must have known6 Turing's concept of a universal Turing machine, suggested building one machine that could be programmed to do all possible computational jobs using software. In the resulting computer revolution, almost all machines are based on this so called von Neumann computer, consisting of a programmable universal machine. It would have been more appropriate to call it the Turing computer.</p><p>The model of computability introduced by Church (lambda definability)although equivalent to that of Turing-was harder to interpret in hardware. Therefore the emergence of the paradigm of functional programming, that is based essentially on lambda definability, took much more time. Because functional programs are closer to the specification of computational problems than imperative ones, this paradigm is more convenient than the traditional imperative one. Another important feature of functional programs is that parallelism is much more naturally expressed in them, than in imperative programs. See [117] and [64] for some evidence for the elegance of the functional paradigm. The implementation difficulties for functional programming have to do with memory usage, compilation time and actual run time of functional programs. In the contemporary state of the art of implementing functional languages, these problems have been solved satisfactorily.7</p><p>Classes offunctional languages. Let us describe some languages that have been-and in some cases still are-influential in the expansion of functional programming. These languages come in several classes. It turns out that eager languages are, nevertheless, computationally complete, as we will soon see. The implementation of these languages was the first milestone in the development of functional programming. The second milestone consisted of the efficient implementation of lazy languages.</p><p>In addition to the distinction between eager and lazy functional languages there is another one of equal importance. This is the difference between untyped and typed languages. The difference comes directly from the difference between the untyped lambda calculus and the various typed lambda calculi, see <ref type="bibr" target="#b7">[8]</ref>. Typing is useful, because many programming bugs (errors) result in a typing error that can be detected automatically prior to running one's program. On the other hand, typing is not too cumbersome, since in many cases the types need not be given explicitly. The reason for this is that, by the type reconstruction algorithm of <ref type="bibr" target="#b33">[38]</ref>  Besides the functional languages that will be treated below, the languages APL and FP have been important historically. The language APL, introduced in <ref type="bibr" target="#b57">[65]</ref>, has been, and still is, relatively widespread. The language FP was designed by Backus, who gave, in his lecture ( <ref type="bibr" target="#b4">[5]</ref>) at the occasion of receiving his Turing award (for his work on imperative languages) a strong and influential plea for the use of functional languages. Both APL and FP programs consist of a set of basic functions that can be combined to define operations on data structures. The language APL has, for example, many functions for matrix operations. In both languages composition is the only way to obtain new functions and, therefore, they are less complete than a full functional language in which user defined functions can be created. As a consequence, these two languages are essentially limited in their ease of expressing algorithms.</p><p>Eager functional languages. Let us first give the promised argument that eager functional languages are computationally complete. Every computable (recursive) function is lambda definable in the Al-calculus (see <ref type="bibr" target="#b26">[30]</ref> or [6, Theorem 9.2.16]). In the RI-calculus a term having a normal form is strongly normalizing (see <ref type="bibr" target="#b27">[31]</ref> or [6, Theorem 9.1.5]). Therefore an eager evaluation strategy will find the required normal form.</p><p>The first functional language, LISP, was designed and implemented by <ref type="bibr" target="#b74">[83]</ref>. The evaluation of expressions in this language is eager. LISP had (and still has) considerable impact on the art of programming. Since it has a good programming environment, many skillful programmers were attracted to it and produced interesting programs (so called 'artificial intelligence'). LISP is not a pure functional language for several reasons. Assignment is possible in it; there is a confusion between local and global variables8 ('dynamic binding'; some LISP users even like it); LISP uses the 'Quote', where (Quote M) is like rM'. In later versions of LISP, Common LISP (see <ref type="bibr">[110]</ref>) and Scheme (see <ref type="bibr" target="#b28">[32]</ref>), dynamic binding is no longer present. The 'Quote' operator, however, is still present in these languages. Since la = a but rla' 7= ra' adding 'Quote' to the lambda calculus is inconsistent. As one may not reduce in LISP within the scope of a 'Quote', however, having a 'Quote' in LIPS is not inconsistent. 'Quote' is not an available function but only a constructor. That is, if M is a well-formed expression, so is 8This means substitution of an expression with a free variable into a context in which that variable becomes bound. The originators of LISP were in good company: in <ref type="bibr">[</ref> (implemented as a cycle) that is also found in later functional languages. In the meantime, <ref type="bibr" target="#b68">[77]</ref> developed an abstract machine-the SECD machine-for the implementation of reduction. Many implementations of eager functional languages, including some versions of LISP, have used, or are still using, this computational model. (The SECD machine also can be modelled for lazy functional languages, see <ref type="bibr" target="#b50">[57]</ref>.) Another way of implementing functional languages is based on the so called CPS-translation. This was introduced in <ref type="bibr" target="#b87">[96]</ref> and used in a compilers by <ref type="bibr" target="#b99">[109]</ref> and <ref type="bibr" target="#b2">[3]</ref>. See also <ref type="bibr" target="#b84">[93]</ref> and <ref type="bibr">[97]</ref>.</p><p>The first important typed functional language with an eager evaluation strategy is Standard ML, see <ref type="bibr" target="#b75">[84]</ref>. This language is based on the Curry variant of i-l, the simply typed lambda calculus with implicit typing, see <ref type="bibr" target="#b7">[8]</ref>. Expressions are type-free, but are only legal if a type can be derived for them. By the algorithm of Curry and Hindley cited above, it is decidable whether an expression does have a type and, moreover, its most general type can be computed. but to ... @. @ ... ; @ : A, where the first two occurrences of @ are pointers referring to the A behind the third occurrence. In this way lambda expressions become dags (directed acyclic graphs).'0 Based on the idea of graph reduction, using carefully chosen combinators as primitives, the experimental language SASL, see [115] and [116], was one of the first implemented lazy functional languages. The notion of graph reduction was extended by Turner by implementing the fixed-point combinator (one of the primitives) as a cyclic graph. (Cyclic graphs were already described in [119] but were not used there.) Like LISP, the language SASL is untyped. It is fair to say that-unlike programs written in the eager languages such as LISP and Standard ML-the execution of SASL programs was orders of magnitude slower than that of imperative programs in spite of the use of graph reduction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Milner added two features to 2-&gt;. The first is the addition of new primitives. One has the fixed-point combinator Y as primitive, with essentially all types of the form (A -&gt; A) -) A, with</head><p>In the 1980s typed versions of lazy functional languages did emerge, as well as a considerable speed-up of their performance. A lazy version of ML, called Lazy ML (LML), was implemented efficiently by a group at Chalmers University, see <ref type="bibr" target="#b58">[66]</ref>. As underlying computational model they used the so called G-machine, that avoids building graphs whenever efficient. For example, if an expression is purely arithmetical (this can be seen from type information), then the evaluation can be done more efficiently than by using graphs. Another implementation feature of the LML is the compilation into super-combinators, see <ref type="bibr" target="#b56">[63]</ref>, that do not form a fixed set, but are created on demand depending on the expression to be evaluated. Emerging from SASL, the first fully developed typed lazy functional language called MirandaTM was developed by <ref type="bibr">[118]</ref>. Special mention should be made of its elegance and its functional I/O interface (see below).</p><p>Notably, the ideas in the G-machine made lazy functional programming much more efficient. In the late 1980s very efficient implementations of two typed lazy functional languages appeared that we will discuss below: Clean, see <ref type="bibr" target="#b35">[40]</ref>, and Haskell, see <ref type="bibr" target="#b83">[92]</ref>, <ref type="bibr" target="#b55">[62]</ref>. These languages, with their implementations, execute functional programs in a way that is comparable to the speed of contemporary imperative languages such as C.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Interactive functional languages. The versions of functional programming that we have considered so far could be called 'autistic'. A program consists of an expression M, its execution of the reduction of M and its output of the normal form Mf (if it exists). Although this is quite useful for many</head><p>'?Robin Gandy mentioned at a meeting for the celebration of his seventieth birthday that already in the early 1950s Turing had told him that he wanted to evaluate lambda terms using graphs. In Turing's description of the evaluation mechanism he made the common oversight of confusing free and bound variables. The solution put forward in the functional language Clean is to use a typing system that guarantees that the I/O channels are never duplicated. For this purpose a so-called 'uniqueness' typing system is designed, see <ref type="bibr" target="#b12">[14,</ref><ref type="bibr">15]</ref>, that is related to linear logic (see <ref type="bibr">[50]</ref>). Once this is done, one can improve the way in which parts of the world are used explicitly. A representation of all aspects of the world can be incorporated in lambda calculus. Instead of having just [In, Out], the world can now be extended to include (a representation of) the screen, the printer, the mouse, the keyboard and whatever gadgets one would like to add to the computer periphery (e.g., other computers to form a network). So interpreting 'print' 7 now becomes simply something like put 7 printer. This has the advantage that if one wants to echo a 7 and to print a 3, but the order in which this happens is immaterial, then one is not forced to make an over-specification, like sending first 'print' 3 and then 'echo' 7 to the output channel: What happens first depends on the operating system and parameters, that we do not know (for example on how long the printing queue is). But we are not interested in this. The system satisfies the Church-Rosser theorem and the eventual result (7 is printed and 3 is echoed) is unambiguous. This makes Clean somewhat more natural than Haskell (also in its present version) and definitely more appropriate for an implementation on parallel hardware. Both Clean and Haskell are state of the art functional programming languages producing efficient code; as to compiling time Clean belongs to the class of fast compilers (including those for imperative languages). Many serious applications are written in these languages. The interactive aspect of both languages is made possible by lazy evaluation and the use of higher type12 functions, two themes that are at the core of the lambda calculus (2K, that is). It is to be expected that they will have a significant impact on the production of modern (interactive window based) software. ?4. Reasoning. Computer mathematics. Modern systems for computer algebra (CA) are able to represent mathematical notions on a machine and compute with them. These objects can be integers, real or complex numbers, polynomials, integrals and the like. The computations are usually symbolic, but can also be numerical to a virtually arbitrary degree of precision. It is fair to say-as is sometimes done-that "a system for CA can represent V2 exactly". In spite of the fact that this number has an infinite decimal expansion, this is not a miracle. The number 2 is represented in a computer just as a symbol (as we do on paper or in our mind), and the machine knows how to manipulate it. The common feature of these kind of notions represented in systems for CA is that in some sense or another they are all computable. Systems for CA have reached a high level of sophistication and efficiency and are commercially available. Scientists and both pure and applied mathematicians have made good use of them for their research.</p><p>There is now emerging a new technology, namely that of systems for Computer Mathematics (CM). In these systems virtually all mathematical notions can be represented exactly, including those that do not have a computational nature. How is this possible? Suppose, for example, that we want to represent a non-computable object like the co-Diophantine set X= {n E N-3x D(x,n) = 0}. '2In the functional programming community these are called 'higher order functions'. We prefer to use the more logically correct expression 'higher type', since 'higher order' refers to quantification over types (like in the system A2). Then we can do as before and represent it by a special symbol. But now the computer in general cannot operate on it because the object may be of a non-computational nature. Before answering the question in the previous paragraph, let us first analyze where non-computability comes from. It is always the case that this comes from the quantifiers V (for all) and 3 (exists). Indeed, these quantifiers usually range over an infinite set and therefore one loses decidability.</p><p>Nevertheless, for ages mathematicians have been able to obtain interesting information about these non-computable objects. This is because there is a notion of proof. Using proofs one can state with confidence that e.g., 3 E X, i.e.,-3x, D(x, 3) = 0.</p><p>Aristotle had already remarked that it is often hard to find proofs, but the verification of a putative one can be done in a relatively easy way. Another contribution of Aristotle was his quest for the formalization of logic. After about 2300 years, when Frege had found the right formulation of predicate logic and G6del had proved that it is complete, this quest was fulfilled. Mathematical proofs can now be completely formalized and verified by computers. This is the underlying basis for the systems for CM.</p><p>Present day prototypes of systems for CM are able to help a user to develop from primitive notions and axioms many theories, consisting of defined concepts, theorems and proofs.13 All the systems of CM have been inspired by the AUTOMATH project of de Bruijn (see <ref type="bibr" target="#b23">[26]</ref> and [27] and <ref type="bibr" target="#b79">[88]</ref>) for the automated verification of mathematical proofs.</p><p>Representing proofs as lambda terms. Now that mathematical proofs can be fully formalized, the question arises how this can be done best (for efficiency reasons concerning the machine and pragmatic reasons concerning the human user). Hilbert represented a proof of statement A from a set of axioms F as a finite sequence Ao, A ... , An such that A = An and each Ai, for 0 &lt; i &lt; n, is either in F or follows from previous statements using the rules of logic.</p><p>A more efficient way to represent proofs employs typed lambda terms and is called the propositions-as-types interpretation discovered by Curry, Howard and de Bruijn. This interpretation maps propositions into types and proofs into the corresponding inhabitants. The method is as follows. A statement A is transformed into the type (i.e., collection)</p><p>[A] = the set of proofs of A. A description of the typed lambda calculi in which these types and inhabitants can be formulated is given in <ref type="bibr" target="#b7">[8]</ref>, which also gives an example of a large proof object. Verifying whether p is a proof of A boils down to verifying whether, in the given context, the type of p is equal (convertible) to [A]. The method can be extended by also representing connectives like &amp; andin the right type system. Translating propositions as types has as default intuitionistic logic. Classical logic can be dealt with by adding the excluded middle as an axiom. If a complicated computer system claims that a certain mathematical statement is correct, then one may wonder whether this is indeed the case. For example, there may be software errors in the system. A satisfactory methodological answer has been given by de Bruijn. Proof-objects should be public and written in such a formalism that a reasonably simple proofchecker can verify them. One should be able to verify the program for this proof-checker 'by hand'. We call this the de Bruijn criterion. The proof-development systems Lego (see <ref type="bibr" target="#b71">[80]</ref>) and Coq (see <ref type="bibr" target="#b29">[33]</ref>) satisfy this criterion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>So A is provable if and only if [A]</head><p>A way to keep proof-objects from growing too large is to employ the socalled Poincare principle. [94, p. 12] stated that an argument showing that 2 + 2 = 4 "is not a proof in the strict sense, it is a verification" (actually he claimed that an arbitrary mathematician will make this remark). In the AUTOMATH project of de Bruijn the following interpretation of the Poincare principle was given. If p is a proof of A(t) and t =R t', then the same p is also a proof of A(t'). Here R is a notion of reduction consisting of ordinary fl-reduction and 6-reduction in order to deal with the unfolding of definitions. Since fl-8-reduction is not too complicated to be programmed, '4The reductions may sometimes cause the proof-checking to be of an unacceptable time complexity. We have that p is a proof of A iff type(p) =-/ A. Because the proof is coming from a human, the necessary conversion path is feasible, but to find it automatically may be hard. The problem probably can be avoided by enhancing proof-objects with hints for a reduction strategy. The use of inductive types like Nat and term(Nat) and the corresponding reduction relations for primitive reduction was suggested by <ref type="bibr" target="#b92">[102]</ref> and the extension of the Poincare principle for the corresponding reduction relations of primitive recursion by <ref type="bibr" target="#b72">[81]</ref>. Since such reductions are not too hard to program, the resulting proof checking still satisfies the de Bruijn criterion.</p><p>In <ref type="bibr" target="#b81">[90]</ref> a program is presented that, for every primitive recursive predicate P, constructs the lambda term Kp defining its characteristic function and the proof of the adequacy of Kp. The resulting computations for P = Prime are not efficient, because a straightforward (non-optimized) translation of primitive recursion is given and the numerals (represented numbers) used are in a unary (rather than n-ary) representation; but the method is promising. In <ref type="bibr" target="#b36">[41]</ref>, a more efficient ad hoc lambda definition of the characteristic function of Prime is given, using Fermat's small theorem about primality. Also the required proof obligation has been given.</p><p>Choice offormal systems. There are several possibilities for the choice of a formal system to be used for the representation of theories in systems of computer mathematics. Since, in constructing proof-objects, cooperation between researchers is desirable, this choice has to be made with some care in order to reach an international standard. As a first step towards this, one may restrict attention to systems of typed lambda calculi, since they provide a compact representation and meet de Bruijn's criterion of having a simple proof-checker. In their simplest form, these systems can be described in a uniform way as pure type systems (PTS's) of different strength, see <ref type="bibr" target="#b7">[8]</ref>. The PTS's should be extended by a definition mechanism to become DPTS's (PTS's with definitions), see <ref type="bibr" target="#b94">[104]</ref>. The DPTS's are good for describing several variants of logic: many sorted predicate logic in its first, second or higher order versions. As stated before, the default logic is intuitionistic, but can be made classical by assuming the excluded middle.</p><p>The next step consists of adding inductive types (IT's) and the corresponding reduction relations in order to capture primitive recursion. We suggest that the right formal systems to be used for computer mathematics are the type systems (TS), consisting of DPTS's extended by IT's, as described e.g., in <ref type="bibr" target="#b82">[91]</ref>. TS's come with two parameters. The first is the specification A of the underlying PTS specifying its logical strength, see <ref type="bibr" target="#b7">[8]</ref>. The second is B the collection of inductive types and their respective notions of reduction -+, specifying its mathematical and computational strength. In my opinion, a system for proof-checking should be able to verify proof-objects written in all the systems TS(A, B) (for a 'reasonable' choice spectrum of the parameters). If someone wants to use it for only a subclass of the choice of parameters-dictated by that person's foundational views-then the proofchecker will do its work anyway. I believe that this generality will not be too expensive in terms of the complexity of the checking.15 Illative lambda calculus. Curry and his students continued to look for a way to represent functions and logic into one adequate formal system. Some of the proposed systems turned out to be inconsistent, other ones turned out to be incomplete. Research in TS's for the representation of logic has resulted in an unexpected side effect. By making a modification inspired by the TS's, it became possible, after all, to give an extension of the untyped lambda calculus, called Illative Lambda Calculi (ILC; 'illative' from the Latin word inferre which means to infer), such that first order logic can be faithfully and completely embedded into it. The method can be extended for an arbitrary PTS16, so that higher order logic can be represented too.</p><p>The resulting ILC's are in fact simpler than the TS's. But doing computer mathematics via ILC is probably not very practical, as it is not clear how to do proof-checking for these systems.</p><p>One nice thing about the ILC is that the old dream of Church and Curry came true, namely, there is one system based on untyped lambda calculus (or combinators) on which logic, hence mathematics, can be based. More importantly there is a 'combinatory transformation' between the ordinary interpretation of logic and its propositions-as-types interpretation. Basically, the situation is as follows. The interpretation of predicate logic in ILC is such that</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>-ogic A with proof p Vr F-ILC [A]r[p]</head><p>?'</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F-ILC [A]l[p] -ILC [A]K[p] = K[A]I[p] = [A],</head><p>15It may be argued that the following list of features is so important that they deserve to be present in TS's as primitives and be implemented: quotient types (see <ref type="bibr" target="#b54">[61]</ref>), subtypes (see <ref type="bibr" target="#b3">[4]</ref>) and type inclusion (see <ref type="bibr" target="#b71">[80]</ref>). This is an interesting question and experiments should be done to determine whether this is the case or whether these can be translated into the more basic TS's in a sufficiently efficient way (possibly using some macros in the system for CM).</p><p>'6For first order logic, the embedding is natural, but e.g., for second order logic this is less so. It is an open question whether there exists a natural representation of second and higher order logic in ILC.</p><p>where r ranges over untyped lambda terms. Now if r = I, then this translation is the propositions-as-types interpretation; if, on the other hand, one has r = K, then the interpretation becomes an isomorphic version of first order logic denoted by [A]'. See <ref type="bibr" target="#b11">[13]</ref> and <ref type="bibr" target="#b34">[39]</ref> for these results. A short introduction to ILC (in its combinatory version) can be found in [6, Appendix B].</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>(</head><label></label><figDesc>Axyz.x(yz)y)XYZ -*p X(YZ)Y A term M E A is called in fl-normalform (fl-nf) if M has no part of the form (Ax.M)N. Such part is called a f-redex. A term M is said to have a P-normalform N if N is in p-normal form and M =p N. THEOREM 1.2 (Church-Rosser theorem). Let M, N E A. Then M =f N -3Z [M -* Z&amp;N -* Z]. It follows from the Church-Rosser theorem that a term can have at most one f-normal form. Indeed, if M has M' and M" as fl-nf's, then M' =p M" and so M' -p Z p-M". But since M' and M" are in fl-nf, there are no redexes to contract. Therefore M' = Z = M". Simply typed lambda calculus. Simple types are defined by the abstract syntax tvar = a tvar' type = tvarltypetype.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>F</head><label></label><figDesc>(x:A) Er rF-x: A; rF-M:(A --B), rF-N:A = rFk(MN):B;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>F</head><label></label><figDesc>Inductive types and recursion. Because inductive types are convenient to represent data, both in theories and in programs, some type systems allow the axiomatic introduction of so-called inductive types. The following is a simple example. nat ::= zero | succ nat. Given this definition one has (axiomatically) F-zero : nat, i-succ : nat -, nat and F succ(succ zero) : nat. Inductive types come with natural primitive recursive operators. For example, given a type A and assuming a : A, b : nat -4 A -* A, we may define F : nat -* A as follows. uniformly on a, b. To make this dependence explicit, we write F = R a b and postulate the following. Rab zero -, a; R a b (succ x) -, b x (R a b x).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>5 "? 3 .</head><label>53</label><figDesc>Is it decidable whether a given Diophantine equation has a solution in the integers?" This content downloaded from 130.237.29.138 on Mon, 26 Oct 2015 09:48:18 UTC All use subject to JSTOR Terms and Conditions HENK BARENDREGT holds for P), then P has a recursive characteristic function. See [112] for formal consequences, models, counter-models and an extension of CT. Computing. Lambda calculi are prototype programming languages. As is the case with imperative programming languages, where several examples are untyped (machine code, assembler, Basic) and several are typed (Algol-68, Pascal), systems of lambda calculi exist in untyped and typed versions. There are also other differences in the various lambda calculi. The lambda calculus introduced in [28] is the untyped Al-calculus in which an abstraction Ax.M is only allowed if x occurs among the free variables of M. Nowadays, "lambda calculus" refers to the 2K-calculus developed under the influence of Curry, in which Ax.M is allowed even if x does not occur in M. There are also typed versions of the lambda calculus. Of these, the most elementary are two versions of the simply typed lambda calculus A -. One version is due to [37] and has implicit types. Simply typed lambda calculus with explicit types is introduced in [29] (this system is inspired by the theory of types of [100] as simplified by [95]). In order to make a distinction between the two versions of simply typed lambda calculus, the version with explicit types is sometimes called the Church version and the one with implicit types the Curry version. The difference is that in the Church version one explicitly types a variable when it is bound after a lambda, whereas in the Curry version one does not. So for example in Church's version one has IA = (x : A.x) : A -&gt; A and similarly IA-B : (A -) B) -(A -B), while in Curry's system one has I = (Ax.x) : A -A but also I : (</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>FB1</head><label></label><figDesc>Ao, A1, A2 there exists a lambda term F such that (for variables n, tl, t2) the auxiliary function F =t.(t, Ht). Then by the proposition F can be defined using iteration. Indeed, F(Ptl t2) = (Pt1 t2, H(Pt,t2)) = A2(Ftl)(Ft2), with A2 -tlt2.(P(tl U21)(t2 U2), C2(tl U2) (t2 U2)(t U22)(t2 U22)).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>DEFINITION 3 . 5 .</head><label>35</label><figDesc>Define y2 : tree -* term as follows. /2(*) = te.eU e; /2(leaf n) = Ae.eU2ne; /2 (tl + t2) = Ae.eU3 2(tl ) V2(t2)e. This content downloaded from 130.237.29.138 on Mon, 26 Oct 2015 09:48:18 UTC All use subject to JSTOR Terms and Conditions x.Ao(x). Similarly one can find X1, X2. -This second representation is essentially untypeable, at least in typed lambda calculi in which all typeable terms are normalizing. This follows from the following consequence of a result similar to Proposition 3.6. Let K = -xy.x, K, = Axy.y represent true and false respectively. Then writing if bool then X else Y fi for bool X Y the usual behavior of the conditional is obtained. Now if we represent the natural numbers as a data type in the style of the second representation, we immediately get that the lambda definable functions are closed under minimalization. Indeed, let X(x) = ,uy[g(x,y) = 0], and suppose that g is lambda defined by G. Then there exists a lambda term H such that Hxy = if zero? (Gxy) then y else (Hx(succ y)) fi. Indeed, we can write this as Hx = AxH and apply Proposition 3.6, but now formulated for the inductively defined type num. Then F =_ x.Hx-O-does represent X. Here succ represents the successor function and zero? a test for zero; both are lambda definable, again by the analogon to Proposition 3.6. Since minimalization anables us to define all partial recursive functions, the terms involved cannot be typed in a normalizing system. Self-interpretation. A lambda term M can be represented internally as a lambda term rM1. This representation should be such that, for example, one has lambda terms P1, P2 satisfying PiX XX2 = Xi. [67] already showed that there is a ('meta-circular') self-interpreter E such that, for closed terms M one has Er'M = M. The fact that data types can be represented directly in the lambda calculus was exploited by [85] to find a simpler representation for rM' and E. The difficulty of representing lambda terms internally is that they do not form a first order algebraic data type due to the binding effect of the lambda. [85] solved this problem as follows. Consider the data type with signature const, app, abs where const and abs are unary constructors and app a binary constructor. Let const, app and abs be a representation of these in lambda calculus (according to Definition 3.app rp-r Q; rAx.P' _abs(2x.rp1). Then there exists a self-interpreter E such thatfor all lambda terms M (possibly containing variables) one has ErM-= M. PROOF. By an analogon to Proposition 3.6 there exists a lambda term E ) = Ax.E(zx). Then by an easy induction one can show that ErM' = M for all terms M.-Following the construction of Proposition 3.6 in [24], this term E is given the following very simple form: E ((K,S,C)), where S = Axyz.xz(yz) and C Axyz.x(zy). This is a good improvement over [67] or [6]. See also [7], [9] and [10] for more about self-interpreters. This content downloaded from 130.237.29.138 on Mon, 26 Oct 2015 09:48:18 UTC All use subject to JSTOR Terms and Conditions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>6Church had invited Turing to the United States in the mid 1930's. After his first year it was von Neumann who invited Turing to stay for a second year. See [60]. 7Logical programming languages also have the mentioned advantages. But so far pure logical languages of industrial quality have not been developed. (Prolog is not pure and 2-Prolog, see [87], although pure, is presently a prototype.) 194 This content downloaded from 130.237.29.138 on Mon, 26 Oct 2015 09:48:18 UTC All use subject to JSTOR Terms and ConditionsLambda calculus by itself is not yet a complete model of computation, since an expression M may be evaluated by different so-called reduction strategies that indicate which sub-term of M is evaluated first (see [6, Chapter 12]). By the Church-Rosser theorem this order of evaluation is not important for the final result: the normal form of a lambda term is unique if it exists. But the order of evaluation makes a difference for efficiency (both time and space) and also for the question whether or not a normal form is obtained at all. So called 'eager' functional languages have a reduction strategy that evaluates an expression like FA by first evaluating F and A (in no particular order) to, say, F' _= a. .. a ... a... and A' and then contracting F'A' to ... A' ... A' .... This evaluation strategy has definite advantages for the efficiency of the implementation. The main reason for this is that if A is large, but its normal form A' is small, then it is advantageous both for time and space efficiency to perform the reduction in this order. Indeed, evaluating FA directly to A .A..AA... takes more space and if A is now evaluated twice, it also takes more time.Eager evaluation, however, is not a normalizing reduction strategy in the sense of [6, Chapter 12]. For example, if F = Ax. and A does not have a normal form, then evaluating FA eagerly diverges, while FA = (Ax.I)A = I, if it is evaluated leftmost outermost (roughly 'from left to right'). This kind of reduction is called 'lazy evaluation'.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>and [59] (later rediscovered by [84]), one can automatically find the type (in a certain context) of an untyped but typeable expression. Therefore, the typed versions of functional programming languages are often based on the implicitly typed lambda calculi a la This content downloaded from 130.237.29.138 on Mon, 26 Oct 2015 09:48:18 UTC All use subject to JSTOR Terms and Conditions HENK BARENDREGT Curry. Types also play an important role in making implementations of lazy languages more efficient, see below.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>58] the same mistake was made. 196 This content downloaded from 130.237.29.138 on Mon, 26 Oct 2015 09:48:18 UTC All use subject to JSTOR Terms and Conditions (Quote M)9. Also, LISP has a primitive fixed-point operator 'LABEL'</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>Indeed, if f : A -, A, then Yf is of type A so that both sides of f(Yf) =Yf have type A. Primitives for basic arithmetic operations are also added. With these additions, ML becomes a universal programming language, while 2-&gt; is not (since all its terms are normalizing). The second addition to ML is the 'xa) Quote --Quote a --ra~ and there is no common reduct for these two expressions rla' and ra'. This content downloaded from 130.237.29.138 on Mon, 26 Oct 2015 09:48:18 UTC All use subject to JSTOR Terms and Conditions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>Gandy pointed this out to Turing, who then said: "Ah, this remark is worth 100 pounds a month!" This content downloaded from 130.237.29.138 on Mon, 26 Oct 2015 09:48:18 UTC All use subject to JSTOR Terms and Conditions satisfying (1). This seems to be a good implementation of the continuations and therefore a good way to deal with interactive programs. There is, however, a serious problem. Define M _ Ap.[Write bl Stop p, Write b2 Stop p]. Now consider the evaluation M [In, Out] = [Write bl Stop [In, Out], Write b2 Stop [In, Out]] = [[In, [b, Out]], [In, [b2, Out]]. Now what will happen to the actual output channel: should b1 be added to it, or perhaps b2? The dilemma is caused by the duplication of the I/O channels [In, Out]. One solution is not to explicitly mention the I/O channels, as in the lambda calculus with continuations. This is essentially what happens in the method of monads in the interactive functional programming language Haskell. If one writes something like Main fl o o fn the intended interpretation is (f o ... o fn)[In, Out].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>representing inside the lambda calculus with uniqueness types as many gadgets of the world as one would like, one can write something like F [keyboard, mouse, screen, printer] 202 This content downloaded from 130.237.29.138 on Mon, 26 Oct 2015 09:48:18 UTC All use subject to JSTOR Terms and Conditions THE IMPACT OF THE LAMBDA CALCULUS IN LOGIC AND COMPUTER SCIENCE 203 = [keyboard, mouse, put 3 screen, put 7 printer].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head></head><label></label><figDesc>is 'inhabited' by a proof p. Now a proof of A =X B consists (according to the Brouwer-Heyting interpretation of 13This way of doing mathematics, the axiomatic method, was also described by Aristotle. It was [42] who first used this method very successfully in his Elements. 204 This content downloaded from 130.237.29.138 on Mon, 26 Oct 2015 09:48:18 UTC All use subject to JSTOR Terms and Conditions implication) of a function having as argument a proof of A and as value ] is the Cartesian product of the [Px], because a proof of Vx E A.Px consists of a function that assigns to each element x E A a proof of Px. In this way proof-objects become isomorphic with the intuitionistic natural deduction proofs of [48]. Using this interpretation, a proof of Vy E A.Py =&gt; Py is y :Aix :Py.x. Here Ax :A.B(x) denotes the function that assigns to input x E A the output B(x). A proof of (A = A-B) X A = B is p : (A =x A =&gt; B)lq:A.pqq.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head></head><label></label><figDesc>This content downloaded from 130.237.29.138 on Mon, 26 Oct 2015 09:48:18 UTC All use subject to JSTOR Terms and Conditions the type systems enjoying this interpretation of the Poincare principle still satisfy the de Bruijn criterion14. In spite of the compact representation in typed lambda calculi and the use of the Poincare principle, proof-objects become large, something like 10 to 30 times the length of a complete informal proof. Large proof-objects are tiresome to generate by hand. With the necessary persistence [18] has written lambda after lambda to obtain the proof-objects showing that all proofs (but one) in [76] are correct. Using a modern system for CM one can do better. The user introduces the context consisting of the primitive notions and axioms. Then necessary definitions are given to formulate a theorem to be proved (the goal). The proof is developed in an interactive session with the machine. Thereby the user only needs to give certain 'tactics' to the machine. (The interpretation of these tactics by the machine does nothing mathematically sophisticated, only the necessary bookkeeping. The sophistication comes from giving the right tactics.) The final goal of this research is that the necessary effort to interactively generate formal proofs is not more complicated than producing a text in, say, LATEX. This goal has not been reached yet. See [11] for references, including those about other approaches to computer mathematics. (These include the systems NuPrl, HOL, Otter, Mizar and the Boyer-Moore theorem prover. These systems do not satisfy the de Bruijn criterion, but some of them probably can be modified easily so that they do.) Computations inproofs. The following is taken from [12]. There are several computations that are needed in proofs. This happens, for example, if we want to prove formal versions of the following intuitive statements. handle (1) is to use the Poincare principle extended to the reduction relation -*, for primitive recursion on the natural numbers. Operations like f (n) = [/n] are primitive recursive and hence are lambda definable (using -&gt;,B) by a term, say F, in the lambda calculus extended by an operation for primitive recursion</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>206</head><label></label><figDesc>This content downloaded from 130.237.29.138 on Mon, 26 Oct 2015 09:48:18 UTC All use subject to JSTOR Terms and Conditions THE IMPACT OF THE LAMBDA CALCULUS IN LOGIC AND COMPUTER freely many times. In a similar way, a statement like (2) can be formulated and proved by constructing a lambda defining term Kprime for the characteristic function of the predicate Prime. This term should satisfy the following statement Vn [(Primen &lt;-Kprimen = rl) &amp; (KPrime n = rO' V Krime n = rn)]. which is the proof obligation. Statement (3) corresponds to a symbolic computation. This computation takes place on the syntactic level of formal terms. There is a function g acting on syntactic expressions satisfying g((x + 1)(x + 1)) = x2 + 2x + 1, that we want to lambda define. While x + 1 : Nat (in context x : Nat), the expression on a syntactic level represented internally satisfies 'x + 1' term(Nat), for the suitably defined inductive type term(Nat). After introducing a reduction relation -*, for primitive recursion over this data type, one can use techniques similar to those of ?3 to lambda define g, say by G, so that G'(x + l)(x + 1)' --'xx2 + 2x + 19. Now in order to finish the proof of (3), one needs to construct a selfinterpreter E, such that for all expressions p : Nat one has E'p' --*, p and prove the proof obligation for G which is Vt:term(Nat) E(G t) = Et. This content downloaded from 130.237.29.138 on Mon, 26 Oct 2015 09:48:18 UTC All use subject to JSTOR Terms and Conditions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>208</head><label></label><figDesc>This content downloaded from 130.237.29.138 on Mon, 26 Oct 2015 09:48:18 UTC All use subject to JSTOR Terms and Conditions</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>This content downloaded from 130.237.29.138 on Mon, 26 Oct 2015 09:48:18 UTC All use subject to JSTOR Terms and Conditions</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>This content downloaded from 130.237.29.138 on Mon, 26 Oct 2015 09:48:18 UTC</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>interpretation of ( <ref type="formula">1</ref>) is <ref type="bibr" target="#b2">(3)</ref> (Ax.M)N.</p><p>But this interpretation has its limitations, as N has to be given one fixed type, whereas in (2) the various occurrences of N may have different types. The expression (1) is a way to make use of both the space reduction ('sharing') of the expression (3) and the 'implicit polymorphism' in which N can have more than one type of (2). An example of the let expression is let id be A;x.x in ifx.(id f)(id x) end. <ref type="figure">A -, A) -(A --A)</ref> and<ref type="figure">the third  (A -A</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>This is typeable by (A -t A) -&gt; (A &gt; A), if the second occurrence of id gets type (</head><p>Because of its relatively efficient implementation and the possibility of type checking at compile time (for finding errors), the language ML has evolved into important industrial variants (like Standard ML of New Jersey).</p><p>Although not widely used in industry, a more efficient implementation of ML is based on the abstract machine CAML, see <ref type="bibr" target="#b30">[34]</ref>. CAML was inspired by the categorical foundations of the lambda calculus, see <ref type="bibr" target="#b97">[107]</ref>, <ref type="bibr" target="#b63">[72]</ref> and <ref type="bibr" target="#b31">[35]</ref>. All of these papers have been inspired by the work on denotational semantics of Scott, see <ref type="bibr" target="#b93">[103]</ref> and <ref type="bibr" target="#b47">[54]</ref>.</p><p>Lazy functional languages. Although all computable functions can be represented in an eager functional programming language, not all reductions in the full 2K-calculus can be performed using eager evaluation. We already saw that if F )Ax. I and A does not have a normal form, then eager evaluation of FA does not terminate, while this term does have a normal form. In 'lazy' functional programming languages the reduction of FA to I is possible, because the reduction strategy for these languages is essentially leftmost outermost reduction which is normalizing.</p><p>One of the advantages of having lazy evaluation is that one can work with 'infinite' objects. For example there is a legal expression for the potentially infinite lists of primes Above we explained why eager evaluation can be implemented more efficiently than lazy evaluation: copying large expressions is expensive because of space and time costs. In [119] the idea of graph reduction was introduced in order to also do lazy evaluation efficiently. In this model of computation, an expression like (Ax. .. x... x )A does not reduce to ... A... A .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>purposes, no interaction with the outside world is made. Even just dealing with input and output (I/O) requires interaction.</head><p>We need the concept of a 'process' as opposed to a function. Intuitively a process is something that (in general) is geared towards continuation while a function is geared towards termination. Processes have an input channel on which an input stream (a potentially infinite sequence of tokens) is coming in and an output channel on which an output stream is coming out. A typical process is the control of a traffic light system: it is geared towards continuation, there is an input stream (coming from the pushbuttons for pedestrians) and an output stream (regulating the traffic lights). Text editing is also a process. In fact, even the most simple form of I/O is already a process.</p><p>A primitive way to deal with I/O in a functional language is used in some versions of ML. There is an input stream and an output stream. Suppose one wants to perform the following process P: read the first two numbers x, y of the input stream; put their difference xy onto the output stream. Then one can write in ML the following program write (readread). This is not very satisfactory, since it relies on a fixed order of evaluation of the expression 'readread'.</p><p>A more satisfactory way consists of so-called continuations, see <ref type="bibr">[</ref>  </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Handbook of logic in computer science</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abramsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Gabbay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">S E</forename><surname>Maibaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Background: Computational structures</title>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">W</forename><surname>Ackermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Zum Hilbertschen Aufbau der reellen Zahlen, Mathematische Annalen</title>
		<imprint>
			<biblScope unit="volume">99</biblScope>
			<biblScope unit="page" from="118" to="133" />
			<date type="published" when="1928">1928</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Compiling with continuations</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Appel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Subtyping dependent types, Proceedings of the 11th annual symposium on logic in computer science</title>
		<author>
			<persName><forename type="first">D</forename></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Compagnoni</surname></persName>
		</author>
		<editor>E. Clarke</editor>
		<imprint>
			<date type="published" when="1996-07">July 1996</date>
			<publisher>IEEE Computer Society Press</publisher>
			<biblScope unit="page" from="86" to="97" />
			<pubPlace>New Brunswick, New Jersey</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Can programming be liberatedfrom the von Neuman style?</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Backus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="613" to="641" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">The lambda calculus: its syntax and semantics</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">P</forename><surname>Barendregt</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984">1984</date>
			<pubPlace>North-Holland, Amsterdam</pubPlace>
		</imprint>
	</monogr>
	<note>revised ed.</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Theoretical pearls: Self-interpretation in lambda calculus</title>
	</analytic>
	<monogr>
		<title level="j">Journalof Functional Programming</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="229" to="233" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Lambda calculi with types</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="117" to="309" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Discriminating coded lambda terms, From universal morphisms to megabytes: A Baayen space-odyssey</title>
	</analytic>
	<monogr>
		<title level="m">CWI, Kruislaan 413, 1098 SJ Amsterdam</title>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Apt</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Schrijver</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><forename type="middle">M</forename><surname>Temme</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="141" to="151" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Enumerators of lambda terms are reducing constructively</title>
	</analytic>
	<monogr>
		<title level="j">Annals of Pure and Applied Logic</title>
		<imprint>
			<biblScope unit="volume">73</biblScope>
			<biblScope unit="page" from="39" to="58" />
			<date type="published" when="1090">1995. 1090. 1996</date>
		</imprint>
	</monogr>
	<note>GB Amsterdam</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">P</forename><surname>Barendregt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Barendsen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
	<note>Efficient computations in formal proofs, to appear</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Systems of illative combinatory logic complete forfirst order propositional and predicate calculus</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">P</forename><surname>Barendregt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bunder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Dekkers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="89" to="108" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Conventional and uniqueness typing in graph rewrite systems (extended abstract)</title>
		<author>
			<persName><forename type="first">E</forename><surname>Barendsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E W</forename><surname>Smetsers</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993. 1997</date>
			<biblScope unit="volume">105</biblScope>
			<biblScope unit="page" from="41" to="51" />
		</imprint>
	</monogr>
	<note>Uniqueness typing for functional languages with graph rewriting semantics. to appear in Mathematical Structures in Computer Science</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Beeson</surname></persName>
		</author>
		<title level="m">Foundations of constructive mathematics</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Language in action: Categories, lambdas and dynamic logic</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F A K</forename><surname>Van Benthem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Studies in Logic and the Foundations of Mathematics</title>
		<meeting><address><addrLine>North-Holland, Amsterdam</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">130</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Checking Landau&apos;s &quot;Grundlagen&quot; in the AUTOMATH system</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">S</forename><surname>Van Benthem</surname></persName>
		</author>
		<author>
			<persName><surname>Jutting</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1977">1977</date>
		</imprint>
		<respStmt>
			<orgName>Eindhoven University of Technology</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A self-interpreter of lambda calculus having a normal form</title>
		<author>
			<persName><forename type="first">A</forename><surname>Berarducci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bohm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">702</biblScope>
			<biblScope unit="page" from="85" to="99" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Typed lambda calculi and applications, TLCA&apos;93</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bezem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Groote</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">664</biblScope>
			<date type="published" when="1993">1993</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Berlin and New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">The CUCH as aformal and description language, Annual review in automatic programming</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bohm</surname></persName>
		</author>
		<editor>Richard Goodman</editor>
		<imprint>
			<date type="published" when="1963">1963</date>
			<publisher>Pergamon Press</publisher>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="179" to="197" />
			<pubPlace>Oxford</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Automatic synthesis of typed A-programs on term algebras</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bohm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Berarducci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="135" to="154" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Bohm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Gross</surname></persName>
		</author>
		<title level="m">Introduction to the CUCH, Automata theory</title>
		<editor>
			<persName><forename type="first">E</forename><forename type="middle">R</forename><surname>Caianiello</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1966">1966</date>
			<biblScope unit="page" from="35" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Lambda-definition offunction(al)s by normal forms</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bohm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Piperno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Guerrini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Esop&apos;94 (Berlin</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Sanella</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">788</biblScope>
			<biblScope unit="page" from="135" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P</forename><surname>Ramsay</surname></persName>
		</author>
		<title level="m">The foundations of mathematics and other logical essays, Routledge &amp; Kegan Paul</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Braithwaite</surname></persName>
		</editor>
		<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1960">1960</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The mathematical language A UTOMATH, its usage and some of its extensions, Symposium on automatic demonstration</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">G</forename><surname>De Bruijn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Mathematics</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Laudet</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Lacombe</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Schuetzenberger</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">125</biblScope>
			<biblScope unit="page" from="73" to="100" />
			<date type="published" when="1970">1970</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Berlin and New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">An unsolvable problem of elementary number theory</title>
		<author>
			<persName><forename type="first">A</forename><surname>Church</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">American Journal of Mathematics</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="page" from="354" to="363" />
			<date type="published" when="1936">1936</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A formulation of the simple theory of types</title>
	</analytic>
	<monogr>
		<title level="j">Journal of Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="56" to="68" />
			<date type="published" when="1940">1940</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">The calculi of lambda conversion</title>
		<imprint>
			<date type="published" when="1941">1941</date>
			<publisher>Princeton University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Some properties of conversion</title>
		<author>
			<persName><forename type="first">A</forename><surname>Church</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Rosser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions of the American Mathematical Society</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="472" to="482" />
			<date type="published" when="1936">1936</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Revised report on the algorithmic language Scheme</title>
		<editor>
			<persName><forename type="first">W</forename><surname>Clinger</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Rees</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">IV</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The calculus of constructions</title>
		<author>
			<persName><forename type="first">T</forename><surname>Coquand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Huet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">76</biblScope>
			<biblScope unit="issue">2/3</biblScope>
			<biblScope unit="page" from="95" to="120" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">The categorical abstract machine</title>
		<author>
			<persName><forename type="first">G</forename><surname>Cousineau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-L</forename><surname>Curien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mauny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="173" to="202" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Categorical combinators, sequential algorithms, andfunctionalprogramming</title>
		<author>
			<persName><forename type="first">P-L</forename><surname>Curien</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Research Notes in Theoretical Computer Science</title>
		<imprint>
			<date type="published" when="1986">1986</date>
			<pubPlace>Pitman, London</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Grundlagen der kombinatorischen Logik</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">B</forename><surname>Curry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Functionality in combinatory logic, Proceedings of the National Academy of Science of the USA</title>
		<editor>
			<persName><forename type="first">German</forename></persName>
		</editor>
		<imprint>
			<date type="published" when="1930">1930. 1934</date>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="page" from="584" to="590" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Modified basicfunctionality in combinatory logic</title>
		<imprint>
			<date type="published" when="1969">1969</date>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="83" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Completeness of the propositionsas-types interpretation of intuitionistic logic into illative combinatory logic</title>
		<author>
			<persName><forename type="first">W</forename><surname>Dekkers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bunder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">P</forename><surname>Barendregt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Symbolic Logic</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C J D</forename><surname>Van Eekelen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Plasmeijer</surname></persName>
		</author>
		<title level="m">Functionalprogramming andparallel graph rewriting</title>
		<meeting><address><addrLine>Reading, Massachusetts</addrLine></address></meeting>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">H</forename><surname>Elbers</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
	<note>Personal communication</note>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">The elements, 325 B.C. English translation in [55</title>
		<author>
			<persName><surname>Euclid</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1956">1956</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<author>
			<persName><forename type="first">S</forename><surname>Feferman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">A language and axiomsfor explicit mathematics, Proof theory symposium</title>
		<title level="s">Lecture Notes in Mathematics</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Diller</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><forename type="middle">H</forename><surname>Miiller</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1975">1975</date>
			<biblScope unit="volume">500</biblScope>
			<biblScope unit="page" from="87" to="139" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Erkentniss</forename><surname>Definedness</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="295" to="320" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">T</forename><surname>Gamut</surname></persName>
		</author>
		<title level="m">Logic, language and meaning</title>
		<meeting><address><addrLine>Chicago</addrLine></address></meeting>
		<imprint>
			<publisher>Chicago University Press</publisher>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">Church&apos;s Thesis and principles for mechanisms, The Kleene symposium</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">O</forename><surname>Gandy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1980">1980</date>
			<publisher>North-Holland Publishing Company</publisher>
			<biblScope unit="page" from="123" to="148" />
			<pubPlace>Amsterdam</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Investigations into logical deduction</title>
		<author>
			<persName><forename type="first">G</forename><surname>Gentzen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Untersuchungen iiber das logische Schliessen, Mathematische Zeitschrift</title>
		<imprint>
			<date type="published" when="1935">1969. 1935</date>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="68" to="131" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Linear logic: its syntax and semantics, Advances in linear logic</title>
		<author>
			<persName><forename type="first">J.-Y</forename><surname>Girard</surname></persName>
		</author>
		<ptr target="univ-mrs.fras/pub/girard/Synsem.ps.Z" />
	</analytic>
	<monogr>
		<title level="m">Interpretation fonctionelle et elimination des coupures de l&apos;arithmetique d&apos;ordre superieur</title>
		<title level="s">London Mathematical Society Lecture Note Series</title>
		<editor>
			<persName><forename type="first">J.-Y</forename><surname>Girard</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Lafont</surname></persName>
		</editor>
		<editor>
			<persName><surname>Regnier</surname></persName>
		</editor>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1972">1972. 1995</date>
			<biblScope unit="volume">50</biblScope>
		</imprint>
		<respStmt>
			<orgName>Universite Paris VII</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Proofs and types</title>
		<author>
			<persName><forename type="first">J-Y</forename><surname>Girard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">G A</forename><surname>Lafont</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Taylor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Cambridge Tracts in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<date type="published" when="1989">1989</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Gordon</surname></persName>
		</author>
		<title level="m">Functional programming and Input/Output, Distinguished Dissertations in Computer Science</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<author>
			<persName><forename type="first">K</forename><surname>Grue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Map theory</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="1" to="133" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m" type="main">Semantic domains, Handbook of theoretical computer science</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Gunter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Scott</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">B</biblScope>
			<biblScope unit="page" from="633" to="674" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">The thirteen books of Euclid&apos;s elements</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">L</forename><surname>Heath</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1956">1956</date>
			<publisher>Dover Publications, Inc</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title level="m">From Frege to Gidel: A source book in mathematical logic, 1879-1931</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Van Heijenoort</surname></persName>
		</editor>
		<meeting><address><addrLine>Cambridge, Massachusetts</addrLine></address></meeting>
		<imprint>
			<publisher>Harvard University Press</publisher>
			<date type="published" when="1967">1967</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title level="m" type="main">Functional programming: Application and implementation</title>
		<author>
			<persName><forename type="first">P</forename><surname>Henderson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1980">1980</date>
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Englewood Cliffs, New Jersey</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Grundziige der theoretischen logik</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hilbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Ackermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Die Grundlehren der Mathematischen Wissenschaften in Einzeldars tellungen</title>
		<imprint>
			<publisher>Berlin and New York</publisher>
			<date type="published" when="1928">1928</date>
			<biblScope unit="volume">XXVII</biblScope>
		</imprint>
	</monogr>
	<note>first ed.</note>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">The principal type-scheme of an object in combinatory logic</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hindley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions of the American Mathematical Society</title>
		<imprint>
			<biblScope unit="volume">146</biblScope>
			<biblScope unit="page" from="29" to="60" />
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">The enigma of intelligence, Unwin paperbacks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Hodges</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983">1983</date>
			<pubPlace>London</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">A simple modelfor quotient types, Typed lambda calculi and applications</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hofmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="page" from="216" to="234" />
			<date type="published" when="1977">1977</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Berlin and New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Report on the programming language Haskell: A non-strict, purely functional language (Version 1.2)</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hudak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1" to="R163" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">The design and implementation of programming languages</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J M</forename><surname>Hughes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Computer Journal</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="98" to="107" />
			<date type="published" when="1984">1984. 1989</date>
		</imprint>
		<respStmt>
			<orgName>University of Oxford</orgName>
		</respStmt>
	</monogr>
	<note>Whyfunctionalprogramming matters</note>
</biblStruct>

<biblStruct xml:id="b57">
	<monogr>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">E</forename><surname>Iverson</surname></persName>
		</author>
		<title level="m">A programming language</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Wiley</publisher>
			<date type="published" when="1962">1962</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><surname>Johnsson</surname></persName>
		</author>
		<title level="m">Efficient compilation of lazy evaluation, SIGPLAN Notices</title>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="58" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Lambda-definability and recursiveness</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Kleene</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Duke Mathematical Journal</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="340" to="353" />
			<date type="published" when="1936">1936</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Introduction to metamathematics</title>
	</analytic>
	<monogr>
		<title level="m">The University Series in Higher Mathematics, D. Van Nostrand Comp</title>
		<meeting><address><addrLine>New York, Toronto</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1952">1952</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Reminiscences of logicians, Algebra and logic</title>
	</analytic>
	<monogr>
		<title level="m">Origins of recursive function theory</title>
		<title level="s">Fourteenth summer res. inst.</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">N</forename><surname>Crossley</surname></persName>
		</editor>
		<meeting><address><addrLine>Clayton; Berlin and New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1974">1974. 1975. 1981</date>
			<biblScope unit="volume">450</biblScope>
			<biblScope unit="page" from="52" to="67" />
		</imprint>
	</monogr>
	<note>Austral. Math. Soc., Monash Univ.</note>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">The inconsistency of certain formal logics</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Kleene</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Rosser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Mathematics</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="630" to="636" />
			<date type="published" when="1935">1935</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Models of the lambda calculus</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P J</forename><surname>Koymans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Control</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="306" to="323" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<monogr>
		<title level="m" type="main">Church&apos;s thesis: A kind of reducibility axiom for constructive mathematics</title>
		<author>
			<persName><forename type="first">G</forename><surname>Kreisel</surname></persName>
		</author>
		<imprint>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="page" from="121" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">The formalist-positivist doctrine of mathematical precision in the light of experience</title>
	</analytic>
	<monogr>
		<title level="j">L&apos;age de la Science</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="17" to="46" />
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">An axiomatic theory for partial functions</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kuper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="page" from="104" to="150" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><surname>Landau</surname></persName>
		</author>
		<title level="m">Grundlagen der analysis</title>
		<imprint>
			<publisher>Chelsea Publishing Company</publisher>
			<date type="published" when="1960">1960</date>
		</imprint>
	</monogr>
	<note>third ed.</note>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">The mechanical evaluation of expressions</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Landin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Computer Journal</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="308" to="320" />
			<date type="published" when="1964">1964</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<monogr>
		<title level="m" type="main">Handbook of theoretical computer science</title>
		<editor>J. van Leeuwen</editor>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>MIT-Press</publisher>
			<pubPlace>A, B, North-Holland</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<monogr>
		<title level="m" type="main">Reasoning about functional programs and complexity classes associated with type disciplines, 24th annual symposium on foundations of computer science</title>
		<author>
			<persName><forename type="first">D</forename><surname>Leivant</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983">1983</date>
			<publisher>IEEE</publisher>
			<biblScope unit="page" from="460" to="469" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<monogr>
		<title level="m" type="main">The LEGO proof development system: A user&apos;s manual</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pollack</surname></persName>
		</author>
		<idno>ECS-LFCS-92-211</idno>
		<imprint>
			<date type="published" when="1992-05">may 1992</date>
		</imprint>
		<respStmt>
			<orgName>University of Edinburgh</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b72">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Martin-Lof</surname></persName>
		</author>
		<title level="m">Intuitionistic type theory</title>
		<meeting><address><addrLine>Bibliopolis, Napoli</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
	<note>Studies in Proof Theory</note>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">On recursive unsolvability of hilbert&apos;s tenth problem, Fourth international congress for logic, methodology and philosophy of science</title>
		<author>
			<persName><forename type="middle">V</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><surname>Matijasevic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Studies in Logic and the Foundations of Mathematics</title>
		<meeting><address><addrLine>North-Holland, Amsterdam</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1971">1971</date>
			<biblScope unit="volume">74</biblScope>
			<biblScope unit="page" from="89" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<monogr>
		<title level="m" type="main">Lisp 1.5 programmer&apos;s manual</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mccarthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1962">1962</date>
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, Massachusetts</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">A theory of type polymorphism in programming</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="348" to="375" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">Theoretical pearls: Efficient self-interpretation in lambda calculus</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Ie</forename><surname>Mogensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Functional Programming</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="345" to="364" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Myhill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Vesley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kino</surname></persName>
		</author>
		<title level="m">Intuitionism andproof theory, Studies in Logic and the Foundations of Mathematics</title>
		<meeting><address><addrLine>North-Holland, Amsterdam</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Nadathur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Miller</surname></persName>
		</author>
		<title level="m">An overview of AProlog, Logic programming: Proceedings of the fifth international conference and symposium</title>
		<editor>
			<persName><forename type="first">Robert</forename><forename type="middle">A</forename><surname>Kowalski</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Kenneth</forename><forename type="middle">A</forename><surname>Bowen</surname></persName>
		</editor>
		<meeting><address><addrLine>Cambridge, Massachusetts</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1988-08">August 1988</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="810" to="827" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">Selected papers on automath</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Nederpelt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Geuvers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>De Vrijer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Studies in Logic and the Foundations of Mathematics</title>
		<meeting><address><addrLine>North-Holland, Amsterdam</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">133</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">Eine axiomatisierung der mengenlehre</title>
		<author>
			<persName><forename type="first">J</forename><surname>Neumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal fur die Reine und Angewandte Mathematik</title>
		<imprint>
			<biblScope unit="volume">154</biblScope>
			<biblScope unit="page" from="219" to="240" />
			<date type="published" when="1925">1925</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<monogr>
		<title level="m" type="main">Proof by calculation, Master&apos;s thesis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Oostdijk</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">385</biblScope>
		</imprint>
		<respStmt>
			<orgName>Universitaire School voor Informatica, Catholic University Nijmegen</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<monogr>
		<title level="m" type="main">Inductive definitions in the system Coq; rules and properties, HENK BARENDREGT 1993</title>
		<author>
			<persName><forename type="first">C</forename><surname>Paulin-Mohring</surname></persName>
		</author>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="328" to="345" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<monogr>
		<title level="m" type="main">Imperative functional programming, Conference record of the twentieth annual ACM SIGPLAN-SIGACT symposium on principles of programming languages</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">L</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wadler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">January 10-13, 1992. 1993</date>
			<publisher>ACM Press</publisher>
			<biblScope unit="page" from="71" to="84" />
			<pubPlace>Charleston, South Carolina; English)</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">Call-by-name, call-by-value and the A-calculus</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Plotkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="125" to="159" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Poincare</surname></persName>
		</author>
		<title level="m">La science et l&apos;hypothese, Flammarion</title>
		<meeting><address><addrLine>Paris</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1902">1902</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">The foundations of mathematics</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P</forename><surname>Ramsey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Proceedings of the London Mathematical Society, Series 2</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="338" to="384" />
			<date type="published" when="1925">1925</date>
		</imprint>
	</monogr>
	<note>translated in [25</note>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">Definitional interpreters for higher-order programming languages</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Reynolds</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The discoveries of continuations, LISP and Symbolic Computation</title>
		<meeting><address><addrLine>Boston, Massachusetts</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1972">1972. 1993</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="233" to="247" />
		</imprint>
	</monogr>
	<note>Proceedings of 25th ACM national conference</note>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">The theory of classes-a modification of von Neumann&apos;s system</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Robinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Journal of Symbolic Logic</title>
		<imprint>
			<date type="published" when="1937">1937</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="29" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Rosser</surname></persName>
		</author>
		<title level="m">Highlights of the history of lambda-calculus, ACM symposium on Lisp andfunctionalprogramming (Pennysylvania)</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1982-08">August 1982</date>
			<biblScope unit="page" from="216" to="225" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b90">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A W</forename><surname>Russell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">N</forename><surname>Whitehead</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Principia mathematica</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1910" to="1913" />
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<analytic>
		<title level="a" type="main">Definierbare Funktionen im 2-Kalkiil mit Typen</title>
		<author>
			<persName><forename type="first">H</forename><surname>Schwichtenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Archieffur Mathematische Logik</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="113" to="114" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Constructive validity, Symposium on automated demonstration</title>
		<title level="s">Lecture Notes in Mathematics</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Lacombe</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Laudet</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Schuetzenberger</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1970">1970</date>
			<biblScope unit="volume">125</biblScope>
			<biblScope unit="page" from="237" to="275" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Toposes, algebraic geometry, and logic</title>
		<title level="s">Lecture Notes in Mathematics</title>
		<editor>
			<persName><forename type="first">F</forename><forename type="middle">W</forename><surname>Lawvere</surname></persName>
		</editor>
		<imprint>
			<publisher>Berlin and New York</publisher>
			<date type="published" when="1972">1972</date>
			<biblScope unit="volume">274</biblScope>
			<biblScope unit="page" from="97" to="136" />
		</imprint>
	</monogr>
	<note>Continuous lattices</note>
</biblStruct>

<biblStruct xml:id="b94">
	<analytic>
		<title level="a" type="main">Pure type systems with definitions</title>
		<author>
			<persName><forename type="first">P</forename><surname>Severi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Poll</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of LFCS&apos;94</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Nerode</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Yu</forename><forename type="middle">V</forename><surname>Matijasevic</surname></persName>
		</editor>
		<meeting>LFCS&apos;94<address><addrLine>Berlin and New York; St. Petersburg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">813</biblScope>
			<biblScope unit="page" from="316" to="328" />
		</imprint>
	</monogr>
	<note>LFCS&apos;94</note>
</biblStruct>

<biblStruct xml:id="b95">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th conference on foundations of software technology and theoretical computer science</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Shyamasundar</surname></persName>
		</editor>
		<meeting>the 13th conference on foundations of software technology and theoretical computer science<address><addrLine>Berlin and New York, Bombay, India</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">761</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b96">
	<analytic>
		<title level="a" type="main">Begriindung der elementaren Arithmetik durch die rekurrierende Denkweise ohne Anwendung scheinbarer Verenderlichen mit unendlichem Ausdehnungsbereich, Videnskapsselskapets skrifter, I. Matematisk-naturvidenskabelig klasse</title>
		<author>
			<persName><forename type="first">T</forename><surname>Skolem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">English translation in</title>
		<imprint>
			<date type="published" when="1923">1923</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="302" to="333" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b97">
	<analytic>
		<title level="a" type="main">The category-theoretic solution of recursive domain equations</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Smyth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Plotkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="761" to="783" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b98">
	<analytic>
		<title level="a" type="main">The typed lambda calculus is not elementary recursive</title>
		<author>
			<persName><forename type="first">R</forename><surname>Statman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="73" to="81" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b99">
	<analytic>
		<title level="a" type="main">Rabbit: A compiler for Scheme</title>
		<author>
			<persName><forename type="first">Guy</forename><forename type="middle">L</forename><surname>Steele Jr</surname></persName>
		</author>
		<idno>AI-TR-474</idno>
	</analytic>
	<monogr>
		<title level="m">Common Lisp: The language</title>
		<imprint>
			<publisher>Digital Press</publisher>
			<date type="published" when="1978-05">May 1978. 1984</date>
		</imprint>
		<respStmt>
			<orgName>Artificial Intelligence Laboratory, Massachusetts Institute of Technology, Cambridge, Massachusetts</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b100">
	<monogr>
		<title level="m" type="main">The collected papers of Gerhard Gentzen</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Szabo</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1969">1969</date>
			<pubPlace>North-Holland, Amsterdam</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b101">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Metamathematical investigation of intuitionistic arithmetic and analysis</title>
		<title level="s">Lecture Notes in Mathematics</title>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Troelstra</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin and New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<biblScope unit="volume">344</biblScope>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
