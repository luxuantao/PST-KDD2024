<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Securing SIFT: Privacy-preserving Outsourcing Computation of Feature Extractions over Encrypted Image Data</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Shengshan</forename><surname>Hu</surname></persName>
							<email>hushengshan@whu.edu</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">The State Key Lab of Software Engineering</orgName>
								<orgName type="department" key="dep2">School of Computer Science</orgName>
								<orgName type="institution">Wuhan University</orgName>
								<address>
									<postCode>430072</postCode>
									<settlement>Wuhan</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">The State University of New York at Buffalo</orgName>
								<address>
									<postCode>14260</postCode>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Qian</forename><surname>Wang</surname></persName>
							<email>qianwang@whu.edu</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">The State Key Lab of Software Engineering</orgName>
								<orgName type="department" key="dep2">School of Computer Science</orgName>
								<orgName type="institution">Wuhan University</orgName>
								<address>
									<postCode>430072</postCode>
									<settlement>Wuhan</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">The State University of New York at Buffalo</orgName>
								<address>
									<postCode>14260</postCode>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jingjun</forename><surname>Wang</surname></persName>
							<email>jingjun@whu.edu</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">The State Key Lab of Software Engineering</orgName>
								<orgName type="department" key="dep2">School of Computer Science</orgName>
								<orgName type="institution">Wuhan University</orgName>
								<address>
									<postCode>430072</postCode>
									<settlement>Wuhan</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">The State University of New York at Buffalo</orgName>
								<address>
									<postCode>14260</postCode>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Zhan</forename><surname>Qin</surname></persName>
							<email>zhanqin@buffalo.edu</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">The State Key Lab of Software Engineering</orgName>
								<orgName type="department" key="dep2">School of Computer Science</orgName>
								<orgName type="institution">Wuhan University</orgName>
								<address>
									<postCode>430072</postCode>
									<settlement>Wuhan</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><roleName>Fellow, IEEE</roleName><forename type="first">Kui</forename><surname>Ren</surname></persName>
							<email>kuiren@buffalo.edu</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">The State Key Lab of Software Engineering</orgName>
								<orgName type="department" key="dep2">School of Computer Science</orgName>
								<orgName type="institution">Wuhan University</orgName>
								<address>
									<postCode>430072</postCode>
									<settlement>Wuhan</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Securing SIFT: Privacy-preserving Outsourcing Computation of Feature Extractions over Encrypted Image Data</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8FCCED1F14B5302D25EE7F12F2B59BBB</idno>
					<idno type="DOI">10.1109/TIP.2016.2568460</idno>
					<note type="submission">This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIP.2016.2568460, IEEE Transactions on Image Processing This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIP.2016.2568460, IEEE Transactions on Image Processing</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:58+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Scale-invariant feature transform</term>
					<term>privacypreserving</term>
					<term>security</term>
					<term>homomorphic encryption</term>
					<term>cloud computing</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Advances in cloud computing have greatly motivated data owners to outsource their huge amount of personal multimedia data and/or computationally expensive tasks onto the cloud by leveraging its abundant resources for cost saving and flexibility. Despite the tremendous benefits, the outsourced multimedia data and its originated applications may reveal the data owner's private information, such as the personal identity, locations or even financial profiles. This observation has recently aroused new research interest on privacy-preserving computations over outsourced multimedia data. In this paper, we propose an effective and practical privacy-preserving computation outsourcing protocol for the prevailing scale-invariant feature transform (SIFT) over massive encrypted image data. We first show that previous solutions to this problem have either efficiency/security or practicality issues, and none can well preserve the important characteristics of the original SIFT in terms of distinctiveness and robustness. We then present a new scheme design that achieves efficiency and security requirements simultaneously with the preservation of its key characteristics, by randomly splitting the original image data, designing two novel efficient protocols for secure multiplication and comparison, and carefully distributing the feature extraction computations onto two independent cloud servers. We both carefully analyze and extensively evaluate the security and effectiveness of our design. The results show that our solution is practically secure, outperforms the state-of-theart, and performs comparably to the original SIFT in terms of various characteristics, including rotation invariance, image scale invariance, robust matching across affine distortion, addition of noise and change in 3D viewpoint and illumination.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>trust domains the data owner and the cloud belong to <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>. More specifically, popular social network providers like Facebook and Flickr commonly exploit the outsourced personal image data to conduct behavioral advertising and preference analytics for improving user experience. To do this, instead of directly working on the massive data sets, they extract image features as inputs to well-defined data mining models. On the other side, from the data owner's perspective, to relieve the heavy computation workload in image feature extraction and utilization on the "Big Data" (e.g., massive satellite images) for building versatile user-defined applications such as similarity search indexes, more and more users are inclined to outsource the computation of image feature extractions to the cloud. Obviously, the expose of original image data to the semi-trusted cloud service provider may inevitably reveal the data owner's private information, such as the personal identity, locations or even financial profiles etc. To provide privacy guarantees for sensitive data, a straightforward approach is to encrypt the sensitive multimedia data locally before outsourcing. While providing strong end-to-end privacy, encryption also becomes a hindrance to data computation or utilization. Now the challenging problem is how to enable privacy-preserving image feature extractions over massive image data while apparently relieving the database owner of its high computation burden and relying on the cloud for providing fast and effective image feature extraction services.</p><p>In the existing literature, efforts on privacy-preserving outsourcing computation have been devoted to various mathematical problems including modular exponentiation <ref type="bibr" target="#b5">[6]</ref>, linear equations <ref type="bibr" target="#b6">[7]</ref> and kNN search <ref type="bibr" target="#b7">[8]</ref>. These works mainly focus on engineering computation problems over numerical data or text data. Only in recent years, privacy-preserving data search in the ciphertext domain has been extended to content-based multimedia retrieval <ref type="bibr" target="#b8">[9]</ref>, face recognition <ref type="bibr" target="#b9">[10]</ref> and fingerprint identification <ref type="bibr" target="#b10">[11]</ref>. The authors in <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b12">[13]</ref> explored how to enable secure image search in the data outsourcing environment. Nevertheless, they all assume that the images have been pre-processed by some feature extraction algorithms to obtain their vector representations. Due to the importance of image feature extraction in multimedia data processing and its heavy operations on massive data, especially for satellite data for its tremendous size and large number of feature points, the extraction or detection of image features from the ciphertext domain has began to attract more and more research interest.</p><p>To the best of our knowledge, Hsu et al. <ref type="bibr" target="#b13">[14]</ref> was the first to investigate privacy-preserving SIFT in the encrypted domain by utilizing homomorphic encryption Paillier <ref type="bibr" target="#b14">[15]</ref>. However, their solution is either computationally intractable, or otherwise insecure from the privacy perspective <ref type="bibr" target="#b15">[16]</ref>. As a following work, Qin et al. <ref type="bibr" target="#b16">[17]</ref> presented an improved scheme with the aid of order preserving encryption <ref type="bibr" target="#b17">[18]</ref> and random permutation. In <ref type="bibr" target="#b18">[19]</ref>, Wang et al. considered the problem of secure and private outsourcing of shape-based feature extraction and proposed two approaches with different levels of security by using homomorphic encryption and the garbled circuit protocol <ref type="bibr" target="#b19">[20]</ref>, respectively. While putting great effort on the privacy or efficiency aspect, one common limitation of the previous solutions is that they all lack comprehensive analysis and evaluations with respect to the preservation of the key characteristics of the original image feature extraction algorithm. Recently, we proposed a new scheme <ref type="bibr" target="#b0">[1]</ref> to address this problem with the aid of garbled circuits <ref type="bibr" target="#b19">[20]</ref>. Although this solution has a good preservation of key characteristics of SIFT, there is still room to further reduce its computation and communication costs. More importantly, it is still unable to eliminate edge responses such that the detected keypoints are unstable to small amount noise. Motivated by the above observations, in this paper, we propose an effective and practical privacy-preserving computation outsourcing protocol for the prevailing scale-invariant feature transform (SIFT) over massive encrypted image data. In our design, we first additively and randomly split the image into two shares and distribute them to two semi-honest non-colluding cloud servers. Then we design two secure interactive protocols-batched secure multiplication protocol (BSMP) and batched secure comparison protocol (BSCP) based on somewhat homomorphic encryption (SHE) integrated with the latest batching technique single-instruction multi-data (SIMD). The former one allows the two servers to securely compute the products of multiple pairs of their private inputs simultaneously, while the latter one enables them to compare multiple pairs of private inputs at one time with privacy preservation. Based on the two interactive protocols, we then further develop a new approach to let the two servers collaboratively detect real locations of stable keypoints via the difference-of-Gaussian (DoG) scale space built on encrypted image, and main orientations through computing the orientation range instead of their specific values from the encrypted versions of orientation histogram. Finally, by exploiting the additive property of the encrypted image, the data owner can recover the real feature descriptors from the encrypted descriptors generated by the two servers while preventing them from seeing any information about the original image. Our main contributions can be summarized as follows.</p><p>• We design two novel secure interactive protocols BSMP and BSCP that enable the two servers to compute the products and make comparisons of multiple pairs of integers simultaneously with privacy preservation by using somewhat homomorphic encryption (SHE) and the batching technique SIMD. • We for the first time propose a new and effective privacypreserving outsourcing protocol for SIFT with the preservation of its key characteristics, by randomly splitting </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. PROBLEM STATEMENT A. System Model</head><p>In our work, we consider a cloud-based image feature extraction outsourcing computation system involving three parties: the data owner O, the cloud server S 1 , the cloud server S 2 (as illustrated in Fig. <ref type="figure" target="#fig_0">1</ref>). In this application scenario, we assume that the data owner O holding a large volume of sensitive image files (e.g., satellite images that are usually of extremely large size and each has plenty of keypoints) is resource-constrained. Thus, O would like to outsource both the image data set and the computation-intensive SIFT task to the cloud by leveraging its abundant storage and computation resources. We assume S 1 and S 2 are independent with each other and can be considered to belong to two independent cloud service providers like Amazon EC2 and Microsoft Azure. To protect the privacy, O will first encrypt each image set and then distribute the ciphertexts to S 1 and S 2 . After running SIFT algorithm in the ciphertext domain via a sequence of secure interaction protocols, S 1 and S 2 will return the encrypted feature descriptors to the data owner, who can eventually recover the real feature descriptors from their encrypted versions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Threat Model</head><p>As discussed above, S 1 and S 2 are assumed to be two independent or say non-colluding servers. Note that, as shown in <ref type="bibr" target="#b16">[17]</ref>, delegating all image feature extraction tasks to only one cloud entity will obviously lead to the leakage of pixel values of an image. Hence, it is necessary to have at least two independent entities for achieving privacy-preserving image feature extraction outsourcing. To this end, three independent servers are strictly required in <ref type="bibr" target="#b16">[17]</ref> while our protocol is implemented with only two ones, which is easier to deploy in practice. We emphasize that this non-colluding assumption can be promised in practice because the cloud service providers have to maintain their reputation and take their own financial interests into account.</p><p>Following all existing privacy-preserving data/computation outsourcing protocols <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b18">[19]</ref>, <ref type="bibr" target="#b16">[17]</ref>, we also assume the cloud is semi-trusted (which can be seen as the adversary in our application scenario), i.e., S 1 and S 2 will execute the protocol as specified but may try to learn additional private information from the encrypted image data and all the intermediate results generated during the protocol execution. In addition, instead of knowing the pixels' specific values, the adversary may try to deduce the image content by leveraging i) revealed relationships between pixels (e.g., keypoint locations) and/or ii) encrypted feature descriptors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. BACKGROUND</head><p>Before elaborating our solutions, we will first give a brief overview of the Scale-invariant feature transform (SIFT) algorithm to make the paper self-contained. Then we will discuss the cryptographic tools used as building blocks to construct our privacy-preserving protocol for SIFT outsourcing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Scale-invariant feature transform (SIFT)</head><p>In the area of computer vision and pattern recognition, scale-invariant feature transform (SIFT) is an important feature extraction algorithm that has been widely used due to its distinctiveness and robust matching across a substantial range of affine distortion, addition of noise, and change in illumination <ref type="bibr" target="#b20">[21]</ref>. According to SIFT <ref type="bibr" target="#b20">[21]</ref>, image features are extracted by the following three stages: Keypoint localization. For an initial image I, a differenceof-Gaussian scale space is built by convolving I with a difference-of-Gaussian (DoG) function as</p><formula xml:id="formula_0">D(x, y, σ) =(G(x, y, kσ) -G(x, y, σ)) * I(x, y) =L(x, y, kσ) -L(x, y, σ),<label>(1)</label></formula><p>where L(x, y, σ) = G(x, y, σ) * I(x, y) is the smoothed image and * is the convolution operation in x and y. In order to detect the local extrema of D(x, y, σ), each sample point is compared to its 26 neighbors in the current and adjacent scales.</p><p>If it is larger or smaller than all of them, it will be selected as a candidate keypoint. Then each candidate keypoint will be filtered to eliminate edge responses such that the final detected keypoints are stable. Orientation assignment. One or more orientations will be assigned to each keypoint based on the local image gradient direction. In this way, the keypoint can be represented relative to its orientation and therefore achieve invariance to image rotation. Specifically, for the Gaussian smoothed image L(x, y) that a keypoint lies in, if we denote Diff x = L(x + 1, y) -L(x -1, y), Diff y = L(x, y + 1) -L(x, y -1), the gradient magnitude m(x, y) and orientation θ are computed as m(x, y) = Diff 2 x + Diff 2 y and θ(x, y) = tan -1 Diffy Diffx . Then, an orientation histogram H with 36 bins covering 360-degree range is formed from the gradient orientations of sample points within a region around the keypoint. Each sample added to the histogram is weighted by its gradient magnitude and by a Gaussian-weighted circular window. Finally, the highest peak in the histogram is detected and any other local peaks that are within the 80% of the highest peak are also used to create a keypoint with that orientation. Keypoint descriptor. After being rotated relative to the keypoint orientation, a keypoint descriptor is created by computing the gradient magnitude and the orientation for each sample point in a region around the keypoint. These samples are weighted by a Gaussian window and then accumulated into an orientation histogram with 8 bins covering 360-degree range over 4×4 subregions. Finally, a 128-dimensional feature descriptor is formed by using a vector to represent its 16 histograms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Cryptographic Tools</head><p>Homomorphic encryption is a public-key encryption scheme that supports meaningful operations over the encrypted data. In particular, somewhat homomorphic encryption (SHE) is such a scheme that enables a limited number of both addition and multiplication operations on the ciphertexts. For our privacypreserving outsourcing computation system, we propose to use a ring-LWE-based homomorphic cryptosystem <ref type="bibr" target="#b21">[22]</ref>. This scheme is parametrized by the ring R q Z q [x]/ x n + 1 , where n is a power of two, an odd prime number q, and an error parameter σ that defines a discrete Gaussian error distribution χ = D Z n ,σ with standard deviation σ. The message space of the scheme is defined by a prime t as R t Z t [x]/ x n + 1 . We use the tuple (SH.Gen, SH.Enc, SH.Dec) to represent the key generation, the encryption and the decryption procedures in a SHE scheme, respectively. SH.Gen: Sample a ring element s ← χ and define the secret key sk s. Sample a uniformly random ring element a 1 ← R q and an error e ← χ and compute the public key pk (a 0 = -(a 1 s + te), a 1 ). SH.Enc(m, pk): Given pk = (a 0 , a 1 ) and a message m ∈ R t , the encryption algorithm samples u ← χ, and f, g ← χ, and compute the ciphertext ct = (c 0 , c 1 ) (a 0 u + tg + m, a 1 u + tf ). SH.Dec(ct, sk): To decrypt ct = (c 0 , c 1 , . . . , c δ ), compute m = δ i=0 c i s i . Output the message as m mod t. The reader may refer to <ref type="bibr" target="#b21">[22]</ref>, <ref type="bibr" target="#b22">[23]</ref> for more detailed parameter analysis and cryptosystem construction.</p><p>One of the most appealing advantages of SHE is that the batching technique: single-instruction multiple-data (SIMD) of <ref type="bibr" target="#b23">[24]</ref> can be used to reduce the communication cost and speed up the computation on ciphertexts when solving problems on a large scale <ref type="bibr" target="#b24">[25]</ref>. SIMD enables one to pack l different plaintext elements (where l is typically in the range of 500 ∼ 10000) in a single ciphertext and thus the same operation on these elements (also called plaintext slots) can be computed in parallel. Formally, following <ref type="bibr" target="#b23">[24]</ref> we let Γ l denote the SIMD-type isomorphism mapping that can pack l integers into a single one, and let Γ -1 l denote the inverse mapping correspondingly. We also use ⊕ and ⊗ to denote homomorphic addition and multiplication on the ciphertexts respectively. Then for two l-dimensional integer vectors x = (x 1 , x 2 , . . . , x l ) and y = (y 1 , y 2 , . . . , y l ), the SIMD-type homomorphic operations can be expressed as</p><formula xml:id="formula_1">SH.Enc(Γ l (x 1 + y 1 , x 2 + y 2 , . . . , x n + y n )) = SH.Enc(Γ l (x 1 , x 2 , . . . , x l )) ⊕ SH.Enc(Γ l (y 1 , y 2 , . . . , y l )); SH.Enc(Γ l (x 1 × y 1 , x 2 × y 2 , . . . , x n × y n )) = SH.Enc(Γ l (x 1 , x 2 , . . . , x l )) ⊗ SH.Enc(Γ l (y 1 , y 2 , . . . , y l )).</formula><p>It clearly shows that a single encryption is sufficient to encode the vector, i.e., a single homomorphic operation on the ciphertexts applies the homomorphic operation componentwise on the entire vector. Readers may refer to <ref type="bibr" target="#b24">[25]</ref> for detailed constructions and security proof of the SHE scheme and the SIMD mapping.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. PRIVACY-PRESERVING OUTSOURCING OF SIFT: AN EXAMINATION OF THE STATE-OF-THE-ART</head><p>In this section, we provide a detailed analysis of two most closely-related works, which reflects the most recent research progress and results in privacy-preserving outsourcing of SIFT algorithm. A careful analysis of these solutions (in terms of security/efficiency and the effectiveness of outsourcing in preservation of original SIFT's key characteristics) motivates us to seek a new solution.</p><p>1) HE-SIFT in <ref type="bibr" target="#b13">[14]</ref>: Hsu et al. <ref type="bibr" target="#b13">[14]</ref> was the first to investigate the problem of secure SIFT outsourcing and proposed a solution that enables the cloud server to run SIFT algorithm in the encrypted domain. Their main idea is to encrypt the initial image by using Paillier cryptosystem <ref type="bibr" target="#b14">[15]</ref>, which provides additive homomorphism and plaintext multiplication. By leveraging the above two properties, all the operations of original SIFT, including common addition, multiplication and comparison, can be done over ciphertexts. However, a careful analysis of this solution shows that their scheme has two main limitations that make it inapplicable to real-world applications as first pointed out by <ref type="bibr" target="#b15">[16]</ref>.</p><p>First, it introduces a very large computation complexity on the encrypted data comparison. In the comparison protocol of <ref type="bibr" target="#b13">[14]</ref>, each comparison needs to traverse half of the plaintext space between any two thresholds (Note that the plaintexts and thresholds are transformed to or chosen as integers due to the use of Paillier cryptosystem). Take the following application scenario as an example: assuming that 10 thresholds are chosen and the secret keys p and q are 1000-bit primes (to ensure the security of the Paillier cryptosystem), the plaintext space Z N (N = pq) has about 2 2000 elements, and thus it will require 2 2000 /(2 × 10) &gt; 2 1995 comparison operations. Apparently, it puts an intolerable computation effort on the cloud. Besides, as the user needs to encrypt and decrypt each pixel in the image, by using a local machine with an Intel Xeon CPU running at 2.0GHz and a memory of 4GB, each encryption will cost at least 0.07 seconds for a 1024-bit modulus of the Paillier cryptosystem. For an image of size 300 × 300 pixels, the total encryption time will be about 105 minutes. So, it also puts huge intolerable workload on the data owner, who only has limited computation resource. On the other hand, if the complexity of the comparison protocol is reduced by choosing a smaller plaintext domain, the security will be broken. For example, if the secret keys p and q are 16-bit primes, then the plaintext space will have 2 32 elements which makes the comparison protocol computationally feasible. However, due to the small sizes of p and q, it can factor N and break the whole system by successfully launching a brute-force attack.</p><p>Second, the content of the image can be deduced by the cloud server. This is because the server has the ability to compare two arbitrary ciphertexts by the proposed comparison strategy. Thus, it can order all the pixels and then traverse all the possible values in the range [0, 255] (assuming that each pixel has 8 bits) to recover the image content. For an image of size n × n, it has n 2 elements in total. A quick sorting algorithm has time complexity O(n 2 log n 2 ) and the traversing step is only O(n 2 ). For the cloud server, the time complexity of launching this attack is polynomial-time.</p><p>2) Privacy-Preserving Outsourcing of SIFT in <ref type="bibr" target="#b16">[17]</ref>: As a following work, Qin et al. <ref type="bibr" target="#b16">[17]</ref> proposed a new and efficient secure SIFT outsourcing protocol. The authors argued that the locations of keypoints are protected from revealing to the cloud. However, we show that this is not true and it violates their security statements. In <ref type="bibr" target="#b16">[17]</ref>, to protect the locations of keypoints, it generates a set of dummy keypoints and mixes them with the real ones. To measure its security level, a probability bound that the adversary can choose a real keypoint from the mixed keypoint group is given, i.e., P = |r| |r|+|d| , where |r| denotes number of real keypoints and |d| denotes number of dummy keypoints. In practice, the maximum value of |d| is about 100 times larger than the value of |r|, which leads to P ≈ 1%. For an typical image of size 400 × 400 pixels, about 2000 keypoints will be generated, but the number of dummy keypoints is certainly less than the number of total pixels in the image, say about 160000. Thus, the probability P is approximately 2000 2000+160000 ≈ 1.2%. Strictly speaking, however, this probability is non-negligible at all! That implies that the cloud still has a good probability of finding the real locations of keypoints.</p><p>In addition to the above limitations, the most serious problem with both of the two schemes is that their protocol designs accidentally destroy the robustness and distinctiveness of original SIFT, whose original steps are intentionally modified in order to operate over the ciphertexts. As described in Section III, in the original SIFT algorithm, each keypoint is assigned with the image location, the scale and the orientation to provide invariance to these parameters, and the computation of the keypoint descriptor within a local region of the image makes it highly distinctive. In fact, these properties explain why SIFT outperforms other feature extraction methods and prevails in object recognition. In <ref type="bibr" target="#b13">[14]</ref> and <ref type="bibr" target="#b16">[17]</ref>, however, the authors have both removed the edge response eliminating step in stage 1 (Keypoint localization) and the orientation assignment in the stage 2 (Orientation assignment). Moveover, they created descriptors without sampling in a region in the stage 3 (Keypoint descriptor generation). These modifications make their systems unable to work well in image matching, as will be shown by our experimental results in Section IX.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. PRIVACY-PRESERVING OUTSOURCING OF SIFT: SYSTEM OVERVIEW</head><p>In this work, our ultimate goal is to enable privacypreserving SIFT outsourcing computation while preserving all its key characteristics as much as possbile. To this end, we have the following specific design goals. Security Constraint: The privacy of the original image content should be protected as much as possible from the adversary. Effectiveness Constraint: The extracted feature vectors performed by outsourced SIFT algorithm should be close to the results from original SIFT algorithm as much as possible. Meanwhile, these feature vectors should preserve important properties embedded in the original SIFT algorithm. Efficiency Constraint: The local computations done by the data owner should be substantially reduced compared with performing SIFT algorithm on his own. The computation burden on the cloud servers should be acceptable considering their ability.</p><p>To give a better demonstration, we will first provide a system overview of our proposed scheme as illustrated in Fig. <ref type="figure" target="#fig_2">2</ref>(a) while presenting the detail constructions for each stage in section VII. Image Encryption: The data owner O, who holds a private image I, encrypts it and sends the encrypted sub-images I 1 and I 2 to servers S 1 and S 2 , respectively. Then, S i builds their own Gaussian scale spaces L i (x, y, σ) and difference-of-Gaussian spaces D i (x, y, σ) based on I i (i = 1, 2). Keypoint Localization: S 1 and S 2 run a keypoint localization protocol based on BSCP to find the candidate keypoint locations without compromising the privacy of their own inputs. Then they will eliminate edge responses to obtain stable keypoints with the aid of BSMP. Finally, the locations are revealed to the two servers. Orientation Assignment: S 1 and S 2 run an orientation assignment protocol based on BSCP. By using the orientations of each sample point around the keypoint (computed in Step 1), they will further build their orientation histograms H 1 and H 2 , respectively. Then, the peaks are found in the original orientation histograms H by using H 1 and H 2 , and each peak corresponds to a main orientation (computed in Step 2). Finally, the image data will be rotated relative to the main orientations, and each rotation generates a feature descriptor for a keypoint. Descriptor Generation: S 1 and S 2 build orientation histograms with the directions that have been computed in the above steps without interacting with each other. Then, they respectively transform the orientation histograms into encrypted feature descriptors V 1 and V 2 and send them to the data owner. This phase is called Descriptor Generation</p><formula xml:id="formula_2">Algorithm 1 Batched Secure Multiplication Protocol Require: S 1 has private data x = (x 1 , x 2 , • • • , x N ) ∈ Z N p ; S 2 has private data y = (y 1 , y 2 , • • • , y N ) ∈ Z N p . Ensure: S 1 obtains s = (s 1 , s 2 , • • • , s N ); S 2 obtains r = (r 1 , r 2 , • • • , r N ).</formula><p>At S 1 : 1) Generate a private and public key pair (pk,sk), number l that plaintexts can be packed and then compute d</p><formula xml:id="formula_3">= N l ; 2) for j = 0, 1, • • • , d -1 do c j = SH.Enc(Γ l (x lj+1 , x lj+2 , • • • , x lj+l ), pk); end for 3) Send ciphertexts (c 0 , c 1 , • • • , c d-1 ) and parameters pk, d, l to S 2 . At S 2 : 1) Randomly generate (r 1 , r 2 , • • • , r N ) ∈ Z N p ; 2) Generate T = SH.Enc(Γ l (-1, -1, . . . , -1), pk); 3) for j = 0, 1, • • • , d -1 do t j = c j ⊗ SH.Enc(Γ l (y lj+1 , y lj+2 , • • • , y lj+l ), pk); k j = T ⊗SH.Enc(Γ l (r lj+1 , r lj+2 , • • • , r lj+l ), pk); c j = t j ⊕ k j ; end for 4) Send (c 0 , c 1 , • • • , c d-1 ) to the S 1 . At S 1 : 1) for j = 0, 1, • • • , d -1 do (s lj+1 , s lj+2 , • • • , s lj+l ) = Γ -1 l (SH.Dec(c j )); end for return s = (s 1 , s 2 , • • • , s N ), r = (r 1 , r 2 , • • • , r N ).</formula><p>Protocol. Finally, the data owner can recover the real feature descriptors from V 1 and V 2 .</p><p>In this work, our key idea is to employ two servers to simulate SIFT algorithm by using I 1 and I 2 , such that the final results equal as much as possible to performing SIFT on the original image I, while the two servers learn nothing about it. Therefore, each interaction between S 1 and S 2 is particularly designed to ensure that the returned results well approximate the outputs generated by the original SIFT. This is explicitly shown in our effectiveness analysis in Section VIII-A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. OUR PROPOSED BASIC SECURITY PRIMITIVES</head><p>Before elaborating our scheme, we first present two novel protocols that will be used as sub-routines in our privacypreserving outsourcing scheme for SIFT. The two newly proposed protocols are designed based on SHE integrated with SIMD which are shown to outperform the existing methods in efficiency in terms of both computation and communication overhead. This will be explicitly illustrated in our experiments in section IX.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Batched Secure Multiplication Protocol</head><p>We propose a new protocol for secure multiplication between two parties, the goal of which is that each party obtains a random share of the product of their private inputs.  Specifically, for the two servers S 1 and S 2 who own private k-bit length integer x 1 and y 1 respectively, where x 1 , y 1 ∈ Z p and p is a pre-defined parameter that determines the plaintext space, after executing the protocol, S 1 receives a uniformly distributed random value s 1 ∈ Z p and S 2 receives a dependent uniformly distributed random value r 1 ∈ Z p such that s 1 +r 1 = x 1 ×y 1 (mod p). During this protocol, no information regarding x 1 and y 1 is revealed to the other party.</p><p>Different from the existing scheme proposed in <ref type="bibr" target="#b25">[26]</ref> where the homomorphic cryptosystem Paillier <ref type="bibr" target="#b14">[15]</ref> is adopted to encrypt private messages, our batched secure multiplication protocol (BSMP) is built on SHE as described above that enables the two parties to securely compute the products of multiple pairs of private integers simultaneously, with computation and communication costs greatly reduced. Namely, for two N -dimensional integer vectors x = (x 1 , x 2 , . . . , x N ) and y = (y 1 , y 2 , . . . , y N ) owned by S 1 and S 2 respectively, the outputs of BSMP will be s = (s 1 , s 2 , . . . , s N ) and r = (r 1 , r 2 , . . . , r N ) such that s i + r i = x i × y i (mod p) for 1 ≤ i ≤ N . Since we only consider 8-bit length inputs and p is unique and usually set to be more than 16bits in length, the bit length of intermediate results are much less than p. Thus we will drop this modulo p operations in the following context for ease of exposition. At the beginning of BSMP, S 1 will first encrypt x by using SIMD in a packing manner. Here for simplicity, we assume that N is a multiple of l. If not, we can append enough 0's to x to achieve this goal. Then S 1 sends the encrypted version of x to S 2 , who will then multiply it with y by utilizing the homomorphic properties. Finally, S 2 will blind the multiplication result with randomly-generated numbers and send it to S 1 for decryption. The explicit steps of the protocol BSMP are depicted in Alg. 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Batched Secure Comparison Protocol</head><p>Here we propose a new protocol for secure comparison that enables two servers to compare two integers without revealing the privacy of their own inputs. Compared with the very general secure comparison protocol garbled circuit <ref type="bibr" target="#b19">[20]</ref>, our subsequent experiments will show that our proposed scheme performs much better in efficiency.</p><p>The key idea of our comparison protocol is motivated by <ref type="bibr" target="#b26">[27]</ref>, where a secure comparison protocol is proposed based on the secure scalar product protocol (SPP) proposed in <ref type="bibr" target="#b25">[26]</ref>. However, different from their design, we use SHE combined with SIMD to construct a batched secure comparison protocol (BSCP) instead of using SPP. As a result, we are able to compare multiple pairs of integers at one time with privacy preservation guarantee and substantial communication and computation overhead reduction.</p><p>Specifically, if we want to securely compare two k-bit length integers x, y ∈ Z p , whose binary representations are</p><formula xml:id="formula_4">x k x k-1 • • • x 1 and y k y k-1 • • • y 1 , respectively. Then, for i = k, k -1, • • • , 1 we compute a i and b i as follows • If i = k, then a i = x i × (1 -y i ), b i = y i × (1 -x i ); • If i &lt; k, then a i = (1 -b i+1 ) × (a i+1 + (1 -a i+1 ) × x i × (1 -y i )), b i = (1 -a i+1 ) × (b i+1 + (1 -a i+1 ) × y i × (1 -x i )).</formula><p>If the final result a 1 (b 1 ) equals 1, we claim that x is greater (smaller) than y. Based on this result, S 1 will first conduct bitwise encryption of x and send the ciphertexts to S 2 . Here we also assume that the total number of integers N is a multiple of the batched number l for ease of representation as did in BSMP. Then S 2 will compute the above equations over ciphertexts based on the homomorphic properties. After k iterations, S 2 obtains the final encrypted results, and sends them to S 1 for decryption to get the final results in plaintext form. The explicit steps are presented in Alg. 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. PRIVACY-PRESERVING OUTSOURCING OF SIFT: OUR CONSTRUCTION</head><p>In this section, we will describe each protocol explicitly shown in the Fig. <ref type="figure" target="#fig_2">2(a)</ref>. Each step is carefully designed to satisfy the three constraints mentioned above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Image Encryption</head><p>For an original image I with size of n×n pixels, we use the matrix I(x, y) (0 x, y &lt; n) with each entry of 8-bit length. The data owner randomly selects n 2 integers from [0, 255] to generate a random matrix I 2 (x, y) and then encrypts I(x, y) by computing I 1 (x, y) as: I 1 (x, y) = I(x, y) + I 2 (x, y). The ciphertexts I 1 and I 2 are sent to S 1 and S 2 , respectively. Note that each element of the matrix I 1 (x, y) will be represented with 9 bits due to the potential overflow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 2 Batched Secure Comparison Protocol</head><p>Require: S 1 has private N -dimensional integer vector x = (x 1 , x 2 , . . . , x N ) ∈ Z N p , where x j 's binary representation is</p><formula xml:id="formula_5">x k j x k-1 j • • • x 1 j</formula><p>. S 2 has private N -dimensional integer vector y = (y 1 , y 2 , . . . , y N ) ∈ Z N p , where y j 's binary representation is y k j y k-1 j • • • y 1 j . Ensure: The public binary vector z = (z 1 , z 2 , . . . , z N ), where z j = 1 iff x j &gt; y j . At S 1 :</p><p>1) Generate a private key and public key pair (pk,sk) and the number l. Compute d = N l ; At S 1 :</p><p>1)</p><formula xml:id="formula_6">for i = k, k -1, • • • , 1 do for j = 0, 1, • • • , d -1 do c i j = SH.Enc(Γ l (x i lj+1 , x i lj+2 , . . . , x i lj+l ), pk); end for end for 2) Send ciphertexts (c k 0 , • • • , c k d-1 , • • • , c 1 0 , • • • , c 1 d-1</formula><p>) and parameters pk, d, l to the server S 2 ; At S 2 :</p><formula xml:id="formula_7">1) Randomly select d × k integers from Z p , that is (r k 0 , • • • , r k d-1 , • • • , r 1 0 , • • • , r 1 d-1 ); 2) Compute T = SH.Enc(Γ l (1, 1, . . . , 1), pk) and T = SH.Enc(Γ l (-1, -1, . . . , -1), pk); 3) for j = 0, 1, • • • , d -1 do for i = k, k -1, • • • , 1 do w i j = SH.Enc(Γ l (y i lj+1 , y i lj+2 , . . . , y i lj+l ), pk); if i = k then a i j = c i j (T ⊕ T ⊗ w i j ); b i j = w i j (T ⊕ T ⊗ c i j ); end if if i &lt; k then a i j = (T ⊕T ⊗b i+1 j )(a i+1 j ⊕(T ⊕T ⊗a i+1 j )⊗ c i j ⊗ (T ⊕ T ⊗ w i j )); b i j = (T ⊕ T ⊗ a i+1 j )(b i+1 j ⊕ (T ⊕ T ⊗ b i+1 j ) ⊗ w i j ⊗ (T ⊕ T ⊗ c i j</formula><p>)); end if end for end for 4) Send the binary vector (a 1 0 , a 1 1 , . . . , a 1 d-1 ) to the server S 2 . At S 1 :</p><p>1)</p><formula xml:id="formula_8">for j = 0, 1, • • • , d -1 do (z lj+1 , z lj+2 , . . . , z lj+l ) = Γ -1 l (SH.Dec(a 1 j )); end for 2) Send (z 1 , z 2 , • • • , z N ) back to S 2 . return (z 1 , z 2 , • • • , z N ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Keypoint Localization Protocol</head><p>1) Finding Candidate Keypoint: After receiving ciphertexts</p><formula xml:id="formula_9">I i from O, S i creates Gaussian spaces L i (x, y, σ) (i ∈ {1, 2})</formula><p>by conducting convolution and downsampling operations on it with the variable-scale Gaussian G(x, y, σ). Specifically, S 1 will compute</p><formula xml:id="formula_10">L 1 (x, y, σ) = G(x, y, σ) * I 1 (x, y),<label>(2)</label></formula><p>where * denotes the convolution operation in x and y, and G(x, y, σ) = 1 2πσ 2 e -(x 2 +y 2 )/2σ 2 . As shown in Fig. <ref type="figure" target="#fig_2">2</ref>(a), for each octave of the scale space, the original image is repeatedly convolved with G(x, y, σ) by Eq. ( <ref type="formula" target="#formula_10">2</ref>) to produce the set of images in the scale space. After generating each octave, the Gaussian image is down-sampled by a factor of 2, and the process repeats. Note that the number of octaves (which the repetition times) and number of scales per octave are pre-defined by the data owner.</p><p>Then, S 1 further computes the difference-of-Gaussian function D 1 (x, y, σ) from the substraction of adjacent Gaussian images as</p><formula xml:id="formula_11">D 1 (x, y, σ) = L 1 (x, y, rσ) -L 1 (x, y, σ),</formula><p>where r is a constant multiplicative factor pre-defined by the data owner. In the meantime, S 2 will do the same operations for I 2 (x, y) and obtain D 2 (x, y, σ). Note that both servers operate in the same order to generate a homologous scale space.</p><p>Next, in the process of extremum detection, each sample point is compared with its 26 neighbors in the current and adjacent scales in the original difference-of-Gaussian scale space D(x, y, σ). If it is larger or smaller than all of them, it will be selected as a candidate keypoint. To determine which is larger between points D(x, y, σ) and D(x, y + 1, σ), S 1 and S 2 will compute ∆D 1 = D 1 (x, y, σ) -D 1 (x, y + 1, σ) and ∆D 2 = D 2 (x, y, σ) -D 2 (x, y + 1, σ), respectively. Then, they will work together to compute which is larger between ∆D 1 and ∆D 2 by using BSCP. If ∆D 1 ∆D 2 , we will claim that D(x, y, σ) D(x, y + 1, σ), otherwise D(x, y, σ) &lt; D(x, y + 1, σ).</p><p>2) Eliminating Edge Responses: After the candidate keypoints are located, edge response eliminating will be conducted to exclude the points that are not stable. For a detected candidate keypoint D 1 (x, y, σ) on the server S 1 , its derivatives in x-direction, y-direction and xy-direction are first computed as follows to constitute its Hessian matrix</p><formula xml:id="formula_12">R 1xx =D 1 (x + 1, y, σ) + D 1 (x -1, y, σ) -2D 1 (x, y, σ) R 1yy =D 1 (x, y + 1, σ) + D 1 (x, y -1, σ) -2D 1 (x, y, σ) R 1xy =0.25(D 1 (x + 1, y + 1, σ) -D 1 (x + 1, y -1, σ) -D 1 (x -1, y + 1, σ) + D 1 (x -1, y -1, σ)).</formula><p>Let R 2xx , R 2yy and R 2xy denote that computed on the server S 2 . By using BSMP with R 1xx and R 2yy as the two private inputs, S 1 is able to get a share of the product of R 1xx and R 2yy denoted by M 1 (R 1xx R 2yy ), and S 2 is able to get the other share denoted by</p><formula xml:id="formula_13">M 2 (R 1xx R 2yy ) such that M 1 (R 1xx R 2yy ) + M 2 (R 1xx R 2yy ) = R 1xx R 2yy . Similarly, S 1 can get the shares M 1 (R 1yy R 2xx ) and M 1 (R 1xy R 2xy ), and S 2 can get the shares M 2 (R 1yy R 2xx )</formula><p>and M 2 (R 1xy R 2xy ). Then S 1 will compute the trace and the determinant of the Hessian matrix as</p><formula xml:id="formula_14">Tr 1 =R 1xx + R 1yy Det 1 =R 1xx R 1yy -R 2 1xy -(M 1 (R 1xx R 2yy ) + M 1 (R 1yy R 2xx ) -2M 1 (R 1xy R 2xy )).</formula><p>Correspondingly, S 2 computes the trace Tr 2 and the determinant Det 2 . Finally, to determine whether the point D 1 (x, y, σ) is a stable one, S 1 and S 2 will first compare Det 1 and -Det 2 . If Det 1 -Det 2 , then the point should be rejected immediately, otherwise they will further compute</p><formula xml:id="formula_15">Z 1 = rTr 2 1 -2rM 1 (Tr 1 Tr 2 ) -(r + 1) 2 Det 1 and Z 2 = -(rTr 2 2 - 2rM 2 (Tr 1 Tr 2 ) -(r + 1) 2 Det 2 )</formula><p>respectively, where r is a predefined threshold and M 1 (Tr 1 Tr 2 ) and M 2 (Tr 1 Tr 2 ) denote the two shares of the product of Tr 1 and Tr 2 that are obtained by using BSMP. And then they will involve in BSCP with Z 1 and Z 2 as the two private inputs. If Z 1 &lt; Z 2 , then we claim that the point D 1 (x, y, σ) is stable, otherwise eliminate this point.</p><p>Remarks. To reduce the rounds of interactions in the implementation of BSCP and BSMP, S 1 can prepare all the data simultaneously and transmit all the encrypted data in a onetime transmission. For example, in detecting the candidate keypoints, S 1 and S 2 can compute ∆D 1 and ∆D 2 between all neighboring two points in the scale space simultaneously. Then S 1 can transmit all encrypted ∆D 1 's to S 2 in a one-time transmission. Consequently, the number of rounds of interactions required in detecting all the keypoints is a constant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Orientation Assignment Protocol</head><p>To give a better illustration of this protocol, we first provide a sketch that depicts the workflow in Fig. <ref type="figure" target="#fig_2">2(b</ref>).</p><p>1) Orientation Computation: Once the location of a keypoint is determined, the gradient magnitude and the orientation should be computed according to pixel differences so as to build an orientation histogram. The scale of a keypoint D(x, y, σ), associated with a parameter σ, is used to select the Gaussian smoothed image L that has the closest scale, so all the following computations are performed in a scaleinvariant manner. Thus, for ease of expression we will omit parameter σ in the following discussions.</p><p>For the orientation computation on the keypoint L(x, y) (which is mapped back from D(x, y)), S 1 and S 2 will first determine which is larger between L(x, y + 1) and L(x, y -1), and between L(x + 1, y) and L(x -1, y), respectively. Here, we set two variables α and β as: α = 1 if L(x, y + 1) L(x, y -1); otherwise α = -1, and β = 1 if L(x + 1, y) L(x -1, y); otherwise β = -1. Secure comparisons of the two pairs can be achieved by using the protocol BSCP with L 1 (x, y + 1) -L 1 (x, y -1) and L 2 (x, y + 1) -L 2 (x, y -1) being the two inputs from S 1 and S 2 respectively, L 1 (x + 1, y) -L 1 (x -1, y) and L 2 (x + 1, y) -L 2 (x -1, y) being the other pair of inputs. As a result, which range the orientation lies in can be obtained, i.e., 0</p><formula xml:id="formula_16">• ∼ 90 • , 90 • ∼ 180 • , 180 • ∼ 270 • , 270 • ∼ 360 • .</formula><p>To get a more fine-grained direction range, S 1 computes</p><formula xml:id="formula_17">∆Diff 1 = Diff 1y -kDiff 1x = α(L 1 (x, y + 1) -L 1 (x, y -1)) -kβ(L 1 (x + 1, y) -L 1 (x -1, y)).</formula><p>On the other side, S 2 will get ∆Diff 2 = Diff 2y -kDiff 2x , where k is a constant used to determine the orientation interval. Then, S 1 and S 2 will involve in BSCP computation with ∆Diff 1 and ∆Diff 2 as the two inputs. If ∆Diff 1 ∆Diff 2 , we say that the direction degree is larger than arctan k. Repeatedly executing the above steps for a series of pre-defined k's, a fine-grained direction degree range can be obtained. In our system, we select k to be eight values respectively, i.e. tan 10 • , tan 20 • , . . . , tan 80 • . Therefore, a 360-degree range of orientations can be fully covered with each span of the interval to be 10 • .</p><p>2) Gradient Magnitude Computation: In our outsourcing model, we define our gradient magnitude as</p><formula xml:id="formula_18">m(x, y) = |Diff x | + |Diff y |,<label>(3)</label></formula><p>where Diff x = L(x + 1, y) -L(x -1, y), Diff y = L(x, y + 1) -L(x, y -1). Accordingly, S 1 and S 2 compute gradient magnitudes m 1 (x, y) = Diff 1x + Diff 1y and m 2 (x, y) = Diff 2x + Diff 2y , respectively. Then, they respectively accumulate m 1 and m 2 according to their orientations, after being weighted by the same Gaussian window, to build their own encrypted orientation histograms H 1 and H 2 .</p><p>3) Finding Peaks in the Orientation Histogram: To detect peaks in the original orientation histogram H, all we need is to find whose accumulated gradient magnitude is larger between two bins. Let being the two inputs, if the former is larger, we say the bin of 0 • ∼ 10 • is higher; lower otherwise. After repeating this comparison between any two bins, we are able to find the highest peak and all the local peaks. To detect any local peak within 80% of the highest peak in H, S 1 and S 2 will compute which is larger between LP m 1 -0.8 HP m 1 and LP m 2 -0.8 HP m 2 where LP m i corresponds to the bin with local peak and HP m i (i ∈ 1, 2) corresponds to the bin with the highest peak. As a result, for locations with multiple peaks of similar magnitudes, there exists multiple keypoints created at the same location and scale, but with different orientations as the original SIFT does. Note that, in the above protocol, constant-round interactions can also be achieved by encrypting all the data simultaneously and transmitting the encrypted data at one time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Descriptor Generation Protocol</head><p>Once S 1 and S 2 have detected dominant orientations on a keypoint, they will first generate their respective descriptors as follows.</p><p>First, the coordinates and the gradient orientations are rotated relative to a keypoint orientation. Note that the specific value of the gradient orientation is needed in the process of  rotation, so we propose to use the median of the interval its orientation lies in to replace the actual orientation value. For example, if the orientation of one point lies in the interval 10 • ∼ 20 • , we use 15 • as its orientation to perform rotation. Our subsequent theoretical analysis and experiments show that this approximate orientation substitution has a negligible impact on the final results.</p><p>Second, in the 4 × 4 subregions around the keypoint, gradient magnitudes of sample points (as shown in Eq. ( <ref type="formula" target="#formula_18">3</ref>)) are weighted by a Gaussian window and accumulated into 4 × 4 orientation histograms. Then, each histogram consists of 8 bins and the span of each bin is 45 • so that a 360-degree range of orientations can be covered. To improve the system efficiency, all the gradients are pre-computed in the phase of orientation assignment.</p><p>Finally, a 128-dimensional feature vector is used to represent 16 histograms for a keypoint. Let V 1 and V 2 denote the feature vectors generated by S 1 and S 2 , respectively. They will be sent to O, who can recover the actual feature vector by computing V = V 1 -V 2 , which will be normalized to unit length by O in order to achieve invariance to affine changes in illumination.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. SYSTEM ANALYSIS</head><p>In this section, we will give a careful analysis of the proposed scheme in terms of effectiveness and security. We will show that the proposed scheme is carefully constructed to meet the effectiveness and the security constraints described in our design goals in Section V.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Effectiveness Analysis</head><p>In this subsection, we will provide a theoretical examination of the effectiveness of our scheme step by step in the sense that the extracted features are very close to the outputs generated by the original SIFT. Keypoint Localization Protocol: In the keypoint localization, when comparing two neighbors to detect the extrema after building the difference-of-Gaussian space, we have</p><formula xml:id="formula_19">∆D 1 -∆D 2 = [D 1 (x, y, σ) -D 1 (x, y + 1, σ)] -[D 2 (x, y, σ) -D 2 (x, y + 1, σ)] = [D 1 (x, y, σ) -D 2 (x, y, σ)] -[D 1 (x, y + 1, σ) -D 2 (x, y + 1, σ)] = D(x, y, σ) -D(x, y + 1, σ)</formula><p>which means that the comparison of ∆D 1 and ∆D 2 is equivalent to determine which is larger between D(x, y, σ) and D(x, y + 1, σ). Thus, all candidate keypoints can be correctly localized by the cloud servers. Note that in the above equations we use the property D(x, y, σ) = D 1 (x, y, σ) -D 2 (x, y, σ), which can be easily deduced from the equation</p><formula xml:id="formula_20">L(x, y) = G * I(x, y) = G * (I 1 (x, y) -I 2 (x, y)) = L 1 (x, y) -L 2 (x, y)</formula><p>Then in the process of edge response eliminating, when computing derivatives we have</p><formula xml:id="formula_21">Rxx =D(x + 1, y, σ) + D(x -1, y, σ) -2D(x, y, σ) =D 1 (x + 1, y, σ) + D 1 (x -1, y, σ) -2D 1 (x, y, σ) -[D 2 (x + 1, y, σ) + D 2 (x -1, y, σ) -2D 2 (x, y, σ)] =R 1xx -R 2xx</formula><p>Similarly, we can have R yy = R 1yy -R 2yy and R xy = R 1xy -R 2xy , which will lead to the following equations when computing the Hessian's determinants,</p><formula xml:id="formula_22">Det =RxxRyy -R 2 xy =(R 1xx -R 2xx )(R 1yy -R 2yy ) -(R 1xy -R 2xy ) 2 =[R 1xx R 1yy -R 2 1xy -(M 1 (R 1xx R 2yy ) + M 1 (R 1yy R 2xx ) -2M 1 (R 1xy R 2xy ))] + [R 2xx R 2yy -R 2 2xy -(M 2 (R 1xx R 2yy ) + M 2 (R 1yy R 2xx ) -2M 2 (R 1xy R 2xy ))] =Det 1 + Det 2</formula><p>Note that the above equations hold due to the property</p><formula xml:id="formula_23">M 1 (R 1xx R 2yy + M 2 (R 1xx R 2yy ) = R 1xx R 2yy .</formula><p>Based on the above results, to determine whether the candidate keypoint is a stable keypoint, if Det 1 + Det 2 0, we have Det 0 which indicates that the candidate keypoint has different signs for curvatures and should be rejected immediately. If Det 1 + Det 2 &gt; 0, we have</p><formula xml:id="formula_24">Z 1 -Z 2 = rTr 2 1 -2rM 1 (Tr 1 Tr 2 ) -(r + 1) 2 Det 1 -[-(rTr 2 2 -2rM 2 (Tr 1 Tr 2 ) -(r + 1) 2 Det 2 )] = r(Tr 2 1 + Tr 2 2 -2M 1 (Tr 1 Tr 2 ) -2M 2 (Tr 1 Tr 2 )) -(r + 1) 2 (Det 1 + Det 2 ) = r(Tr 1 -Tr 2 ) 2 -(r + 1) 2 (Det 1 + Det 2 ) = rTr 2 -(r + 1) 2 Det</formula><p>Note that the above equations hold based on M 1 (Tr</p><formula xml:id="formula_25">1 Tr 2 ) + M 2 (Tr 1 Tr 2 ) = Tr 1 Tr 2 and Tr = R xx + R yy = Tr 1 -Tr 2 .</formula><p>Then if Z 1 &lt; Z 2 , there has Tr 2  Det &lt; (r+1) 2 r , which indicates that the candidate keypoint has a low principal curvature and is a stable one.</p><p>Note that in our scheme, we cannot remove some unstable keypoints by fitting a 3D quadratic function as the original SIFT did <ref type="bibr" target="#b20">[21]</ref>. This is because this filtering step contains division and derivative operations that are difficult to be implemented in the ciphertext domain. Therefore, as shown in Fig. <ref type="figure" target="#fig_4">3</ref>, we compare the number of keypoints generated in Lowe's scheme <ref type="bibr" target="#b20">[21]</ref> and ours. As the number of the keypoints varies greatly with the images' content, the average number of keypoints cannot give a better illustration and thus we only choose three specific images with size of 3000 × 3000 for highly structured image, poorly structured image and texture image. Fig. <ref type="figure" target="#fig_4">3</ref> shows that the number of keypoints generated in our scheme is about 1.5 times as much as that of Lowe's. This is roughly equivalent to the results presented in <ref type="bibr" target="#b20">[21]</ref>. Orientation Assignment Protocol: In the computation of orientations, we have</p><formula xml:id="formula_26">∆Diff 1 -∆Diff 2 = [Diff 1y -kDiff 1x ] -[Diff 2y -kDiff 2x ] = [α(L 1 (x, y + 1) -L 1 (x, y -1)) -kβ(L 1 (x + 1, y) -L 1 (x -1, y))] -[α(L 2 (x, y + 1) -L 2 (x, y -1)) -kβ(L 2 (x + 1, y) -L 2 (x -1, y))] = α[(L 1 (x, y + 1) -L 2 (x, y + 1)) -(L 1 (x, y -1) -L 2 (x, y -1))] -kβ[(L 1 (x + 1, y) -L 2 (x + 1, y)) -(L 1 (x -1, y) -L 2 (x -1, y))] = α[L(x, y + 1) -L(x, y -1)] -kβ[L(x + 1, y) -L(x -1, y)] = |Diffy| -k|Diffx|<label>(4)</label></formula><p>When ∆Diff 1 ∆Diff 2 , we will have |Diff y | k|Diff x |, which leads to |Diffy| |Diffx| k. Therefore, we can claim that the direction degree of this keypoint is larger than arctan k. As discussed in Section VII-C, by choosing a series of k's, the orientation of each keypoint can be located in a interval whose span is 10 • So it is enough to construct an orientation histogram with 36 bins covering the 360-degree range as the original SIFT does, though their specific values of orientation still remain unknown.</p><p>In the process of finding peaks, our goal is to determine which is larger between two bins in the original histogram H. For ease of analysis, we assume 10 </p><formula xml:id="formula_27">• m 1 = w 1 m 1 (x, y) and 20 • m 1 = w 2 m 1 (x , y ),</formula><formula xml:id="formula_28">m 2 = w 1 m 2 (x, y) and 20 • m 2 = w 2 m 2 (x , y ) computed on S 2 . Then, when comparing 10 • m 1 -20 • m 1 and 10 • m 2 - 20 • m 2 ), we have ( 10 • m 1 - 20 • m 1 ) -( 10 • m 2 - 20 • m 2 ) =w 1 [m 1 (x, y) -m 2 (x, y)] -w 2 [m 1 (x , y ) -m 2 (x , y )] =w 1 [(Diff 1x + Diff 1y ) -(Diff 2x + Diff 2y )] -w 2 [(Diff 1x + Diff 1y ) -(Diff 2x + Diff 2y )] =w 1 (|Diffx| + |Diffy|) -w 2 (|Diff x | + |Diff y |) =w 1 m(x, y) -w 2 m(x , y ) = 10 • m - 20 • m,<label>(5)</label></formula><p>which explains that this comparison is able to find out which bin has the largest accumulated gradient magnitude in the histogram H. Similarly, local peaks within 80% of the highest peak can also be detected. To sum up, the main orientations can be correctly computed by the Orientation Assignment Protocol. Descriptor Generation Protocol: First, we will theoretically show that the approximate orientation substitution in the image rotation has a very low error probability, which can be ignored. In the orientation assignment, each direction is located in an interval, and we use the median to represent its value. If one point, for example, lies in the interval 0 • ∼ 10 • , we will assume its direction is 5 • . Since the rotation degrees are 0 • , 10 • , 20 • , . . . , 350 • , and it needs to determine which new interval (i.e. , 0 • ∼ 45 • , 45 • ∼ 90 • , . . . , 315 • ∼ 360 • ) the rotated direction lies in, the error that the rotated direction is distributed into a wrong interval will happen with probability </p><formula xml:id="formula_29">4 36 × 1 2 = 1 18 ≈ 6%.</formula><p>In order to further demonstrate that this probability is low enough to be ignored in practice, we define the error rate as:</p><formula xml:id="formula_30">Err V = &lt; V -V &gt; |V |</formula><p>where V denotes the feature vector extracted by the our scheme and V denotes the feature descriptor extracted by the original SIFT. As shown in Fig. <ref type="figure" target="#fig_8">5</ref>(a), the maximum error rate of the orientation is lower than 5%, which is small enough to be ignored in practice. In Section IX, our experimental results will further validate our theoretical analysis.</p><p>Finally, in the descriptor recovery process, for the entry corresponding to the bin of 0 • ∼ 10 • in the descriptor, the data owner O has</p><formula xml:id="formula_31">10 • m 1 - 10 • m 2 = w 1 m 1 (x, y) -w 1 m 2 (x, y) = w 1 m(x, y) = 10 • m.</formula><p>Note that the above equation holds by Eq. ( <ref type="formula" target="#formula_28">5</ref>), and it has the same property for all the other entries in the descriptor. This means that each entry O derives by computing V = V 1 -V 2 is the accumulated gradient magnitude in that orientation of the original histogram. Therefore, O is able to recover the real descriptor correctly in this way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Security Analysis 1) Confidentiality of Pixel Values:</head><p>In the Image Encryption step, each image I represented by a matrix is disguised by adding a random matrix. After splitting, each cloud server receives a random matrix. If the image has size of 300 × 300 and each pixel has 8 bits, the server has to use brute-force approach which needs 256 300×300 operations to recover the image, and it is computationally-infeasible in practice. As for the Keypoint Localization Protocol, the two servers interact with each other and may derive some additional information. Since our proposed interaction protocols BSMP and BSCP </p><p>Fig. <ref type="figure">4</ref>: Recovered images by the cloud server.</p><p>are built on semantically-secure SHE and all the intermediate results are generated in the encrypted form, the two servers cannot learn anything but the final encrypted results. Specifically, in BSMP, S 1 only observes a random encryption of the two private inputs' product as s = xy -r, where r is random and held by S 2 . Thus, both S 1 and S 2 can derive nothing at all. In BSCP, the servers only know large or small of pixel values between any two neighbors, thus they are unable to compute the specific value of each pixel. Similarly, in the Orientation Assignment Protocol, the servers can obtain nothing but some more complex but unuseful relationships between pixels in a small region around keypoints. For example, they may get L(x, y + 1) L(x, y -1) and |Diff y | k|Diff x | in orientation computation, and 10 • m 20 • m in finding peaks. These available inequalities are still insufficient to compute the exact value of L(x, y). Therefore, we claim that the confidential of pixel values are well protected against the servers.</p><p>2) Privacy of Image Content: We next show that the servers are unable to deduce the original image content by what they have obtained. As illustrated above, the servers can only get some inequalities about the pixel values, so they have to traverse all the possibilities for each pixel that satisfy these inequalities. We argue that in order to reconstruct the whole image, the most useful information is the knowledge of the relationship between any two neighboring pixels while other inequality constraints have very limited contribution in recovering pixels. Fig. <ref type="figure">4</ref> depicts the cloud server's possible reconstructions of twelve images that fulfill this relationship. These images are randomly chosen from twelve categories of Caltech256 Dataset <ref type="bibr" target="#b27">[28]</ref>, and correspond to a bat, a clutter, a duck, a iguana, a butterfly, a touring-bike, a centipede, a chimp, a comet, a crab, a toad and a fighter-jet from Fig. <ref type="figure">4</ref>(a) to Fig. <ref type="figure">4</ref>(l). Obviously, it is almost impossible to recognize the original content in the recovered images, let alone the details. On the other hand, we show that there exists exponential number of possible reconstructions that satisfy the given constraints between any two neighboring pixels. For an image of size n × n with each pixel of 8-bit length, as shown in Fig. <ref type="figure" target="#fig_8">5</ref>  in the image, the total number of different possibilities is at least</p><formula xml:id="formula_33">( 256 4 ) ( n 4 ) 2</formula><p>. Hence, there has an exponential number of possible reconstructions of the original image, which is impractical for the servers to launch an exhaustive search.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IX. EXPERIMENTAL EVALUATION</head><p>In this section, we conduct various experiments to evaluate the effectiveness and the efficiency of our secure SIFT outsourcing scheme using representative real-world image datasets. All our experiments are implemented by C++ programming language on Linux machines, each of which is with an Intel Core CPU 3.1GHz processor and a 12GB RAM running Ubuntu 14.04 LTS.</p><p>A. Effectiveness Evaluation 1) Descriptor Evaluation: In the following experiments, we compare our scheme with Qin et al.'s scheme <ref type="bibr" target="#b16">[17]</ref>, Hsu et al.'s scheme <ref type="bibr" target="#b13">[14]</ref> and the original SIFT proposed by Lowe <ref type="bibr" target="#b20">[21]</ref> at the same time. To have a better evaluation on the distinctiveness and robustness of feature vectors, we choose to measure the performance on keypoint matching experiment as did in <ref type="bibr" target="#b28">[29]</ref>. That is, given an interest point, we will find all matches of that interest point in a dataset. More specifically, we will compute Euclidean distances between feature vectors to find the nearest point and the second nearest one in the dataset. A match between the interest point and its nearest point occurs if the distance ratio between these two points is below a threshold t. We conduct experiments on real image dataset: INRIA Graffiti [30], which contains images of graffiti-covered walls taken from different camera viewpoints changes. For each change, it contains 6 images with a gradual geometric or photometric transformation, and all images in this dataset are approximately in 800 × 600 pixels. We then use well-acknowledged evaluation metrics recall and 1-precision defined in <ref type="bibr" target="#b29">[31]</ref> to quantify our results: recall = number of correct-matches total number of positives and 1-precision = number of false-matches total number of matches , where a correct-match is a match where the two keypoints correspond to the same physical location while a false-match is a match where the two keypoints come from different physical locations, and the total number of positives is known as a priori for a given dataset. In Fig. <ref type="figure" target="#fig_10">6</ref>, we plot recall VS. 1-precision for the image matching experiment by varying the distance ratio threshold t (0 t 1). In Fig. <ref type="figure" target="#fig_10">6</ref>     and scaled by 20%. It is shown that when t is rather small, our scheme and Lowe's scheme both perform better in finding the correct matches, i.e., achieving a high recall that is getting close to the maximum 0.5 and a low 1-precision that is much smaller than 0.  Fig. <ref type="figure" target="#fig_10">6</ref>(c) measures the performance for images with a significant amount blur which is introduced by changing the camera focus. The results show that all descriptors generated by the three schemes are affected by this type of image degradation. But Lowe's and our scheme clearly dominate Qin et al.'s scheme and Hsu et al.'s scheme especially when the threshold t is rather low. This is because <ref type="bibr" target="#b16">[17]</ref> and <ref type="bibr" target="#b13">[14]</ref> are able to eliminate unstable points that are poorly localized along an edge (and are therefore sensitive to noise). Fig. <ref type="figure" target="#fig_10">6</ref>(d) shows the results for illumination changes which have been obtained by changing the camera setting. It again shows that both our scheme and Lowe's perform better than the competing approaches. However, <ref type="bibr" target="#b16">[17]</ref> and <ref type="bibr" target="#b13">[14]</ref> have a low recall due to the reason that they have computed their feature descriptors without sampling in a region.</p><p>To further demonstrate the property of invariance to rotation and image scale, Fig. <ref type="figure" target="#fig_13">7</ref> depicts the precision as a function of rotation angle and scale ratio respectively. It shows that both our scheme and Lowe's scheme maintain a stable and high precision (i.e. , always larger than 0.9) no matter how the image rotated. On the contrary, the precision of Qin et al's scheme and Hsu et al.'s scheme fall sharply when the image is only rotated by 20 • . When it comes to scale change, both our scheme and Lowe's decrease slowly in precision with the increase of scale ratio, and they will stay above 0.4 at last, while the precision of Qin et al.'s scheme and Hsu et al.'s scheme stay lower than 0.2 all the time. The results indicate that both our scheme and Lowe's provide a good invariance to rotation change and a certain degree of invariance to image scale, but Qin et al's scheme and Hsu et al.'s scheme provide neither of the two properties.</p><p>2) Keypoint Matching Experiment: In Fig. <ref type="figure">8</ref>, we provide a comparison of three scheme's keypoint matching results visualized for illustration purpose. The images are selected from real-world scenes taken from different viewpoints. For a better illustration, we manually set the thresholds to have each scheme return only 10 matches, which contain correct matches and false positives. It clearly shows that our scheme approaches Lowe's original SIFT and outperforms Qin et al.'s scheme and Hsu et al.'s scheme in finding correct matches.</p><p>3) Image Retrieval Experiment: In Fig. <ref type="figure" target="#fig_15">9</ref>, we conduct image retrieval experiments to evaluate the descriptors inspired from <ref type="bibr" target="#b30">[32]</ref>. We randomly select 11 categories from Oxford database [33] which consists of 5062 images collected from Flickr as the dataset by searching for particular Oxford landmarks. Given a query image, it returns a ranked list of images that contain the same objects by using the voted based method. The number below each returned image represents how many votes it receives. It clearly shows that our scheme receives much more votes than the original sift. We think this may be caused by much more keypoints generated in our scheme. We can also see that Lowe's scheme and ours generate less false positives than Qin et al's and Hsu et al's.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Efficiency Evaluation</head><p>In Fig. <ref type="figure" target="#fig_5">10</ref>, we evaluate the computation efficiency of privacy-preserving SIFT outsourcing with the increase of image size on the data owner side. The time cost and communication cost are computed for one image with different sizes. As has been analyzed in Section IV-1, Hsu et al'scheme incurs an intolerable computation burden on the data owner, so we    the time cost of performing SIFT algorithm locally and that of outsourcing of SIFT scheme. As can be seen, our scheme has an extreme low time cost on the data owner, which is nearly a constant value. On the contrary, without outsourcing the time cost on the data owner increases linearly with the image size. This is because without outsourcing the data owner needs to perform full extraction algorithm while in our scheme it only needs to do some addition operations. With the increase of image size, the benefit of outsourcing will become more apparent. The side effect of outsourcing is generating some communication overheads on the data owner. In our scheme, however, the communication cost is low enough to be acceptable by the data owner as shown below.</p><p>As for the communication cost on the data owner side as illustrated in Fig. <ref type="figure" target="#fig_5">10</ref>(b), since the data owner only sends two split images to the two cloud servers and receives two split descriptors with fixed size, our scheme and Qin et al.'s scheme have the same communication overhead which grows linearly with the size of an image.</p><p>In Fig. <ref type="figure" target="#fig_5">11</ref>, we evaluate the time cost and the communication cost of our scheme on the server side. Note that the servers and the data owner are all simulated on machines of the same configuration without using multithreading or any other parallel techniques. To make a better illustration, we also compare i) the secure product protocol (SPP) proposed in <ref type="bibr" target="#b25">[26]</ref> that adopts the Paillier cryptosystem <ref type="bibr" target="#b14">[15]</ref> with our BSMP, and ii) a general secure comparison protocol-garbled circuit <ref type="bibr" target="#b19">[20]</ref> with our BSCP. Since the protocols BSMP and BSCP take up most of the time costs (because of encryption and decryption operations) and are the only source of communication cost, we only evaluate these two protocols and ignore the other steps such as building gaussian scale spaces, computing descriptors etc. In our experiments, we set the Paillier cryptosystem with a 1024-bit modulus and implement SHE with the aid of SIMD. Garbled circuit is tested using the lastest optimizations <ref type="bibr">[34]</ref>.</p><p>Fig. <ref type="figure" target="#fig_5">11</ref>(a) shows the time cost on the servers. With the increase of image size, the time cost in garbled circuit grows much faster than that of BSCP, and SPP also consumes much more than BSMP. According to our experimental results, when the image size grows to 500 × 500, garbled circuit and SPP will cost more than 10854 minutes and 3799 minutes respectively, while the costs in BSCP and BSMP are about 235 minutes and 2.2 minutes respectively. Fig. <ref type="figure" target="#fig_5">11</ref>(b) evaluates the communication cost between two servers which is generated by using BSCP and BSMP. It also shows that communication cost of BSMP is much lower than that of SPP, and BSCP also outperforms the garbled circuit greatly. Particularly, when the image size grows to 500×500, garbled circuit costs more than 8458MB while BSCP costs about 2968MB, and SPP needs about 2226MB while BSMP costs about 240MB. The above results indicate that the proposed protocols BSCP and BSMP are more suitable for practical applications. Note that when the image size grows to 3000 × 3000, our scheme will consume about 711 minutes and 8875MB in total. Our future work may focus on further reducing the time and communication costs for large-size images, by exploring some parallel techniques and more packing methods.</p><p>As for the interactions between two servers, as we have shown in section VII, a constant number of round can be achieved by sending all the encrypted data in one-time transmission. The specific number of interactions depends on the parameters chosen in somewhat homomorphic enryption scheme. In our experiment, it needs dozens of rounds to complete the entire extraction process.</p><p>Finally, for the memory cost on the servers, for a n × n image it at most needs 12 × n × n bytes where 12 is a predefined parameter to decide the number of scales in scale space. Thus when n = 3000 the memory cost is about 103MB, which is still acceptable for an off-the-shelf machine, let alone a powerful cloud server.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>X. FUTURE RESEARCH DIRECTIONS</head><p>In this section, we will give some discussions on the extensions of our scheme.</p><p>First, SIFT is now widely computed in a dense manner. Dense SIFT computes a descriptor for every pixel in the image instead of locating points that we are only interested in. The other steps such as orientation assignment and descriptor computation are exactly the same as SIFT. Therefore, we claim that our scheme can be directly applied to dense SIFT outsourcing. This is because the two servers only need to proceed the other steps identically without performing the keypoint localization protocol.</p><p>Second, one may want to aggregate SIFT descriptors into a compact representation by using Fish vectors <ref type="bibr" target="#b31">[35]</ref> or VLAD <ref type="bibr" target="#b32">[36]</ref>. In fact, it is also possible to compute VLAD by using a secure outsourcing protocol. This can be achieved by using techniques in <ref type="bibr" target="#b33">[37]</ref> to outsource k-means algorithm to the cloud, and then computing aggregated descriptors which only needs addition operations. As for Fisher vectors, since it contains many derivative and division operations which are difficult to be implemented in the ciphertext domain, we are not sure whether it is suitable for outsourcing yet. We will investigate this issue in our future work.</p><p>Finally, feature descriptors are usually used in content-based retrieval such as k-nn search. As far as we know, secure outsourcing of k-nn search has been widely studied and many solutions have been proposed such as <ref type="bibr" target="#b7">[8]</ref>. In <ref type="bibr" target="#b7">[8]</ref>, the data owner only needs to encrypt descriptors and sends ciphertexts to the two cloud servers. The cloud servers will then work cooperatively to complete the k-nn search task and return an accurate search result without obtaining anything private about the descriptors. This method can be directly combined with our scheme such that the data owner can relieve himself from the burden of computationally-intensive search jobs. XI. CONCLUSION Privacy-preserving outsourcing of image feature extraction offers the promise of obtaining feature descriptors dependent on private data without exposing the data owner's privacy, while enjoying the abundant cloud computation resources. However, previous solutions for secure SIFT outsourcing have either security or efficiency issues, and none can preserve the important characteristics of the original SIFT in terms of distinctiveness and robustness. In this work, we presented a new and novel privacy-preserving SIFT outsourcing protocol based on newly proposed secure interactive protocols BSMP and BSCP. We both carefully analyze and extensively evaluate the security and effectiveness of our design. Our experimental results show that our protocol outperforms the state-of-the-art and performs comparably to the original SIFT and is practical for real-world applications.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 :</head><label>1</label><figDesc>Fig. 1: System model.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>L1(x,y,σ)L2(x,y,σ) D1(x,y,σ) D2(x,y,σ) System Overview.L1(x,y+1)-L1(x,y-1) ,y+1)-L2(x,y-1) A sketch of orientation assignment protocol.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 :</head><label>2</label><figDesc>Fig. 2: System and OSP overviews.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>The 3000 × 3000 pixel original texture image. (h) 35299 keypoints found in Lowe's scheme. (i) 45888 keypoints found in ours.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3 :</head><label>3</label><figDesc>Fig. 3: Comparison of the number of keypoints generated in Lowe's scheme and ours for different types of images.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>1 2</head><label>1</label><figDesc>only when the rotated interval contains 45 • , 135 • , 225 • and 315 • , such as 40 • ∼ 50 • , 130 • ∼ 140 • , 220 • ∼ 230 • and 310 • ∼ 320 • . Hence, the total error probability is</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>(b) with n = 10, the values of pixels in each square have 256 4 different possibilities. The rest pixels are supposed to have only one possibility so that all the neighbors can meet the given constraints. Since there exist at least ( n 4 ) The average error. (b) Structure analysis for image recovery.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 5 :</head><label>5</label><figDesc>Fig. 5: The average error and structure analysis.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>(a), the target images are rotated by 20 • Qin et al.' Scheme Hsu et al.' Scheme Our Scheme (a) Matching experiments where target images are rotated by 20 • and scaled by 20%. Qin et al.' Scheme Hsu et al.' Scheme Our Scheme (b) Matching experiments where target images have a 3D viewpoint change of 20 • . Matching experiment where target images have illumination change.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 6 :</head><label>6</label><figDesc>Fig. 6: Recall versus 1-precision.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>Precision varies as a function of rotation angle.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>Precision varies as a function of scale ratio.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 7 :</head><label>7</label><figDesc>Fig. 7: Rotation invariance and image scale invariance.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 6 (</head><label>6</label><figDesc>b) is obtained when the target images have a 3D viewpoint change of 20 • , it is shown that our scheme and Lowe's almost have the same performance and both of them outperform Qin et al.'s scheme and Hsu et al.'s scheme.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig. 9 :</head><label>9</label><figDesc>Fig. 9: A comparison of four schemes for the image matching application. The leftmost column consists of four query images while the right column images are the corresponding top-k (k=4) matching results of each scheme. Note that in each image the yellow rectangle depicts the matched object, and the images without it are the false positives.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig. 8 :Fig. 10 :Fig. 11 :</head><label>81011</label><figDesc>Fig. 8: A performance comparison of the visualized matching results. Here, real-world images are selected from Graffiti dataset taken from different viewpoints. The top ten matches are shown for each algorithm: solid white lines represent correct matches while dotted black lines represent false ones.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>10 • m 1 and 20 • m 1 denote the accumulated gradient in H 1 whose orientations lie in 0 • ∼ 10 • and 10 • ∼ 20 • , respectively. Let 10 • m 2 and 20 • m 2 denote those computed in H 2 . Then with the aid of BSCP with 10 • m 1 -20 • m 1 and 10 • m 2 -20 • m 2</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>where w 1 and w 2 denote the corresponding Gaussian weight values. It means that the bins 0 • ∼ 10 • and 10 • ∼ 20 • in the histogram built by S 1 consist of only one point. Accordingly, we can get •</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>1, while the recalls of Qin et al.'s scheme and Hsu et al.'s scheme are low (i.e., smaller than 0.2) and their 1-precision are high (i.e., larger than 0.1). Note that when t approaches to 1, the 1-precision in our scheme and Lowe's remain around 0.5 but that of Qin et al.'s scheme and Hsu et al.'s scheme have quickly increased to 0.7. The results indicate that Qin et al.'s scheme and Hsu et al.'s scheme will generate much more false matches than our scheme and Lowe's under the same threshold. The reason why Qin et al.'s scheme and Hsu et al.'s scheme have the same performance is that they always generate the same feature descriptors.</figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>ACKNOWLEDGMENT Qian's research is supported in part by National Natural Science Foundation of China under Grant No. 61373167, National Basic Research Program of China (973 Program) under Grant No. 2014CB340600, National High Technology Research and Development Program of China (863 Program) under Grant No. 2015AA016004, Wuhan Science and Technology Bureau under Grant No. 2015010101010020, and Fundamental Research Funds for the Central Universities under Grant No. 2042016kf0137. Kui's research is supported in part by US National Science Foundation under grants CNS-1262277. Qian Wang is the corresponding author.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Catch me in the dark: Effective privacy-preserving outsourcing of feature extractions over image data</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Du</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of INFOCOM&apos;16</title>
		<meeting>of INFOCOM&apos;16</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note>Accepted to appear</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Security challenges for the public cloud</title>
		<author>
			<persName><forename type="first">K</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Internet Computing</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="69" to="73" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Dynamic proofs of retrievability for coded cloud storage systems</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Xu</surname></persName>
		</author>
		<idno type="DOI">10.1109/TSC.2015.2481880</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Services Computing</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Enabling personalized search over encrypted outsourced data with efficiency improvement</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Huang</surname></persName>
		</author>
		<idno type="DOI">10.1109/TPDS.2015.2506573</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Parallel and Distributed Systems</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A secure and dynamic multi-keyword ranked search scheme over encrypted cloud data</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Parallel and Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="340" to="352" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">How to securely outsource cryptographic computations</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hohenberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lysyanskaya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of TCC&apos;05</title>
		<meeting>of TCC&apos;05</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="264" to="282" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Efficient secure outsourcing of large-scale linear systems of equations</title>
		<author>
			<persName><forename type="first">S</forename><surname>Salinas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of INFOCOM&apos;15</title>
		<meeting>of INFOCOM&apos;15</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1035" to="1043" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Secure k-nearest neighbor query over encrypted data in outsourced environments</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Elmehdwi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">K</forename><surname>Samanthula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Jiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICDE&apos;14</title>
		<meeting>of ICDE&apos;14</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="664" to="675" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A privacy-preserving framework for large-scale content-based information retrieval</title>
		<author>
			<persName><forename type="first">L</forename><surname>Weng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Amsaleg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Morton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Marchand-Maillet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Forensics and Security</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="152" to="167" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Scifi-a system for secure face identification</title>
		<author>
			<persName><forename type="first">M</forename><surname>Osadchy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jarrous</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Moskovich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of S&amp;P&apos;10</title>
		<meeting>of S&amp;P&apos;10</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="239" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Cloudbi: Practical privacy-preserving outsourcing of biometric identification in the cloud</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Du</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ESORICS&apos;15</title>
		<meeting>of ESORICS&apos;15</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="186" to="205" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Pop: Privacypreserving outsourced photo sharing and searching for mobile devices</title>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X.-Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICDCS&apos;15</title>
		<meeting>of ICDCS&apos;15</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="308" to="317" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Pic: Enable large-scale privacy preserving content-based image search on cloud</title>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X.-Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICPP&apos;15</title>
		<meeting>of ICPP&apos;15</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="949" to="958" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Image feature extraction in encrypted domain with privacy-preserving sift</title>
		<author>
			<persName><forename type="first">C.-Y</forename><surname>Hsu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-C</forename><surname>Pei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Image Processing</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="4593" to="4607" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Efficient public-key cryptosystems provably secure against active adversaries</title>
		<author>
			<persName><forename type="first">P</forename><surname>Paillier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ASIACRYPT&apos;99</title>
		<meeting>of ASIACRYPT&apos;99</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="165" to="179" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Notes on non-interactive secure comparison in image feature extraction in the encrypted domain with privacy-preserving sift</title>
		<author>
			<persName><forename type="first">M</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IH &amp; MMSec&apos;14</title>
		<meeting>of IH &amp; MMSec&apos;14</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="135" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Towards efficient privacy-preserving image feature extraction in cloud computing</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM MM&apos;14</title>
		<meeting>of ACM MM&apos;14</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="497" to="506" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Order-preserving symmetric encryption</title>
		<author>
			<persName><forename type="first">A</forename><surname>Boldyreva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Chenette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Oneill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of EUROCRYPT&apos;09</title>
		<meeting>of EUROCRYPT&apos;09</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="224" to="241" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Secure and private outsourcing of shape-based feature extraction</title>
		<author>
			<persName><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Nassar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Atallah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Malluhi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICICS&apos;13</title>
		<meeting>of ICICS&apos;13</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="90" to="99" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Faster secure twoparty computation using garbled circuits</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Malka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of USENIX Security Symposium</title>
		<meeting>of USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">201</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Distinctive image features from scale-invariant keypoints</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Lowe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Computer Vision</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="91" to="110" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Fully homomorphic encryption from ring-lwe and security for key dependent messages</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Brakerski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of CRYPTO&apos;11</title>
		<meeting>of CRYPTO&apos;11</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="505" to="524" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Can homomorphic encryption be practical?</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naehrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Lauter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of CCSW&apos;11</title>
		<meeting>of CCSW&apos;11</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="113" to="124" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Fully homomorphic simd operations</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Smart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Vercauteren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Designs, codes and cryptography</title>
		<imprint>
			<biblScope unit="volume">71</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="57" to="81" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Multiparty computation from somewhat homomorphic encryption</title>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Pastro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Smart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zakarias</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of CRYPTO&apos;12</title>
		<meeting>of CRYPTO&apos;12</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="643" to="662" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">On private scalar product computation for privacy-preserving data mining</title>
		<author>
			<persName><forename type="first">B</forename><surname>Goethals</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Laur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lipmaa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mielikäinen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICISC&apos;04</title>
		<meeting>of ICISC&apos;04</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="104" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Efficient privacy-preserving k-nearest neighbor search</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Atallah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICDCS&apos;08</title>
		<meeting>of ICDCS&apos;08</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="311" to="319" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Caltech-256 object category dataset</title>
		<author>
			<persName><forename type="first">G</forename><surname>Griffin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Holub</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Perona</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A performance evaluation of local descriptors</title>
		<author>
			<persName><forename type="first">K</forename><surname>Mikolajczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Schmid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1615" to="1630" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Pca-sift: A more distinctive representation for local image descriptors</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sukthankar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of CVPR&apos;04</title>
		<meeting>of CVPR&apos;04</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="506" to="513" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Object retrieval with large vocabularies and fast spatial matching</title>
		<author>
			<persName><forename type="first">J</forename><surname>Philbin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Chum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Isard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sivic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zisserman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of CVPR&apos;07</title>
		<meeting>of CVPR&apos;07</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Improving the fisher kernel for large-scale image classification</title>
		<author>
			<persName><forename type="first">F</forename><surname>Perronnin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sánchez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mensink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ECCV&apos;10</title>
		<meeting>of ECCV&apos;10</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="143" to="156" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Aggregating local descriptors into a compact image representation</title>
		<author>
			<persName><forename type="first">H</forename><surname>Jégou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Douze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Schmid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pérez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of CVPR&apos;10</title>
		<meeting>of CVPR&apos;10</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="3304" to="3311" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Privacy of outsourced k-means clustering</title>
		<author>
			<persName><forename type="first">D</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Bertino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Asiaccs&apos;14</title>
		<meeting>of Asiaccs&apos;14</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="123" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">His research interests include crowdsourcing and cloud computing security. Zhan Qin is currently working toward his Ph.D. degree at the director of the Ubiquitous Security and Privacy Research Laboratory (UbiSeC) in the Computer Science and Engineering Department of the State University of New York at Buffalo. His research interests are in the areas of cloud computing and security, with focus on differential privacy data collection and publication, cybersecurity in smart grid. He is a student member of the IEEE, IEEE COMSOC, and ACM. Kui Ren is an Associate Professor of computer science at State University of New York at Buffalo. He received his PhD degree from Worcester Polytechnic Institute and both BE and ME degrees from Zhejiang University. Kui&apos;s research interests include Cloud Security, Wireless Security, and Smartphoneenabled Crowdsourcing Systems</title>
	</analytic>
	<monogr>
		<title level="m">His research has been supported by NSF, DoE, AFRL, MSR, and Amazon</title>
		<title level="s">Qian Wang is a Professor the School of Computer Science</title>
		<meeting><address><addrLine>China; China; China; China; China</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003">2014. 2003</date>
		</imprint>
		<respStmt>
			<orgName>Wuhan University ; Computer Science and Technology. He is currently a PhD candidate in the School of Computer Science in Wuhan University ; Wuhan University ; Shanghai Institute of Microsystem and Information Technology, Chinese Academy of Sciences ; Computer Science, Wuhan University</orgName>
		</respStmt>
	</monogr>
	<note>IEEE Transactions on Information Forensics and Security. a Distinguished Lecturer of IEEE Vehicular Technology Society, and a past board member of Internet Privacy Task Force, State of Illinois</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
