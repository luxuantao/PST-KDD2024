<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Managing Model Conflicts in Distributed Development</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Antonio</forename><surname>Cicchetti</surname></persName>
							<email>cicchetti@di.univaq.it</email>
							<affiliation key="aff0">
								<orgName type="department">Dipartimento di Informatica via Vetoio</orgName>
								<orgName type="institution">Università degli Studi dell&apos;Aquila</orgName>
								<address>
									<postCode>I-67010</postCode>
									<settlement>Coppito, L&apos;Aquila</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Davide</forename><forename type="middle">Di</forename><surname>Ruscio</surname></persName>
							<email>diruscio@di.univaq.it</email>
							<affiliation key="aff0">
								<orgName type="department">Dipartimento di Informatica via Vetoio</orgName>
								<orgName type="institution">Università degli Studi dell&apos;Aquila</orgName>
								<address>
									<postCode>I-67010</postCode>
									<settlement>Coppito, L&apos;Aquila</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alfonso</forename><surname>Pierantonio</surname></persName>
							<email>alfonso@di.univaq.it</email>
							<affiliation key="aff0">
								<orgName type="department">Dipartimento di Informatica via Vetoio</orgName>
								<orgName type="institution">Università degli Studi dell&apos;Aquila</orgName>
								<address>
									<postCode>I-67010</postCode>
									<settlement>Coppito, L&apos;Aquila</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Managing Model Conflicts in Distributed Development</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D09FB63539A9A7F03424D42439E24EAF</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T09:59+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The growing complexity of current software systems naturally conveyed their development toward incremental and distributed approaches to speed up the process. Several developers update the same artefact operating concurrent manipulations which need to be coherently combined. The interaction among those changes inevitably involves conflicts which must be detected and reconciled.</p><p>This paper proposes a domain specific language able to define and manage conflicts caused by cooperative updates over the same model elements. The approach relies on a model-based representation of model differences and enables the specification and the detection of both syntactical and semantic conflicts.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Software engineering projects are inherently cooperative, requiring many software engineers to coordinate their efforts to produce large systems <ref type="bibr" target="#b0">[1]</ref>. With models becoming more and more commonplace, the collaboration among software developers in a distributed environment must increasingly consider also the management of models lifecycle <ref type="bibr" target="#b1">[2]</ref>. For the collaboration based on software artefacts, version control systems are frequently used and play an important role among software engineers. However, the documents stored in these tools are almost code-level programs, and lack a reasonable organization and abstraction from designer's perspective. In this respect, merging documents representing modifications of models in a distributed environment is a challenging operation, both for its effectiveness and technical intricacy. In fact, every time modifications are merged, they may compete on the same resources giving place to conflict related issues. Conflicts can be distinguished into syntactic and semantic ones <ref type="bibr" target="#b2">[3]</ref>. The former refers to modifications which interfere from a syntactic point of view, e.g. two modifiers give in parallel two different names to the same model element. The latter consists of collisions which are implicit and cannot be inferred from the structure of the performed modifications only.</p><p>A number of works have been proposed to deal with the problem of conflict management (see Sect. 4 for a discussion); nevertheless, they are usually based on implicit mechanisms for conflict detection, i.e. an a priori evaluation to understand which problems can arise and what are the ones to be checked. This makes impossible to find a technique capable of an arbitrary accuracy <ref type="bibr" target="#b2">[3]</ref> and forces the designer to find a trade-off between false-positive and false-negative occurrences (in a similar way to e-mail spam filters).</p><p>This work proposes a conflict definition technique consisting of a domain-specific language able to specify both syntactic and semantic conflicts endowed with associated resolution criteria. To this end, difference models (already presented in <ref type="bibr" target="#b3">[4]</ref>) are used to represent modifications between subsequent versions of a model. Therefore, conflicts are formalized in terms of relations between difference models representing parallel and conflicting modifications. Arbitrary scenarios can be described enabling the identifications of semantics-related patterns usually neglected by the traditional structural-based methods. The aim is to pursue a flexible conflict management toward the support of domain specific versioning through customizable conflict sets.</p><p>The paper is organized as follows: Sect. 2 introduces the difference representation approach which underpins the proposed techniques. Next section illustrates the conflict specification metamodel and its application by means of a running example. Sect. 4 gives an overview of related works and finally, Sect. 5 draws some conclusions and presents possible perspective work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head><p>Increasingly, complex software systems are cooperatively designed in distributed environments and suitable techniques are required to detect and represent the various design modifications software systems undergo during their life-cycle. In the same way, changes performed in parallel need to be analyzed since they may cause conflicts which require to be managed.</p><p>This section recalls the technical background which underpins the approach proposed in this paper. In particular, Sect. 2.1 outlines the technique which is adopted in this work to represent model differences. The technique relies on suitable difference models which can be composed both in sequence and in parallel to represent more complex modifications as described in Sect. 2.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Representing Model Differences</head><p>The problem of model differences is intrinsically complex and requires specialized algorithms and notations <ref type="bibr" target="#b4">[5]</ref>. Encoding the relevant information about modifications as Fig. <ref type="figure">1</ref>. Overall structure of the model difference representation approach models allows the designer to derive from model differences powerful and interesting artefacts. In particular, they enable a wide range of possibilities, such as reconstructing the final model starting from an initial one, performing subsequent analysis, or detecting and manipulating conflicts. In this paper, model differences are represented according to the approach proposed in <ref type="bibr" target="#b3">[4]</ref> and illustrated in Fig. <ref type="figure">1</ref>: given two base models M 1 and M 2 which conform to an arbitrary base metamodel MM, their difference Δ conforms to a difference metamodel MMD derived from the former by means of an automated transformation MM2MMD. The approach does not impose any restriction over the metamodel MM, i.e. it is metamodel-independent and can be applied to any arbitrary modeling language as the simplified UML metamodel in Fig. <ref type="figure">2</ref>. In particular, the metamodel extension implemented in the MM2MMD transformation consists of adding new constructs able to represent the possible modifications that can occur on models that are additions, deletions, and changes. For instance, the application of the MM2MMD transformation to the sample UML metamodel in Fig. <ref type="figure">2</ref> produces the difference metamodel in Fig. <ref type="figure" target="#fig_6">3</ref>: essentially, for each metaclass MC of the source metamodel, the additional metaclasses AddedMC, DeletedMC, and ChangedMC are produced.</p><p>The generated difference metamodel is able to represent all the differences amongst models which conform to the base metamodel. For example, the instances of the new metaclass AddedClass in Fig. <ref type="figure" target="#fig_6">3</ref> can be used to represent additions of new classes in the initial model. In a similar way, the metaclasses which extend the Deleted one will be used to specify deletions of existing model elements. Interestingly, the difference metamodel is able to represent also model updates by means of instances of Changed elements. For instance, the visibility modification of the attribute mouse performed on the model M 1 in Fig. <ref type="figure" target="#fig_1">4</ref> leading to M 2 is represented in the upper side of the delta model in Fig. <ref type="figure" target="#fig_2">5</ref>.a by means of ChangedClass, ChangedAttribute, and ChangeOperation elements. Changed elements are also used in the difference model in Fig. <ref type="figure" target="#fig_2">5</ref>.b to represent the modifications performed in the model M 1 in Fig. <ref type="figure" target="#fig_1">4</ref> to obtain M 3 . In particular, a ChangedClass instance is defined to represent the changes affecting the class Mouse in which a new constructor has been added.</p><p>The difference representation mechanism introduced above satisfies a number of properties, as illustrated in <ref type="bibr" target="#b3">[4]</ref>. One of them is the applicability, i.e. difference models can be exploited to re-apply changes to arbitrary input models (see <ref type="bibr" target="#b3">[4]</ref> for further details) and for managing model co-evolution induced by metamodel manipulations <ref type="bibr" target="#b5">[6]</ref>. Another interesting property is the compositionality, that is the possibility to combine difference models by means of operators like the sequential and the parallel ones. This is crucial in cooperative environments where many software engineers have to coordinate their efforts to produce large software systems <ref type="bibr" target="#b0">[1]</ref>. In this respect, combining difference models can give place to conflict issues which need to be resolved, as discussed in the rest of the section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Composition of Model Differences</head><p>The evolution of a model consists of the initial specification and a number of difference models in such a way the final model can be obtained by applying all the modifications to the original one. In general, it can be convenient composing the difference models in order to obtain a unique one capturing all the occurred modifications. The composition can be performed in sequence and/or in parallel. In particular, if we consider only two subsequent modifications represented in the difference models Δ 1 and Δ 2 , their sequential composition corresponds to merging the modifications conveyed by the first document with the second one, i.e.</p><formula xml:id="formula_0">Δ = Δ 1 ; Δ 2<label>(1)</label></formula><p>with ";" the sequential composition operator. The resulting difference model contains a minimal difference set, i.e. only those modifications which have not been overridden by subsequent modifications. Interestingly, the representation technique has operators which are compositional, i.e. they are algebraically compatible with the induced transformations <ref type="bibr" target="#b3">[4]</ref>. More precisely, the transformation T Δ1 ; Δ2 induced by the composed difference model Δ 1 ; Δ 2 is completely defined by the transformations T Δ1 and T Δ2 , respectively, i.e.: </p><formula xml:id="formula_1">T Δ1 ; Δ2 = T Δ1 • T Δ2 (2)</formula><p>with ";" as before and • an appropriate composition operator among transformation, i.e. the functional composition of transformations. Sequential compositionality is always assured by the sequential independence condition (see <ref type="bibr" target="#b2">[3]</ref> for an extended discussion on the topic), i.e. when the modifications do not interfere with each other and can take place independently in any order. Parallel compositions are exploited to combine modifications operated from the same ancestor in a concurrent way. In case both manipulations are not affecting the same model elements they are said to be parallel independent and their composition is obtained by merging the difference models. More formally, two difference models Δ 1 and Δ 2 are parallel independent if the following condition holds</p><formula xml:id="formula_2">Δ 1 | Δ 2 = (Δ 1 ; Δ 2 ) + (Δ 2 ; Δ 1 )<label>(3)</label></formula><p>where "+" denotes the non determinist choice. In essence, their application is not affected by the adopted order since they do not present any interdependencies. Otherwise, Δ 1 and Δ 2 are referred to as parallel dependent since conflict issues arise which need to be detected and eventually resolved. This is the case of the sample modifications Δ 1,2 , and Δ 1,3 reported in Fig. <ref type="figure" target="#fig_2">5</ref>. In particular, Δ 1,2 represents the necessary modifications required to apply the singleton design pattern <ref type="bibr" target="#b6">[7]</ref> (which will be considered throughout the paper as explanatory example) to the first version of the class Mouse reported in Fig. <ref type="figure" target="#fig_1">4</ref>.a: the class constructor and the attribute mouse have been changed to private, and the new operation getInstance() has been added. The modifications represented in Δ 1,3 consist of the addition of the new constructor Mouse(posX: Integer, posY: Integer) keeping the rest of the model unchanged (see Fig. <ref type="figure" target="#fig_1">4</ref>.c).</p><p>According to (1) and (3), Δ 1,2 and Δ 1,3 in Fig. <ref type="figure" target="#fig_2">5</ref> are neither sequentially nor parallel independent. In fact, they interfere with the visibility of the attribute mouse and of the constructor Mouse(). In general, this kind of conflicts are called syntactic conflict (since the modifications interfere from a syntactical point of view) and there are a number of approaches which are able to detect them <ref type="bibr" target="#b2">[3]</ref>, even though their resolution generally requires manual interventions. For instance, according to <ref type="bibr" target="#b7">[8]</ref> in order to maintain the singleton modification, the conflicts can be resolved by applying Δ 1,3 and subsequently Δ 1,2 . In this way all the modifications are merged and the conflicting ones represented in Δ 1,3 are overwritten by those in Δ 1,2 leading to the target model in Fig. <ref type="figure" target="#fig_3">6</ref>.</p><p>Although all the syntactic conflicts have been resolved, the obtained model in Fig. <ref type="figure" target="#fig_3">6</ref> does not adhere to the singleton design pattern prescriptions. In fact, taking into account the semantics behind the singleton, the accessibility of the new constructor Mouse(posX: Integer, posY: Integer) breaks that design pattern principles. This is due to parallel changes which interfere on a level which concerns the underlying pattern semantics and that are not syntactically detectable. In particular, the addition of the new constructor specified in the model Δ 1,3 does not conflict with any modification represented in Δ 1,2 , even though it raises problems with respect to the semantic of the singleton design pattern. In general, this kind of conflicts are called semantic conflicts (according to the terminology in <ref type="bibr" target="#b2">[3]</ref>) and demand explicit techniques to support their specification as advocated in <ref type="bibr" target="#b2">[3]</ref>.</p><p>The rest of paper proposes an approach able to support semantic conflicts. In particular, the proposal is based on a meta-model to specify conflicts and corresponding resolution criteria, and to (partly) automate their parallel composition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">A Metamodel for Conflict Management</head><p>The mechanism proposed in this paper is inspired by the work in <ref type="bibr" target="#b8">[9]</ref>, where the authors introduce the Join Point Description Diagrams (JPPDs) which are a mechanism to locate modification points in the source code (called join points according to aspectoriented software development <ref type="bibr" target="#b9">[10]</ref> terminology) from the model abstraction level. Each join point is defined through a set of UML model element patterns, which can be directly mapped toward OCL expressions. In order to minutely pick up source code points such descriptions must be fine-grained, which makes the resulting pattern definition very powerful. In this respect, OCL is widely accepted as a model query language, and its usability and scalability benefits are discussed in <ref type="bibr" target="#b8">[9]</ref>.</p><p>This paper extends and adapts the mentioned mechanism introduced in order to define a conflict specification formalism which relies on a model-based pattern language endowed with constructs for resolution criteria descriptions. In the following, the details of the conflict specification language will be explained together with its semantics given in terms of OCL expressions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Representing Conflicts</head><p>Incompatibilities between parallel model modifications are precisely specified by means of conflict models relating left-and right-hand sides which represent not allowed contemporary matches. If one of them occurs, a conflicting situation has been found and needs to be solved. The reconciliation can be left to the manual intervention of developers, even if it could become a tedious and error prone task in the context of large systems. Besides, direct manipulation hides the rationale which guided the different choices. Therefore, we made it possible to attach resolution criteria by decorating the links between element patterns with reconciliation decisions.</p><p>An excerpt of the conflict specification metamodel is given in Fig. <ref type="figure" target="#fig_4">7</ref>: a Conflict Block groups a number of pattern boxes and relations between them. In order to have a valid specification at least two patterns and one ConflictRelation between them are needed. In other words, conflict models must contain at least a left-hand side and a right-hand side visualizing an undesired scenario. A PatternBox contains a number of DifferenceElements each of which can have some related MetaData, i.e. general information which is not intrinsic to the specific difference model like the creation/modification date, the author and so on. Since a difference element represents a pattern, its properties can be used to narrow the matching set if specified; moreover, a variable can be declared which will be bound if there is at least one match (boundVariableName). The importance of this variable is that it can be referred to by other patterns through its Negative patterns can be specified by means of the inverseSelection flag, which can be considered as the not boolean operator. Moreover, two or more element patterns can be combined for refinement purposes; by default, they are joined through AND relations, i.e. they have all to be matched. Whereas, by means of BooleanRestrictions it is possible to compose patterns by using different boolean operators. In this respect, precedences between boolean operators are established through the next association. Finally, the negativePattern flag in each ConflictLinkEnd can be activated to negate the selection of the referred PatternBox. When negativePattern is enabled (i.e. set to true) an interesting collision management scenario takes place, since it means that there is a problem if a given modification has not been performed. Consequently, mandatory manipulations can also be prescribed through the proposed approach. The conflicting scenarios can be given corresponding resolution criteria through ReconciliationStrategy, which states how each conflict should be resolved. Criteria are expressed by means of OCLExpressions <ref type="bibr" target="#b10">[11]</ref> and combine Rules, i.e. predicates in terms of Metadata information. In this paper, we focus on conflict specifications only, the interested reader can refer to <ref type="bibr" target="#b11">[12]</ref> for a detailed discussion about the definition of reconciliation strategies.</p><p>As already mentioned, conflict definitions are based on DifferenceElements. In particular, elements to be related are selected through the corresponding delta metaclasses obtained by means of the automated meta-model generation procedure illus-trated in Sect. 2.1. The dashed part in Fig. <ref type="figure" target="#fig_4">7</ref> shows how the current delta language is bound to the pattern. It has to be noted that AddedMC, DeletedMC and ChangedMC entities are used as placeholders of the current derived elements, as for example the AddedClass, ChangedClass and DeletedClass of the simplified UML metamodel shown in Fig. <ref type="figure">2</ref>. Moreover, three new meta-classes have been added to match all instances of a certain kind of manipulation, that are Added, Deleted and Changed. In summary, delta elements can be selected at different levels of granularity, like the kind of manipulation they represent, the portion of input model entities involved in the modifications and the specific values used to perform the revision.</p><p>The definition of the conflict metamodel, as customized for the particular source metamodel taken into account, has been automated through a model transformation (currently implemented in ATL <ref type="bibr" target="#b12">[13]</ref>) that takes as input the source metamodel and generates the corresponding conflict specification metamodel. For example, starting from the SimpleUML metamodel in Fig. <ref type="figure">2</ref> it is possible to automatically obtain the corresponding SimpleUMLCSpec metamodel, that is the appropriate conflict specification language. The description of the details of such transformation goes beyond the scope of this paper. However, it can be simply obtained by extending the mechanism for the difference metamodel derivation and the interested reader can find it for download at <ref type="bibr" target="#b13">[14]</ref>.</p><p>The obtained SimpleUMLCSpec conflict metamodel can be used to specify conflicts like the one depicted in Fig. <ref type="figure">8</ref> through the ConflictBlock element cb. For presentation purposes, the model is given as an object diagram which contains instances of the conflict metamodel even though alternative concrete syntaxes can be defined to have more human readable documents. The model specifies the singleton violation conflict which can be exploited to detect the semantic collision introduced in the previous section. In particular, it presents a collision in which two concurrent updates of a class (cC1 and cC2) bound to the cClass variable, do not converge to compatible results. Going deeper, the left pattern (see the pbLeft element named Singleton) captures the minimal updates required to introduce the singleton design pattern that can be summarized as follows: (i) the modifications which involve the visibility of the attribute containing the instances of the class itself, and that of the constructor (see the elements attr1 and opt1, respectively), and (ii) the addition of a new public operation which returns instances of the class (see the op2 operation named getInstance).</p><p>The right-hand side of the conflict specification (see the pattern box pbRight named Singleton violation) specifies some modifications which corrupt the requirements prescribed for the singleton design pattern. Hence, neither the constructor should be made public (see the cOp2 operation updated with the element op3), nor an additional public constructor should be added (see op4), nor the shared instance value should be made modifiable through a public attribute (see attr2). Such changes are grouped by means of the OR boolean operator represented by the restriction element. As said before, pattern entities are glued through an AND by default, which would require the contemporary matching of all the conditions. In this case it is sufficient that one of the three different updates is matched to violate the singleton pattern, or in other words to cause a collision with the left-hand side pattern box.</p><p>It is worth noting that this conflict definition abstracts from a particular class, whereas it refers to a generic situation where the singleton design pattern is introduced and in Fig. <ref type="figure">8</ref>. A model specifying the singleton violation conflict the mean time some concurrent delta corrupts that specific pattern. In this respect, it becomes evident the usefulness of bound variables, which can be exploited to refer to the particular values of the current matches (see the property boundVariableName of the elements cC1 and cC2).</p><p>The application of the model in Fig. <ref type="figure">8</ref> to the difference models in Fig. <ref type="figure" target="#fig_2">5</ref> detects the occurrence of a semantic conflict consisting of the singleton violation introduced by the model Δ 1,3 with respect to the differences represented in Δ 1,2 . In fact, by matching Δ 1,2 with the left pattern box in Fig. <ref type="figure">8</ref> and Δ 1,3 with the right one, a semantic conflict is identified and human interventions are required instead of generating models like the one in Fig. <ref type="figure" target="#fig_3">6</ref> (as current syntactical approaches do) which does not adhere to the singleton prescriptions.</p><p>The syntactic description of collisions has to be assisted by its semantics, in the same way difference metamodels induce transformations on input models. Therefore, in the following it is explained how to give precise meanings to conflict declaration models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Interpreting Conflict Models</head><p>The interpretation of conflict models induces the verification of co-existing updates in the input difference models Δ 1 and Δ 2 . Difference element patterns can be seen as model queries which are naturally expressed by OCL expressions, therefore, each model conforming to the metamodel shown in Fig. <ref type="figure" target="#fig_4">7</ref> can be translated into the corresponding OCL constructs (in a similar way to the approach given in <ref type="bibr" target="#b8">[9]</ref>), which interrogate the couple of concurrent manipulations to detect collisions and eventually to give them a reconciliation. It has to be noted that the matching procedure has to be founded on a minimal set of expected entities and related properties, which are provided by the meta metamodel.</p><p>Let ml and mr be the instances for Δ 1 and Δ 2 models, respectively. Then the general OCL rule to match patterns against input models can be formulated as follows:</p><p>1 c o n t e x t ConflictRelation : :   The function matchingPatternBoxes returns a collection of conflicting situation pairs by means of tuples; in turn, each tuple contains a sequence of elements resulting either from the left pattern (matchedL) or from the corresponding right pattern selection (matchedR). Firstly, left pattern matches are detected through the matchPBL function (see line 6); then, this collection of elements is exploited to look for matches on the right-hand side of conflict specification (lines 7-14). In particular, matchPBR is iterated on left matchings to detect corresponding elements on the right; if the returned set of elements is not empty, the computed pair of changes is appended as an entry in the current result. In this way, left selections allow to resolve variable bindings which have been eventually exploited in the right part too, while the right pattern ones are computed autonomously and are not intended to be used on the left-hand side. For example, the cClass variable shown in Figure <ref type="figure">8</ref> is bound at the beginning of the matching process and then its value is exploited to find the remaining correspondences. In this respect, each time a variable is bound its value is resolved wherever it has been referred to.</p><p>Both the function matchPBL and matchPBR detect correspondences in the same way, by starting with variables which need to be bound (if there exist) and then resolving the remaining portion of correspondences. Listing 1.2 shows a key OCL function called by matchPBL and matchPBR for selecting entities which match against a given difference pattern. More precisely, given a difference element pertaining to the model specifying conflicts, the matches OCL function looks for possible correspondences in the input difference document provided as parameter. Therefore, firstly potential matching metaclasses are selected (lines 7-14) and then the related set of structural features needs to be met (lines 16-43). Going into more details, for each outgoing Reference both its properties and the linked element have to match (lines <ref type="bibr" target="#b20">[21]</ref><ref type="bibr" target="#b21">[22]</ref><ref type="bibr" target="#b22">[23]</ref><ref type="bibr" target="#b23">[24]</ref><ref type="bibr">[25]</ref><ref type="bibr">[26]</ref><ref type="bibr">[27]</ref><ref type="bibr">[28]</ref><ref type="bibr">[29]</ref><ref type="bibr">[30]</ref><ref type="bibr">[31]</ref><ref type="bibr">[32]</ref><ref type="bibr">[33]</ref><ref type="bibr">[34]</ref><ref type="bibr">[35]</ref>. In an analogous manner, the remaining structural properties (i.e. attributes) have to be considered as new patterns to be matched through recursive calls (lines 37-38).</p><p>At the end of the outlined process, a sequence is returned; if it is empty then the matching computation failed, i.e. no conflicts have been found, otherwise it contains entities in the difference document which correspond to the patterns depicted in the conflict model. In this respect, the binding of variables is preserved implicitly by means of the DifferenceElement meta-class which allows to enrich a delta element with the declared bound variable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Related Works</head><p>This paper deals with colliding revisions of artefacts developed in parallel. Especially, it copes with interferences which can not be detected by means of syntactic analyses and are usually referred to as semantic conflicts <ref type="bibr" target="#b2">[3]</ref>. Those issues are considered in few works, which tend to provide support only to a particular modeling language (see <ref type="bibr" target="#b14">[15]</ref> for a detailed discussion). In this respect, the proposed technique can be considered as an extension of <ref type="bibr" target="#b15">[16]</ref> to arbitrary metamodels.</p><p>In <ref type="bibr" target="#b14">[15]</ref> the authors illustrate SMoVer, that is a model versioning tool able to deal with both syntax (structural) and semantic (behavioural) conflicts. In particular, the semantic issues are faced by exploiting appropriate view definitions toward which structural specifications are mapped. In other words, they use translational semantics in order to elicit particular interferences. With respect to our work, the mechanism in <ref type="bibr" target="#b14">[15]</ref> requires new domain characterizations to customize the set of the identified interferences. Moreover, conflicts are detected by comparing the whole concurrent revisions, whereas here collisions are managed taking into account only difference documents, i.e. only the elements involved by changes.</p><p>Composition of differences is partly considered in few works which mainly focus on software refactoring like <ref type="bibr" target="#b7">[8]</ref> and differences occurring on systems developed in parallel <ref type="bibr" target="#b16">[17]</ref>. In <ref type="bibr" target="#b7">[8]</ref> the authors propose a graph-based technique to discover couples of manipulation conflicts (critical pairs). Then, a set of conflict reduction heuristics is given, even if developers can not specify their own resolution criteria. The work in <ref type="bibr" target="#b16">[17]</ref> deals with differences occurring on systems developed in parallel; through the use of program slicing and system dependency graphs, semantic interferences are detected. However, the level of abstraction is too low with respect to models. In this respect, we presented an approach to raise the level of abstraction by reformulating part of the knowledges and experiences of these works in a model-driven setting.</p><p>A number of efforts deal with the general problems of consistency management and model composition; as software systems are specified by means of disparate notations related to different points of view of the same application, keeping the different documents coherent with each others is an unavoidable issue to take care of <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref>. In particular, consistency management is faced by defining a kind of conflicts between modifications occurring on the different views which are solved by propagating the changes toward newer coherent documents. However, in general these solutions are specifically designed for the problem domain they are applied in, like the UML diagrams and similar. Moreover, inconsistencies are always thought as existing between a pair of elements, while conflicts can be defined as ranging from a single and independent entity update to an arbitrary group of element manipulations. In summary, consistency management can be considered as a sub-problem of conflict issues.</p><p>In <ref type="bibr" target="#b19">[20]</ref> a set of common definitions are provided to outline the key requirements of a model composition solution, in terms of language and tool support. Moreover, in <ref type="bibr" target="#b20">[21]</ref> a number of operators for model integration are described and they have partially inspired the composition constructs proposed so far. Finally, other works take into account the specific issue of model merging, both in the case of different versions of a system design <ref type="bibr" target="#b21">[22]</ref> and in a generic scenario, like <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b23">24]</ref> for example. However, those papers seem to focus on establishing correspondences between elements of the input models (matching phase), while conflict troubles are largely missed out.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusions and Future Work</head><p>Increasingly, complex software systems are cooperatively designed in distributed environments and the interaction among concurrent manipulations inevitably causes conflicts which must be detected and reconciled.</p><p>This paper illustrated a model-driven conflict specification mechanism based on the declarative description of incompatibilities between competing difference models. In particular, a conflict metamodel has been proposed to specify conflict patterns between difference elements which cannot take place at the same time. This way, it is possible to introduce non-syntactical conflicts which usually would not be identified by merging approaches based on implicit conflict detection techniques. As a benefit, it is possible to improve conflict management adaptability to different application domains, since each domain has a set of its own semantic dependencies which need to be specified to obtain a useful detection and resolution method.</p><p>Future work will necessarily encompass further validation against large projects in order to evaluate the efforts demanded to the developer for managing model compositions. For example, the process could benefit of improved automation degree by taking into account heuristics and by-example approaches <ref type="bibr" target="#b14">[15]</ref>. Finally, an enhancement of the conflict specification language will be investigated for supporting multi-view consistency, which demands the description of change interferences between models not necessarily conforming to the same metamodel, and hence inducing disparate difference metamodels.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .Fig. 3 .</head><label>23</label><figDesc>Fig. 2. Sample UML metamodel</figDesc><graphic coords="3,97.14,464.19,223.66,113.56" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Sample model modifications</figDesc><graphic coords="5,101.03,53.81,225.12,147.18" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Sample delta models</figDesc><graphic coords="6,71.44,185.18,286.16,84.53" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Sample model TΔ 1,3 ;Δ 1,2 (M1)</figDesc><graphic coords="6,135.00,488.15,159.20,84.72" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. The conflict specification meta-model</figDesc><graphic coords="8,41.84,55.19,346.11,245.20" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>2 matchingPatternBoxes( ml : Sequence ( DifferenceElement ) ,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>3 mr:</head><label>3</label><figDesc>Sequence ( DifferenceElement ) ) : 4 Sequence ( TupleType ( matchedL : Sequence ( DifferenceElement) ,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>5 matchedR: 8 iterate ( 9 lm 18 ) 1 . 1 .</head><label>5891811</label><figDesc>Sequence ( DifferenceElement) ) ) 6 p o s t : result = 7 self . matchPBL ( ml , self . left )-&gt; ; res = Sequence {} | 10 l e t rightMatches = self . matchPBR ( lm , mr , self . right ) i n 11 if ( rightMatches-&gt;notEmpty ( ) ) Tuple{matchedL = lm , matchedR = rightMatches}) Listing The general OCL rule to match conflicting changes in parallel delta composition</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>1 c o n t e x t 3 Sequence 10 ( 11 ( 13 ( 45 )Listing 1 . 2 .</head><label>31011134512</label><figDesc>DifferenceElement : : matches ( de : 2 Sequence{DifferenceElement}) : ( DifferenceElement ) 4 pre : negate : Boolean = self . inverseSelection and 5 failed : Boolean = false 6 p o s t : result = mEl . oclIsTypeOf ( self . oclType ( ) ) and mEl . isAbstract = self . isAbstract or 12 self . isAstract . oclIsUndefined ) and mEl . name = self . name or 14 self . name = isUndefined ) ) res = Sequence {} | 22 if ( sF1 . oclIsTypeOf ( Reference ) ) oclIsTypeOf ( Reference ) and 28 ( sF1 . matchReference ( sF2 ) xor 29 negate@pre ) and 30 ( not sF1 . opposite . oclIsUndefined ( ) implies 31 ( ( sF1 . opposite . matchReference ( sF2 . opposite ) xor 32 negate@pre ) ) ) and 33 ( sF1 . type . matches ( sF2 . type )-&gt;notEmpty ( ) ) 34 )-&gt; 35 res-&gt;collect({ sF2 , sF1 . type . matches ( sF2 . type ) }) 36 and 37 res-&gt;isEmpty ( ) implies failed = true 38 else 39 res-&gt;collect ( sF1 . matches ( de . structuralFeatures) ) and 40 res-&gt;isEmpty ( ) implies failed = true 41 ) and 42 if ( not failed ) 43 then result-&gt;collect({ mEl , res}) 44 endif The general OCL rule to match a delta element pattern</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="10,41.94,55.60,345.20,319.81" type="bitmap" /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>K. Czarnecki et al. (Eds.): MoDELS 2008, LNCS 5301, pp. 311-325, 2008. c Springer-Verlag Berlin Heidelberg 2008</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Collaboration in software engineering: A roadmap</title>
		<author>
			<persName><forename type="first">J</forename><surname>Whitehead</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOSE 2007: 2007 Future of Software Engineering</title>
		<meeting><address><addrLine>Washington, DC, USA; Los Alamitos</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="214" to="225" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Favre</surname></persName>
		</author>
		<title level="m">Meta-Model and Model Co-evolution within the 3D Software Space. In: Procs. of the Int. Workshop ELISA at ICSM</title>
		<imprint>
			<date type="published" when="2003-09">September 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A State-of-the-Art Survey on Software Merging</title>
		<author>
			<persName><forename type="first">T</forename><surname>Mens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Softw. Eng</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="449" to="462" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A Metamodel Independent Approach to Difference Representation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cicchetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Di Ruscio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pierantonio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Object Technology</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="165" to="185" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Model Comparison: A Key Challenge for Transformation Testing and Version Control in Model Driven Software Development</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">OOPSLA Work. MDSD</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Automating co-evolution in modeldriven engineering</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cicchetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Di Ruscio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Eramo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pierantonio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th IEEE International EDOC Conference (EDOC 2008)</title>
		<meeting><address><addrLine>München (Germany</addrLine></address></meeting>
		<imprint/>
	</monogr>
	<note>to appear, 2008</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Design Patterns</title>
		<author>
			<persName><forename type="first">E</forename><surname>Gamma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Helm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vlissides</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Detecting Structural Refactoring Conflicts Using Critical Pair Analysis</title>
		<author>
			<persName><forename type="first">T</forename><surname>Mens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Taentzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Runge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electr. Notes Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">127</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="113" to="128" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A Graphical Notation to Specify Model Queries for MDA Transformations on UML Models</title>
		<author>
			<persName><forename type="first">D</forename><surname>Stein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hanenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Unland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MDAFA 2003</title>
		<editor>
			<persName><forename type="first">U</forename><surname>Aßmann</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Aks ¸it</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Rensink</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3599</biblScope>
			<biblScope unit="page" from="77" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Aspect-Oriented Software Development</title>
		<author>
			<persName><forename type="first">R</forename><surname>Filman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Elrad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Aksit</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">OMG): OCL 2.0 Specification</title>
		<idno>OMG Document formal/2006- 05-01</idno>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
		<respStmt>
			<orgName>Object Management Group</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Cicchetti</surname></persName>
		</author>
		<title level="m">Difference Representation and Conflict Management in Model-Driven Engineering</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
		<respStmt>
			<orgName>University of L&apos;Aquila, Computer Science Dept</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Transforming Models with ATL</title>
		<author>
			<persName><forename type="first">F</forename><surname>Jouault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Kurtev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MoDELS 2005</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Bruel</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">3844</biblScope>
			<biblScope unit="page" from="128" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Management of conflicts on the AMMA platform</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cicchetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Di Ruscio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pierantonio</surname></persName>
		</author>
		<ptr target="http://www.di.univaq.it/cicchetti/conflictManagement.php" />
		<imprint>
			<date type="published" when="2008-05">May 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Semantically Enhanced Conflict Detection between Model Versions in SMoVer by Example</title>
		<author>
			<persName><forename type="first">K</forename><surname>Altmanninger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bergmayr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Schwinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kotsis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Procs of the Int. Workshop on Semantic-Based Software Development at OOPSLA 2007, Montral, Canada</title>
		<meeting>s of the Int. Workshop on Semantic-Based Software Development at OOPSLA 2007, Montral, Canada</meeting>
		<imprint>
			<date type="published" when="2007-10">October 2007</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Weaving models in conflict detection specifications</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cicchetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rossini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Procs of the ACM Symposium on Applied Computing (SAC 2007), Model Transformation track</title>
		<meeting>s of the ACM Symposium on Applied Computing (SAC 2007), Model Transformation track<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="1035" to="1036" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Parallel Changes: Detecting Semantic Interferences</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">L</forename><surname>Thione</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Perry</surname></persName>
		</author>
		<editor>COMP-SAC</editor>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>IEEE Computer Society</publisher>
			<biblScope unit="page" from="47" to="56" />
			<pubPlace>Los Alamitos</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Fixing Inconsistencies in UML Design Models</title>
		<author>
			<persName><forename type="first">A</forename><surname>Egyed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Procs. of the 29th ICSE 2007</title>
		<meeting>s. of the 29th ICSE 2007<address><addrLine>Los Alamitos</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="292" to="301" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Consistency Management with Repair Actions</title>
		<author>
			<persName><forename type="first">C</forename><surname>Nentwich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Emmerich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Finkelstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Procs. of the 25th ICSE 2003</title>
		<meeting>s. of the 25th ICSE 2003<address><addrLine>Los Alamitos</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2003-10">May 3-10. 2003</date>
			<biblScope unit="page" from="455" to="464" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A Canonical Scheme for Model Composition</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bézivin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bouzitouna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D D</forename><surname>Fabro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Gervais</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Jouault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kolovos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Kurtev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Paige</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECMDA-FA 2006</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Rensink</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Warmer</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4066</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Model Integration Through Mega Operations</title>
		<author>
			<persName><forename type="first">T</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kapsammer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Retschitzegger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wimmer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on MDWE 2005</title>
		<imprint>
			<date type="published" when="2005-07">July 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Merging Models with the Epsilon Merging Language (EML)</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Kolovos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">F</forename><surname>Paige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Polack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MoDELS 2006</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Nierstrasz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Whittle</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Reggio</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4199</biblScope>
			<biblScope unit="page" from="215" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Using a Model Merging Language for Reconciling Model Versions</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">D</forename><surname>Engel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">F</forename><surname>Paige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Kolovos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECMDA-FA 2006</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Rensink</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Warmer</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4066</biblScope>
			<biblScope unit="page" from="143" to="157" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Merging Models Based on Given Correspondences</title>
		<author>
			<persName><forename type="first">R</forename><surname>Pottinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="826" to="873" />
		</imprint>
		<respStmt>
			<orgName>VLDB</orgName>
		</respStmt>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
