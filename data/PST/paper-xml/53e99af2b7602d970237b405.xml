<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The SPARK Agent Framework</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">David</forename><surname>Morley</surname></persName>
							<email>morley@ai.sri.com</email>
							<affiliation key="aff0">
								<orgName type="department">Artificial Intelligence Center, SRI International</orgName>
								<address>
									<addrLine>333 Ravenswood Ave</addrLine>
									<postCode>94025</postCode>
									<settlement>Menlo Park</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Karen</forename><surname>Myers</surname></persName>
							<email>myers@ai.sri.com</email>
							<affiliation key="aff0">
								<orgName type="department">Artificial Intelligence Center, SRI International</orgName>
								<address>
									<addrLine>333 Ravenswood Ave</addrLine>
									<postCode>94025</postCode>
									<settlement>Menlo Park</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">The SPARK Agent Framework</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">BFA908A5B49BE48AA03276F899CFB0B4</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T10:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>There is a need for agent systems that can scale to realworld applications, yet retain the clean semantic underpinning of more formal agent frameworks. We describe the SRI Procedural Agent Realization Kit (SPARK), a new BDI agent framework that combines these two qualities.</p><p>In contrast to most practical agent frameworks, SPARK has a clear, well-defined formal semantics that is intended to support reasoning techniques such as procedure validation, automated synthesis, and procedure repair. SPARK also provides a variety of capabilities such as introspection and meta-level reasoning to enable more sophisticated methods for agent control, and advisability techniques that support user directability. On the practical side, SPARK has several design constructs that support the development of large-scale agent applications.</p><p>SPARK is currently being used as the agent infrastructure for a personal assistant system for a manager in an office environment.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Numerous agent frameworks have been published in the literature in recent years. These frameworks can be categorized into two groups with very distinctive characteristics.</p><p>The first group consists of the formal agent frameworks that provide elegant, semantically grounded models of agent behavior (e.g., AgentSpeak(L) <ref type="bibr" target="#b17">[18]</ref>, Golog/ConGolog <ref type="bibr" target="#b7">[8]</ref>, and 3APL <ref type="bibr" target="#b8">[9]</ref>). The semantic underpinnings of these models enable formal reasoning about current and potential agent activity to ensure that the agent meets appropriate criteria for correctness and well-behavedness. Applications of these frameworks have generally been to test problems that illustrate features of the design, rather than to real-world problems.</p><p>The second group consists of agent frameworks that have been designed to support demanding applica-tions (e.g., PRS <ref type="bibr" target="#b10">[11]</ref>, PRS-Lite <ref type="bibr" target="#b12">[13]</ref>, JAM <ref type="bibr" target="#b9">[10]</ref>, RAPS <ref type="bibr" target="#b4">[5]</ref>, dMARS <ref type="bibr" target="#b3">[4]</ref>, and JACK <ref type="bibr" target="#b1">[2]</ref>). These frameworks are more practical in nature, generally providing much more expressive mechanisms for encoding and controlling agent behavior to meet the requirements of their motivating applications. This increased sophistication, however, has generally come at the cost of formal grounding, with the systems taking on the character of general-purpose programming environments that are not amenable to formal analysis.</p><p>Our background lies primarily with agent frameworks in the second category. However, our efforts to deploy such frameworks in challenging applications (e.g., real-time tracking <ref type="bibr" target="#b6">[7]</ref>, mobile robots <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b12">13]</ref>, crisis action planning <ref type="bibr" target="#b19">[20]</ref>, intelligence gathering <ref type="bibr" target="#b14">[15]</ref>, air operations <ref type="bibr" target="#b13">[14]</ref>) has made clear to us the need to be able to support formal reasoning about both the agent's knowledge and its execution state. These capabilities are essential for system validation, effective awareness of the current situation, and the ability to project into the future. Thus, an ideal agent system should combine the sophisticated representations and control of the more practical systems with principled semantics that enable reasoning about system behavior.</p><p>These requirements have motivated us to develop a new agent framework called SPARK (the SRI Procedural Agent Realization Kit) that attempts to combine the best of both worlds. SPARK builds on a Belief-Desire-Intention (BDI) model of rationality <ref type="bibr" target="#b18">[19]</ref> that has been heavily influenced by the PRS family of agent systems. SPARK provides a flexible plan execution mechanism that interleaves goal-directed activity and reactivity to changes in its execution environment. In contrast to the representations typically found in most practical agent systems, SPARK's procedural language has a clear, well-defined formal semantics that can support reasoning techniques for procedure validation, synthesis, and repair.</p><p>SPARK also contains a number of features and capabilities to support its use in constructing large-scale agent applications in rich and dynamic domains. On the conceptual side, these include an expressive procedure language with a range of control structures, a powerful introspective capability, rich metalevel control, and an ability to support high-level user directability of agent activity. On the engineering side, the execution model and treatment of variables facilitate integration with external components. They also allow for a range of implementations from short-timescale reactive control systems to long-timescale workflow systems. Other features motivated by practicality include a module system, a well-defined failure mechanism, the ability to adapt behavior at runtime, and an integrated development environment (IDE) based on Eclipse <ref type="bibr" target="#b16">[17]</ref>.</p><p>This paper provides a high-level overview of SPARK's design. Sections 2, 3, and 4 outline the SPARK architecture, language, and semantic model respectively. Section 5 explores some of the advanced features of SPARK (including the meta-level and agent guidance). Section 6 describes the balance between formal and practical concerns in the system. Section 7 describes a current use of SPARK as the basis for an intelligent personal assistant designed to improve the productivity of a manager-level office worker. Finally, Section 8 compares SPARK with other agent systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">SPARK</head><p>Figure <ref type="figure">1</ref> depicts the overall architecture for a SPARK agent. Each agent maintains a knowledge base (KB) of beliefs about the world and itself that is updated both by sensory input from the external world and by internal events. The agent has a library of procedures that provide declarative representations of activities for responding to events and for decomposing complex tasks into simpler tasks. At any given time the agent has a set of intentions, which are procedure instances that it is currently executing. The hierarchical decomposition of tasks bottoms out in primitive actions that instruct effectors to bring about some change in the outside world or the internal state of the agent. At SPARK's core is the executor whose role is to manage the execution of intentions. It does this by repeatedly selecting one of the current intentions to process and performing a single step of that intention. Steps generally involve activities such as performing tests on and changing the KB, adding tasks, decomposing tasks by applying procedures, or executing primitive actions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Language Constructs</head><p>The specification of a SPARK agent consists of declarations of constant, function, predicate, and action symbols, together with facts that give the initial state of extensional predicates and procedures that define how to respond to events. The key syntactic structures are term expressions, logical expressions, actions, task expressions, and procedures.</p><p>A term expression, ν, represents a value. Atomic term expressions are constants such as 42, "Hi", and pi, and variables of the form $x. These are combined to form compound term expressions, including lists (e.g., [1 2 3]), function applications (e.g., (-$x 1)), and closures (e.g., {fun [$x] (-$x 1)}). Closures represent parameterized term, logical, and task expressions that can be passed around as first-order values.</p><p>A logical expression, φ, is constructed from predicate symbols applied to term expressions (e.g., (p 1 $x)), logical operators (e.g., (not (q)), (and (q) (r)), (or (q) (r))), and existential quantifiers (e.g., (exists [$x $y] (p $x $y))). In SPARK, the testing of a logical expression binds previously unbound variables to values that make the expression true.</p><p>An action, α, is constructed from an action symbol and term expressions as parameters (e.g., (send $authorization bill)). The action may be a primitive action, in which case it is performed by executing some procedural attachment, or a nonprimitive action, in which case procedures describe how to hierarchically decompose the action into subtasks.</p><p>A task expression, τ , is an activity that when attempted may either succeed or fail. Tables <ref type="table" target="#tab_1">1</ref> and<ref type="table" target="#tab_2">2</ref> summarize SPARK's task expressions (simplified somewhat for the sake of presentation). The basic task expressions include trying to perform some action and trying to bring about or "achieve" the truth of some atomic logical expression if it is not already true. The compound task expressions are constructed from basic task expressions using task operators. In each of the compound task expressions (with the sole exception of τ in [try: τ τ 1 τ 2 ]) if one of the component task expressions fails then the compound task expression then fails. Also, each test of a condition φ is intended to remain valid up to the start of execution of the appropriate task expression. For example, at the time [while: φ τ 1 τ 2 ] starts [conclude: φ] Add fact φ to the KB.</p><p>[retract: φ] Remove facts matching φ from the KB.</p><p>[do: α] Perform the action α. [achieve: φ] Attempt to make φ true. At its simplest, a SPARK procedure has the form {defprocedure name cue: event precondition: φ body: τ }. This indicates that if φ is true when event occurs, then executing τ is a valid way of responding. The cue event may be of the form [newfact: φ] to respond to the fact φ being added to the KB, or [achieve: φ] or [do: α] to respond to a new task. The procedure in Figure <ref type="figure">2</ref> specifies that whenever a fact of the form (order $id $user $item) becomes true, where $item is expensive and $user's boss is $boss, then the action (inform $boss $id) should be performed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Semantics</head><p>The cognitive state of an agent at any time is given by its KB and a set of active procedure instances called the intention structure. We model the task expressions that form the bodies of procedures by finite state machines (FSMs). This allows us to model the intention structure by a set of FSM instances, one per intended procedure instance. Each {defprocedure "PlaceOrder" cue: [newfact: (order $id $user $item)] precondition: (and (Expensive $item) (Supervisor $user $boss)) body: [do: (inform $boss $id)]}</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 2. An Example Procedure</head><p>FSM instance is an FSM plus an FSM state (abbreviated to state where unambiguous) indicating the current execution state of that FSM.</p><p>Both sensory input and procedure execution can change the state of the KB, which in turn can cause new procedure instances to be added to the intention structure. The dynamics of an agent are modeled by transitions on the KB and intention structure models. Hierarchical task expansion is modeled as assertions of "desires" into the KB that trigger the addition of new FSM instances. On completion of these FSM instances, the KB is updated to record their success or failure. For primitive actions, we do not explicitly model the action of the effectors. Instead we assume that the effectors are triggered by the existence of the "desires" and that the success or failure of the actions is recorded by sensory input.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">KB Semantics</head><p>An agent's KB is a set of ground literals. A ground literal is considered true with respect to the KB if and only if it is an element of that set. We evaluate the truth of a logical expression, given an assignment of values to free variables, in the standard way. KB changes are simple additions and deletions of ground literals.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Task Expressions as State Machines</head><p>Each task expression, τ , is interpreted as an FSM, or more precisely a family of FSMs equivalent under state renaming. Each transition of the FSM is labeled with guard conditions that test the KB and effects that modify the KB. The set of FSM state names, Σ, includes the distinguished states:</p><formula xml:id="formula_0">σ • the initial state σ + the success state σ -the failure state.</formula><p>An FSM, M , is defined to be a set of transitions, each of the form σ s c| e</p><formula xml:id="formula_1">-→σ t where σ s ∈ Σ \ {σ + , σ -} is the source state; σ t ∈ Σ \ {σ • } is the target state; c = c 1 ...c n is</formula><p>a sequence of conditions of the form c i = φ or φ where φ is a logical expression; and e is a sequence of effects of the form ψ or ψ where ψ is an atomic logical expression. ε denotes an empty condition sequence or effect sequence.</p><p>The FSM {σ • ε| e -→σ + } is so common that we abbreviate it as M e . A transition is allowed if all conditions φ are true with respect to the KB at the time of the transition and all conditions φ are not true.</p><p>Note that uniformly renaming the nondistinguished states in an FSM yields a new FSM that is functionally identical to the original. We will use an individual FSM, M , to represent the equivalence set |τ | of identical FSMs corresponding to a task expression, τ , writing M = |τ | rather than M ∈ |τ |.</p><p>To define the FSMs corresponding to compound task expressions, we introduce the following operators.</p><p>• φ::M prepends the condition φ to the conditions of each transition in M leading from the initial state, σ • . • [σ] M replaces all occurrences of σ • with σ.</p><p>• M σ replaces all occurrences of σ + with σ.</p><p>• M σ replaces all occurrences of σ -with σ.</p><p>• M 1 ∪ M 2 contains all transitions from both M 1 and M 2 where the states of M 1 and M 2 , other than the distinguished states and those explicitly introduced, have been uniformly renamed to ensure that they are disjoint.</p><p>We can now specify the subset of possible FSMs that correspond to SPARK task expressions. We require the following three well-behavedness conditions on such FSMs: (i) σ • has only outgoing transitions, (ii) for any KB state at least one outgoing transition from σ • must be allowed, (iii) σ + and σ -are the only states that have no outgoing transitions.</p><formula xml:id="formula_2">• |[noop:]| = {σ • ε|ε -→σ + } = M ε</formula><p>There is a single transition from the initial state to the success state with an empty condition list and no effect on the KB.</p><formula xml:id="formula_3">• |[fail:]| = {σ • ε|ε -→σ -}</formula><p>There is a single transition from the initial state to the failure state with no effect on the KB.</p><formula xml:id="formula_4">• |[conclude: ψ]| = {σ • ε|ψ -→σ + } = M ψ</formula><p>There is a single transition from the initial state to the success state with an empty condition list and the effect of adding ψ to the KB.</p><formula xml:id="formula_5">• |[retract: ψ]| = {σ • ε| ψ -→σ + } = M ψ</formula><p>There is a single transition from the initial state to the success state with an empty condition list and the effect of removing ψ from the KB if it is present.</p><formula xml:id="formula_6">• |[do: α]| = {σ • ε|(d α) -→ σ, σ (s α)|ε -→ σ + , σ (f α)|ε</formula><p>-→ σ -} The desire to perform action α is posted by asserting (d α) into the KB. The FSM then waits in state σ until either the success (s α) or failure (f α) of the action has been reported.</p><formula xml:id="formula_7">• |[achieve: φ]| = {σ • φ|ε -→σ + , σ • φ|(d φ) -→ σ, σ (s φ)|ε -→ σ + , σ (f φ)|ε</formula><p>-→ σ -} Here the desire to achieve φ is posted only if the condition φ is not already satisfied. is added to those of |τ 2 |. Note that rather than sequentially performing the test and then executing the appropriate task expression, we instead require the appropriate condition, φ or φ, to hold at the time τ 1 or τ 2 performs its first transition, thus eliminating the possibility of something changing the truth of φ between the test and the task execution. This provides an important transactional capability that many agent systems lack.</p><formula xml:id="formula_8">• |[seq: τ 1 τ 2 ]| = |τ 1 | σ ∪[σ] |τ 2 |</formula><formula xml:id="formula_9">• |[try: τ τ 1 τ 2 ]| = |τ | σ 1 σ 2 ∪[σ 1 ] |τ 1 |∪[σ 2 ] |τ 2 |</formula><p>where </p><formula xml:id="formula_10">(ii). • |[while: φ τ 1 τ 2 ]| = M ε σ ∪ [σ] φ::|τ 1 | σ ∪ [σ] φ::|τ 2 |</formula><p>where there is an initial transition to an internal state σ at which point, if φ is true, τ 1 will be executed returning to σ; otherwise τ 2 will be executed. The initial M ε transition exists to satisfy wellbehavedness condition (i).</p><p>For simplicity in this paper, we have restricted the above semantic model of SPARK task expressions to atomic term expressions (i.e., no closures, list, or functions) and we have ignored the housekeeping involved in managing different "do" and "achieve" task instances. We have skipped the semantics for tasks of the form [parallel: τ 1 τ 2 ] due to the complexity of treating failed subtasks.</p><p>We have also not described the treatment of free variables. Allowing free variables requires extending the execution state of the FSM to include a set of variable bindings, mapping variables to values. Roughly speaking, a transition is allowed if there is a set of variable bindings consistent with the existing variable bindings that makes the positive transition conditions true. When a transition is performed, one of the possible sets of bindings is selected and those variable bindings are added to the execution state of the FSM. In this way, the set of variable bindings grows progressively as the FSM is executed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Execution Semantics</head><p>The execution of an agent consists of repeatedly processing sensory input, stepping procedure instances, and dropping completed procedure instances. Each of these activities can change the KB, which in turn can cause new procedure instances to be added to the intention structure.</p><p>We model the application of changes e to a KB by the function K = apply( e, K) that adds or removes atomic facts atomic facts from K as required. We model the intention structure by a set of FSM instances, being pairs of an FSM and an FSM state, I = { M 1 , σ 1 ... M k , σ k }. The consequential changes to the intention structure caused by a change in the KB are then modeled by a set of FSM instances to be added to the intention structure, calculated as follows.</p><p>Given a set of procedures, a function appl(K , φ) determines a set of applicable FSMs {M 1 , ..., M n } that could be intended when a fact φ has been added to produce the new KB K . We collect the FSMs M i = |τ i | derived from the body τ i of each procedure whose cue matches φ and whose precondition is satisfied by K . The cue [do: α] matches (d α), [achieve: φ ] matches (d φ ), and [newfact: φ] matches anything else.</p><p>A selection function, select(appl(K , φ), K , φ) determines which of these FSMs get added to the intention structure. The default selection function acts as follows, depending upon whether φ is (i) a desire to perform a nonprimitive action (d α) or to achieve a condition (d φ ), or (ii) some other new fact.</p><formula xml:id="formula_11">(i) If appl(K , (d x)) is empty, a "failure" FSM M (f x) is added.</formula><p>Otherwise, a single FSM is selected randomly.</p><p>(ii) All FSMs in appl(K , φ) are used.</p><p>The change-inducing steps in the execution of an agent can be modeled by a fair interleaving of the following operations on KB and intention structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Sensory Input applies a set of changes to the KB.</head><p>Task Execution selects an FSM instance M, σ ∈ I with a transition σ c| e -→σ that is allowed in K. The state of the FSM instance is updated I = (I \ { M, σ }) ∪ { M, σ } before the changes e are made.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Task Removal selects a completed FSM instance</head><p>M, σ ∈ I where σ ∈ {σ + , σ -} and removes it: I = I \ { M, σ }. If the FSM was for a desire (d x) the appropriate fact (s x) or (f x) is added to the KB.</p><p>Each of these steps is immediately followed by the addition of FSM instances M, σ • for each M ∈ select(appl(K , φ), K , φ)} where φ has become true (i.e., φ ∈ K \K).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Reflective Capabilities / Advanced Features</head><p>SPARK provides two introspective capabilities (influenced heavily by concepts in PRS) that endow each agent with a level of "self-awareness" of its own execution state. One capability is a set of predicates and actions that provide access to an agent's intention structure. The second capability is a set of meta-predicates that track significant execution events, including the existence of multiple candidate procedure instances for a task, and the successful or failed completion of a task. The value of these meta-predicates is that they can be used to trigger meta-procedures for modifying system behavior. Examples of current usage of such meta-procedures within SPARK are given below.</p><p>• Meta-predicates can trigger the logging of information about the agent's state and progress of execution.</p><p>• Customized failure response can be achieved through meta-procedures that respond to task failure metapredicates.</p><p>• The default procedure selection mechanism (Section 4.3) can be replaced by alternatives. For example, meta-level procedures can be used to select between the applicable procedures on the basis of advice supplied by the user. More sophisticated meta-level predicates might be used to indicate that a new procedure is required and request one from the user, or from a planning or reasoning system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Agent Guidance</head><p>One unique feature of SPARK is its built-in capability to support directability of an agent through userspecified guidance. This guidance, which is represented as a set of declarative policies, can be used to explicitly bound the activities that an agent is allowed to perform without user involvement. Guidance is expressed in a high-level language that shields the user from having to know the details of the system's underlying knowledge or its execution state at any point in time.</p><p>Guidance could be defined from the perspective of either explicitly enabling or restricting agent activities. We are interested in domains where agents will generally need to operate with high degrees of autonomy. For this reason, we assume a permissive environment: unless stated otherwise, agents are allowed to operate independently of human interaction. In this context, guidance is used to limit the scope of activities that can be performed autonomously. Activities outside that set may still be performable, but require some form of interaction with the user. SPARK supports two types of guidance: strategy preference and adjustable autonomy (see <ref type="bibr" target="#b15">[16]</ref> for details).</p><p>Guidance for strategy preference comprises recommendations on how an agent should accomplish tasks. These preferences could indicate specific procedures to employ or restrictions on procedures that should not be employed, as well as constraints on how plan variables can be instantiated. For example, the directive "Use Expedia to find options for flying to Washington next week" expresses a preference over approaches to finding flight information for planning a particular trip. On the other hand, the directive "Don't schedule project-related meetings for Monday mornings" restricts the choice for instantiating parameters that denote project meeting times.</p><p>Guidance for adjustable autonomy enables a supervisor to vary the degree to which agents can act without human intervention. This form of guidance can be used to force the agent to seek permission for executing designated procedures (e.g., "Obtain permission before making any revisions to my schedule") and to require that the user be consulted for certain decisions such as instantiating variables or selecting among alternative procedures (e.g., "Consult me when deciding how to respond to requests to cancel staff meetings").</p><p>Guidance can be asserted and retracted throughout the scope of an agent's operation, thus providing the means to tailor agent behavior dynamically in accord with a user's changing perspective on what he or she feels comfortable delegating to the agent. This comfort level may change as a result of the user acquiring more confidence in the agent's ability to perform certain tasks, or the need for the user to focus his problem-solving skills on more important matters.</p><p>Guidance is implemented through meta-level procedures that test properties associated with tasks, procedures, and actions. Two key properties used in specifying advice and guidance are features and roles. Features identify characteristics of procedures and actions (e.g., "COM-MUNICATIVE"), whereas roles identify how particular parameters are used within an action (e.g., "RECIPIENT" parameter of a "SEND EMAIL" action).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Balancing Formal and Practical Concerns</head><p>SPARK has been designed as a framework to support the development of real-world agent systems. That requirement has led to the inclusion of several capabilities within SPARK geared toward practical concerns. In addition, our experience with applications has made clear the need for a well-defined semantics for both an agent's knowledge and its execution model to enable various forms of reasoning about the agent and its capabilities. To date, we have concentrated on the practical aspects of the framework, as described in Section 6.1. Our work on the formal side has been limited to implementing the foundations to support the future reasoning capabilities described in Section 6.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Practical Features</head><p>The main practical concerns that have driven the development of SPARK are ease of integration, scalability, failure handling, and developer support.</p><p>SPARK's treatment of predicates and logical variables allows a logic-based interpretation of its task repre-sentation as required to support reasoning about procedures. However, SPARK does not use full unification as in other logic-based languages, but rather a restricted form of pattern matching. As a consequence, data values in SPARK are always fully instantiated, eliminating the need for variable dereferencing or explicit unbinding of variables. The benefits include a simpler implementation and easier integration of SPARK with external components written in procedural, functional, and object-oriented programming languages, without sacrificing logical semantics.</p><p>The language and execution models of SPARK were designed to allow diverse implementations covering different timescales. The current implementation of SPARK is as an interpreter written in Python. Python was chosen for its rapid prototyping capabilities, open source implementation, and ability to compile to the Java Virtual Machine via Jython (facilitating SPARK's integration with systems such as OAA <ref type="bibr" target="#b2">[3]</ref> and SHAKEN <ref type="bibr" target="#b0">[1]</ref>). By suitably restricting SPARK higher-level constructs, it is feasible to compile SPARK into efficient code in target languages such as C and C++ that could be used for applications requiring fast response times (e.g., robot control).</p><p>The semantic model of SPARK's if:, try:, and wait: constructs provides much finer control over failure handling and race conditions than its predecessor, PRS, and does this in a way that is well-grounded formally. The concept of failure is fundamental within the finite state machine model of SPARK execution. More research is required into different ways of specifying failure recovery, but the existing SPARK language constructs and formal model provide a good starting point.</p><p>For modularity, SPARK uses a hierarchical namespace for functions, predicates, actions, and constants. This simplifies both the parallel development of agent knowledge and the reuse of knowledge, both of which are critical for large-scale applications.</p><p>For developer support, SPARK has an IDE built on top of IBM's Eclipse Platform <ref type="bibr" target="#b16">[17]</ref>. The IDE provides editing and debugging capabilities, with access to the internal state of execution of SPARK agents.</p><p>In the future, we plan to extend SPARK with a number of additional practically-motivated capabilities: a type system for static and dynamic type checking; compilation into a variety of target languages; the ability to have procedures persisting over very long times, with the ability to recover after machine crashes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Formal Reasoning</head><p>Two main challenges motivate the need for formal reasoning within an agent system: knowledge modeling and self-awareness.</p><p>Knowledge modeling refers to the formulation of the activity knowledge that an agent uses to respond to stim-uli (events, tasks) within its operating environment. Formulating procedural representations of activity knowledge, as required by SPARK, presents a significant modeling challenge. Current practice mostly relies on the handcrafting of such knowledge -a practice that is both time-consuming and error-prone. The use of a formally grounded representation framework can help to address the knowledge modeling problem by enabling three types of reasoning. First, verification and validation techniques can be applied to identify shortcomings in handcrafted knowledge. Second, procedure synthesis techniques can be used (in some cases) to generate composite procedures from descriptions of possible activities. Third, learning methods can be used to adapt existing procedural knowledge to handle unexpected situations that arise at runtime. Our future work will explore how to provide such reasoning services within SPARK.</p><p>Self-awareness refers to an agent's ability to introspect on its own knowledge and activities to understand its operation. As agent systems grow in complexity, selfawareness is essential to ensuring appropriate agent execution. The introspective and meta-level capabilities within SPARK provide a strong foundation upon which to build self-awareness functionality. Currently, we are developing three capabilities of this type. Temporal projection supports the ability to reason into the future based on a formal representation of an agent's objectives, commitments, and knowledge, to ensure that objectives can be met and undesirable consequences avoided; temporal projection is critical to ensuring that local decisions made by an agent are consistent with long-term objectives. Explanation of agent activity is necessary when agents operate on behalf of a human, and so must be able to justify their actions to him or her. Recognition of knowledge limits is essential to ensuring that an agent does not undertake activities that lie beyond the scope of its problem-solving abilities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">SPARK-based Personal Assistant</head><p>SPARK provides general-purpose agent technology for a range of domains that require reactive task execution. To date, the driving application for SPARK has been the development of an intelligent personal assistant for a high-level knowledge worker. This assistant, called CALO, will be able to perform routine tasks on behalf of its user (e.g., arrange meetings, complete online forms, file email), as well as undertake open-ended processes (e.g., purchasing a computer online), and anticipate future needs of its user.</p><p>At the heart of CALO is a SPARK-based task manager that initiates, tracks, and executes activities and commitments on behalf of its user, while remaining responsive to external events. The task manager is capable of fully autonomous operation (i.e., for tasks that are delegated completely by the user), but can also operate in a mixed-initiative fashion when the user prefers to be more involved in task execution. The desired level of autonomy can be specified by the user through SPARK's guidance mechanisms (see Section 5.1).</p><p>To date, task manager development has focused on managing the user's calendar, performing certain routine tasks (e.g., email management), and supporting computer purchases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Comparison to Other Agent Frameworks</head><p>At the theoretical end of the spectrum of agent languages there are logic-based agent languages, such as AgentSpeak(L) <ref type="bibr" target="#b17">[18]</ref>, Golog/ConGolog <ref type="bibr" target="#b7">[8]</ref>, and 3APL <ref type="bibr" target="#b8">[9]</ref>, that were designed primarily to have well-defined formal properties. These do not scale well for use in building large applications that need to integrate with and control other systems.</p><p>At the other extreme lie commercial agent development systems such as JACK <ref type="bibr" target="#b1">[2]</ref>. The JACK Agent Language is an extension of Java that incorporates agentoriented concepts and it comes with a suite of tools for developing and deploying "commercial-grade" multiagent sytems. However, since JACK is an extension of Java, if you want to reason about and synthesize JACK agents' plans, you need to be able to reason about and construct Java programs -not something that Java was designed for. SPARK falls between these extremes. The finite state machine model of SPARK execution is much more amenable to formal analysis than the extended Java programs of JACK. An additional advantage is that SPARK allows new procedures to be constructed on-the-fly at runtime as a result of reasoning about new situations. Compared with the logic-based agent languages, SPARK's treatment of variables and the FSM model of execution make SPARK a closer fit for integration with external components and allow for simple and efficient implementations.</p><p>SPARK has been heavily influenced by PRS, particularly with respect to the design of the meta level. Compared with PRS, SPARK has a more precisely defined semantic model and a greater emphasis on engineering issues.</p><p>The robotics community has produced a number of agent systems that serve as task-level controllers for managing the activities of mobile robots (e.g., PRS-lite <ref type="bibr" target="#b12">[13]</ref> and RAP <ref type="bibr" target="#b5">[6]</ref>). As with SPARK, these sytems act as embedded controllers in a dynamic world, applying predefined libraries of procedural knowledge to perform tasks and respond to unexpected events. Like SPARK, these procedural languages provide great flexibility and expressiveness in order to handle the complexities inherent to activity in the real world. The nature of the robotics applications, however, has resulted in some significant technical differences from SPARK. Responsiveness is paramount for robotics applications, resulting in architectural designs that try keep the execution cycle time on the order of tens of milliseconds. For this reason, the type of reflective reasoning provided by SPARK is not supported. Furthermore, program variables of different types are often used to characterize world state rather than the more general declarative knowledge base used within SPARK. Finally, little attention has been paid by the robotics community to issues related to reasoning about procedures, with the result that the semantics of the richer representation languages are not well defined.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Conclusions</head><p>To tackle many real-world applications, agent systems need both a strong formal model and a practical implementation that scales well and integrates with other components. Motivated by these two needs, SPARK has taken the middle ground between theoretical agent formalisms and large-scale agent implementation systems, by providing an expressive and practical agent development system backed by a logical semantic model.</p><p>SPARK is currently being used as the process representation and execution mechanism in CALO, a large agent system that integrates a variety of AI technologies. To date, the development of SPARK has concentrated on the practical aspects of the formalism required to support CALO. In the future, we plan to apply the formal properties of SPARK to the problem of reasoning about agents and their capabilities.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>[</head><label></label><figDesc>noop:] Do nothing. [fail:] Fail.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 . Basic Task Expressions [</head><label>1</label><figDesc>seq: τ 1 τ 2 ] Execute τ 1 and then τ 2 .[parallel: τ 1 τ 2 ] Execute τ 1 and τ 2 in parallel.[if:φ τ 1 τ 2 ] If φ is true, execute τ 1 otherwise execute τ 2 . [try: τ τ 1 τ 2 ] If τ succeeds, execute τ 1 ,otherwise execute τ 2 . [wait: φ τ ] Wait until φ is true, then execute τ .[while: φ τ 1 τ 2 ] Repeat τ 1 until φ has no solution then execute τ 2 .</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 . Compound Task Expressions executing</head><label>2</label><figDesc>τ 2 , φ is guaranteed to be false. The exact meaning of this will be made clear in Section 4.2.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>|[if: φ τ 1 τ 2 ]| = φ::|τ 1 | ∪ φ::|τ 2 | where the condition φ is added to all initial transitions of |τ 1 | and φ</figDesc><table /><note><p>where the success state of |τ 1 | and the initial state of |τ 2 | are replaced by a new state σ joining the two FSMs. Note that if there are no transitions to the success state of |τ 1 |, then it will be impossible to reach any of the states in |τ 2 |. •</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>the success state of |τ | and initial state of |τ 1 | are replaced by a new state σ 1 , and the failure state of |τ | and the initial state of |τ 2 | are replaced by a new state σ 2 .</figDesc><table /><note><p>• |[wait: φ τ ]| = M ε σ ∪ [σ] φ::|τ | where there is an initial transition to an internal state σ after which it is possible to transition into |τ | only if φ is true. The initial M ε transition exists to satisfy well-behavedness condition</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This material is based upon work supported by the Defense Advanced Research Projects Agency (DARPA), through the Department of the Interior, NBC, Acquisition Services Division, under Contract No. NBCHD030010, and by internal funding from SRI International. The authors wish to thank others who have contributed to the development of SPARK, including Mabry Tyson, Alyssa Glass, Ken Conley, Regis Vincent, Andrew Agno, and Michael Ginn.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A library of generic concepts for composing knowledge bases</title>
		<author>
			<persName><forename type="first">K</forename><surname>Barker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Clark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the First Int. Conf. on Knowledge Capture (K-Cap&apos;01)</title>
		<meeting>of the First Int. Conf. on Knowledge Capture (K-Cap&apos;01)</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">JACK -components for intelligent agents in Java</title>
		<author>
			<persName><forename type="first">P</forename><surname>Busetta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rönnquist</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hodgson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lucas</surname></persName>
		</author>
		<ptr target="http://www.agent-software.com" />
	</analytic>
	<monogr>
		<title level="j">Agent Oriented Software Pty. Ltd</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report 1</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The Open Agent Architecture</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Cheyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Martin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Autonomous Agents and Multi-Agent Systems</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="143" to="148" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A formal specification of dMARS</title>
		<author>
			<persName><forename type="first">M</forename><surname>Inverno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kinny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Luck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wooldridge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Agent Theories, Architectures, and Languages</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="155" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Adaptive execution in complex dynamic worlds</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Firby</surname></persName>
		</author>
		<idno>RR-672</idno>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
		<respStmt>
			<orgName>Yale University CS Dept</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Task networks for controlling continuous processes</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Firby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Second Int. Conf. on AI Planning Systems</title>
		<meeting>of the Second Int. Conf. on AI Planning Systems<address><addrLine>Menlo Park, CA</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<author>
			<persName><forename type="first">T</forename><surname>Garvey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The intelligent information manager. Final Report SRI Project 8005</title>
		<meeting><address><addrLine>Menlo Park, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Con-Golog, a concurrent programming language based on the situation calculus</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lesperance</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Levesque</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">121</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="109" to="169" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Formal semantics for an abstract agent programming language</title>
		<author>
			<persName><forename type="first">K</forename><surname>Hindriks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>De Boer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Van Der Hoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-J</forename><surname>Meyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Intelligent Agents IV: Proc. of the Fourth Int. Workshop on Agent Theories, Architectures and Languages, LNAI 1365</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="215" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">JAM: A BDI-theoretic mobile agent architecture</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Huber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Third Int. Conf. on Autonomous Agents (Agents &apos;99)</title>
		<meeting>of the Third Int. Conf. on Autonomous Agents (Agents &apos;99)</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="236" to="243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">An architecture for real-time reasoning and system control</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">F</forename><surname>Ingrand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Georgeff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Rao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Expert</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">6</biblScope>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The Saphira Architecture: A design for autonomy</title>
		<author>
			<persName><forename type="first">K</forename><surname>Konolige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Ruspini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Saffiotti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Experimental and Theoretical AI</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A procedural knowledge approach to task-level control</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Third Int. Conf. on AI Planning Systems</title>
		<meeting>of the Third Int. Conf. on AI Planning Systems</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">CPEF: A continuous planning and execution framework</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AI Magazine</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Human directability of agents</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">N</forename><surname>Morley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the First Int. Conf. on Knowledge Capture</title>
		<meeting>of the First Int. Conf. on Knowledge Capture</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">The TRAC framework for agent directability</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">N</forename><surname>Morley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Adjustable Autonomy</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Hexmoor</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Falcone</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Castelfranchi</surname></persName>
		</editor>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Eclipse platform technical overview</title>
		<ptr target="http://www.eclipse.org/whitepapers/eclipse-overview.pdf" />
		<imprint>
			<date type="published" when="2003-02">February 2003</date>
			<publisher>Object Technology International, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">AgentSpeak(L): BDI agents speak out in a logical computable language</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Rao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Agents Breaking Away</title>
		<title level="s">Lecture Notes in Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">V</forename><surname>De Velde</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Perram</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1038</biblScope>
			<biblScope unit="page" from="42" to="55" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">BDI-agents: from theory to practice</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Georgeff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the First Int. Conf. on Multiagent Systems</title>
		<meeting>of the First Int. Conf. on Multiagent Systems<address><addrLine>San Francisco</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Planning and reacting in uncertain and dynamic environments</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Wilkins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Lowrance</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">P</forename><surname>Wesley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Experimental and Theoretical AI</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="197" to="227" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
