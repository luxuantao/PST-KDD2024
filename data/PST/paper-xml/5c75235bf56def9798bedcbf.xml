<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">DEFT: A Distributed IoT Fingerprinting Technique</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><roleName>Dinil</roleName><forename type="first">Vijayanand</forename><surname>Thangavelu</surname></persName>
							<email>vijayanand@u.nus.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">are with National University of Singapore</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">are with National University of Singapore</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mon</forename><surname>Divakaran</surname></persName>
							<email>dinil.divakaran@singtel.com</email>
							<affiliation key="aff0">
								<orgName type="institution">are with National University of Singapore</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Rishi</forename><surname>Sairam</surname></persName>
							<email>rishi.sairam@u.nus.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">are with National University of Singapore</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">are with National University of Singapore</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Suman</forename><surname>Sankar Bhunia</surname></persName>
							<email>suman.s.bhunia@ieee.org</email>
							<affiliation key="aff0">
								<orgName type="institution">are with National University of Singapore</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mohan</forename><surname>Gurusamy</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">are with National University of Singapore</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">are with National University of Singapore</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Suman</forename><surname>Sankar</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">are with National University of Singapore</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">DEFT: A Distributed IoT Fingerprinting Technique</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">7192CA5EBB3332EBC5C2B60E648A612D</idno>
					<idno type="DOI">10.1109/JIOT.2018.2865604</idno>
					<note type="submission">This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2018.2865604, IEEE Internet of Things Journal</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:24+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Network</term>
					<term>IoT</term>
					<term>Identification</term>
					<term>Fingerprint</term>
					<term>Security</term>
					<term>NFV</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Identifying IoT devices connected to a network has multiple security benefits, such as deployment of behaviorbased anomaly detectors, automated vulnerability patching of specific device types, dynamic attack mitigation, etc. In this work, we look into the problem of IoT device identification at network level, in particular from an ISP's perspective. The simple solution of deploying a supervised machine learning algorithm at a centralized location in the network neither scales well nor can identify new devices. To tackle these challenges, we propose and develop DEFT, a distributed fingerprinting solution that addresses and exploits the presence of common devices, including new devices, across smart homes and enterprises in a network. A DEFT controller develops and maintains classifiers for fingerprinting, while gateways located closer to the IoT devices at homes perform device classification. Importantly, the controller and gateways coordinate to identify new devices in the network. DEFT is designed to be scalable and dynamic-it can be deployed, orchestrated and controlled using SDN and NFV. DEFT is able to identify new device types automatically, while achieving high accuracy and low false positive rate. We demonstrate the effectiveness of DEFT by experimenting on data obtained from real-world IoT devices.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Security concerns with respect to IoT devices are different and new, in comparison with the PC market. A primary factor is the scale-the number of IoT devices is expected to grow to a few tens of billions by 2023 <ref type="bibr" target="#b0">[1]</ref>. Besides, the IoT market is much more heterogeneous in the types, based (mostly) on applications and protocols. The number of vendors in this market is continuously increasing, but not all vendors would continue to exist during the lifetime of their products. These factors raise multiple issues. As new vulnerabilities get discovered, it is likely that many of these will be left unpatched, and hence open to exploits. Even in the PC market, where there is often a user to maintain the computer(s) owned, it is not uncommon that many vulnerabilities remain unpatched. This trend will be worse for IoT devices, as most devices will not have a human user dedicatedly attending to it. Exposed vulnerabilities are exploited by attackers for a variety of purposes, such as leaking private information <ref type="bibr" target="#b1">[2]</ref>, launching large-scale attacks (as witnessed in the recent Mirai attack <ref type="bibr" target="#b2">[3]</ref>), infecting critical infrastructures <ref type="bibr" target="#b3">[4]</ref>, etc. Therefore, to secure IoT devices, multiple approaches need to be taken, from design to attack monitoring to mitigation.</p><p>In this work, we take a network-centric approach for securing IoT devices. The first step in this process is to identify IoT devices. This is also referred to as fingerprinting of devices, as solution seeks to find unique characteristics that can identify and distinguish devices. Identifying IoT devices has multiple security benefits. One, knowing the devices in a network helps in analyzing the normal behavior of a particular device type, which can subsequently be used to detect anomalous behaviors, such as unusual incoming traffic, connections to unseen servers, etc. Two, once a vulnerability of a device type (say, camera of vendor X and model Y) is known, security patches or mitigation solutions can be applied at the earliest, specifically on the devices identified to be of this type. In addition, device identification helps an organization to continuously maintain its asset list, to quarantine and isolate misbehaving or vulnerable devices, etc. If fingerprints of devices are unique, then they can also be used for authentication <ref type="bibr" target="#b4">[5]</ref>.</p><p>We study the problem of fingerprinting IoT devices by analyzing network traffic. We view the problem from the perspective of an ISP; specifically, we focus on the scenario where IoT devices are connected to an ISP network via gateways. Here, gateways are essentially access points at smart homes and enterprises, connecting IoT devices to the Internet. In the near future, a gateway is likely to talk multiple communications protocols such as Ethernet, Wi-Fi, Bluetooth, ZigBee, etc., so that it can communicate with a variety of IoT devices.</p><p>A centralized approach for solving the problem of fingerprinting IoT devices is to train a supervised machine learning model using network traffic of devices, and use that model at a centralized controller in the network, to classify devices based on the traffic characteristics. We note that, a good solution needs to update its model continuously, as the traffic patterns of devices change over time due to reasons such as change in configuration, firmware update, user behavioral changes, environmental changes, etc. This means that, without any other intelligence in the network, a centralized fingerprinting solution has a serious limitation--all traffic flows from devices need to be sent to the controller. This is challenging to scale with increasing number of devices and smart homes. Besides, a supervised classifier only identifies known devices (using pre-trained models). However, in an ever growing IoT market, it is important to detect new devices as well.</p><p>We argue that a fingerprinting solution for IoT devices should meet two important objectives. One, the fingerprinting solution should be scalable while not compromising on accuracy of device identification. Two, the solution should be able to dynamically detect and differentiate new IoT devices connected to the network. The solution should learn the fingerprints of new devices automatically. DEFT works on a hierarchical network architecture, consisting of two entities-control logic and gateway. A DEFT control logic resides in the ISP network, and controls a set of gateways for fingerprinting IoT devices. Fig. <ref type="figure" target="#fig_0">1</ref> illustrates this architecture. Each gateway corresponds to a smart home or enterprise to which IoT devices are connected. As ISPs are gradually embracing SDN (software-defined networking), the DEFT control logic is essentially an application deployed at an SDN controller. The path shown in the figure is therefore a path in the control plane of the ISP network, connecting the SDN-controller to the gateway. Henceforth, unless otherwise stated, we use controller to refer to the DEFT control logic. Though one can imagine a tree structure of controllers, where a controller higher up in the tree structure controls all its child nodes, we limit our discussion henceforth to two levels-the first level consists of (independent) controllers, and the second level consists of non-overlapping sets of gateways, each set controlled by a DEFT controller.</p><p>DEFT is designed to meet the two objectives stated above. The gateways perform device classification using the model developed by the controller. All traffic sessions from IoT devices are processed and classified locally at the corresponding gateway, without being sent to the controller. The only information sent from a gateway to its controller is the feature vector corresponding to selected traffic sessions. This happens rarely, when the gateway is not confident about its classification (and most likely when a new device is connected to the gateway). Besides, the size of a feature vector is limited to a few KBs, whereas that of a traffic session can vary arbitrarily from hundreds of KBs to hundreds of MBs and even more.</p><p>The DEFT controller learns fingerprints of devices, builds and continuously improves the fingerprint classification system, to deploy the up-to-date classifier at the gateways it controls. The controller coordinates with the gateways to gather information about (potentially) new devices across the different smart homes/enterprises, to subsequently label and identify new devices. DEFT is designed to work with SDN and NFV (Network Function Virtualization), with the controller having the ability to orchestrate the classifier as a virtual The rest of the paper is organized as follows. We present an overview of our proposed system DEFT in the next section. We provide details on the features we use for identifying IoT devices using network traffic in Section III. In Section IV, we develop and present the algorithms that define DEFT. We evaluate the effectiveness of DEFT in fingerprinting devices and present the results in Section V.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. OVERVIEW OF DEFT</head><p>Fig. <ref type="figure">2</ref> gives an overview of DEFT building blocks. The upper part of the figure consists of processes executed at the gateways, while the processes in the lower part are executed at the DEFT controller. Features are extracted from traffic sessions (defined later in Section III) that arrive at the gateway. After feature extraction, the gateway classifies the device (traffic session) into a particular type (or class). The classifiers used at the gateways are obtained from the controller. The gateways do not perform any training; instead training of classifiers is performed by the controller. After performing classification, the gateway separates out the sessions that were classified with low probability, as diffident sessions; such sessions are later sent to the controller. A classification may have low probability when the corresponding device is new; or the probability could be low even for an existing device when the traffic pattern has changed. Note that, a change in the firmware of an existing device might lead to a low classification probability.</p><p>All the three modules of Feature extraction, Device Classification and Confidence Evaluation are parts of a single fingerprint classification application that can be developed as a virtual network function (VNF) and deployed at the gateway. Furthermore, three individual modules can be developed as microservices, thereby allowing them to be modified and deployed independently, while adhering to standard interfaces for communications between themselves. Thus, our design is based on NFV and microservice architecture to provide modularity and robustness.</p><p>The controller gathers diffident sessions from the different gateways it controls, and proceeds to cluster them. For clustering, the controller uses a set of labeled data as seed clusters. The controller updates the labeled dataset continuously and actively based on its algorithm; and each time the dataset is updated, the controller retrains the classifier generating a new model. This model is sent to all the gateways it controls. And the gateways use the updated model for classifying the traffic sessions captured from then on.</p><p>As we will discuss later, a gateway only sends feature vectors of diffident sessions to its controller, and not the actual traffic session. The size of a feature vector is O(k), where k is the dimension of the vector. In our work, the value of k is around 100. Thus, even when sessions may have hundreds of packets resulting in session sizes that varies between hundreds of KBs (kilobytes) to MBs, the size of the corresponding feature vector is in 1-2KBs.</p><p>It is also worth noting that, DEFT is designed to be scalable. If the number of gateways increase, more instances of the DEFT controller can be spawned to balance the load; and the different controllers can synchronize the classifier model via a controller in the above layer in the hierarchical architecture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Illustration of the fingerprinting process</head><p>We illustrate the fingerprinting process in DEFT using a simple example depicted in Fig. <ref type="figure" target="#fig_3">3</ref>. There are three gateways-G 1 , G 2 , and G 3 -connected to a DEFT controller. The system currently has a model for classifying six devices {a, b, c, d, e, f}. The devices currently connected to the gateways are shown in the figure. The next steps, in simplified form, are given below.</p><p>1) A new device, of type x, connects to the gateway G 1 .</p><p>2) G 1 observes that the classification probability of traffic session from this device is low, based on the current model in use. 3) G 1 collects the traffic sessions (feature vectors) of this device and sends to the controller. 4) Meanwhile, a new device, of the same type x, is connected to the gateway G 3 . 5) G 3 has low confidence in classifying this new device's sessions. 6) G 3 sends traffic sessions of this device to the controller. 7) The controller, on receiving sufficient number of sessions (data points), performs clustering, unaware that the sessions obtained from the two gateways (G 1 and G 3 ) could be of the same device type. The clustering process however groups the data points from G 1 and G 2 into a new and distinct cluster. It updates the labeled dataset and retrains the model based on the clustering output. 8) Subsequently, the controller sends the new model to all the gateways. 9) A new device, of type x, connects to the gateway G 2 . 10) G 2 classifies x using the new model (to the label learned by the model which the controller trained).</p><p>III. TRAFFIC FEATURES FOR IOT FINGERPRINTING Network traffic has important information that can be extracted as features for different kinds of analysis, including Fig. <ref type="figure" target="#fig_3">3</ref>: Illustration of the fingerprinting system fingerprinting. Features could be extracted both from packet headers as well as payloads. Extracting features from payloads is an expensive process, though such features may provide useful information for fingerprinting. Payload analysis is also often considered intrusive to user privacy. The features used in DEFT are not from user data; however, we do extract features from DNS queries and HTTP URI's (see Section III-A), which may be considered as private information.</p><p>Depending on the analysis, traffic can be represented at different levels. At the finest level of granularity, a feature vector represents per packet information; examples being application protocol (port number) used, packet size, destination IP address, IP options, etc. This representation is useful if the goal is to classify each packet. However, there is no strong motivation to carry out fingerprinting of devices at packet level, in particular considering the fact that per-packet classification is costly. Instead, we find it sufficient to classify a traffic session. A session is an aggregation of traffic connections from and to one particular device and localized in time. For example, if the session time is defined to be 15 minutes, then all the network packets sent and received by a device within a 15minute window will constitute a single session. Therefore, a session is identified by both a device and a time interval.</p><p>Session interval can be determined either dynamically or statically. In a dynamic approach, one can look for an inactive period, and group traffic connections into one session as long as the inactivity period is less than a predetermined time (say, one minute). In a static approach, time is split into fixedsize intervals (say, 15 minutes), and all traffic connections made by a device within one such interval is considered as a single session. The length of dynamic sessions could be quite arbitrary, particularly because devices may maintain keep-alive probes. For this work, we define sessions based on fixed-size time intervals.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Feature list</head><p>The features used in DEFT are listed in Table <ref type="table" target="#tab_1">I</ref>. We broadly classify them below. In the following as well as in the table, we use 'stats' and 'statistics' to denote the mean, minimum and maximum of the concerned feature in a session. be valuable for fingerprinting IoT devices. We consider features related to both DNS and mDNS (multicast DNS). The features considered are number of DNS queries, DNS packet count, most frequently queried domain name, number of DNS errors (i.e., response code = NOER-ROR), the number of INTERNET class queries, statistics of DNS packet length and DNS query response time, etc. All these features are collected over each of the sessions defined based on time.</p><p>• V 2 : We also extract two session level features that are protocol agnostic: (i) number of packets sent during the session; and (ii) activity period of the session. Although a session might be defined for, say, 15 minutes, packets might be sent only in the first ten minutes; in this case, the activity period is 10 minutes. Observe, this set of features is least privacy-intrusive, as they do not require reading of even packet headers. • V 3 : Most communications between IoT devices and cloud are encrypted. As we see increasing adoption of TLS <ref type="bibr" target="#b5">[6]</ref>, we extract TLS related features for fingerprinting. The features extracted are minimum, maximum and mean of TLS packet length, flow duration, and number of TCP keep-alive probes used in TLS session. In this class we also consider HTTP features as listed in the table. • V 4 : In this feature class, we consider a number of protocols, as given in Table <ref type="table" target="#tab_1">I</ref>. STUN (Session Traversal of UDP through NAT) is used to establish bidirectional communication between an IoT device and its cloud server, in the presence of a NAT server. SSDP (Simple Service Discovery Protocol) is a server-less discovery protocol, forming the basis of UPnP (Universal Plug and Play) architecture; it is adopted by many IoT devices. MQTT (message queue telemetry transport) is a publishsubscribe based light-weight messaging protocol used to collect and transfer data from devices to their servers. Due to its various features (small footprint, adaptability with constrained network, simplicity in implementation, etc.), MQTT is expected to be widely adopted by the IoT market. QUIC (Quick UDP Internet Connection) is a recently developed transport protocol, supported by Google servers and Google Chrome, that aims to perform better than the widely used TCP. We refer readers to Table <ref type="table" target="#tab_1">I</ref> for the full list of features. All the above features form our feature vector of dimension 111. While previous works have used combinations of some of the feature mentioned above, to the best of our knowledge, all the features have not been used together for fingerprinting previously.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Initial feature analysis</head><p>To understand the goodness of the features in distinguishing the IoT devices, we carry out preliminary analysis using PCA (Principal Component Analysis). PCA is often used for dimension-reduction, by explaining the variance in the data using a small number of orthogonal components. It is also useful to visualize high-dimension data in smaller, two or three, dimensions. We extracted features from traffic of 16 devices (listed in Table <ref type="table" target="#tab_4">III</ref>) and analyzed them using PCA with two components; the corresponding 2D planes are plotted in Fig. <ref type="figure" target="#fig_1">4</ref>. For clarity, the devices are separated into smaller groups and presented in different plots. We observe that there is clear separation among feature vectors belonging to different devices. Though we observed overlap when we plotted the components of all devices in a single 2D plane, the overlap reduced significantly when another component was added to the PCA. This insight provides motivation to develop clustering algorithm(s) at the controller for identifying new devices. We use PCA only for this preliminary analysis, and do not use it further in any of the algorithms forming DEFT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. DEFT: ALGORITHMS</head><p>We develop the algorithms defining the DEFT system in this section. Before doing so, we provide background on related concepts. Table <ref type="table" target="#tab_2">II</ref> gives the list of commonly used notations in this work.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Preliminary</head><p>We brief some important concepts used in this work, primarily to estimate the distance between two sets of points, so as to decide whether they are close enough to be considered as one cluster or not.</p><p>1) Centroid: Formally, given a set F of m-dimensional vectors, where |F| denotes the number of vectors in F, the centroid ζ of set F is computed as,</p><formula xml:id="formula_0">ζ(F) = 1 |F| f ∈F f ,<label>(1)</label></formula><p>the addition and average being computed over the vector components.</p><p>2) Euclidean distance: We also utilize the commonly used Euclidean distance, to compute the distance between two sets of points. Given two vectors u, v with the same dimension m, the Euclidean distance is computed as,</p><formula xml:id="formula_1">dist(u, v) = m i=1 (u i -v i ) 2 ,<label>(2)</label></formula><p>where u i and v i denote the i th component of vectors u and v, respectively.</p><p>3) z-score: Consider a population with mean µ and standard deviation σ. Given an observation x, z-score gives the number of standard deviations the observed value is from the population mean.</p><formula xml:id="formula_2">zScore(x; µ, σ) = x -µ σ<label>(3)</label></formula><p>z-score is based on the mean and standard deviation, which have a breakdown point of 0%. Therefore, in scenarios where the data may have anomalies, it is common to replace these estimators (µ and σ) with their robust counterparts of median and median of all absolute deviations from the median (MAD). Both median and MAD have breakdown point of 50%. However, as we are currently generating data in a controlled environment, we find it sufficient to use z-score in this work. return NULL No classification done 13: end if 14: return c as class of S centroids of the k clusters F k 's, then the partition is achieved by minimizing the following objective function:</p><formula xml:id="formula_3">k i=1 f ∈F k ||f -µ k || 2 .</formula><p>Seeded k-means <ref type="bibr" target="#b6">[7]</ref> is a semi-supervised clustering algorithm based on k-means, in which labeled data sets are used for seeding. These labeled data sets are used for initializing kmeans in computing the centroids (instead of choosing random points). Thereafter, each observation f is assigned to the nearest cluster (i.e., the cluster with the nearest centroid to the observation), and the centroid of that cluster is re-computed. As will be described later in Section IV-C, our clustering algorithm uses a similar approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Classification at gateways</head><p>Algorithm 1 lists the steps taken at a gateway, when it captures a traffic session S. The first if statement checks if the controller has sent a new model back to this gateway, and if so, updates its model accordingly. In practice, this would be implemented separately and independent of the classification at gateways, using a publish-subscribe model, so that gateways receive the latest model at the earliest.</p><p>Line no. 4 in Algorithm 1 extracts features from traffic sessions. Supervised classification is performed in line no. <ref type="bibr" target="#b4">5</ref>, where M denotes the model used at gateways for classification. We assume the first such model is trained using a set of known devices, which we call as seed devices. The model itself is obtained from the controller, which retrains the model as and when necessary (explained later in Algorithm 2). All gateways use the same model M for classification.</p><p>The Classify_GW function runs a supervised classifier trained by the DEFT controller. Later in Section V, we discuss on the supervised learning algorithms evaluated for device classification. The Classify_GW function returns the device class c of the session, as well as a measure of confidence p for the class assigned. The second if statement assesses this confidence; if the confidence is low, the corresponding session's feature vector F is appended to the list diffident sessions-a list of sessions predicted with low confidence.</p><p>Observe that diffident sessions is indexed by X; X is the unique address of an IoT device, for example, its MAC address. This information allows the gateway to segregate sessions based on the device addresses, even while it is not certain of the device type. Note that, while a device can fake a MAC address it presents to the gateway, this does not pose a problem as long as the faked MAC address is not the same as another device connected to the gateway. Duplicate MAC addresses can be easily detected by a gateway. This segregation based on address is used only to aggregate feature vectors from the same device. When the number of low-confidence sessions observed from a particular device (i.e., length of list diffident sessions[X]) is θ, it is sent over to the controller (line no. 9). Henceforth, we refer to diffident sessions[X] as feature aggregate F (that is, F is a set of feature vectors coming from an unknown device).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Identifying new devices at Controller</head><p>The SendToController function invoked by gateways (in Algorithm 1) sends feature aggregates to the controller. This function invokes Algorithm 2 at the controller. Consider the case where the controller has received a list of feature aggregates from some of its gateways. We denote this list as P. Another important data structure is R, which is a list of clusters from seed devices. A cluster here is a labeled feature aggregate, which has at least θ number of feature vectors. We also maintain T, a data structure similar to P (list of feature aggregates). T is used to reduce the feature aggregates in P, such that each feature aggregate in T corresponds to a unique device type. That is, DEFT merges 'similar' feature aggregates (potentially belong to same device type), as detailed in the algorithms below. Initially, T is bootstrapped with clusters from R. The logic of having two related lists R and T is that, DEFT uses R to maintain the final clusters corresponding to device types.</p><p>For clustering, we first experimented with standard k-means algorithm. In this experiment, we used all devices listed in Table <ref type="table" target="#tab_4">III</ref> and set k equal to the number of devices (16 here). We then evaluated the accuracy as the number of traffic sessions (feature vectors) correctly classified as belonging to the appropriate device. The accuracy achieved using k-means was a low 40.87%. Another disadvantage of this approach is that, we need to specify the number of devices as the input parameter k; note, this information is not available at the controller. To overcome these obstacles, we carried out analyses and made a few observations. One, instead of clustering feature vectors, we can cluster feature aggregates. Two, inter-cluster distances is a good metric for clustering feature aggregates. The second observation comes from the analysis that we have provided in Section V-D3. Following these observations, we developed our clustering algorithm, which is inspired by the seeded k-means algorithm in <ref type="bibr" target="#b6">[7]</ref>-a semi-supervised clustering technique. In this algorithm, the end if 8: end for 9: updateModelClusters(T) labels of the known data are not changed, but is used to estimate the centroids of the clusters. Based on this concept of using data with known labels, we proceed to develop our clustering algorithm given in Algorithm 2.</p><p>The basic idea here is to check if the feature aggregate obtained from a gateway is close to any of the known feature aggregate in T. Each iteration in the for loop operates on one feature aggregate F. We first find the cluster in T that is nearest to F, using the function nearestCluster (line no. 2 of Algorithm 2). The If statement checks whether the distance to this nearest cluster G is within acceptable range, using the function withinICR (as described below, z-score is used for this purpose). In this case, the feature vectors in F is added to G, and this new merged feature aggregate (F ∪ G) replaces the old feature aggregate G in T. If the nearest feature aggregate is not within the acceptable range, F is considered as a new feature aggregate in T, and added to T (line no. 6). Finally, both the model M and the list of clusters in R are updated by invoking the function updateModelClusters.</p><p>Next, we describe the other algorithms used at DEFT the controller. The nearestCluster function is presented in Algorithm 3. The function computes the distances between centroid of the given feature aggregate F to the centroid of each feature aggregate in T, and returns the feature aggregate to which the distance is minimum. The function withinICR, defined in Algorithm 4, checks if the two given feature aggregates are within the range of the inter-cluster distance measure. Given two feature aggregates, the algorithm computes the centroid of these feature aggregates (line no. 1) and the distance between the centroids (line no. 2). To decide whether these two feature aggregates can be merged or not, we do the following. Let µ and σ denote the mean and standard deviation of the inter-cluster distancesdistances between the clusters in R. Estimation of µ and σ are carried out in Algorithm 5. Given the estimated mean and standard deviation, and using the computed distance between the feature aggregates in line no. 2, we compute the z-score using Eq. ( <ref type="formula" target="#formula_2">3</ref>). If the absolute value of z-score is less than a threshold β, DEFT considers the feature aggregates to be close enough to be merged.   Retrain and obtain new model 8: estimateClusterDist(R) 9: SendToGWs(M)</p><formula xml:id="formula_4">for j in [i + 1..l] do 4: D[R[i], R[j]] = dist(R[i], R[j]</formula><p>Send new model to all gateways Algorithm 5 estimates the mean and standard deviation of cluster distances, and is self-explanatory. Algorithm 6 updates the cluster list R, such that R ⊂ T and each F ∈ R has more than θ feature vectors. These clusters are then used to update the model used for classification at the gateways; and this is achieved using the train function (line no. 7). The train function uses a supervised learning algorithm for training a classifier model. The specific classification algorithm deployed is given in the following section; however DEFT only requires this classifier to be trained using a supervised approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Computational complexity</head><p>In this section we analyze the cost of fingerprinting at the gateways and the controller.</p><p>Gateway: The two main tasks at a gateway are (i) feature extraction (line no. 4 in Algorithm 1) and (ii) classification of the instance-traffic session here. Most well-known classifiers take time linear in the number of features for classifying a given instance. (Although for Random Forests classifier, we need to factor in the number of trees given as an input parameter.) Since the number of features is small and fixed, the cost of classifying an instance can be seen as constant. Therefore, the computational cost at the gateway is dominated by the feature extraction process. An instance for classification is obtained by processing and extracting all relevant features from a traffic session. This essentially requires processing of each packet, with slightly different yet simple computations performed for extracting information for different features. For example, the number of packets, the statistical summaries of packet lengths, the duration of flow (connection), etc., are computed for different protocols. Therefore, feature extraction process takes m × O(n), where m is the number of features and n is the number of packets in a session.</p><p>Controller: The two main operations at the DEFT controller are (i) clustering, and (ii) update/retraining of model. For clustering, the computational cost due to the function nearestCluster is O(|T|), and that due to updateModelClusters is also O(|T|).  <ref type="bibr" target="#b7">[8]</ref>. Therefore, the computational time at the controller is dominated by the retraining process.</p><p>It is important to note here that, for both clustering and retraining of the classifier, the input is a list of feature aggregates; and a feature aggregate is essentially an aggregation of vectors (traffic sessions). Therefore, the costs of these operations are in terms of traffic sessions and, to highlight, not in packets. In addition, the feature aggregates that the controller receives are formed from only the diffident traffic sessions at the gateways (line no. 8-11 of Algorithm 1). Therefore the run-time cost of algorithms on the controller is practically low and acceptable. Besides, since the controller is hosted in the cloud, it can also be scaled up with additional resources as and when needed (say, when there is an increase in the rate of arrival of diffident sessions from gateways). Of course, the number of controllers can itself be increased when the number of gateways each controller manages increases beyond a limit-an important advantage of the hierarchical architecture of the DEFT system (as motivated in Section I).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. PERFORMANCE EVALUATION</head><p>In the following, we carry out experiments to evaluate DEFT. Our design of DEFT works for both smart homes and enterprises; however, for the experiments here, we consider a network of smart homes. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Experimental setup</head><p>Our experimental setup consists of 16 IoT devices relevant to smart homes. They are connected to the Internet via a gateway over Ethernet or WiFi. We used Raspberry Pi 3 as a gateway, to capture traffic generated by the devices. We used an interval length of 15 minutes to define sessions. Table <ref type="table" target="#tab_4">III</ref> gives the details of the devices and the number of sessions collected for each. In total, 7584 sessions were generated and captured over a period of seven days. In this controlled environment, MAC addresses in the packet headers were used to label the traffic sessions from different devices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Scenario</head><p>The scenario we consider for evaluation consists of one controller and five gateways. Each gateway is located at a smart home, to which five devices are connected. Each home has 1-2 devices that are used in other homes as well. At the start of the experiment, we assume there are five known devices, each located at different homes; that is, the traffic of devices are available for training. Therefore, when the system initializes, there are five seed clusters whose labels are known. We refer to these known devices as seed devices and the remaining ones as test devices. The initial model is trained using feature vectors from these seed devices.</p><p>The labels of the test devices are not known, and their traffic would be new to gateway(s) and controller. As described in the algorithms, when a gateway observes low classification probability of traffic session(s) from the new device, it sends the corresponding set of feature vectors to the controller. This scenario is executed offline, where traffic is captured and send as input to the gateway (Algorithm 1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Metrics for evaluation</head><p>Precision, recall and F 1 are the commonly used metrics for multi-class classification. For a given class, precision and recall are defined as:</p><formula xml:id="formula_5">precision = # True Positive # True Positive + # False Positive ; recall = # True Positive # True Positive + # False Negative .</formula><p>Precision gives the fraction of correctly predicted instances of all those predicted for (and as) a particular class. Recall is the fraction of correctly predicted instances of the true instances of a class. For example, consider a set of instances for classification, where class A has 100 instances. If a classifier predicted 120 of all the instances to be of class A, but in reality only 90 were of class A (remaining 30 were wrongly predicted), then the precision for this class is 0.75. The recall for class A would be 0.9, since 90 of the 100 were 'recalled'.</p><p>Based on precision and recall, the F 1 score for a class is defined as:</p><formula xml:id="formula_6">F 1 score = 2 × precision × recall precision + recall .</formula><p>The overall accuracy is the ratio of the sum of correctly predicted instances to the total number of instances.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Results</head><p>1) Centralized and supervised classification with known devices: In this section, we intend to evaluate the performance when fingerprinting is carried out in a centralized approach and using supervised classification with known and labeled IoT devices. We experimented such a scenario, in which training was performed using labeled data from all the 16 IoT devices listed in Table <ref type="table" target="#tab_4">III</ref>. The testing phase had the same device set used for training, and no unknown IoT device. The following machine learning algorithms were tested: Random Forests, k-Gaussian and Bernoulli Naive Bayes. All features listed in Table <ref type="table" target="#tab_1">I</ref> were used. Among these algorithms, Random Forests classifier performed the best with 98% accuracy and Naive Bayes performed worst with 85% accuracy. Observe that, these also represent the best results obtained in the scenario where all traffic sessions from all the gateways are sent to a centralized controller performing supervised classification. Since Random Forests classifier can also easily train in parallel as well as work on heterogeneous data types, for our evaluation of DEFT below, we used Random Forests for supervised classification at the gateways (in line no. 7 of Algorithm 6).</p><p>2) Clustering accuracy: We first analyze the accuracy of clustering the data corresponding to test devices. Recall that gateway a feature aggregate (set of points) to the controller when in The size of this set is controlled by a parameter θ (refer line no. 8 in Algorithm 1), we experiment the accuracy of clustering as a function of this parameter θ. We use all the features listed in Table <ref type="table" target="#tab_1">I</ref> for this experiment.</p><p>If P denotes the list of feature aggregates received at the controller, let ν denote the number of required to reduce P to a set of clusters such that each cluster maps uniquely to its corresponding device. Let η denote the number of feature aggregates correctly merged to form the right clusters corresponding to devices.</p><p>Clustering accuracy = η ν Fig. <ref type="figure" target="#fig_8">5</ref> plots the clustering accuracy as a function of θ, the of the feature aggregate. We observe that the accuracy is high even for small values of θ, and close to 100% accuracy is achieved with a feature aggregate of size 100. Note that, each point in the plot is the mean of clustering accuracies from five runs.</p><p>3) Inter-cluster and intra-cluster distances: Furthermore, we analyzed the inter-cluster distances and intra-cluster distances. These distances are essentially the Euclidean distances between the centroids of the corresponding clusters. Hence, inter-cluster distances for a device are obtained from the distances between its cluster and the clusters of the remaining devices. For intra-cluster distances of a device, we randomly partition the corresponding device cluster into 10 equal parts, and calculate the distances between every pair. Fig. <ref type="figure" target="#fig_9">6</ref> depicts the box-plots for these distances. We observe almost an order of difference between the intra-cluster distances and the intercluster distances. This justifies the accuracies achieved due to clustering.</p><p>4) Analysis based on z-score: We analyzed clustering accuracy as a function of z-score, in Fig. <ref type="figure">7</ref>. The feature vector dimension used is 100, and the cluster size is set to 100. We highlight that, the parameters for computing the z-score, namely µ and σ, are initially estimated from the data of seed devices. Subsequently, these parameters are continuously reestimated as and when the clusters in R are updated. There is a range of values for the threshold β, approximately [2.2-3.0], for which the clustering accuracy peaks, and the accuracy decreases on both sides of this range. This is expected as a low z-score would create more number of clusters than necessary, and a high z-score will miss out creating new clusters for unknown test devices.</p><p>5) DEFT classification accuracy: Next, we analyze the accuracy of DEFT. The first five devices given in Table <ref type="table" target="#tab_4">III</ref> were used as seed devices. More specifically, the list R was initialized with five seed clusters containing 50% of the total number of sessions collected for these device. That also means, no initial labeled dataset was used for the remaining 11 devices in DEFT. Therefore, clusters corresponding to these 11 devices were formed automatically and dynamically by DEFT during the experiment. The performance metrics we present are for all the devices, including the seed devices. We point out  Though fingerprint classification is performed at the gateway, the accuracy is dependent on the clustering accuracy. For this experiment, the cluster size θ was set to 105. The value of β for the z-score test was set to three. We achieved an accuracy of approximately 97% for fingerprinting using the DEFT system. This high accuracy, obtained when we used all features listed in Table <ref type="table" target="#tab_1">I</ref>, is close to that obtained with the centralized and supervised classification using labels of all IoT devices (presented in Section V-D1). Table <ref type="table" target="#tab_6">IV</ref> gives the precision, recall and F 1 score of all devices. Observe that, DEFT performs very good even in the presence of similar devices. For instance, the last four devices are from one vendor (TP-Link), and in particular two of them have same functionality but different models. In this case, the minimum 1 score is still above 75%.</p><p>To understand how DEFT compares against a centralized and supervised learning approach for the same scenario used for the evaluation of DEFT, we conducted further experiments. In this setup, there were six labeled classes, five of which corresponded to five different IoT devices randomly picked in each experiment. The last class, unknown, represents another set of five IoT devices, again randomly selected. Therefore, we used a total of 10 devices for supervised training. Testing was performed using 16 devices, of which six were not used in training. This setting allows any new device unseen in the training phase to be classified as unknown device class, in addition to the five devices grouped into unknown class during the training phase. In other words, for these 11 devices, misclassification occurs only if they are classified into any class other than unknown class (i.e., into one of the first five known labeled classes). We used Random Forests algorithm as the supervised classifier. We carried out 50 trials of this experiment, selecting IoT devices randomly each time; and the mean accuracy achieved was 70.55%, with a 95% confidence interval of [67.2, 73.9]. Clearly, DEFT performs better than a centralized and supervised approach, under the same scenario wherein there are unknown devices to fingerprint.</p><p>6) Analysis of feature classes: In Fig. <ref type="figure" target="#fig_10">8</ref>, we plot the overall accuracy for the different classes of feature vectors we defined in Table <ref type="table" target="#tab_1">I</ref>. Observing accuracies with the feature class V 2 and its combination with other classes (V 12 , V 23 , V 24 ), we note that this class of session-related features (which are protocol agnostic) contributes more to accurate fingerprinting than the rest. Though limited to the devices we tested with, we observe that for systems where only such aggregate and minimally privacy-intrusive features are available, fingerprinting using DEFT could still achieve high accuracy.</p><p>7) Scalability: Since the run-time complexity at the controller is dominated by the retraining of the classifier (Section IV-D), we estimated the time to build a classifier model. We utilized Python's scikit-learn library <ref type="bibr" target="#b8">[9]</ref> for implementing the Random Forests classifier. On a Ubuntu-based VM, running on Intel Core i7-7700HQ @ 2.8GHz with 4 cores and 4GB of RAM, the controller took 81.79ms to train a classifier using 7584 sessions across 16 devices. This indicates that the computation at the controller is not a bottleneck for scalability in the DEFT design. Moreover, we recall that, the controller performs retraining only when it receives a pre-defined number of feature aggregates from gateways.</p><p>To quantify the bandwidth saved due to the distributed approach of DEFT, we computed the sum of the sizes of sessions we gathered from all 16 IoT devices. The average session size was approximately 1.6 MB. Whereas, the average size of feature vectors (corresponding to these same sessions)  was less than 550 bytes. As mentioned in Section I, a reinforcing classifier would need to analyze traffic continuously. In a centralized solution, since there is no intelligence besides the controller, all traffic would have to be sent to the controller. But DEFT does not send all feature vectors to the controller. Even if we make a conservative assumption that DEFT sends only one in ten feature vectors to the controller, we note that there is at least four orders of magnitude savings brought about by DEFT. This shows that DEFT is a highly scalable solution, in comparison with a centralized approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. RELATED WORK</head><p>Fingerprinting, in general, refers to the specific characteristics that can be used identify the entity of interest. Network traffic at different layers can be used to fingerprint a few interesting entities, such as wireless devices (e.g., access points) <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b11">[12]</ref>, operating systems <ref type="bibr" target="#b12">[13]</ref>, applications <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b14">[15]</ref>, etc. Depending on the goal, the features extracted are different. For example, fingerprinting has been used for indoor localization in recent works, based on information obtained from RSS (received signal strength) and CSI (channel state information) of communication links <ref type="bibr" target="#b15">[16]</ref>, <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b17">[18]</ref>. In another work <ref type="bibr" target="#b10">[11]</ref>, a sequence of inter-arrival times between packets flowing through an access point (AP) is used as features for fingerprinting APs. Whereas, the work in <ref type="bibr" target="#b12">[13]</ref> extracted features from TCP/IP (such as IP TTL and TCP header values), TLS and HTTP protocols, for passive OS fingerprinting in the potential presence obfuscation strategies. Passive fingerprinting refers to the approach in which traffic is only monitored by the solution (p0f <ref type="bibr" target="#b18">[19]</ref> is an example); as opposed to active approaches that send probes into the network for fingerprinting purposes (e.g., Nmap <ref type="bibr" target="#b19">[20]</ref>). Our proposed solution DEFT passively monitors network traffic to fingerprint IoT devices.</p><p>As mentioned previously, IoT market presents a new set of challenges, primarily due to its scale, heterogeneity, and fast adoption. IoTs raise not only security concerns, but also privacy risks <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b21">[22]</ref>. In <ref type="bibr" target="#b22">[23]</ref>, the authors demonstrate how sensitive private information can be inferred by analyzing network traffic from smart homes, even when the device traffic is encrypted. They show that user activities can be inferred from traffic rates of a few IoT devices. The work also discusses on device identification, analyzing features such as device MAC addresses, DNS queries and traffic rates.</p><p>If fingerprints of devices turn out to be unique, then they can be used for authentication. Motivated by this objective, the work in <ref type="bibr" target="#b4">[5]</ref>, uses a multivariate Gaussian distribution to model fingerprint of a device; a supervised approach is used to learn the model. The work also applies transfer learning <ref type="bibr" target="#b23">[24]</ref>, to minimize the difference due to normal environmental changes. While this is an interesting proposal, due to lack of experimentation using real IoT devices, it is early to comment on the effectiveness of the proposal. We note that there is also scope in enhancing the model to make it a distributed solution. Additionally, it would likely be a new and challenging problem to extend the model to identify unknown devices.</p><p>A meta-classifier trained using supervised machine learning was developed in <ref type="bibr" target="#b24">[25]</ref> for identifying IoT devices in two stages. In the first stage, IoT devices are differentiated from other devices; and in the second stage, identification of IoT devices is carried out. Besides extracting features from network, transport and application layers, features are also extracted from data gathered from external sources (Alexa top website ranking <ref type="bibr" target="#b25">[26]</ref> and geo-location of IP addresses). In another related work <ref type="bibr" target="#b26">[27]</ref>, a system for automatic identification of IoT devices and security enforcement of IoT devices is presented. For identification, the system proposed uses 23 features extracted from the fixed number of packets. A twofold classification method is proposed. For the first step, a supervised binary classifier is trained for each device. If multiple classifier gives positive results for a device, then an edit distance based comparison is made in the second step to decide on the final device type. Each classifier is trained using 'one v/s rest' data. This system uses fewer features than DEFT, and in particular does not use important features from DNS, TLS, HTTP, SSDP, STUN, etc. The disadvantage due to this was evident in the classification results-more than a third of the devices had an accuracy of only around 50%. Both the above mentioned solutions use a centralized and supervised learning approach, which neither scales well nor identifies new device types.</p><p>IoT devices can also be identified by fingerprinting radio frequency signals transmitted over the air. A recent interesting work proposed in <ref type="bibr" target="#b27">[28]</ref> uses Symbolic Aggregate Approximation (SAX) to reduce a time-series representation of statistical features of RF signal. A supervised machine learning (k-NN) is applied after SAX reduction, and was observed to classify with high accuracy (in terms of the common metrics of accuracy, precision, recall and F 1 score). Though this work also uses a centralized and supervised learning approach, we find it complementary to our work, as our solution does not analyze features below the network layer in the TCP/IP stack. In particular, it is possible to explore a distributed and semisupervised version of the solution in <ref type="bibr" target="#b27">[28]</ref> to enhance the capability of DEFT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. CONCLUSIONS</head><p>In this work, we developed DEFT, a distributed approach for fingerprinting IoT devices based on network traffic. Our design is scalable, and based on a hierarchical network architecture. The DEFT control logic, that can work as an application in SDN controller, develops, maintains and deploys classifier model at all its gateways. The deployment can be done dynamically using the NFV and microservice architecture. The traffic is classified locally, without being sent to the controller; while the controller coordinates with its gateways to learn models for new unknown devices and updates the model dynamically. We evaluated DEFT on real-world IoT devices, and demonstrated its effectiveness in classifying IoT devices while also identifying new unknown devices. Our results also show that DEFT is scalable requiring significantly less (in several orders of magnitude) communication overhead towards the controller, in comparison with a centralized approach.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 :</head><label>1</label><figDesc>Fig. 1: Hierarchical IoT network architecture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 4 :</head><label>4</label><figDesc>Fig. 4: PCA for different devices</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Algorithm 2 3 :</head><label>23</label><figDesc>clustering at Controller(P) Input: P: List of feature aggregates Variables: T: List of labeled feature aggregates 1: for each set F ∈ P do 2: G = nearestCluster(T, F) if withinICR(F, G) == TRUE then</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Algorithm 3</head><label>3</label><figDesc>nearestCluster(T, F) Input: T: List of labeled feature aggregates F: Set of feature vectors (points) 1: C = ζ(F) computed using Eq. 1 2: G = arg min X ∈T (C -ζ(X )) find nearest based on centroid 3: return G</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Algorithm 4</head><label>4</label><figDesc>withinICR(F 0 , F 1 ) Input: F 0 , F 1 : Feature aggregate Variables: T: List of sets of labeled feature vectors; 1: Compute centroids ζ F0 and ζ F1 using Eq. (1) 2: D(F 0 , F 1 ) = dist(ζ F0 , ζ F1 ) computed using Eq. (2) 3: if | zScore(D(F 0 , F 1 ), µ, σ)| &lt; β then 4: return TRUE 5: end if Algorithm 5 estimateClusterDist(R) Input: R: List of clusters used for training the classifier 1: l = len(R) 2: for i in [1..l -1] do 3:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>end for 7: µ, σ = mean_std(D) Algorithm 6 updateModelClusters(T ) Input: T: List of feature aggregates Variables: R: List of clusters used for training the classifier; M: Classifier model 1: Re-initialize R as an empty list 2: for each F ∈ T do 3:if len(F) &gt; θ then end for 7: M = train(R)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Therefore, the clustering operation has a time complexity of O(|T|). The cost of retraining the classifier depends on the supervised classification used. For example, the standard k-NN (k-nearest neighbors) does not perform any computation for training. Whereas, Naive Bayes classifier takes time linear in the product of the size of the training set and the feature dimension (m). Random Forests with B trees can take between O(mB|F | log 2 |F |) and O(mB|F | 2 log |F |) time depending on the data (or, how balanced the trees are)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 5 :</head><label>5</label><figDesc>Fig. 5: Clustering accuracy as a function of θ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 6 :</head><label>6</label><figDesc>Fig. 6: Inter/Intra cluster box chart for each device</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 8 :</head><label>8</label><figDesc>Fig. 8: Analysis of feature classes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE I :</head><label>I</label><figDesc>List of traffic features extracted</figDesc><table><row><cell cols="2">ID Protocols</cell><cell>Features</cell></row><row><cell></cell><cell></cell><cell>-# DNS queries</cell></row><row><cell></cell><cell></cell><cell>-# DNS errors</cell></row><row><cell>V1</cell><cell>DNS mDNS</cell><cell>-# IN class queries -DNS packet count -Mode of domain name queries</cell></row><row><cell></cell><cell></cell><cell>-DNS packet length (stats)</cell></row><row><cell></cell><cell></cell><cell>-DNS query response time (stats)</cell></row><row><cell>V2</cell><cell>Session statistics</cell><cell>-# packets in session -active duration</cell></row><row><cell></cell><cell></cell><cell>-# TCP keep alive</cell></row><row><cell></cell><cell>TLS</cell><cell>-TLS packet count -TLS packet length (stats)</cell></row><row><cell></cell><cell></cell><cell>-TLS flow duration (stats)</cell></row><row><cell></cell><cell></cell><cell>-# HTTP response code</cell></row><row><cell>V3</cell><cell></cell><cell>-# HTTP method</cell></row><row><cell></cell><cell></cell><cell>-# TCP keep alive</cell></row><row><cell></cell><cell>HTTP</cell><cell>-HTTP request URI</cell></row><row><cell></cell><cell></cell><cell>-HTTP packet count</cell></row><row><cell></cell><cell></cell><cell>-HTTP packet length (stats)</cell></row><row><cell></cell><cell></cell><cell>-HTTP flow duration (stats)</cell></row><row><cell></cell><cell></cell><cell>-SSDP packet count</cell></row><row><cell></cell><cell>SSDP</cell><cell>-SSDP packet length (stats)</cell></row><row><cell></cell><cell></cell><cell>-SSDP flow duration (stats)</cell></row><row><cell></cell><cell></cell><cell>-QUIC packet count</cell></row><row><cell></cell><cell>QUIC</cell><cell>-QUIC packet length (stats) -QUIC flow duration (stats)</cell></row><row><cell></cell><cell></cell><cell>-# QUIC packet type</cell></row><row><cell></cell><cell></cell><cell>-MQTT packet count</cell></row><row><cell>V4</cell><cell>MQTT</cell><cell>-MQTT packet length (stats) -MQTT flow duration (stats)</cell></row><row><cell></cell><cell></cell><cell>-# MQTT packet type</cell></row><row><cell></cell><cell></cell><cell>-STUN packet count</cell></row><row><cell></cell><cell>STUN</cell><cell>-STUN packet length (stats)</cell></row><row><cell></cell><cell></cell><cell>-STUN flow duration (stats)</cell></row><row><cell></cell><cell></cell><cell>-NTP packet count</cell></row><row><cell></cell><cell>NTP</cell><cell>-NTP packet length (stats)</cell></row><row><cell></cell><cell></cell><cell>-NTP flow duration (stats)</cell></row><row><cell></cell><cell></cell><cell>-BOOTP packet count</cell></row><row><cell></cell><cell>BOOTP</cell><cell>-BOOTP packet length (stats)</cell></row><row><cell></cell><cell></cell><cell>-BOOTP flow duration (stats)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE II :</head><label>II</label><figDesc>Table of notations</figDesc><table><row><cell>Notation</cell><cell>Description</cell></row><row><cell>F</cell><cell>Feature vector</cell></row><row><cell>m</cell><cell>Feature dimension</cell></row><row><cell>k</cell><cell>No. of clusters</cell></row><row><cell>F</cell><cell>Aggregate of feature vectors</cell></row><row><cell>M</cell><cell>Model for supervised classification</cell></row><row><cell>P</cell><cell>List of feature aggregates</cell></row><row><cell>T</cell><cell>List of merged feature aggregates</cell></row><row><cell>R</cell><cell>List of clusters</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Traffic session; X: device address Variables: c: device class; p: prob. of classification, diffident sessions[X]: list of sessions via interface X 1: if ExistsNewModel == TRUE then</figDesc><table><row><cell>2:</cell><cell>M ← From_Controller()</cell><cell>Update model</cell></row><row><cell cols="2">3: end if</cell><cell></cell></row><row><cell cols="2">4: F = ExtractFeature(S)</cell><cell></cell></row><row><cell cols="2">5: [c, p] ← Classify_GW(F, M)</cell><cell></cell></row><row><cell cols="2">6: if p &lt; threshold then</cell><cell>If confidence is low</cell></row><row><cell>7:</cell><cell>diffident sessions[X].append(F)</cell><cell></cell></row><row><cell>8:</cell><cell cols="2">if len(diffident sessions[X] == θ then</cell></row><row><cell>9:</cell><cell cols="2">SendToController(diffident sessions[X])</cell></row><row><cell>10:</cell><cell>diffident sessions[X] = []</cell><cell>Empty list</cell></row><row><cell>11:</cell><cell>end if</cell><cell></cell></row><row><cell>12:</cell><cell></cell><cell></cell></row></table><note><p>4) k-means clustering: k-means is a clustering algorithm used to partition a given set of data points into k clusters, where k is provided as input. If µ 1 , µ 2 , . . . , µ k represent the Algorithm 1 fingerprinting at GW(S, X) Input: S:</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>TABLE III :</head><label>III</label><figDesc>Information on IoT devices used</figDesc><table><row><cell>Label</cell><cell>Device</cell><cell>Brand</cell><cell>Sessions captured</cell></row><row><cell>0</cell><cell>Echo dot</cell><cell>Amazon</cell><cell>490</cell></row><row><cell>1</cell><cell>Smart remote</cell><cell>Broadlink</cell><cell>480</cell></row><row><cell>2</cell><cell>Camera (DCS930L)</cell><cell>D-Link</cell><cell>384</cell></row><row><cell>3</cell><cell>Camera (DCS5030L)</cell><cell>D-Link</cell><cell>410</cell></row><row><cell>4</cell><cell>Smart socket (DSPW215)</cell><cell>D-Link</cell><cell>672</cell></row><row><cell>5</cell><cell>Chromecast</cell><cell>Google</cell><cell>297</cell></row><row><cell>6</cell><cell>Home control</cell><cell>Google</cell><cell>529</cell></row><row><cell>7</cell><cell>Smart bulb</cell><cell>MI</cell><cell>295</cell></row><row><cell>8</cell><cell>Smart socket</cell><cell>Oittm</cell><cell>394</cell></row><row><cell>9</cell><cell>Hue light</cell><cell>Philips</cell><cell>644</cell></row><row><cell>10</cell><cell>Smart things</cell><cell>Samsung</cell><cell>587</cell></row><row><cell>11</cell><cell>Smart bulb (LB100)</cell><cell>TP-Link</cell><cell>482</cell></row><row><cell>12</cell><cell>Camera (NC250)</cell><cell>TP-Link</cell><cell>587</cell></row><row><cell>13</cell><cell>Camera (NC450)</cell><cell>TP-Link</cell><cell>494</cell></row><row><cell>14</cell><cell>Smart socket (HS100)</cell><cell>TP-Link</cell><cell>452</cell></row><row><cell>15</cell><cell>Smart socket (HS110)</cell><cell>TP-Link</cell><cell>387</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>TABLE IV :</head><label>IV</label><figDesc>Precision, recall and F 1 score for devices</figDesc><table><row><cell>Device</cell><cell cols="3">Precision Recall F1 Score</cell></row><row><cell>Echo dot</cell><cell>0.99</cell><cell>1.00</cell><cell>0.99</cell></row><row><cell>Smart remote</cell><cell>1.00</cell><cell>1.00</cell><cell>1.00</cell></row><row><cell>Camera (DCS930L)</cell><cell>1.00</cell><cell>1.00</cell><cell>1.00</cell></row><row><cell>Camera (DCS5030L)</cell><cell>1.00</cell><cell>1.00</cell><cell>1.00</cell></row><row><cell>Smart socket (DSPW215)</cell><cell>0.96</cell><cell>0.98</cell><cell>0.97</cell></row><row><cell>Chromecast</cell><cell>1.00</cell><cell>1.00</cell><cell>1.00</cell></row><row><cell>Home control</cell><cell>1.00</cell><cell>1.00</cell><cell>1.00</cell></row><row><cell>Smart bulb</cell><cell>0.95</cell><cell>1.00</cell><cell>0.97</cell></row><row><cell>Smart socket</cell><cell>1.00</cell><cell>1.00</cell><cell>1.00</cell></row><row><cell>Hue light</cell><cell>1.00</cell><cell>1.00</cell><cell>1.00</cell></row><row><cell>Smart things</cell><cell>1.00</cell><cell>1.00</cell><cell>1.00</cell></row><row><cell>Smart bulb (LB100)</cell><cell>1.00</cell><cell>0.99</cell><cell>1.00</cell></row><row><cell>Camera (NC250)</cell><cell>0.80</cell><cell>0.89</cell><cell>0.85</cell></row><row><cell>Camera (NC450)</cell><cell>1.00</cell><cell>1.00</cell><cell>1.00</cell></row><row><cell>Smart socket (HS100)</cell><cell>0.99</cell><cell>1.00</cell><cell>1.00</cell></row><row><cell>Smart socket (HS110)</cell><cell>0.90</cell><cell>0.66</cell><cell>0.76</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>• V 1 : DNS being one of the fundamental protocols of the Internet, features extracted from DNS protocol could</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENT</head><p>This research is supported by the National Research Foundation, Prime Minister's Office, Singapore under its Corporate Laboratory@University Scheme, National University of Singapore, and Singapore Telecommunications Ltd.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><surname>Ericsson</surname></persName>
		</author>
		<ptr target="https://www.ericsson.com/en/mobility-report/reports/november-2017/internet-of-things-outlook" />
		<title level="m">IoT connections outlook (Mobility report)</title>
		<imprint>
			<date type="published" when="2017-11">Nov. 2017. May 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A Smart Home is No Castle: Privacy Vulnerabilities of Encrypted IoT Traffic</title>
		<author>
			<persName><forename type="first">N</forename><surname>Apthorpe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Reisman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Feamster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Data and Algorithmic Transparency (DAT&apos;16)</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Understanding the Mirai Botnet</title>
		<author>
			<persName><forename type="first">M</forename><surname>Antonakakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>April</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bailey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bernhard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Bursztein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cochran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Durumeric</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Halderman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Invernizzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kallitsis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mason</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Menscher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Seaman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sullivan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 26th USENIX Security Symposium</title>
		<meeting>26th USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1093" to="1110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Security and Privacy Challenges in Industrial Internet of Things</title>
		<author>
			<persName><forename type="first">A.-R</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wachsmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Waidner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 52nd Annual Design Automation Conference, ser. ACM DAC &apos;15</title>
		<meeting>the 52nd Annual Design Automation Conference, ser. ACM DAC &apos;15</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="page">6</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">On the authentication of devices in the internet of things</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Sharaf-Dabbagh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Saad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 17th Int&apos;l Symposium on World of Wireless, Mobile and Multimedia Networks (WoWMoM)</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1" to="3" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Machine Learning for Encrypted Malware Traffic Classification: Accounting for Noisy Labels and Non-Stationarity</title>
		<author>
			<persName><forename type="first">B</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mcgrew</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 23rd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</title>
		<meeting>23rd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="1723" to="1732" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Semi-supervised Clustering by Seeding</title>
		<author>
			<persName><forename type="first">S</forename><surname>Basu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Mooney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Nineteenth International Conference on Machine Learning, ser. ICML &apos;02</title>
		<meeting>the Nineteenth International Conference on Machine Learning, ser. ICML &apos;02</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="27" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Algorithm Runtime Prediction: Methods &amp; Evaluation</title>
		<author>
			<persName><forename type="first">F</forename><surname>Hutter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">H</forename><surname>Hoos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Leyton-Brown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">206</biblScope>
			<biblScope unit="page" from="79" to="111" />
			<date type="published" when="2014-01">Jan. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Scikit-learn: Machine learning in Python</title>
		<author>
			<persName><forename type="first">F</forename><surname>Pedregosa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varoquaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gramfort</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Michel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Thirion</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grisel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Blondel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Prettenhofer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Weiss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Dubourg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vanderplas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Passos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Cournapeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Brucher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Perrot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Duchesnay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="2825" to="2830" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">On Fast and Accurate Detection of Unauthorized Wireless Access Points Using Clock Skews</title>
		<author>
			<persName><forename type="first">S</forename><surname>Jana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Kasera</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Mobile Computing</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="449" to="462" />
			<date type="published" when="2010-03">March 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A passive approach to wireless device fingerprinting</title>
		<author>
			<persName><forename type="first">K</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Corbett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Beyah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="383" to="392" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Device fingerprinting in wireless networks: Challenges and opportunities</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Saad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Communications Surveys &amp; Tutorials</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="94" to="104" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">OS fingerprinting: New techniques and a study of information gain and obfuscation</title>
		<author>
			<persName><forename type="first">B</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mcgrew</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Conference on Communications and Network Security (CNS)</title>
		<meeting>IEEE Conference on Communications and Network Security (CNS)</meeting>
		<imprint>
			<date type="published" when="2017-10">Oct 2017</date>
			<biblScope unit="page" from="1" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Markov chain fingerprinting to classify encrypted traffic</title>
		<author>
			<persName><forename type="first">M</forename><surname>Korczyski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Duda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE INFOCOM</title>
		<meeting>IEEE INFOCOM</meeting>
		<imprint>
			<date type="published" when="2014-04">April 2014</date>
			<biblScope unit="page" from="781" to="789" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">DECANTeR: DEteCtion of Anomalous outbouNd HTTP TRaffic by Passive Application Fingerprinting</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bortolameotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Van Ede</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Caselli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Everts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hartel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hofstede</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Jonker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Peter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc.33rd Annual Computer Security Applications Conference</title>
		<meeting>.33rd Annual Computer Security Applications Conference</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017">2017. 2017</date>
			<biblScope unit="page" from="373" to="386" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Indoor localization for IoT applications using fingerprinting</title>
		<author>
			<persName><forename type="first">P</forename><surname>Fonseka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sandrasegaran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE 4th World Forum on Internet of Things (WF-IoT)</title>
		<imprint>
			<date type="published" when="2018-02">Feb 2018</date>
			<biblScope unit="page" from="736" to="741" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">CSI Phase Fingerprinting for Indoor Localization With a Deep Learning Approach</title>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Internet of Things Journal</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1113" to="1123" />
			<date type="published" when="2016-12">Dec 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">CSI Amplitude Fingerprinting-Based NB-IoT Indoor Localization</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Internet of Things Journal</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1494" to="1504" />
			<date type="published" when="2018-06">June 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<ptr target="http://lcamtuf.coredump.cx/p0f3" />
		<title level="m">A tool for passive traffic fingerprinting</title>
		<imprint>
			<date type="published" when="2018-05">May 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Nmap: The Network Mapper -free security scanner</title>
		<ptr target="https://nmap.org" />
		<imprint>
			<date type="published" when="2018-05">May 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Experiments with security and privacy in iot networks</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Schurgot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Shinberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">G</forename><surname>Greenwald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 16th IEEE International Symposium on World of Wireless, Mobile and Multimedia Networks (WoWMoM)</title>
		<meeting>16th IEEE International Symposium on World of Wireless, Mobile and Multimedia Networks (WoWMoM)</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Security, privacy and trust in Internet of Things: The road ahead</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sicari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rizzardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Grieco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Coen-Porisini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Networks</title>
		<imprint>
			<biblScope unit="volume">76</biblScope>
			<biblScope unit="page" from="146" to="164" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Spying on the smart home: Privacy attacks and defenses on encrypted iot traffic</title>
		<author>
			<persName><forename type="first">N</forename><surname>Apthorpe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Reisman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sundaresan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Narayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Feamster</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1708.05044</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A Survey on Transfer Learning</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Knowledge and Data Engineering</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1345" to="1359" />
			<date type="published" when="2010-10">Oct 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">ProfilIoT: A Machine Learning Approach for IoT Device Identification Based on Network Traffic Analysis</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Meidan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bohadana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shabtai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Guarnizo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ochoa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">O</forename><surname>Tippenhauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Elovici</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Symposium on Applied Computing</title>
		<meeting>Symposium on Applied Computing</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="506" to="509" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Alexa top sites</title>
		<ptr target="https://www.alexa.com/topsites" />
		<imprint>
			<date type="published" when="2018-05">May 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">IoT Sentinel: Automated device-type identification for security enforcement in IoT</title>
		<author>
			<persName><forename type="first">M</forename><surname>Miettinen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Marchal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Hafeez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Asokan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-R</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tarkoma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE 37th International Conference on Distributed Computing Systems (ICDCS)</title>
		<meeting>IEEE 37th International Conference on Distributed Computing Systems (ICDCS)</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="2177" to="2184" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The application of the Symbolic Aggregate Approximation algorithm (SAX) to radio frequency fingerprinting of IoT devices</title>
		<author>
			<persName><forename type="first">G</forename><surname>Baldini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Giuliani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Steri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Sanchez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gentile</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Communications and Vehicular Technology</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
