<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Practical Constructions and New Proof Methods for Large Universe Attribute-Based Encryption</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yannis</forename><surname>Rouselakis</surname></persName>
						</author>
						<author role="corresp">
							<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
							<email>bwaters@cs.utexas.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">The University of Texas at Austin</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">The University of Texas at Austin</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Practical Constructions and New Proof Methods for Large Universe Attribute-Based Encryption</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">09F2F78764C636478FA9EA1CCD8E0AAE</idno>
					<idno type="DOI">10.1145/2508859.2516672</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:04+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>E.3 [Data]: Data Encryption-Public key cryptosystems Security</term>
					<term>Theory attribute-based encryption</term>
					<term>large universe</term>
					<term>unbounded</term>
					<term>qtype assumptions</term>
					<term>ciphertext-policy</term>
					<term>key-policy</term>
					<term>Charm</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We propose two large universe Attribute-Based Encryption constructions. In a large universe ABE system any string can be used as an attribute and attributes need not be enumerated at system setup. Our first construction establishes a novel large universe Ciphertext-Policy ABE scheme on prime order bilinear groups, while the second achieves a significant efficiency improvement over the large universe Key-Policy ABE system of Lewko-Waters and Lewko. Both schemes are selectively secure in the standard model under two "q-type" assumptions similar to ones used in prior works. Our work brings back "program and cancel" techniques to this problem and aims in providing practical large universe ABE implementations.</p><p>To showcase the efficiency improvements over prior constructions, we provide implementations and benchmarks of our schemes in Charm; a programming environment for rapid prototyping of cryptographic primitives. We compare them to implementations of the only three published constructions that offer unbounded ABE in the standard model.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Traditionally, public key encryption schemes provided any user with the ability to share data with another specific user in a private manner. However, in many applications we would like to have the additional capability to encrypt data for a set of users according to a specific policy on their credentials. For example, one might want to store data in a public server such that only parties with credentials of specific forms are able to decrypt. Instead of encrypting the data once for each party it would be beneficial to be able to encrypt only once for all desired parties. This encryption notion, called Attribute-Based Encryption (ABE), was introduced by Sahai and Waters <ref type="bibr" target="#b38">[36]</ref>. In this setting, each user possesses a set of attributes/credentials and a secret key that corresponds to these credentials. The encrypting party can define any Boolean formula on the possible attributes and a user can decrypt if and only if his attribute set satisfies the Boolean formula.</p><p>Several attribute-based constructions have been presented since then (see related work below). A common classification property is whether a system is a "small universe" or "large universe" constructions. In "small universe" constructions the size of the attribute space is polynomially bounded in the security parameter and the attributes were fixed at setup. Moreover, the size of the public parameters grew linearly with the number of attributes. In "large universe" constructions, on the other hand, the size of the attribute universe can be exponentially large, which is a desirable feature.</p><p>Achieving the large universe property can be challenging. Different works either imposed restrictions on the expressiveness of the policies or were proved secure in the random oracle model. For example, in <ref type="bibr" target="#b20">[20]</ref> a bound n was fixed at setup on the number of attributes that could be used while encrypting a message. For constructions that had no bounds on the expressiveness of policies and constant sized public parameters, the random oracle security model was used.</p><p>The above restrictions place undesirable burdens on the deployment of ABE schemes. If the designer of the system desires the benefits of avoiding the random oracle heuristic, he has to pick a specific bound for the expressiveness of the system at the setup time; either the size of the attribute universe or the bound on the policies. If the bound is too small, the system might exhaust its functionality and will have to be completely rebuilt. For example, consider the design of a framework that allows Attribute-Based Encryption in a huge multinational company and suppose that, as this company expands, a large number of new attributes have to be added to the system. If this number exceeds the bound set during the initial deployment of the system, then the company would have to re-deploy the (expanded) system and possibly re-encrypt all its data spending a huge amount of expenses. On the other hand, if the bound chosen is too big, the increased size of the public parameters will impose an unnecessary efficiency burden on all operations. The first large-universe constructions in the standard model were presented in the recent work of Lewko and Waters <ref type="bibr" target="#b26">[25]</ref>. They presented the first large universe KP-ABE construction, secure in the standard model. The system was proved selectively secure under static assumptions. The authors of <ref type="bibr" target="#b26">[25]</ref> refer to their construction as an "unbounded" scheme, in the sense that the public parameters do not impose additional limitations on the functionality of the systems. Their scheme is indeed large universe, since the size of the attribute universe is exponentially large in the security parameter.</p><p>The authors utilized the dual system framework on composite order groups to prove security. While this framework is highly useful for the proofs, the actual constructions require use of bilinear groups of large composite order. As a result, these schemes sustain a significant efficiency overhead in comparison to prime order ABE constructions. In a recent result <ref type="bibr" target="#b23">[22]</ref> building on <ref type="bibr" target="#b31">[30,</ref><ref type="bibr" target="#b34">32,</ref><ref type="bibr" target="#b24">23,</ref><ref type="bibr" target="#b17">17]</ref>, one can actually "emulate" the effects of the composite order groups by creating special subspaces of vectors, called dual vector spaces introduced by Okamoto and Takashima, and construct a large universe KP-ABE system on prime order groups. This improves the efficiency of the original construction, but there is still a significant performance penalty due to the required size of the vectors.</p><p>In a subsequent work by Okamoto and Takashima <ref type="bibr" target="#b35">[33]</ref>, another unbounded KP-ABE scheme and the first unbounded CP-ABE scheme are presented. Both of them are the first fully secure unbounded ABE schemes in the standard model and utilize the dual vector spaces framework. Their systems are unbounded, since the size of the public parameters is constant and does not impose any limitations on the size of the attribute universe. However, the traditional notion of "large"-"small" universe is not applicable, since each "attribute" can take one or more different values from an exponential-sized space, instead of "present"/"not present". The total number of these sub-universes should be polynomial in the security parameter and the maximum number of times each sub-universe can be used in a policy is a parameter fixed at the setup of the system. As this bound is increased, the overall efficiency of the system is impaired. In our benchmarks, we implement the most efficient "basic version" of their constructions where this parameter is equal to 1, i.e. each sub-universe can be present only once in each policy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Goals and Contributions</head><p>We present new constructions and proof techniques for Large Universe ABE in the standard model. Departing from the above recent trends, our constructions are proved selectively secure using what is know as partitioning style techniques.</p><p>We believe that this is an interesting avenue to explore for two reasons. First, by considering selective model of security we are able to get more efficient and more practical constructions. While full security is the strongest notion of security, we believe selective is still a meaningful notion and can be a reasonable trade off for performance in some circumstances. In addition, new partitioning proofs can give different and new insights into the security or the style of a construction.</p><p>Second, Lewko and Waters <ref type="bibr" target="#b27">[26]</ref> recently showed a surprising connection between Dual System Encryption and older selective proofs. Prior fully secure ABE systems <ref type="bibr" target="#b24">[23]</ref> required an additional (relative to selective schemes) limit t on the number of times an attribute could be used in a formula. The public parameters and ciphertext size for KP-ABE (key size for CP-ABE) grew proportionally to the bound t. Lewko and Waters showed that through a new "delayed parameter" variant of Dual System Encryption this limit could be done away with. An integral part of their proof was that it leveraged older "program and cancel" style techniques. Given this recent work, a reasonable conclusion is that developing selectively secure proofs might typically become a first step to developing full security. (We note that the large universe construction of <ref type="bibr" target="#b26">[25]</ref> was only proved selectively secure.)</p><p>We aim to get practical large-universe ABE schemes by adapting and expanding the system from <ref type="bibr" target="#b26">[25]</ref> into the prime order setting. In proving security we go back to more traditional "program and cancel" techniques instead of the dual system framework. We present two practical large universe ABE constructions (one CP-ABE and one KP-ABE) in prime order bilinear groups both selectively secure in the standard model under two different q-type assumptions. Our three main objectives in this work were large universe constructions, efficiency, and security in the standard model. Both schemes support a "large universe" attribute space and their public parameters consist of a constant number of group elements. No bounds or other restrictions are imposed on the monotonic Boolean formulas or the attribute sets used by the algorithms of the schemes; thus eliminating the need for design decisions at setup. The efficiency objective refrained us from using composite order groups or dual pairing vector spaces, while to achieve security in the standard model we relied on non static (q-type) assumptions and selective notions. These assumptions are non static in the sense that a polynomial number of terms is given to the adversary and therefore they are intuitively stronger than the static ones. However, the polynomial number of terms gives the ability to the simulator of the proof to embed the additional entropy in the constant number of public parameters. We showcase different techniques for harnessing the power of these assumptions to achieve our large universe constructions. Finally, we demonstrate the efficiency of our constructions by implementing our schemes. We compare performance results to other ABE schemes in prime order groups.</p><p>Our Techniques The techniques used to achieve our goals and prove the security of our schemes fall in the category of partitioning methodologies. In this setting the simulator of the reduction sets up the public parameters of the systems in such a way that the set of the possible policies (for KP-ABE) or the powerset of the attribute universe (for CP-ABE) is partitioned in two disjoint sets. One for which he can create the secret keys and answer the attackers' queries, and one for which this is not possible, where the challenge query should belong. Since we are dealing with se-lective security notions, the simulator knows in advance the required challenge set and therefore the suitable partition. However due to the fact that we are aiming for large universe ABE, which implies constant size public parameters, the simulator has to embed a polynomial amount of "challenge information" in them. This is achieved by utilizing the non static power of our assumptions. Namely, the assumptions' "size" depends on the size of the declared challenge query. The additional terms available to the simulator allow him to create all the necessary terms for the reduction.</p><p>Both our schemes work in a "layered" fashion in order to encrypt information securely and being able to decrypt. In the KP-ABE construction, which is simpler and directly inspired by the composite order construction of <ref type="bibr" target="#b26">[25]</ref>, two "layers" are employed: the "secret sharing" layer and the "attribute layer". The first layer is responsible for the sharing of the master secret key during the key generation algorithm and the storing of the blinding factor randomness during the encryption algorithm. The "attribute layer" holds information about the attributes used in both key generation and encryption phases. A "binder term" is utilized to connect the two layers in a secure way. In the CP-ABE construction the situation is slightly more complicated due to the fact that the policies are applied on the ciphertext side. As a result, the "sharing" is applied to the blinding factor randomness and not on the master secret key. Therefore, an additional "binder term" in the public parameters is being used to allow correct decryption using the master secret key. As we will see, the assumptions and the corresponding reductions follow closely this "layer" intuition.</p><p>Finally, we mention that both constructions use the "individual randomness" technique from <ref type="bibr" target="#b26">[25]</ref> in the "attribute layer" to achieve the large universe functionality. The component for each attribute is masked by a different randomness and as a result no restrictions are imposed on the policies or the attributes, since each component is individually randomized.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Related Work</head><p>Attribute-Based Encryption was introduced by Sahai and Waters <ref type="bibr" target="#b38">[36]</ref>. The refinement of the two notions was given in <ref type="bibr" target="#b20">[20]</ref> and many CP-ABE and KP-ABE selectively secure constructions followed <ref type="bibr">[6,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b19">19,</ref><ref type="bibr" target="#b36">34,</ref><ref type="bibr" target="#b37">35,</ref><ref type="bibr" target="#b45">43]</ref>. Most of them work for monotonic access structures with the exception of the schemes by Ostrovsky, Sahai, and Waters <ref type="bibr" target="#b36">[34]</ref>, who showed how to realize negation by incorporating specific revocation schemes into the GPSW construction. Fully secure constructions in the standard model were first provided by Okamoto and Takashima <ref type="bibr" target="#b34">[32]</ref> and Lewko, Okamoto, Sahai, Takashima, and Waters <ref type="bibr" target="#b24">[23]</ref>. The first large universe KP-ABE construction in the standard model was given in <ref type="bibr" target="#b26">[25]</ref> (composite order groups) and the first fully secure unbounded constructions were given in <ref type="bibr" target="#b35">[33]</ref>. Okamoto and Takashima initiated the dual pairing vector space framework in various works <ref type="bibr" target="#b31">[30,</ref><ref type="bibr" target="#b32">31,</ref><ref type="bibr" target="#b34">32]</ref>, which lead to the first large universe KP-ABE construction in prime order group groups by Lewko <ref type="bibr" target="#b23">[22]</ref>. Parameterized (non static) assumptions were introduced in <ref type="bibr" target="#b7">[7]</ref> and used in several subsequent works <ref type="bibr" target="#b18">[18,</ref><ref type="bibr" target="#b45">43]</ref>. The problem of an environment with multiple central authorities in ABE was considered in <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b25">24]</ref>, while several authors have presented schemes that do not address the problem of collusion resistance <ref type="bibr" target="#b42">[40,</ref><ref type="bibr" target="#b29">28,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b2">2,</ref><ref type="bibr" target="#b3">3,</ref><ref type="bibr" target="#b4">4]</ref>.</p><p>We note that several techniques in ABE schemes have roots in Identity-Based Encryption <ref type="bibr" target="#b39">[37,</ref><ref type="bibr" target="#b8">8,</ref><ref type="bibr" target="#b16">16,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b44">42,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b9">9]</ref>. Finally, we mention here the related concept of Predicate Encryption introduced by Katz, Sahai, and Waters <ref type="bibr" target="#b22">[21]</ref> and further refined in <ref type="bibr" target="#b41">[39,</ref><ref type="bibr" target="#b40">38,</ref><ref type="bibr" target="#b32">31,</ref><ref type="bibr" target="#b24">23,</ref><ref type="bibr" target="#b34">32,</ref><ref type="bibr" target="#b10">10]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Organization</head><p>In Sec. 2 we introduce some notation, background information about access structures and linear secret-sharing schemes, and the complexity assumption for our CP-ABE scheme. Section 3 contains the algorithms and the selective security definition for CP-ABE schemes. Our CP-ABE construction and the security proof are in Sec. 4. Finally, implementations and efficiency results are presented in Sec. 5.</p><p>The assumption for our KP-ABE construction is in App. A. In App. B and App. C we present the KP-ABE algorithms with the security definition, and our KP-ABE construction with the security proof, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PRELIMINARIES 2.1 Notation</head><formula xml:id="formula_0">For n ∈ N, we define [n] def. = {1, 2, . . . , n}. Also, for n1, n2, . . . , n k ∈ N: [n1, n2, . . . , n k ] def. = [n1] × [n2] × . . . × [nm].</formula><p>When S is a set, we denote by s $ ← S the fact that the variable s is picked uniformly at random from S. We write s1, s2, . . . , sn When v is a vector (of any type), we will denote by vi the i-th element and by v, w the inner product of vectors v and w.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Access Structures and Linear Secret-Sharing Schemes</head><p>In this section, we present the formal definitions of access structures and linear secret-sharing schemes introduced in <ref type="bibr" target="#b5">[5]</ref>, adapted to match our setting. Definition 2.1 (Access Structures <ref type="bibr" target="#b5">[5]</ref>). Let U be the attribute universe. An access structure on U is a collection A of non-empty sets of attributes, i.e. A ⊆ 2 U \ { }. The sets in A are called the authorized sets and the sets not in A are called the unauthorized sets.</p><p>Additionally, an access structure is called</p><formula xml:id="formula_1">monotone if ∀B, C ∈ A : if B ∈ A and B ⊆ C, then C ∈ A.</formula><p>In our constructions, we only consider monotone access structures, which means that as a user (CP-ABE setting) acquires more attributes, he will not lose his possible decryption privileges. General access structures in large universe ABE can be realized by splitting the attribute universe in half and treating the attributes of one half as the negated versions of the attributes in the other half <ref type="bibr" target="#b20">[20]</ref>. We note that if the access structure is encoded as a monotonic Boolean formula over attributes 1 , there is a generic algorithm that generates the corresponding access policy in polynomial time <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b25">24]</ref>. Definition 2.2 (Linear Secret-Sharing Schemes (LSSS) <ref type="bibr" target="#b5">[5]</ref>). Let p be a prime and U the attribute universe. A secretsharing scheme Π with domain of secrets Zp realizing access structures on U is linear over Zp if 1. The shares of a secret s ∈ Zp for each attribute form a vector over Zp.</p><p>2. For each access structure A on U, there exists a matrix M ∈ Z ×n p , called the share-generating matrix, and a function ρ, that labels the rows of M with attributes from U, i.e. ρ : [ ] → U, which satisfy the following:</p><p>During the generation of the shares, we consider the column vector v = (s, r2, . . . , rn) , where r2, . . ., rn $ ← Zp. Then the vector of shares of the secret s according to Π is equal to M v ∈ Z ×1 p . The share (M v)j where j ∈ [ ] "belongs" to attribute ρ(j).</p><p>We will be referring to the pair (M, ρ) as the policy of the access structure A.</p><p>According to <ref type="bibr" target="#b5">[5]</ref>, each secret-sharing scheme (not only the linear ones) should satisfy the reconstruction requirement (each authorized set can reconstruct the secret) and the security requirement (any unauthorized set cannot reveal any partial information about the secret).</p><p>In our setting, let S denote an authorized set for the access structure A encoded by the policy (M, ρ). Then let I be the set of rows whose labels are in S, i.e. I = {i|i ∈ [ ] ∧ ρ(i) ∈ S}. The reconstruction requirement asserts that the vector (1, 0, . . . , 0) is in the span of rows of M indexed by I. This means that there exist constants {ωi} i∈I in Zp such that for any valid shares {λi = (M v)i} i∈I of a secret s according to Π, it is true that: i∈I ωiλi = s. Additionally, it has been proved in <ref type="bibr" target="#b5">[5]</ref> that the constants {ωi} i∈I can be found in time polynomial in the size of the share-generating matrix M .</p><p>On the other hand, for unauthorized sets S no such constants {ωi} exist. Moreover, in this case it is also true that if I = {i|i ∈ [ ] ∧ ρ(i) ∈ S }, there exists a vector w ∈ Z 1×n p , such that its first component w1 is any non zero element in Zp and Mi, w = 0 for all i ∈ I , where Mi = (Mi,1, Mi,2, . . . , Mi,n); the i-th row of M .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Assumption 1</head><p>For our CP-ABE construction we will use a q-type assumption on prime order bilinear groups, denoted by q-1, which is similar to the Decisional Parallel Bilinear Diffie-Hellman Exponent Assumption <ref type="bibr" target="#b45">[43]</ref>. It is parameterized by a security parameter λ ∈ N and an integer q, polynomial in λ. We assume that there exists a group generator algorithm G(1 λ ) → (p, G, GT , e) that outputs the description of the (symmetric) bilinear group of order p = Θ(2 λ ). This assumption can be proved secure in the generic group model, but the proof is omitted due to space constraints. It is defined via the following game between a challenger and an attacker:</p><p>Initially the challenger calls the group generation algorithm with input the security parameter, picks a random that as a key (in CP-ABE) or a ciphertext (in KP-ABE) acquires more attributes it will not lose the decryption capabilities. group element g $ ← G, and q + 2 random exponents a, s, b1, b2, . . ., bq $ ← Zp. Then he sends to the attacker the group description (p, G, GT , e) and all of the following terms:</p><formula xml:id="formula_2">g, g s g a i , g b j , g sb j , g a i b j , g a i /b 2 j ∀(i, j) ∈ [q, q] g a i b j /b 2 j ∀(i, j, j ) ∈ [2q, q, q] with j = j g a i /b j ∀(i, j) ∈ [2q, q] with i = q + 1 g sa i b j /b j , g sa i b j /b 2 j ∀(i, j, j ) ∈ [q, q, q] with j = j</formula><p>The challenger also flips a random coin b $ ← {0, 1} and if b = 0, it gives to the attacker the term e(g, g) sa q+1</p><p>. Otherwise it gives a random term R $ ← GT . Finally the attacker outputs a guess b ∈ {0, 1}. Definition 2.3. We say that the q-1 assumption holds if all PPT attackers have at most a negligible advantage in λ in the above security game, where the advantage is defined as</p><formula xml:id="formula_3">Adv = Pr [b = b] -1/2.</formula><p>Remark: Notice the absence of the term g a q+1 /b j in the fourth line of the assumption. If this term were given to the attacker, then he could break the assumption trivially by pairing it with the corresponding g sb j term. On the other hand, the term g a q+1 b j /b 2 j is given, and this poses no problems in the generic group model since j = j and by possible pairing the adversary cannot get rid of the bj's.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">CIPHERTEXT -POLICY ATTRIBUTE -BASED ENCRYPTION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Algorithms</head><p>A Ciphertext-Policy Attribute-Based Encryption scheme consists of the following four PPT algorithms:</p><p>• Setup(1 λ ) → (pp, msk):</p><p>The Setup algorithm takes the security parameter λ ∈ N encoded in unary and outputs the public parameters pp and the master secret key msk. We assume that the public parameters contain a description of the attribute universe U. 2  • KeyGen(1 λ , pp, msk, S) → sk: The key generation algorithm takes as inputs the public parameters pp, the master secret key msk and a set of attributes S ⊆ U. The security parameter is included in the inputs to ensure that it is polynomial time in λ. The algorithm generates a secret key corresponding to S.</p><p>• Encrypt(1 λ , pp, m, A) → ct: The encryption algorithm takes as inputs the public parameters pp, a plaintext message m, and an access structure A on U. It outputs the ciphertext ct.</p><p>• Decrypt(1 λ , pp, sk, ct) → m: The decryption algorithm takes as inputs the public parameters pp, a secret key sk, and a ciphertext ct. It outputs the plaintext m.</p><p>Correctness:</p><p>We require that a CP-ABE scheme is correct, i.e the decryption algorithm correctly decrypts a ciphertext of an access structure A with a secret key on S, when S is an authorized set of A. Formally: 2 In previous CP-ABE constructions the attribute universe U (or its size) was one of the arguments of the Setup algorithm. In our constructions, the attribute universe depends only on the size of the underlying group G, which depends on the security parameter λ and the group generation algorithm. Definition 3.1. A CP-ABE scheme is correct when for all messages m, and all attribute sets S and access structures A with S ∈ A (i.e. for S authorized), any pair (pp, msk) output from Setup(1 λ ), any secret key sk output from KeyGen (1 λ , pp, msk, S), and any ciphertext ct output by Encrypt (1 λ , pp, m, A), it is true that: Decrypt(1 λ , pp, sk, ct) = m.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">CP-ABE Selective Security</head><p>In this section we present the definition of selective security for CP-ABE schemes. This is described by a game between a challenger and an attacker and is parameterized by the security parameter λ ∈ N. The phases of the game are the following:</p><p>• Initialization: In this phase the attacker declares the challenge access structure A * , which he will try to attack, and sends it to the challenger.</p><p>• Setup: Here the challenger calls the Setup(1 λ ) algorithm and sends the public parameters pp to the attacker.</p><p>• Query Phase 1:</p><p>In this phase the attacker can adaptively ask for secret keys for the sets of attributes S1, S2, . . ., SQ 1 . For each Si the challenger calls KeyGen(msk, Si) → ski and sends ski to the attacker. The restriction that has to be satisfied for each query is that none of the queried sets satisfies the challenge access structure, i.e. ∀i ∈ [Q1] : Si / ∈ A * .</p><p>• Challenge:</p><p>The attacker declares two equal-length plaintexts m0 and m1 and sends them to the challenger. He flips a random coin b ∈ {0, 1} and calls Encrypt(m b , A * ) → ct. He sends ct to the attacker.</p><p>• Query Phase 2: This the same as query phase 1. The attacker asks for the secret key for the sets SQ 1 +1, SQ 1 +2, . . ., SQ, for which the same restriction holds: ∀i ∈</p><formula xml:id="formula_4">[Q] : Si / ∈ A * .</formula><p>• Guess: The attacker outputs his guess b ∈ {0, 1} for b. Definition 3.2. A CP-ABE scheme is selectively secure if all PPT attackers have at most a negligible advantage in λ in the above security game, where the advantage of an attacker is defined as</p><formula xml:id="formula_5">Adv = Pr [b = b] -1/2.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">OUR LARGE UNIVERSE CP-ABE</head><p>In this section we present our large universe CP-ABE construction. The public parameters consist of the six group elements (g, u, h, w, v, e(g, g) α ), which intuitively are utilized in two separate "layers" to achieve secure large universe CP-ABE. In the "attribute layer", the u, h terms provide a Boneh-Boyen-style <ref type="bibr" target="#b7">[7]</ref> hash function (u A h), while in the "secret sharing layer" the w term holds the secret randomness r during key generation and the shares of the secret randomness s during encryption. The v term is used to "bind" the two layers together. The g and e(g, g) α terms are used to introduce the master secret key functionality and allow correct decryption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Construction</head><p>Our scheme consists of the following four algorithms:</p><p>• Setup(1 λ ) → (pp, msk): The setup algorithm calls the group generator algorithm G(1 λ ) and gets the descriptions of the groups and the bilinear mapping D = (p, G, GT , e), where p is the prime order of the groups G and GT . The attribute universe is U = Zp.</p><p>Then the algorithm picks the random terms g, u, h, w, v $ ← G and α $ ← Zp. It outputs pp = (D, g, u, h, w, v, e(g, g) α ) msk = (α)</p><p>• KeyGen(msk, S = {A1, A2, . . . , A k } ⊆ Zp) → sk: Initially, the key generation algorithm picks k+1 random exponents r, r1, r2, . . . , r k $ ← Zp. Then it computes K0 = g α w r , K1 = g r , and for every τ ∈ [k] Kτ,2 = g rτ and Kτ,3</p><formula xml:id="formula_6">= (u Aτ h) rτ v -r</formula><p>The secret key output is sk = (S, K0, K1, {Kτ,2, Kτ,3} τ ∈[k] ).</p><p>• Encrypt(m ∈ GT , (M, ρ)) → ct:</p><p>The encryption algorithm takes the plaintext message m and the access structure encoded in an LSSS policy, with M ∈ Z ×n p and ρ : [ ] → Zp. First, it picks y = (s, y2, . . . , yn)</p><formula xml:id="formula_7">$ ← Z n×1 p .</formula><p>In the terminology of Sec. 2.2, s is the random secret to be shared among the shares. The vector of the shares is λ = (λ1, λ2, . . . , λ ) = M y.</p><p>It then picks random exponents t1, t2, . . . , t $ ← Zp and calculates C = m • e(g, g) αs , C0 = g s , and for every τ ∈ [ ]</p><formula xml:id="formula_8">Cτ,1 = w λτ v tτ , Cτ,2 = (u ρ(τ ) h) -tτ and Cτ,3 = g tτ The ciphertext output is ct = ((M, ρ), C, C0, {Cτ,1, Cτ,2, Cτ,3} τ ∈[ ] ) • Decrypt (sk, ct) → m:</formula><p>Firstly, the decryption algorithm calculates the set of rows in M that provide a share to attributes in S, i.e. I = {i : ρ(i) ∈ S}. Then it computes the constants {ωi ∈ Zp} i∈I such that i∈I ωi Mi = (1, 0, . . . , 0), where Mi is the i-th row of the matrix M . These constants exist if the set S is an authorized set of the policy (c.f. Sec.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.2).</head><p>Then it calculates B = e(C0, K0)</p><p>i∈I (e(Ci,1, K1)e(Ci,2, Kτ,2)e(Ci,3, Kτ,3)) ω i where τ is the index of the attribute ρ(i) in S (it depends on i). The algorithm outputs m = C/B.</p><p>Correctness: If the attribute set S of the secret key is authorized, we have that i∈I ωiλi = s. Therefore: B = e(g, g) αs e(g, w) rs i∈I e(g, w) <ref type="figure">,</ref><ref type="figure">g</ref>) αs e(g, w) rs e(g, w) r i∈I ω i λ i = e(g, g) αs</p><formula xml:id="formula_9">rω i λ i e(g, v) rt i ω i e(g, u ρ(i) h) -rτ t i ω i • 1 i∈I e(g, u ρ(i) h) rτ t i ω i e(g, v) -rt i ω i = e(g</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Proof of Selective Security</head><p>We will prove the following theorem regarding the selective security of our CP-ABE scheme: Theorem 4.1. If the q-1 assumption holds then all PPT adversaries with a challenge matrix of size × n, where , n ≤ q, have a negligible advantage in selectively breaking our scheme.</p><p>Proof. To prove the theorem we will assume that there exists a PPT attacker A with a challenge matrix that satisfies the restriction, which has a non negligible advantage AdvA in selectively breaking our scheme. Using this attacker we will build a PPT simulator B that attacks the q-1 assumption with a non negligible advantage. Initialization: B receives the given terms from the assumption and a challenge policy (M * , ρ * ) from A. We have that M * is an ×n matrix, where , n ≤ q, and ρ * : [ ] → Zp.</p><p>Setup: The simulator B has to provide A the public parameters of the system. In order to do that it implicitly sets the master secret key of the scheme to be α = a q+1 + α, where a, q are set in the assumption and α $ ← Zp is a known to B random exponent. Notice that this way α is correctly distributed and a is information-theoretically hidden from A. Then B picks the random exponents ṽ, ũ, h $ ← Zp and using the assumption gives to A the following public parameters:</p><formula xml:id="formula_10">g = g u = g ũ • (j,k)∈[ ,n] g a k /b 2 j M * j,k h = g h • (j,k)∈[ ,n] g a k /b 2 j -ρ * (j)M * j,k w = g a v = g ṽ • (j,k)∈[ ,n] g a k /b j M * j,k e(g, g) α = e(g a , g a q ) • e(g, g) α</formula><p>The term w is properly distributed in A's view because the term e(g, g) α hides the exponent a information-theoretically. The terms v, u, h are also properly distributed due to ṽ, ũ, h, respectively. Notice that all terms can be calculated by the simulator using suitable terms from the assumption and the challenge policy given by A.</p><p>As one can see, the "attribute layer", which consists of the terms u, h, is made up of terms whose exponents have b 2 i in the denominator, the "binder term" v has bi, and the "secret sharing layer" w has only one power of a. This scaling of the powers of bi will allow our simulator to properly simulate all terms.</p><p>Query phases 1 and 2: Now the simulator has to produce secret keys for non authorized sets of attributes requested by A. In both phases the treatment is the same. We describe here the way B works in order to create a key for an attribute set S = A1, A2, . . . , A |S| received by A.</p><p>Since S is non authorized for (M * , ρ * ), there exists a vector w = (w1, w2, . . . , wn) ∈ Z n p such that w1 = -1 and</p><formula xml:id="formula_11">M * i , w = 0 for all i ∈ I = {i|i ∈ [ ] ∧ ρ * (i) ∈ S} (c.f. Sec. 2.</formula><p>2). The simulator calculates w using linear algebra. Then it picks r $ ← Zp and implicitly sets r = r + w1a q + w2a q-1 + . . .</p><formula xml:id="formula_12">+ wna q+1-n = r + i∈[n] wia q+1-i</formula><p>This is properly distributed due to r. Then using the suitable terms from the assumption it calculates:</p><formula xml:id="formula_13">K0 = g α w r = g a q+1 g αg ar i∈[n] g w i a q+2-i = g α (g a ) r n i=2 g a q+2-i w i K1 = g r = g r i∈[n]</formula><p>g a q+1-i w i</p><p>Additionally, for all τ ∈ [|S|] it has to compute the terms Kτ,2 = g rτ and Kτ,3 = (u Aτ h) rτ v -r . The common part v -r for these terms is the following:</p><formula xml:id="formula_14">v -r   g ṽ (j,k)∈[ ,n] g a k M * j,k /b j   -i∈[n] w i a q+1-i = v -r i∈[n] g a q+1-i -ṽw i • (i,j,k)∈ [n, ,n] g -w i M * j,k a q+1+k-i /b j = v -r i∈[n] g a q+1-i -ṽw i • (i,j,k)∈ [n, ,n],i =k g a q+1+k-i b j -w i M * j,k Φ • (i,j)∈[n, ] g -w i M * j,i a q+1 /b j = Φ • j∈[ ] g -w, M * j a q+1 /b j = Φ • j∈[ ] ρ * (j) / ∈S g -w, M * j a q+1 /b j</formula><p>The Φ part can be calculated by the simulator using the assumption, while the second part has to be canceled by the (u Aτ h) rτ part. So for every attribute Aτ ∈ S the simulator sets implicitly</p><formula xml:id="formula_15">rτ = rτ + r • i ∈[ ] ρ * (i ) / ∈S b i Aτ -ρ * (i ) = rτ + r • i ∈[ ] ρ * (i ) / ∈S b i Aτ -ρ * (i ) + (i,i )∈[n, ] ρ * (i ) / ∈S wib i a q+1-i Aτ -ρ * (i )</formula><p>where rτ $ ← Zp and therefore rτ is properly distributed. The use of the bi's in the numerators of the fractions is explained by the "layer" intuition presented before. Namely, these bi will cancel with the b 2 i denominators in the "attribute layer" and provide a cancellation for the unknown part of v -r . Also, notice that rτ is well-defined only for attributes in the specific unauthorized set S or unrelated attributes (outside the policy), since the sum is over the i such that ρ * (i ) / ∈ S. Therefore, for all Aτ ∈ S or Aτ / ∈ ρ * ([ ]), the denominators Aτ -ρ * (i ) are non zero. If the simulator tries to include more attributes of the policy in the key (and possibly make a key for an authorized set), he would have to divide by zero (see Figure <ref type="figure">1</ref>). Namely, the set of secret keys is partitioned in two sets: the unauthorized, which the simulator can create using the above method, and the authorized, which the simulator cannot create.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Zp ρ * ([ ])</head><p>S</p><p>Figure <ref type="figure">1</ref>: The simulator can not create the components for attributes in the gray area.</p><p>After some algebraic manipulations, the (u Aτ h) rτ part of Kτ,3 is computed as:</p><formula xml:id="formula_16">(u Aτ h) rτ • (Kτ,2/g rτ ) ũAτ + h • (i ,j,k)∈[ , ,n] ρ * (i ) / ∈S g r(Aτ -ρ * (j))M * j,k b i a k /(Aτ -ρ * (i ))b 2 j • (i,i ,j,k)∈[n, , ,n] ρ * (i ) / ∈S g (Aτ -ρ * (j))w i M * j,k b i a q+1+k-i /(Aτ -ρ * (i ))b 2 j = Ψ • (i,j)∈[n, ] ρ * (j) / ∈S g (Aτ -ρ * (j))w i M * j,i b j a q+1+i-i /(Aτ -ρ * (j))b 2 j = Ψ • j∈[ ] ρ * (j) / ∈S g w, M * j a q+1 /b j</formula><p>where Ψ includes the remaining terms of the product. The Ψ and Kτ,2 terms can be calculated using the suitable terms of our assumption. The second part of (u Aτ h) rτ cancels exactly with the problematic part of v -r . Therefore the simulator can calculate Kτ,2 and Kτ,3 for all Aτ ∈ S and hand over the secret key sk = (S, K0, K1, {Kτ,2, Kτ,3} τ ∈[|S|] ) to the attacker A.</p><p>Challenge: The attacker will output a pair of messages (m0, m1) of the same length. In this phase the simulator flips a random coin b $ ← {0, 1} and constructs</p><formula xml:id="formula_17">C = m b • T • e(g, g s ) α and C0 = g s</formula><p>where T is the challenge term and g s the corresponding term of the assumption.</p><p>The simulator sets implicitly y = (s, sa + ỹ2, sa 2 + ỹ3, . . ., sa n-1 + ỹn) , where ỹ2, ỹ3, . . . , ỹn $ ← Zp. We see that the secret s and the vector y are properly distributed, since s was information theoretically hidden from A and the ỹi's are picked uniformly at random. As a result, since λ = M * y we have that</p><formula xml:id="formula_18">λτ = i∈[n] M * τ,i sa i-1 + n i=2 M * τ,i ỹi = i∈[n] M * τ,i sa i-1 + λτ for each row τ ∈ [ ].</formula><p>Notice that the terms λτ = n i=2 M * τ,i ỹi are known to the simulator. For each row the simulator B sets implicitly tτ = -sbτ . This is properly distributed as well, because the bi's are information theoretically hidden from the attacker. Using the above, B calculates:</p><formula xml:id="formula_19">Cτ,1 = w λτ v tτ = w λτ • i∈[n] g M * τ,i sa i • g sbτ -ṽ • (j,k)∈[ ,n] g -M * j,k a k sbτ /b j = w λτ • g sbτ -ṽ • i∈[n] g M * τ,i sa i • k∈[n] g -M * τ,k a k sbτ /bτ • (j,k)∈[ ,n] j =τ g -M * j,k a k sbτ /b j = = w λτ • g sbτ -ṽ • (j,k)∈[ ,n] j =τ g sa k bτ /b j -M * j,k Cτ,2 = u ρ * (τ ) h -tτ = g sbτ -(ũρ * (τ )+ h) •   (j,k)∈[ ,n] g (ρ * (τ )-ρ * (j))M * j,k a k /b 2 j   -sbτ = g sbτ -(ũρ * (τ )+ h) • (j,k)∈[ ,n] j =τ g sa k bτ /b 2 j -(ρ * (τ )-ρ * (j))M * j,k Cτ,3 = g tτ = g sbτ -1</formula><p>Notice that by using tτ = -sbτ we "raised" the exponents of the "binder" term v so that they cancel with the unknown powers of w λτ . Therefore, the simulator hands over the ciphertext ct = ((M * , ρ * ), C, C0, {Cτ,1, Cτ,2, Cτ,3} τ ∈[ ] ) to the attacker A.</p><p>Guess: After the query phase 2, where the simulator creates the secret keys as described above, the attacker outputs a guess b for the challenge bit. If b = b the simulator outputs 0, i.e. it claims that the challenge term is T = e(g, g) sa q+1</p><p>. Otherwise, it outputs 1. If T = e(g, g) sa q+1</p><p>then A played the proper security game, because C = m b • T • e(g, g s ) α = m b • e(g, g) αs . On the other hand, if T is a random term of GT then all information about the message m b is lost in the challenge ciphertext. Therefore the advantage of A is exactly 0. As a result, if A breaks the security game with a non negligible advantage, B has a non negligible advantage in breaking the q-1 assumption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">IMPLEMENTATION AND EVALUATION</head><p>Implementation Details We implemented our schemes in Charm <ref type="bibr" target="#b1">[1]</ref>; a framework developed to facilitate the rapid prototyping of cryptographic schemes and protocols. It is based on the Python language which allows the programmer to write code similar to the theoretical implementations. However, the routines that implement the dominant group operations use the PBC library <ref type="bibr" target="#b28">[27]</ref> (written natively in C) and the time overhead imposed by the use of Python is usually less than 1%. Charm also provides routines for applying and using LSSS schemes needed for Attribute-Based systems.</p><p>All Charm routines use formally asymmetric groups (although the underlining groups might be symmetric) and therefore we translated our schemes to the asymmetric setting. Namely, we have three groups G1, G2 and GT and the pairing e is a function from G1 × G2 to GT . The assumptions and the security proofs can be translated to the asymmetric setting in a generic way. We notice here that we tried to implement our algorithms so that more operations are executed in the G1 group than in the G2 and that encryption consists mainly of operations in G1, compared to key generation. The reason is that the time taken to execute them in the G1 group is considerably smaller than G2 in specific asymmetric groups such as the "MNT224" elliptic curve group. We tested the schemes on all ECC groups provided by Charm, i.e. three super-singular symmetric groups and two MNT asymmetric groups <ref type="bibr" target="#b30">[29]</ref>.</p><p>For more information on Charm we refer the reader to <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b1">1]</ref>. The source code of our implementations can be found in <ref type="bibr" target="#b43">[41]</ref>. All our benchmarks were executed on a dual core Intel R Xeon R CPU W3503@2.40GHz with 2.0GB RAM running Ubuntu R10.04 and Python3.2.3.</p><p>We implemented our two ABE schemes (of Sec. 4 and App. C), the prime order KP-ABE construction from <ref type="bibr" target="#b23">[22]</ref>, and the two basic 3 constructions from <ref type="bibr" target="#b35">[33]</ref>. Actually, in <ref type="bibr" target="#b23">[22]</ref> a large universe prime order HIBE is provided, but the transformation to KP-ABE is straightforward by substituting in the key generation algorithm the additive shares of the secrets with the LSSS shares and the identities with the attributes ρ(τ ). This modified construction is the one we used for comparison to our KP-ABE scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Time Benchmarks</head><p>In Table <ref type="table">1</ref> we present time benchmarks in different elliptic curve groups for some sample policies (≈ size 4 attributes).</p><p>Regarding the comparison between our schemes and prior works, we notice the big gap between the timings of our constructions and prior ones. This is due to the fact that dual vector spaces of high dimension (≈ 10 -14) are utilized, which increase the number of group operations by big factors. We remind the reader that the OT schemes are fully secure, while our scchemes and the LW schemes are selectively secure.</p><p>Regarding the practicality, in general, of both our schemes we notice that the KeyGen, Encrypt, and Decrypt times of our algorithms are relatively small. They are all under 100ms, with the exception of the super singular 1024-bit curve. Even for this curve the times for each algorithm are under the 700 msec mark. Although one would expect that as the policies and the attributes sets grow bigger these times will increase, the additional overhead will grow only linearly. Thus we believe that the two constructions constitute the most practical implementations of large universe ABE, secure in the standard model. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. OUR LARGE UNIVERSE KP-ABE</head><p>In this section we present our large universe KP-ABE scheme. We mention here that it can be converted to an HIBE scheme using non repeating identities, "AND" policies and delegation capabilities (c.f. <ref type="bibr" target="#b26">[25]</ref>). The intuition behind the functionality of this construction is simpler than the CP-ABE. In this setting the public parameters consist of the five terms (g, u, h, w, e(g, g) α ). There is one term less due to the fact that now the master secret key α is the secret to be shared during all the key generation calls. As a result the "secret sharing layer" uses the g term only and the w term is used to "bind" this layer to the u, h "attribute layer".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.1 Construction</head><p>Our scheme consists of the following four algorithms.</p><p>• Setup(1 λ ) → (pp, msk): The setup algorithm calls the group generator algorithm G(1 λ ) and gets the descriptions of the groups and the bilinear mapping D = (p, G, GT , e), where p is the prime order of the groups G and GT . The attribute universe is U = Zp.</p><p>Then the algorithm picks the random terms g, u, h, w </p><formula xml:id="formula_20">Kτ,0 = g λτ w tτ Kτ,1 = u ρ(τ ) h -tτ Kτ,2 = g tτ</formula><p>The secret key is sk = ((M, ρ), {Kτ,0, Kτ,1, Kτ,2} τ ∈[ ] ).</p><p>• Encrypt(m, S = {A1, A2, . . . , A k } ⊆ Zp) → ct: Initially, the algorithm picks k + 1 random exponents s, r1, r2, . . ., r k $ ← Zp. It computes C = m • e(g, g) αs , C0 = g s , and for every τ ∈</p><formula xml:id="formula_21">[k] it computes Cτ,1 = g rτ Cτ,2 = (u Aτ h) rτ w -s The ciphertext is ct = (S, C, C0, {Cτ,1, Cτ,2} τ ∈[k]</formula><p>).</p><p>• Decrypt (sk, ct) → m: The algorithm finds the set of rows in M that provide a share to attributes in S, i.e. I = {i : ρ(i) ∈ S}. Then it calculates constants {ωi ∈ Zp} i∈I such that i∈I ωi Mi = (1, 0, . . . , 0), where Mi is the i-th row of the matrix M . These constants exist if the set S is an authorized set of the policy (c.f. Sec. 2.2).</p><p>Then it calculates B = i∈I (e(C0, Ki,0)e(Cτ,1, Ki,1)e(Cτ,2, Ki,2)) ω i where τ is the index of the attribute ρ(i) in S (it depends on i). The algorithm outputs m = C/B.</p><p>Correctness: If the attribute set S of the ciphertext is authorized, we have that i∈I ωiλi = α. Therefore: B = i∈I e(g, g) sω i λ i e(g, w) st i ω i • e(g, u ρ(i) h) -rτ t i ω i e(g, u ρ(i) h) rτ t i ω i e(g, w) -st i ω i = e(g, g) s i∈I ω i λ i = e(g, g) αs</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.2 Proof of Selective Security</head><p>We will prove the following theorem regarding the selective security of our KP-ABE scheme:</p><p>Theorem C.1. If the q-2 assumption holds, then all PPT adversaries with a challenge attribute set of size k, where k ≤ q, have a negligible advantage in selectively breaking our scheme. Proof. To prove the theorem we will assume that there exists a PPT attacker A with a challenge attribute set that satisfies the restriction, which has a non negligible advantage AdvA in selectively breaking our scheme. Using this attacker we will build a PPT simulator B that attacks the q-2 assumption with a non negligible advantage.</p><p>Initialization: Initially, B receives the given terms from the assumption and an attribute set</p><formula xml:id="formula_22">S * = {A * 1 , A * 2 , . . ., A * k } ⊆ U.</formula><p>Setup: Now, the simulator B has to provide A the public parameters of the system. In order to do that it implicitly sets the master secret key of the scheme to be α = xy, where x, y are set in the assumption. Notice that this way α is properly distributed. Then B picks the random exponents ũ, h $ ← Zp and gives to A the following terms:</p><formula xml:id="formula_23">g = g u = g ũ • i∈[k] g y/b 2 i h = g h • i∈[k] g xz/b i • i∈[k] g y/b 2 i -A * i w = g x e(g, g) α = e(g x , g y )</formula><p>Since x is information-theoretically hidden from A, because it is multiplied by y in α, the term w is properly uniformly random in G. The terms u, h are properly distributed due to ũ, h respectively. Notice that all terms can be calculated by the simulator using suitable terms from the assumption and the challenge set S * given by A.</p><p>In the KP-ABE proof we see that the "binder term" of the CP-ABE reduction has been contained in the "attribute layer"; namely the g xz/b i of the h term. Since the master secret key α is shared in all key generation queries in KP-ABE, we don't need any more the extra functionality provided by the powers of a.</p><p>Query phases 1 and 2: The simulator has to produce secret keys for policies requested by A, for which the set S * is not authorized. In both phases the treatment is the same. We describe here the way B works in order to create a key for a policy (M, ρ) with M ∈ Z ×n p and ρ : [ ] → Zp. Since S * is non authorized for (M, ρ), there exists a vector w = (w1, w2, . . . , wn) ∈ Z n p such that w1 = 1 and Mτ , w = 0 for all τ ∈ [ ] such that ρ(τ ) ∈ S * (c.f. Sec. 2.2). The simulator calculates w using linear algebra. The vector y that will be shared is implicitly y = xy w + (0, ỹ2, ỹ3, . . . , ỹn) where ỹ2, ỹ3, . . . , ỹn $ ← Zp. This vector is properly distributed because its first component is xy = α and the remaining components are uniformly random in Zp. Therefore for each row τ ∈ [ ] the share is λτ = Mτ , y = xy Mτ , w + Mτ , (0, ỹ2, ỹ3, . . . , ỹn) = xy Mτ , w + λτ As we mentioned above for each row τ for which ρ(τ ) ∈ S * it is true that Mτ , w = 0. Therefore in this case λτ = λτ = Mτ , (0, ỹ2, ỹ3, . . . , ỹn) ; hence its value is known to the simulator. In that case it picks tτ xzbi Mτ , w ρ(τ ) -A i</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>+ tτ</head><p>Since ρ(τ ) / ∈ S * the above fractions are defined and tτ is properly distributed due to tτ . The intuition behind this choice is that the y exponent "raises" the power of w to the secret α = xy. However, this also results to xyz/bi exponents from h. Thus, the cancellation is provided by the xzbi exponents on the y/b 2 i part. Now the simulator can compute the following terms using the assumption: Kτ,0 = g λτ w tτ • w tτ Kτ,1 = (u ρ(τ ) h) -tτ = = g y Mτ , w (ρ(τ )ũ+ h)</p><formula xml:id="formula_24">i∈[k]</formula><p>g -xzb i (ρ(τ )ũ+ h) Mτ , w /(ρ(τ )-A * i )</p><p>• g xzb i Mτ , w /(ρ(τ )-A * i )</p><p>• g tτ Therefore B can reply to A's query with the entire secret key sk = (M, ρ), {Kτ,0, Kτ,1, Kτ,2} τ ∈[ ] .</p><p>Challenge: The attacker will output a pair of messages (m0, m1) of the same length. In this phase the simulator flips a random coin b $ ← {0, 1} and sets implicitly s = z from the q-2 assumption. Also, it sets rτ = bτ for every level τ ∈ [k]. These parameters are properly distributed since z, b1, . . . , bq are information-theoretically hidden from the attacker's view. Now the simulator can compute the following terms using the assumption:</p><formula xml:id="formula_25">C = m b • T C0 = g s = g z Cτ,1 = g rτ = g bτ Cτ,2 = (u A * τ h) rτ • w -s = g bτ (ũA * τ + h) • i∈[k] g xzbτ /b i i∈[k] g ybτ (A * k -A * i )/b 2 i • g -xz = g bτ ũA * τ + h • i∈[k] i =τ g xzbτ /b i i∈[k] i =τ g ybτ /b 2 i A * τ -A * i</formula><p>As one can see, the choice of rτ = bτ "raises" one of the xz/bi components to xz and achieves the cancellation with w -s . The simulator hands over the ciphertext ct = S * , C, C0, {Cτ,1, Cτ,2} τ ∈[k] to the attacker A. Guess: After the query phase 2, where the simulator creates the secret keys as described above, the attacker outputs a guess b for the challenge bit. If b = b the simulator outputs 0, i.e. it claims that the challenge term is T = e(g, g) xyz . Otherwise, it outputs 1.</p><p>If T = e(g, g) xyz then A played the proper security game, because C = m b • T = m b • e(g, g) αs . On the other hand, if T is a random term of GT then all information about the message m b is lost in the challenge ciphertext. Therefore the advantage of A is exactly 0. As a result, if A breaks the security game with a non negligible advantage, B has a non negligible advantage in breaking the q-2 assumption.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>By negl(n) we denote a negligible function in n and by PPT probabilistic polynomial-time. The set of matrices of size m × n with elements in Zp is denoted by Z m×n p . Special subsets are the set of row vectors of length n: Z 1×n p , and column vectors of length n: Z n×1 p .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Definition B. 2 .</head><label>2</label><figDesc>A KP-ABE scheme is selectively secure if all PPT attackers have at most a negligible advantage in λ in the above security game, where the advantage of an attacker is defined as Adv = Pr [b = b] -1/2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>←</head><label></label><figDesc>Zp. It outputs pp = (D, g, u, h, w, e(g, g) α ) msk = (α) • KeyGen(msk, (M, ρ)) → sk: Initially, the algorithm picks y = (α, y2, . . . , yn) where . . . , yn $ ← Zp. In the terminology of Sec. 2.2, the master secret key α is the secret to be shared among the shares. The vector of the shares is λ = (λ1, λ2, . . . , λ ) = M y It then picks random exponents t1, t2, . . . , t $ ← Zp and for every τ ∈ [ ] it computes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>$←$←</head><label></label><figDesc>Zp and outputs the terms Kτ,0, Kτ,1, Kτ,2 as in the KeyGen algorithm. On the other hand, for each row τ for which ρ(τ ) / ∈ S * it picks tτ Zp and sets implicitly tτ = -y Mτ , w + i∈[k]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>=</head><label></label><figDesc>g xy Mτ , w + λτ • g -xy Mτ , w + i∈[k] x 2 zb i Mτ , w ρ(τ )-A * i • w tτ = g λτ • i∈[n] g x 2 zb iMτ , w /(ρ(τ )-A * i )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>•i∈[k] g y 2 2 ig y 2 /b 2 i 2 i-</head><label>2222</label><figDesc>i∈[k] g xyz Mτ , w /b i (i,j)∈[k,k] g -(xz) 2 b j Mτ , w /b i (ρ(τ )-A * j ) Mτ , w (ρ(τ)-A * i )/b 2 i • (u ρ(τ ) h) -tτ • (i,j)∈[k,k] g -xyz Mτ , w b j (ρ(τ)-A * i )/b (ρ(τ )-A * j ) = (g y ) Mτ , w (ρ(τ )ũ+ h) i∈[k] g xzb i -(ρ(τ )ũ+ h) Mτ , w /(ρ(τ )-A * i ) • (i,j)∈[k,k] g (xz) 2 b j /b i -Mτ , w /(ρ(τ )-A * j ) • i∈[k] Mτ , w (ρ(τ)-A * i ) • (u ρ(τ ) h) -tτ • (i,j)∈[k,k] i =j g xyzb j /b Mτ , w (ρ(τ)-A * i )/(ρ(τ)-A * j )Kτ,2 = g tτ = (g y ) -Mτ , w • i∈[k]    </figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>A monotonic Boolean formula consists of only AND, OR, and threshold gates, for example A1 ∧(A2 ∨A3). This means</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* Supported by NSF CNS-0915361 and CNS-0952692, CNS-1228599 DARPA through the U.S. Office of Naval Research under Contract N00014-11-1-0382, DARPA N11AP20006, Google Faculty Research award, the Alfred P. Sloan Fellowship, Microsoft Faculty Fellowship, and Packard Foundation Fellowship. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the Department of Defense or the U.S. Government.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX A. ASSUMPTION 2</head><p>For our KP-ABE construction we will use a q-type assumption on prime order bilinear groups, denoted by q-2, which is similar to the Decisional Bilinear Diffie-Hellman Assumption augmented with q parameters bi. It is parameterized by a security parameter λ ∈ N and an integer q, polynomial in λ. We assume that there exists a group generator algorithm G(1 λ ) → (p, G, GT , e) that outputs the description of the (symmetric) bilinear group of order p = Θ(2 λ ). This assumption can be proved secure in the generic group model, but the proof is omitted due to space constraints. It is defined via the following game and an attacker:</p><p>Initially the challenger calls the group generation algorithm with input the security parameter, picks a random group element g $ ← G, and q + 3 random exponents x, y, z, b1, b2, . . ., bq $ ← Zp. Then he sends to the attacker the group description (p, G, GT , e) and all of the following terms:</p><p>The challenger also flips a random coin b $ ← {0, 1} and if b = 0 it gives to the attacker the term e(g, g) xyz . Otherwise it gives a random term R $ ← GT . Finally the attacker outputs a guess b ∈ {0, 1}.</p><p>Definition A.1. We say that the q-2 assumption holds if all PPT attackers have at most a negligible advantage in λ in the above security game, where the advantage is defined as</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. KEY-POLICY ATTRIBUTE-BASED EN-CRYPTION B.1 Algorithms</head><p>A Key-Policy Attribute-Based Encryption scheme consists of the following four PPT algorithms:</p><p>• Setup(1 λ ) → (pp, msk):</p><p>The Setup algorithm takes the security parameter λ ∈ N encoded in unary and outputs the public parameters pp and the master secret key msk. We assume that the public parameters contain a description of the attribute universe U.</p><p>• KeyGen(1 λ , pp, msk, A) → sk: The key generation algorithm takes as inputs the public parameters pp, the master secret key msk and an access structure A on U. The algorithm generates a secret key corresponding to A.</p><p>• Encrypt(1 λ , pp, m, S) → ct: The encryption algorithm takes as inputs the public parameters pp, a plaintext message m, and a set of attributes S ⊆ U. It outputs the ciphertext ct.</p><p>• Decrypt(1 λ , pp, sk, ct) → m: The decryption algorithm takes as inputs the public parameters pp, a secret key sk, and a ciphertext ct. It outputs the plaintext m.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Correctness:</head><p>We require that a KP-ABE scheme is correct, i.e the decryption algorithm correctly decrypts a ciphertext on S with a secret key of an access structure A when S is an authorized set of A. Formally: Definition B.1. A KP-ABE scheme is correct when for all messages m, and all attribute sets S and access structures A with S ∈ A (i.e. for S authorized), any pair (pp, msk) output from Setup(1 λ ), any secret key sk output from KeyGen (1 λ , pp, msk, A), and any ciphertext ct output by Encrypt (1 λ , pp, m, S), it is true that: Decrypt(1 λ , pp, sk, ct) = m.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.2 KP-ABE Selective Security</head><p>The selective security game for KP-ABE is described by a game between a challenger and an attacker and is parameterized by the security parameter λ ∈ N. The phases of the game are the following:</p><p>• Initialization: In this phase the attacker declares the challenge attribute set S * , which he will try to attack, and sends it to the challenger.</p><p>• Setup: Here the challenger calls the Setup(1 λ ) algorithm and sends the public parameters pp to the attacker.</p><p>• Query Phase 1: In this phase the attacker can adaptively ask for secret keys for the access structures A1, A2, . . ., AQ 1 . For each Ai the challenger calls KeyGen(msk, Ai) → ski and sends ski to the attacker. The restriction that has to be satisfied for each query is that none of the queried policies is satisfied by the challenge attribute set, i.e. ∀i ∈ [Q1] : S * / ∈ Ai.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• Challenge:</head><p>The attacker declares two equal-length plaintexts m0 and m1 and sends them to the challenger. He flips a random coin b ∈ {0, 1} and calls Encrypt(m b , S * ) → ct. He sends ct to the attacker.</p><p>• Query Phase 2: This the same as query phase 1. The attacker asks for the secret key for the access structures AQ 1 +1, AQ 1 +2, . . ., AQ, for which the same restriction holds: ∀i ∈ [Q] : S * / ∈ Ai. • Guess: The attacker outputs his guess b ∈ {0, 1} for b.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Charm: A framework for rapidly prototyping 3 Where each sub-universe can appear at most once in the policy. cryptosystems</title>
		<author>
			<persName><forename type="first">Joseph</forename><forename type="middle">A</forename><surname>Akinyele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Avi</forename><surname>Rubin</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2011">2011/617, 2011</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Escrow-free encryption supporting cryptographic workflow</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sattam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Al-Riyami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nigel</forename><forename type="middle">P</forename><surname>Malone-Lee</surname></persName>
		</author>
		<author>
			<persName><surname>Smart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Inf. Sec</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="217" to="229" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Policy-based encryption schemes from bilinear pairings</title>
		<author>
			<persName><forename type="first">Walid</forename><surname>Bagga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Refik</forename><surname>Molva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefano</forename><surname>Crosta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACCS</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page">368</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Secure cryptographic workflow in the standard model</title>
		<author>
			<persName><forename type="first">Manuel</forename><surname>Barbosa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pooya</forename><surname>Farshim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INDOCRYPT</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="379" to="393" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Secure Schemes for Secret Sharing and Key Distribution</title>
		<author>
			<persName><forename type="first">Amos</forename><surname>Beimel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
		<respStmt>
			<orgName>Dept. of Computer Science, Technion</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Ciphertext-policy attribute-based encryption</title>
		<author>
			<persName><forename type="first">John</forename><surname>Bethencourt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amit</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="321" to="334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Efficient selective-id secure identity-based encryption without random oracles</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Boyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="223" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Identity-based encryption from the Weil pairing</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><forename type="middle">K</forename><surname>Franklin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="213" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Space-efficient identity based encryption without pairings</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Craig</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Hamburg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="647" to="657" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Functional encryption: Definitions and challenges</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amit</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="253" to="273" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Concealing complex policies with hidden credentials</title>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">W</forename><surname>Bradshaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jason</forename><forename type="middle">E</forename><surname>Holt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kent</forename><forename type="middle">E</forename><surname>Seamons</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Computer and Communications Security</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="146" to="157" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<ptr target="http://www.charm-crypto.com" />
		<title level="m">Charm</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Multi-authority attribute based encryption</title>
		<author>
			<persName><forename type="first">Melissa</forename><surname>Chase</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="515" to="534" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Improving privacy and security in multi-authority attribute-based encryption</title>
		<author>
			<persName><forename type="first">Melissa</forename><surname>Chase</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sherman</forename><forename type="middle">S M</forename><surname>Chow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Computer and Communications Security</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="121" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Provably secure ciphertext policy ABE</title>
		<author>
			<persName><forename type="first">Ling</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Calvin</forename><forename type="middle">C</forename><surname>Newport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Computer and Communications Security</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="456" to="465" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An identity based encryption scheme based on quadratic residues</title>
		<author>
			<persName><forename type="first">Clifford</forename><surname>Cocks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IMA Int. Conf</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="360" to="363" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Converting pairing-based cryptosystems from composite-order groups to prime-order groups</title>
		<author>
			<persName><forename type="first">David</forename><surname>Mandell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Freeman</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="44" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Practical identity-based encryption without random oracles</title>
		<author>
			<persName><forename type="first">Craig</forename><surname>Gentry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="445" to="464" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Bounded ciphertext policy attribute based encryption</title>
		<author>
			<persName><forename type="first">Vipul</forename><surname>Goyal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Abhishek</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Omkant</forename><surname>Pandey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amit</forename><surname>Sahai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="579" to="591" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Attribute-based encryption for fine-grained</title>
		<author>
			<persName><forename type="first">Vipul</forename><surname>Goyal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Omkant</forename><surname>Pandey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amit</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">MNT&quot; are the Miyaji, Nakabayashi, Takano curves (asymmetric pairing groups), while &quot;SS&quot; are super singular curves (symmetric pairing groups). The number after the type of the curve denotes the size of the base field in bits. access control of encrypted data</title>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Computer and Communications Security</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="89" to="98" />
		</imprint>
	</monogr>
	<note>Table 1: Typical running times in milliseconds of each scheme. KeyGen and Encrypt are called with attribute sets and policies of size 4, while Decrypt with common attribute sets of size 2</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Predicate encryption supporting disjunctions, polynomial equations, and inner products</title>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amit</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="146" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Tools for simulating features of composite order bilinear groups in the prime order setting</title>
		<author>
			<persName><forename type="first">Allison</forename><forename type="middle">B</forename><surname>Lewko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="318" to="335" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Fully secure functional encryption: Attribute-based encryption and (hierarchical) inner product encryption</title>
		<author>
			<persName><forename type="first">Allison</forename><forename type="middle">B</forename><surname>Lewko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tatsuaki</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amit</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Katsuyuki</forename><surname>Takashima</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="62" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Decentralizing attribute-based encryption</title>
		<author>
			<persName><forename type="first">Allison</forename><forename type="middle">B</forename><surname>Lewko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="568" to="588" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Unbounded HIBE and attribute-based encryption</title>
		<author>
			<persName><forename type="first">Allison</forename><forename type="middle">B</forename><surname>Lewko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="547" to="567" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">New proof methods for attribute-based encryption: Achieving full security through selective techniques</title>
		<author>
			<persName><forename type="first">Allison</forename><forename type="middle">B</forename><surname>Lewko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="180" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">The Stanford pairing based crypto library</title>
		<author>
			<persName><forename type="first">Ben</forename><surname>Lynn</surname></persName>
		</author>
		<ptr target="http://crypto.stanford.edu/pbc" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Controlling access to published data using cryptography</title>
		<author>
			<persName><forename type="first">Gerome</forename><surname>Miklau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="898" to="909" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Characterization of elliptic curve traces under fr-reduction</title>
		<author>
			<persName><forename type="first">Atsuko</forename><surname>Miyaji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Masaki</forename><surname>Nakabayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shunzo</forename><surname>Takano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICISC</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="90" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Homomorphic encryption and signatures from vector decomposition</title>
		<author>
			<persName><forename type="first">Tatsuaki</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Katsuyuki</forename><surname>Takashima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Pairing</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="57" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Hierarchical predicate encryption for inner-products</title>
		<author>
			<persName><forename type="first">Tatsuaki</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Katsuyuki</forename><surname>Takashima</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m">ASIACRYPT</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="214" to="231" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Fully secure functional encryption with general relations from the decisional linear assumption</title>
		<author>
			<persName><forename type="first">Tatsuaki</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Katsuyuki</forename><surname>Takashima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="191" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Fully secure unbounded inner-product and attribute-based encryption</title>
		<author>
			<persName><forename type="first">Tatsuaki</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Katsuyuki</forename><surname>Takashima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="349" to="366" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Attribute-based encryption with non-monotonic access structures</title>
		<author>
			<persName><forename type="first">Rafail</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amit</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Computer and Communications Security</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="195" to="203" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Secure attribute-based systems</title>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Pirretti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Traynor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Mcdaniel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Computer and Communications Security</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="99" to="112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Fuzzy identity-based encryption</title>
		<author>
			<persName><forename type="first">Amit</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="457" to="473" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Identity-based cryptosystems and signature schemes</title>
		<author>
			<persName><forename type="first">Adi</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="47" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Predicate privacy in encryption systems</title>
		<author>
			<persName><forename type="first">Emily</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elaine</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="457" to="473" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Delegating capabilities in predicate encryption systems</title>
		<author>
			<persName><forename type="first">Elaine</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="560" to="578" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Access control using pairing based cryptography</title>
		<author>
			<persName><forename type="first">Nigel</forename><forename type="middle">P</forename><surname>Smart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CT-RSA</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="111" to="121" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">Source code of our constructions</title>
		<ptr target="www.cs.utexas.edu/~jrous/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Efficient identity-based encryption without random oracles</title>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="114" to="127" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Ciphertext-policy attribute-based encryption: An expressive, efficient, and provably secure realization</title>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Public Key Cryptography</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="53" to="70" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
