<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An Empirical Study of the Robustness of Two Module Clustering Fitness Functions</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Mark</forename><surname>Harman</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Stephen</forename><surname>Swift</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">King&apos;s College Strand</orgName>
								<address>
									<postCode>WC2R 2LS</postCode>
									<settlement>London</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Mahdavi King&apos;s College Strand</orgName>
								<orgName type="institution">Brunel University Uxbridge</orgName>
								<address>
									<postCode>UB8 3PH, WC2R 2LS</postCode>
									<settlement>Middlesex, London</settlement>
									<country>UK. Kiarash, UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">GECCO&apos;05</orgName>
								<address>
									<addrLine>June 25-29</addrLine>
									<postCode>2005</postCode>
									<settlement>Washington</settlement>
									<region>D.C</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">An Empirical Study of the Robustness of Two Module Clustering Fitness Functions</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">3D323DFAB57AD2DBA947D1B086119A7A</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.2.7 [Distribution</term>
					<term>Maintenance and Enhancement]: Restructuring</term>
					<term>reverse engineering and reengineering Algorithms</term>
					<term>Experimentation Clustering</term>
					<term>Modularization</term>
					<term>Fitness Functions</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Two of the attractions of search-based software engineering (SBSE) derive from the nature of the fitness functions used to guide the search. These have proved to be highly robust (for a variety of different search algorithms) and have yielded insight into the nature of the search space itself, shedding light upon the software engineering problem in hand.</p><p>This paper aims to exploit these two benefits of SBSE in the context of search based module clustering. The paper presents empirical results which compare the robustness of two fitness functions used for software module clustering: one (MQ) used exclusively for module clustering. The other is EVM, a clustering fitness function previously applied to time series and gene expression data.</p><p>The results show that both metrics are relatively robust in the presence of noise, with EVM being the more robust of the two. The results may also yield some interesting insights into the nature of software graphs.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Search based module clustering has been used to automate the process of finding good choices of modularization for software systems which comprise many modules. The level of granularity of the clustering can be chosen to suit the application, so a module might denote (at the fine level of granularity) a single function or procedure or (at coarser levels of granularity) a file (which may contain many procedures and functions).</p><p>Often, the modularization imposed when the system is first created becomes degraded as new modules are added to a system and as the existing modules are maintained. This degradation may be a signal, indicating the necessity for a phase of re-drawing the module boundaries as a part of the maintenance process. For some legacy systems, there is no 'initial modularization' available because the system was never created as a modular system. This makes maintenance much harder and migration to more, inherently modular, languages (such as object oriented styles) very time consuming and therefore costly <ref type="bibr" target="#b20">[19]</ref>.</p><p>In these situations, automation of the process of drawing module boundaries can be highly cost effective. Automated re-modularization through search based clustering analysis has been an area of much interest in search based software engineering, leading to the development of fast and effective tools for automated software module clustering.</p><p>One of the attractions of search-based clustering (and of search-based software engineering itself <ref type="bibr" target="#b2">[2]</ref>) arises from the robustness of the search algorithms. Software engineering problems are typically 'messy' problems in which the available information is often incomplete, sometimes vague and almost always subject to a high degree of change (including unforeseen change) <ref type="bibr" target="#b20">[19]</ref>. In the case of modularization, the input information comes from dependence information collected from the source code of the program to be modularized. However, as programs evolve, their structure degrades, and so a legacy system may contain spurious dependencies which would be removed by restructuring.</p><p>In other engineering fields, this characteristic of messiness, incompleteness and vagueness is typified by the presence of noise, and so the term 'noise' is used in this paper as an umbrella term to indicate the inherent uncertainty in the information available to an automated software module clustering system. The paper presents the results of an empirical study of the robustness of search based software module clustering using two fitness functions to guide the search: the MQ fitness function of Mancoridis et al. <ref type="bibr" target="#b14">[13]</ref> and the EVM fitness function of Tucker et al. <ref type="bibr" target="#b23">[22]</ref>.</p><p>The representation of a software module clustering problem is expressed using a Module Dependency Graph, following Mancoridis et al. <ref type="bibr" target="#b14">[13]</ref>. These may be referred to as MDGs or simply 'graphs' hereinafter. Data were collected for the application of search based clustering applied to six real and six artificial MDGs. The artificial systems allow a comparison of how the techniques behave when applied to perfect, real and random graphs. The experiments were repeated for mutated versions of the systems under study. The mutations of the systems represent the presence of increasing levels of noise in the data, facilitating a study of the robustness of the fitness functions as a guide to search based clustering algorithms.</p><p>The primary findings of this study are:</p><p>1. Searches guided by both fitness functions degrade smoothly as noise increases, but EVM would appear to be the more robust fitness function for real systems.</p><p>2. Searches guided by MQ behave poorly for perfect and near-perfect MDGs (though results degrade smoothly as noise is introduced, even for these graphs).</p><p>3. Tentatively, the difference in performance may shed some light of the nature of program graphs themselves. These results must be treated with caution, but there is some evidence to suggest that program graphs are closer to perfect graphs (those for which an ideal modularization exists) than to arbitrary random graphs of equivalent edge density.</p><p>The rest of the paper is organised as follows: Section 2 describes the experimental methods, subjects used, the two fitness functions studied and potential threats to validity. Section 3 presents the results of the study and discusses the findings. Section 4 briefly describes related work and Section 5 concludes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">EXPERIMENTAL METHODS</head><p>This section describes the experimental methods used to conduct the empirical study. Section 2.1 describes the subject programs and MDGs used. Sections 2.2 and 2.3 describe the search algorithms and fitness functions used. Sections 2.4 and 2.5 describes the method used to model the effect of noise in the MDG and method used to assess clustering similarity. Section 2.6 considers the threats to validity of the results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Subjects</head><p>An MDG is a graph in which nodes represent modules and edges represent the dependence relationships between modules. Three types of MDG were studied: real program MDGs, random MDGs and perfect MDGs. The real program MDGs come from six open source programs, ranging in size from 20 modules to 174 modules, all of which are above the size for which search-space enumeration is possible <ref type="bibr" target="#b16">[15]</ref>. The details of these programs are summarised in Figure <ref type="figure">1</ref>. Their MDGs were obtained using the programs' files, where each file corresponds to a module. Where one file uses another file, these uses are treated as module dependencies in constructing the Module Dependence Graphs.</p><p>The random graphs were obtained by constructing graphs with a random number of edges for three different numbers of nodes. The edge density (average number of outgoing edges per node) was chosen to be identical to the average of that for the real programs studied (about 10% of the maximum possible). Therefore, the random graphs are comparable with the real programs in size and edge density, but the connections are entirely random. Three random graphs were studied, with different sizes: 50, 75 and 100 nodes (modules). The details of these graphs are summarised in Figure <ref type="figure">1</ref>.</p><p>A perfect graph, is so-named because it is one for which a perfect modularization exists. That is, it is possible to cluster the modules of the graph in such a way that all modules in a cluster are related to all other modules and there are no extra-cluster relationships. Such a clustering achieves maximum possible cohesion and minimum possible coupling. The graphs with perfect clusterings were constructed to have a set of perfect clusters of nodes of increasing size. In all, the cluster sizes start with a single node, which, in the perfect clustering, belongs to a single module on its own, and range up to a cluster of size k, which, in the perfect clustering, is a cluster of k nodes, all of which are related to each other and no other nodes. Three perfect graphs were studied: The smallest with 55 nodes (with clusters of sizes: 1 to 10 inclusive nodes), and the largest with 105 nodes (with cluster sizes from 1 to 14 inclusive).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Clustering Algorithm Used</head><p>The clustering algorithm used is based upon the Bunch algorithm <ref type="bibr" target="#b16">[15]</ref>. This was re-implemented to create a tool BruBunch. The algorithm uses a hill climbing approach, like that in Bunch, but does not include the facility in Bunch to remove omnipresent and library modules prior to clustering. An Omnipresent module is one which has many ingoing and out-going relationships to other modules. Such modules would tend to belong in every cluster and so they can adversely affect the results of clustering. Similarly, a library module, is one which is used by a large number of modules (and which uses few itself). Library modules also tend to 'belong' in a large number of clusters. The Bunch tool has facilities to remove these omnipresent and library modules so that their presence does not adversely affect the clustering search.</p><p>These two features were not included in BruBunch, however, because one of the goals of the experiment is to explain the difference in behaviour for the clustering fitness functions, when applied to perfect, real and random graphs. Perfect graphs contain many omnipresent modules (by definition), so these could not be removed while retaining comparability with results for other graphs. In all other respects the BruBunch tool is a faithful re-implementation of the Bunch tool, constructed according to the literature on Bunch <ref type="bibr" target="#b16">[15]</ref>.</p><p>The BruBunch tool was created to allow experimentation with different fitness functions for clustering and different search strategies<ref type="foot" target="#foot_0">1</ref> .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Fitness Functions Used</head><p>Two fitness functions were experimented with: MQ, as implemented in Bunch and introduced by Mancoridis et al. <ref type="bibr" target="#b14">[13]</ref>, and the EVM function of Tucker et al. <ref type="bibr" target="#b23">[22]</ref>. MQ has been used exclusively with Bunch and other work on software modularization <ref type="bibr" target="#b5">[4,</ref><ref type="bibr" target="#b13">12,</ref><ref type="bibr" target="#b14">13,</ref><ref type="bibr" target="#b15">14,</ref><ref type="bibr" target="#b16">15,</ref><ref type="bibr" target="#b17">16,</ref><ref type="bibr" target="#b18">17]</ref>. EVM was introduced by Tucker et al. <ref type="bibr" target="#b23">[22]</ref> and has been applied to problems in time series data <ref type="bibr" target="#b23">[22]</ref>, and clustering of genes according to gene expression data <ref type="bibr" target="#b8">[7]</ref>.</p><p>The MQ function is inspired by software engineering concerns of maximizing cohesion and minimizing coupling <ref type="bibr" target="#b4">[3]</ref>. It rewards clusterings for the presence of intra-module relationships and punishes them for the presence of extra-  <ref type="figure">c</ref>, it defines the score for the cluster in terms of the maximum possible set of intramodule relationships, incrementing the clusters' score for each relationship which is present, and decrementing it for those which are absent. Therefore, it may indirectly punish high coupling, because a re-allocation of modules to clusters might turn high coupling between two modules into lower coupling between them and higher cohesion within one (possibly both) of them.</p><p>In the following formal definitions of MQ and EVM, let a clustering C be defined to be a set of sequences {c1, . . . , cm}, where each cluster ci is denoted by a sequence of elements, such that {c1, . . . , cm} partitions C. Let ki be the size |ci| of the i th cluster of C. Let cij refer to the j th element of the i th cluster of C.</p><p>The formal definition <ref type="bibr" target="#b23">[22]</ref> of EV M (C) for clustering, C is</p><formula xml:id="formula_0">EV M (C) = m i=1 h(ci)</formula><p>where, h(ci), the score for cluster ci is defined as:</p><formula xml:id="formula_1">h(ci) = È k i -1 a=1 È k i b=a+1 L(cia, c ib ) if ki &gt; 1 0 otherwise</formula><p>where L(cxy, cpq) is defined as</p><formula xml:id="formula_2">L(cxy, cpq) = 1</formula><p>if there is a relationship from cxy to cpq or vice versa</p><formula xml:id="formula_3">-1 otherwise</formula><p>The formal definition <ref type="bibr" target="#b16">[15]</ref> of</p><formula xml:id="formula_4">M Q(C) for a clustering, C is M Q(C) = i=|C| i=1 CF(ci)</formula><p>Where the score, CF(ci), awarded to a single cluster, ci is defined as follows:</p><formula xml:id="formula_5">CF(ci) = 2µi 2µi + j=|C| j=1,j =i ǫ ij +ǫ ji 2</formula><p>Where µi is the number of relationships between elements in cluster ci and ǫij is the number of relationships between elements of cluster ci and cluster cj.</p><p>Strictly speaking, neither MQ nor EVM is a metric, since the value is not normalised. That is, in each case, the value of the function is the result of a summation over individual values for each cluster. Therefore, there are no upper bounds to the functions' values. The EVM function has a global optimum corresponding to all modules in a single cluster, where the modules are all related to every other module. Similarly, for the 'perfect' MDGs, the perfect clustering corresponds to the global optimum for EVM. For MQ, the perfect clusterings do not correspond to global optima, as will be seen (see Section 3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Modelling Noise</head><p>In order to model the effect of noise, the MDGs studied are mutated by altering some of the edges of the graph. This mutation, allows the MDG to gradually differ from the original MDG from which it is created, with increases in difference created by larger amounts of mutation. The amount of mutation is measured as a percentage. A mutation of an MDG, m by x% represents the fact that x% of the entries in m's adjacency matrix have been changed (either from 1 to 0 or 0 to 1). Put another way, for x% of the pairs of nodes in the graph denoted by m, an edge has been added or removed where one was absent or present (respectively).</p><p>For each MDG studied, values of mutation from one to ten percent (in increments of one percent) were experimented with. As the mutation percentage increases, the MDG to which clustering algorithms are applied becomes less and less like the original and it is therefore expected that the similarity in the clustering produced (when compared to that of the original) will decrease. The interesting question is the way in which clustering similarity will decrease as the mutation rate increases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Assessing Clustering Similarity and Collecting Results</head><p>The Weighted-Kappa metric <ref type="bibr" target="#b1">[1]</ref> was used to measure the similarity of two clusterings. The value of WK ranges from -1.0 to 1.0, with values in the range 0.2 to 0.6 representing weak agreement and values above 0.6 representing good agreement (with values above 0.8 representing very good agreement).</p><p>The metric is computed in terms of a matrix of observations, with rows representing one observer and columns representing the other. In this case, the observers are clustering techniques. In general, there can be arbitrarily many observations, but in this case there are only two. That is, for a pair of nodes, the question is: 'do these nodes occur in the same cluster or a different cluster?'. For each pair of nodes, a single observation is obtained. With two observers and two possible observations (same cluster, different cluster) there are four possible outcomes to a single paired observation. In two of these four outcomes, both observers agree (either agreeing on 'same cluster' or agreeing on 'different cluster'). In the other two, they differ (one observes that the nodes are in the same cluster while the other observes that they are in different clusters).</p><p>In general, where n observations are possible, an n-by-n matrix is constructed. In this case the matrix is a 2-by-2 matrix. The four elements of the matrix each denote the total number of occasions on which one of the four possible outcomes occur. On the leading diagonal, the two 'agreement' outcome totals are recorded: total number of pairs where both clusterings agree: 'same cluster' and total number of occasions where both clusterings agree: 'different cluster'. The other two elements of the matrix record the two possible 'disagreement' outcomes.</p><p>If the final value of the matrix contains zero in all places other than the leading diagonal, then the observers agree completely. In this case, it means that the clusterings are identical and the value of WK will be 1. If the clusterings are not identical, then some non-leading diagonal elements will be non-zero. At the extreme, where the leading diagonal consists solely of zero elements, then the clusterings are in complete disagreement about every pair of nodes and the value of WK will be -1.</p><p>For the perfect graphs, the perfect clustering is known and so it is possible to compare the result of the clustering found by search with the perfect clustering. For all other graphs, the 'perfect' clustering is not known and so it is only possible to compare the clusterings produced for increasingly noisy versions of an MDG with the clustering obtained for the original MDG.</p><p>In order to factor out the effects of randomness that are inherent in the application of hill climbing search techniques, the basic experiment was repeated ten times and the results reported are averages over these ten runs. Therefore, for each MDG, the WK metric is used to compare the results of the initial clustering obtained for the iteration of the experiment with each of those obtained for the subsequent ten runs of the increasingly mutated versions of the original MDG.</p><p>In total, just over 280 million evaluations of the EVM fitness function were computed and 580 million evaluations of the MQ fitness function were computed. The number of evaluations of each fitness function, for each of the MDGs studied are reported in Figure <ref type="figure">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Threats to Validity</head><p>In any empirical study, it is necessary to consider the possible threats to the validity of the results. There were no human subjects in the empirical study reported here, and so threats to validity primarily fall into those of external and internal validity. The external validity concerns the extent to which it is possible to generalise from the results presented.</p><p>In the case of the study reported here, the primary external threat to validity is the number and variety of programs considered. Are these typical? Can the results be considered to apply more widely? This is a common concern in empirical studies of software systems, because of the diverse nature of programs and the many differing applications to which they may be put. To address this concern, an attempt has been made to select a sample of programs with different application characteristics, including, tools, operating systems, utilities and application software and with sizes which vary by an order of magnitude.</p><p>The threats to internal validity concern the possible selection bias in the choice of subjects and in the application of the experiment itself: Could the subjects could haver been chosen to show certain characteristics? Could the results could be a fluke, resulting from some random chance? The programs used in the study reported here were a subset of those used in other related studies <ref type="bibr" target="#b5">[4,</ref><ref type="bibr" target="#b14">13,</ref><ref type="bibr" target="#b15">14,</ref><ref type="bibr" target="#b16">15,</ref><ref type="bibr" target="#b17">16,</ref><ref type="bibr" target="#b18">17]</ref>. It is unlikely that there was any selection bias, since the experimenters could not have predicated the results from the MDGs due to the size of the search spaces involved. In order to mitigate concerns over the possibility that the results could have been obtained by random chance, the underlying experiment on robustness was repeated 10 times for each MDG and each fitness function and the results presented are the average over those 10 iterations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">RESULTS AND ANALYSIS</head><p>Figure <ref type="figure" target="#fig_1">2</ref> shows the results of the experiment for perfect MDGs described in Figure <ref type="figure">1</ref>. Since these are graphs for which the perfect clustering is known, the Weighted-Kappa (WK) values are compared with those for the perfect clustering arrangement. In these figures, the horizontal axis shows the mutation percentage and the vertical axis shows the value of Weighted-Kappa. Each figure contains the results for both fitness functions for comparison, indicated by triangular points for MQ and square points for EVM. A point plotted at (x, y) indicates that, when the MDG is mutated by x percent, the average similarity (over 10 hill climbs) of the clustering produced when compared to the perfect clustering is y according to the Weighted-Kappa metric. In the three graphs depicted in Figure <ref type="figure" target="#fig_1">2</ref> a additional mutation percentage of 0% is included (this is not included in the results for non perfect MDGs which follow). This data point shows the level to which the set of 10 initial hill climbs agree with each other for the unmutated MDG.</p><p>Figure <ref type="figure" target="#fig_0">3</ref> shows the results for the six real programs. The programs in Figures 3 are presented in order of increasing size (reading from top to bottom, then left to right). In the case of this and all other results (for non-perfect MDGs), the perfect clustering is not known. For these figures, a point plotted at (x, y) indicates that, when the MDG is mutated by x percent, the average similarity (over 10 hill climbs) of the clustering produced when compared to the cluster-ing obtained for the unmutated MDG is y according to the Weighted-Kappa metric.</p><p>To allow comparison with the results for the random and real MDGs, results were also collected to compare the clusterings of mutated versions of the perfect graphs with those obtained in the initial clustering (rather than compared with the perfect clustering). These results are depicted in Figure <ref type="figure">4</ref>. Figure <ref type="figure">5</ref> shows the results of the experiment for the three random graphs described in Figure <ref type="figure">1</ref>.</p><p>In all these figures, the higher the values of WK achieved, the closer the agreement with the clustering obtained from the unmutated MDG (or the perfect clustering in the case of Figure <ref type="figure" target="#fig_1">2</ref>).</p><p>Clearly, the results for both fitness functions are better for perfect graphs than for random graphs (as expected). However, notice that the results for perfect graphs show that EVM produces clusterings which are perfect (for the perfect graph) and that the clusterings produced stay very close to the perfect results as more noise is introduced. This is true, both for the comparison against the perfect clustering (Figure <ref type="figure" target="#fig_1">2</ref>), and the initial clustering (Figure <ref type="figure">4</ref>). By comparison, the MQ fitness function performs much less well with these perfect MDGs.</p><p>In Figure <ref type="figure">4</ref>, both fitness functions are fairly robust (the Weighted-Kappa values remain relatively stable as the mutation rate increases). However, the similarity of the results of the MQ-guided searches with the initial clustering are much worse than those for the EVM-guided searches. Also, the initial set of 10 hill climbs all converge on the perfect clustering for EVM-guided searches, but not for the MQguided searches. Moreover, there is a 'lack of agreement' among the MQ-guided searches, not found in the EVMguided searches.</p><p>This behaviour can be explained by the nature of the MQ fitness function. It yields a value (between 0 and 1) for each cluster in a clustering. If a cluster has only relationships between members of the cluster and none to any elements outside the cluster, then the score for the cluster is 1 (the maximum possible). The value of MQ is the sum (over all clusters) for the score for each cluster. For a perfect MDG of n clusters, the reader might expect that MQ would have a value of n at its global optimum. However, this is not the case. The score obtainable using MQ for a perfect MDG of n clusters can be higher than n, because the clustering could contain more than n clusters, each of which does have a few relationships to modules outside the cluster, but each of which has a value only slightly lower than 1.</p><p>Therefore, the global optimum of the MQ function does not correspond to the perfect clustering for a perfect MDG. Because of this, searches guided by MQ do not produce the perfect clustering for a perfect MDG, but a clustering with a higher MQ value. These results highlight a possible weakness in MQ as a guiding fitness function for modularization searches; it may be possible to improve upon it by addressing this issue.</p><p>For random graphs, MQ and EVM degrade gracefully (there are no sharp drops in the graphs of Figure <ref type="figure">5</ref>), but MQ produces clusterings which are consistently closer to the initial clustering, when compared to the results for EVM. That is, the graph of the degradation in MQ's performance is always above that for EVM. This is precisely the reverse of the trend for perfect graphs, which is also apparent when observing the graphs of real programs in Figure <ref type="figure" target="#fig_0">3</ref>.</p><p>For the real programs, EVM consistently produces clusterings which are closer to those for the initial MDG (with no noise) than the clusterings produced by MQ. These results must be treated with caution (see Section 2.6), but they do suggest some possible insights into the nature of software engineering graphs, when compared to graphs in general.</p><p>The results show that EVM performs consistently better than MQ in the presence of noise for both perfect and real MDGs, but worse for random MDGs. The fact that these results appear to be so consistent for all six of the real programs indicates that there may be a trend here. It is tempting to speculate that the results of the experiments capture something of the nature of what constitutes a 'real' software engineering graph, rather than a purely random graph (or a 'perfect' graph).</p><p>The results provides some empirical evidence for the claim that real systems have dependency graphs which 'behave' more like perfect graphs than they behave like random graphs. This would be perhaps a source of comfort to practitioners of software engineering; particularly those concerned with the maintenance of systems, where good modularization is so essential. It is also an interesting example of search based software engineering shedding potential insights into the nature of software engineering problems and artifacts, as well as providing a means to automate the search for good solutions.</p><p>As the real programs in Figure <ref type="figure" target="#fig_0">3</ref> increase in size (as measured by number of nodes and edges in their MDGs), there appears to be a decrease in the difference between the performance of searches guided by EVM and those guided by MQ. With only six programs studied, any attempt at a statistical analysis of the significance of this apparent trend would be extremely questionable. However, the apparent trend is noteworthy: It may suggest that the choice of fitness function becomes less important as the size of a module increases; perhaps EVM is only more robust than MQ for smaller programs. Alternatively, it might suggest that, as system sizes increase, the graphs of systems' dependence become more random in character and less like perfect graphs. Further study is required to provide a definitive answer.</p><p>Overall, the results suggest that EVM may be worthy of further consideration as a means of assessing clustering quality. The results provide further evidence that search techniques are highly robust and degrade gracefully in the presence of noise in data (an optimistic finding for search based software engineering) and that the study of search based software engineering may be useful as a mechanism for shedding light on the nature of software engineering problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RELATED WORK</head><p>The work reported here is most closely related to work on the Bunch tool, by Mancoridis, Mitchell et al. <ref type="bibr" target="#b5">[4,</ref><ref type="bibr" target="#b14">13,</ref><ref type="bibr" target="#b15">14,</ref><ref type="bibr" target="#b16">15,</ref><ref type="bibr" target="#b17">16,</ref><ref type="bibr" target="#b18">17]</ref>, who introduced the search-based approach to software modularization in 1998 <ref type="bibr" target="#b15">[14]</ref>. Harman et al. <ref type="bibr" target="#b6">[5]</ref>, studied the effect of assigning a particular modularization granularity as part of the search and Mahdavi et al. <ref type="bibr" target="#b12">[11,</ref><ref type="bibr" target="#b13">12]</ref> showed how multiple hill climbs could be used to identify building blocks which improve the behaviour of genetic algorithms when applied to the search-based modularization problems. However, despite many attempts in the litera- A related problem of hierarchical decomposition of software is considered by Lutz <ref type="bibr" target="#b11">[10]</ref>. Lutz is concerned with the problem of decomposition of software into hierarchies at different levels of abstraction, whereas the present work is concerned with only a single level of abstraction (the implementation level). Lutz therefore considers designs rather than code. More importantly, the fitness function used by Lutz, is based on an information-theoretic view point inspired by Shannon <ref type="bibr" target="#b22">[21]</ref>. As such, it is very different from both MQ and EVM, so the results reported here do not have anything to say about such and information-theoretic approach to search-based modularization.</p><p>Other authors have used the fitness functions themselves to assess properties of the software engineering problem under consideration. For example, Kirsopp et al. <ref type="bibr" target="#b9">[8]</ref> use a sampling of the height of landscape peaks to assess aspects of the landscape for a feature subset selection problem applied to software cost estimation, while Pohlheim and Wegener <ref type="bibr" target="#b19">[18]</ref> use exhaustive analysis of projections of the landscape to explore the characteristic of the landscape. The primary difference between these studies and that reported here lies in the fact that the study here involved repeated hill climbs, rather than repeated fitness evaluations. Each hill climb involves many fitness evaluations, so the approach adopted here requires many more fitness evaluations to sample the search space. The results reported in Section 3 required over 860 million fitness function evaluations.</p><p>Other work on software re-modularization has adopted analytical solutions based upon formal concept analysis and clustering fitness functions <ref type="bibr">[6,</ref><ref type="bibr" target="#b10">9,</ref><ref type="bibr" target="#b24">23]</ref> and sets of heuristic rules <ref type="bibr" target="#b21">[20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">CONCLUSIONS AND FUTURE WORK</head><p>This paper has presented results concerning the robustness of two fitness functions EVM and MQ. Both fitness functions degrade smoothly as noise increases, but the EVM fitness function appears to be the more robust fitness function for real systems, suggesting that it may be worthy of further study as a guide for search-based module clustering.</p><p>The results also compare performance of the two clustering fitness functions for perfect and entirely random graphs, suggesting some tantalizing (but highly tentative) observations about the nature of software systems. Specifically, the </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Results for the MDGs taken from Real Software Systems</figDesc><graphic coords="6,82.63,304.39,215.88,107.94" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Results for 'Perfect' MDGs Compared to the Perfect Clustering Result</figDesc><graphic coords="7,65.39,300.80,215.88,107.94" type="bitmap" /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Indeed, extensive experiments were carried out to attempt to find the best search strategy for clustering, including variations on hill climbing, genetic algorithms and simulated annealing. None of these were found to outperform the Bunch algorithm in terms of the values of MQ for the clustering found by each search strategy. The results of these experiments are beyond the scope of this paper, but they do suggest that the Bunch algorithm is highly effective.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The authors would like to express their sincere thanks to Spiros Mancoridis and Brian Mitchell for providing the Bunch tool to experiment with, for the MDGs of the six programs used in the experiment and for many valuable discussions on search-based modularization.</p><p>Mark Harman is supported, in part, by EPSRC Grants GR/R98938, GR/S93684 and GR/T22865 and by three development grants from DaimlerChrysler.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Practical Statistics for Medical Research</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Altman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Chapman and Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">J</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Dolado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Hierons</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Perfect</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="page">105</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Figure 4: Results for &apos;Perfect&apos; MDGs Compared to generation zero</title>
		<author>
			<persName><forename type="first">B</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lumkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mancoridis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rees</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Roper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shepperd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEE Proceedings -Software</title>
		<imprint>
			<biblScope unit="volume">150</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="161" to="175" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
	<note>Reformulating software engineering as a search problem</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">L</forename><surname>Constantine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Yourdon</surname></persName>
		</author>
		<title level="m">Structured Design</title>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Automatic clustering of software systems using a genetic algorithm</title>
		<author>
			<persName><forename type="first">D</forename><surname>Doval</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mancoridis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Software Tools and Engineering Practice (STEP&apos;99)</title>
		<meeting><address><addrLine>Pittsburgh, PA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999-09-02">30 August -2 September 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A new representation and crossover operator for search-based optimization of software modularization</title>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hierons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Proctor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GECCO 2002: Proceedings of the Genetic and Evolutionary Computation Conference</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann Publishers</publisher>
			<date type="published" when="2002-07">July 2002</date>
			<biblScope unit="page" from="9" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">System structure analysis: clustering with data bindings</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hutchens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Basili</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering, SE</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="749" to="757" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A framework for modelling virus gene Random50 Random75 Random100 Figure 5: Results for MDGs of Random Graphs expression data</title>
		<author>
			<persName><forename type="first">P</forename><surname>Kellam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Orengo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tucker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Intelligent Data Analysis</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="267" to="279" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Search heuristics, case-based reasoning and software project effort prediction</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kirsopp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shepperd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GECCO 2002: Proceedings of the Genetic and Evolutionary Computation Conference</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann Publishers</publisher>
			<date type="published" when="2002-07">July 2002</date>
			<biblScope unit="page" from="9" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Assessing modular structure of legacy code based on mathematical concept analysis</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lindig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Snelting</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1997 International Conference on Software Engineering</title>
		<meeting>the 1997 International Conference on Software Engineering</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="349" to="359" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Evolving good hierarchical decompositions of complex systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Lutz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Systems Architecture</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="613" to="634" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Finding building blocks for software clustering</title>
		<author>
			<persName><forename type="first">K</forename><surname>Mahdavi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hierons</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Genetic and Evolutionary Computation -GECCO-2003</title>
		<meeting><address><addrLine>Chicago</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003-07">July 2003</date>
			<biblScope unit="volume">2724</biblScope>
			<biblScope unit="page" from="12" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A multiple hill climbing approach to software module clustering</title>
		<author>
			<persName><forename type="first">K</forename><surname>Mahdavi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Hierons</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Software Maintenance (ICSM 2003)</title>
		<meeting><address><addrLine>Amsterdam, Netherlands; Los Alamitos, California, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2003-09">Sept. 2003</date>
			<biblScope unit="page" from="315" to="324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Bunch: A clustering tool for the recovery and maintenance of software system structures</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mancoridis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">R</forename><surname>Gansner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings; IEEE International Conference on Software Maintenance</title>
		<meeting>IEEE International Conference on Software Maintenance</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="50" to="59" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Using automatic clustering to produce high-level system organizations of source code</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mancoridis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rorres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">R</forename><surname>Gansner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Workshop on Program Comprehension (IWPC&apos;98)</title>
		<meeting><address><addrLine>Ischia, Italy; Los Alamitos, California, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="45" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">A Heuristic Search Approach to Solving the Software Clustering Problem</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Mitchell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002-01">Jan. 2002</date>
			<pubPlace>Philadelphia, PA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Drexel University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD Thesis</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Using heuristic search techniques to extract design abstractions from source code</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mancoridis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GECCO 2002: Proceedings of the Genetic and Evolutionary Computation Conference</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann Publishers</publisher>
			<date type="published" when="2002-07">July 2002</date>
			<biblScope unit="page" from="9" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Using interconnection style rules to infer software architecture relations</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mancoridis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th Genetic and Evolutionary Computing Conference (GECCO&apos;04)</title>
		<meeting><address><addrLine>Seattle, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004-07">July 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Testing the temporal behavior of real-time software modules using extended evolutionary algorithms</title>
		<author>
			<persName><forename type="first">H</forename><surname>Pohlheim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wegener</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Genetic and Evolutionary Computation Conference</title>
		<editor>
			<persName><forename type="first">W</forename><surname>Banzhaf</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Daida</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">E</forename><surname>Eiben</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Garzon</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">V</forename><surname>Honavar</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Jakiela</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Smith</surname></persName>
		</editor>
		<meeting>the Genetic and Evolutionary Computation Conference<address><addrLine>Orlando, Florida, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1999-07">July 1999</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="13" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Software Engineering: A Practitioner&apos;s Approach</title>
		<author>
			<persName><forename type="first">R</forename><surname>Pressman</surname></persName>
		</author>
		<author>
			<persName><surname>Maidenhead</surname></persName>
		</author>
		<author>
			<persName><surname>Berkshire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><forename type="middle">K</forename><surname>England</surname></persName>
		</author>
		<editor>Darrel Ince</editor>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>McGraw-Hill Book Company Europe</publisher>
		</imprint>
	</monogr>
	<note>3rd edition, 1992. European adaptation</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">An intelligent tool for re-engineering software modularity</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Schwanke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Conference on Software Engineering</title>
		<meeting>the 13th International Conference on Software Engineering</meeting>
		<imprint>
			<date type="published" when="1991-05">May 1991</date>
			<biblScope unit="page" from="83" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A mathematical theory of communication</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Shannon</surname></persName>
		</author>
		<idno>27:379-423 and 623-656</idno>
	</analytic>
	<monogr>
		<title level="j">Bell System Technical Journal</title>
		<imprint>
			<date type="published" when="1948-10">July and October 1948</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Grouping multivariate time series via correlation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Tucker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Systems, Man, and Cybernetics. Part B: Cybernetics</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="235" to="245" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Identifying objects using cluster and concept analysis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Van Deursen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kuipers</surname></persName>
		</author>
		<idno>SEN-R9814</idno>
	</analytic>
	<monogr>
		<title level="j">Centrum voor Wiskunde en Informatica (CWI)</title>
		<imprint>
			<date type="published" when="1998-09">Sept. 1998</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
