<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A perspective on inductive databases</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Luc</forename><surname>De Raedt</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Institut f ür Informatik</orgName>
								<orgName type="institution">Albert-Ludwigs-University</orgName>
								<address>
									<addrLine>Georges Koehler Allee 79</addrLine>
									<postCode>D-79110</postCode>
									<settlement>Freiburg</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A perspective on inductive databases</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">E33184A55FD64D13EF2F0DA79CEB310A</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T10:38+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>inductive databases</term>
					<term>inductive querying</term>
					<term>constraint-based mining</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Inductive databases tightly integrate databases with data mining. The key ideas are that data and patterns (or models) are handled in the same way and that an inductive query language allows the user to query and manipulate the patterns (or models) of interest. This paper proposes a simple and abstract model for inductive databases. We describe the basic formalism, a simple but fairly powerful inductive query language, some basics of reasoning for query optimization, and discuss some memory organization and implementation issues.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Ever since the start of the field of data mining, it has been realized that the data mining process should be supported by database technology. In recent years, this idea has been formalized in the concept of inductive databases <ref type="bibr" target="#b28">[28]</ref>. Inductive databases are databases that, in addition to data, also contain patterns, i.e., generalizations extracted from the data. Within the inductive database framework knowledge discovery in databases is modelled as an interactive process in which users can query data as well as patterns. To this aim a so-called inductive query language is used. A number of specialized inductive query languages have been proposed and implemented, e.g., MINE RULE <ref type="bibr" target="#b35">[35]</ref>, MSQL <ref type="bibr" target="#b29">[29]</ref>, DMQL <ref type="bibr" target="#b22">[22]</ref> and XMine <ref type="bibr" target="#b10">[10]</ref>. Most of these inductive query languages extend an existing database query (SQL or XML) language with some primitives to support data mining. The combination of a data mining algorithm (usually some variant of Apriori <ref type="bibr" target="#b1">[1]</ref>) with a language such as SQL offers some interesting querying abilities. Other researchers have argued that data mining primitives should be as close as possible to those of traditional query languages <ref type="bibr">[20; 6]</ref>. The work on inductive query languages has been complemented by several approaches to constraint based mining <ref type="bibr">[3; 23; 24; 38; 31; 16]</ref>. Constraint based mining provides the user with certain primitives (such as frequency and syntactic constraints) to specify the patterns of interest. This line of research has focussed on discovering useful constraints that can be processed efficiently. Despite these many interesting contributions, we are still far away from a deep understanding of inductive databases. It appears to the author that several important components of inductive databases (such as traditional databases and constraint based mining techniques) are already well understood, but that the overall picture is still unclear. Indeed, with a few notable exceptions <ref type="bibr">[5; 28; 18; 16]</ref>, few works have addressed architectural or design issues in inductive databases. A simple theory that gives a clear answer to simple questions such as "What is an inductive database?" and "What is the functionality of an inductive database?" seems to be missing and yet of central importance to the further development of this idea. Although it is probably too early to give a final answer to the above questions, this paper wants to contribute a partial answer to this question that is grounded in database theory and logic. The answer consists of a simple but fairly powerful inductive database concept that clearly exemplifies the nature as well as the functionality of an inductive database.</p><p>In formulating this answer, we start from first principles rather than from complex state-of-the-art techniques and algorithms, so that we do not get lost in technical details and are, we hope, able to address the true design issues in inductive databases. The resulting design does not pretend to be realistic and is -from a practical perspective -overly simple. It is merely meant to give insight into the possible nature and properties of inductive databases and these principles are generally applicable. One specific context in which they are successfully being applied is that of the molecular feature miner MolFea <ref type="bibr">[13; 31]</ref>, in which the user can query for molecular patterns or fragments of interest using primitives such as frequency and generality. The paper is organized as follows: Section 2 introduces the data and pattern components of inductive databases and illustrates them using MolFea; Section 3 introduces the inductive query language for specifying patterns of interest; in Section 4 it is shown how queries can be used to create, update and modify data and pattern sets; Section 5 is concerned with reasoning about queries with the aim of query evaluation and optimization; Section 6 contains some ideas and challenges concerned with memory organization and data structures, and finally, in Section 7, we conclude.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">INDUCTIVE DATABASES</head><p>Inductive databases do not only store data but also patterns: the patterns are first class objects. Thus an inductive database I(D, P) consists of a data component D and a pattern component P. We assume that both the data and the pattern components D and P are sets of sets. This assumption is motivated by an analogy with traditional relational databases. A relational database can be considered a set of relations where each relation is a set of tuples. So, relational databases are -as our data component -sets of sets. The assumption is further justified because in data mining one is often coping with different data sets. Indeed, one distinguishes the training from the test set, the set of positives from the set of negatives, the set of instances in a given cluster, the correctly classified examples from the incorrectly classified ones, etc. This justifies the assumption that D is a collection of data sets. Each data set D ∈ D contains different examples or instances, which will be denoted by e or i. Everything that was said about the data component also applies to the pattern component. Indeed, during the knowledge discovery process, one will often work with different sets of patterns, each of which may reside in the inductive database. These different sets may correspond to different hypotheses constructed on different data sets during crossvalidation, to hypotheses constructed under various parameter settings (e.g., levels of frequency), to user supplied patterns, post-processed patterns, etc. Pattern sets will be denoted by P and their elements, i.e., the patterns, by p, pi, . . .. In order to illustrate the key concepts of our inductive database design, we will employ the pattern domain of strings. This pattern domain, as many of the other ideas presented in this paper, are motivated by the domain specific inductive database MolFea <ref type="bibr" target="#b31">[31]</ref>. We will therefore first briefly review the MolFea setting and then abstract from MolFea in defining the pattern domain of strings. At the same time, we hope that the MolFea experiences and setting will convince the reader of the practical relevance of the presented inductive database concepts. MolFea is a domain specific inductive database for mining features of interest in sets of molecules. The examples in MolFea are thus molecules, and the patterns are molecular fragments. More specifically, in <ref type="bibr" target="#b31">[31]</ref> we employed the 2D (graph) structure of molecules, and linear sequences of atoms and bonds as fragments. An example molecule named Azidothymidine (AZT), a commonly used drug against HIV, is illustrated in Figure <ref type="figure" target="#fig_0">1</ref>. Two interesting molecular fragments discovered using MolFea are:</p><formula xml:id="formula_0">N=N=N-C-C-C-n:c:c:c=O N=N=N-C-C-C-n:c:n:c=O</formula><p>In these fragments, 'C', 'N', 'Cl', etc. denote elements 1 , and '-' denotes a single bond, '=' a double bond, '#' a triple bond, and ':' an aromatic bond. The two fragments occur in AZT because there exist labelled paths in the graph AZT that correspond to these fragments. Let us now introduce the string pattern domain, which is an abstraction of MolFea. This pattern domain should also be useful for other applications in bioinformatics involving, e.g., DNA/RNA or proteins. In the string pattern domain, examples as well as patterns are strings expressed in a language LΣ over an alphabet Σ. Furthermore, a pattern p matches or covers an example e if and only if p is a substring of e, i.e. the symbols of p occur at consecutive positions in e. An • D = {D1, D2, D3} and P = {P1}</p><p>Instead of using the pattern domain of strings, one could also employ other domains such as the data miner's favorite item sets. Then, if I is the set of items considered, examples e as well as patterns p are subsets of I. Data and pattern sets are then sets of item-sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">AN INDUCTIVE QUERY LANGUAGE</head><p>One of the crucial reasons behind the success of relational databases is that relational query languages, such as the relational algebra, are fairly powerful but yet reasonably simple. <ref type="foot" target="#foot_0">2</ref>What should an inductive query language look like? We will assume that the result of an inductive query is either a pattern set or a data set. This assumption guarantees the so-called closure property <ref type="bibr">[28; 6]</ref>. The closure property is again justified by analogy with relational databases, where the result of a query is always a relation; one can argue that the reason for the success of relational algebra was due to the closure property and not to its inherent strength. Given that we distinguish data sets from pattern sets, we need two types of queries: those that generate data sets and those that generate pattern sets. Queries that start from both data sets as well as pattern sets are sometimes called cross-over operations <ref type="bibr" target="#b6">[6]</ref>. Motivated by the use of logic for both databases and constraint based mining as well as by the intimate relationship between logic and set theory, we propose to use logic to design inductive query languages. Using logic should facilitate the definition of the semantics of the query language, should allow to reason about queries and their execution, and should also result in declarative querying possibilities.</p><p>In our example inductive query language, we allow for queries q that either contain no variables or contain exactly one variable τ as in q(τ ). Queries without variables will be interpreted as true or false; queries q(τ ) with a single variable τ will be interpreted as sets {i | q(i) is true}; queries with two or more variables are not allowed. Let us now define a simple though powerful query language (inspired on MolFea) for our inductive database. Again, we wish to stress that the list of primitives sketched is by no means exhaustive, it is meant for illustrative purposes and it can easily be extended with other primitives, with other pattern domains (such as item sets <ref type="bibr" target="#b1">[1]</ref>, episodes <ref type="bibr" target="#b34">[34]</ref>, Datalog queries <ref type="bibr" target="#b12">[12]</ref>, etc.), and even with primitives for other data mining tasks (such as clustering <ref type="bibr" target="#b42">[42]</ref>).</p><p>• Let g and s be strings. Then g is more general than s, notation g s, if and only if g is a substring of s. E.g., on our earlier example, p2 p1 evaluates to true, and p3 p1 to false. This primitive -defined in the context of strings -applies to virtually any pattern domain.</p><p>• The relation can now be used in primitive constraints of the type p p , τ p, ¬(τ p), p τ , and ¬(p τ ), where τ denotes the target pattern and p and p specific patterns. E.g., τ ab yields as solutions the set of substrings of ab, i.e., { , a, b, ab}. • The f req(p, D) construct can be used in the following type of constraints: f req(p, D) ≥ t, f req(p, D) ≤ t, f req(τ, D) ≥ t and f req(τ, D) ≤ t where t is a numerical threshold, τ is the queried pattern or string, p is a specific pattern and D is a data set. Notice that f req is usually involved in cross-over operations. E.g., f req(τ, D2) ≥ 2 yields the set of all substrings of bc.</p><p>• Given that we work with sets it will be useful to employ traditional set operations: i ∈ I, i ∈ I, τ ∈ I as well as τ ∈ I where τ is the queried pattern, i an element and I a set.</p><p>• Finally, the language IL consists of any boolean expression b involving the above introduced primitives. We allow for the usual boolean connectives ∧, ∨, ¬ 3 .</p><p>So, within the sketched language, we can formulate the following queries:</p><p>• All traditional set operations can be performed; e.g. the query (τ ∈ D1) ∨ (τ ∈ D2) denotes the set D1 ∪ D2. For ease of expression and compactness, we will sometimes use the (simpler) set notation in queries.</p><p>• Traditional minimal frequency queries can be performed, e.g., f req(τ, D1) ≥ 2.</p><p>3 If desired, one might also use =⇒ and ⇐⇒.</p><p>• One can also obtain the set of examples in D3 covered by a given pattern p2 using (τ ∈ D3) ∧ (p2 τ ); given the example inductive database listed above, this query returns the set D1.</p><p>• A complex query such as</p><formula xml:id="formula_1">(f req(τ, Dpos) ≥ n) ∧ (f req(τ, Dneg) ≤ m)</formula><p>asks for the set of patterns that are frequent on the positive examples Dpos and infrequent on the negatives in Dneg. On our toy database, the query</p><formula xml:id="formula_2">(τ ∈ P1) ∧ (f req(τ, D1) ≤ 0) ∧ (f req(τ, D2) ≥ 1)</formula><p>would yield the set {cc}.</p><p>The data mining primitives are an extension of those employed in the MolFea system for mining molecular features <ref type="bibr" target="#b31">[31]</ref>. The key differences are that MolFea does not support the set oriented primitives and that it only allows for conjunctive queries. Here, arbitrary boolean queries are supported.</p><p>Notice that even though the inductive query language is simple, the range of queries that can be expressed is quite large. Two features are especially important and distinguish our language from other ones: the use of arbitrary boolean queries (introduced in <ref type="bibr" target="#b16">[16]</ref>) and the ability to formulate minimum as well as maximum frequency constraints over multiple data sets (introduced in <ref type="bibr" target="#b13">[13]</ref>). For building efficient query solvers, it is crucial that the key primitives (frequency and generality) satisfy the monotonicity or antimonotonicity property <ref type="foot" target="#foot_1">4</ref> . A constraint c is anti-monotonic (resp. monotonic) w.r.t. generality whenever</p><formula xml:id="formula_3">∀ patterns s, g : (g s) ∧ (s ∈ sol(c)) → (g ∈ sol(c)) (resp. (g ∈ sol(c)) → (s ∈ sol(c))</formula><p>). Anti-monotonic (resp. monotonic) constraints have the property that whenever a pattern s satisfies the constraint, all its generalizations (resp. specializations) will also satisfy the constraint. The basic anti-monotonic constraints in our framework are: (τ p) and f req(τ, D) ≥ m, the basic monotonic ones are (p τ ) and f req(τ, D) ≤ m. Furthermore the negation of a monotonic constraint is anti-monotonic and vice versa. It would be relatively straightforward to extend our language and solvers with other primitives that are monotonic or antimonotonic. One important challenge for inductive querying concerns the use of primitives that are neither monotonic nor anti-monotonic (cf. <ref type="bibr" target="#b40">[40]</ref>). As an example constraint consider acc(τ, Dpos, Dneg) ≥ 0.8. The answer set of this constraint contains all patterns τ that have a minimum accuracy of 80 per cent on the data sets Dpos and Dneg. Here, we could define the accuracy as acc(τ, Dpos, Dneg) = f req(τ, Dpos) f req(τ, Dpos) + f req(τ, Dneg) (provided that the frequencies are not equal to 0). Efficiently evaluating queries within inductive database languages such as IL is one of the most important challenges in inductive databases. From a logical point of view, inductive database queries can -as their traditional counter parts -be decomposed into their constituents, which correspond -for IL -to the primitives outlined above. The problem is then to combine them in such a way that 1) the available solvers can compute the answers, and 2) the computational resources needed in this process are minimized. To illustrate this problem, consider the query (f req(τ, D) ≥ t d ) ∧ (f req(τ, E) ≥ te). There are various ways of finding the solution set to this query. First, one could compute (f req(τ, D) ≥ t d ) and then remove those elements not satisfying (f req(τ, E) ≥ te) (or the other way around). Secondly, one could compute the answers to each of the conjuncts independently and then compute the intersection. Thirdly one could compute the result using the overall conjunction directly (e.g., using a level wise search using the conjunction as the constraint). Which of these is to be preferred will depend on the data sets, thresholds and algorithms available. The problem of deciding among these is similar to that in traditional query optimization. It seems therefore likely that similar solutions could work as well. One might e.g. want to use a cost estimates for comparing different execution plans for a given query. It remains -so far -an open question as to what cost estimates would be useful and appropriate for inductive queries. At the same time, it should be clear that reasoning about inductive queries (cf. Section 5) and efficient data structures and memory organization (cf. Section 6) will be of key importance to develop efficient query solvers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">OPERATIONS</head><p>So far, we have mainly addressed architectural and querying aspects of inductive databases. We have not yet addressed how to create and modify an inductive database. Again, it is useful to exploit the analogy with existing databases to the maximal possible extent. As in SQL, we therefore use creation, deletion and update operations as well as regular sets and view sets. This results in the operations sketched below, which are also inspired by ongoing work on the MineRULE system by Rosa Meo (personal communication). Again, we assume a perfect symmetry among the data and the pattern components. So even though we only list the operations on the data component, every operation on the data has an equivalent one on patterns. The provided operations are similar to those supported in a relational database. First, the result of an inductive data query can be stored into a new data set. Second, one can also define virtual or view data sets. View data sets behave as views in a relational database. Basically, the defining query is stored (and possibly materialized as well), and the data set can be queried just as if it were a normal set. Changes or updates to the data and pattern sets after the introduction of the view are dynamically reflected in the view data set. Updates on views can be complex. Thirdly, it is possible to delete and modify a data set. Of course, in any possible realistic inductive database more complex update operations will be available.</p><p>Whereas the sketched operations are unsurprising for the data component, they are less straightforward when applied to the pattern component. Let us illustrate and motivate the key concepts on our inductive toy-database. Assume the following statements are given:</p><p>create data set D4 as (τ ∈ D3) ∧ (a τ ); create pattern view P2 as (b τ ) ∧ f req(τ, D4) ≥ 2; update data set D4 delete {abbc};</p><p>This sequence of commands has the following effects on our database:</p><p>• Immediately after executing the first command and before the update command, D4 becomes {e1, e2, e4} = {aabbcc, abbc, abc}.</p><p>• The value of the pattern view P2 before the update command is {b, ab, bb, bc, abb, bbc, abbc}.</p><p>• After the update command, the value of D4 is {aabbcc, abc} and the value of the pattern view P2 becomes {b, ab, bc}.</p><p>This example illustrates a form of incremental data mining where changes to the underlying data sets have an immediate effect on the defined pattern sets. This is realized through the use of pattern views. The use of pattern views is interesting from a practical perspective. Indeed, it is easy to imagine a basket analysis scenario where one always wants to query the patterns that hold in the transaction data of the last week. Dealing efficiently with such incremental data mining and pattern views seems an important challenge for data mining. An example of that illustrates some of the issues in pattern view maintenance, is presented in Section 6.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">REASONING</head><p>A theory of inductive databases can only be useful if it offers the possibility to reason about data mining and its processes. This section explores the possibilities of our logical view for reasoning about query evaluation and optimization. Such reasoning processes must start from logical axioms. The reason why a logical axiomatization of constructs in the language are useful is given by the following two properties:</p><p>P1 For all queries q1 and q2 we have (q1 =⇒ q2) if and only if for all inductive databases I we have: sol(q1, I) ⊆ sol(q2, I), where sol(qi, I) denotes the set of solutions to query qi in the inductive database.</p><p>P2 For all queries q1 and q2 we have (q1 ⇐⇒ q2) if and only if for all inductive databases I we have sol(q1, I) = sol(q2, I). (This is, of course, a corollary of P1.)</p><p>These properties state that logical implication or entailment among queries directly corresponds to the subset relation among its answer sets.</p><p>For the sketched inductive query language, the axioms listed below should be useful. The list is only meant to illustrate the kind of axioms that query optimizers could use. Studying alternative axiomatizations and their properties remains an important topic for further research. In this context, Calders and Paredaens have recently contributed an interesting axiomatization of frequent sets, cf. <ref type="bibr" target="#b9">[9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A1 an axiomatization of finite sets;</head><p>A2 an axiomatization of the partial order , i.e. reflexivity, transitivity, and possibly anti-symmetry;</p><p>A3 an axiomatization of the total order ≤ for numbers;</p><p>A4 For all data sets D1, D2 and patterns p: D1 ⊆ D2 =⇒ f req(p, D1) ≤ f req(p, D2); and A5 For all patterns p1, p2 and data sets D: p1 p2 =⇒ f req(p1, D) ≥ f req(p2, D).</p><p>The axioms A1 could be used for reasoning about the relationships among the various sets in the inductive database and queries. The axioms A3 are intended to support reasoning about the numerical thresholds in the frequency constraints. The axioms A4 and A5 specify the monotonicity properties of f req for both of its arguments. The above axioms can be used in a variety of different ways. Let us illustrate these on some representative examples. Consider queries q3 and q4 such that A1-5|= q3 =⇒ q4. E.g., q3 and q4 could be f req(τ, D) ≥ 3 and f req(τ, D) ≥ 2, or alternatively f req(τ, D) ≥ m and f req(τ, D ∪ E) ≥ m. The following situations can be imagined, cf. <ref type="bibr" target="#b2">[2]</ref>.</p><p>• Query q3 needs to be answered and assume that the solution set q4 has already been stored as pattern set P4 of the inductive database. Then q3 can be solved by evaluating q3 on all elements of P4. If the results of q3 must be stored as a pattern set P3 in the database, the inductive database management system may store P4 as the union of the two sets P3 and P4 -P3 for compactness reasons.</p><p>• Query q4 needs to be answered and assume that the solution set q3 has already been stored as pattern set P3 of the inductive database. The inductive database management system can immediately retrieve the answers P3 and present them to the user while computing the missing answers in P4 -P3. This may reduce the computational resources needed for answering the queries under certain conditions. Furthermore, the set P4 may again be stored as the union of the two subsets P3 and P4 -P3 for compactness reasons.</p><p>Notice that the very same observations and situations apply to queries that return data sets. Furthermore, this type of reasoning is also required to effectively handle the pattern views introduced earlier. Logical reasoning could be used to decide when and how to update materialized views. In this context, one might -by analogy to the traditional view update problem in databases -also consider the pattern view update problem. The pattern view update problem consists of deciding how the underlying data and pattern sets need to be updated to insert or delete a pattern to/from the pattern view. This corresponds to a kind of what if questions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">INTERNAL REPRESENTATIONS</head><p>Efficient data structures and memory management are crucial for database theory. Therefore, we also discuss some of the memory management issues and challenges for inductive databases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Representing Pattern Sets</head><p>First, at the level of the data and pattern component, it will be useful to keep track of the subset relation. Indeed, when sets D1 and D2 are present in the data base and D1 ⊆ D2, this fact should be represented explicitly. Storing these properties in a systematic way amounts to representing the whole structure of the data and pattern component. This will be useful in the context of query optimization. Also, other facts about the relationship among different pattern sets may be useful (e.g., when one pattern set is a condensed representation of another one, cf. below).</p><p>Secondly, it will be useful to explicitly represent the relation among the patterns in the pattern set, especially for pattern sets that are irregular w.r.t. the relation (e.g., when they are not convex or representable by border sets, cf. below). Explicitly representing the relation will allow the inductive database management system to optimize queries of the type (τ ∈ P ) ∧ q(τ ) where P is a pattern set and q a query in the language IL introduced above. Using the internal representation of , the constraint τ ∈ P can be pushed into the solver. E.g., if q(τ ) = (f req(τ, D) ≥ m), a variant of the level wise algorithm could efficiently generate as candidates only those elements that belong to P . The alternative would be to search the space of all patterns, and then filter out those that do not belong to P . For illstructured or small pattern sets this form of post-processing is likely to be less efficient, cf. also <ref type="bibr" target="#b24">[24]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Operations on Pattern Sets</head><p>It is not only important to develop efficient data structures for representing pattern sets, but also to devise operations on these data structures. Such operations would directly implement the primitive constraints and the logical operations in the inductive database language. Thus they could serve as the elementary operations (a kind of algebra) for query evaluation as well as query optimization. Furthermore, the intermediate pattern sets could be cached for further use in interactive querying sessions. To illustrate this point, let us assume that pattern sets are represented using a directed acyclic graph; Figure <ref type="figure">2</ref> shows a graph corresponding to the materialized pattern set P2 = {b, ab, bb, bc, abb, bbc, abbc} for the pattern view (b τ ) ∧ f req(τ, D4) ≥ 2, where D4 is initially {aabbcc, abbc, abc} <ref type="foot" target="#foot_2">5</ref> . In a pattern graph, nodes correspond to patterns and edges to the generalization relation. The labels of the nodes denote properties of the patterns. The most important property is the membership flag with values "+" and "-". The label "+" (resp. "-") denotes that the corresponding pattern belongs (resp. does not belong) to the pattern set represented by the graph. So, a pattern graph may also contain information about patterns outside the pattern set it represents, e.g. a ∈ P2 because of the la-bel "-". Furthermore, from Figure <ref type="figure">2</ref>, one can directly read that b belongs to P2 and also that (within P2) it has three minimal specializations, i.e. ab, bb and bc. This kind of information should be useful when searching for patterns in P2 that satisfy certain constraints (cf. Section 6.1). The other labels on the nodes representing a pattern denote coverage information. Indeed, the second label in a node encodes the indexes of the examples (here in D4 = {e1, e2, e4}) that are covered by the pattern, the third one, those (in D4) that are not covered, where "*" denotes the empty set. E.g., bb covers e1 and e2 but not e4. Given data structures such as pattern graphs, an inductive database language can be implemented using operations on these data structures. As an example consider the pattern graph operations "∪", "∩" and " -" corresponding to the logical operations " ∧ ", " ∨ " and "¬" <ref type="foot" target="#foot_3">6</ref> . These operations would compute the union, intersection or difference of two pattern graphs. They are useful to decompose queries of the form q1 ∧ q2; q1 ∨ q2 and q1 ∧ ¬q2. Indeed, these queries can be answered by first computing the pattern graphs w.r.t. q1 and q2 and then performing the appropriate operation on the resulting pattern graphs. Other operations that are likely to be useful could manipulate the labels of the nodes in a pattern graph. The labels w.r.t. coverage could be modified in order to reflect an update in the pattern view (e.g., as the result of deleting or adding an element of the set D4 used in the definition of the pattern view). In addition, updates to the underlying data set would also trigger changes in the membership label. Interesting and challenging situations occur when new nodes need to be inserted in the pattern graph as the result of an update. (At this point, the reader may want to investigate the effect of deleting the element abbc from D4 on the pattern graph.) Pattern graphs and their operations are not only useful in the context of query evaluation and optimization, they can also be employed for optimizing interactive querying sessions. Indeed, the intermediate results of one inductive query can often serve to optimize the computation of the answer to the next query. As far as the author is aware, pattern graphs -in the form presented above -have not yet been used within the field of data mining. Nevertheless, there exist some interesting data structures, such as FP-trees <ref type="bibr">[24; 40]</ref> and version space trees <ref type="bibr" target="#b16">[16]</ref> that are typically constructed while evaluating the query and that contain several of the components sketched above. One of the remaining challenges -that we are currently studying for version space trees -is to develop efficient implementations of the pattern set operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Condensed Representations</head><p>It is sometimes possible to represent pattern sets using condensed representations. A condensed representation R(P ) of a pattern set P is a subset R(P ) ⊆ P such that the original pattern set P can be reconstructed from R(P ) <ref type="foot" target="#foot_4">7</ref> . So, R(P ) Figure <ref type="figure">2</ref>: Pattern graph corresponding to P2. encodes all relevant information about P in a more compact, i.e. condensed, manner. In the literature one can distinguish two types of condensed representations. On the one hand, there are local condensed representations, based on properties of the individual patterns; on the other hand, there are global condensed representations based on the properties of the complete pattern set. Examples of local condensed representations include free item sets, closed item sets, δ-free item sets, etc. See e.g. <ref type="bibr">[8; 39; 41]</ref> for more details. An item set I is e.g. free w.r.t. to a data set if and only if there is no rule of the form i1 ⇒ i2 that is valid on the data set where i1, i2 are two disjoint subsets of I. Local condensed representations allow one to eliminate redundant patterns from the search space as well as from the solutions. Various algorithms working with local condensed representations have been published in the literature, e.g. <ref type="bibr">[7; 39; 41; 8]</ref>. Global representations are often oriented towards representing the border sets, that is the minimal and maximal elements in the set w.r.t. the partial order . More formally, let max(P ) = {p ∈ P | ¬∃q ∈ P : p q}, i.e. max(P ) contains the maximally specific elements in P , and define min(P ) dually, i.e. min(P ) = {p ∈ P | ¬∃q ∈ P : q p}, i.e. min(P ) contains the maximally general or minimally specific elements in P . We can then also define the borders of a pattern set P : S(P ) = max(P ) and G(P ) = min(P ) 8 . The interesting point about borders is that they can be used as condensed representations. It has been shown <ref type="bibr" target="#b13">[13]</ref> that queries q that are a conjunction of anti-monotonic and monotonic constraints are version spaces. This means that they are completely characterized by their sets S(q) and G(q), i.e. q = {p | ∃s ∈ S(q), g ∈ G(q) : g p s}. On our earlier example, the reader may want to verify that the pattern set P2 = {b, ab, bb, bc, abb, bbc, abbc} represented in as well. Other condensed representations require only that the original set (with or without additional information) can be approximated <ref type="bibr" target="#b30">[30]</ref>. 8 Sometimes one also uses negative borders <ref type="bibr" target="#b34">[34]</ref>, they contain patterns not belonging to the pattern set P but are in a sense closest (w.r.t. the generality relation). E.g. the S -(P ) border w.r.t. a minimum frequency threshold contains the maximally general elements that are strictly more specific than an element in S(P ). the pattern graph is completely characterized by G(P2) = min(P2) = {b} and S(P2) = max(P2) = {abbc}. Within the field of data mining the use of border sets has been introduced in <ref type="bibr" target="#b34">[34]</ref>, who propose to keep track of the set S(P ) for anti-monotonic constraints, and within machine learning there is the well-known work of <ref type="bibr">[37; 36]</ref> on version spaces. In the past few years, a number of algorithms have been published that focuss on the efficient computation of these border sets in the context of data mining, see e.g. <ref type="bibr">[4; 26; 31; 21; 17; 11]</ref>. One of the most recent and exciting results is that by <ref type="bibr" target="#b17">[17]</ref>, who basically show how some local and global condensed representations can be integrated using version spaces. Whereas our earlier results stated that the solution set of a conjunctive query involving anti-monotonic and monotonic constraints can be represented using a single version space, our more recent results <ref type="bibr">[14; 16]</ref> state that the answer set of any boolean query over anti-monotonic and monotonic constraints can be represented as the union of different version spaces. To see why this is the case, rewrite the query in a disjunctive normal form. Each conjunction with the disjunctive normal form will then involve monotonic and antimonotonic constraints. Hence, the earlier result applies and the conjunction can be represented as a version space, and the original set as the union of such version spaces. This result in turn leads to some interesting questions such as "What is the minimal number of version spaces needed to represent the answers to an inductive query?". This last question is answered in <ref type="bibr" target="#b16">[16]</ref>. In the same paper, version space trees are introduced. These combine ideas from pattern graphs and version spaces for the pattern domain of strings. It seems possible to adapt these ideas to FP-trees <ref type="bibr" target="#b24">[24]</ref>. Finally, we mention also that operations such as union and intersection on condensed representations have been investigated, cf. <ref type="bibr">[26; 32; 14]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSIONS</head><p>Despite the fact that the presentation of our inductive database framework has been quite informal and presented in the context of string data, there is significant evidence that the line of research sketched in this paper is fruitful from the theoretical as well as from the practical point of view. Much of the present evidence comes from the MolFea system for molecular feature mining, which has effectively been used in a number of real-life applications involving large and complex data sets such as the HIV-data set which contains over 40 000 compounds <ref type="bibr" target="#b31">[31]</ref>. Furthermore systems based on the same principles as MolFea have been developed. These include DualMiner by <ref type="bibr" target="#b11">[11]</ref> for item sets, ProFea <ref type="bibr" target="#b15">[15]</ref> for analyzing the secondary structure of proteins, MineSeqLog <ref type="bibr" target="#b33">[33]</ref> for mining logical (i.e. structured) sequences and Version Space Trees <ref type="bibr" target="#b16">[16]</ref>. Nevertheless, there are several important limitations of the proposed design. It only addresses local pattern mining tasks <ref type="foot" target="#foot_5">9</ref> , does not account for primitives that are neither antimonotonic nor monotonic (such as e.g. accuracy), ignores probabilistic issues, etc. Despite these limitations the author hopes that the framework inspires some further devel-</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Chemical Structure of Azidothymidine</figDesc><graphic coords="2,348.23,33.83,180.23,144.18" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>•</head><label></label><figDesc>Let p be a pattern and D a data set, i.e., a set of examples. Then f req(p, D) = card{e ∈ D | p e}, where card(S) denotes the cardinality of the set S. So, f req(p, D) denotes the number of instances in D covered by p, i.e., the frequency of p in D. E.g., f req(p3, D2) = 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>create data set D as qD: inserts the new data set D obtained by evaluating qD into the data component D of the inductive database I(D, P). create view data set D as qD: inserts the new virtual data set D defined by the inductive query qD into the data component D of the inductive database I(D, P). delete data set D: deletes the (view or regular) data set D from the data component D of the inductive database I(D, P). update data set D (add | delete) qD: either adds or deletes the examples in qD to/from the set D.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>It is easy to give examples of queries that one cannot express using relational algebra; just consider aggregates. Thus having simple examples that fall outside the query language does not necessarily mean that the language is fatally flawed.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>Interesting variants and extensions of these notions are studied in a recent paper by<ref type="bibr" target="#b40">[40]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>Usually, one would not employ graph structures for these purposes, but some special purpose tree structure such as FP-trees<ref type="bibr" target="#b24">[24]</ref> for item sets or version space trees for string patterns<ref type="bibr" target="#b16">[16]</ref>. However, in order to simplify the exposition and to focuss on the key ideas, we choose graphs rather than these more complex data structures.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_3"><p>Ideally, an operation implementing the complement of a pattern graph would also be provided to compute the answers to a query ¬q on the basis of the pattern graph. However, the resulting pattern graphs would be extremely large (in the case of strings even infinitely large) and therefore impractical. Furthermore, in many cases, as in traditional databases, queries of the form ¬q will not be</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_4"><p>safe.<ref type="bibr" target="#b7">7</ref> Some condensed representations require that additional information (such as exact frequencies) can be reconstructed</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_5"><p><ref type="bibr" target="#b25">[25]</ref> distinguish local patterns from global models. Global models are models about a data set as a whole, whereas local patterns are statements about a (local) subset of the data. opments in inductive databases.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>This work was partly supported by the ESPRIT FET project cInQ. The author is grateful to Heikki Mannila for several suggestions for improvement concerning this paper, to Manfred Jaeger, Stefan Kramer, Sau Dan Lee, and Heikki Mannila for an exciting collaboration on inductive querying, and to the cInQ partners for inspiring discussions, in particular to Jean-Francois Boulicaut, Rosa Meo, Mika Klemettinen, and Pier Luca Lanzi.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Mining association rules between sets of items in large databases</title>
		<author>
			<persName><forename type="first">R</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Imielinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Swami</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGMOD Conference on Management of Data</title>
		<meeting>ACM SIGMOD Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="207" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Incremental Refinement of Mining Queries</title>
		<author>
			<persName><forename type="first">E</forename><surname>Baralis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Psaila</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st International Conference on Data Warehousing and Knowledge Discovery Proceedings</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Mukesh</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">Min</forename><surname>Mohania</surname></persName>
		</editor>
		<editor>
			<persName><surname>Tjoa</surname></persName>
		</editor>
		<meeting>the 1st International Conference on Data Warehousing and Knowledge Discovery Proceedings</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1676</biblScope>
			<biblScope unit="page" from="173" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Special Issue on Constraint-Based Data Mining</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bayardo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGKDD Explorations</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Efficiently mining long patterns from databases</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bayardo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGMOD Conference on Management of Data</title>
		<meeting>ACM SIGMOD Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Querying Inductive Databases: A Case Study on the MINE RULE Operator</title>
		<author>
			<persName><forename type="first">Jean-Francois</forename><surname>Boulicaut</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mika</forename><surname>Klemettinen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Heikki</forename><surname>Mannila</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd European Conference on Principles and Practice of Knowledge Disocvery in Databases</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 2nd European Conference on Principles and Practice of Knowledge Disocvery in Databases</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1510</biblScope>
			<biblScope unit="page" from="194" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Modeling KDD Processes within the Inductive Database Framework</title>
		<author>
			<persName><forename type="first">J-F</forename><surname>Boulicaut</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Klemettinen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mannila</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st International Conference on Data Warehousing and Knowledge Discovery</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 1st International Conference on Data Warehousing and Knowledge Discovery</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1676</biblScope>
			<biblScope unit="page" from="293" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Jean</forename><surname>Francois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boulicaut</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<pubPlace>France</pubPlace>
		</imprint>
		<respStmt>
			<orgName>INSA-Lyon</orgName>
		</respStmt>
	</monogr>
	<note>habilitation thesis</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Free-sets: a condensed representation of boolean data for frequency query approximation</title>
		<author>
			<persName><forename type="first">J-F</forename><surname>Boulicaut</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bykowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rigotti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Mining and Knowledge Discovery</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Axiomatization of Frequent Sets</title>
		<author>
			<persName><forename type="first">Toon</forename><surname>Calders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Paredaens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Conference on Database Theory</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Van Den Bussche</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</editor>
		<meeting>the 8th International Conference on Database Theory</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">1973</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Klemettinen. Mining Association Rules from XML Data</title>
		<author>
			<persName><forename type="first">D</forename><surname>Braga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Campi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ceri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lanzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International Conference on Data Warehousing and Knowlege Discovery</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 4th International Conference on Data Warehousing and Knowlege Discovery</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2454</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">DualMiner: A dual pruning algorithm for item sets with constraints</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bucila</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gehrke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kifer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>White</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 8th ACM SIGKDD Conference on Knowledge Discovery in Databases</title>
		<meeting>of the 8th ACM SIGKDD Conference on Knowledge Discovery in Databases</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Discovery of Frequent Datalog Patterns</title>
		<author>
			<persName><forename type="first">L</forename><surname>Dehaspe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Toivonen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Mining and Knowledge Discovery</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The level wise version space algorithm and its application to molecular fragment finding</title>
		<author>
			<persName><forename type="first">L</forename><surname>De Raedt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kramer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th International Joint Conference on Artificial Intelligence</title>
		<meeting>the 17th International Joint Conference on Artificial Intelligence</meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Query evaluation and optimisation in inductive databases using version spaces</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">De</forename><surname>Raedt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the DTDM Workshop</title>
		<meeting>the DTDM Workshop</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Inductive databases for bioand chemo-informatics</title>
		<author>
			<persName><forename type="first">L</forename><surname>De Raedt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kramer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Artificial Intelligence and Heuristic Methods for Bioinformatics</title>
		<title level="s">Nato Science Series)</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Frasconi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Shamir</surname></persName>
		</editor>
		<imprint>
			<publisher>IOS Press</publisher>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>In press</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A theory of inductive querying</title>
		<author>
			<persName><forename type="first">L</forename><surname>De Raedt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jaeger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mannila</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd IEEE Conference on Data Mining</title>
		<meeting>the 2nd IEEE Conference on Data Mining<address><addrLine>Mabaeshi, Japan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Condensed Representations for Sets of Mining Queries</title>
		<author>
			<persName><forename type="first">A</forename><surname>Giacometti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Laurent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Diop</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1st Workshop on Knowledge Discovery with Inductive Queries Helsinki, ECML/PKDD</title>
		<meeting>1st Workshop on Knowledge Discovery with Inductive Queries Helsinki, ECML/PKDD</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Querying Inductive Databases via Logic-Based User-Defined Aggregates</title>
		<author>
			<persName><forename type="first">F</forename><surname>Giannotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Manco</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd European Conference on Principles and Practice of Knowledge Discovery in Databases</title>
		<title level="s">Lecture Notes in Artificial Intelligence</title>
		<meeting>the 3rd European Conference on Principles and Practice of Knowledge Discovery in Databases</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1704</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">On supporting interactive association rule mining</title>
		<author>
			<persName><forename type="first">B</forename><surname>Goethals</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van Den Bussche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd International Conference on Data Warehousing and Knowlege Discovery</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 2nd International Conference on Data Warehousing and Knowlege Discovery</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1874</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A priori versus a posteriori filtering of association rules</title>
		<author>
			<persName><forename type="first">Bart</forename><surname>Goethals</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Van Den Bussche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGMOD Workshop on Research Issues in Data Mining and Knowledge Discovery</title>
		<meeting>the ACM SIGMOD Workshop on Research Issues in Data Mining and Knowledge Discovery</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Discovering All Most Specific Sentences by Randomized Algorithms</title>
		<author>
			<persName><forename type="first">D</forename><surname>Gunopulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mannila</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Saluja</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of , 6th International Conference on Database Theory</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Foto</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Phokion</forename><surname>Afrati</surname></persName>
		</editor>
		<editor>
			<persName><surname>Kolaitis</surname></persName>
		</editor>
		<meeting>6th International Conference on Database Theory</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1186</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">DMQL: A Data Mining Query Language for Relational Databases</title>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Koperski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Zaiane</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGMOD Workshop on Research Issues on Data Mining and Knowledge Discovery</title>
		<meeting>the ACM SIGMOD Workshop on Research Issues on Data Mining and Knowledge Discovery</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">V S</forename><surname>Lakshmanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">T</forename><surname>Ng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Constraint-Based, Multidimensional Data Mining</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="46" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Mining frequent patterns without candidate generation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of ACM SIGMOD Conference on Management of Data</title>
		<meeting>eeding of ACM SIGMOD Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Principles of data mining</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mannila</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Smyth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>The MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Generalizing Version Spaces</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hirsh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine Learning</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="5" to="46" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Theoretical underpinnings of versionspaes</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hirsh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Joint Conference on Artificial Intelligence</title>
		<meeting>the 12th International Joint Conference on Artificial Intelligence</meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A database perspective on knowledge discovery</title>
		<author>
			<persName><forename type="first">T</forename><surname>Imielinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mannila</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="58" to="64" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">MSQL: A Query Language for Database Mining</title>
		<author>
			<persName><forename type="first">Tomasz</forename><surname>Imielinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aashu</forename><surname>Virmani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Mining and Knowledge Discovery</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="373" to="408" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<author>
			<persName><forename type="first">Baptiste</forename><surname>Jeudy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean-François</forename><surname>Boulicaut</surname></persName>
		</author>
		<title level="m">Optimization of association rule mining queries, Intelligent Data Analysis</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">6</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Molecular Feature Mining in HIV Data</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kramer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>De Raedt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Helma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</title>
		<meeting>the 7th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Programming by demonstration using versionspace algebra</title>
		<author>
			<persName><forename type="first">T</forename><surname>Lau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wolfman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Domingos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Weld</surname></persName>
		</author>
		<imprint>
			<publisher>Machine Learning</publisher>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Mining logical sequences in Mi-neSeqLog</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">De</forename><surname>Raedt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the SIGKDD workshop on Multi-Relational Data Mining</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Dzeroski</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>De Raedt</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Wrobel</surname></persName>
		</editor>
		<meeting>the SIGKDD workshop on Multi-Relational Data Mining</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Levelwise search and borders of theories in knowledge discovery</title>
		<author>
			<persName><forename type="first">H</forename><surname>Mannila</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Toivonen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Mining and Knowledge Discovery</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">An extension to SQL for mining association rules</title>
		<author>
			<persName><forename type="first">R</forename><surname>Meo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Psaila</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ceri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Mining and Knowledge Discovery</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="195" to="224" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">The description identification algorithm</title>
		<author>
			<persName><forename type="first">C</forename><surname>Mellish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="151" to="168" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Generalization as Search, Artificial Intelligence</title>
		<author>
			<persName><forename type="first">T</forename><surname>Mitchell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1980">1980</date>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="203" to="226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Exploratory mining and pruning optimizations of constrained associations rules</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">T</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">V S</forename><surname>Lakshmanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIG-MOD Conference on Management of Data</title>
		<meeting>ACM SIG-MOD Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Efficient mining of association rules using closed itemset lattices</title>
		<author>
			<persName><forename type="first">N</forename><surname>Pasquier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bastide</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Taouil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lakhal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Systems</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="25" to="46" />
			<date type="published" when="1999-01">Jan. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Constraint frequent pattern mining: a pattern-growth view</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGKDD Explorations</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Closet: An efficient algorithm for mining frequent closed itemsets</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIG-MOD Workshop on Research Issues in Data Mining and Knowledge Discovery</title>
		<editor>
			<persName><forename type="first">W</forename><surname>Chen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Naughton</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</editor>
		<meeting><address><addrLine>Dallas, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Constraint-Based Clustering in Large Databases</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K H</forename><surname>Tung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">V S</forename><surname>Lakshmanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">T</forename><surname>Ng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Conference on Database Theory</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 8th International Conference on Database Theory</meeting>
		<imprint>
			<date type="published" when="1973">1973. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
