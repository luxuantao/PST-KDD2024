<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient Optimization of a Class of Relational Expressions</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Ah0</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Bell Laboratories and Y. SAGIV and J.D. ULLMAN Princeton University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Bell Laboratories and Y. SAGIV and J.D. ULLMAN Princeton University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Y</forename><surname>Sagiv</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Bell Laboratories and Y. SAGIV and J.D. ULLMAN Princeton University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Bell Laboratories and Y. SAGIV and J.D. ULLMAN Princeton University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Efficient Optimization of a Class of Relational Expressions</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">3AA9881C43EB1846716BEE64B190B1D2</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:04+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>relational database</term>
					<term>relational algebra</term>
					<term>query optimization</term>
					<term>equivalence of queries</term>
					<term>NP-completeness</term>
					<term>tableaux CR Categories: 3.74</term>
					<term>4.33</term>
					<term>5.25</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The design of several database query languages has been influenced by Codd's relational algebra. This paper discusses the difficulty of optimizing queries based on the relational algebra operations select, project, and join. A matrix, called a tableau, is proposed as a useful device for representing the value of a query, and optimization of queries is couched in terms of finding a minimal tableau equivalent to a given one. Functional dependencies can be used to imply additional equivalences among tableaux. Although the optimization problem is NP-complete, a polynomial time algorithm exists to optimize tableaux that correspond to an important subclass of queries.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>The relational data model of Codd <ref type="bibr" target="#b8">[9]</ref> has been influential in current database system design, and a number of new systems have been built around this model <ref type="bibr" target="#b12">[13]</ref>. Its chief virtues are data independence and the ability to formulate queries nonprocedurally in terms of relational calculus and, to a lesser extent, relational algebra.</p><p>A penalty is paid for these advantages, however. In the relational framework, it becomes easy to express queries that are hard to implement, or for which efficient implementations seem hard to find. Consequently, a number of authors have investigated the problem of optimizing queries in a relational database <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr">261</ref>. As with code "optimization," these papers present heuristics to transform queries to a form in which the answer to a query can, hopefully, be Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific extracted from the database more efficiently than with the original form, although no guarantee of global optimality can be given. <ref type="bibr">Chandra and Merlin [a]</ref> show how to find a global optimum for a class of queries that includes those we shall consider, but the running time of their algorithm can be exponential in the size of a query.</p><p>In this paper we consider the computational difficulty of determining whether two queries are equivalent. We are motivated by the problem of finding, given a query, an equivalent query that is the cheapest to implement. For our query language we consider a restricted subset of relational algebra ("SPJ-expressions") that includes only the relational algebra operators select, project, and (natural) join. Although this subset is not relationally complete, it is broad enough to express many common queries. These operators occupy a central place in the optimization techniques of <ref type="bibr" target="#b23">[24]</ref>, for example. Nevertheless, we shall see that the general optimization problem for even this restricted subset of relational algebra is computationally difficult.</p><p>In Section 3 of this paper we discuss "tableaux," a two-dimensional representation for SPJ-expressions. Tableaux may also be considered a stylized notation for a subset of Zloof's "Query-by-Example" language <ref type="bibr" target="#b27">[28]</ref> and Chandra and Merlin's "conjunctive queries" <ref type="bibr">[B]</ref>. We then show how the equivalence and optimization problems for queries can be reduced to the analogous problems for tableaux. The tableau approach allows us to deal with functional dependencies mechanically, an advantage not possessed by more direct techniques.</p><p>We next present an algorithm for minimizing the number of rows in a tableau, an operation that corresponds to minimizing the number of joins needed to evaluate an SPJ-expression. Since join is typically a very expensive operator to implement, this optimization is quite desirable in query evaluation. Row minimization also serves to eliminate common subexpressions from a query. We can then synthesize from the minimum row tableau an expression that performs selections and projections as early as possible. This transformation, found useful in <ref type="bibr" target="#b20">[21]</ref>, is incorporated into the overall optimization process.</p><p>In Section 4 we discuss the subclass of "simple tableaux" for which the equivalence and optimization problems are tractable. Although the set of queries having simple tableaux is a proper subset of all SPJ-expressions, we nevertheless feel that most practical queries that contain only these operators can be represented by simple tableaux.</p><p>This paper is based on a talk given at the 1978 ACM SIGMOD Conference. The theory outlined in this paper is developed in more detail in <ref type="bibr" target="#b2">[3]</ref>. Additional results and applications of tableaux are contained in [l, 4, 7, 19, 231.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND</head><p>In this section we shall briefly review some basic terminology from the relational database area. The reader is referred to <ref type="bibr" target="#b24">[25]</ref> for a more detailed discussion of the notation and theory of relational databases. attribute for that column. Each row of a table is called a tuple or record. For the purposes of this paper, we assume the ordering of columns in a table (or, equivalently, the ordering of components in a tuple) is unimportant.</p><p>The terms "table" and "relation" are used synonymously. If R is the set of attributes labeling the columns of a table r, then r is said to be the current relation for R. R is called the relation scheme that defines the format of r.</p><p>Whenever no confusion will arise, we use a relation scheme as the name of a table.</p><p>Example 1. Suppose we have the two relation schemes SCG and CT, representing the formats of two tables, one with columns S, C, and G, the other with columns C and T. (S stands for Student, C for Course, G for Grade, T for Teacher.) Figure <ref type="figure">1</ref> shows two relations that might be possible current relations for these relation schemes.</p><p>Cl</p><p>We shall treat each row of a table as a mapping p from the set of attributes of the table to the corresponding domains. We shall use p(A) to denote the value of attribute A of row p. If X ={Al, AZ, . . . , Ah} is a set of attributes, then we shall use p[X] to denote the tuple (p(A,), p(A2), . . . , p(Ak)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Dependencies</head><p>The values of entries in relations often satisfy certain constraints such as functional <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b8">9]</ref> and multivalued [S, <ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b26">27]</ref> dependencies. In this paper we assume all dependencies are functional. Our techniques also apply to multivalued dependencies, although an efficient equivalence test in that case is unknown.</p><p>A functional dependency is a statement X + Y, read "X determines Y," where X and Y are sets of attributes. A relation r satisfies this functional dependency if and only if for all rows ~1 and v in r, p</p><formula xml:id="formula_0">[X] = v[X] implies p[ Y] = u[ Y].</formula><p>That is, if two rows of r agree in the columns for X, then they must agree in the columns for Y. For instance, in Example 1 the functional dependency {SC} + {G} holds.' If r satisfies a given set of dependencies, then it may also satisfy additional dependencies. For example, if r satisfies A + B and B + C, it also satisfies A + C. For a set of attributes X, we define X*, the closure of X, as follows:</p><p>(1) xcx*.</p><p>(2) If Y G X*, and Y + Z is a given functional dependency, then Z c X*.</p><p>(3) No attribute is in X* unless it so follows from (1) and ( <ref type="formula">2</ref>).</p><p>If Y c X*, then the functional dependency X + Y is in, or can be derived from, the given set of dependencies. Two sets of dependencies are equivalent if, for all subsets of attributes X, the set X* is the same under either set of dependencies. It is well known that any set of dependencies is equivalent to a set in which each right side consists of a single attribute, and we henceforth assume all sets of functional dependencies are of this form.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">SPJ-Expressions</head><p>We use a subset of relational algebra expressions which we call SPJ-expressions for our query language. The operands of SPJ-expressions are relation schemes and the operators are the relational operators select, project, and (natural) join. These operators are defined as follows.</p><p>Select. Let r be a relation on a set of attributes X. Let A be an attribute in X and c a value from the domain of A. Then the selection A = c, writtenuA=,( r), is the set (p 1~1 is in r and p(A) = c}, that is, the subset of r having value c for attribute A.</p><p>Project. Let r be a relation on a set of attributes X. Let Y be a subset of X. We define nu( r), the projection of r onto Y, to be (p[ Y] ( p is in r}, that is, the relation obtained by removing all the components of the tuples of r that do not belong to Y and identifying common tuples.</p><p>For example, if r is the first relation of Figure <ref type="figure">1</ref> With SPJ-expressions we can also express Cartesian product (if in a join the sets of attributes for the two relations are disjoint) and intersection (which is a special case of the natural join where the two relations are over the same set of attributes). It is also possible to treat a more general form of selection, where the criterion may involve logical and arithmetic operators on tuple components, e.g., A &lt; B &amp; B &lt; C. We assume that such a selection has the same effect (as far as expression improvement is concerned) as equating attributes A, B, and C to constants. This approach is conservative, in that it never allows the improvement process to produce an expression inequivalent to the original, but it may cause us to miss some improvements.</p><p>Note that the relational algebra of Codd [9, 111 includes other operators, and we would need to add union, set difference, and selections involving arithmetic comparisons between two components of a tuple to make a "complete" set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Two Notions of Equivalence</head><p>Given an SPJ-expression E, we wish to find an optimal expression that poses the same query as E. To solve this problem we need a precise definition of what it means for two expressions to be equivalent. Although several definitions are possible, strong and weak equivalence, the two notions of expression equivalence presented in this section, appear to be the most basic.</p><p>Let E be a relational algebra expression with operand relation schemes RI, R2, . ..) Rk. An assignment associates a relation r, with each relation scheme R,, 1 &lt;i &lt; K. Given an assignment a! of relations to relation schemes, the value of E, denoted u,(E), is computed by applying the relational operators in E to the operand relations.</p><p>We may also regard expression E as a function, mapping assignments of values for its operands to values for the expression. That is, if E is an expression with operands RI, R2, . . . , Rk, we define V(E) to be the mapping that associates the value u,(E) with the assignment (Y of relations rl, r2, . . . , rk for RI, R2, . . . , Rk.</p><p>We say that two expressions El and E2 are strongly equivalent if V(E,) and V(E2) are the same mapping. Strong equivalence appears to be the notion underlying previous attempts at expression optimization, and is the natural notion with which most users querying a database would feel secure.</p><p>For weak equivalence we restrict assignments of values to relation schemes RI, R2, . . . , Rk by insisting that there be some relation I on the set of attributes U$=I Ri such that the value ri assigned to Ri is%%,(I). We call I an instance of the uniuerse, or often, simply, an instance. If v,( El) = u,( Ez) for all assignments (Y obtained in this way from an instance, then we say El and E2 are weakly equivalent, and write El = Ez. Strong equivalence implies weak equivalence but, as we shall see, the converse is not true.</p><p>The notion of weak equivalence is also well motivated. It is the natural notion to consider when a database is being viewed as though there were a single underlying universal relation [l, 5, 61. It is also essential when we deal with equivalences between expressions whose operands are different relation schemes. For example, it underlies the development of lossless joins, as in [l, 23, 271, and it is the notion of equivalence present in the normal form decompositions of <ref type="bibr">[9, 101.</ref> We shall deal with weak equivalence, which we hereafter call simply equiua-Zence, almost exclusively in this paper, mentioning how our results carry over to strong equivalence as well. The motivation for so doing is not our belief that strong equivalence is an inferior notion; rather our ideas are more simply expressed when (weak) equivalence is considered. In particular, we may take advantage of the presence of universal instances to regard the value of an expression as a map from instances to relations. That is, if I is an instance, UI( E) is the value of expression E when each argument Ri of E is replaced by TR, (I).</p><p>Example 3. Consider the expression E = ITAB(AB W BC). Here, A, B, and C are attributes, and relation schemes are denoted by strings of attributes, i.e., AB stands for the relation scheme (A, B). We can show that E is weakly, but not strongly, equivalent to the expression consisting of the single relation scheme AB.</p><p>To see this, suppose that there is a universal instance I over attributes A, B, and C, in that order. Then the value rAB for relation scheme AB is ( ab ( for some c, abc is in I} and the value of rBC for BC is { bc 1 for some a, abc is in 1). The value of AB w BC is rAB w rBC = { abc 1 for some a' and c', abc' and a'bc are in I}. Finally, the value of E is { ab ] for some a', c' and c, abc' and a'bc are in I} <ref type="bibr" target="#b0">(1)</ref> which is just { ab ] for some c, abc is in I&gt; as we may take a = a' and c = c' in <ref type="bibr" target="#b0">(1)</ref>.</p><p>Thus, E is equivalent to AB.</p><p>On the other hand, consider strong rather than weak equivalence. Then rAB and rBC can be independently chosen relations. The value of E is {ab I for some c, ab is in rAB and bc is in rBc} which is not necessarily equal to I;is. For example, if r,4s = { ab} and ?-EC = (z, then the value of E is 0, not (ab) , Note that these values for f;lB and rBC cannot come from one instance. Whether (ab} and 0 are legitimate simultaneous values for AB and BC is a matter of the application at hand. 0 Constraints, such as functional dependencies, also affect the requirements for equivalence of expressions. For example, functional dependencies may be applied to instances, and in the presence of a set of functional dependencies we say that El = EB if ur(Ed = ur(EJ for all instances I that satisfy the functional dependencies. Similarly, functional dependencies may apply to relations, and we define El to be strongly equivalent to Ez in the presence of functional dependencies, if u,( El) = u,( Ez) for all assignments (Y of relations ri to arguments R, such that the ri's satisfy the dependencies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">TABLEAUX</head><p>In this section we show how to represent the mappings defined by SPJ-expressions by specialized matrices called "tableaux." Tableaux are suggestive of the tabular queries of Query-by-Example <ref type="bibr" target="#b27">[28]</ref> and provide a convenient notation for mappings similar to the conjunctive queries of Chandra and Merlin <ref type="bibr" target="#b7">[8]</ref>. We shall see that for every SPJ-expression there is a tableau with the same value, but unfortunately, the correspondence is not exact. There are tableaux that do not correspond to any expression over the operators we discuss.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Definition of a Tableau</head><p>A tableau is a matrix in which the columns correspond to the attributes of the universe in a fixed order. The first row of the matrix is called the summary of the tableau. Hereafter, the remaining rows are to be exclusively called rows, and the summary is not referred to as a "row."</p><p>The general idea is that the tableau is a shorthand for the set formers, such as (1) above, used to define the value of an expression. The summary represents what appears to the left of the vertical bar, e.g., ab in <ref type="bibr" target="#b0">(1)</ref>. The rows represent the tuples required to be in I, such as abc' and a'bc in <ref type="bibr" target="#b0">(1)</ref>.</p><p>To simplify later discussion, we shall adopt the following conventions regarding tableaux. The symbols appearing in a tableau are chosen from (1) Distinguished variables, for which we use a's possibly with subscripts. These correspond to the free variables to the left of the bar, as a and b in (1). and constants. We also require that the same variable not appear in two different columns of a tableau, and that a distinguished variable not appear in a column unless it also appears in the summary of that column.</p><p>Let T be a tableau and let S be the set of all symbols appearing in T (i.e., variables and constants). A valuation p for T associates with each symbol of S a constant, such that if c is a constant in S, then p(c) = c. We extend p to the summary and rows of T as follows. Let wg be the summary of T, and ~1, WZ, . . . , w, the rows. Then p(wi) is the tuple obtained by substituting p(u) for every variable u that appears in wi.   Finally, if we assign 1 to bz and bd, and 2 to the other variables, then we see that 22 is in T(I). Thus, T(I) = <ref type="bibr" target="#b10">(11,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b21">22)</ref>. cl Conventionally, we also regard 0 as a tableau. This tableau represents the function that maps every instance to the empty relation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Representation of Expressions by Tableaux</head><p>In this section we show how to construct a tableau to represent any SPJexpression. The construction proceeds by induction on the number of operators in an expression. The rules for building a tableau for an expression E are <ref type="bibr" target="#b0">(1)</ref> If there are no operators in E, then E is a single relation scheme R. The tableau T for E has one row and a summary such that (i) If A is an attribute in R, then in the column for A, tableau T has the same distinguished variable in the summary and row.</p><p>(ii) If A is not in R, then its column has a blank in the summary and a distinct nondistinguished variable in the row.</p><p>(2) Suppose E is of the form cr~=~(E~), and we have constructed TI, the tableau for E,. (4) Suppose E is of the form El W EZ, and T1 and T2 are the tableaux for El and Ez, respectively. (i) If T1 and Tz have some column in which their summaries have distinct constants, then it is easy to show that V( E ) maps all instances to 0, so 0 is the tableau for E. We should point out that not every tableau derives from an expression over the operators we have considered. The following tableau is an example of one that does not. (See <ref type="bibr" target="#b2">[3]</ref> for a proof.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Modification for Strong Equivalence</head><p>We can also use tableaux to test for strong equivalence. In this case, the procedure to construct a tableau from an expression is slightly modified as follows. If RI, RX, A.V. Aho, Y. Sagiv, and J.D. Ullman . . . 7 Rk are the relation schemes that appear in an expression E, then we "tag" each row of the tableau T for E by one of these relation schemes. Let Gi be the tag for the ith row of T. Suppose relations rl , rz, . . . , rk are assigned to RI, Rz, . . . ) Rk. Then the value of T for this assignment is {p(u)o) ] for some valuation p of the symbols of T, p(wi) is in the relation assigned to Gi, where wo is the summary of T and wl, ~2, . . . , wk are the rows of T}.</p><p>The construction of tagged tableaux proceeds exactly as before, except that when a one-row tableau is created for a relation scheme R, the row is tagged by (R) and has blanks (rather than nondistinguished variables) for attributes not in R. The equivalence problem for tagged tableaux can be reduced in polynomial time to the equivalence problem for ordinary tableaux, and conversely <ref type="bibr" target="#b2">[3]</ref>. Thus, we can use essentially the same procedure to test for strong equivalence as for weak equivalence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Testing Equivalence of Tableaux</head><p>We define two tableaux Tl and T2 to be (weakly) equivalent, written Tl = T2, if for all instances I, T,(I) = T2(1). We say that T1 is (weakly) contained in T2, written ( T1 c T2), if for all instances 1, the relation Tl (I) is a subset of the relation TX(I). We shall give a method for testing the equivalence of tableaux, thus providing an algorithm to test the equivalence of expressions.</p><p>The key idea in the equivalence test is what we call a containment mapping, which we shall define as a mapping from the rows of one tableau to another that preserves distinguished variables and constants and does not map any symbol to two different symbols. Formally, let Tl and TZ be tableaux, and let f3 be a mapping from the rows of Tl to the rows of Tz. We say 0 is a containment mapping if then rows e(i) and B(j) have the same symbol in that column. That symbol could be constant, distinguished, or nondistinguished. Also note that e(i) = 8(j) is possible.</p><p>The techniques of <ref type="bibr" target="#b7">[8]</ref> can be used to show that TI is equivalent to TZ if and only if their summaries are the same (up to renaming of distinguished variables), and there are containment mappings from T1 to T2 and from Tz to Tl. This generaliition allows us to discuss containment, as well as equivalence of tableaux (which explains the term "containment mapping").</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>*</head><p>A.V. Aho, Y. Sagiv, and J.D. Ullman</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Strong Equivalence of Tableaux</head><p>The same ideas that gave us an algorithm for weak equivalence can be adapted to strong equivalence. As in Section 3.3, we use tagged tableaux. We then require of a containment mapping B that any row i have the same tag as row e(i).</p><p>Example 8. Let us consider the strong equivalence of r,dAB W BC) and AB. The tags for rows w1 and w3 are (AB), and the tag for row WP is (BC). The map from T2 to Tl that sends wg to w1 is a containment mapping that preserves tags, but there can be no containment mapping from Tl to Tz, since Tz has no row with the same tag as w2. Thus, as we have noted, AB is not strongly equivalent to rAB(AB W BC). Example 7 showed the two expressions to be (weakly) equivalent. cl</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Minimal Tableaux</head><p>One obvious application of the tableau equivalence test is to use it to find, given a tableau T, an equivalent tableau TO with the fewest rows. Since the number of rows in a tableau constructed from an expression is one more than the number of joins in the expression, this step corresponds to eliminating joins wherever possible. It is therefore satisfying that there is, up to renaming of variables and reordering of rows, a unique minimum row tableau equivalent to T. This result follows from the unique minimum conjunctive queries of <ref type="bibr" target="#b7">[8]</ref>.</p><p>We may also show that if Tl and TZ are equivalent minimal tableaux, then there is a one-to-one correspondence of the rows of Tl and TZ that is a containment mapping in both directions. As a corollary, if T is any tableau, we can create a minimum row tableau equivalent to T by deleting some rows of T. That is, every tableau has within its rows a minimal equivalent tableau.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">The Effect of Functional Dependencies</head><p>When functional dependencies are included in the database design, we can use them to transform tableaux to equivalent forms. This can be done in the following way. Suppose X is a set of attributes, A is an attribute, and X + A. Suppose also that two rows i and j of T have identical symbols in all columns corresponding to attributes of X. Let T' be constructed from T as follows.</p><p>(a) If rows i and j have two distinct constants in the colur~ corresponding to A, then T' is 0. (b) Otherwise, make the symbols found in row i and row j of column A identical.</p><p>If one of them is a constant, then the resulting symbol is the same constant; if both of them are variables and one is distinguished, so is the resulting symbol.</p><p>Reference [l] gives an efficient algorithm for making such modifications to tableaux. It was shown in <ref type="bibr" target="#b2">[3]</ref> that if T' is obtained from T as described above, then T(I) = T'(I) for every instance I that satisfies the functional dependency X-A. One way to test the equivalence of two tableaux is to consider all possible containment mappings in each direction. Since the number of mappings from nl rows to n2 rows is nznl, this procedure can take exponential time in the worst case.</p><p>One might therefore be interested in finding a procedure that takes less time.</p><p>Using recent developments in complexity theory, however, it has been shown that an algorithm whose worst case performance is substantially better is not likely to exist. In particular, the tableau equivalence problem is "NP-complete." This means that the tableau equivalence problem has the same combinatorial complexity as hundreds of other well-studied problems for which no algorithms of less than exponential time complexity have been found. Therefore, proving a new problem is NP-complete is strong evidence that it has no solution which always runs in less than exponential time. References <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b15">16</ref>, 181 present the methodology and theory behind NP-completeness results as well as enumerating many of the known NP-complete problems.</p><p>NP-completeness of equivalence for conjunctive queries was shown in <ref type="bibr" target="#b7">[8]</ref>. In <ref type="bibr" target="#b2">[3]</ref> it is proved that the equivalence and containment problems for tableaux, either in the weak or strong sense, are NP-complete even in the following special cases.</p><p>(1) The tableaux come from expressions that have no select operators, but there is a set of functional dependencies that must be satisfied. (2) The tableaux come from expressions (including select operators), but no dependencies need be satisfied. (3) There are no constants in the tableaux, nor are there dependencies, but the tableaux need not come from expressions.</p><p>Under the same conditions, the problem of determining whether T1 c T2 for two tableaux Tl and TZ is also NP-complete. Moreover, even if Tl is a tableau with the same summary as Tz, and the rows of TI are a subset of those of T2, it is NP-complete to determine whether Tl = Tz. This implies that minimizing the rows of a tableau is also very likely an exponential process in the worst case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">SIMPLE TABLEAUX</head><p>In Section 3 we saw that the equivalence and minimixation problems for tableaux were NP-complete. In this section we show that there exists an important subset of tableaux for which these problems can be solved in time no greater than the fourth power of the size of the tableaux involved.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Definition of Simple Tableaux</head><p>A tableau is simple if in any column with a repeated nondistinguished variable there is no other symbol that appears in more than one row. It is not easy to produce an expression with a nonsimple tableau. Figure <ref type="figure" target="#fig_3">2</ref> exhibits the parse tree for what is in a sense a minimal such expression; the column for B has repeated nondistinguished and distinguished variables. The reader may convince himself that "natural" queries using the operators select, project, and join often have simple tableaux.</p><p>Intuitively, the algorithm for minimizing a tableau T works as follows. If T = TO, where TO is the minimal tableau whose rows are a subset of T, and TO has fewer rows than T, then there are rows i andj of T such that i is not in To, j is in To, and there is a containment mapping 8 from T to TO such that 8(i) = d(j) = j. This is true whether or not T is simple. It is also true in general that TO is as small w / flAC \ /"\ i"\ AB BC AB BD Fig. <ref type="figure" target="#fig_3">2</ref>. Expression with a nonsimple tableau as any tableau equivalent to T. However, if T is simple, there is an easy test to determine whether such a containment mapping 19 exists. Using terms we shall define formally in the following subsections, we first compute the "closure of row i with respect to row j." This is the set of rows that must also map to row j under this containment mapping. Then we test whether the closure is "covered" by row j, and if so we eliminate the closure. Then we may compute CL,, ({ WP}) as follows. First, wg agrees with u/2 in column 3 and disagrees with wl in that column, so wg is added to the closure. We cannot if and only if j covers CLj ({ i} ). Thus to prove that the procedure REDUCE minimizes a simple tableau T, we make the following observations.</p><p>(1) In the procedure REDUCE we do not have to consider i and j more than once. That is, by the commutativity lemma of <ref type="bibr" target="#b2">[3]</ref>, if after elimination of some rows of 2' it becomes true that j covers CLj( { i}), then this covering was true for the original tableau T. (2) If there is a containment mapping 8 from T to a proper subset of its rows, then there is another containment mapping 8' and two rows i and j such that O'(i) = 13'(j) = j. In proof, let i be a row of T such that 8 maps no row of T to i, and consider f?(i), e2( i), . . . . There must be integers p and q, 1 6 p &lt; q, such that P(i) = eq( i). Define 0' = &amp;'p(q-p) and j = e'(i). It is easy to show that the composition of containment mappings is also a containment mapping, so 8' is a containment mapping. Asp 3 1, q -p 2 1, and Bq-p(8P(i))</p><p>= P(i), it follows that e'(j) = j.</p><p>We should observe that if T has r rows and c columns, then CLOSE takes O(r'c) steps and COVERS takes O(rc) steps. Thus REDUCE takes O(r4c). As the size of T is I%, this figure is no more than the fourth power of the size and will be considerably less if c is on the same order as r, or greater.</p><p>We also observe that the procedure REDUCE can be applied as a heuristic to minimize tableaux that are not simple. REDUCE should give good,.ifnot optimal, results for nonsimple tableaux that arise in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Equivalence of Tableaux</head><p>An efficient algorithm to determine the equivalence of simple tableaux is given in <ref type="bibr" target="#b2">[3]</ref>. However, as we now have an algorithm to minimize simple tableaux, and deleting rows from a simple tableau keeps the tableau simple, it is sufficient to give a test for the equivalence of minimal simple tableaux. Therefore, to determine whether T1 = T2 it is sufficient to test the equivalence of the minimal tableaux equivalent to T, and Tz, respectively. Assume now that T, and TZ are minimal simple tableaux. Let A be a column in which there is a repeated nondistinguished variable, b, and let S be the set of rows in which b appears. We remarked in Section 3 that there is a one-to-one mapping 0 from the rows of T1 to Tz such that both 8 and 0-l are containment mappings. Suppose 8, viewed as a mapping on symbols, maps b to symbol d of TP. If d is not a nondistinguished variable, then 8-l, which may be viewed as mapping d to b, is not a containment mapping. Moreover, as 6' is one-to-one, d must be a nondistinguished variable appearing exactly as many times as b, and the rows in S must map to the rows with d. As T2 is simple, d is unique if it exists. Therefore, we may "promote" b and d to the same constant, and there will still be containment mappings from T1 to Tz and back if T1 = Tz.</p><p>Having promoted repeated nondistinguished variables to new constants as above, the only remaining nondistinguished variables appear exactly once. The test for the existence of containment mappings between the modified T, and TZ is now easy; we merely check that each row of Tl is covered by a row of T2 and vice versa.</p><p>The efficient algorithms for minimization and equivalence carry over directly to strong equivalence. We need only redefine "covers" to require that i covers j only when i and j have the same tag, in addition to our earlier requirements on constants and distinguished variables in rows i and j. With the obvious modification to the procedure COVERS, the procedure REDUCE becomes an algorithm to find the minimum row tableau strongly equivalent to T. The test for equivalence of minimal tableaux can also be modified to reflect the new definition of "covers."</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Synthesis of Expressions from Tableaux</head><p>The minimization of tableaux, while a useful first step, is not a complete algorithm for finding an optimal expression equivalent to a given expression. What is needed is a way to go from a tableau to an expression that performs selections and projections as early as possible. The latter assumption may be viewed as our "cost criterion" and is consonant with the assumptions of the previous works in the field of expression optimization cited earlier. Reference <ref type="bibr" target="#b3">[4]</ref> presents an efficient algorithm for producing an optimal expression, in the above sense, from a simple tableau. We do not at this time know of an efficient algorithm for this task in the case of general tableaux.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">OPEN PROBLEMS</head><p>We perceive that the following problems are worth solving if the tableau method of optimization is to realize its full potential.</p><p>(1) Extend the method to other relational operators. We conjecture that it is not possible to do so in any reasonable way for a set of operators that is complete for relational calculus. However, we can already do enough to handle an important subset, and the method could be used for optimization where it applies.</p><p>It should be noted that <ref type="bibr" target="#b7">[8]</ref> characterizes conjunctive queries in terms of relational operators that are generalized select, project, join and a restriction operator that has the effect on tableaux of equating distinguished symbols from two different columns. However, because tableaux associate columns with attributes, while conjunctive queries do no analogous thing, this characterization fails to carry over to tableaux, even if we relax the restriction that a variable not appear in two columns of a tableau. Also note that <ref type="bibr" target="#b22">[23]</ref> extends some of the results of the present paper to sets of tableaux, and sets of differences of sets of tableaux, which can be used to represent certain expressions with the union and difference operators.</p><p>(2) Investigate expression synthesis from general tableaux. Along these lines, M. Yannakakis has shown that it is NP-complete even to determine whether a tableau comes from an expression.</p><p>(3) Develop methods to take advantage of functional dependencies in minimization. The problem here is that while we may use dependencies to modify tableaux, and perhaps make them more susceptible to minimization, the minimal tableau with symbols made equal due to dependencies may not come from an expression over the same set of operands, even when dependencies are applied to the tableau coming from such an expression.</p><p>(4) What is the complexity of tableau equivalence when there are multivalued dependencies to take into account? Reference [l] discusses how to use multival-ued dependencies to modify tableaux, but the resulting equivalence algorithm is doubly exponential (i.e., 2'") for general tableaux and singly exponential for simple tableaux. We conjecture that this is the best that can be done.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>permission. The work of Y. Sagiv and J. D. Ullmsn was supported in part by the National Science Foundation under Grant MCS-7615255. Authors' present addresses: A. V. Aho, Bell Laboratories, Murray Hill, NJ 07974; Y. Sagiv, Department of Computer Science, University of Illinois at Urbana-Champaign, Urbana, IL 61801; J. D. Ullman, Department of Computer Science, Stanford University, Stanford, CA 94305. 0 1979 ACM 0362-5915/79/1200-0435 $00.75</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>2. 1 Fig. 1 .</head><label>11</label><figDesc>Fig. 1. Two tables</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>, then ns( r) = {Horse, Ox, Turtle}. (Natural) Join. The join operator, denoted by W, combines two relations into a single relation whose attributes are the union of the attributes of the two argument relations. Let RI and Rz be two relation schemes with current values rl and r-2. Then rl W r2 = {cl 1 p is a tuple with components RI U RP, and there exist tuples ~1 in rl and v2 in r2, such that vIIRI] = p[RI] and v2[R2] = p[ Rz]}. Example 2. If rl and r2 are the two relations of Figure 1, then rl W r-2 is the relation Even with SPJ-expressions we can pose a variety of interesting queries. Here are two examples that refer to the database in Figure 1. (1) The query "List Turtle's courses and grades" can be represented by the expression VCG( u,w-I-~~w( SCG) ) . (2) The query "List the teachers of all courses taken by Turtle" becomes vry4u.w~Turd SCG W CT)).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>( 2 )</head><label>2</label><figDesc>Nondistinguished variables, for which we generally use b's. These are the bound variables appearing in set formers, such as a' and c' in (1). (3) Constants, for which we use c's or nonnegative integers. (4) Blank. The summary of a tableau may contain only distinguished variables, constants, and blanks. The rows of a tableau may contain variables (distinguished and nondistinguished)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>The target relation scheme of a tableau is the set of attributes with nonblank entries in the summary. A tableau defines a mapping from an instance to a target relation in the following way. If T is a tableau and I is an instance, then T(I) is the relation on the attributes whose columns are nonblank in the summary, such that T(I) = {p(wo)lfor some valuation p we have p(Wi) in I for 1 G i G n}.Example 4. Let T be the tableau A B CWe conventionally show the summary first, with a line below it. We can interpret this tableau as defining the following relation on the target relation scheme AB: T(I) = {uluz1(3b1)(3b2)(3b3)(3b4) such that albIb is in I andbzu21isinIandbgblbqisinI) where I is any instance.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>l A.V. Aho, Y. Sagiv, and J.D. Ullman For example, suppose I is the instance (111, 222, 121). If we assign 1 to all variables, the three rows of T each become 111, which is a member of I. Therefore, p(alan) = 11 is in T(I).If we assign 2 to bl and u2, and 1 to the other variables, ah rows become 121, so 12 is in T(I).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>If we assign 2 to al, bl, and b3, and 1 to the other variables, then ~(a~&amp; b3) = 222 is in I, p(b~u~l) = 111 is in 1, and p(&amp;blb4) = 121 is in 1, so p(alun) = 21 is in T(I).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>(i) If the summary for E1 has blank in the column for A, then the expression E has no meaning, and the tableau T for E is undefined. (ii) If there is a constant c' # c in the summary column for A, then for any I, ul(E1) has only tuples with c' in the component for A, and VI(E) is 0. Again, the tableau for E is 0. If c' = c, then T1 is also the tableau for E. (iii) If T, has a distinguished variable a in the summary column for A, the tableau T for E is constructed by replacing a by c whenever it appears in T1. (3) Suppose E is of the form rx(x(E1 ) and T1 is the tableau for El. Construct T for E by replacing nonblank symbols by blanks in the summary of Tl for those columns whose attributes are not in X. Distinguished variables in those columns become new nondistinguished variables.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>(</head><label></label><figDesc>ii) If no corresponding positions in the summaries have distinct constants, let S1 and SZ be the symbols of T1 and Tz, respectively. We may, by renaming if necessary, take S1 and Sz to have disjoint sets of nondistinguished variables, but identical distinguished variables in corre-sponding columns. Construct T for E to have the union of all the rows of Tl and T2, The summary of T has in a given column (a) The constant c if one or both of TI and TZ have c in that column's summary. In this case replace any distinguished variable in that column by c. (b) The distinguished variable a if (a) does not apply, but one or both of Tl and TZ have a in that column's summary. (c) Blank, otherwise. Example 5. Suppose we have the expression TAC(UB=O(AB W BC)). By Rule (l), the tableaux for AB and BC are Rule (4), the tableau for AB W BC is By Rule (2), the tableau for uBd(AB W BC) is A B C Finally, by Rule (3), the tableau for vr.~(u~+o(AB W BC)) is A B C cl</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Example 6 .</head><label>6</label><figDesc>Consider the expression E = nAB(AB W BC). The tagged tableau for AB is MB) and for BC it is The tagged tableau for AB W BC is</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>(a) For each row i of T1, if row i has a distinguished variable in some column A, then row O(i) of Tz also has a distinguished variable in column A.' (b) If row i of T1 has a constant c in column A, then row 13(i) has c in column A. (c) If rows i and j of T1 have the same nondistinguished variable in column A,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Example 7 .</head><label>7</label><figDesc>The expression rAs(AB W BC) has tableau AB over set of attributes A, B, and C has tableauTz=~~ ciIn one direction, the map that sends both w1 and w2 to wg is a containment mapping. The equivalent mapping of symbols (called a homomorphism in [8direction, we may map w3 to WI, showing the containment of Tl in T2. Thus AB and ~AB(AB W BC) are (weakly) equivalent. 0' In<ref type="bibr" target="#b2">[3]</ref> 6'( i) can have a constant in column A if that constant appears in the summary for that column.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Example 9 .</head><label>9</label><figDesc>Consider the expression ('IIAc(AB W BC)) W AB W AD, whose ACM Transactions on Database Systems, Vol. 4. No. 4, December 197%Efficient Optimization of a Class of Relational Expressions dependencies B + A and A + C hold. Then B + A implies that al = b4, and then A + C implies that all of b2, a3, bs, and bs are the same. Therefore Tl is equivalent to mapping that takes the first three rows of T2 to the first row of TS and the last row of T2 to the last row of T3 in one direction, and the last two rows of T3 to the last two rows of T2 in the other. 0 3.8 Tableau Equivalence and Optimization</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>4. 2</head><label>2</label><figDesc>Row CoveringLet x and y be two rows. We say that x covers y if the following two conditions hold. (a) x and y have the same number of columns. (b) If y has a distinguished variable in a given column, so does x. If y has a constant in a given column, then x has the same constant in this column. Row x covers set of rows S if n covers every row in S. T2 are simple tableaux. The third row of Tl is covered by the first row of T1 or the first row of T2. No row of Tl covers the second row of Tz. Cl 4.3 Row Closures Suppose that T is a simple tableau. The closure of a set of rows S with respect to a given row w, denoted CL,(S), is the minimal set of rows that contains S and satisfies the following condition: If x1 is in CL,(S) and x2 is any row of T such that XI and x2 have the same repeated nondistinguished variable in some column, and w has a different symbol in this column, then x2 is in CL,(S).Example 11. Let T be the simple tableau</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>ACM Transactions on Database Systems, Vol. 4, No. 4, December 1979, Pages 435-454.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>A.V. Aho, Y. Sagiv, and J.D. Ullman</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>ACM Transactions on Database Systems, Vol. 4, No. 4, December 1979.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_3"><p>ACM Transactions on Database Systems. Vol. 4, No. 4, December 1979.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_4"><p>ACM Transactions on Database Systems, Vol. 4, NO. 4, December 1979.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In <ref type="bibr" target="#b2">[3]</ref> it is shown that a containment mapping that sends rows i and j to j exists</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The theory of joins in relational databases</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Beeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="297" to="314" />
			<date type="published" when="1979-09">Sept. 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">The Design and Analysis of Computer Algorithms</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Hopcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1974">1974</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Equivalences among relational expressions</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comptg</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="218" to="246" />
			<date type="published" when="1979-05">May 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Inferring a tree from lowest common ancestors with an application to the optimization of relational expressions</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">G</forename><surname>Szymanski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 16th Ann. Allerton Conf. on Commun</title>
		<meeting>16th Ann. Allerton Conf. on Commun</meeting>
		<imprint>
			<date type="published" when="1978-10">Oct. 1978</date>
			<biblScope unit="page" from="54" to="63" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Dependency structures of data base relationships</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Armstrong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing</title>
		<imprint>
			<biblScope unit="volume">74</biblScope>
			<biblScope unit="page" from="580" to="583" />
			<date type="published" when="1974">1974</date>
			<publisher>North-Holland Pub. Co</publisher>
			<pubPlace>Amsterdam</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A complete axiomatization for functional and multivalued dependencies in database relations</title>
		<author>
			<persName><forename type="first">C</forename><surname>Beeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Howard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD Int. Conf. on Manage. of Data</title>
		<meeting>ACM SIGMOD Int. Conf. on Manage. of Data<address><addrLine>Toronto, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="47" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Synthesizing independent database schemas</title>
		<author>
			<persName><forename type="first">J</forename><surname>Biskup</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Dayal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. ACM SIGMOD Conf</title>
		<imprint>
			<biblScope unit="page" from="143" to="151" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Optimal implementation of conjunctive queries in relational data bases</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Merlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Ninth Ann. ACM Symp. on Theory of Comptg</title>
		<imprint>
			<biblScope unit="page" from="77" to="90" />
			<date type="published" when="1976-05">May 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A relational model for large shared data banks</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">F</forename><surname>Codd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="377" to="387" />
			<date type="published" when="1970-06">June 1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Further normalization of the data base relational model</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">F</forename><surname>Codd</surname></persName>
		</author>
		<editor>Data Base Systems, R. Rustin</editor>
		<imprint>
			<date type="published" when="1972">1972</date>
			<publisher>Prentice-Hall</publisher>
			<biblScope unit="page" from="33" to="64" />
			<pubPlace>Englewood Cliffs, N.J.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Relational completeness of data base sublanguages</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">F</forename><surname>Codd</surname></persName>
		</author>
		<editor>Data Base Systems, R. Rustin</editor>
		<imprint>
			<date type="published" when="1972">1972</date>
			<publisher>Prentice-Hall</publisher>
			<biblScope unit="page" from="65" to="98" />
			<pubPlace>Englewood Cliffs, N.J.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The complexity of theorem proving procedures</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd Ann</title>
		<meeting>3rd Ann</meeting>
		<imprint>
			<date type="published" when="1971-05">May 1971</date>
			<biblScope unit="page" from="151" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">An Introduction to Database Systems</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Date</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1975">1975</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Contributions theoretiques a la conception d&apos;un systeme d&apos;informations</title>
		<author>
			<persName><forename type="first">C</forename><surname>Delobel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ph.D. Th., U. of Grenoble</title>
		<imprint>
			<date type="published" when="1973-10">Oct. 1973</date>
			<pubPlace>Grenoble, France</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Multivalued dependencies and a new normal form for relational databases</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="262" to="278" />
			<date type="published" when="1977-09">Sept. 1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Computers and Intractability: A Guide to the Theory of NP-Completeness</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1978">1978</date>
			<pubPlace>Freeman, San Francisco</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Optimization of a single relational expression in a relational database system</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A V</forename><surname>Hall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM J. Res. Develop</title>
		<imprint>
			<biblScope unit="page" from="244" to="257" />
			<date>May 19761</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Reducibility among combinatorial problems</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Karp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Complexity of Computer Computations</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Miller</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Thatcher</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Plenum Press</publisher>
			<date type="published" when="1972">1972</date>
			<biblScope unit="page" from="85" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Testing implications of data dependencies</title>
		<author>
			<persName><forename type="first">D</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mendelzon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="455" to="469" />
			<date type="published" when="1979-12">Dec. 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Performing inferences over relational databases</title>
		<author>
			<persName><forename type="first">J</forename><surname>Minker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Dept. of Comptr. Sci., U. of Maryland</title>
		<imprint>
			<date type="published" when="1975-03">March 1975</date>
			<pubPlace>College Park, Md</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep. TR363</note>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">A database search problem</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P</forename><surname>Palermo</surname></persName>
			<affiliation>
				<orgName type="collaboration">Znformation Systems COINS ZV</orgName>
			</affiliation>
		</author>
		<editor>J.T. Tou</editor>
		<imprint>
			<date type="published" when="1974">1974</date>
			<publisher>Plenum Press</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Efficient evaluation of expressions in a relational algebra</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Pecherer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. ACM Pacific Conf</title>
		<imprint>
			<biblScope unit="page" from="44" to="49" />
			<date type="published" when="1975-04">April 1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Equivalence among relational expressions with the union and difference operations</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Fourth Int. Conf. on Very Large Data Bases</title>
		<meeting>Fourth Int. Conf. on Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="1978">1978</date>
			<biblScope unit="page" from="535" to="548" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Optimizing the performance of a relational algebra database interface</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">Y</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><surname>-T</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="568" to="579" />
			<date>Oct. 19751</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Principles of Database Systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<publisher>Computer Sciences Press</publisher>
			<pubPlace>Potomac, Md</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Decomposition-a strategy for query processing</title>
		<author>
			<persName><forename type="first">E</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Youssefi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="223" to="241" />
			<date type="published" when="1976-09">Sept. 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Analysis and design of relational schemata for database systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Zaniolo</surname></persName>
		</author>
		<idno>UCLA- ENG-7769</idno>
	</analytic>
	<monogr>
		<title level="j">Dept. of Comptr. Sci., U. of California</title>
		<imprint>
			<date type="published" when="1976-07">July 1976</date>
			<pubPlace>Los Angeles, Calif</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Query-by-example: The invocation and definition of tables and forms</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Zloof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Int. Conf. on Very Large Data Bases</title>
		<meeting>ACM Int. Conf. on Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="1975-09">Sept. 1975</date>
			<biblScope unit="page">24</biblScope>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
