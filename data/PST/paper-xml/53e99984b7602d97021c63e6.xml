<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">How Much Memory is Needed to Win Infinite</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Stefan</forename><surname>Dziembowski3</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Marcin</forename><surname>Jurdzi6ski3j4</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Igor</forename><surname>Walukiewicz</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Institute of Informatics5 Warsaw University I</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Institute of Informatics</orgName>
								<orgName type="institution">Warsaw University</orgName>
								<address>
									<addrLine>Banacha 2</addrLine>
									<postCode>02-097</postCode>
									<settlement>Warszawa</settlement>
									<country key="PL">Poland</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">How Much Memory is Needed to Win Infinite</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">3C4987E581A6347E8DCBF75F29F5173A</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T09:16+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>We consider a class of infinite two-player games on nitely coloured graphs. Our main question is: given a inning condition, what is the inherent blow-up (additional emory) of the size of the I/O automata realizing winning trategies in games with this condition. This problem is relvant to synthesis of reactive programs and to the theory of utomata on infinite objects. We provide matching upper nd lower bounds for the size of memory needed by wining strategies in games with a fixed winning condition. We Lnce record) data structure of Gurevich and Harrington is ptimal. Then we propose a more succinct way of repreenting winning strategies by means of parallel composiions of transition systems. We study the question: which lasses of winning conditions admit only polynomial-size</head><p>i lowup of strategies in this representation.</p><p>I lso show that in the general case the LAR (latest appear-'A part of this research was carried out while the authors were visiting Basic Research in Computer Science, Centre of the Danish National Research Foundation. No.8TllC002 11.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(1 Introduction</head><p>We consider games played on (not necessarily finite) raphs coloured with a finite number of colours <ref type="bibr">[15,</ref> 231. he two players altematively choose vertices forming an infinite path through the game graph. The winner is established by a Muller winning condition (defined on the finite set of colours).</p><p>These games can be seen as a special case of general Bore1 games and were first studied by Buchi and Landweber [4]. Gurevich and Harrington in their seminal paper [ 111 I have shown that if a player has a strategy in such a game then there is a winning strategy for her that uses only finite information (memory) about the history of the play.</p><p>Since this result, infinite games became a central tool in the theory of automata on infinite objects <ref type="bibr">[9,</ref><ref type="bibr">13,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr">201</ref>. They were also used in understanding logics of programs [9, 18,211. It was also observed that a game may be considered as a specification of a reactive system by viewing it as a description of all possible interactions between player 0 (Control) and player 1 (Environment). A winning condition in a game specifies some requirements on the behaviour of the reactive system (for example some liveness properties). In this metaphor, a winning strategy can be seen as a program satisfying the specification. Hence, in this framework, strategy construction amounts to program synthesis and deciding if there exists a winning strategy for player 0 is equivalent to the problem of realizability of specifcations of reactive systems. These problems were studied for example in [l, 4, 14, 171.</p><p>In all these applications an important question is how much memory a strategy may need. As an example from automata theory, consider the complementation lemma for automata on infinite trees. There, in the construction of the automaton accepting the complement of the language, one takes as states subsets of the set of pairs: (state of the original automaton, memory state of the strategy). Hence the size of the required memory influences the size of the automaton for the complement. In particular it can change this size from single to double exponential. In the area of program logics, additional memory reflects in complications in proof constructions as for example in <ref type="bibr" target="#b20">[21]</ref> or in tableau constructions [3, 61. In these applications it is important to understand the structure of the additional memory. Until now essentially the only known memory structure were LAR's [ l l , 15,231.</p><p>Most importantly, however, the question of memory size is crucial in the program synthesis. It measures the inherent blow-up of the size of a program satisfying a specification in terms of the size of the specification itself. In order to understand feasibility of program synthesis, as described above, it is hence important to classify winning conditions according to the blow-up in the size of strategies they may incur.</p><p>In some applications it is necessary to deal with infinite game graphs, e.g., when proving complementation lemma for automata on infinite trees. When considering program synthesis, however, one usually takes into account game graphs of size at most polynomial in the number of colours in the winning condition. (Although finitely definable infinite size games also were considered in this context [5, 20, 221 and our results are also applicable there). As we will see the case when the size of the game graph is bounded in the number of colours is different and technically more difficult, hence it is appropriate to consider it separately. We will consider the problem: how much memory is needed to win games with a given class of winning conditions. We will consider both, the case when we bound the size of games by the number of colours in the condition and the case when we do not impose this bound.</p><p>It is well known that there exists a sequence of games The problem is to give an explicit description of a function h : {0,1}* + {0,1} that is not computable in nonuniform NC1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Overview of the results</head><p>First we consider the case when we do not limit the size of game graphs in terms of the number of colours in the winning condition. We define the size of the memory of a strategy as number of states of an U 0 automaton realizing the strategy. In this case we obtain matching upper and lower bounds for any fixed winning condition 3, i.e., we determine a number mg such that:</p><p>1. For every game with the winning condition 3, memory of size m g is sufficient for a winning strategy in this game.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>There exists a game with the winning condition 3 for which every winning strategy requires memory of size at least mg.</p><p>If we restrict ourselves to game graphs of size polynomial in the number of colours in the winning condition then, clearly, the upper bound still holds. General lower bounds, however, do not follow from the above, because our games requiring memory of size m g have graphs roughly of size ms (which may be exponential in the number of colours). We, however, provide a particular lower bound, that establishes optimality of LAR's also in this setting:</p><p>3. There exists a sequence of games ( $ n ) n 6 ~, such that the game graph of 9, is of size U(n) and every winning strategy requires memory of size n!.</p><p>In the last section we consider the problem of representing strategies by means of p-automata. We show that the strategies in the games 9, from (3) can be represented by polynomial size p-automata. Indeed polynomial size pautomata realising winning strategies exist for all games with winning conditions that can be represented by a Turing machine working in a space polynomial in the number of colours used in the condition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Comparison with the related work</head><p>Our upper bound theorem was inspired by the paper of Zielonka <ref type="bibr" target="#b22">[23]</ref>. He mentions some savings in memory for winning strategies by considering his notion of "useful colours". This observation is sufficient for showing memoryless determinacy for games with Rabin winning conditions (see also <ref type="bibr">[7,</ref><ref type="bibr" target="#b12">131)</ref>. In general his bound is not optimal. Our upper bound is in some cases exponentially smaller than his. Zielonka's motivation comes from automata theory so he considers potentially infinite graphs. In this setting our upper and lower bounds for memory needed by winning strategies are optimal.</p><p>Memory requirements in the context of program synthesis were studied by Lescow <ref type="bibr" target="#b11">[12]</ref>. He considers only game graphs of size linear in the number of colours and seeks a characterisation of winning conditions admitting a Preliminaries scow provides also some 2"(") lower bounds. We improve :see [20], p. 9).</p><p>Finally let us mention the following algorithmic prob-.em: given a game and a node, establish whether player 0 ias a winning strategy from this node. McNaughton <ref type="bibr" target="#b14">[15]</ref> 9 we define the set of frequent colours of R (denoted by</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I n . f ( ~) )</head><p>as the set of colours that occur infinitely often in the sequence ( x ( v o ) , x ( v l ) , x ( v ~) , . . .). An infinite play R is a winning play for player 0 if the set of its frequent colours is an element of the winning condition for player 0, i.e., I n . f ( ~) E 3.</p><p>A strategy for player 0 in a game 9 is a partial function</p><formula xml:id="formula_0">&lt; : V * 2 Vi, defined for finite plays R = ( v o , v l , . . . ,vk)</formula><p>with vk E h, such that ( v k , C ( ~) ) E E. A play R = (vo,v1, 212, . . .) from a node vo E VO is consistent with the strategy if ((vo, . . . , v2i) = v2i+l for i = 0, 1, . . . . A strategy C is winning for player 0 from a vertex 00 if every infinite play starting from vo consistent with ( is winning for player 0.</p><p>A winning set for player 0 is the set of vertices of the arena from which there exists a winning strategy for player 0. It is easy to see that these strategies can be "merged" (see <ref type="bibr" target="#b14">[ 15]</ref>), hence there is also one common winning strategy on the winning set. Proviso: We will consider winning strategies for player 0. Thus w.1.o.g. we can assume that player 0 has a strategy to win from every vertex of the arena. To meet this requirement it is enough to restrict the arena to the winning set of player 0.</p><p>It turns out (see <ref type="bibr" target="#b10">[ 11,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr">231)</ref> that for the games we consider the winning strategies can be realized by functions that do not have to refer to the whole histories of the play (i.e., the elements of the set V ' ) , but only to a finite information about the play so far. To make this precise we introduce the notion of strategies with memory. 3er of colours. In case the of games with winning condi-):ions given in Rabin form, <ref type="bibr">Emerson and Jutla [8]</ref> show that he problem is NP-complete. From our general upper bound on memory we infer a class of winning conditions for which :he problem is in NP n co-NP (see <ref type="bibr">Corollary 12)</ref>. This can A play R = (VO, v1, v2, . . .) is consistent with S if there is a sequence of memory states (mo, m l , m 2 , . . .), such that</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>U1</head><p>We consider infinite duration games played by two play-:rs (player 0 and player 1) on finitely coloured graphs called lzrenas. An arena is a tuple A = (V, h, V I , E , C, x) where:</p><formula xml:id="formula_1">:V, Vi, fi, E ) is a (not necessarily finite) bipartite directed mo =</formula><p>and mi mi+1 for every i = O , l , 2 , . . I .</p><p>A strategy automaton S realizes a strategy ( with (finite) memory M , defined as follows. For a finite play R = (vo,. . . ,v2k) consistent with S we set C(R) = v if for the memory mk obtained as above we have mk 3 m and ( w ,</p><formula xml:id="formula_2">v ) E E .</formula><p>In case M is a one element set, we call the strategy memoryless.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Upperbound</head><p>In this section we are going to determine (Theorem 6) for every winning condition 3 the number ms such that for every game with the winning condition 3 the memory of size m3 is sufficient for a winning strategy in this game. </p><formula xml:id="formula_3">1. If C 2. If C E F then the root of Z ~, C is labelled with C. Let</formula><p>CO, c1, . . . , ck-1 be all the maximd sets in { X # 3 : X C_ C}. Then we attach to the root, as its subtrees, the Zielonka trees of 3 r Ci, i.e. Z ~I C ; , C ~,</p><formula xml:id="formula_4">for i =</formula><p>The domain of Zs,c (denoted by I~ZF-,C I I) is defined as the set of nodes of the tree. The Zielonka tree Zs,c can be formally seen as the labelling function e : IlZs,cll + ?(C) assigning to every node in the domain its label as defined above. In the sequel we will usually write 2s to denote Zs,c, if C is clear from the context.</p><p>A node of 23 is a 0-level node if it is labelled with a set from 3. Otherwise it is a I-level node.</p><p>Let 3   Let .A = (V, Vi, V I , E , C, x) be an arena. Now we will define the notion of an attractor. This will be a subarena of the arena. For simplicity in the sequel we will often identify subarenas with the sets of their vertices. </p><formula xml:id="formula_5">F then Z 3 , c = Zg,c whereF = Y(C) \ 3. 0,1, ..., k -1 . 1 -level 0-level 1-level k Figure 1. Example of a Zielonka tree Example: Let C, = {tl ,... , t n , f l , . ..,f,}, for every n E N.</formula><formula xml:id="formula_6">0 T o = T f l W , Tg+1 = Tg U {V E n W : V E n Tg # 0} U {V 6 Vi-i fl W : V E C Tg}, 0 if &lt; is a limit ordinal then let Tg = U, , . , &lt; T,,.</formula><p>Set Attry(T) = Ue Tc.</p><p>Remark: It is easy to show (see <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr">201)</ref> that Attry(T) is the set of vertices in W from which player i can force the play into T using a memoryless strategy.</p><p>Let us consider a game 9 = (A,3) with the winning condition 3 5 ?(C) and the arena .A = (V, 6 , V I , E , C, x). We enrich the labels of the Zielonka tree Z 3 , c to contain also sub-arenas of .A, on which player 0 has winning strategies in respective subgames. We also remove those subtrees for which the associated subarenas are empty. In this way we obtain the Zielonka tree of the game 9. The labelling V will assign to the nodes of Z 3 , c subarenas of V . Hence eventually we will have two labelling functions: e as in the definition of ZS,C, and V which we are going to define now.</p><p>1. Set V ( s ) = V if s is the root node, i.e., the root is labelled with the set V of all vertices of the arena.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>Suppose that for a node s' the function V(s') = V' is already defined and e(s') = C' E 3. For every son s"</p><formula xml:id="formula_7">of s' we set ~( s " ) = V' \ Attrl' (X-'(C' \ ~( s " ) ) ) .</formula><p>3. Suppose that V(s') = V' is already defined and  efinition 5 (Memory of a Zielonka tree) Let Z be a ielonka tree. A subtree of Z is called a I-subtree, if it in be obtained from Z by leaving at most one child of ev-'y 1-level node. We define the memory of Z to be the set fz = { 1,2, . . . , mz}, where mz is the maximal num-:r of leaves of a 1-subtree of 2. We will use M 3 and For the rest of this section let us fix a game 9 = (A, 3) ith the arena A = (V, V,, VI , E, C, x). To prove the theo-:m we will construct an I/O automaton realizing a strategy I this game. This automaton will have mg states. First we :ed some definitions.</p><p>We start with the definition of a numbering of the leaves of Zg. Let Z be a Zielonka tree and s E N. We define the s-numbering of 2 inductively:</p><p>1. If the root of 2 is a leaf, then let s be its number.</p><p>2. If the root of Z is a 0-level node, then let 20, . . . , Zk-1 be all its immediate subtrees. The s-numbering of Z is obtained by the si-numbering of Z i for every i = 0,. . . , IC -1, where si = s + Cjz0 mzj.</p><p>3. If the root of Z is a 1-level node, then let ZO, . . . , Zk-1 be all its immediate subtrees. The s-numbering of Z is obtained by the s-numbering of Z i for every i = i-1 0, ..., k-1.</p><p>The numbering of the leaves of Zg we are after is simply the 1-numbering of 29. Observe, that this numbering associates with every leaf of the Zielonka tree Zg an element of A memory m E Mg does not uniquely determine a path from the root down the Zielonka tree 29. The reason is that a memory specifies only branchings at 0-level nodes of the tree, i.e., at a 0-level node we branch into the only subtree that may possibly contain leaves numbered with m. A pair (w,m) E V x Mg, however, is just enough to single out such a unique path. To determine the "missing" branchings at 1-level nodes of Zg, we use the fact, that sets of vertices labelling the children of a 1-level node of Zg are pairwise disjoint. Thus either we branch to the unique child of a 1level node which is labelled with a set of vertices containing U, or we have reached the end of the path if none such a child ex is ts .</p><p>M s -Definition 7 (Anchor node) We will say that s E 11Zg11 is the anchor node for (w,m) E V x Mg, if it is the lowest node on the unique path for (w, m), as described above, such that w belongs to the set of vertices labelling s in the Zielonka tree Zg .</p><p>Before we describe the strategy for player 0 in the game 9, we shall define the memory updatefunction and the next move function, which will be the essential components of the strategy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 8 (Memory update function) We define the memory update function pg</head><formula xml:id="formula_8">: V x Mg + Mg. Given (U, m) E V</formula><p>x Mg we first find the anchor node s E 11Zg11 for (U, m). We define pg (U, m) by cases:</p><p>If s is a leaf in 11Zg11 or s is a 1-level node then 0 Otherwise s is a 0-level node. Find the son s' of s, with a leaf numbered m in the subtree rooted in s'. Suppose it is the i-th son of s.</p><formula xml:id="formula_9">P9 (U, m) = -If w E x-l(e(s) \ e(s')) then pg(v,m) = m',</formula><p>where m' E Mg is the lowest number associated with a leaf in the ((i + 1) mod k)-th subtree of s, and k is the number of children of s in 2 g .</p><p>-Otherwise ps (w, m) = m.</p><p>Definition 9 (Next move function) We define the next</p><formula xml:id="formula_10">movefunction og : Vo x Mg + VI. Let (U, m) E V x Mg</formula><p>and lets' be the anchor node for (w, m). Let (C', V') be the label of s'. We define q ( w , m) by cases:</p><p>I f s ' is a leaf in /12~1( then ag(w,m) = w' for some</p><formula xml:id="formula_11">w' E V n WE.</formula><p>If s' is a O-level node, then find the son s" of s', with a leaf numbered m in the subtree rooted in s". Let (C'', V") be the label of s" in the Zielonka tree 29.</p><p>(a) If w E x-l(C' \ C") then q ( w , m ) = w' for some 'U' E V n WE. where T : VO 2 VI is the memoryless strategy "attract to the set W,".</p><p>Remark: According to our proviso, player 0 has a strategy from every vertex of the game. With this assumption it can be shown (see <ref type="bibr" target="#b22">[23]</ref>) that indeed w E UF Wc; hence there exists p required in the last clause of the above definition. The strategy Cg uses memory Mg of size mg 5 ms (see Definition 5). To prove Theorem 6 it remains to show that Cg is a winning strategy for player 0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 10 (The strategy</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 11</head><p>The strategy Cg is winning for player 0. the strategy 4-5 attracts the play to a set 2, with a smaller ( than before. We can, however, decrease 5 only finitely many times, so almost every wj belongs to some fixed</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2, E y t m o d h ) .</head><p>Thus almost every sj belongs to the subtree of Zg rooted at ([ mod k)-th child of s,. This, however, contradicts the definition of s,. 0</p><p>Observation 11.2 s , occurs infinitely often in (81 , s 2 , 3 3 7 * * . ).</p><p>Proof: If it did not, then there would exist an i, such that for almost every j we would have wj E q. This contradicts the definition of s,. 0</p><p>From the definition of s , it is evident that Inf(7r) E C'.</p><p>From Observations 11.1 and 11.2 it follows that for every i = 0,. . . , k -1 the strategy Cg attracts the play 7r to the set x-l (C' \ Ci) infinitely many times, so in fact we have that As, by Observation 11.1, s is a O-level node, we have that Inf(~) E 3. Hence Cs is winning for player 0 and</p><p>Remark: Note that, in particular, if F(C) \ 3 is closed under union, i.e., 3 can be expressed by a Rabin condition (see <ref type="bibr" target="#b22">[23]</ref>), then the strategy &lt;g is memoryless. Memoryless determinacy for such games was shown in [7, <ref type="bibr">131.</ref> Remark: Observe that every l-subtree of a tree from the Example on page 4 (Figure <ref type="figure" target="#fig_3">1</ref>) has n leaves (labelled with H i l , . . . , H,, for some i). From Theorem 6 it follows that winning strategies for player 0 in every game with such a winning condition need at most memory of size O ( n ) .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>W ( X ) $2 ci.</head><p>Theorem 6 is proved. where mr is the initial memory of (CJ. Let the uring of the nodes of G be inherited from the colour7 of the arena A, i.e., x((v,m)) = ~( v ) . Deciding if strategy CCJ is winning for player 0 is clearly equivato checking that all the infinite paths in the graph G are sets belonging to 3.</p><p>winning for player 0.  <ref type="bibr">(As,</ref><ref type="bibr">3)</ref> requires memory of size at least m3.</p><formula xml:id="formula_12">r</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>Let 3 E P(C). Assume that C E 3. Otherwise we take a son s' of the root, such that, there is a 1-subtree with m3 leaves below s'. Then we can take the label C' of s' and continue our construction for 3 1 C' instead of 3.</p><p>Let T be a 1-subtree of the Zielonka tree 23 with m3 leaves and let q , . . . , U,, be all the leaves of T . We define the arena A 3 as follows. For every set of colours After performing these moves player 1 updates his current memory ( d l , . . . , dn) by changing its j-th component to the next element of Dj in some fixed linear order (or to the minimal element of Dj in this order, if d j was maximal). Now we will argue that this counter-strategy guarantees a win for player 1. For a play R formed according to this counter-strategy consider the set I of indices j chosen infinitely often in the way described above. Set i = min <ref type="bibr">(I)</ref> and observe that from some moment of the play R only colours in the set Di U Di+l U -. a U D, = Di appear (recall that DI 3 D1+1 for I = 1,. . . ,n. -1). Moreover, each colour of Di is hit infinitely often. Thus Inf(n-) = Di. This completes the proof since Di is a winning set for player 1.</p><formula xml:id="formula_13">E = {</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="0">U</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Remark:</head><p>The arena A 3 constructed in the proof of Theorem 14 is roughly of size 7713. Hence, if for a family of conditions ( 3 n ) n E ~ the number my, grows superpolynomially in the number of colours of 3,, then our lower bound does not apply to the case when we restrict ourselves to arenas of size polynomial in the number of colours. We do not know whether the m3 bound is strict in this case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Optimality of the LAR's</head><p>Now we show a factorial lower bound establishing optimality of the LAR data structure even for games with arena sizes bounded linearly in the number of colours of the winning condition. Optimality of LAR's in the case when we do not bound the size of the game follows from the previous section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 15 (LAR's are optimal)</head><p>There is a family of games ( g n ) n E ~, such that the arena of g, is of size O(n) and every winning strategy for player 0 in 9, has memory of size at least n!.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>The game 9, has the arena An = (V, b, fi, E , Cn, x ) , where: VO = {-n ,..., -1}, VI = (1 ,... <ref type="figure">,</ref><ref type="figure">n},</ref><ref type="figure">j ) ,</ref><ref type="figure">( i ,</ref><ref type="figure">j E</ref> (1 ,..., n } } andCn = V . We identify vertices with colours setting x(v) = U , for every v E V . The winning condition of 9, is defined as</p><formula xml:id="formula_14">3n = {C E Cn : IC n &amp;I = max(C n Vi)}.</formula><p>It is not difficult to see that player 0 has an LAR winning strategy in 9, (in fact it suffices to consider LAR's over colours from the set VO only).</p><p>Suppose that S = ( M , Vo, Vi, mI , =+.) is an U 0 automaton realizing a strategy for player 0. For the sake of this proof by the transition graph of S we will understand the graph ( M , +) with edges labelled by elements of VO, where m 3 m' if there is a v1 E &amp;, such that m 3 m' holds.</p><p>In the following lemma we slightly strengthen the statement of the theorem, in order for the proof by induction on n to go through.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>U1</head><p>Lemma <ref type="bibr" target="#b15">16</ref> Let S be the VO automaton realizing a winning strategy for player 0 in 9, . Then there is a state m E M reachable from the initial state of the transition graph of S, and a finite sequence w E V,* with at least one occurrence of every element of VO, such that:</p><p>1. m 3 , m, i.e., the path in the transition graph of the automaton S, labelled with the input word w and starting in state m is a loop, 2. IM, I 2 n!, where M , is the set of states of S on the Proof: W.1.o.g. we can assume that the transition graph of the automaton S is strongly connected. Otherwise we could restrict the transition graph of S to one of its strongly connected components (s.c.c.), that is reachable from the initial state, and is final in the acyclic graph of all s.c.c.'s of S (i.e., there are no edges going out of this S.C.C. in the transition graph of S). As player 1 can in a finite number of moves force the play into a reachable final s.c.c., clearly after such a restriction the remaining strategy is still winning for player 0.</p><p>The base case of the induction follows immediately from the assumption that the transition graph of S is strongly connected.</p><p>Let XI, . . . , X, be sub-games of 9, , such that Xi is obtained by removing -i from VO and n from VI. It is easy to see that U 0 automata SI,. . . , S, obtained by straightforward restrictions' of S realize winning strategies for player 0 in games XI, . . . , Xn. From the induction hypothesis it follows that there are states ml, . . . , m, E M , and path described above.</p><p>'More precisely, in order to obtain Si we restrict the input alphabet of S to VO \ { -i}, and change the output component of the transition relation whenever it is 12 to, for example, (n -1). finite sequences wi, . . . ,wn, such that wi E (VO \ {-i})* and lMil 2 (nl)!, where Mi is the set of states on the path mi 3, mi.</p><p>Observe that the outputs produced by S on any path m i 9, mi for i = 1,. . . , n do not contain any occurrence of n E Vi. Otherwise, the infinite input sequence would form a play winning for player 1. This, however, would contradict the assumption that S realized a winning strategy for player 0 in 9, .</p><p>We will now argue, that if i # j then Mi n Mj = 0. This would immediately imply that I Mil 2 n * (n -1) = n!. Assume the contrary, i.e., that there is a state m E Mi n Mj for some i # j . Then there are partitions Wi = u1 .u2 and wj = v1 v2, such that mi 7, m 7, mi and mj 2, m 5, mj. So there is a loop m m. Hence, the infinite input sequence (212 . u1 . v2induces a play winning for player 1, because the sequence u2 u1 v2 . vi contains occurrences of all n elements of VO, and the output generated by S does not contain a occurrence of n E Vi. This, however, contradicts the assumption that S realized a winning strategy for player 0.</p><p>To finish the proof of the Lemma it remains to show that the sequences wi for i = 1, . . . , n can be composed to yield a sequence w, such that m 3, m for some m E M and this cycle includes all cycles mi 3, mi as its sub-paths.</p><p>Again, the assumption of strong connectedness of the tran-</p><formula xml:id="formula_15">0 U 2 ~t b ~W 2 ~~1</formula><p>+, sition graph of S makes this task trivial. 0</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Polynomially representable strategies</head><p>The lower bound of the previous section indicates that the size of the memory of U 0 automata realizing winning strategies may be inherently big as a function of the size of the arena. Here we consider a representation of strategies in terms of so called p-automata, which are parallel compositions of U 0 automata. It turns out that p-automata are capable of encoding strategies in a more succinct way than VO automata. One would like to measure the size of a winning strategy in a game in terms of two parameters: the size of the arena and the size of the winning condition. From the perspective of program synthesis it seems natural to assume that the arena is given just as a graph. On the other hand it is much too restrictive to assume that winning conditions are given in Muller form. For example, Rabin conditions can be sometimes exponentially more succinct than Muller conditions. To avoid these problems of different representations we propose to represent winning conditions by means of Turing machines, or equivalently, by p-automata. For a function p(n), we will say that a family Tv[ of winning conditions is p(n)-recognisable if for every winning condition F E M with n colours there exists a p-automaton of size p ( n ) recognizing 3. Hence our notion of recognizability will be a non-uniform one. We find it more intuitive to express this notion in terms of p-automata.</p><p>The main result of this section is that if a family of winning conditions is p(n)-recognisable for some polynomial p(n) then winning strategies in games with these conditions are representable by polynomial size p-automata. We also show that it is difficult to characterize all families of winning conditions admitting polynomial size strategies in terms of p-automata. For this we recall that it is an open problem to show an example of aBoolean function not computable in nonuniform NC'. Every family of conditions not admitting polynomial size strategies would give an example of such a function. Hence, although there are many families of winning conditions that do not admit polynomial size p-strategies, it is not easy to come across one of them. Definition 17 (p-automaton) Let (Xi)?==, be a tuple of U 0 automata, each of the form Xi = (Qi, Gin, Eout, qi, *i).</p><p>We assume that there is a special letter T E Cin n Eout. If (. . . ,qi,. . .)+a(.. . ,q:, . . .) (. . . ,qz,. . . ,e,. . .)+a(. . . ,q:, . . . , q;, . . .)</p><p>We can use p-automata to succinctly represent languages over some alphabet E. For this we let Cezt 1 C U {tt,fl} and say that a word w E E* is accepted by a p-automaton if the global automaton outputs tt after reading W.</p><p>A Muller sequence ( M n ) n E ~ is a sequence of sets of winning conditions, such that every 3 E XIn is a condition using at most n colours.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 18 (Polynomially representable Muller sequence)</head><p>We say that aMuller sequence (3YCn)ncN ispolynomially representable if there exists a polynomial p(n), such that for every 3 E M, there is a p-automaton of size p(n) representing 3; here we consider 3 to be a set of sequences of colours.</p><p>We can also use p-automata to succinctly represent "sequential" U 0 automata (as in Definition 1). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Not every game is so easy. A simple counting argument shows:</head><p>Proposition 20 There exists a Muller sequence (M,),,~I that does not have polynomially representable strategies.</p><p>Next we will show that every polynomially representable Muller sequence has polynomially representable strategies and p-automata realizing these strategies can be constructed in polynomial time. 1 inspection of the definition of the strategy (9 ast given an oracle for recognizing sets in the winning ion, the whole winning strategy can be in fact com-(however not necessarily output) in space polynomial</p><p>The polynomial space Turing machine T computing e strategy can be in a straightforward way encoded by a pomaton 'J of size linear in the size of configurations of T. nce, to obtain the p-automaton 3 realizing the strategy ('9 is enough to "compose" 7 and In;, so that the oracle quess of 'J are answered by W , After "composition" with W nally obtain a p-automaton of size O(poly(lJ11,1WI)).</p><p>mark: This proposition does not contradict the fact that, general, constructing sequential strategy automata is difult. It may be difficult to construct a sequential straty automaton from the parallel one. The reason is that ptomaton may sometimes do a long sequence of 7-moves fore answering the next move.</p><p>orollary 22 Suppose that a family of winning conditions recognised by a Turing machine working in a space mial in the number of colours used in the condition. ws that winning strategies in games with these conions can be represented by polynomial size p-automata. particular Rabin or Street winning conditions with the ber of pairs polynomial in the number of colours admit lynomial size strategies.</p><p>It would be tempting to say that if a Muller sequence mits polynomially representable strategies then the seence itself is polynomially representable. This turns out position 23 There exists a Muller sequence (M,),,N has polynomially representable strategies, but is not nomially representable. a boolean function h : {0,1}* + {0,1} that is not omially representable. Define the Muller sequence ,EN by ?&amp;,-I = 0 and M2, = (3,) for evn = 1,2, . . . , where 3n is as defined in the example ge 4. Clearly the Muller sequence (Jvt,JnE~ is not omially representable. Nevertheless, from the The-6 it follows that (nlc,),,~ has polynomially repreable strategies (see the second remark after the proof of U The problem of characterizing families of winning contions having polynomially representable strategies is at ast as difficult as giving an answer to one of the main stions in nonuniform complexity theory. We will now that if we had such a characterisation then we could</p><p>show an example of a function h : {0,1}* + {0,1} that is not computable in nonuniform NC1. This is known to be the major open question about nonuniform complexity classes (see <ref type="bibr" target="#b1">[2]</ref> pp. 763-764 for the description of the problem). We show that arbitrary characterisation of Muller sequences having polynomially representable strategies will allow us to decide whether a function is computable in PSPACE/poly. Let h : {0,1}* + {0,1} be a function. For every n construct a game G(h, n) as in Figure <ref type="figure" target="#fig_6">4</ref>. Player 1 moves in square vertices and player 0 in the circle vertex. The set of colours is C, = {tl, . . . , t,, fl, . . . , fn, 0,l). The winning condition is the smallest set closed under union that contains the sets { X I , .</p><p>-. . , xn, h(371,. . . ,Tn)}; where xi E {ti, fi} and ?i = 1, f a = 0, for every i = 1 , 2 . . . , n.</p><p>It should be clear that player 0 has a winning strategy in this game. The simplest one is to give correct answers each time. Intuitively also all other strategies should be "aware" of the correct values of h.</p><p>If h is computable in PSPACE/poly then, by Proposition 21, for every n there is a polynomially representable strategy in the game G(h,n). If the strategies for all the games are polynomially representable then we claim that h is in PSPACWpoly. Let us take n and a p-automaton Xn of size p(n) realizing a winning strategy in the game G(h, n).</p><p>To calculate the value of the function h on some arguments X I , . . . , x, we simulate a particular play in G(h, n). In this play we make player 1 repeatedly choose x1 , . . . , x, and see what are the answers of 3, in this play. The first answer may not be correct but eventually the answers of Rn must stabilize at the correct answer. This should happen after no more than d steps, where d is the number of configurations of X,. It should be clear that this simulation can be performed in PSPACWpoly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Acknowledgements</head><p>The first two authors are grateful to Damian Niwidski for spiritual support and a wonderful introduction to the theory of automata on infinite objects.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>)</head><label></label><figDesc>e seen as a generalisation of the result due to Emerson, Jutla and Sistla [IO], where NP f l co-NP upper bound was Definition 1 (Strategy with memory) Let A = (V, VO, V I , E , C, x) be an arena. A strategy automaton is an I/O automaton S = ( M , VO, VI mr =$-), where M is a finite set of (memory) states; Vo, VI are input and output alphabets respectively; mr E M is the initial state; and *E M x h x VI x M is the transition relation. If m 3 m'then S being in the state m and reading vo from the input, outputs v1 and changes its state to m'.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>?Definition 2 (</head><label>2</label><figDesc>(C) be a winning condition. Define 3 1 D as the set {D' E 3 : D' 5 D}. Zielonka tree of a winning condition) We define the Zielonka tree of 3 5 ?(C) (denoted by 2 3 , ~) inductively:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>For a boolean function h : {O,l}n + {0,1} define a winning condition 3, 5 iP(Cn) as the family 0 and zi E { t i , f i } } , where = 1 and fi = 0 for every i = 1,. . . , n. The root of the Zielonka tree Z3-(c.f.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 1 )</head><label>1</label><figDesc>Figure1) is a I-level node labelled with the set C, of all colours. The k children of the root are 0-level nodes labelled with H I , . . . , Hk respectively. Every node labelled with Hi = {hil, . . . , hi,} has n children labelled with the sets Hil, . . . ,Hi, respectively, where Hij = Hi \ {hij}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>0</head><label>0</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>-</head><label></label><figDesc>{HI,. . . ,Hk} = ((51,. . . , x n } c c, : h ( Z , . . . , z n ) = Definition 3 (Attractor) Define the attractor for player i of a set T in the subarena W V (denoted by Attry (T)) in the following way. Construct by transfinite induction the increasing sequence To, Tl , T2, . . . of sets of vertices:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Definition 4 (</head><label>4</label><figDesc>Zielonka tree of a game) To define the Zielonka tree 5 9 of the game 9 we first define another labelling V : I IZ3,cl I + ?(V) of the Zielonka tree 2 3 , ~.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>A2</head><label></label><figDesc>e(s') = C' 3. Let sO,sl,. . . , sk-1 be all the sons of s' in Z ~, C , and e(si) = Ci f o r i = 0,1,. . . , k -1. Set V ( s i ) = Ui where the sets U; are computed as follows: Set initially WO := 0 and iterate through &lt; = 0 , 1 , 2 , . . . until We = We+, = . . . = Wc+k-,. The sequence (Wg) is defined by transfinite induction. If 5 is a limit ordinal then we set Wg = U,,&lt;$ W,,, and otherwise perform the following computations (see Figure 2): (a) Set X g = V' \ Attrr'(Wg). (b) Set Y g = Xg \ Attr? (x-'(C' \ C(cmodk))). The shaded region is equal to Wc+1; AI = Attrr'(Wc); Dc = x-l(C' \ C(cmodk)); A2 = Attrf['(Dc).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Calculating Wc+l</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>1 3</head><label>3</label><figDesc>to denote the memory and the size of memory of the ielonka tree 23. Similarly we will use Mg and mg when :ferring to the memory and the size of memory of the ee 29. Clearly, for a game 9 = (A, 3) we have that Zgll C IlZsll, hence mg 5 m3. heorem 6 (Upper bound) 7r every game 9 with the winning condition 3, player 0 zs a strategy Cg winning from every node of her winning !t and requiring memory of size at most ms.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>( b )</head><label>b</label><figDesc>Otherwise og(w,m) = T ( W ) where T : &amp; 3 VI is the memoryless strategy "attract to the set x-l(C' \ C")". If s' is a 1-level node and p = m a { ( : w W,} (where W, for C; = 0 , 1 , 2 , . . . are the same as calculated in the definition of 'V(s')), then os (w, m) = T ( W )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>0</head><label></label><figDesc>Cg) The strategy &lt;g in the game 9 is realized by the I/O automaton S = (Mg,Vo,V~,mx,+), whereml = 1 E Mg a n d m 3 m'whenever w', m' can be "computed" by performing the folupdate the memory according to the move of player 1 (m" = P ( V , m)), 0 compute the move to be performed (U' = ~( w , m")), 0 update the memory according to this move (m' = P ( W ' 1 m")).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>0 problem 12 (</head><label>012</label><figDesc>Corollary Complexity of games) The { (Zs,A, 210) : player 0 has a winning strategy in the game (A, F) starting from the vertex WO of the arena A} is in NP n CO-NP. F). If player 0 has a winning strategy in 9 then ess is the strategy (9. To prove that the problem to show, that there is a polynomial time decide if this strategy is winning for player 0. artite graph, such that m = m ' a n d ( v , v ' ) E V i xvoisanedgeofthearena tomaton realizing CCJ. restrict G to the vertices reachable from the vertex , m ~) ,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>Figure 3(a). In the square (uncoloured) vertex player 1 makes a choice to visit a vertex coloured with one of the colours in E. To facilitate the description of the whole arena let us use the sequence of labels on the path leading to a node of T to identify this node. A notation Ci Di . . . CnDn(Cn+l) denotes a leaf to which leads a path with labels C1 D1. . . CnDn or C1 D1. . . Cn DnCn+1. For every leaf ci = C l D l . . . C,Dn(Cn+l) of T we define a subarena ~o x ( a ) as on Figure 3(b). Again, in the square (uncoloured) vertex player 1 makes a move. Finally the arena A3 is defined as on Figure 3(c), where in the circle (uncoloured) vertex player 0 makes a move.Observe that a play on the arena A3 consists of an infinite sequence of the following choices:1. Player 0 chooses Box(a) for some leaf ci = C l D l . . . CnD,(Cn+l) of T.2. Player 1 chooses one of the indices j E { 1, . . . , n } .3. Player 1 picks a vertex coloured with one of the colours in Cj and then a vertex coloured with one of the colours in Cj \ Dj.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>q=&amp;iq' then, intuitively, the automaton does not read from the input; similarly for but then the automaton outputs nothing. A p-automaton is a sequence of I/O automata (Xi)?==, together with a set Cext of external letters.One can think of such an automaton as of a parallel composition of automata (ai)?==, restricted on actions not in Celt. In other words, it can be considered to be a CCS process: ( 2 1 1 1 . . . llRn)\((EinUEout) -Eext). The semantics of p-automata is based on this intuition. A sequence (Xi)?=' and a set Cezt as above de-Qn, X i n , Eout, (41,. . . ,qn), -3) with the transition function defined by the rules: fine a global I/O automaton X = (QI x X q i 3 a d a,b E C e x t</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Proposition 21</head><label>21</label><figDesc>There exists an algorithm that given a game 9 with the arena A and the winning condition represented by a p-automaton W, constructs in time O(polp(lA1,IWI)) a p-automaton 2 of size O(poly(JAJ, 1WI)) realizing a winning strategy for player O on her winning set.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. The arena of the game G(h, n)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Consider an infinite play 7r = (wl ,212, w3, . . . ) consistent with the strategy ('9 and let (ml , m2, m3, . . . ) be the se-. . , where mo = mr E Mg is the initial memory of Let (SI, s2, s3, . . ) be the sequence of the anchor nodes for the respective pairs (wj,mj). Define s, to be the root of the lowest subtree of Zg containing almost every sj. Let (C',V') be the label of s, in Zg. Let (Ca,&amp;), for i = 0,. . . , k -1, be the labels of the k children of s, .</figDesc><table><row><cell>quence of corresponding memories, i.e., we have ~2 j =</cell></row><row><cell>og(wzj-1,mzj-1) a n d m j = pg(wj,mj-~), foreveryj =</cell></row><row><cell>1,2,. 4-5.</cell></row><row><cell>Observation 11.1 s , is a O-level node.</cell></row></table><note><p>Proof: Suppose s, is a I-level node. Let 2, for E = 0, 1 , 2 , . . . be the same as calculated in the definition of V(s,). Every time s , is the anchor node for some (wj , mj)</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Theorem 14 (Lower bound) For every winning condition 3 there is an arena A3 such that every winning strategy forplayer 0 in the game</head><label></label><figDesc>The mg lower boundHere we consider the lower bound on the size of memory</figDesc><table><row><cell>13 (Strategy synthesis algorithm) There is an</cell></row><row><cell>that given a game 9 = (A, F) computes a win-layer 0 in time O((lA1 * d ) h ) ; here d is</cell></row><row><cell>4 Lower bounds</cell></row><row><cell>4.1</cell></row></table><note><p>every S.C.C. H of G find all 0-level nodes 0 ark: Corollary 12 can be seen as a generalisation of result of Emerson, Jutla and Sistla [ 101 that the decision m for games with Rabin chain (parity) conditions is r l CO-NP. In this special case the size of the Zielonka linear in the number of colours. a careful analysis of the strategy synthesis algorithm it in the definition of the strategy Cs one can obtain</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Such an automaton S, represented by 2, has all the same components as 3 but the transition relation. This relation is defined by: $&amp;&amp; if there are states a' and a", such that, &amp;=$a a ' A &amp; {"&amp;a a!. In other words, we can read an input, do some number of 7 moves, and then give an output.</figDesc><table><row><cell></cell><cell>b</cell><cell></cell></row><row><cell>7</cell><cell>7</cell><cell>b</cell></row><row><cell cols="3">Definition 19 (Polynomially representable strategies)</cell></row><row><cell cols="3">We say that a Muller sequence ( 3 M n j n E ~ has polynomially</cell></row><row><cell cols="3">representable strategies if there exists a polynomial p ( n ) ,</cell></row><row><cell cols="3">such that for every game (A, 5Fn) with 3n E M,, there is</cell></row><row><cell cols="3">a parallel automaton of size p( [AI) representing a winning</cell></row><row><cell cols="3">strategy for player 0 on her winning set.</cell></row></table><note><p><p><p>Let us give an example of savings that can be made with this representation. Consider the game 9, as defined in the proof of Theorem 15. Player 0 has a winning strategy in this game that consists of keeping LAR memory and choosing a number equal to the number of negative integers appearing before the change pointer in the LAR (for a description of LAR memory see</p>[20]</p>). To implement this strategy using a p-automaton, we can take n U 0 automata, each for storing one coordinate of the LAR. Then we add a component that takes care of input/output and of updating the other components. It should be obvious that the size of each of the components is linear inn. Hence there is a constant c, s.t., a winning strategy in 9, can be represented by a p-automaton of size cn. On the other hand Theorem 15 states that every "sequential" winning strategy for 9, must have size n(n!).</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>1. Choose P i c k ( C j ) and then pick a vertex coloured with d j , where (dl , . . . , d,) is the current memory of player 1.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ZThis work was partially supported by</head><p>Polish KBN grant 3Supported by BRICS Summer Student Programme. 4Supported by by Polish-Danish Student Exchange Programme.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>often by player 0 in step 1. Let ?j. = C1 D1 . . . CiDi, for j = 1,. . . , k be all the children of y in T . Observe that for every j = 1, . . . , IC there is a leaf uj in the subtree rooted in yj, such that the index i is chosen by player 1 in step 2 infinitely often in Box(nj). This, however, implies that If(-.) Dij for every j = 1,. . . , IC. On the other hand it is not hard to see that Inf(-.)</p><p>Ci, hence Inf(-.) E 3. 0 If the size of the memory of a strategy for player 0 in the game (A?, 3) is less than ms, then clearly there is a leaf g of T , such that player 0 playing according to this strategy never visits BOX(LT). Hence, the following claim establishes the lower bound of the theorem. Claim 14.2 Consider a strategy for player 0 in the game (AS, 3) and a leaf g in the tree T . If player 0 never visits Box((T) when playing according to the strategy, then the strategy is not winning for player 0.</p><p>Proof: Let n = CIDl . . . CnD,(Cn+l). We will now provide a counter-strategy for player 1 allowing him to make one of Di's the set of frequent colours. Which Di it will turn out to be depends on the actual behaviour of the strategy of player 0.</p><p>To </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Realizable and unrealizable specijications of reactive systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wolper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 16th Int. Coll. Automata, Languages and Programming</title>
		<meeting>16th Int. Coll. Automata, Languages and Programming</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">372</biblScope>
			<biblScope unit="page" from="1" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The complexity offinite functions</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Boppana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sipser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Handbook of Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Van Leeuwen Ed</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">A</biblScope>
			<biblScope unit="page" from="757" to="804" />
			<date type="published" when="1990">1990</date>
			<publisher>Elsevier</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">An effective tableau system for the linear time p-calculus</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bradfield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Esparza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mader</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 23rd Int. Coll. Automata, Languages and Programming</title>
		<meeting>23rd Int. Coll. Automata, Languages and Programming</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1099</biblScope>
			<biblScope unit="page" from="98" to="109" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Solving sequential conditions by jinite state strategies</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">H</forename><surname>Landweber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trans. Amer. Math. Soc</title>
		<imprint>
			<biblScope unit="volume">138</biblScope>
			<biblScope unit="page" from="295" to="298" />
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Model checking for contextfree processes</title>
		<author>
			<persName><forename type="first">B</forename><surname>Burkart</surname></persName>
		</author>
		<author>
			<persName><surname>Steffen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th Int. Conf. on Computer Aided Verification</title>
		<meeting>4th Int. Conf. on Computer Aided Verification</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">630</biblScope>
			<biblScope unit="page" from="123" to="137" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">DAM, CTL&apos; and ECTL&apos; as a fragments of the modal pcalculus</title>
		<author>
			<persName><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAAP&apos;92</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">581</biblScope>
			<biblScope unit="page" from="145" to="165" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automata, tableaux, and temporal logics</title>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="volume">193</biblScope>
			<biblScope unit="page" from="79" to="88" />
		</imprint>
	</monogr>
	<note>Logics of Programs</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The complexity of tree automata and logics of programs</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jutla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 29th Annual IEEE Symp. on Foundations of Computer Science</title>
		<meeting>of 29th Annual IEEE Symp. on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="328" to="337" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Tree automata, mucalculus and determinacy</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jutla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 32nd Annual IEEE Symp. on Foundations of Computer Science</title>
		<meeting>of 32nd Annual IEEE Symp. on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="368" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">On model-checking for fragments of p-calculus</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jutla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Sistla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th Int. Conf. on Computer Aided Verification</title>
		<meeting>5th Int. Conf. on Computer Aided Verification</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">697</biblScope>
			<biblScope unit="page" from="383" to="396" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">Y</forename></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Harrington</surname></persName>
		</author>
		<title level="m">Proc. of 14th Annual ACM Symp. on Theory of Computing</title>
		<meeting>of 14th Annual ACM Symp. on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="60" to="65" />
		</imprint>
	</monogr>
	<note>Trees, automata, and games</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">On polynomial-size programs winning finitesrare games</title>
		<author>
			<persName><forename type="first">H</forename><surname>Lescow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th Int. Conf. on Computer Aided Verification</title>
		<meeting>7th Int. Conf. on Computer Aided Verification</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">939</biblScope>
			<biblScope unit="page" from="239" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Progress measures, immediate determinacy, and a subset construction for tree automata</title>
		<author>
			<persName><forename type="first">N</forename><surname>Klarlund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 7th Annual IEEE Symp. on Logic in Computer Science</title>
		<meeting>of 7th Annual IEEE Symp. on Logic in Computer Science</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="382" to="393" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">On the synthesis of discrete controllers for timed systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Maler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><surname>Sifakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 12th Annual Symp. on Theoretical Aspects of Computer Science</title>
		<meeting>of 12th Annual Symp. on Theoretical Aspects of Computer Science</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">900</biblScope>
			<biblScope unit="page" from="229" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Infinite games played on finite graphs</title>
		<author>
			<persName><forename type="first">R</forename><surname>Mcnaughton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ann. Pure Appl. Logic</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="page" from="149" to="184" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">MC-Naughton games and extracting strategies for concurrent programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Nerode</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Remmel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yakhnis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ann. Pure Appl. Logic</title>
		<imprint>
			<biblScope unit="volume">78</biblScope>
			<biblScope unit="page" from="203" to="242" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">On the synthesis of a reactive module</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 16th Annual ACM Symp. on Principles of Programming Languages</title>
		<meeting>16th Annual ACM Symp. on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="179" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Modal and temporal logics for processes</title>
		<author>
			<persName><forename type="first">C</forename><surname>Stirling</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>to appear in LNCS</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Automata on Infinite Objects</title>
		<author>
			<persName><forename type="first">W</forename><surname>Thomas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Handbook of Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Van Leeuwen Ed</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">B</biblScope>
			<biblScope unit="page" from="133" to="192" />
			<date type="published" when="1990">1990</date>
			<publisher>Elsevier</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">On the synthesis of strategies in infinite games</title>
		<author>
			<persName><forename type="first">W</forename><surname>Thomas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 12th Annual Symp. on Theoretical Aspects of Computer Science</title>
		<meeting>of 12th Annual Symp. on Theoretical Aspects of Computer Science</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">900</biblScope>
			<biblScope unit="page" from="1" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Completeness of Kozen&apos;s axiomatisation of the propositional mu-calculus</title>
		<author>
			<persName><forename type="first">I</forename><surname>Walukiewicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 10th Annual IEEE Symp. on Logic in Computer Science</title>
		<meeting>of 10th Annual IEEE Symp. on Logic in Computer Science</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="14" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Pushdown processes: games and model checking</title>
		<author>
			<persName><forename type="first">I</forename><surname>Walukiewicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 8th Int. Conf. on Computer Aided Verification</title>
		<meeting>8th Int. Conf. on Computer Aided Verification</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1102</biblScope>
			<biblScope unit="page" from="62" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Infinite games on finitely coloured graphs with applications to automata on infinite trees</title>
		<author>
			<persName><forename type="first">W</forename><surname>Zielonka</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
		<respStmt>
			<orgName>Universitk Bordeaux I</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>to appear in TCS</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
