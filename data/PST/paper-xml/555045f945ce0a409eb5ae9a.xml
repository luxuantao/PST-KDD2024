<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">S3: A Symbolic String Solver for Vulnerability Detection in Web Applications</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Minh-Thai</forename><surname>Trinh</surname></persName>
							<email>trinhmt@comp.nus.edu.sg</email>
							<affiliation key="aff0">
								<orgName type="institution">National University of Singapore</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Joxan</forename><surname>Jaffar</surname></persName>
							<affiliation key="aff1">
								<address>
									<addrLine>November 3-7</addrLine>
									<postCode>2014</postCode>
									<settlement>Scottsdale</settlement>
									<region>Arizona</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">S3: A Symbolic String Solver for Vulnerability Detection in Web Applications</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">90E2E6391344B8FAD3053731E3B29F52</idno>
					<idno type="DOI">10.1145/2660267.2660372</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T02:56+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.4.6 [Security and Protection]: Verification</term>
					<term>D.2.5 [Software Engineering]: Testing and Debugging Security, Reliability, Verification String Analysis</term>
					<term>String Constraint Solver</term>
					<term>Web Applications</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Motivated by the vulnerability analysis of web programs which work on string inputs, we present S3, a new symbolic string solver. Our solver employs a new algorithm for a constraint language that is expressive enough for widespread applicability. Specifically, our language covers all the main string operations, such as those in JavaScript. The algorithm first makes use of a symbolic representation so that membership in a set defined by a regular expression can be encoded as string equations. Secondly, there is a constraintbased generation of instances from these symbolic expressions so that the total number of instances can be limited. We evaluate S3 on a well-known set of practical benchmarks, demonstrating both its robustness (more definitive answers) and its efficiency (about 20 times faster) against the state-of-the-art.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Web applications nowadays provide critical services over the Internet and frequently handle sensitive data. Unfortunately, the development is error prone, resulting in applications that are vulnerable to attacks by malicious users. The global accessibility of critical web applications make this an extremely serious problem.</p><p>According to the Open Web Application Security Project, or OWASP for short <ref type="bibr" target="#b26">[26]</ref>, the most serious web application vulnerabilities include: (#1) Injection flaws (such as SQL injection) and (#3) Cross Site Scripting (XSS) flaws. These two vulnerabilities occur mainly due to inadequate sanitization and inappropriate use of input strings provided by users.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>How Important is Symbolic String Solving?</head><p>To explain why we need string solving, let us look at dynamic analysis which involves testing an application as a closed entity with a set of concrete inputs. Its main disadvantage is of course that it is not a complete method. For example, some program paths may only be executed if certain inputs are passed as parameters to the application, but it is very unlikely that a dynamic analyzer can exhaustively test an application with all possible inputs. For web applications, the problem is even more severe since dynamic analysis needs to take into account not only the value space (i.e., how the execution of control flow paths depends on input values), but also an application's event space (i.e., the possible sequences of userinterface actions). As a result, there is in general an impractical number of execution paths to systematically explore, leading to the "low code coverage" issue of dynamic analysis.</p><p>A standard approach to have good or complete coverage is static analysis. However, the problem here is the existence of false positives, arising from an over-approximation of the program's behavior. Recent works to avoid false positives, but still preserve high code coverage, are based on dynamic symbolic execution (DSE). Some examples are <ref type="bibr" target="#b28">[28,</ref><ref type="bibr" target="#b4">4,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b23">23,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b30">30,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b16">16,</ref><ref type="bibr" target="#b17">17,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b29">29,</ref><ref type="bibr">9,</ref><ref type="bibr" target="#b8">8,</ref><ref type="bibr" target="#b24">24,</ref><ref type="bibr" target="#b35">35,</ref><ref type="bibr" target="#b21">21]</ref>. These approaches employ both concrete and symbolic execution to automatically and systematically generate tests in order to expose vulnerabilities in web applications. DSE for automated test generation involves instrumenting and concolically running a program while collecting path constraints on the inputs. Then it attempts to derive new inputs -using an SMT (Satisfiability Modulo Theories) solver -with the hope to steer next executions toward new program paths. For vulnerability detection, DSE combines the derived path constraints with the specifications for attacks, often given by the security experts, to create queries for the SMT solver.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dynamic Analysis</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DSE Code Coverage</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Potentially Low High</head><p>False Positives</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Low Low</head><p>Executable Paths (EPs)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Unlikely to cover all EPs</head><p>Likely to cover all EPs Table <ref type="table">1</ref>: DSE as a More Effective Paradigm</p><p>In fact, there is a strong connection between an effective vulnerability detection framework and symbolic string solving. As shown in Table <ref type="table">1</ref>, DSE achieves higher code coverage. However, because not all path executed by DSE are guaranteed to be executable, to avoid false positives we must be able to decide if a (symbolic) path constraint is satisfiable or not. Thus a powerful SMT solver, capable of handling symbolic string variables, is the key to achieve efficient analyses with high code coverage and low false positives.  To illustrate more clearly how constraint solvers can be helpful in securing web applications, in Fig. <ref type="figure" target="#fig_0">1</ref>, we present a JavaScript function which is used to validate input email addresses. The user fills the client-side form, by providing an email address to the HTML input element with name "email" (and a password, removed for simplicity). When the Login button is clicked, the browser invokes the JavaScript validating function validateEmail, which is assigned to the submit event of the form. This function first fetches the email address supplied by the user from the corresponding form field and then checks if the email address is valid. Each student of our department has two email accounts, one from NUS (nus.edu.sg), the other from SoC (comp.nus.edu.sg). The web page hence accepts both of these two domains. However, these two types of accounts have different formats. While the local part of the former is constructed by one alphabetic characters, followed by seven numeric ones, the latter's simply requires at least four characters.</p><p>The question is whether this web page is vulnerable to an XSS attack, or to an SQL injection. More specifically, can the following PHP code, with an appropriate instantiation for string variable $eml, be executed on the server side, leading to an attack:</p><formula xml:id="formula_0">$eml = $_POST['email']; $pwd = $_POST['password'];</formula><p>$stm="SELECT ... where email='$eml' and password='$pwd'"; $result = mysql_query($stm);</p><p>The answer is yes for both of the questions. Now, let us explain the way DSE detects possible vulnerabilities, in comparison with typical dynamic analyses. Since a dynamic analysis is essentially black-box testing, it has no knowledge about the JavaScript code. Thus, it is possible that the dynamic analyzer does not test with email addresses whose domain is comp.nus.edu.sg, and subsequently, cannot detect SQL injection and XSS vulnerabilities. In contrast, DSE, which can be seen as white-box testing, enables us to attempt all execution paths by generating three path constraints, corresponding to the three program paths of the validateEmail function.</p><p>After symbolically executing the program, DSE frameworks such as <ref type="bibr" target="#b28">[28]</ref> will combine its results with the specifications for attacks, given by the security experts, to create queries for the constraint solver. The specifications, often come in form of assertions, are some (regular) grammars encoding a set of strings that would constitute an attack against a particular sink. If the constraint solver finds a solution to a query, then this represents an attack that can reach the critical sink and exploit a code injection vulnerability. For example, with the specification to assert if the input email address contains ' OR 1=1--, we can in fact generate the input that leads to an SQL injection. Similarly, a specification for an XSS attack &lt;script&gt;alert('Test')&lt;/script&gt; would help us to generate the input email address &lt;script&gt;alert('Test')&lt;/script&gt;@comp.nus.edu.sg that can be exploited by attackers.</p><p>In summary for this subsection, DSE, presently the state-of-theart in vulnerability detection, is intimately tied to being able to provide definitive answers for the derived constraint queries. In the case of JavaScript and web applications, since the constraints often concern string variables, symbolic string solving is thus the key to detect vulnerabilities in this class of applications. As the encountered string constraints may be in an undecidable class, it is important to have a solver which returns a definitive answer often and in a timely manner.</p><p>We next describe the main contribution of this paper, a new constraint solver S3, which stands for Symbolic String Solver. Our solver makes use of Z3 <ref type="bibr" target="#b11">[11]</ref>, in order to leverage the recent advances in modern SMT solvers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>What Language Do We Need?</head><p>We first argue that a pure string language does not suffice to analyze web applications. This is due to the fact that non-string operations (e.g., boolean, arithmetic constraints) are also widely used in web applications. Moreover, their use is often intertwined with string operations, such as in the case of string length -a string-to-integer constraint. Reasoning about strings and non-strings simultaneously is thus necessary. In other words, we need to deal with a multisorted theory which includes, at least, strings and integers.</p><p>To amplify this point, let us now state some statistics from a comprehensive study of practical JavaScript applications <ref type="bibr" target="#b28">[28]</ref>. Constraints arising from the applications have an average (per benchmark query) of 63 JavaScript string operations, while the remaining are boolean, logical and arithmetic constraints. The largest fraction are for operations like indexOf, length (78%). A significant fraction of the operations, including substring (5%), replace (8%), and split, match (1%). Of the match, split and replace operations, 31% are based on regular expressions. Operations such as replace and split give rise to new strings from the original ones, thereby giving rise to constraints involving multiple string variables.</p><p>To summarize, constraints of interest are either non-strings (e.g., bool-sort, int-sort and particularly length constraints) or strings such as: string equations, membership predicates and high-level string operations, which are over multiple string variables. It is folklore that query with just basic string equations along with length constraints on the string variables is extremely hard to solve (its decidability is open). Therefore, the validation of any approach can only realistically be done empirically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S3: A Robust and Incremental String Solver</head><p>Although there exist solvers that can reason about both string and non-string constraints (e.g., <ref type="bibr" target="#b28">[28,</ref><ref type="bibr" target="#b6">6,</ref><ref type="bibr" target="#b27">27,</ref><ref type="bibr" target="#b39">39]</ref>), they depend on strings being bounded in length. Unbounded regular expressions, which can be constructed using Kleene star operation, are not supported Thus the supported high-level operations are only in bounded forms. For example, instead of fully supporting replace function, which could mean replacement of all occurrences. existing tools support an operation to replace a fixed number of occurrences in a string.</p><p>It may be argued that certain bounds suffice for a class of applications. There is a more important reason why the bound dependency is bad: the algorithms that rely on the bounded reasoning are highly combinatorial in approach. In other words, the problem at hand is broken down into cases, the number of which is often a large combinatorial combination arising from some given bounds.</p><p>Finally, we mention <ref type="bibr" target="#b1">[1]</ref>, where there is a real requirement for reasoning about unbounded strings. In verifying client-side input validation functions, a bounded string solver can only find policy violations but it cannot prove the conformance to a given policy. There are certainly some solvers <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b36">36,</ref><ref type="bibr" target="#b37">37]</ref> that can reason about unbounded strings. However, their key weakness is that they cannot handle non-string constraints, particularly length constraints. As shown in the statistics above, missing length constraints (whose appearance is frequent) will lead to many false positives. This clearly is not acceptable.</p><p>With regard to all the arguments above, we now conclude this Section with three important features of S3.</p><p>First, S3 is expressive (Section 2). Specifically, it is the first to handle unbounded regular expressions in the presence of length constraints, and express precisely high-level string operations, which ultimately enables a more accurate string analysis.</p><p>Second, S3 is robust. This means that S3 is able to provide definitive answers to a new level, far beyond the state-of-the-art. This in turn means we can detect more vulnerabilities and more bugs. We demonstrate in Section 6 with two case studies:</p><p>• The first compares with Kaluza -the core of Kudzu <ref type="bibr" target="#b28">[28]</ref> -a JavaScript symbolic execution framework. We show that S3 is several times faster, and helps detect many more paths that reach the critical sink, that is, paths that are vulnerable.</p><p>• The second compares with Z3-str <ref type="bibr" target="#b39">[39]</ref>. We show S3 reasons about length constraints much more effectively than Z3-str. This leads to a large increase in applicability to web programs, because these kind of constraints are widely used.</p><p>Third, S3 is efficient, and one key reason is that it is incremental. Our algorithm for string theory is designed in an incremental fashion driven by the try-and-backtrack procedure of the Z3 core (Section 4), so that given a set of input constraints, we perform incremental reduction for string variables until the variables are bounded with constant strings/characters. Another technical challenge is how to reason, effectively and efficiently, about the Kleene star and high-level operations such as replace (in its most general usage), of which the semantics are by nature recursively defined. Section 5 introduces the gist of our proposal, the encodings using recursively-defined functions, on which we can incrementally reason: by lazily unfolding them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">OUR CONSTRAINT LANGUAGE</head><p>We introduce the constraint language of our solver in Fig. <ref type="figure" target="#fig_1">2</ref>. For simplicity, we only list three primitive types: int, bool and string 1 . The input formula can be of the following forms: 1 Z3 supports more primitive types <ref type="bibr" target="#b11">[11]</ref>. • a comparison operation between two integer or boolean expressions;</p><p>• an equation between two string expressions. S3 also supports other common string operations. We list here only important ones;</p><p>• a membership predicate between a string expression and a regular expression, where an expression can either be a string constant, a variable or their concatenation<ref type="foot" target="#foot_0">2</ref> , and regular expressions are constructed from string constants using concatenation (•), union (+) and Kleene star ( );</p><p>• a composite formula constructed using negation and binary connectives, including ∧, ∨, ⇒.</p><p>Z3-str <ref type="bibr" target="#b39">[39]</ref> and Kaluza <ref type="bibr" target="#b28">[28]</ref> are important existing solvers that can support both string and non-string operations, especially the length constraint. Compared to the constraint syntax of Z3-str, ours can be viewed as an extension with regular expressions, membership predicates, and high-level string operations that often work on regular expressions such as search, replaceAll<ref type="foot" target="#foot_1">3</ref> , match, split, test, exec. Our constraint language is also slightly more expressive than Kaluza's since we handle above string operations in its original semantics -unbounded.  In addition, we note that our constraint language, which is necessary to reason about high-level string operations in scripting languages, is beyond the class of context free languages. To illustrate, let us look at the following constraints, in which x can be of any string in the context-sensitive language { a n</p><formula xml:id="formula_1">(t1 &amp;&amp; t2 &amp;&amp; t3) } p1 ∈ ("ab") ∧ p2 ∈ ("bc") ∧ length(p2) &gt; 0 ∧ res = p1 • p2 ∧ nM = "ababababababcc" ∧ res = nM p1 = star("ab",n1) ∧ p2 = star("bc",n2) ∧ length(p2) &gt; 0 ∧ res = p1 • p2 ∧ nM = "ababababababcc" ∧ res = nM</formula><formula xml:id="formula_2">•b n •c n | n≥0 }: x = y • z • t ∧ y ∈ a ∧ z ∈ b ∧ t ∈ c ∧ length(y)=length(z) ∧ length(z)=length(t)</formula><p>Therefore, existing solvers, which only approximate strings using context free grammars, are not able to reason about the constraints addressed by this paper.</p><p>Finally, though it is not shown in Fig. <ref type="figure" target="#fig_1">2</ref>, S3 is able to accommodate most regular expression features in JavaScript via a preprocessing step as done in Kudzu <ref type="bibr" target="#b28">[28]</ref>. Examples are (possibly negated) character classes, escaped sequences, repetition operators ({n}/?/ /+/) and sub-match extraction using capturing parentheses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">MOTIVATING EXAMPLES</head><p>In this Section, we present two simplified examples to position our work against the state-of-the-art.</p><p>In Fig. <ref type="figure" target="#fig_2">3</ref> we start with an example of a regular-expression-based input validation function. The first column is the JavaScript function used to validate the two input fields, namely p1 and p2. This function ensures that p2 is not an empty string and p1 and p2 must belong to the regular expressions re1 and re2, respectively. Now we want to prove that, given the inputs which have passed the validation function, the output res, that is constructed by concatenating p1 with p2, is different from a specified bad string nM = "ababababababcc". Ultimately, the above question is reduced to the problem of deciding the satisfiability of the generated constraint formula, presented in the second column of Fig. <ref type="figure" target="#fig_2">3</ref>. The proof succeeds if the formula is unsatisfiable <ref type="foot" target="#foot_2">4</ref> .</p><p>This requires reasoning about string equation res=p1•p2, membership predicates p1 ∈ ("ab") and p2 ∈ ("bc") , and length constraint length(p2) &gt; 0. In short, it becomes a complicated problem involving strings, non-strings and their combinations (e.g., length constraints). Now, let us discuss how existing solvers would deal with this particular problem.</p><p>HAMPI <ref type="bibr" target="#b22">[22]</ref>, and other solvers <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b31">31,</ref><ref type="bibr" target="#b20">20,</ref><ref type="bibr" target="#b34">34,</ref><ref type="bibr" target="#b2">2,</ref><ref type="bibr" target="#b38">38,</ref><ref type="bibr" target="#b19">19,</ref><ref type="bibr" target="#b32">32,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b18">18]</ref>, which work in the string domain only, cannot handle this example. Since they only support string operations, they are not able to handle non-string constraints, and particularly length constraints that are related to both string and non-string domain and cannot be captured in each individual one.</p><p>On the other hand, the solvers Kaluza <ref type="bibr" target="#b28">[28]</ref>, <ref type="bibr" target="#b6">[6]</ref> and Z3-str <ref type="bibr" target="#b39">[39]</ref> are in the same category as ours, and can reason about strings and non-strings simultaneously. Since <ref type="bibr" target="#b6">[6]</ref> is similar to Kaluza in many ways, we will just focus on Kaluza here. Kaluza is the string solver used in a JavaScript dynamic test generation framework <ref type="bibr" target="#b28">[28]</ref>. To support a wider range of constraint types including integer, boolean and string, it extends both STP <ref type="bibr" target="#b22">[22]</ref> and HAMPI.</p><p>One major drawback of Kaluza is that it requires the lengths of string variables to be known prior to being able to encode them and query the underlying SMT solvers. In particular, before solving for string constraints, Kaluza finds a set of satisfying solutions for each string length. For each possible length, it encodes each string variable as an array of bits and then queries a bit-vector solver. Kaluza is unable to reuse the encodings and the result of bit-vector solver in previous calls, which induces the overall high cost of repetitive encoding and querying external solvers.</p><p>For the example at hand in Fig. <ref type="figure" target="#fig_2">3</ref>, Kaluza first needs to come up with a set of satisfying solutions for the lengths of p1 and p2, each denoted by a pair l1; l2 , where l1 is the length of p1 and l2 is the length of p2. In this case, the set of satisfying solutions for the lengths is { 0; 12 , 2; 10 , 4; 8 , 6; 6 , 8; 4 , 10; 2 }. For each possible length solution, Kaluza encodes the string variables, and then queries the external bit-vector solver, before finding out that the original set of constraints is unsatisfiable. Overall, Kaluza needs to encode and query bit-vector solver 6 times.</p><p>Let us not have the impression that, in general, the number of satisfying solutions for the string lengths should be of this linear complexity. In fact, practical applications involve many string variables, Kaluza approach, i.e., generate-and-test, would easily suffer from a combinatorial explosion.</p><p>Z3-str <ref type="bibr" target="#b39">[39]</ref> cannot handle regular expressions, thus also cannot handle this example. However, it can be considered the first SMTbased string solver. Instead of relying on other theories, it builds a string theory for itself and allows this string theory to be plugged into a modern and powerful solver -Z3 <ref type="bibr" target="#b11">[11]</ref>. Thus an important contribution of Z3-str is that string and non-string constraints are now solved simultaneously, in an incremental manner.</p><p>Inspired by Z3-str's design, our target is to build a string theory that can interact with other theories via Z3. Nevertheless, we want to support a powerful input language, which is especially demanded for testing and analysis of practical web applications.</p><p>There are two key technical challenges: (1) how to incrementally handle the Kleene star, which is the heart of the issue in reasoning about regular expressions; (2) how to incrementally handle highlevel string operation such as replace, whose semantics is most naturally defined by recursive rules. Our solution therefore is to employ, in our string theory, recursively defined functions whose semantics will be lazily unfolded during the process of incremental solving. Such approach resembles the constrain-and-generate technique (to contrast with generate-and-test) in the literature of constraint solving.</p><p>We elaborate later with a technical description in Section 5. But now let us give some intuitions on how we approach this example. Internally, we represent membership of regular expression as equation involving a symbolic representation of the Kleene star. In particular, p1∈("ab") is represented as p1=star("ab",n1) and similarly p2∈("bc") is represented as p2=star("bc",n2). By rewriting, we would derive the following equation: star("ab",n1) • star("bc",n2) = "ababababababcc" Since the length of p2 is positive and the RHS is a constant string, this would force the unfolding of expression star("bc",n2) to star("bc",n2-1) • "bc". A conflict is then derived since the LHS string ends with "bc" while the RHS string ends with "cc". Our system then can conclude that the input formula is UNSAT. Now let us dissect Z3-str more carefully. Fig. <ref type="figure" target="#fig_3">4</ref> presents an input example for Z3-str, a pattern which is commonly found in many benchmarks extracted from <ref type="bibr" target="#b28">[28]</ref>'s comprehensive set of JavaScript applications (e.g. big2). Starting with the fact that z2 is a constant string of one character, Z3-str is able to deduce that z2 is of length 1. This constraint will be fed into the arithmetic theory. Similarly, the arithmetic theory would receive the information that y's length is the sum of z1's length and z2's length. Since, from the input, the length of x1 equals to the length of z1 plus 1, the arithmetic theory can deduce that x1 and y are of the same length. However, this information will never be passed back to the string theory.</p><formula xml:id="formula_3">x = x 1 • x 2 ∧ z = y • z 3 ∧ y = z 1 • z 2 ∧ z 2 = "_" ∧ l 1 = length(x 1 ) ∧ l 2 = length(z 1 ) ∧ l 1 = l 2 + 1 ∧ x = z ∧ indexOf (y, "a") = 3 ∧ indexOf (x1, "a") = 4</formula><p>As discussed in <ref type="bibr" target="#b39">[39]</ref>, the current design of Z3 enforces that the plug-in theory, namely Z3-str, to be disjoint from Z3's arithmetic theory. Being a plug-in, however, means there is supervisory control over Z3-str which can feed length information to the arithmetic theory so that early conflicts can be detected and exploited. But, importantly, partial information derived by the arithmetic theory will not be fed back to Z3-str. This is the source of Z3-str's inefficiency in many cases.</p><p>Returning to the example, if the information that x1 and y are of the same length is propagated back to the string theory, together with the fact that x1 and y are prefixes of the two equal strings x and z, our string theory can derive that x1 and y are equal, therefore proceed the search much more efficiently. In Section 4.2, we discuss our new design in order to overcome this drawback, therefore even when restricted to the same input language as of Z3-str, our tool, S3, does advance the concept of incremental solving to the next level.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">DESIGN OF S3</head><p>Here we present the design of S3. This design is inspired by Z3-str <ref type="bibr" target="#b39">[39]</ref>, and thus inherits its two main advantages. First, we support the primitive type of string so that there is no need to convert strings to other representations, e.g., bit-vectors. As a result, we can support string variables whose lengths can be unknown, especially in the context of static analysis. Second, we leverage the power of Z3 in dealing with multiple theories, and this ultimately leads to the capability of reasoning on string and non-string constraints simultaneously and efficiently. We first give an overview of Z3-str, focusing on how it interacts with the core of Z3. Later we describe our design of S3, along with the improvement of the corresponding component Z3-str-star over Z3-str.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Overview of Z3-str</head><p>Z3-str acts as a plug-in string theory for a SMT solver Z3 <ref type="bibr" target="#b11">[11]</ref>. The architecture of Z3 is shown in the shaded box of Fig. <ref type="figure" target="#fig_4">5</ref>. Its</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Constraints</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S3</head><p>Regex Reduction</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Z3</head><p>SAT and a possible model UNSAT assert ((e1 ∨ e2) ∧ e3 ∧ e4) e1 : x = "abc" • m e2 : x = "ef gh" e3 : y = "ef g" • n e4 : x = y Consider the assertion above. The core component cannot interpret the string operations; instead it treats them as four independent boolean variables (e1, e2, e3 and e4) and tries to assign boolean values to them. We now walk through the process of how Z3's core component and the string theory solver interact.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fact added Eq-class</head><p>Reduction/Action 1 y="ef g"•n {y,"ef g"•n} 2 x=y {x,y} {y,"ef g"•n}</p><formula xml:id="formula_4">• conflict detected 3 x="abc"•m {x,"abc"•m, y,"ef g"•n}</formula><p>• backtrack and remove facts</p><p>• try another option for e1 4 x="ef gh" {x,"ef gh", y,"ef g"•n} "ef gh"="ef g"•n ⇒ n="h" SAT solution: x = "ef gh", y = "ef gh", n = "h" In Table <ref type="table" target="#tab_2">2</ref>, initially there is no fact. The core starts by setting e3 and e4 to true and reaches step 3. Without loss of generality, assume the core component first tries true for e1. Beware that the core can detect functionally equivalent terms, based on the theory of uninterpreted functions. Hence, it puts {x, y, "abc" • m, "ef g" • n} into one equivalence class and notifies the string theory plug-in. We note that the plug-in string theory Z3-str can only know about the equivalent terms that belong to its theory.</p><p>As a side remark, if we have an equation length(x) = 4, then Z3-str is not aware of the fact that length(x) is equal to 4. However, if e2 were set to true, Z3-str would know that x is equivalent to a constant string of length 4. Therefore, it can deduce that length(x) is equal to 4, thus subsequently passing this information to the arithmetic theory.</p><p>Back to the example, with the above equivalence class at step 3, Z3-str detects a conflict and then informs the core component about the new finding through an axiom e3 ∧ e4 → ¬e1. With this new axiom, the core component backtracks and tries false for e1. When the core component backtracks, it discards the relevant fact and any insertions into equivalence classes as the consequence of the fact. The core then derives that e2 must be true and this assignment is performed in step 4.</p><p>Based on the concatenation semantics, Z3-str can infer that n must be "h". This new finding is formulated by introducing a new boolean variable e5 representing n = "h" and an axiom "ef gh" = "ef g" • n ⇒ e5, which is sent back to the core. From the existing facts and the new axiom, the core component derives e5 is true. After all boolean expressions have been assigned consistently and Z3-str can find the satisfying values for string variables x, y, and n, the search procedure terminates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Improvement of Z3-str-over Z3-str</head><p>Z3-str-star (or Z3-str-for short), a component of our tool, is responsible for solving equations between string expression and recursively-defined functions. It can be viewed as a significant extension of Z3-str with the support of recursively-defined functions, introduced to facilitate representing and reasoning about the Kleene star and commonly used high-level string operations.</p><p>As mentioned before, in its current implementation, Z3-str does not know about equivalent terms that belong to other theories, especially the arithmetic theory. Another important improvement of Z3-str-(over Z3-str) is its direct interactions with the Z3 core, to query about the equivalence classes among multiple theories. More specifically, it asks Z3 core two following questions:</p><p>• Is a string length "ground" with a non-negative constant?</p><p>• What is the relationship (=, &lt;, &gt;, ≤, ≥) between different length variables?</p><p>To answer these questions, we extend Z3 API so that Z3-str-can interact with the congruence closure core, similarly to other built-in theory solvers. Moreover, the newly introduced API methods also help us to query about other inequality relationship, if necessary. Answers to these questions ultimately allow us to propagate the information of string lengths to string theory solver so that string and non-string constraints can be simultaneously reasoned about. In short, this gives us a truly incremental solver for strings and nonstrings. We will revisit this side contribution in our experimental evaluation -Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">ALGORITHM</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Top-level Algorithm</head><p>S3 finds a list of string assignments that satisfies the input formula or decides that no satisfying assignment exists. Algorithm 1 summarizes its top level algorithm.</p><p>Input: F : Formula Output: (IsSat : bool, Solutions : (variable, string) list) reduced_F ← reduce(F); Given an input formula F, S3 recursively reduces F into new formula reduced_F, which may contain equations (among string expressions and recursive functions such as star) and length constraints. Here we only take into consideration the string and length constraints, non-string constraints will be unchanged unless otherwise stated. Reduction rules may result in a disjunctive formula. Thus, the next step is to normalize reduced_F into disjunctive normal form (DNF). To decide the satisfiability of each disjunct, we extend Z3-str <ref type="bibr" target="#b39">[39]</ref> to support recursive functions. In particular, we use the recursive function star to represent the Kleene star. For presentation purpose, we first only discuss how to handle the star function, calling our extended component Z3-str-. Similar treatment for high-level operations such as replaceAll will be elaborated later. If Z3-str-finds a satisfiable disjunct, it stops and returns the corresponding satisfying assignments. Otherwise, it decides that no such assignment exists.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Reduction of Regular Expressions</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Rule Reduction</head><p>[CONST]</p><p>e ∈ s → e=s</p><formula xml:id="formula_5">[UNION] e ∈ r1+r2 → e ∈ r1 ∨ e ∈ r2 [CONCAT] e ∈ r1•r2 → e=e1•e2 ∧ 2 i=1 ei ∈ ri [STAR]</formula><p>e ∈ r → e ∨ = star(r, n)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 3: Reduction Rules</head><p>Given an input constraint formula, we first reduce membership predicates into equations among string expressions and star function. The reduction rules are summarized in Table <ref type="table">3</ref>. Our aim is to obtain a list of new constraints of the form that can be solved incrementally by Z3-str--equations among string expressions and recursively-defined functions, along with length constraints.</p><p>These rules deal with constraints checking if a string expression e (LHS) is in a regular expression (RHS). If the RHS is merely a string constant, rule [CONST] will convert such membership constraint into an equality. The next two rules handle the case when the RHS is constructed by union and concatenation operations. While rule <ref type="bibr">[UNION]</ref> ensures that the LHS expression e is a member of one of the RHS sub-expressions (of the union), rule [CONCAT] splits e into two fresh string variables, namely e1 and e2, and checks that they satisfy the condition e1 ∈ r1 ∧ e2 ∈ r2 conjunctively.</p><p>The RHS regular expression can also be formed by repeating r zero or more times (Kleene star). Rule [STAR] encodes such constraint as an equation, where the LHS is a string expression and the RHS is a symbolic representation for a family of strings generated by the Kleene star. The fresh (symbolic) integer variable n indicates the frequency where r is repeated. This symbolic variable is used to:</p><p>• Distinguish different star functions, which have the same base regular expression (e.g. r).</p><p>• Guide the on-demand unfolding in the recursively-defined functions such as star or replaceAll (that will be discussed later).</p><p>• Interact with the Arithmetic Solver module in Z3.</p><p>When r is a constant string and n is a concrete value, the ∨ = operator is interpreted as equality operator =. For convenience, we overload ∨ = with the = notation.</p><p>In short, after the reduction for regular expressions, we have equations among string expressions and recursively-defined star functions, along with length constraints. Z3-str-is then responsible for solving them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">star Functions</head><p>Z3-str-extends Z3-str <ref type="bibr" target="#b39">[39]</ref> with the support for handling star functions. The internal language is extended with the following:</p><formula xml:id="formula_6">Term:str ::= ConstString | ... |</formula><p>star(Term:regexpr, Term:int)</p><p>Like Z3-str, Z3-str-also works as a plug-in of Z3. It is notified by the Z3 core component when a string equation is asserted as part of the try-and-backtrack process. In particular, the core component invokes a callback function in the plug-in, providing the abstract syntax tree (AST ) of the equation as an input parameter. The callback function inspects the AST , and if it involves string operations, the function tries to reduce AST to a simpler abstract syntax tree, say AST . The reduction is conveyed to the core component by adding an axiom with the form of AST ⇒ . Recall that since the core component does not understand the string domain, it treats both AST and AST as independent boolean variables. Because AST has been assigned a true value, with the new axiom, the core will assign true to AST as well, which is a new fact, and in turn triggers further plug-in processing. Thus, to act as a plug-in, we need to provide reduction rules for each callback from Z3.</p><p>We list selected reduction rules in Table <ref type="table">4</ref>. There are 3 cases of interest related to star functions:</p><p>• when star appears in one side of an equation,</p><p>• when star appears in both side of an equation and</p><p>• when star can be used to concretize other concatenations based on its concrete string value.</p><p>The gist of our reduction rules is to make use of the semantics of star functions (or their previous forms -regular expressions with Kleene star). In fact, with a membership constraint such as x ∈ ("ab") , we can directly make use Z3-str to generate the possible string assignments for x, then checking membership is straightforward since x is already ground. However, this naive approach is likely to be inefficient. Sometimes, it may be worse than Kaluza's approach, where the lengths are used to refine the string constraints.</p><p>To deal with star functions effectively and efficiently, we propose to reduce it lazily and only on demand. We call that technique "unfold and consume". The basic principle is to lazily unfold its semantics, until we find a matching between constant string segments in the two sides of an equation. At that time, we can easily to choose either consume these constants (of course with the capability of backtracking), or to find a conflict between unmatchable constants in the two sides.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Incremental Solving for star Functions</head><p>In Table <ref type="table">4</ref> we introduce four auxiliary functions: csm_hd(s, r), csm_tl(s, r), r csm_hd(r2, r1), and csm_all(s, r). The first one takes a constant string and a regular expression, and returns a list of strings si such that: s ∈ r•si. Intuitively, this function aims to consume the prefix of s matching r. Similarly, while the second, csm_tl(s, r), consumes the suffix of s matching r, the third one applies to two regular expressions instead. Lastly, csm_all(s, r) checks if s can be consumed completely by matching it with r.</p><p>Now, let us have a look at reductions rules in Table <ref type="table">4</ref>. The rule [CON-] says about the case when star(r, n) equals to some constant string s. As we explained above, method csm_all(s, r) is used to decide whether s can be a member of r . If yes, we can update other string expressions that contain star(r, n). Otherwise, it is a conflict and Z3 core component will need to backtrack. Note that, in Table <ref type="table">4</ref>, all E1, E2 and E3 are concatenations among string expressions and star functions.</p><p>The rules [HT-] and [HD-] are to handle the case when there is a matching between star and a constant string. In the latter, the matching is at the beginning of the LHS; while the former is a special case of it, where the matchings occur at both ends. These two rules will be elaborated more in the next example. Similarly, we have the rule [TL-] for the matching at the end of the LHS.</p><p>The rule [HD--] ([TL--], [HT--]) is applied when there are two star function at the beginning (end or both) of each side of the equation. In the rule [HD--], we assume that r1 cannot be consumed by r2 so that we only need the auxiliary function r csm_hd(r2, r1).</p><p>The last rule [REP-] aims to replace all string variables by their aliases, which are a concatenation among constant strings and star functions.</p><p>To illustrate how these rules are applied, in Table <ref type="table">5</ref>, we present running steps for solving the example in Fig. <ref type="figure" target="#fig_2">3</ref>. Z3 core continually sends the assignments to our Z3-str-(via its call back function) from step 1 to step 5. At the same time, Z3 also maintains functionally equivalent terms in their equivalence classes. From step 1 to step 4, we apply the rule [REP-] repetitively to replace a string variable by a constant string, a star function or their concatenation (shown in column 4, step 1-4). In step 5, we apply a specialized version of rule [HT-], where we also make use of constraints on variable n1 and n2. More specifically, for this running example, we are able to force the unfolding of star("bc",n2) so that we can find a conflict between "bc" and "cc". Finally, we give back the new axiom (in column 4, step 5) to Z3 so that Z3 can conclude the input formula is UNSAT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">String Operations</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Operations Reduction Rules</head><p>I=search(S, r)</p><formula xml:id="formula_7">(I&lt;0 ∧ ¬(S ∈ (. )•r•(. ))) ∨ (I≥0 ∧ S=U•M1•M2•R ∧ M1•M2 ∈ r ∧ length(U)=I ∧ length(M2)=1 ∧ ¬(U•M1 ∈ (. )•r•(. ))) R=replaceAll(S, r, T) I=search(S, r) ∧ ((I&lt;0 ∧ R=S) ∨ (I≥0 ∧ S=U•M•S1 ∧ R=U•T•R1 ∧ M ∈ r ∧ length(U)=I ∧ R1=replaceAll(S1, r, T)))</formula><p>Table <ref type="table">7</ref>: Reduction Rules for search and replaceAll</p><p>Typically, the semantics of string operations such as replaceAll, match, split, test, exec, are recursively defined. As such, it is natural for us to interpret them as recursively-defined functions, similarly to our handling of star functions. In this Subsection, we only Rule Reduction Condition star(r, n)=s ⇒ ¬star(r, n)=s ¬csm_all(s, r), s:</p><formula xml:id="formula_8">ConstString [CON-] star(r, n)=s∧ (E1•star(r, n)•E2=E3) ⇒ E1•s•E2=E3 csm_all(s, r), s: ConstString [HT-] star(r1, n1)•E1•star(r2, n2) =s1•E2•s2 ⇒ (E1=s1•E2•s2∧n1=0∧n2=0)∨ ( k i=1 star(r1, n1-1)•E1=si•E2•s2∧n2=0)∨ ( l j=1 E1•star(r2, n2-1)=s1•E2•sj∧n1=0)∨ k,l i,j star(r1, n1-1)•E1•star(r2, n2-1)=si•E2•sj [si]=csm_hd(s1, r1), [sj]=csm_tl(s2, r2) [HD-] star(r, n)•E1=s•E2 ⇒ (E1=s•E2∧n=0)∨ k i=1 star(r, n-1)•E1=si•E2 [si]=csm_hd(s, r) [TL-] E1•star(r, n)=E2•s ⇒ (E1=E2•s∧n=0)∨ k i=1 E1•star(r, n-1)=E2•si [si]=csm_tl(s, r) [HT--] star(r1, n1)•E1•star(r3, n3)= star(r2, n2)•E2•star(r4, n4) ⇒ (n2=0∧n4=0∧star(r1, n1)•E1•star(r3, n3)=E2)∨ (n2=0∧star(r1, n1)•E1•star(r3, n3)=E2•star(r4, n4))∨ (n4=0∧star(r1, n1)•E1•star(r3, n3)=star(r2, n2)•E2)∨ k,l i,j star(r1, n1-1)•E1•star(r3, n3-1)= si•star(r2, n2-1)•E2•star(r4, n4-1)•sj [si]= r csm_hd(r3, r1), [sj]= r csm_tl(r4, r2) [HD--] star(r1, n1)•E1= star(r2, n2)•E2 ⇒ (E1=E2∧n1=0∧n2=0)∨ (star(r1, n1)•E1=E2∧n2=0)∨ (E1=star(r2, n2)•E2∧n1=0)∨ k i=1 star(r1, n1-1)•E1=si•star(r2, n2-1)•E2 [si]= r csm_hd(r2, r1) [TL--] E1•star(r1, n1)= E2•star(r2, n2) ⇒ (E1=E2∧n1=0∧n2=0)∨ (E1•star(r1, n1)=E2∧n2=0)∨ (E1=E2•star(r2, n2)∧n1=0)∨ k i=1 E1•star(r1, n1-1)=E2•star(r2, n2-1)•si [si]= r csm_tl(r2, r1) [REP-] x=E∧ (E1•x•E2) ⇒ E1•E•E2</formula><p>E is a concatenation among constant strings and star functions Table <ref type="table">4</ref>: Selected Reduction Rules for star Functions give the details of reduction for replaceAll. Other operations can be treated in a similar manner.</p><p>As stated earlier, we aim to support the most general usage of replace function -replacing all occurrences. In practice, there is also another version (e.g. in PHP) which allows users to specify the maximum number of occurrences to be replaced. We call it replaceN, to distinguish the two versions. In fact, replaceN is already supported by existing solvers, e.g., Kaluza. The typical treatment is to model the input parameter as a concatenation of N parts, and then apply one replacement to each part. However, this technique cannot be generalized to address replaceAll, since we do not know such an N beforehand. Here we propose to model both re-placeAll and replaceN, again, using recursively-defined functions. In fact, restricting to replaceN alone, our approach will be more efficient than Kaluza's. This efficiency comes from the superiority of incremental solving (via constrain-and-generate approach) over generate-and-test approach.</p><p>Since replaceN is a special case of replaceAll, we focus on discussing only the latter. Table <ref type="table">7</ref> shows that R=replaceAll(S, r, T) belongs to one of two possible cases:</p><p>• the recursive case, when we find a substring M, that matches regular expression r, at an index I. We then can replace M by T and continue to apply replaceAll function on the remaining part S1 until we reach the base case.</p><p>• the base case, when we cannot find any substring that satisfies such condition. The resulting string R is then the same as the input string S.</p><p>The replaceAll function will use search function to find the index of substring M=M1•M2 in S. Specifically, this auxiliary function takes as input a symbolic string input S, a regular expression r, and returns the starting index I of a substring in S that matches r. If there exists no such substring, it returns a negative number. Otherwise, it returns the index of the substring M that satisfies the condition. We remark that the second parameter of replaceAll function cannot be a variable since in such case, the behavior of this function is undefined. Naively, we can keep unfolding recursively-defined function replaceAll, until we can decide if the current formula is satisfiable or not. However, we provide reduction rules (unfolding on demand) for them instead. For presentation purpose, Table <ref type="table">6</ref> lists only two reduction rules for the case when the prefix of the first parameter S is known <ref type="foot" target="#foot_3">5</ref> . In rule [RED-1], the prefix of S is a constant string s, while it is star(s, n) in rule [RED-2]. In both cases, since the prefix is already known, we are able to apply the replacement on the part s (star(s, n) in the other case) via auxiliary function rep. In rule [RED-1], suppose that S is composed by s and R, function rep(s, r, T ) replaces all occurrences in s, match-</p><p>Step Fact added Eq-class Reduction/Action 1 nM = "ababababababcc" {"ababababababcc", res, nM, p1 • p2} [REP-]: res = "ababababababcc" 2 p1 = star("ab",n1) {p1, star("ab",n1)} [REP-]: res = star("ab",n1) • p2 3 p2 = star("bc",n2) {p2, star("bc",n2)} [REP-]: res = star("ab",n1) • star("bc",n2) 4 res= star("ab",n1)•star("bc",n2)</p><p>{"ababababababcc", res, nM, star("ab",n1)• star("bc",n2), p1 • p2}</p><p>[REP-]:star("ab",n1)•star("bc",n2)= "ababababababcc" 5 star("ab",n1) • star("bc",n2) = "ababababababcc"</p><p>{"ababababababcc", res, nM, star("ab",n1)• star("bc",n2), p1 • p2} star("ab",n1)•star("bc",n2)="ababababababcc"⇒ ¬star("ab",n1)•star("bc",n2)="ababababababcc" UNSAT Table <ref type="table">5</ref>: A Solving Procedure for the Motivating Example in Fig. <ref type="figure" target="#fig_2">3</ref> Rule Reduction Condition</p><formula xml:id="formula_9">[RED-1] replaceAll(s•R, r, T )=U ⇒ V •replaceAll(t•R, r, T )=U (V, t)=rep(s, r, T ) [RED-2] replaceAll(star(s, n)•R, r, T )=U ⇒ V •replaceAll(t•R, r, T )=U (V, t)=rep(star(s, n), r, T )</formula><p>Table <ref type="table">6</ref>: Reduction Rules for replaceAll Functions ing the regular expression r, by T . It then returns the pair (V, t) such that replaceAll(s, r, T )=V •t, where t is guaranteed to be the longest suffix of s that must be examined together with R in the next step replaceAll(t•R, r, T ). The application of rep for the case star(s, n) is similar to s except that V is parameterized by n. Now, we illustrate how this auxiliary function can be applied via two examples. In the first example:</p><p>replaceAll("abcd"•R, "ab", T ) = U the rep("abcd", "ab", T ) method will return (T •"cd", ""). In the second one:</p><p>replaceAll("abcd"•R, ("ab" + "de"), T ) = U it will return (T •"c", "d") since it is possible that R starts with character 'e'.</p><p>Length constraints. We have inherited rules from Z3-str, to infer length constraints such as X=Y → length(X)=length(Y ).</p><p>Due to space limit, we do not include them in our paper. Importantly, the unfolding of recursive functions (star, replaceAll, etc.) would incrementally expose more concrete (sub)strings and therefore the interactions from Z3-str-to the Arithmetic Solver module in Z3 also happen incrementally.</p><p>In addition, as stated in Sec. 4.2, the length constraints, in the feedback from the Arithmetic Solver module, can also be used to prune the search space in string theory component, Z3-str-. For example, when the Arithmetic Solver module can deduce concrete values for length variables, Z3-str-will be able to make use of such information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">EVALUATION</head><p>In our experimental evaluation, we conduct two case studies to compare S3 with state-of-the-art string solvers. All experiments are run on an 3.2GHz machine with 8GB memory.</p><p>In Section 3, we stated that constraint solvers, which work only on string domain or only on non-string domain, are not effective for analyzing web applications. Thus, it is sufficient for us to compare S3 only with Kaluza and Z3-str.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Comparison with Kaluza</head><p>In this case study, we use the set of (50,000+) benchmarks that is shipped with Kaluza, which can be downloaded at: http://webblaze.cs.berkeley.edu/2010/kaluza They were generated using Kudzu <ref type="bibr" target="#b28">[28]</ref>, a symbolic execution framework for JavaScript. Since our solver can parse these generated constraints directly, it is straight-forward to plug S3 into Kudzu. The Kaluza benchmarks are classified into two:</p><p>• SAT, where Kaluza finds a satisfying solution and returns YES.</p><p>• UNSAT, where Kaluza cannot find any solutions and returns NO or it ends up with errors.</p><p>For each category, the benchmarks are further divided into two groups: small and big, based on the size of the files. We note that the classification is done by <ref type="bibr" target="#b28">[28]</ref>; such classification is not necessarily accurate in reality. In fact, after rectifying totally We first consider a timing comparison. We ran both Kaluza (column K) and S3 on all the benchmarks in the SAT category, as well the small benchmarks in the UNSAT category. The reason for omitting the large benchmarks in the UNSAT category is that often Kaluza fails to find a definitive answer here (due to crashing or timing out, after 1 minute), and therefore it is not meaningful to compare with its timing. The results, which are summarized in Table <ref type="table" target="#tab_3">8</ref>, clearly show that S3 is much faster, by a factor 19 or more.</p><p>In the next experiment, we consider something of perhaps greater importance: robustness. Roughly speaking, this measures how often a solver is able to provide a definitive answer. This, in turn, means that if the solver returns YES, then it should produce a particular model which demonstrates the executability of the path in question. If the solver returns NO, then it should mean that the path in question is in fact not executable. There is of course a third possible answer, MAYBE, which is not definitive (and which is the cause of false alarms). A robust system therefore is one which returns definitive answers often.</p><p>As mentioned above, the Kaluza benchmarks are categorized into SAT and UNSAT.</p><p>In the SAT category (of 19984 + 1835 = 21819 benchmarks), S3 finds 6 of them are unsatisfiable. By a careful investigation, it is in fact the case. Moreover, S3 successfully reports YES on all the benchmarks (excluding the 6 which are wrongly classified), and further, the complete models, returned by S3, are cross-checked by running them using Kaluza.</p><p>Next, we use S3 to cross-check the models produced by Kaluza. Since in Kaluza, each query must specify a variable, for which they will generate the model, in our setting we tested with the variable that starts with 'var' 6 . As a result, Kaluza has errors with 11 benchmarks that do not have any variable starting with 'var'. For the other 21808 benchmarks, it reports a YES answer. However, in 695 out of 21813 indeed satisfiable benchmarks, the model returned by Kaluza is incomplete. Because Kaluza only returns the model for one variable, it is possible that the return model for the chosen variable may not be extensible to become a complete model which includes other variables. In short, these 695 models are in fact not really models that are useful to reproduce attacks. (We note that <ref type="bibr" target="#b39">[39]</ref> has previously remarked this "semi-soundness" issue of Kaluza.)</p><p>Table <ref type="table" target="#tab_4">9</ref> shows statistics for 33230 (11761 + 21469) benchmarks in the UNSAT category. Kaluza reports a YES answer for 2894 out of 4057 rectified benchmarks. For other files (including the other rectified files), Kaluza is not reporting a NO answer to all benchmarks therein; rather, the answer is MAYBE most of the times. In fact, more than half (18210) of the benchmarks in this category was determined by S3 as SATISFIABLE! Again, the return models are confirmed by running them using Kaluza. This means that S3 has much more potential for vulnerability detection than Kaluza does. Note that in Table <ref type="table" target="#tab_4">9</ref> we no longer distinguish between big and small programs. The frequency of Kaluza crashing (ERROR) or timing out (TIMEOUT, after 1 minute), as opposed to saying NO, is extremely high. Also note that, 2894 files that Kaluza reports SAT (YES) only belong to rectified ones. Moreover, Kaluza often (about 70% of the time) returns a non-definitive answer, either by crashing or timing out. In contrast, S3 returns a definitive answer much more often.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S3</head><p>In summary for this study, we have first shown that S3 is far more efficient than Kaluza using its own impressive set of (50, 000+) benchmarks, by a significant margin. Perhaps as importantly, we have also shown that for a large number of cases where Kaluza provides no conclusion, S3 can actually provide a definitive conclusion (about 99.6% on the UNSAT benchmarks). Thus S3 is far more efficient and robust than Kaluza.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Comparison with Z3-str</head><p>Recall that Z3-str deals with a smaller class of constraints than S3 (since Z3-str cannot handle regular expressions). The purpose 6 There is usually one such variable in each benchmark. of this study is to answer the question: w.r.t constraints that can be handled by both of the two solvers, are the performances the same? We now demonstrate that the answer is no, via defining the classes that show S3's improvement (esp. our enhanced design).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Benchmark</head><p>Model produced?  To demonstrate that S3 is better, we first use six test cases from the SAT benchmarks of Kaluza. We follow the setting of Z3-str <ref type="bibr" target="#b39">[39]</ref> and remove all the constraints related to regular expressions. This way we can run Z3-str on the resulting constraints. These six benchmarks are presented in the first part of Table <ref type="table" target="#tab_6">10</ref>. For each of them, while S3 returns YES with a solution model, Z3-str instead returns NO. We note that the models S3 provides are validated as correct by using Z3-str itself.</p><p>We now briefly discuss why we have this difference. One reason is that Z3-str cannot acquire the concrete values assigned to length variables. In contrast, our design, presented in Section 4.2, enables the direct interactions between the string solver plug-in Z3-strand Z3 core, to query if the lengths of some string variables have been deduced or constrained in the arithmetic theory. This helps Z3-str-avoid repetitive case analysis.</p><p>More specifically, the six we use in Table <ref type="table" target="#tab_6">10</ref>, have the following (frequent) pattern: there exists at least one variable that is only constrained by its length. Basically, with the constraint length(x)=i, the solution for x can be any string of length i, i.e. "@..@", where each @ is an arbitrary character. However, Z3-str cannot make use of this length constraint and keeps trying to assign string value for x, starting from the empty string. Given that x is constrained by its length, Z3-str must try-and-test many times until there is no more conflict with that length constraint. Thus, the total number of values to be tested by Z3-str will be blown up, preventing it from finding a solution.</p><p>We next consider another set of benchmarks, representing another pattern (which is also frequent in Kaluza's benchmarks): there exists a relationship between the lengths of different string variables. Indeed the example presented in Fig. <ref type="figure" target="#fig_3">4</ref> resembles such pattern. See the second part of Table <ref type="table" target="#tab_6">10</ref>, where statistics for 4 benchmarks are shown. We purposely make two benchmarks satisfiable -names start with 'sat', whereas the other two are unsatisfiablenames start with 'unsat'. In the two whose names end with 'bnd', the lengths of the string variables are bounded by 10, while in the other two (the names end with 'unbnd'), there is no such bound. For each satisfiable benchmarks, both Z3-str and S3 can find a correct solution model. However, S3 outperforms Z3-str significantly by an order of magnitude. For the unsatisfiable cases, while S3 returns NO within a second, Z3-str runs for more than 2 hours without producing an answer.</p><p>In summary, our design allows the full interaction between string theory and arithmetic theory, enabling S3 to handle length constraints more effectively. Thus, even discounting the fact that S3 solves a more general class of constraints than Z3-str, its performance is much better in the common class of constraints. This ensures its applicability in web programs, where length constraints are ubiquitous.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">RELATED WORK</head><p>Symbolic execution has recently been exploited to address a wide range of security problems. Some notable examples are: automated fingerprint generation <ref type="bibr" target="#b7">[7]</ref>, protocol replay <ref type="bibr" target="#b25">[25]</ref>, automated code transformation to eliminate SQL injection attacks in legacy web applications <ref type="bibr" target="#b4">[4]</ref>.</p><p>Motivated by the problem of analyzing JavaScript code for the purpose of detecting security flaws, <ref type="bibr" target="#b28">[28]</ref> proposed a framework, Kudzu, which leverages the benefits of both concrete and symbolic evaluation. This work effectively reduced the analysis problem of web applications to the problem of solving string constraints. In order to be widely applicable, it is important to have a string solver which is able to reason about both string and non-string constraints. Importantly, the solver must also support constraints involving regular expressions and with multiple variables.</p><p>There is a vast literature on the problem of string solving. In previous Sections, we have carefully positioned our work against Kaluza and Z3-str. We now focus on other closely related work.</p><p>Practical methods for solving string equations can loosely be divided into bounded and unbounded methods. Bounded methods (e.g., HAMPI <ref type="bibr" target="#b22">[22]</ref>, CFGAnalyzer <ref type="bibr" target="#b3">[3]</ref>, and <ref type="bibr" target="#b18">[18]</ref>) often assume fixed length string variables, then treat the problem as a normal constraint satisfaction problem (CSP). These methods can be quite efficient in finding satisfying assignments and often can express a wider range of constraints than the unbounded methods. However, as also identified in <ref type="bibr" target="#b28">[28]</ref>, there is still a big gap in order to apply them to constraints arising from the analysis of web applications.</p><p>In the spirit of Kaluza, <ref type="bibr" target="#b6">[6]</ref> proposed to reason about feasibility of a symbolic execution path from high-level programs, of which string constraints are involved. In principle, the approach is similar to Kaluza: it proceeds by first enumerating concrete length values, before encoding into bit-vectors. It supports common integer related string operations, taken from the basic .NET string library, except for replace. Unlike Kaluza, however, regular expressions are not supported here. In a similar manner, <ref type="bibr" target="#b27">[27]</ref> addresses multiple types of constraints for Java PathFinder. Though this approach can handle many operators, it provides limited support for replace, requiring the result and arguments to be concrete. Furthermore, it does not handle regular expressions. In summary, the above methods are less powerful than S3 in terms of the expressiveness of the input language. Importantly, they have similar limitations as Kaluza, which we have carefully discussed.</p><p>PISA <ref type="bibr" target="#b33">[33]</ref> is the first path-and index-sensitive string solver that targets static analysis of web applications. The verification is conducted by encoding the program in Monadic Second-Order Logic (M2L). It supports regular expressions as well as Java's replace method. However, it does not support binary operations between two variables, i.e., PISA requires at least one of them to be constant. Also importantly, its expressiveness for arithmetic operations is restricted due to the limitations of M2L. For example, it does not support numeric multiplications and divisions.</p><p>Other unbounded methods are often built upon the theory of automata or regular languages. We will be brief and mention a few notable works. Java String Analyzer (JSA) <ref type="bibr" target="#b10">[10]</ref> applies static analysis to model flow graphs of Java programs in order to capture dependencies among string variables. A finite automata is then derived to constrain possible string values. The work <ref type="bibr" target="#b31">[31]</ref> used finite state machines (FSMs) for abstracting strings during symbolic execution of Java programs. They handle a few core methods in the java.lang.String class, and some other related classes. They partially integrate a numeric constraint solver. For instance, string operations which return integers, such as indexOf, trigger case-splits over all possible return values.</p><p>In short, using automata and/or regular language representations potentially enables the reasoning of infinite strings and regular expressions. However, most of existing approaches have difficulties in handling string operations related to integers such as length and indexOf, let alone other high-level operations addressed in this paper. More importantly, to assist web application analysis, it is necessary to reason about both string and non-string behavior together. It is not clear how to adapt such techniques for the purpose, given that they do not provide native support for constraints of the type integer.</p><p>Since our method does not rely on the length bounds in enumerating solutions, and our particular treatment of (possibly unbounded) recursive operations is lazy, it is possible that S3 can handle query of unbounded length variables as well as unbounded regular expression. However, to guarantee termination, we do rely on the fact that the lengths are bounded. In fact, our work targets the input constraints arising from realistic web applications. Therefore, even when the lengths are not precisely known -in the case of static analysis -it is reasonable to assume that the lengths of input string variables are indeed bounded, as many modern practical string solvers do.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUDING REMARKS</head><p>This paper presents a new algorithm for solving string constraints. The class of constraints is practically expressive, for its intended purpose of analyzing web programs which manipulate string inputs. Experimental evaluations show that our solver S3, despite being more expressive than other solvers, is much more robust and efficient.</p><p>We remark that in lieu of presenting an end-to-end system, we show that our proposed solver is indeed a modular contribution to any hypothetical dynamic symbolic execution end-to-end system. That is, the superior performance of our solver can be used, without significant engineering of integrating it, to obtain an improvement in the hypothetical system.</p><p>We believe, based on its symbolic representation of string constraints, S3 can also be extended to be more efficient in the context of static analysis, where even regular expressions can also be symbolically constructed.</p><p>Astute readers might already notice that our underlying symbolic representation goes well beyond regular languages. As an example, {a n •b n | n ≥ 0} can be easily modeled as star(a, n)•star(b, n)∧ n ≥ 0. While this paper focuses on the practical impact of S3, investigating the theoretical impact of such symbolic representation is left as our future work.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: An Example of Email Address Validation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: The Grammar of Our Input Constraint Language</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: From a JavaScript Program to the Generated Constraints</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: A Frequent Constraint Pattern</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: The Design of S3 core component consists of the following modules: the congruence closure engine, a SAT solver-based DPLL layer, and several built-in theory solvers, such as integer linear arithmetic, bit-vectors, etc. The congruence closure engine can detect equivalent terms and then classify them into different equivalence classes, which are shared among all built-in theory solvers. The SAT-based DPLL layer is responsible for handling the boolean structure of the input formula.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>niAlgorithm 1 :</head><label>1</label><figDesc>disjuncti ← normalize_to_DNF(reduced_F); for i = 1 to n do (Res, Sols) ← Z3-str-(disjuncti); if Res = SAT then return (true, Sols); end end return (false, []); Top-level Algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>How Z3-str Interacts with Z3 and Its Backtracking</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 8 :</head><label>8</label><figDesc>Timing Comparison: S3 vs. Kaluza</figDesc><table><row><cell>1 file in SAT</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 9 :</head><label>9</label><figDesc>S3 vs. Kaluza on UNSAT Category</figDesc><table><row><cell></cell><cell></cell><cell>Kaluza</cell></row><row><cell>NO</cell><cell>14877</cell><cell>7124</cell></row><row><cell>YES</cell><cell>18210</cell><cell>2894</cell></row><row><cell>ERROR</cell><cell>0</cell><cell>22653</cell></row><row><cell>TIMEOUT (1 min)</cell><cell>0</cell><cell>559</cell></row><row><cell>MAYBE</cell><cell>143</cell><cell>0</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 10 :</head><label>10</label><figDesc>S3 vs. Z3-str</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>We use x • y as a shorter form for concat(x, y).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>This operation is used to replace all occurrences.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>Otherwise, the solver should return satisfying assignments, representing a potential bug/vulnerability of the system.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_3"><p>Other rules related to the second, the third parameter, the result and their combinations are constructed similarly.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Verifying Client-side Input Validation Functions Using String Analysis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Alkhalaf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bultan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Gallegos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="947" to="957" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">ViewPoints: Differential String Analysis for Discovering Client-and Server-side Input Validation Inconsistencies</title>
		<author>
			<persName><forename type="first">M</forename><surname>Alkhalaf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">R</forename><surname>Choudhary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fazzini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bultan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Orso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISSTA</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="56" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Analyzing Context-Free Grammars Using an Incremental SAT Solver</title>
		<author>
			<persName><forename type="first">R</forename><surname>Axelsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Heljanko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lange</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="410" to="422" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">NoTamper: Automatic Blackbox Detection of Parameter Tampering Opportunities in Web Applications</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bisht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hinrichs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Skrupsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bobrowicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">N</forename><surname>Venkatakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="607" to="618" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">WAPTEC: Whitebox Analysis of Web Applications for Parameter Tampering Exploit Construction</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bisht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hinrichs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Skrupsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">N</forename><surname>Venkatakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="575" to="586" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Path Feasibility Analysis for String-Manipulating Programs</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bjørner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Tillmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="307" to="321" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Towards Automatic Discovery of Deviations in Binary Implementations with Applications to Error Detection and Fingerprint Generation</title>
		<author>
			<persName><forename type="first">D</forename><surname>Brumley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Caballero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Newsome</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="1" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Prototyping Symbolic Execution Engines for Interpreted Languages</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bucur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kinder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="239" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Symbolic Security Analysis of Ruby-on-rails Web Applications</title>
		<author>
			<persName><forename type="first">A</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Foster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="585" to="594" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Precise Analysis of String Expressions</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Christensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Møller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Schwartzbach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAS</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="1" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Z3: An Efficient SMT Solver</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>De Moura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Bjørner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="337" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Dynamic Test Input Generation for Database Applications</title>
		<author>
			<persName><forename type="first">M</forename><surname>Emmi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ISSTA</title>
		<imprint>
			<biblScope unit="page" from="151" to="162" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Unbounded Model-Checking with Interpolation for Regular Language Constraints</title>
		<author>
			<persName><forename type="first">G</forename><surname>Gange</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Navas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Stuckey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Søndergaard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Schachte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="277" to="291" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">JST: An Automatic Test Generation Tool for Industrial Java Applications with Strings</title>
		<author>
			<persName><forename type="first">I</forename><surname>Ghosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shafiei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-F</forename><surname>Chiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="992" to="1001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">DART: Directed Automated Random Testing</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Klarlund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGPLAN Not</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="213" to="223" />
			<date type="published" when="2005-06">June 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Automated Whitebox Fuzz Testing</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Molnar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In NDSS</title>
		<imprint>
			<biblScope unit="page" from="151" to="166" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Precise Interface Identification to Improve Testing and Analysis of Web Applications</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">G</forename><surname>Halfond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Anand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Orso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISSTA</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="285" to="296" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Solving String Constraints: The Case for Constraint Programming</title>
		<author>
			<persName><forename type="first">J</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Flener</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pearson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CP</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="381" to="397" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A Decision Procedure for Subset Constraints over Regular Languages</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hooimeijer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="188" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Solving String Constraints Lazily</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hooimeijer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASE</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="377" to="386" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Automated Testing with Targeted Event Sequence Generation</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Prasad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Møller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISSTA</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="67" to="77" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">HAMPI: A Solver for String Constraints</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kiezun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Ganesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hooimeijer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISSTA</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="105" to="116" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Automatic Creation of SQL Injection and Cross-site Scripting Attacks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kiezun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Jayaraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="199" to="209" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Generating Feature Usage Scenarios in Client-side Web Applications</title>
		<author>
			<persName><forename type="first">J</forename><surname>Maras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Štula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Carlson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICWE</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="186" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Replayer: Automatic Protocol Replay by Binary Analysis</title>
		<author>
			<persName><forename type="first">J</forename><surname>Newsome</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Brumley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="311" to="321" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Top ten project</title>
		<author>
			<persName><surname>Owasp</surname></persName>
		</author>
		<ptr target="http://www.owasp.org/" />
		<imprint>
			<date type="published" when="2013-05">May 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Symbolic Execution of Programs with Strings</title>
		<author>
			<persName><forename type="first">G</forename><surname>Redelinghuys</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Visser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Geldenhuys</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAICSIT</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="139" to="148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A Symbolic Execution Framework for JavaScript</title>
		<author>
			<persName><forename type="first">P</forename><surname>Saxena</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Akhawe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hanna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mccamant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SP</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="513" to="528" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Jalangi: A Selective Record-replay and Dynamic Analysis Framework for JavaScript</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kalasapur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Brutch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gibbs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESEC/FSE</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="488" to="498" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">CUTE: A Concolic Unit Testing Engine for C</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Marinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Agha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESEC/FSE</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="263" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Efficient Symbolic Execution of Strings for Validating Web Applications</title>
		<author>
			<persName><forename type="first">D</forename><surname>Shannon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Ghosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Khurshid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DEFECTS</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="22" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Path-and Index-sensitive String Analysis based on Monadic Second-order Logic</title>
		<author>
			<persName><forename type="first">T</forename><surname>Tateishi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pistoia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Tripp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISSTA</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="166" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Path-and Index-sensitive String Analysis Based on Monadic Second-order Logic</title>
		<author>
			<persName><forename type="first">T</forename><surname>Tateishi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pistoia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Tripp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Softw. Eng. Methodol</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="33" />
			<date type="published" when="2013-10">Oct. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Rex: Symbolic Regular Expression Explorer</title>
		<author>
			<persName><forename type="first">M</forename><surname>Veanes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Halleux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Tillmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICST</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="498" to="507" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">MetaSymploit: Day-one Defense Against Script-based Attacks with Security-enhanced Symbolic Analysis</title>
		<author>
			<persName><forename type="first">R</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SEC</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="65" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Sound and Precise Analysis of Web Applications for Injection Vulnerabilities</title>
		<author>
			<persName><forename type="first">G</forename><surname>Wassermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Su</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="32" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Static Detection of Cross-site Scripting Vulnerabilities</title>
		<author>
			<persName><forename type="first">G</forename><surname>Wassermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Su</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="171" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">STRANGER: An Automata-based String Analysis Tool for PHP</title>
		<author>
			<persName><forename type="first">F</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Alkhalaf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bultan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="154" to="157" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Z3-str: A Z3-based String Solver for Web Application Analysis</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Ganesh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESEC/FSE</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="114" to="124" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
