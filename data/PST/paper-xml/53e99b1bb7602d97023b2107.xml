<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">State-Dependent Representation Independence</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Amal</forename><surname>Ahmed</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Derek</forename><surname>Dreyer</surname></persName>
							<email>dreyer@mpi-sws.mpg.de</email>
						</author>
						<author>
							<persName><forename type="first">Andreas</forename><surname>Rossberg</surname></persName>
							<email>rossberg@mpi-sws.mpg.de</email>
						</author>
						<title level="a" type="main">State-Dependent Representation Independence</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">B77050511614BBF63C26468A123C8EC0</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:30+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.3.1 [Programming Languages]: Formal Definitions and Theory</term>
					<term>D.3.3 [Programming Languages]: Language Constructs and Features-Abstract data types</term>
					<term>F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs General Terms Languages, Theory, Verification data types, representation independence, existential types, local state, step-indexed logical relations</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Mitchell's notion of representation independence is a particularly useful application of Reynolds' relational parametricity -two different implementations of an abstract data type can be shown contextually equivalent so long as there exists a relation between their type representations that is preserved by their operations. There have been a number of methods proposed for proving representation independence in various pure extensions of System F (where data abstraction is achieved through existential typing), as well as in Algol-or Java-like languages (where data abstraction is achieved through the use of local mutable state). However, none of these approaches addresses the interaction of existential type abstraction and local state. In particular, none allows one to prove representation independence results for generative ADTs -i.e., ADTs that both maintain some local state and define abstract types whose internal representations are dependent on that local state.</p><p>In this paper, we present a syntactic, logical-relations-based method for proving representation independence of generative ADTs in a language supporting polymorphic types, existential types, general recursive types, and unrestricted ML-style mutable references. We demonstrate the effectiveness of our method by using it to prove several interesting contextual equivalences that involve a close interaction between existential typing and local state, as well as some well-known equivalences from the literature (such as Pitts and Stark's "awkward" example) that have caused trouble for previous logical-relations-based methods.</p><p>The success of our method relies on two key technical innovations. First, in order to handle generative ADTs, we develop a possible-worlds model in which relational interpretations of types are allowed to grow over time in a manner that is tightly coupled with changes to some local state. Second, we employ a step-indexed stratification of possible worlds, which facilitates a simplified account of mutable references of higher type.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Reynolds' notion of relational parametricity <ref type="bibr" target="#b22">[23]</ref> is the essence of type abstraction -clients of an abstract type behave uniformly across all relational interpretations of that type and thus cannot depend in any way on how the type is represented. Mitchell's notion of representation independence <ref type="bibr" target="#b16">[17]</ref> is a particularly useful application of relational parametricity -two different implementations of an abstract data type can be shown contextually equivalent so long as there exists a relation between their type representations that is preserved by their operations. This is useful even when the type representations of the two ADTs are the same, because the choice of an arbitrary relational interpretation for the abstract type allows one to establish the existence of local invariants.</p><p>Originally these ideas were developed in the context of (variants of) System F, but over the past two decades there has been a great deal of work on extending them to the setting of more realistic languages, such as those with recursive functions <ref type="bibr" target="#b19">[20]</ref>, general recursive types <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b10">11]</ref>, selective strictness <ref type="bibr" target="#b28">[29]</ref>, etc. In these functional languages, data abstraction is achieved through the use of existential types. Others have considered representation independence in the setting of imperative languages, such as Algol and Java, where data abstraction is achieved instead through the use of local mutable state (e.g., local variables or private fields) <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b13">14]</ref>.</p><p>Of course, most modern languages (such as ML) are neither purely functional nor imperative, but rather freely mix the paradigms. However, none of the existing work on representation independence has considered a language supporting both the functional and the imperative approaches to data abstraction, i.e., both existential types and local state. This is unfortunate, since both abstraction mechanisms play important, interdependent roles in the definition of generative abstract data types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Reasoning About Generative Abstract Data Types</head><p>Existential type abstraction provides type generativity -every unpacking of an existential package generates a fresh abstract type that is distinct from any other. This is similar to the behavior of Standard ML's generative functors, which generate fresh abstract types at each application, and indeed the semantics of SML-style functors may be understood as a stylized use of existential type abstraction <ref type="bibr" target="#b24">[25]</ref>. The clearest motivation for type generativity is in the definition of ADTs that encapsulate some local state. In such instances, generativity is sometimes necessary to achieve the proper degree of data abstraction. As a simple motivating example, consider the SML module code in Figure <ref type="figure" target="#fig_0">1</ref>, which is adapted from an example of Dreyer et al. <ref type="bibr" target="#b11">[12]</ref>. (Later in the paper, we will develop a similar example using existential types.) Here, the signature SYMBOL describes a module implementing a mutable symbol table, which maps "symbols" to strings. The module provides an abstract type t describing the symbols currently in its table; a function eq for comparing symbols for equality; a function insert, which adds a  given string to the table and returns a fresh symbol mapped to it; and a function lookup, which looks up a given symbol in the table and returns the corresponding string.</p><p>The functor Symbol implements the symbol type t as an integer index into a (mutable) list of strings. When applied, Symbol creates a fresh table (represented as a pointer to an empty list) and a mutable counter size (representing the size of the table). The implementations of the various functions are straightforward, and the body of the functor is sealed with the signature SYMBOL, thus hiding access to the local state (table and size).</p><p>The call to List.nth in the lookup function might in general raise a Subscript exception if the input n were an arbitrary integer. However, we "know" that this cannot happen because lookup is exported with argument type t, and the only values of type t that a client could possibly have gotten hold of are the values returned by insert, i.e., integers that are between 1 and the current size of table. Therefore, the implementation of the lookup function need not bother handling the Subscript exception.</p><p>This kind of reasoning is commonplace in modules that encapsulate local state. But what justifies it? Intuitively, the answer is type generativity. Each instantiation of the Symbol functor creates a fresh symbol type t, which represents the type of symbols that are valid in its own table (but not any other). Were Symbol not generative, each application of the Symbol functor would produce a module with distinct local state but the same symbol type. It would then be easy to induce a Subscript error by accidentally passing a value of one table's symbol type to another's lookup function. <ref type="foot" target="#foot_0">1</ref>While this intuition about the importance of generativity is very appealing, it is also completely informal. The goal of this paper is to develop a formal framework for reasoning about the interaction of generative type abstraction and mutable state.</p><p>In the case of an example like the Symbol functor, we will be able to show that the implementation of Symbol shown in Figure <ref type="figure" target="#fig_0">1</ref> is contextually equivalent to one whose lookup function is replaced by: fun lookup n = if n &gt; 0 andalso n &lt;= !size andalso !size = length(!table) then List.nth (!table, !size -n) else "Hell freezes over"</p><p>In other words, there is no observable difference between the original Symbol functor and one that dynamically checks the various invariants we claim to "know." Hence, the checks are unnecessary.</p><p>This kind of result can be understood as an instance of representation independence, albeit a somewhat degenerate one in that the ADTs in question share the same type representation. As with most such results, the proof hinges on the construction of an appropriate relational interpretation of the abstract type t, which serves to impose an invariant on the possible values of type t. In this case, we wish to assert that for a particular structure S defined by Symbol(), the only values of type S.t are integers between 1 and the current size of S's table. This will allow us to prove that any range check on the argument to S's lookup function is superfluous.</p><p>The problem is that the relational interpretation we wish to assign to S.t depends on the current values stored in S's local state. In effect, as S's insert function is called repeatedly over time, its table grows larger, and the relational interpretation of S.t must grow accordingly to include more and more integers. Thus, what we need is an account of state-dependent representation independence, in which the relational interpretations of abstract types are permitted to grow over time, in a manner that is tightly coupled with changes to some local state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Overview</head><p>In this paper, we present a novel method for proving state-dependent representation independence results. Our method extends previous work by Ahmed on syntactic step-indexed logical relations for recursive and quantified types <ref type="bibr" target="#b0">[1]</ref>. We extend her technique with support for reasoning about local state, and demonstrate its effectiveness on a variety of small but representative examples. Although our primary focus is on proving representation independence for ADTs that exhibit an interaction of existentials and state, our method also handles several well-known simply-typed examples from the literature on local state (such as Pitts and Stark's "awkward" example <ref type="bibr" target="#b20">[21]</ref>) that have proven difficult for previous logical-relations-based methods to handle.</p><p>In order to reason about local state, we build into our logical relation a notion of possible worlds. While several aspects of our possible worlds are derived from and inspired by prior work, other aspects are quite novel: 1. We enrich our possible worlds with populations and laws, which allow us to evolve the relational interpretation of an abstract type over time in a controlled, state-dependent fashion.</p><p>For instance, we can use a population to grow a set of values (e.g., the integers between 1 and some n), together with a law that explains what the current population implies about the current machine state (e.g., that the symbol table has size n).</p><p>2. Second, our method provides the ability to reason locally about references to higher-order values. While ours is not the first method to handle higher-order state, our approach is novel and arguably simpler than previous accounts. It depends critically on step-indexing in order to avoid a circularity in the construction of possible worlds.</p><p>The remainder of the paper is structured as follows. In Section 2, we present F µ! , our language under consideration, which is essentially System F extended with general recursive types and general ML-style references. In Section 3, we explain at a high level how our method works and what is novel about it. In Section 4, we present the details of our logical relation and prove it sound (but not complete) with respect to contextual equivalence of F µ! programs. In Section 5, we show how to use our method to prove a number of interesting contextual equivalences. Finally, in Section 6, we conclude with a thorough comparison to related work, as well as directions for future work.   We consider F µ! , a call-by-value λ-calculus with impredicative polymorphism, iso-recursive types, and general ML-style references. The syntax of F µ! is shown in Figure <ref type="figure" target="#fig_3">2</ref>, together with excerpts of the static and dynamic semantics. We assume an infinite set of locations Loc ranged over by l. Our term language includes equality on references (e1 == e2), but is otherwise standard. We define a small-step operational semantics for F µ! as a relation between configurations (s, e), where s is a global store mapping locations l to values v. We use evaluation contexts E to lift the primitive reductions to a standard left-to-right call-by-value semantics for the language. We elide the syntax of evaluation contexts as it is completely standard, and we show only some of the reduction rules in Figure <ref type="figure" target="#fig_3">2</ref>.</p><formula xml:id="formula_0">τ ::= α | unit | int | bool | τ 1 × τ 2 | τ 1 → τ 2 | ∀α. τ | ∃α. τ | µα. τ | ref τ Prim Ops o ::= + | -| = | &lt; | ≤ | . . .</formula><formula xml:id="formula_1">= () | l | ±n | true | false | v 1 , v 2 | λx : τ. e | Λα. e | pack τ 1 , v as ∃α. τ | fold v s, (λx : τ. e) v -→ s, [v/x]e s, (Λα. e) [τ ] -→ s, [τ /α]e s, unpack (pack τ, v as ∃α. τ ) as α, x in e -→ s, [τ /α][v/x]e s, unfold (fold v) -→ s, v s, ref v -→ s[l → v], l where l / ∈ dom(s) s, !l -→ s, v where s(l) = v s, l:= v -→ s[l → v], () where l ∈ dom(s) s, l == l -→ s, true s, l == l -→ s,</formula><p>F µ! typing judgments have the form ∆; Γ; Σ e : τ where the contexts ∆, Γ, and Σ are defined as in Figure <ref type="figure" target="#fig_3">2</ref>. The type context ∆ is used to track the set of type variables in scope; the value context Γ is used to track the term variables in scope (along with their types τ , which must be well formed in context ∆, written ∆ τ ); and the store typing Σ tracks the types of the contents of locations in the store. Note that Σ maps locations to closed types. We write FTV (τ ) to denote the set of type variables that appear free in type τ . The typing rules are entirely standard, so we show only a few rules in Figure <ref type="figure" target="#fig_3">2</ref>. We refer the reader to the online technical appendix <ref type="bibr" target="#b2">[3]</ref> for full details of F µ! .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Contextual Equivalence</head><p>A context C is an expression with a single hole [•] in it. Typing judgments for contexts have the form C : (∆; Γ; Σ τ ) ⇒ (∆ ; Γ ; Σ τ ), where (∆; Γ; Σ τ ) indicates the type of the hole. Essentially, this judgment says that if e is an expression such that ∆; Γ; Σ e : τ , then ∆ ; Γ ; Σ C[e] : τ . The typing rule for a hole [•] is as follows:</p><formula xml:id="formula_2">∆ ⊆ ∆ Γ ⊆ Γ Σ ⊆ Σ [•] : (∆; Γ; Σ τ ) ⇒ (∆ ; Γ ; Σ τ )</formula><p>The other rules are straightforward (see our online appendix <ref type="bibr" target="#b2">[3]</ref>).</p><p>We define contextual approximation (∆; Γ; Σ e1 ctx e2 : τ ) to mean that, for any well-typed program context C with a hole of the type of e1 and e2, the termination of C[e1] implies the termination of C[e2]. Contextual equivalence (∆; Γ; Σ e1 ≈ ctx e2 : τ ) is then defined as approximation in both directions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.1 (Contextual Approximation &amp; Equivalence)</head><p>Let ∆; Γ; Σ e1 : τ and ∆; Γ; Σ e2 : τ .</p><formula xml:id="formula_3">∆; Γ; Σ e 1 ctx e 2 : τ def = ∀C, Σ , τ , s. C : (∆; Γ; Σ τ ) ⇒ (•; •; Σ τ ) ∧ s : Σ ∧ s, C[e 1 ] ⇓ =⇒ s, C[e 2 ] ⇓ ∆; Γ; Σ e 1 ≈ ctx e 2 : τ def = ∆; Γ; Σ e 1 ctx e 2 : τ ∧ ∆; Γ; Σ e 2 ctx e 1 : τ</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">The Main Ideas</head><p>In this section we give an informal overview of the main novel ideas in our method, and how it compares to some previous approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Logical Relations</head><p>Broadly characterized, our approach is a logical relations method. We define a relation V τ ρ, which relates pairs of values at type τ , where the free type variables of τ are given relational interpretations in ρ. The relation is "logical" in the sense that its definition follows the structure of τ , modeling each type constructor as a logical connective. For example, arrow types correspond to implication, so functions are defined to be related at an arrow type iff relatedness of their arguments implies relatedness of their results. We will show that this logical relation is sound with respect to contextual equivalence for F µ! . This is useful because, for many examples, it is much easier to show two programs are in the logical relation than to show they are contextually equivalent directly.</p><p>Logical relations methods are among the oldest techniques for proving representation independence results. We will assume the reader is generally familiar with the flavor of these techniques, and instead focus on what is distinctive and original about ours.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Local Reasoning via Possible Worlds and Islands</head><p>As explained in Section 1, our core contribution is the idea of state-dependent relational interpretations of abstract types. That is, whether two values are related by some abstract type's relational interpretation may depend on the current state of the heap. But when defining such a relational interpretation, how can we characterize the "current state of the heap?"</p><p>As a starting point, we review the general approach taken by a number of prior works on reasoning about local state <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b9">10]</ref>. This approach, which utilizes a possible worlds model, has influenced us greatly, and constitutes the foundation of our method. However, the form it has taken in prior work is insufficient for our purposes, and it is instructive to see why.</p><p>The general approach of these prior works is to index the logical relation not only by a type τ but by a world W . Instead of characterizing the current state of the heap, W characterizes the properties we expect the heap to have. In other words, it is a relation on machine stores, and we restrict attention to pairs of stores that satisfy it. If two values v1 and v2 are in the logical relation at type τ and world W , then it means they are related when considered under any two stores s1 and s2, respectively, that satisfy W .</p><p>Worlds in turn are constructed as a separating conjunction of smaller worlds w1, . . . , wn , sometimes called islands, where each island is a relation that "concerns" a disjoint piece of the store. Intuitively, this means that each island distinguishes between pairs of stores only on the basis of a particular set of memory locations, and the set of locations that one island cares about is disjoint from the set that any other one cares about.</p><p>Exactly how the separation criterion on islands is formalized is immaterial; the important point is that it enables local reasoning. Suppose we want to prove that one expression is related to another in world W . Each may allocate some fresh piece of the store, and before showing that the resulting values of the expressions are related, we are permitted to extend W with a new island w describing how these fresh pieces of the store relate to each other. World extension is sound here precisely because the new island is (due to freshness of allocation) separate from the others. So long as the expressions in question do not make the locations in their local stores publicly accessible, no other part of the program is capable of mutating the store in such a manner as to violate w.</p><p>To make things concrete and to observe the limitations of possible worlds (at least as we have described them), let us consider the motivating example from Section 1. To prove that the two implementations of the Symbol functor are contextually equivalent, we will show that their bodies are logically related in an arbitrary initial world W0. Both functors allocate local state in the same way, namely by allocating one pointer for table and one for size, so we will want to extend W0 with an island wsym describing the local invariants on table and size. How should we define wsym?</p><p>One useful invariant that wsym can enforce is that, for both implementations of Symbol, the integer pointed to by size is equal to the length of the list pointed to by table. By incorporating this property into wsym, we will be guaranteed that, in any future world (i.e., any extension of W0 wsym) in which the lookup function is called, the dynamic check !size = length(!table) in the second implementation of Symbol will always evaluate to true.</p><p>We can also use wsym to enforce that !size is the same in the stores of both programs, and similarly for !table. Unfortunately, while this is a necessary condition, it is not sufficient to prove that the range check on the argument of lookup in the second Symbol implementation always evaluates to true. For that, we need a way of correlating the value of !size and the possible values of type t, but the islands we have developed thus far do not provide one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Populating the Islands and Enforcing the Laws</head><p>The problem with islands is that they are static entities with no potential for development. To address this limitation, we enrich islands with populations. A population is a set of values that "inhabit" an island and affect the definition of the store relation for that island. An island's population may grow over time (i.e., as we move to future worlds), and its store relation may change accordingly. In order to control population growth, we equip every island with an immutable law governing the connection between its population and its store relation. We denote populations by V , store relations by ψ, and laws by L.</p><p>Consider the Symbol example. Let us define Vn = {1, . . . , n}, and let ψn be the store relation containing pairs of stores that obey the properties concerning table and size described in Section 3.2 and that, in addition, both map the location size to n. The idea is that Vn describes the set of values of type t, given that the current stores satisfy ψn. Thus, when we extend the initial world W0 with an island wsym governing Symbol's local state, we will choose that wsym to comprise population V0, store relation ψ0, and a law L defined as {(ψn, Vn) | n ≥ 0}. Here, V0 and ψ0 characterize the initial world, in which there are no values of type t and the size of the table is 0. The law L describes what future populations and store relations on this island may look like. In particular, L enforces that future populations may contain 1 to n (for any n), but only in conjunction with stores that map size to n. (Of course, the initial population and store relation must also obey the law, which they do.) An island's law is established when the island is first added to the world and may not be amended in future worlds.</p><p>Having extended the world W0 with this new island wsym, we are now able to define a relational interpretation for the type t, namely: values v1 and v2 are related at type t in world W if v1 = v2 = m, where m belongs to the population of wsym in W . In proving equivalence of the two versions of the lookup function, we can assume that we start with stores s1 and s2 that are related by some world W , where W is a future world of W0 wsym, and that the arguments to lookup are related at type t in W . Consequently, given the law that we established for wsym together with the interpretation of t, we know that the arguments to lookup must both equal some m, that the current population of wsym must be some Vn, where 1 ≤ m ≤ n, and that the current store relation must be ψn. Since s1 and s2 satisfy W , they must satisfy ψn, which means they map size to n ≥ m. Hence, the dynamic range check in the second version of Symbol must evaluate to true.</p><p>For the above relational interpretation of t to make sense, we clearly need to be able to refer to a particular island in a world (e.g., wsym) by some unique identifier that works in all future worlds. We achieve this by insisting that a world be an ordered list of islands, and that new islands only be added to the end of the list. This allows us to access islands by their position in the list, which stays the same in future worlds.</p><p>In addition, an important property of the logical relation, which relational interpretations of abstract types must thus obey as well, is closure under world extension, i.e., that if two values are related in world W , then they are related in any future world of W . To ensure closure under world extension for relations that depend on their constituents' inhabitation of a particular island (such as the relation used above to interpret t), we require that island populations can only grow larger in future worlds, not smaller.</p><p>For expository purposes, we have motivated our population technique with an example that is deliberately simple, in the sense that the relational interpretation of t is completely dependent on the current local state. That is, if we know that the current value of !size is n, then we know without a doubt that the relational interpretation of t in the current world must be {(1, 1), . . . , (n, n)}. In Section 5, we will see more complex examples in which the relational interpretation of t may depend not only on the current state, but also on the history of the program execution up to that point. Our population techniques scales very nicely to handle such examples because it allows us to control the evolution of an abstract type's relational interpretation over time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Mutable References to Higher-Order Values</head><p>Most prior possible-worlds logical-relation approaches to reasoning about local state impose serious restrictions on what can be stored in memory. Pitts and Stark <ref type="bibr" target="#b20">[21]</ref>, for example, only allow references to integers. Reddy and Yang <ref type="bibr" target="#b21">[22]</ref> and Benton and Leperchey <ref type="bibr" target="#b6">[7]</ref> additionally allow references to data, which include integers and pointers but not functions. In the present work, however, we would like to avoid any restrictions on the store.</p><p>To see what (we think) is tricky about handling references to higher-order values, suppose we have two programs that both maintain some local state, and we are trying to prove these programs equivalent. Say the invariant on this local state, which we will enforce using an island w, is very simple: the value that the first program stores in location l1 is logically related to the value that the second program stores in l2. If these values were just integers, we could write the law for w (as we did in the Symbol example) so that in any future world, w's store relation ψ must demand that two stores s1 and s2 are related only if s1(l1) = s2(l2). This works because at type int, the logical relation coincides with equality.</p><p>If the locations have some higher type τ , however, the definition of w's store relation ψ will need to relate s1(l1) and s2(l2) using the logical relation at type τ , not mere syntactic equality. But the problem is: logical relations are indexed by worlds. In order for ψ to say that s1(l1) and s2(l2) are related at type τ , it needs to specify the world W in which their relation is being considered.</p><p>Bohr and Birkedal <ref type="bibr" target="#b9">[10]</ref> address this issue by imposing a rigid structure on their store relations. Specifically, instead of having a single store relation per island, they employ a local parameter, which is roughly a set of pairs of the form (P, LL), where P is a store relation and LL is a finite set of pairs of locations (together with a closed type). The way to interpret this local parameter is that the current stores must satisfy one of the P 's, and all the pairs of locations in the corresponding LL must be related by the logical relation in the current world. In the case of our example with l1 and l2, they would define a local parameter {(P, LL)}, where P is the universal store relation and LL = {(l1, l2, τ )}. Bohr and Birkedal's approach effectively uses the LL's to abstract away explicit references to the world-indexed logical relation within the store relation. This avoids the need to refer to a specific world inside a store relation, but it only works for store relations that are expressible in the highly stylized form of these local parameters.</p><p>Instead, our approach is to parameterize store relations over the world in which they will be considered. Then, in defining what it means for two stores s1 and s2 to satisfy some world W , we require that for every ψ in W , (s1, s2) ∈ ψ[W ], i.e., s1 and s2 obey ψ when it is instantiated to the current world W . The astute reader will have noticed, however, that this parameterization introduces a circularity: worlds are defined to be collections of store relations, which are now parameterized by worlds. To break this circularity, we employ step-indexed logical relations. <ref type="bibr" target="#b3">[4]</ref> introduced the step-indexed model as a way to express semantic type soundness proofs for languages with general recursive and polymorphic types. Although its original motivation was tied to foundational proof-carrying code, the technique has proven useful in a variety of applications. In particular, Ahmed <ref type="bibr" target="#b0">[1]</ref> has used a binary version of Appel and McAllester's model for relational reasoning about System F extended with general recursive types, and it is her work that we build on.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Step-Indexed Logical Relations and Possible Worlds</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appel and McAllester</head><p>The basic idea is closely related to classic constructions from domain theory. We define the logical relation V τ ρ as the limit of an infinite chain of approximation relations Vn τ ρ, where n ≥ 0. Informally, values v1 and v2 are related by the n-th approximation relation only if they are indistinguishable in any context for n steps of computation. (They might be distinguishable after n steps, but we don't care because the "clock" has run out.) Thus, values are related in the limit only if they are indistinguishable in any context for any finite number of steps, i.e., if they are really indistinguishable.</p><p>The step-indexed stratification makes it possible to define the semantics of recursive types quite easily. Two values fold v1 and fold v2 are defined to be related by Vn µα. τ ρ iff v1 and v2 are related by V k [µα. τ /α]τ ρ for all k &lt; n. Even though the un-folded type is larger (usually a deal breaker for logical relations, which are typically defined by induction on types), the step index gets smaller, so the definition of the logical relation is wellfounded. Moreover, it makes sense for the step index to get smaller, since it takes a step of computation to extract vi from fold vi.</p><p>Just as we use steps to stratify logical relations, we can also use them to stratify our quasi-circular possible worlds. We define an "n-level world" inductively to be one whose constituent store relations (the ψ's) are parameterized by (n-1)-level worlds. The intuition behind this stratification of worlds is actually very simple: an n-level world describes properties of the current stores that may affect the relatedness of pairs of values for n steps of computation. Since it takes one step of computation just to inspect the stores (via a pointer dereference), the relatedness of pairs of values for n steps can only possibly depend on the relatedness of the current stores for n-1 steps. Thus, it is fine for an n-level world to be defined as a collection of (n-1)-level store relations, i.e., ψ's that only guarantee relatedness of memory contents for n-1 steps. And these (n-1)-level ψ's, in turn, need only be parameterized by (n-1)level worlds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Step-Indexed Logical Relations for F µ!</head><p>In this section, we present the details of our logical relation for F µ! and prove it sound with respect to contextual equivalence.</p><p>The basic idea is to give a relational interpretation V τ of a (closed) type τ as a set of tuples of the form (k, W, v1, v2), where k is a natural number (called the step index), W is a world (as motivated in Section 3), and v1 and v2 are values. Informally, (k, W, v1, v2) ∈ V τ says that in any computation running for no more than k steps, v1 approximates v2 at the type τ in world W . An important point is that to determine if v1 approximates v2 for k steps (at type τ ), it suffices for the world W to be a k-level world. That is, the store relations ψ in W need only guarantee relatedness of memory contents for k -1 steps, as discussed in Section 3.5. We make the notion of a "k-level world" precise in Section 4.1.</p><p>Preliminaries In the rest of the paper, the metavariables i, j, k, m, and n all range over natural numbers. We use the metavariable χ to denote sets of tuples of the form (k, W, e1, e2) where k is a step index, W is a world, and e1 and e2 are closed terms (i.e., terms that may contain locations, but no free type or term variables). Given a set χ of this form, we write χ val to denote the subset of χ such that e1 and e2 are values.</p><p>As mentioned in Section 3.3, a world W is an ordered list (written w1, . . . , wn ) of islands. An island w is a pair of some current knowledge η and a law L. The knowledge η for each island represents the current "state" of the island. It comprises four parts: a store relation ψ, which is a set of tuples of the form (k, W, s1, s2), where k is a step index, W is a world, and s1, and s2 are stores; a population V , which is a set of closed values; and two store typings Σ1 and Σ2. The domains of Σ1 and Σ2 give us the sets of locations that the island "cares about" (a notion we mentioned in Section 3.2). Meanwhile, a law L is a set of pairs (k, η). If (k, η) ∈ L, it means that, at "time" k (representing the number of steps left on the clock), the knowledge η represents an acceptable state for the island to be in. Below we summarize our notation for ease of reference.</p><p>Type Interpretation χ ::= {(k, W, e 1 , e 2 ), . . . } Store Relation</p><formula xml:id="formula_4">ψ ::= {(k, W, s 1 , s 2 ), . . . } Population V ::= {v 1 , . . . } Knowledge η ::= (ψ, V, Σ 1 , Σ 2 ) Law L ::= {(k, η), . . .} Island w ::= (η, L) World W ::= w 1 , . . . , wn CandAtom k def = {(j, W, e 1 , e 2 ) | j &lt; k ∧ W ∈ CandWorld j } CandType k def = P(CandAtom val k ) CandStoreAtom k def = {(j, W, s 1 , s 2 ) | j &lt; k ∧ W ∈ CandWorld j } CandStoreRel k def = P(CandStoreAtom k ) CandKnowledge k def = CandStoreRel k × Population × StoreTy × StoreTy CandLawAtom k def = {(j, η) | j ≤ k ∧ η ∈ CandKnowledge j } CandLaw k def = P(CandLawAtom k ) CandIsland k def = CandKnowledge k × CandLaw k CandWorld k def = {W ∈ (CandIsland k ) n | n ≥ 0} CandAtomω def = S k≥0 CandAtom k CandType ω def = P(CandAtom val ω ) ⊇ S k≥0 CandType k χ k def = {(j, W, e 1 , e 2 ) | j &lt; k ∧ (j, W, e 1 , e 2 ) ∈ χ} ψ k def = {(j, W, s 1 , s 2 ) | j &lt; k ∧ (j, W, s 1 , s 2 ) ∈ ψ} η k def = ( ψ k , V, Σ 1 , Σ 2 ) where η = (ψ, V, Σ 1 , Σ 2 ) L k def = {(j, η) | j ≤ k ∧ (j, η) ∈ L} w k def = ( η k , L k )</formula><p>where w = (η, L) </p><formula xml:id="formula_5">W k def = w 1 k , . . . , wn k where W = w 1 , . . . , wn (ψ , V , Σ 1 , Σ 2 ) (ψ, V, Σ 1 , Σ 2 ) def = V ⊇ V ∧ Σ 1 ⊇ Σ 1 ∧ Σ 2 ⊇ Σ 2 (η , L ) (η, L) def = η η ∧ L = L w 1 , . . . , w n+m w 1 , . . . , wn def = m ≥ 0 ∧ ∀i ∈ {1, . . . , n}. w i w i (j, W ) (k, W ) def = j ≤ k ∧ W W j ∧ W ∈ W orld j ∧ W ∈ W orld k (j, W ) (k, W ) def = j &lt; k ∧ (j, W ) (k, W ) Atom[τ 1 , τ 2 ] k def = {(j, W, e 1 , e 2 ) ∈ CandAtom k | W ∈ World j ∧ Σ 1 (W ) e 1 : τ 1 ∧ Σ 2 (W ) e 2 : τ 2 } Type[τ 1 , τ 2 ] k def = {χ ∈ P(Atom[τ 1 , τ 2 ] val k ) | ∀(j, W, v 1 , v 2 ) ∈ χ. ∀(j , W ) (j, W ). (j , W , v 1 , v 2 ) ∈ χ} StoreAtom k def = {(j, W, s 1 , s 2 ) ∈ CandStoreAtom k | W ∈ World j } StoreRel k def = {ψ ∈ P(StoreAtom k ) | ∀(j, W, s 1 , s 2 ) ∈ ψ. ∀(i, W ) (j, W ). (i, W , s 1 , s 2 ) ∈ ψ} Knowledge k def = {(ψ, V, Σ 1 , Σ 2 ) ∈ CandKnowledge k | ψ ∈ StoreRel k ∧ ∀s 1 , s 2 , s 1 , s 2 . ( ∀l ∈ dom(Σ 1 ). s 1 (l) = s 1 (l) ∧ ∀l ∈ dom(Σ 2 ). s 2 (l) = s 2 (l) ) =⇒ ∀j, W. (j, W, s 1 , s 2 ) ∈ ψ ⇐⇒ (j, W, s 1 , s 2 ) ∈ ψ} LawAtom k def = {(j, η) ∈ CandLawAtom k | η ∈ Knowledge j } Law k def = {L ∈ P(LawAtom k ) | ∀(j, η) ∈ L. ∀i &lt; j. (i, η i ) ∈ L} Island k def = {(η, L) ∈ Knowledge k × Law k | (k, η) ∈ L} World k def = {W ∈ (Island k ) n | n ≥ 0 ∧ ∀a, b ∈ {1, . . . , n}. a = b =⇒ dom(W [a].Σ 1 ) # dom(W [b].Σ 1 ) ∧ dom(W [a].Σ 2 ) # dom(W [b].Σ 2 )} Atom[τ 1 , τ 2 ] def = S k≥0 Atom[τ 1 , τ 2 ] k Type[τ 1 , τ 2 ] def = {χ ∈ CandType ω | ∀k ≥ 0. χ k ∈ Type[τ 1 , τ 2 ] k } ⊇ S k≥0 Type[τ 1 , τ 2 ] k</formula><formula xml:id="formula_6">w.η ≡ η i w.L ≡ L i w.ψ ≡ ψ i w.V ≡ V i w.Σ 1 ≡ Σ i1 w.Σ 2 ≡ Σ i2</formula><p>If W is a world with n islands, we also use the following shorthand:</p><formula xml:id="formula_7">Σ 1 (W ) def = S 1≤j≤n W [j].Σ 1 Σ 2 (W ) def = S 1≤j≤n W [j].Σ 2</formula><p>We write Val for the set of all values, Store for the set of all stores (finite maps from locations to values), and StoreTy for the set of store typings (finite maps from locations to closed types). We write Population for the set of all subsets of Val . Finally, we write S1 # S2 to denote that the sets S1 and S2 are disjoint.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Well-Founded, Well-Formed Worlds and Relations</head><p>Notice that we cannot naïvely construct a set-theoretic model based on the above intentions since the worlds we wish to construct are (effectively) lists of store relations and store relations are themselves parameterized by worlds (as discussed in Section 3.4). If we ignore islands, laws, populations, and store typings for the moment, and simply model worlds as lists of store relations, we are led to the following specification which captures the essence of the problem:</p><formula xml:id="formula_8">StoreRel = P(N × World × Store × Store) World = StoreRel n</formula><p>A simple diagonalization argument shows that the set StoreRel has an inconsistent cardinality (i.e., it is an ill-founded recursive definition). We eliminate the inconsistency by stratifying our definition via the step index. To do so, we first construct candidate sets, which are well-founded sets of our intended form. We then construct proper notions of worlds, islands, laws, store relations, and so on, by filtering the candidate sets through some additional wellformedness constraints.</p><p>Figure <ref type="figure" target="#fig_4">3</ref> (top left) defines our candidate sets by induction on k. First, note that elements of CandAtom k and CandStoreAtom k are tuples with step index j strictly less than k. Hence, our candidate sets are well-defined at all steps. Next, note that elements of CandLawAtom k are tuples with step index j ≤ k. Informally, this is because a k-level law should be able to govern the current knowledge (i.e., the knowledge at the present time when we have k steps left to execute), not just the knowledge in the future when we have strictly fewer steps left.</p><p>While our candidate sets establish the existence of sets of our intended form, our worlds and type relations will need to be wellbehaved in other ways. There are key constraints associated with atoms, types, store relations, knowledge, laws, islands, and worlds that will be enforced in our final definitions. To specify these constraints we need some additional functions and predicates.</p><p>For any set χ and any set ψ, we define the k-approximation of the set (written χ k and ψ k , respectively) as the subset of its elements whose indices are strictly less than k (see Figure <ref type="figure" target="#fig_4">3</ref>, top right). Meanwhile, for any set L, we define the k-approximation of the set (written L k ) as the subset of its elements whose indices are less than or equal to k. We extend these k-approximation notions to knowledge η, islands w, and worlds W (written η k , w k , and W k , respectively) by applying k-approximation to their constituent parts. Note that each of the k-approximation functions yields elements of CandX k where X denotes the appropriate semantic object.</p><p>Next, we define the notion of world extension (see Figure <ref type="figure" target="#fig_4">3</ref>, middle). We write (j, W ) (k, W ) (where is pronounced "extends") if W is a world that is good for k steps (i.e., W ∈ World k , see below), W is a good world for j ≤ k steps (W ∈ World j ), and W extends W j (written W W j ). Recall from Section 3.3 that future worlds accessible from W may have new islands added to the end of the list. Furthermore, for each island w ∈ W j , the island w in the same position in W must extend w. Here we require that w .L = w.L since an island's law cannot be amended in future worlds (see Section 3.3). We also require that w .η w.η, which says that the island's population may grow (w .V ⊇ w.V ), as may the sets of locations that the island cares about (w .Σ1 ⊇ w.Σ1 and w .Σ2 ⊇ w.Σ2). Though it may seem from the definition of knowledge extension in Figure <ref type="figure" target="#fig_4">3</ref> that we do not impose any constraints on w .ψ, this is not the case. As explained in Section 3.3, an island's law should govern what the island's future store relations, populations, and locations of concern may look like. The requirement W ∈ World j (which we discuss below) ensures that the future knowledge w .η obeys the law w .L.</p><p>Figure <ref type="figure" target="#fig_4">3</ref> (bottom) defines our various semantic objects, again by induction on k. These definitions serve to filter their corresponding candidate sets. We proceed now to discuss each of these filtering constraints.</p><p>Following Pitts <ref type="bibr" target="#b19">[20]</ref>, our model is built from syntactically welltyped terms. Thus, we define Atom[τ1, τ2] k as the set of tuples (j, W, e1, e2) where Σ1(W ) e1 : τ1 and Σ2(W ) e2 : τ2, and j &lt; k. (Recall that Σi(W ) denotes the "global" store typing-i.e., the union of the Σi components of all the islands in W .) We also require the world W to be a member of World j .</p><p>We define Type[τ1, τ2] k as those sets χ ⊆ Atom[τ1, τ2] val k that are closed under world extension. Informally, if v1 and v2 are related for k steps in world W , then v1 and v2 should also be related for j steps in any future world W such that (j, W ) is accessible from (i.e., extends) (k, W ). We define StoreRel k as the set of all ψ ⊆ StoreAtom k ⊆ CandStoreAtom k that are closed under world extension. This property is critical in ensuring that we can extend a world with new islands without fear of breaking the store properties from the old islands. Knowledge k is the set of all tuples of the form (ψ, V, Σ1, Σ2) ∈ CandKnowledge k such that ψ ∈ StoreRel k . As mentioned above, the domains of Σ1 and Σ2 contain the locations that an island cares about. What this means is that when determining whether two stores s1 and s2 belong to the store relation ψ, we cannot depend upon the contents of any location in store s1 that is not in dom(Σ1) or on the contents of any location in s2 that is not in dom(Σ2). Thus, Σ1 and Σ2 essentially serve as accessibility maps <ref type="bibr" target="#b6">[7]</ref>. While Benton and Leperchey's accessibility maps are functions from stores to subsets of Loc, our accessibility maps are essentially sets of locations that are allowed to grow over time.</p><p>We define Law k as the set of laws L such that for all (j, η) ∈ L we have that η ∈ Knowledge j . Furthermore, we require that the sets L be closed under decreasing step index-that is, if some knowledge η obeys law L for j steps, then it must be the case that at any future time, when we have i &lt; j steps left, the i-approximation of knowledge η still obeys the law L.</p><p>Island k is the set of all pairs (η, L) ∈ (Knowledge k × Law k ) such that the knowledge η obeys the law L at the current time denoted by step index ki.e., (k, η) ∈ L.</p><p>Finally, we define World k as the set of all W ∈ (Island k ) n . We also require that the sets of locations that each island W [a] cares about are disjoint from the sets of locations that any other island W [b] cares about, thus ensuring separation of islands. Since functions are suspended computations, their relatedness is defined based on the relatedness of computations (characterized by the relation En τ ρ, discussed below). Two functions λx : ρ1(τ ). e1 and λx : ρ2(τ ). e2 are related for k steps in world W at the type τ → τ if, in any future world W where there are j &lt; k steps left to execute and we have arguments v1 and v2 that are related at the argument type τ , the computations [v1/x]e1 and [v2/x]e2 are also related for j steps in world W at the result type τ (i.e., they are in the relation En τ ρ). Intuitively, j &lt; k suffices since beta-reduction consumes a step. Parameterizing over an arbitrary future world W is necessary here in order to ensure closure of the logical relation under world extension.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Relational Interpretations of Types</head><p>Before we can specify when two computations are related, we have to describe what it means for two stores to be related. We write s1, s2 : k W , denoting that the stores s1 and s2 are related for k steps at the world W (see Figure <ref type="figure" target="#fig_5">4</ref>, top), if the stores are well-typed with respect to the store typings Σ1(W ) and Σ2(W ), respectively, and if the stores are considered acceptable by-i.e., they are in the store relations of-all the islands in W at all future times when j &lt; k.</p><formula xml:id="formula_9">s 1 , s 2 : k W def = s 1 : Σ 1 (W ) ∧ s 2 : Σ 2 (W ) ∧ ∀w ∈ W. ∀j &lt; k. (j, W j , s 1 , s 2 ) ∈ w.ψ Vn τ ρ = Vn τ ρ ∩ Atom[ρ 1 (τ ), ρ 2 (τ )] val n Vn α ρ = χ where ρ(α) = (χ, τ 1 , τ 2 ) Vn unit ρ = {(k, W, (), ())} Vn int ρ = {(k, W, v, v) | v ∈ Z} Vn bool ρ = {(k, W, v, v) | v = true ∨ v = false} Vn τ × τ ρ = {(k, W, v 1 , v 1 , v 2 , v 2 ) | (k, W, v 1 , v 2 ) ∈ Vn τ ρ ∧ (k, W, v 1 , v 2 ) ∈ Vn τ ρ} Vn τ → τ ρ = {(k, W, λx : ρ 1 (τ ). e 1 , λx : ρ 2 (τ ). e 2 ) | ∀(j, W ) (k, W ). ∀v 1 , v 2 . (j, W , v 1 , v 2 ) ∈ Vn τ ρ =⇒ (j, W , [v 1 /x]e 1 , [v 2 /x]e 2 ) ∈ En τ ρ} Vn ∀α. τ ρ = {(k, W, Λα. e 1 , Λα. e 2 ) | ∀(j, W ) (k, W ). ∀τ 1 , τ 2 , χ ∈ Type[τ 1 , τ 2 ]. (j, W , [τ 1 /α]e 1 , [τ 2 /α]e 2 ) ∈ En τ ρ[α → (χ, τ 1 , τ 2 )]} Vn ∃α. τ ρ = {(k, W, pack τ 1 , v 1 as ∃α. ρ 1 (τ ), pack τ 2 , v 2 as ∃α. ρ 2 (τ )) | ∃χ ∈ Type[τ 1 , τ 2 ]. (k, W, v 1 , v 2 ) ∈ Vn τ ρ[α → (χ, τ 1 , τ 2 )]} Vn µα. τ ρ = {(k, W, fold v 1 , fold v 2 ) | k &lt; n ∧ ∀j &lt; k. (j, W j , v 1 , v 2 ) ∈ V k [µα. τ /α]τ ρ} Vn ref τ ρ = {(k, W, l 1 , l 2 ) | k &lt; n ∧ w ref (k, ρ, τ, l 1 , l 2 ) ∈ W } w ref (k, ρ, τ, l 1 , l 2 ) = (η, L)</formula><p>where η = (ψ, {}, {l 1 : The relation En τ ρ specifies when two computations are logically related. Two closed, well-typed terms e1 and e2 are related for k steps at the type τ in world W if, given two initial stores s1 and s2 that are related for k steps at world W , if s1, e1 evaluates to s 1 , v1 in j &lt; k steps then the following conditions hold. First, s2, e2 must evaluate to some s 2 , v2 in any number of steps. (For details on why the number of steps e2 takes is irrelevant, see Ahmed <ref type="bibr" target="#b0">[1]</ref>.) Second, there must exist a world W ∈ World k-j that extends the world W . Third, the final stores s 1 and s 2 must be related for the remaining k -j steps at world W . Fourth, the values v1 and v2 must be related for k -j steps in the world W at the type τ . Notice the asymmetric nature of the relation on computations: if s1, e1 terminates, then s2, e2 must also terminate. Hence, our relations Vn τ ρ model logical approximation rather than logical equivalence.</p><formula xml:id="formula_10">ρ 1 (τ )}, {l 2 : ρ 2 (τ )}) ψ = {(j, W , s 1 , s 2 ) | (j, W , s 1 (l 1 ), s 2 (l 2 )) ∈ V k τ ρ} L = {(j, η j ) | j ≤ k} En τ ρ = {(k, W, e 1 , e 2 ) ∈ Atom[ρ 1 (τ ), ρ 2 (τ )]n | ∀j &lt; k. ∀s 1 , s 2 , s 1 , v 1 . s 1 , e 1 -→ j s 1 , v 1 ∧ s 1 , s 2 : k W =⇒ ∃s 2 , v 2 , W . (k -j, W ) (k, W ) ∧ s 2 , e 2 -→ * s 2 , v 2 ∧ s 1 , s 2 : k-j W ∧ (k -j, W , v 1 , v 2 ) ∈ Vn τ ρ} V τ ρ = S n≥0 Vn τ ρ E τ ρ = S n≥0 En τ ρ D • = {∅} D ∆, α = {ρ[α → (χ, τ 1 , τ 2 )] | ρ ∈ D ∆ ∧ χ ∈ Type[τ 1 , τ 2 ]} G • ρ = {(k, W, ∅) | W ∈ World k } G Γ, x : τ ρ = {(k, W, γ[x → (v 1 , v 2 )]) | (k, W, γ) ∈ G Γ ρ ∧ (k, W, v 1 , v 2 ) ∈ V τ ρ} S Σ = {(k, W ) | ∀(l : τ ) ∈ Σ. (k, W, l, l) ∈ V ref τ ∅} ∆; Γ; Σ e 1 log e 2 : τ def = ∆; Γ; Σ e 1 : τ ∧ ∆; Γ; Σ e 2 : τ ∧ ∀k ≥ 0. ∀ρ, γ, W. ρ ∈ D ∆ ∧ (k, W, γ) ∈ G Γ ρ ∧ (k, W ) ∈ S Σ =⇒ (k, W, ρ 1 (γ 1 (e 1 )), ρ 2 (γ 2 (e 2 ))) ∈ E τ ρ ∆; Γ; Σ e 1 ≈ log</formula><p>The cases of the logical relation for ∀α.τ and ∃α.τ are essentially standard. The former involves parameterizing over an arbitrary relational interpretation χ of α, and the latter involves choosing an arbitrary relational interpretation χ of α. The way the worlds are manipulated follows in the style of the other rules. The logical relation for µα.τ is very similar to previous step-indexed accounts of recursive types, as described in Section 3.5. (Note that, although the type gets larger on the r.h.s. of the definition, the step index gets smaller, so the definition is well-founded.)</p><p>Any two locations related at a type ref τ are publicly accessible references. For reasoning about such visible locations, existing logical relations methods usually employ some mechanism that is distinct from the machinery used to reason about local or hidden state. Since there always exists a bijection between the visible locations of the two computations, the mechanism usually involves having a special portion of the world that tracks the bijection between visible locations as well as the type τ of their contents. Unlike previous methods, our worlds have no specialized machinery for reasoning about visible locations. Our technique for modeling (publicly accessible) references is simply a mode of use of our mechanism for reasoning about local state.</p><p>Intuitively, two locations l1 and l2 should be related at the type ref τ in world W for k steps if, given any two stores s1 and s2 that are related for k steps at world W , the contents of these locations, i.e., s1(l1) and s2(l2), are related for k -1 steps at the type τ . To enforce this requirement, we simply install a special island w ref that only cares about the one location l1 in s1 and the one location l2 in s2. Furthermore, w ref has an empty population and a law that says the population should remain empty in future worlds. Finally, the island's fixed store relation ψ relates all stores s1 and s2 whose contents at locations l1 and l2, respectively, are related at type τ for j &lt; k steps. Here j &lt; k suffices since pointer dereferencing consumes a step (see Section 3.5).</p><p>The definitions of logical approximation and equivalence for open terms are given at the bottom of Figure <ref type="figure" target="#fig_5">4</ref>. These definitions rely on the relational semantics ascribed to the contexts ∆, Γ, Σ, which we discuss next.</p><p>We say a type substitution ρ belongs to the relational interpretation of ∆ if dom(ρ) = ∆, and whenever ρ(α) = (χ, τ1, τ2), χ is a well-formed relational interpretation (i.e., χ ∈ Type[τ1, τ2]).</p><p>We let the metavariable γ range of relational value substitutions. These are finite maps from term variables x to pairs of values (v1, v2). If γ(x) = (v1, v2), then γ1(x) denotes v1 and γ2(x) denotes v2. We say γ belongs to the relational interpretation of Γ for k steps at world W (written (k, W, γ) ∈ G Γ ρ, where FTV (Γ) ⊆ dom(ρ)), if dom(γ) = dom(Γ), and the values γ1(x) and γ2(x) are related for k steps in world W at type Γ(x).</p><p>We say a world W satisfies a store typing Σ for k steps (written (k, W ) ∈ S Σ ) if W contains an island of the form w ref (k, ∅, τ, l, l) for each (l : τ ) ∈ Σ-i.e., if l is related to itself for k steps in world W at type ref τ . We write ∆; Γ; Σ e1 log e2 : τ (pronounced "e1 logically approximates e2") to mean that for all k, given a type substitution ρ ∈ D ∆ and a relational value substitution γ such that (k, W, γ) ∈ G Γ ρ, where the world W satisfies Σ for k steps, the closed terms ρ1(γ1(e1)) and ρ2(γ2(e2)) are related for k steps in world W at the type τ . Finally, we say e1 and e2 are logically equivalent, written ∆; Γ; Σ e1 ≈ log e2 : τ , if they logically approximate each other.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Fundamental Property &amp; Soundness of Logical Relation</head><p>Here we state some of the main properties of our logical relation and sketch interesting aspects of the proofs. Further details of the meta-theory are given in the online technical appendix <ref type="bibr" target="#b2">[3]</ref>. An important property of logical approximation is that it is a precongruence, i.e., it is compatible with all the constructs of the language (see e.g., Pitts <ref type="bibr" target="#b19">[20]</ref>). We state these compatibility lemmas, and give detailed proofs of the ones involving references, in the online technical appendix <ref type="bibr" target="#b2">[3]</ref>. The most involved cases are those for allocation (ref) and assignment, which we discuss below. Proofs of compatibility lemmas that do not involve references essentially follow the proofs given in Ahmed <ref type="bibr" target="#b0">[1]</ref>-although we must now deal with additional hypotheses and goals involving stores and worlds, this does not complicate the proofs in any fundamental way.</p><p>The compatibility property for ref says that if ∆; Γ; Σ e1 log e2 : τ then ∆; Γ; Σ ref e1 log ref e2 : ref τ . In the proof, we find ourselves at a point where we have stores s1, s2 : k W and we allocate locations l1 / ∈ dom(s1) and l2 / ∈ dom(s2) to hold the values v1 and v2 respectively (where we know that (k, W, v1, v2) ∈ V τ ρ). To proceed, we define a new world W ∈ World k-1 , which is just W k-1 extended with a new island w ref (k -1, ρ, τ, l1, l2). In addition to showing that W is a valid world, which is straightforward, we must also show that (1)</p><formula xml:id="formula_11">(k -1, W ) (k, W ) and (2) s1[l1 → v1], s2[l2 → v2] : k-1 W .</formula><p>For (1) we need to show that l1 and l2 are distinct from locations that any island w ∈ W "cares about"-that is, l1 / ∈ dom(Σ1(W )) and l2 / ∈ dom(Σ2(W )), which follows easily since l1 and l2 are fresh for s1 and s2. For (2) we must show that for all w ∈ W , and j &lt; k -1, (j, W j , s1[l1 → v1], s2[l2 → v2]) ∈ w .ψ. If w is the new island w ref (k -1, ρ, τ, l1, l2), then the desired result follows from the knowledge that v1 and v2 are logically related. If w is any other island, it must be the (k-1)-th approximation of some island w ∈ W . In this case, the desired result follows from closure of w.ψ under world extension, together with the fact that si and si[li → vi] are identical when restricted to the domain w.Σi.</p><p>The proof of the compatibility lemma for assignment is quite similar to that for ref, except that we do not add a new island to W since we know that W already contains an island w ref (k, ρ, τ, l1, l2) where l1 and l2 are the locations being updated. Soundness To show that the logical relation is sound with respect to contextual approximation, we need an additional property we call store parametricity. This property says that if s : Σ and W ∈ World k is a world comprising one w ref island for each location in Σ-i.e., if Σ = {l1 : τ1, . . . , ln : τn} and W = w1, . . . , wn , where each wi = w ref (k, ∅, τi, li, li))-then s, s : k W .</p><p>Notice that, to prove store parametricity, we need to show that for each (li : τi) ∈ Σ, the value stored at location li in store s is related to itself at the type τi (i.e., (k, W, s(li), s(li)) ∈ V τi ∅). Unfortunately, the latter does not follow from the Fundamental Property, which only allows us to conclude from •; •; Σ s(li) : τi that (k, W, s(li), s(li)) ∈ E τi ∅.</p><p>What we need is the notion of logical value approximation, ∆; Γ; Σ v1 log val v2 : τ , which we define exactly as ∆; Γ; Σ v1 log v2 : τ except that the E τ ρ at the end of that definition is replaced with V τ ρ. Now we can prove that any well-typed value is related to itself in the appropriate value relation V τ ρ, not just in the computation relation E τ ρ as established by the Fundamental Property. Specifically, we show that ∆; Γ; Σ v : τ implies ∆; Γ; Σ v log val v : τ . (The proof is by induction on ∆; Γ; Σ v : τ and for each case the proof is similar to that of the corresponding compatibility lemma.) With this lemma in hand, store parametricity follows easily. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Examples</head><p>In this section we present a number of examples demonstrating applications of our method. Our examples do not make use of recursive types (or even recursion), but Ahmed's prior work, which we build on, gives several examples that do <ref type="bibr" target="#b0">[1]</ref>. We will walk through the proof for the first example in detail. For the remaining ones, we only sketch the central ideas, mainly by giving suitable island definitions and type interpretations. Full proofs for these examples and others appear in the online technical appendix <ref type="bibr" target="#b2">[3]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Name Generator</head><p>Our first example is perhaps the simplest possible state-dependent ADT, a generator for fresh names. Nevertheless, it captures the essence of the Symbol example from the introduction:</p><formula xml:id="formula_12">e = let x = ref 0 in pack int, λz : unit. (++x), λz : int. (z ≤ !x) as σ</formula><p>where σ = ∃α. (unit → α) × (α → bool) and (++x) abbreviates the expression (x := !x+1; !x), and let is encoded in the standard way (using function application). The package defines an abstract type α of names and provides two operations: the first one returns a fresh name on each invocation, and the second one checks that any value of type α it is given is a "valid" name, i.e., one that was previously generated by the first operation. Names are represented as integers, and the local counter x stores the highest value that has been used so far. The intended invariant of this implementation is that no value of type α ever has a representation that is greater than the current content of x. Under this invariant, we should be able to prove that the second operation, which dynamically checks this property, always returns true.</p><p>To prove this, we show that e is equivalent to a second expression e , identical to e, except that the dynamic check (z ≤ !x) is eliminated and replaced by true. We only show the one direction, e log e : σ. The other direction is proven analogously.</p><p>Because the terms are closed, this only requires showing that (k0, W0, e, e ) ∈ E σ ∅ for all k0 ≥ 0 and worlds W0. Assume stores s0, s 0 : k 0 W0 and the existence of a reduction sequence s0, e -→ k 1 s1, v1 with k1 &lt; k0. According to the definition of E σ ∅, we need to come up with a reduction s 0 , e -→ * s 1 , v 1 and a world W1 such that (k0 -k1, W1) (k0, W0) and:</p><formula xml:id="formula_13">s1, s 1 : k 0 -k 1 W1 ∧ (k0 -k1, W1, v1, v 1 ) ∈ V σ ∅</formula><p>By inspecting the definition of reduction, we see that s1 = s0[l → 0], v1 = pack int, λz.(++l), λz.(z ≤ !l) as σ for some l / ∈ dom(s0). In the same manner, s 0 , e obviously can choose some l / ∈ dom(s 0 ) and reduce to:</p><formula xml:id="formula_14">s 1 = s 0 [l → 0], v 1 = pack int, λz.(++l ), λz.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>true as σ</head><p>We now need to define a suitable island that enables us to show that v1 and v 1 are related. We know W0 has the form w1, . . . , wp for some p. Let W1 be W0 k 0 -k 1 , extended with a new island, wp+1, defined as follows:</p><formula xml:id="formula_15">wp+1 = (η 0 k 0 -k 1 , L k 0 -k 1 ) η n k = (ψ n k , Vn, {l : int}, {l : int}) ψ n k = {(j, W, s, s ) ∈ StoreAtom k | s(l) = s (l ) = n} Vn = {i | 1 ≤ i ≤ n} L k = {(j, η n j ) ∈ LawAtom k | n ∈ N}</formula><p>The population Vn consists of all integers that are "valid" names in the current world, i.e., not greater than the current value of x. We have to show (k0 -k1, W1) (k0, W0) and s1, s 1 :</p><formula xml:id="formula_16">k 0 -k 1 W1. Both are straightforward.</formula><p>By definition of V ∃α.τ , we need to continue by giving a relation χα ∈ Type[int, int], such that:</p><formula xml:id="formula_17">(k0 -k1, W1, λz.(++l), λz.(z ≤ !l) , λz.(++l ), λz.true ) ∈ V (unit → α) × (α → bool) ρ with ρ = [α → (χα, int, int)].</formula><p>We choose the following one:</p><formula xml:id="formula_18">χα = {(j, W, i, i) ∈ Atom[int, int] | i ∈ W [p + 1].V }</formula><p>This interpretation of α depends on the (valid) assumption that it will only be considered at W 's that are future worlds of W1 (in particular, it assumes that the (p+1)-th island in W , written</p><formula xml:id="formula_19">W [p + 1]</formula><p>, is a future version of the wp+1 we defined above). We could build this assumption explicitly into the definition of χα, but as we will see it is simply not necessary to do so. By virtue of this assumption, a value i is only a valid inhabitant of type α in worlds whose (p+1)-th island population contains i, that is, where !l ≥ i.</p><p>Note that the relation is closed under world extension because V may only grow over time, as explained in Section 3.3. By definition of V τ × τ , it remains to be shown that:</p><formula xml:id="formula_20">1. (k0 -k1, W1, λz.(++l), λz.(++l )) ∈ V unit → α ρ 2. (k0 -k1, W1, λz.(z ≤ !l), λz.true) ∈ V α → bool ρ</formula><p>For each of these, we assume we begin in some strictly future world W2 in which (k2, W2) (k0 -k1, W1) and s2, s 2 : k 2 W2. First consider <ref type="bibr" target="#b0">(1)</ref>. We are given s2, (++l) -→ k 3 s3, v3 for some k3 &lt; k2, and it remains to show that s 2 , (++l ) -→ * s 3 , v 3 , such that s3, s 3 and v3, v 3 are related in some future world W3 such that (k2 -k3, W3) (k2, W2).</p><p>From (k2, W2) (k0 -k1, W1) we know that W2</p><formula xml:id="formula_21">[p + 1].L = W1[p + 1].L k 2 = L k 2 . From that (k2, W2[p + 1].η) ∈ L k 2</formula><p>follows, and hence there exists n such that W2</p><formula xml:id="formula_22">[p+1].η = η n k 2 . That is, W2[p+1].ψ = ψ n k 2 and W2[p+1].V = Vn. From s2, s 2 : k 2 W2 and k3 &lt; k2 we can conclude (k3, W2 k 3 , s2, s 2 ) ∈ ψ n k 2 and thus s2(l) = s 2 (l ) = n. Consequently, v3 = v 3 = n + 1, s3 = s2[l → n + 1], and s 3 = s 2 [l → n + 1]. Now we choose W3 to be W2 k 2 -k 3 with its (p + 1)-th island updated to (η n+1 k 2 -k 3 , L k 2 -k 3 )</formula><p>. Again, we have to check the relevant properties, (k2 -k3, W3) (k2, W2) and s3, s 3 : k 2 -k 3 W3, which are straightforward. Last, we have to show that the results v3, v 3 are related in V α ρ under this world, i.e., (k2-k3, W3, n+</p><formula xml:id="formula_23">1, n + 1) ∈ χα. Since n + 1 ∈ Vn+1 = W3[p + 1].V , this is immediate from the definition of χα.</formula><p>Now consider <ref type="bibr" target="#b1">(2)</ref>. The proof is similar to that for part (1), but simpler. We are given that (k2, W2, v2, v 2 ) ∈ V α ρ = χα, and s2, (v2 ≤ !l) -→ k 3 s3, v3 for some k3 &lt; k2. The main thing to show is that v3 = true (we can pick the end world W3 to just be W2 k 2 -k 3 ). As in part (1), we can reason that W2</p><formula xml:id="formula_24">[p + 1].η = η n k 2</formula><p>for some n, and therefore that s2(l) = n and, by definition of χα, also that v2 ≤ n. Hence, v2 ≤ s2(l), and the desired result follows easily.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Using ref As a Name Generator</head><p>An alternative way to implement a name generator is to represent names by locations and rely on generativity of the ref operator. </p><formula xml:id="formula_25">(unit → α) × (α × α → bool).</formula><p>Here, the second function implements a proper equality operator on names. We want to prove this implementation contextually equivalent to one using integers, as in the previous example:</p><formula xml:id="formula_26">e = let x = ref 0 in pack int, λz : unit. (++x), λp : (int × int). (fst p = snd p) as σ</formula><p>Here are a suitable island definition and type interpretation for α:</p><formula xml:id="formula_27">wp+1 = (η k 0 , L k 0 ) η l 1 ,...,ln k = (ψ n k , V l 1 ,...,ln , {li : unit | 1 ≤ i ≤ n}, {l : int}) ψ n k = {(j, W, s, s ) ∈ StoreAtom k | s (l ) = n} V l 1 ,...,ln = { li, i | 1 ≤ i ≤ n} L k = {(j, η l 1 ,...,ln j ) ∈ LawAtom k | n ∈ N} χα = {(j, W, l, i) ∈ Atom[ref unit, int] | l, i ∈ W [p + 1].V }</formula><p>Here, and in the examples that follow, k0 represents the current step level, and p the number of islands in the current world W0, at the point in the proof where we extend W0 with the island wp+1 governing the example's local state. In this example, we assume that all labels in a list l1, . . . , ln are pairwise disjoint, and l is a distinguished label, namely the one that has been allocated for x (as in the previous example). In the definitions above, the population not only records the valid names for e (as in Section 5.1), but also relates them to the locations allocated by e. The latter are not guessable ahead of time, due to nondeterminism of memory allocation, but the law L k is flexible enough to permit any partial bijection between {1, . . . , n} and Loc to evolve over time. We (ab)use term-level pairs l, i to encode this partial bijection in V . This is sufficient to deduce i = j iff li = lj when proving equivalence of the equality operators.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Twin Abstraction</head><p>Another interesting variation on the generator theme involves the definition of two abstract types (we write pack τ1, τ2, e as ∃α, β.τ to abbreviate two nested existentials in the obvious way):</p><formula xml:id="formula_28">e = let x = ref 0 in pack int, int, λz : unit. (++x), λz : unit. (++x), λp : (int × int). (fst p = snd p) as σ where σ = ∃α, β. (unit → α) × (unit → β) × (α × β → bool).</formula><p>Here we use a single counter to generate names of two types, α and β, and a comparison operator that takes as input names of different type. Because both types share the same counter, it appears impossible for a name to belong to both types (either it was generated as a name of type α or of type β but not of both). The example is interesting, however, in that we have no way of knowing the interpretations of α and β ahead of time, since calls to the name generation functions can happen in arbitrary combinations. We can verify our intuition by proving that e is equivalent to an e where the comparison operator is replaced by λp : (int × int). false.</p><p>The following w and χ definitions enable such a proof:</p><formula xml:id="formula_29">wp+1 = (η 0,∅ k 0 , L k 0 ) η n,S k = (ψ n k , Vn,S, {l : int}, {l : int}) ψ n k = {(j, W, s, s ) ∈ StoreAtom k | s(l) = s (l ) = n} Vn,S = { 1, i | i ∈ S} ∪ { 2, i | i ∈ {1, . . . , n} \ S} L k = {(j, η n,S j ) ∈ LawAtom k | n ∈ N ∧ S ⊆ {1, . . . , n}} χα = {(j, W, i, i) ∈ Atom[int, int] | 1, i ∈ W [p + 1].V } χ β = {(j, W, i, i) ∈ Atom[int, int] | 2, i ∈ W [p + 1].V }</formula><p>The population here is partitioned into the valid names for α and the valid names for β, basically recording the history of calls to the two generator functions. To encode such a disjoint union in V , each value is wrapped in a pair with the first component marking the type it belongs to (1 for α, 2 for β). When proving equivalence of the two comparison operators, the definitions of χα, χ β and W [p + 1].V directly imply that the arguments must be from disjoint sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Cell Class</head><p>The next example is a more richly-typed variation of the higherorder cell object example of Koutavas and Wand <ref type="bibr" target="#b12">[13]</ref>:</p><formula xml:id="formula_30">e = Λα. pack ref α, λx : α. ref x, λr : ref α. !r, λ r, x : ref α × α. (r := x) as σ where σ = ∃β. (α → β) × (β → α) × (β × α → unit).</formula><p>We use pattern matching notation here merely for clarity and brevity (imagine replacing occurrences of r and x in the third function with fst and snd projections, respectively, of the argument). This example generalizes Koutavas and Wand's original version in two ways. First, we parameterize over the cell content type α, which can of course be instantiated with an arbitrary higher type, thus exercising our ability to handle higher-order stored values. Second, instead of just implementing a single object, our example actually models a class, where β represents the abstract class type, and the first function acts as a constructor for creating new cell objects. (A subsequent paper by Koutavas and Wand also considers a class-based version of their original example <ref type="bibr" target="#b13">[14]</ref>, but it is modeled with a Java-like nominal type system, not with existential types.)</p><p>Similar to <ref type="bibr" target="#b12">[13]</ref>, we want to prove this canonical cell implementation equivalent to one using two alternating slots:</p><formula xml:id="formula_31">e = Λα. pack (ref int × (ref α × ref α)), λx : α. ref 1, ref x, ref x , λ r0, r1, r2 : (ref int × (ref α × ref α)). if !r0 = 1 then !r1 else !r2, λ r0, r1, r2 , x : (ref int × (ref α × ref α)) × α.</formula><p>if !r0 = 1 then (r0 := 2; r2 := x) else (r0 := 1; r1 := x) as σ</p><p>When e or e is instantiated with a type argument, neither one immediately allocates any new state. Correspondingly, no island is introduced at that point in the proof. Rather, a new island is added to the world at each call to the classes' constructor functions, for it is at that point when fresh state is allocated in both programs.</p><p>So, assuming we have been given a relational interpretation χα ∈ Type[τα, τ α ] for the type parameter α, consider the proof that the constructor functions are logically related. When the constructors are called, we allocate fresh state: l in the first program, and l 0 , l 1 , l 2 in the second program. For convenience, we will package these together notationally as ls = l, l 0 , l 1 , l 2 . We now extend the current world W with wp+1, defined as follows:</p><formula xml:id="formula_32">wp+1 = (η ls k 0 , L ls k 0 ) η ls k = (ψ ls k , {ls}, {l : τα}, {l 0 : int, l 1 : τ α , l 2 : τ α }) ψ ls k = {(j, W, s, s ) ∈ StoreAtom k | ∃i ∈ {1, 2}. s (l 0 ) = i ∧ (j, W, s(l), s (l i )) ∈ χα} L ls k = {(j, η ls j ) | j ≤ k}</formula><p>The store relation ψ ls k ensures that the contents of l are related (by χα) to the contents of the proper slot l 1 or l 2 , depending on the current flag value stored in l 0 . Note how the definition of ψ ls k relies crucially on the presence of the world parameter W . Without it, we would not know in which world to compare s(l) and s (l i ). Note also that in this example wp+1 does not evolve (i.e., its store relation remains the same in all future worlds).</p><p>Finally, when proving equivalence of the existential packages, we represent the cell class type β with χ β defined as follows:</p><formula xml:id="formula_33">χ β = {(j, W, l, l 0 , l 1 , l 2 ) | W ∈ World j ∧ ∃w ∈ W. w = (η ls j , L ls j )</formula><p>, where ls = l, l 0 , l 1 , l 2 } Note that χ β includes ls's owned by any island of the right form. This might add some "junk" to the relation (e.g., objects that were created by some other class's constructor function), but any such junk is harmless since it adheres to the same invariants that the objects created by e and e do.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Irreversible State Changes</head><p>A well-known example that has caused trouble for previous logical relations methods is Pitts and Stark's "awkward" example <ref type="bibr" target="#b20">[21]</ref>. Although this example does not involve existentials, it has proven difficult to handle because it involves an irreversible state change: The idea here is that e and e are equivalent because, as soon as they are applied, the contents of x are set to 1, after which point !x will always return 1. In other words, the first application of e marks an irreversible state change from x → 0 to x → 1.</p><p>Intuitively, irreversible state changes are hard to handle if the knowledge about a piece of local state is fixed once and for all at the point it is allocated. Using traditional possible-worlds models, the most precise invariant one can enforce about the contents of x is that they are either 0 or 1. With such a weak invariant, it is impossible to know when returning from f () whether !x is still 1.</p><p>Using populations, however, we can prove the equivalence of e and e quite easily. A suitable island definition is:</p><formula xml:id="formula_34">wp+1 = (η ∅ k 0 , L k 0 ) η V k = (ψ V k , V, {lx : int}, {}) ψ V k = {(j, W, s, s ) ∈ StoreAtom k | s(lx) = |V |} L k = {(j, η V j ) | j ≤ k ∧ |V | ≤ 1}</formula><p>The intuition here is that we use V to encode a flag telling us whether x has already been set to 1. Initially, !x is 0, signified by V = ∅. When x is set to 1, we add some arbitrary value to V , making it a singleton set of size 1. Because V is only allowed to grow, we know that x can never be changed back to 0. In addition, since the law L k requires |V | ≤ 1, x must remain at 1 permanently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Callback with Lock</head><p>The proofs for the examples presented so far do not use step indices in an interesting way. The last of our examples, which is inspired by the reentrant callback example of Banerjee and Naumann <ref type="bibr" target="#b5">[6]</ref>, demonstrates an unexpected case where the steps come in handy. Relying as it does on subtle stepwise reasoning, our proof for this example is rather involved (some might say ugly), but like a dog walking on its hind legs, one is surprised to find it done at all.</p><p>Consider the following object encoding of higher-order type τ = ((unit → unit) → unit) × (unit → int):</p><formula xml:id="formula_35">e = C[f (); x := !x + 1]</formula><p>where</p><formula xml:id="formula_36">C = let x = ref 0 in λf : unit → unit. [•], λz : unit. !x</formula><p>It implements a counter object with two methods: an increment function, and a get function requesting the current counter value. An interesting feature of this object is that its increment method takes a callback argument, which is invoked before the counter is incremented. Now, consider the following alternative implementation for this object, in which x is dereferenced before the callback:</p><formula xml:id="formula_37">e = C[let n = !x in f (); x := n + 1]</formula><p>One might naïvely assume that the two versions are equivalent, because x is not publicly accessible. But f might perform arbitrary operations, including recursively calling the increment function! In this case, x may be modified between read and write access in e .</p><p>Such reentrance can be prevented by adding a lock: With C reimplemented using a lock, e and e are now contextually equivalent. But how do we go about actually proving this? To show the two increment functions equivalent, we need to establish that f cannot modify x. But how can we set up an island that ensures that? After all, the island's law must certainly allow updates to x in general. How can we formulate a law that allows the store to change, but still can temporarily prohibit it?</p><formula xml:id="formula_38">C = let b = ref</formula><p>Steps to the rescue! When proving that the two increment functions are related, we assume that one terminates with j steps. Assuming b is set to true (i.e., assuming that x is "unlocked"), we can partition the reduction sequence for its execution into 3 phases of length j1 +j2 +j3 = j, where j2 spans the steps spent in the call to f . These j2 steps are the time window in which x is not allowed to change. So the idea is to define a law that allows setting up time windows of this kind, during which !x must remain constant.</p><p>The following island definition does the trick:</p><formula xml:id="formula_39">wp+1 = (η { k 0 ,k 0 ,0 } k 0 , L k 0 ) η V k = (ψ min(V ) k , V, {l b : bool, lx : int}, {l b : bool, l x : int}) ψ k 1 ,k 2 ,n k = {(j, W, s, s ) ∈ StoreAtom k | (j ≤ k1 ∧ s(l b ) = s (l b ) ∧ s(lx) = s (l x )) ∧ (j ≥ k2 ⇒ (s(l b ) = false ∧ s(lx) = n))} L k = {(j, η V j ) ∈ LawAtom k | V = { k1, k 1 , n1 , . . . , km, k m , nm } ∧ k1 ≥ k 1 &gt; k2 ≥ • • • ≥ k m-1 &gt; km ≥ k m }</formula><p>Each window is represented by a triple k1, k2, n in V (assuming the obvious encoding of triples using pairs), with k1 and k2 giving its first (upper) and last (lower) step, and n being the value to which x is fixed during the window. The side condition in L k ensures that windows do not overlap. Consequently, there is always a unique lowest (newest) window min(V ) = k1, k2, n , i.e., the one with the least first projection (the k1). The store relation ψ ensures that, if the step level j has not yet passed the lower bound k2 of the newest window (i.e., if j ≥ k2), then !x must equal the n from that window, and the lock must be held. The definition of ψ also prohibits windows from starting in the future by requiring j ≤ k1.</p><p>To prove equivalence of the increment functions, starting at step k with s0(lx) = s 0 (l x ) = n and s0(l b ) = s 0 (l b ) = true (the interesting case), we proceed in j1 steps to set b to false, and then add a new lowest window k -j1, k -j1 -j2 -1, n to the population of the (p+1)-th island. Next, we know f () returns after exactly j2 steps in some future world W , and the stores s1 and s 1 that it returns must be related by W at step m = k -j1 -j2, which means that (m -1, W m-1, s1, s 1 ) ∈ W [p + 1].ψ. Since the step level m -1 is still in the range of the window we installed, we know that f () could not have added an even lower window to the population of the (p+1)-th island (as the law disallows adding windows that start in the future). Thus, we know that W</p><formula xml:id="formula_40">[p+1].ψ = ψ m+j 2 ,m-1,n m</formula><p>, and consequently s1(lx) = s 1 (l x ) = n and s1(l b ) = s 1 (l b ) = false. That is, thanks to our use of the lock, the call to f () could not have affected our local state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7">Well-Bracketed State Changes</head><p>To conclude, we give two examples that our method appears unable to handle. The first one, suggested to us by Jacob Thamsborg, is a variant of Pitts and Stark's "awkward" example (Section 5.5):</p><formula xml:id="formula_41">e = let x = ref 0 in λf : (unit → unit). (x := 0; f (); x := 1; f (); !x) e = λf : (unit → unit). (f (); f (); 1)</formula><p>Here, unlike in the "awkward" example, the state of x changes back and forth between 0 and 1. The reason we believe e and e to be equivalent (we do not have a proof!) is that the state changes occur in a "well-bracketed" fashion -i.e., every change to 0 is guaranteed to be followed later on in the computation by a change to 1. This implies (informally) that invoking the callback function f will either leave the state of x unchanged or will return control with x set to 1. However, it is not clear to us how to formally establish this. The trick of representing irreversible state changes via population growth is inapplicable since the state changes are not irreversible, and the time windows idea from Section 5.6 is inapplicable as well since the example does not make use of locks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.8">Deferred Divergence</head><p>Here is another example we cannot handle, due to Hongseok Yang:</p><formula xml:id="formula_42">2 e1 = λf : (unit → unit) → unit. f (λz : unit. diverge) e2 = λf : (unit → unit) → unit. let x = ref 0 in let y = ref 0 in f (λz : unit. if !x = 0 then y := 1 else diverge); if !y = 0 then x := 1 else diverge</formula><p>Here, f may either call its argument directly, in which case the computation clearly diverges (in e2 this happens eventually because y is set to 1), or it may store its argument in some ref cell. In the latter case, any subsequent call to the stored argument by the program context will also cause divergence (in the case of e2, because x will be 1 at that point). Only if neither f nor the context ever tries to call f 's argument may the computation terminate.</p><p>For us to prove e1 and e2 equivalent, we would need some way of relating the two arguments to f . Initially, however, when the arguments are invoked, one terminates and the other does not, so it is not obvious how to relate them. In fact, they are only related under the knowledge of what e1 and e2 will do after the call to f . This suggests to us that one way to handle such an example might be to define a relation on terms coupled with their continuations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Related and Future Work</head><p>There is a vast body of work on methods for reasoning about local state and abstract data types. In the interest of space, we only cite a representative fraction of the most closely related recent work.</p><p>Logical Relations Our work continues (and, to an extent, synthesizes) two lines of recent work: one on using logical relations to reason about type abstraction in more realistic languages, the other on using logical relations to reason about local state.</p><p>Concerning the former, Pitts <ref type="bibr" target="#b19">[20]</ref> provides an excellent overview, although it is now slightly outdated -in the last few years, several different logical relations approaches have been proposed for handling general recursive (as well as polymorphic) types <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b10">11]</ref>, which Pitts considers an open problem. Much of the work on this topic is concerned with logical relations that are both sound and complete with respect to contextual equivalence. Completeness is useful for establishing various extensionality properties at different types, e.g., that two values of type ∀α.τ are contextually equivalent iff their instantiations at any particular type τ are equivalent. In general, however, just because a method is complete with respect to contextual equivalence does not mean that it is effective in proving all contextual equivalences. In fact, Pitts gives a representation independence example for which existing techniques are "effectively" incomplete. <ref type="foot" target="#foot_2">3</ref>For a logical relation to be complete it must typically be what Pitts terms "equivalence-respecting." There are different ways to achieve this condition, such as -closure <ref type="bibr" target="#b19">[20]</ref>, biorthogonality <ref type="bibr" target="#b15">[16]</ref>, or working with contextual equivalence classes of terms <ref type="bibr" target="#b10">[11]</ref>. Pitts' -closure neatly combines the equivalencerespecting property together with admissibility (or continuity, necessary for handling recursive functions) into one package.</p><p>We build on the work of Ahmed <ref type="bibr" target="#b0">[1]</ref> on step-indexed logical relations for recursive and quantified types. One advantage of the step-indexed approach is that admissibility comes "for free," in the sense that it is built directly into the model. By only ever reasoning about finite approximations of the logical relation (Vn τ ρ), we avoid the need to ever prove admissibility. (In other words, an inadmissible relation is indistinguishable from an admissible one if one only ever examines its step-indexed approximations.) Of course, the price one pays for this is that one is forced to use stepwise reasoning everywhere, so admissibility is not really "free" after all. To ameliorate this burden, we are currently investigating techniques for proving logical approximation in our model without having to do explicit stepwise reasoning. As we saw in Section 5.6, though, sometimes the presence of the step indices can be helpful. Like Ahmed's previous work, our logical relation is sound, but not complete, with respect to contextual equivalence. (Hers is complete except for the case of existential types. <ref type="foot" target="#foot_3">4</ref> ) While our method cannot in its current form prove extensionality properties of con-textual equivalence, it is still useful for proving representation independence results, which is our primary focus. Recent work by Ahmed and Blume <ref type="bibr" target="#b1">[2]</ref> involves a variant of <ref type="bibr" target="#b0">[1]</ref> that is complete with respect to contextual equivalence, where completeness is obtained by essentially Church-encoding the logical interpretation of existentials (this is roughly similar to what -closure does, too). We are currently attempting to develop a complete version of our method, using a similar approach to Ahmed and Blume.</p><p>Concerning the second line of work -logical relations for reasoning about local state -most of the recent previous work we know of employs possible-worlds models of the sort we discussed in Section 3.2, so we refer the reader to that earlier section for a thorough comparison <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b9">10]</ref>. However, there are two recent pieces of work that are worth discussing in further detail.</p><p>Perhaps the closest related work to ours is Nina Bohr's PhD thesis <ref type="bibr" target="#b8">[9]</ref>, which extends her work with Lars Birkedal <ref type="bibr" target="#b9">[10]</ref> in two directions. First, she gives a denotational possible-worlds model for a language with general recursive types, polymorphism, and higher-order references, with the restriction that references must have closed type. This restriction seems to imply that her method is inapplicable to the cell class example in Section 5.4 because it involves references of type ref α. Second, she proposes a more refined (and complex) notion of possible world in which an island's store relation has the ability to change over time. This is similar in certain ways to our population technique, except that her islands do not contain anything resembling a population. Her approach is designed to handle examples involving irreversible state changes, like Pitts and Stark's "awkward" example (Section 5.5), but not generative ADTs (Sections 5.1-5.3). Bohr's possible worlds also include the ability to impose invariants on the continuations of related terms, so we believe her technique can handle at least one, if not both, of the examples in Section 5.7 and 5.8, which we cannot.</p><p>In a paper conceived concurrently with ours, Birkedal, Støvring, and Thamsborg <ref type="bibr" target="#b7">[8]</ref> present a relationally parametric denotational model of a language with general recursive types, polymorphism, and references of arbitrary type. Their model improves on Bohr's in the flexibility of its references, but it offers only a weak notion of possible worlds, with which one can only do very simple reasoning about local state. Their model cannot handle any of our examples.</p><p>Bisimulations For reasoning about contextual equivalences (involving either type abstraction or local state), one of the most successful alternatives to logical relations is the coinductive technique of bisimulations. Pierce and Sangiorgi <ref type="bibr" target="#b18">[19]</ref> define a bisimulation for reasoning about polymorphic π-calculus, and they demonstrate its effectiveness on an example that is similar to our symbol table example. Due to the low-level, imperative nature of the π-calculus, it is difficult to give a precise comparison between their technique and ours, but the basic idea of their technique (described below) has been quite influential on subsequent work.</p><p>Sumii and Pierce define bisimulations for an untyped language with a dynamic sealing operator <ref type="bibr" target="#b26">[27]</ref>, as well as an extension of System F with general recursive types <ref type="bibr" target="#b27">[28]</ref>. Koutavas and Wand <ref type="bibr" target="#b12">[13]</ref> adapt the Sumii-Pierce technique to handle an untyped higher-order language with general references; in the process, they improve on Sumii-Pierce's treatment of contextual equivalences involving higher-order functions. Interestingly, the Koutavas-Wand technique involves the use of inductive stepwise reasoning when showing that two functions are in the bisimulation. Subsequently, Sangiorgi, Kobayashi, and Sumii <ref type="bibr" target="#b25">[26]</ref> propose environmental bisimulations, which generalize Sumii and Pierce's previous work to an untyped framework subsuming that of Koutavas-Wand's, but in a way that does not appear to require any stepwise reasoning. While all of these bisimulation approaches are sound and complete with respect to contextual equivalence, none handles a language with both existential type abstraction and mutable state.</p><p>There are many similarities between bisimulations and logical relations, although a precise comparison of the techniques remains elusive (and an extremely interesting direction for future work). With bisimulations, one defines the relational interpretations of abstract types, or the invariants about local state, up front, as part of a relation also containing the terms one wishes to prove contextually equivalent, and then one proceeds to show that the relation one has defined is in fact a bisimulation. With logical relations, the proof proceeds backward in a structured way from the goal of showing two terms logically equivalent, and the invariants about type representations or local state are chosen in mid-proof. It is arguably easier to sketch a bisimulation proof (by just stating the bisimulation), whereas the islands and χ definitions in our proof sketches must be stated in medias res. On the other hand, our islands and χ's are more minimal than bisimulations, which must often explicitly include a number of redundant intermediate proof steps.</p><p>The Sumii-Pierce-Koutavas-Wand-Sangiorgi-Kobayashi-Sumii approach is roughly to define bisimulations as sets of relations, with each relation tied to a particular environment, e.g., a type interpretation, a pair of stores, etc. Various "up-to" techniques are used to make bisimulations as small as possible. This approach seems conceptually similar to possible-worlds semantics, but the exact relationship is unclear, and we plan to explore the connection further in future work.</p><p>Separation Logic To reason about imperative programs in a localized manner, O'Hearn, Reynolds et al. introduced separation logic <ref type="bibr" target="#b23">[24]</ref> as an extension to Hoare logic. Separation logic has been enormously influential in the last few years, but it has not to our knowledge been used to reason about higher-order typed functional languages with type abstraction and higher-order store. Notably, however, the desire to scale separation logic to reason about a functional programming language has led to Hoare Type Theory (HTT) <ref type="bibr" target="#b17">[18]</ref>. HTT is a dependently typed system where computations are assigned a monadic type in the style of a Hoare triple. Under this approach, programs generally have to pass around explicit proof objects to establish properties. Currently, HTT only handles strong update (where a location's type can vary over time), not MLstyle references with weak update (and thus stronger invariants).</p><p>Relational Reasoning About Classes There is a large body of work on reasoning techniques for object-oriented languages. For example, Banerjee and Naumann <ref type="bibr" target="#b4">[5]</ref> present a denotational method for proving representation independence for a Java-like language. Koutavas and Wand <ref type="bibr" target="#b13">[14]</ref> have adapted their bisimulation approach to a subset of Java. The languages considered in these works do not provide generativity and first-class existential types, but rather tie encapsulation to static class definitions. On the other hand, subsequent work by Banerjee and Naumann <ref type="bibr" target="#b5">[6]</ref> addresses the issue of ownership transfer, which we do not. We believe that the generativity of existential quantification and the separation enforced by possible-island semantics are closely related to various notions of ownership and ownership types, but we leave the investigation of this correspondence to future work.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Generativity Example</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Types</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Terms e ::= x | () | l | ±n | o(e 1 , . . . , en) | true | false | if e then e 1 else e 2 | e 1 , e 2 | fst e | snd e | λx : τ. e | e 1 e 2 | Λα. e | e [τ ] | pack τ, e as ∃α. τ | unpack e 1 as α, x in e 2 | fold e | unfold e | ref e | !e | e 1 := e 2 | e 1 == e 2 Values v ::</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. F µ! Syntax + Dynamic and Static Semantics (excerpts)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Auxiliary Definitions: Candidate Sets, k-Approximation, World Extension, and Well-Formedness Conditions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 (</head><label>4</label><figDesc>Figure 4 (top)  gives the definition of our logical relations for F µ! . The relations Vn τ ρ are defined by induction on n and nested induction on the type τ . We use the metavariable ρ to denote type substitutions. A type substitution ρ is a finite map from type variables α to triples (χ, τ1, τ2) where τ1 and τ2 are closed types, and χ is a relational interpretation in Type[τ1, τ2]. If ρ(α) = (χ, τ1, τ2), then ρ1(α) denotes τ1 and ρ2(α) denotes τ2.Note that, by the definition of Vn τ ρ, if (k, W, v1, v2) ∈ Vn τ ρ, then k &lt; n, W ∈ World k , and Σ1(W ) v1 : ρ1(τ ) and Σ2(W ) v2 : ρ2(τ ). Most of the relations Vn τ ρ are straightforward. For instance, the logical relation at type int says that two integers are logically related for any number of steps k and in any world W as long as they are equal. The relations for the other base types unit and bool are similar. The logical relation at type τ × τ says that two pairs of values are related for k steps in world W if their first and second components are related (each for k steps in world W ) at types τ and τ respectively.Since functions are suspended computations, their relatedness is defined based on the relatedness of computations (characterized by the relation En τ ρ, discussed below). Two functions λx : ρ1(τ ). e1 and λx : ρ2(τ ). e2 are related for k steps in world W at the type τ → τ if, in any future world W where there are j &lt; k steps left to execute and we have arguments v1 and v2 that are related at the argument type τ , the computations [v1/x]e1 and [v2/x]e2 are also related for j steps in world W at the result type τ (i.e., they are in the relation En τ ρ). Intuitively, j &lt; k suffices since beta-reduction consumes a step. Parameterizing over an arbitrary future world W is necessary here in order to ensure closure of the logical relation under world extension.Before we can specify when two computations are related, we have to describe what it means for two stores to be related. We write s1, s2 : k W , denoting that the stores s1 and s2 are related for k steps at the world W (see Figure4, top), if the stores are well-typed with respect to the store typings Σ1(W ) and Σ2(W ), respectively, and if the stores are considered acceptable by-i.e., they are in the store relations of-all the islands in W at all future times when j &lt; k.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Step-Indexed Logical Relations for F µ!</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Lemma 4 . 1 (</head><label>41</label><figDesc>Closure Under World Extension)Let ∆ τ and ρ ∈ D ∆ . If (k, W, v1, v2) ∈ Vn τ ρ and (j, W ) (k, W ), then (j, W , v1, v2) ∈ Vn τ ρ.Proof: By induction on n and nested induction on ∆ τ .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Theorem 4 . 2 (</head><label>42</label><figDesc>Fundamental Property) If ∆; Γ; Σ e : τ then ∆; Γ; Σ e log e : τ . Proof: By induction on the derivation of ∆; Γ; Σ e : τ . Each case follows from the corresponding compatibility lemma.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Theorem 4 . 3 (</head><label>43</label><figDesc>Soundness w.r.t. Contextual Approximation) If ∆; Γ; Σ e1 log e2 : τ then ∆; Γ; Σ e1 ctx e2 : τ . Proof: Suppose C : (∆; Γ; Σ τ ) ⇒ (•; •; Σ τ ), s : Σ , and s, C[e1] -→ k s1, v1. We must show that s, C[e2] ⇓. If Σ = {l1 : τ1, . . . , ln : τn}, let W = w1, . . . , wn , where each wi = w ref (k + 1, ∅, τi, li, li). By the compatibility lemmas, we can show •; •; Σ C[e1] log C[e2] : τ . Hence, noting that (k+1, W ) ∈ S Σ , we have (k+1, W, C[e1], C[e2]) ∈ E τ ∅. Since s, s : k+1 W (by store parametricity) and s, C[e1] -→ k s1, v1 (from the premise), it follows that s, C[e2] ⇓.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>e</head><label></label><figDesc>= pack ref unit, λz : unit. (ref ()), λp : (ref unit×ref unit). (fst p == snd p) as σ where σ = ∃α.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>e</head><label></label><figDesc>= let x = ref 0 in λf : (unit → unit). (x := 1; f (); !x) e = λf : (unit → unit). (f (); 1)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>true in let x = ref 0 in λf : unit → unit. (if !b then (b := false; [•]; b := true) else ()) λz : unit. !x Note that it is still possible for f to invoke the get function, which just reads the current x.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>This is the case, for example, in OCaml, which only supports applicative (i.e., non-generative) functors<ref type="bibr" target="#b14">[15]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>A similar example is discussed in Benton and Leperchey<ref type="bibr" target="#b6">[7]</ref>, at the end of their section 5. However, the two terms in their example are not actually equivalent in our language, because we have higher-order store.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>Pitts'  example is actually provable quite easily by a transitive combination of logical relations proofs (www.mpi-sws.org/~dreyer/pitts.txt). Dreyer has suggested a harder example, mentioned on page 25 of Sumii and Pierce<ref type="bibr" target="#b27">[28]</ref>, for which there is not even any known "brute-force" proof.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>The published conference version of her paper claims full completeness, but the proof contains a technical flaw uncovered by the second author. The extended version of her paper corrects the error<ref type="bibr" target="#b0">[1]</ref>.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Step-indexed syntactic logical relations for recursive and quantified types</title>
		<author>
			<persName><forename type="first">Amal</forename><surname>Ahmed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
	<note>Extended/corrected version of this paper available as Harvard University TR-01-06</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Typed closure conversion preserves observational equivalence</title>
		<author>
			<persName><forename type="first">Amal</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Blume</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICFP</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">State-dependent representation independence</title>
		<author>
			<persName><forename type="first">Amal</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Derek</forename><surname>Dreyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Rossberg</surname></persName>
		</author>
		<ptr target="http://ttic.uchicago.edu/~amal/papers/sdri/" />
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical appendix</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">An indexed model of recursive types for foundational proof-carrying code</title>
		<author>
			<persName><forename type="first">Andrew</forename><forename type="middle">W</forename><surname>Appel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Mcallester</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="657" to="683" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Ownership confinement ensures representation independence in object-oriented programs</title>
		<author>
			<persName><forename type="first">Anindya</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">A</forename><surname>Naumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="894" to="960" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">State based ownership, reentrance, and encapsulation</title>
		<author>
			<persName><forename type="first">Anindya</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">A</forename><surname>Naumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECOOP</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Relational reasoning in a nominal semantics for storage</title>
		<author>
			<persName><forename type="first">Nick</forename><surname>Benton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Leperchey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TLCA</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Relational parametricity for references and recursive types</title>
		<author>
			<persName><forename type="first">Lars</forename><surname>Birkedal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kristian</forename><surname>Støvring</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jacob</forename><surname>Thamsborg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008-07">July 2008</date>
		</imprint>
	</monogr>
	<note>Draft, submitted for publication</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Advances in Reasoning Principles for Contextual Equivalence and Termination</title>
		<author>
			<persName><forename type="first">Nina</forename><surname>Bohr</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
		<respStmt>
			<orgName>IT University of Copenhagen</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Relational reasoning for recursive types and references</title>
		<author>
			<persName><forename type="first">Nina</forename><surname>Bohr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lars</forename><surname>Birkedal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">APLAS</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Syntactic logical relations for polymorphic and recursive types</title>
		<author>
			<persName><forename type="first">Karl</forename><surname>Crary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Harper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computation, Meaning and Logic: Articles dedicated to Gordon Plotkin</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A type system for higher-order modules</title>
		<author>
			<persName><forename type="first">Derek</forename><surname>Dreyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Karl</forename><surname>Crary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Harper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Small bisimulations for reasoning about higher-order imperative programs</title>
		<author>
			<persName><forename type="first">Vasileios</forename><surname>Koutavas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mitchell</forename><surname>Wand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Reasoning about class behavior</title>
		<author>
			<persName><forename type="first">Vasileios</forename><surname>Koutavas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mitchell</forename><surname>Wand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOOL/WOOD</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Applicative functors and fully transparent higher-order modules</title>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Leroy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Recursive polymorphic types and parametricity in an operational framework</title>
		<author>
			<persName><forename type="first">Paul-André</forename><surname>Melliès</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jérôme</forename><surname>Vouillon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Representation independence and data abstraction</title>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Hoare type theory, polymorphism and separation</title>
		<author>
			<persName><forename type="first">Aleksandar</forename><surname>Nanevski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Greg</forename><surname>Morrisett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lars</forename><surname>Birkedal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Functional Programming</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">5&amp;6</biblScope>
			<biblScope unit="page" from="865" to="911" />
			<date type="published" when="2008-09">September 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Behavioral equivalence in the polymorphic pi-calculus</title>
		<author>
			<persName><forename type="first">Benjamin</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Davide</forename><surname>Sangiorgi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="531" to="586" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Advanced Topics in Types and Programming Languages</title>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Pitts</surname></persName>
		</author>
		<editor>B. C. Pierce</editor>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>The MIT Press</publisher>
			<biblScope unit="page" from="245" to="289" />
		</imprint>
	</monogr>
	<note>Typed operational reasoning</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Operational reasoning for functions with local state</title>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Pitts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ian</forename><surname>Stark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HOOTS</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Correctness of data representations involving heap data structures</title>
		<author>
			<persName><forename type="first">Uday</forename><surname>Reddy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hongseok</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Types, abstraction and parametric polymorphism</title>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">C</forename><surname>Reynolds</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Information Processing</title>
		<imprint>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Separation logic: A logic for shared mutable data structures</title>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">C</forename><surname>Reynolds</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Non-dependent types for Standard ML modules</title>
		<author>
			<persName><forename type="first">Claudio</forename><forename type="middle">V</forename><surname>Russo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PPDP</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Environmental bisimulations for higher-order languages</title>
		<author>
			<persName><forename type="first">Davide</forename><surname>Sangiorgi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Naoki</forename><surname>Kobayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eijiro</forename><surname>Sumii</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A bisimulation for dynamic sealing</title>
		<author>
			<persName><forename type="first">Eijiro</forename><surname>Sumii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Pierce</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">375</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="161" to="192" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A bisimulation for type abstraction and recursion</title>
		<author>
			<persName><forename type="first">Eijiro</forename><surname>Sumii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Pierce</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1" to="43" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Selective strictness and parametricity in structural operational semantics, inequationally</title>
		<author>
			<persName><forename type="first">Janis</forename><surname>Voigtländer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patricia</forename><surname>Johann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">388</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="290" to="318" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
