<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Computers &amp; Operations Research</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2008-12-24">24 December 2008</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ling</forename><surname>Wang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Tsinghua National Laboratory for Information Science and Technology (TNList)</orgName>
								<orgName type="department" key="dep2">Department of Automation</orgName>
								<orgName type="institution">Tsinghua University</orgName>
								<address>
									<postCode>100084</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Quan-Ke</forename><surname>Pan</surname></persName>
							<email>qkpan@lcu.edu.cn</email>
							<affiliation key="aff1">
								<orgName type="department">College of Computer Science</orgName>
								<orgName type="institution">Liaocheng University</orgName>
								<address>
									<postCode>252059</postCode>
									<settlement>Liaocheng</settlement>
									<country key="CN">PR China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">P</forename><forename type="middle">N</forename><surname>Suganthan</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">School of Electrical and Electronic Engineering</orgName>
								<orgName type="institution">Nanyang Technological University</orgName>
								<address>
									<addrLine>50 Nanyang Ave</addrLine>
									<postCode>639798</postCode>
									<settlement>Singapore</settlement>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Wen-Hong</forename><surname>Wang</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">College of Computer Science</orgName>
								<orgName type="institution">Liaocheng University</orgName>
								<address>
									<postCode>252059</postCode>
									<settlement>Liaocheng</settlement>
									<country key="CN">PR China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ya-Min</forename><surname>Wang</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">College of Computer Science</orgName>
								<orgName type="institution">Liaocheng University</orgName>
								<address>
									<postCode>252059</postCode>
									<settlement>Liaocheng</settlement>
									<country key="CN">PR China</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Computers &amp; Operations Research</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2008-12-24">24 December 2008</date>
						</imprint>
					</monogr>
					<idno type="MD5">829BE176B2AC66D696A49A79ED28E01B</idno>
					<idno type="DOI">10.1016/j.cor.2008.12.004</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Blocking flow shop Differential evolution Discrete differential evolution Hybrid algorithm Local search Speed-up</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper proposes a novel hybrid discrete differential evolution (HDDE) algorithm for solving blocking flow shop scheduling problems to minimize the maximum completion time (i.e. makespan). Firstly, in the algorithm, the individuals are represented as discrete job permutations, and new mutation and crossover operators are developed for this representation, so that the algorithm can directly work in the discrete domain. Secondly, a local search algorithm based on insert neighborhood structure is embedded in the algorithm to balance the exploration and exploitation by enhancing the local searching ability. In addition, a speed-up method to evaluate insert neighborhood is developed to improve the efficiency of the whole algorithm. Computational simulations and comparisons based on the well-known benchmark instances of Taillard [Benchmarks for basic scheduling problems. European Journal of Operational Research 1993;64:278-285], by treating them as blocking flow shop problem instances with makespan criterion, are provided. It is shown that the proposed HDDE algorithm not only generates better results than the existing tabu search (TS) and TS with multi-moves (TS + M) approaches proposed by Grabowski and Pempera [The permutation flow shop problem with blocking. A tabu search approach 2007;35:302-311], but also outperforms the hybrid differential evolution (HDE) algorithm developed by Qian et al. [An effective hybrid DE-based algorithm for multi-objective flow shop scheduling with limited buffers. Computers and operations research 2009;36(1):209-233] in terms of solution quality, robustness and search efficiency. Ultimately, 112 out of 120 best known solutions provided by Grabowski and Pempera [The permutation flow shop problem with blocking. A tabu search approach 2007;35:302-311] and Ronconi [A branch-and-bound algorithm to minimize the makespan in a flowshop problem with blocking. Annals of Operations Research 2005;138(1):53-65] are further improved by the proposed HDDE algorithm.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Flow shop scheduling problem is one of the most popular machine scheduling problems with extensive engineering relevance, representing nearly a quarter of manufacturing systems, assembly lines, and information service facilities in use nowadays <ref type="bibr" target="#b0">[1]</ref><ref type="bibr" target="#b1">[2]</ref><ref type="bibr" target="#b2">[3]</ref><ref type="bibr" target="#b3">[4]</ref><ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref>. This paper considers flow shop scheduling problems with blocking constraint. In blocking flow shops, there are no buffers between machines and hence intermediate queues of jobs waiting in the production system for their next operations are not allowed. Therefore, when needed, a job having completed processing on a machine has to remain on this machine and block itself until next machine is available for processing. The blocking flow shop scheduling problems have 0305-0548/$ -see front matter © 2009 Published by Elsevier Ltd. doi:10.1016/j.cor.2008.12.004 important applications in the production environment where processed jobs are sometimes kept in the machines because of the lack of intermediate storage <ref type="bibr" target="#b8">[9]</ref>, or stock is not allowed in some stages of the manufacturing process because of technological requirements <ref type="bibr" target="#b9">[10]</ref>. On the other hand, it has been proved that the blocking flow shop scheduling problem to minimize makespan with three machines is NP-hard in the strong sense <ref type="bibr" target="#b10">[11]</ref>. Therefore, it is of significance both in theory and in engineering applications to develop effective and efficient novel solution procedures to solve such problems.</p><p>However, blocking flow shop scheduling problems have not captured enough research so far <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b11">12]</ref>. Among the research, McCormich et al. <ref type="bibr" target="#b12">[13]</ref> developed a constructive heuristic, known as profile fitting (PF), for solving sequencing problems in an assembly line with blocking to minimize cycle time. In their heuristic, the authors created a partial sequence by adding an unscheduled job to obtain the minimum sum of idle times and blocking times on machines. A more comprehensive approach is presented by Leisten <ref type="bibr" target="#b13">[14]</ref> for dealing with permutation and non-permutation flow shops with finite and unlimited buffers to maximize the use of buffers and to minimize the machine blocking. However, the author concluded that the heuristic did not produce better solutions than the Nawaz-Enscore-Ham (NEH) <ref type="bibr" target="#b15">[16]</ref> heuristic. Ronconi <ref type="bibr" target="#b8">[9]</ref> proposed three constructive heuristics, called minmax (MM), combination of MM and NEH (MME), and combination of PF and NEH (PFE), respectively, for blocking flow shop problems with makespan criterion. It was demonstrated by the authors that the MME and PFE heuristics outperformed the NEH algorithm in problems with up to 500 jobs and 20 machines. Based on the connection between no-wait flow shop scheduling problems and flow shop scheduling problems with blocking, Abadi et al. <ref type="bibr" target="#b16">[17]</ref> proposed a heuristic for minimizing cycle time in blocking flow shops. Recently, Ronconi and Henriques <ref type="bibr" target="#b11">[12]</ref> studied the minimization of the total tardiness in flow shops with blocking scheduling and presented some constructive heuristics. By computational tests, the authors showed that their new approaches were promising for the problems considered.</p><p>With the development of computer technology, a few metaheuristics have been used to solve blocking flow shop scheduling problems. Caraffa <ref type="bibr" target="#b17">[18]</ref> developed a genetic algorithmic approach for solving large size restricted slowdown flow shop problems in which blocking flow shop problems were special cases. Ronconi <ref type="bibr" target="#b3">[4]</ref> proposed a heuristic algorithm based on branch-and-bound method by using the new lower bounds which exploited the blocking nature and were better than those presented in their earlier paper <ref type="bibr" target="#b14">[15]</ref>. By applying some properties of the problems associated with the blocks of jobs as well as using multi-moves to accelerate the convergence to more promising areas of the solutions space, recently, Grabowski and Pempera <ref type="bibr" target="#b1">[2]</ref> developed two tabu search (TS) and TS with multimove (TS+M) approaches. Computational results demonstrated that the TS and TS + M algorithms outperformed both the genetic algorithm <ref type="bibr" target="#b17">[18]</ref> and Ronconi's method <ref type="bibr" target="#b3">[4]</ref>.</p><p>The differential evolution (DE) algorithm was first introduced by Storn and Price <ref type="bibr" target="#b18">[19]</ref> to optimize complex continuous nonlinear functions. As a population-based evolutionary algorithm, the DE uses simple mutation and crossover operators to generate new candidate solutions, and applies one-to-one competition scheme to greedily decide whether the new candidate or its parent will survive in the next generation. Due to its simplicity, ease of implementation, fast convergence, and robustness, the DE algorithm has gained much attention and a wide range of successful applications such as digital PID controller design <ref type="bibr" target="#b19">[20]</ref>, feed-forward neural networks training <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b34">35]</ref>, digital filter design <ref type="bibr" target="#b21">[22]</ref> and earthquake hypocenter location <ref type="bibr" target="#b22">[23]</ref>. However, because of its continuous nature, applications of the DE algorithm on scheduling problems are still considerably limited <ref type="bibr" target="#b23">[24]</ref><ref type="bibr" target="#b24">[25]</ref><ref type="bibr" target="#b25">[26]</ref><ref type="bibr" target="#b26">[27]</ref><ref type="bibr" target="#b27">[28]</ref><ref type="bibr" target="#b28">[29]</ref><ref type="bibr" target="#b29">[30]</ref><ref type="bibr" target="#b30">[31]</ref>. Therefore, in this paper, we propose a hybrid discrete DE (HDDE) algorithm for solving blocking flow shop scheduling problems with makespan criterion. In the proposed DDE algorithm, individuals are represented as discrete job permutations, and novel job-permutation-based mutation and crossover operators are employed to generate new candidate solutions, and an effective insert-neighborhood-based local search is embedded to enhance exploitation. Furthermore, a speed-up method for insert neighborhood structure is developed to reduce computational time requirements. Simulation results and comparisons demonstrate the effectiveness of the proposed HDDE algorithm in solving blocking flow shop scheduling problems with makespan criterion.</p><p>This paper is organized as follows. In Section 2, the blocking flow shop scheduling problem is stated and formulated. In Section 3, the speed-up method for the insert neighborhood structure is proposed. In Section 4, the discrete DE (DDE) algorithm is proposed in detail. Section 5 presents a HDDE algorithm after explaining an effective local search. The computational results and comparisons are provided in Section 6. Finally, we conclude the paper with some concluding remarks in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">The blocking flow shop scheduling problem</head><p>The blocking flow shop scheduling problem can be defined as follows. There are n jobs from the set J = {1, 2, . . . , n} and m machines from the set M = {1, 2, . . . , m}. Each job j ∈ J will be sequentially processed on machine 1, 2, . . . , m. Operation o j,k corresponds to the processing of job j ∈ J on machine k (k = 1, 2, . . . , m) during an uninterrupted processing time p j,k , where its setup time is included into the processing time. At any time, each machine can process at most one job and each job can be processed on at most one machine. The sequence in which the jobs are to be processed is the same for each machine. Since the flow shop has no intermediate buffers, a job cannot leave a machine until its next machine downstream is free. In other words, the job has to be blocked on its machine if its next machine is not free. The aim is then to find a sequence for processing all jobs on all machines so that its maximum completion time (i.e. makespan) is minimized.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Mathematical model</head><p>Let a job permutation = { 1 , 2 , ... , n } represent the schedule of jobs to be processed, and e j,k be the departure time of operation o j,k (illustrated in Fig. <ref type="figure" target="#fig_0">1</ref>). According to the literature <ref type="bibr" target="#b8">[9]</ref>, e j,k can be calculated as follows</p><formula xml:id="formula_0">e 1,0 = 0,<label>(1)</label></formula><formula xml:id="formula_1">e 1,k = e 1,k-1 + p 1,k , k = 1, ... , m -1,<label>(2)</label></formula><formula xml:id="formula_2">e j,0 = e j-1,1 , j = 2, ... , n,<label>( 3 )</label></formula><formula xml:id="formula_3">e j,k = max{e j,k-1 + p j,k , e j-1,k+1 }, j = 2, ... , n, k = 1, ... , m -1,<label>(4)</label></formula><p>e j,m = e j,m-1 + p j,m , j = 1, ... , n, (</p><p>where e j,0 , j = 1, . . . , n, denotes the starting time of job j on the first machine. In the above recursion, the departure times of the first job on every machine are calculated first, then the second job, and so on until the last job. Then the makespan of the job permutation = { 1 , 2 , ... , n } is given by C max ( ) = e n,m , and its computational complexity is O(mn).</p><p>Let f j,k be the tail, i.e., duration between the latest loading time of operation o j,k (k = m, . . . , 1) and the end of the operations, and f j,m+1 be the duration between the latest completion time of operation o j,m and the end of the operations (illustrated in Fig. <ref type="figure">2</ref>). To follow the blocking constraints, we can obtain the recursion below</p><formula xml:id="formula_5">f n,m+1 = 0, (<label>6</label></formula><formula xml:id="formula_6">)</formula><formula xml:id="formula_7">f n,k = f n,k+1 + p n,k , k = m, ... , 2,<label>(7)</label></formula><formula xml:id="formula_8">f j,m+1 = f j+1,m , j = n -1, . . . , 1,<label>(8)</label></formula><formula xml:id="formula_9">f j,k = max(f j,k+1 + p j,k , f j+1,k-1 ), j = n -1, ... , 1, k = m, ... , 2,<label>(9)</label></formula><formula xml:id="formula_10">f j,1 = f j,2 + p j,1 , j = n, ... , 1.<label>(10)</label></formula><p>In the above recursion, the tails of the last job on every machine are calculated first, then the second last job, and so on until the first job. Then, an alternative approach to calculate the makespan of job permutation = { 1 , 2 , ... , n } can be given by C max ( ) = f 1,1 in time O(mn).</p><p>Therefore, the objective of the blocking flow shop scheduling problem with makespan criterion is to find a permutation * in the set of all permutations such that</p><formula xml:id="formula_11">C max ( * ) C max ( ), ∀ ∈ . (<label>11</label></formula><formula xml:id="formula_12">)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Graph representation</head><p>A graph representation model is used by Grabowski and Pempera <ref type="bibr" target="#b1">[2]</ref> to present the blocking flow shop scheduling problem (see Fig. <ref type="figure" target="#fig_2">3</ref>). For a permutation , a graph G( ) = (Z, A) is created with a set of nodes Z = n j=1 m k=1 (j, k) and a set of arcs A = A + ∪ A 0 ∪ A -, where the node (j, k) with weight p j ,k represents the processing of  operation O j ,k , and</p><formula xml:id="formula_13">A + = n j=1 m-1</formula><p>k=1 {((j, k), (j, k + 1))} is a subset of the arcs connecting consecutive operations of the same job, and A 0 = n-1 j=1 m k=1 {((j, k), (j + 1, k))} is a subset of the arcs connecting operations on the same machine in the processing order given by , and A -= n-1 j=1 m-1 k=1 {((j, k+1), (j+1, k))} is a subset of arcs associated with the blocking constraints, and each arc ((j, k + 1), (j + 1, k)) from A -has weight -p j ,k+1 . The makespan C max ( ) is equal to the longest (critical) path from node (1, 1) to node (n, m) in the graph G( ), which can be decomposed into several specific sub-paths and each of them contains the nodes linked with the same type of arcs. The first type of sub-paths is determined by the arcs in A 0 which correspond to sequences of operations processed on the same machine without inserted idle time. The second type of sub-paths is defined by the arcs in A -which correspond to blocked jobs. For simplicity, denote the first type of sub-paths and the second type of sub-paths as blocks and anti-blocks, respectively. Note that the critical path can contain many different blocks and anti-blocks, and all the blocks and antiblocks are connected in series. A simple graph model is shown in Fig. <ref type="figure" target="#fig_2">3</ref> for the blocking flow shop scheduling problem with n = 8 and m = 6, where arcs from A + and A 0 are represented by solid lines, and arcs from A -by dashed lines, and nodes in the critical path by bold circles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Insert-neighborhood-based speed-up method</head><p>Insert neighborhood of a job permutation = { 1 , 2 , ... , n } is widely used for flow shop scheduling problems in the literature <ref type="bibr" target="#b31">[32]</ref>, and is defined by considering all possible insert moves in the set V = {v(i, q)|i, q ∈ {1, 2, . . . , n} ∧ q / ∈ {i, i -1}}. The insert move v(i, q) generates a permutation from the permutation by removing a job i from its original position i and inserting it into another position q (q / ∈ {i, i -1}):</p><formula xml:id="formula_14">= { 1 , ... , i-1 , i+1 , ... , i , q , q+1 , ... , n } if (i &lt; q), (<label>12</label></formula><formula xml:id="formula_15">) = { 1 , ... , q-1 , i , q+1 , ... , i-1 , i+1 , ... , n } if (i &gt; q). (<label>13</label></formula><formula xml:id="formula_16">)</formula><p>The number of neighbors in the insert neighborhood of a permutation is (n -1) 2 , so the computational complexity to evaluate the whole insert neighborhood is O(mn 3 ) by using each approach proposed in Section 2.1. However, making use of the similarity of the permutation and its neighbor , and inspired by reduction of computational complexity presented by Grabowki <ref type="bibr" target="#b9">[10]</ref>, Taillard <ref type="bibr" target="#b32">[33]</ref> and Smutnicki <ref type="bibr" target="#b33">[34]</ref>, we develop a speed-up to evaluate the insert neighborhood for the problems considered here. The procedure is given below:</p><p>Step 1: Calculate the departure times e j,k , j=1, 2, . . . , n, k=1, 2, . . . , m using Eqs. ( <ref type="formula" target="#formula_0">1</ref>)-( <ref type="formula" target="#formula_4">5</ref>).</p><p>Step 2: Calculate the tails f j,k , j = n, n -1, . . . , 1, k = m, m -1, . . . , 1 using Eqs. ( <ref type="formula" target="#formula_5">6</ref>)- <ref type="bibr" target="#b9">(10)</ref>.</p><p>Step 3: Let i = 1.</p><p>Step 4: Let = { 1 , 2 , ... , n-1 } be a partial permutation generated by removing job i from the permutation .</p><p>Step 5: Get the departure times e j,k , j= 1, 2, . . . , n -1, k = 1, 2, . . . , m, for the partial permutation as follows. If j &lt; i, then let e j,k = e j,k ; else calculate e j,k using Eqs. ( <ref type="formula" target="#formula_0">1</ref>)-( <ref type="formula" target="#formula_4">5</ref>).</p><p>Step 6: Get the tails</p><formula xml:id="formula_17">f j,k , j = n -1, n -2, ... , 1, k = m, m -1, . . . , 1,</formula><p>for the permutation as follows. If j &gt; i, then let f j,k = f j+1,k ; else calculate f j,k using Eqs. ( <ref type="formula" target="#formula_5">6</ref>)- <ref type="bibr" target="#b9">(10)</ref>.</p><p>Step 7: Repeat the following steps until all possible positions q, q ∈ {1, 2, . . . , n} ∧ q / ∈ {i, i -1}, of the permutation are considered. Step 7.1: Insert job i into position q and generates a permutation .</p><p>Step 7.2: Calculate the departure times e q,k by using the obtained departure time e q-1,k , where k = 1, 2, . . . , m.</p><p>Step 7.3: The makespan of the permutation is given as follows (illustrated in Fig. <ref type="figure">4</ref>):</p><formula xml:id="formula_18">C max ( ) = m max k=1 (e q,k + f q,k ).</formula><p>Step 8: Let i = i + 1. If i &gt; n then stop; otherwise go back to</p><p>Step 4.</p><p>There are n iterations for Steps 5-7, and each of these steps can be executed in time O(mn). So, the computational complexity of this speed-up method is O(mn 2 ) to evaluate the whole insert neighborhood of the permutation .</p><p>In addition, according to the block properties presented by Grabowski <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b33">34]</ref> based on the graph model, we can further reduce the computational time to evaluate an insert neighborhood. The theorem is given as follows:</p><p>Theorem 1 <ref type="bibr">(Grabowski [2]</ref>). Let ∈ be any permutation with blocks</p><formula xml:id="formula_19">B g i ,h i = ( g i , g i +1 , ... , h i ), (g i , h i ) ∈ GH = {(g i , h i )|i = 1, ... , l B } and anti- blocks A s i ,t i = ( s i , s i +1 , ... , t i ) (s i , t i ) ∈ ST = {(s i , t i )|i = 1, ... , l A }.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>If the permutation has been obtained by an interchange of jobs that</head><formula xml:id="formula_20">C max ( ) &lt; C max ( ), then in (1) at least one job j ∈ B g i ,h i precedes job g i , for some (g i , h i ) ∈ GH, or (2) at least one job j ∈ B g i ,h i succeeds job h i , for some (g i , h i ) ∈ GH, or (3) at least one job j ∈ A s i ,t i precedes job s i , for some (s i , t i ) ∈ ST, or (4) at least one job j ∈ A s i ,t i succeeds job t i , for some (s i , t i ) ∈ ST.</formula><p>It is concluded from the above theorem that some insert moves cannot produce the permutations with better makespan. Since in our algorithm, we aim to find a better permutation than in its neighborhood, we will remove these non-improving moves from the insert move set V to further save computational time. The procedure is given as follows:</p><p>Step 1: Set j = 1 and k = m.</p><p>Step 2: If e j,k + f j+1,k = C max ( ), then the following two cases may arise Case 1: e j,k = e j,k-1 + p j,k . In this case, let</p><formula xml:id="formula_21">B k = {o j,k , o j+1,k } if B k = { }, B k ∪ {o j+1,k } otherwise,</formula><p>where B k is a block.</p><p>Case 2: e j,k &gt; e j,k-1 + p j,k . In this case, let</p><formula xml:id="formula_22">AB k = {o j,k+1 , o j+1,k } if AB k+1 = { }, AB k+1 ∪ {o j+1,k } otherwise,</formula><p>and</p><formula xml:id="formula_23">AB k+1 = { },</formula><p>where AB k is an anti-block. If k = 1, then remove the non-improving moves from V according to anti-block AB k and Theorem 1, and let AB k = { }.</p><p>Step 3: If e j,k + f j+1,k &lt; C max ( ), then remove the invalid moves from V according to theorem 1, B k and AB k+1 , then let B k = { } and AB k+1 = { }.</p><p>Step 4: If k &gt; 0, let k = k -1 and go to Step 2.</p><p>Step 5: If j &lt; n, let j = j + 1 and k = m, then go to Step 2; otherwise stop the procedure. The above method can effectively extract some non-improving insert moves from the set V, so the neighbors of the permutation to be evaluated are tailed off and the computational time requirement to find the better neighbors is further decreased. It is easy to verify that in some special cases, such as all p j,k are identical and n 3, each machine has single block containing all jobs. After executing the procedure, the remaining moves in the set V is decreased to 4n -8, whereas the initial number of moves is no less than (n -1) 2 . Note that when the non-improving moves are extracted, the indices of the neighbors will be changed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">DDE algorithm</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Brief introduction to DE algorithm</head><p>The basic DE algorithm <ref type="bibr" target="#b18">[19]</ref>   <ref type="bibr" target="#b18">[19]</ref>, the procedure of the basic DE algorithm can be described as follows:</p><p>Step 1: Initialization phase. Set the parameters and generate a population of PS individuals randomly. Let bestsofar be the best individual found so far, and t = 0.</p><p>Step 2: Mutation phase. Set t = t + 1, and generate mutant individual V t i , i = 1, 2, . . . , PS, as follows:</p><formula xml:id="formula_24">v t ij = x t-1 aj + Z × (x t-1 bj -x t-1 cj ), (<label>14</label></formula><formula xml:id="formula_25">)</formula><p>where a, b and c are three random integers in the range [1, PS] such that a, b, c and i are pairwise different, and j = 1, 2, . . . , n, and Z ∈ (0, 2) is a scale factor to control the amplification of the differential variation between two target individuals.</p><p>Step 3: Crossover phase. Generate trial individual U t i , i=1, 2, . . . , PS, as follows:</p><formula xml:id="formula_26">u t ij = v t ij if rand( ) &lt; CR or j = D j , x t-1 ij otherwise,<label>(15)</label></formula><p>where CR ∈ [0, 1] is a crossover parameter to control the diversity of the population, rand( ) denotes a uniform random number between 0 and 1, and D j refers to an index randomly chosen from the set {1, 2, . . . , n} to ensure that at least one dimension of</p><formula xml:id="formula_27">U t i is different from its counterpart X t-1 i .</formula><p>Step 4: Selection phase. For a minimization problem, each new target individual can be generated as follows:</p><formula xml:id="formula_28">X t i = U t i if f (U t i ) f (X t-1 i ), X t-1 i otherwise,<label>(16)</label></formula><p>where f (•) is the objective function.</p><p>Step 5: Update bestsofar.</p><p>Step 6: If a stopping criterion is satisfied, then output bestsofar; otherwise go back to Step 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">DDE algorithm</head><p>The basic DE algorithm cannot be used to directly generate discrete job permutations since it is originally designed to solve continuous optimization problems where the individuals are represented by floating-point numbers. Therefore, in this section, we will present a novel DDE algorithm to solve the blocking flow shop scheduling problem after explaining solution representation, new mutation and crossover operators, and initialization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1.">Solution representation</head><p>The job-permutation-based representation has been widely used in the literature for flow shop scheduling problems and it is easy to decode to reduce the cost of the algorithm <ref type="bibr" target="#b5">[6]</ref>. In this section, we adopt this representation and an example is given in Table <ref type="table" target="#tab_1">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2.">Job-permutation-based mutation operator</head><p>According to the basic DE algorithm, a mutant individual is generated by adding the weighted difference between two target individuals randomly selected from previous population to another individual, so a job-permutation-based mutation operator can be presented as follows:</p><formula xml:id="formula_29">V t i = X t-1 a ⊕ Z ⊗ (X t-1 b -X t-1 c ),<label>(17)</label></formula><p>where a, b and c are three random integers in the range <ref type="bibr" target="#b0">[1,</ref><ref type="bibr">PS]</ref> such that a, b, c and i are pairwise different, and i = 1, 2, . . . , PS, and Z ∈ [0, 1] is a mutant scale factor. The above formula consists of two components. The first component refers to the weighted difference between two target individuals X t-1 b and X t-1 c , that is,</p><formula xml:id="formula_30">t i = Z ⊗ (X t-1 b -X t-1 c ) ⇔ t i,j = x t-1 b,j -x t-1 c,j if rand( ) &lt; Z, 0 otherwise, (<label>18</label></formula><formula xml:id="formula_31">)</formula><p>where</p><formula xml:id="formula_32">t i = ( t i,0 , t i,1 , ... , t i,n</formula><p>) is a temporary vector. The second component is to produce a mutant individual V t i by adding t i to another target individual X t-1 a , that is,</p><formula xml:id="formula_33">V t i = X t-1 a ⊕ t i ⇔ v t ij = x t-1 aj ⊕ t ij = mod((x t-1 aj + t ij + n), n), (<label>19</label></formula><formula xml:id="formula_34">)</formula><p>where "mod" denotes the modulus operator whose result is the remainder when the first operand is divided by the second. This operator ensures that each dimension of V t i can represent a job. In order to better understand the proposed mutation operator, an example is given in Fig. <ref type="figure" target="#fig_4">5</ref>.</p><p>From Fig. <ref type="figure" target="#fig_4">5</ref>, it follows that each dimension of V t i represents a job, but V t i itself cannot always represent a complete sequence since some jobs may repeat many times whereas other jobs may be lost. However, from the crossover operator of the basic DE algorithm, it can be seen that a mutant individual is used to enhance perturbation to a target individual to avoid premature convergence to a non-global local optimum. Therefore, it is not necessary to ensure a feasible solution by mutation operator, and a legal target individual can be obtained by the following crossover operator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3.">Job-permutation-based crossover operator</head><p>The crossover operator generates a trial individual U t i by combining a mutant individual V t i and a target individual X t-1 i , and we expect the U t i to be better than X t-1 i . To well inherit good structures from the target individual X t-1 i and to yield a better U t i , the jobpermutation-based crossover operator is given as follows (illustrated by an example in Fig. <ref type="figure" target="#fig_6">6</ref>):</p><p>Step 1: From j = 1 to n, remove job v t i,j ∈ V t i if rand( ) CR or the job has already been in V i .</p><p>Step 2: Let</p><formula xml:id="formula_35">U t i = X t-1 i</formula><p>, and eliminate the jobs included in V i from U t i .</p><p>Step 3: The first job from V i is taken and inserted in the best position of U t i by evaluating all the possible slots of U t i . This step is repeated until V i is empty. Now a complete schedule is obtained.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.4.">Population initialization</head><p>Since NEH heuristic <ref type="bibr" target="#b15">[16]</ref> is one of the well-know heuristics in the literature, and it performs better than PF approach developed by Mccormick et al. <ref type="bibr" target="#b12">[13]</ref> and the heuristics by Leistein <ref type="bibr" target="#b13">[14]</ref> for the considered problem, to guarantee an initial population with a certain quality and diversity, we take advantage of NEH to produce an individual, while the other individuals are randomly generated in the solution space. The NEH heuristic has two phases. In phase I, jobs are ordered in descending sums of their processing times. In phase II, a job sequence is established by evaluating the partial schedules based on the initial order of phase I. In this paper, the speed-up method proposed in Section 3 is used to evaluate the partial schedules, so the NEH heuristic can be executed in time O(mn 2 ) for the blocking flow shop scheduling problem.  </p><formula xml:id="formula_36">0 1 2 3 4 5 X b 2 0 5 3 1 4 X c -2 1 -3 0 3 1 X b -X c 0.2 0.6 0.4 0.5 0.1 0.7 rand() -2 1 -3 0 3 1 X b -X c Δ i -2 0 -3 0 3 0 1 0 5 3 2 4 X c Δ i -2 0 -3 0 3 0 V i = X a Δ i 5 0 2 3 5 4</formula><formula xml:id="formula_37">V t i = X t-1 a ⊕ t i .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.5.">Procedure of the DDE algorithm</head><p>Based on the above design, the procedure of the DDE algorithm for solving the blocking flow shop scheduling problem is presented as follows:</p><p>Step 1: Initialization phase. Set the parameters PS, CR, and Z. Initialize population. Let bestsofar be the best individual found so far, and t = 0.</p><p>Step 2: Mutation phase. Set t = t + 1, and generate PS mutant individuals by using the job-permutation-based mutation operator.</p><p>Step 3: Crossover phase. Generate PS trial individuals by using the job-permutation-based crossover operator.</p><p>Step 4: Selection phase. Decide PS target individuals for next generation.</p><p>Step 5: Update bestsofar.</p><p>Step 6: If a stopping criterion is satisfied, then output bestsofar; otherwise go back to Step 2.  Unlike the basic DE algorithm, the DDE algorithm adopts the job-permutation-based encoding scheme, employs the jobpermutation-based mutation and crossover operators, and takes advantage of the initialization based on NEH heuristic, so it can be easily applied to the blocking flow shop scheduling problem.</p><formula xml:id="formula_38">V i 5 0 2 3 5<label>4</label></formula><formula xml:id="formula_39">X i 1 0 5 3 2 4 V i rand() V i U i U i 1 0 3<label>4</label></formula><formula xml:id="formula_40">U i 1 0 3 5 2 V i Insert U i 1 5 0 3 4 4 2 V i Insert 1 5 0 3 U i 1 5 0 3 2</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">HDDE algorithm</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">A problem-dependent local search</head><p>To balance the exploration and exploitation, a problemdependent local search is presented and applied to each trial individual U t i with a probability P l to enhance the local searching ability. That is, a uniform random number between 0 and 1 is firstly generated, and the individual will undergo the local search if the random number is less than P l . For the job-permutation-based optimization problems, insert, swap, and inverse operators are commonly used to produce a neighboring solution <ref type="bibr" target="#b1">[2]</ref>. Among them, insert operator is the most suitable for performing a fine local search <ref type="bibr" target="#b27">[28]</ref>. Thus, we employ insert operator to be embedded in the DDE algorithm to refine local search for the problem considered. The procedure of the local search is described as follows:</p><p>Step 1: Let i = 0, j = 0, and produce a reference sequence r = { r 1 , r 2 , ... , r n } randomly.</p><p>Step 2: Let i = i + 1, and set i = in if i &gt; n.</p><p>Step 3: Extract job r i from the trial individual sequence U t i , and insert it into all the other possible slots of U t i , respectively. Denote the best obtained sequence as b .</p><p>Step 4: If f ( b ) &lt; f (U t i ), then let U t i = b and j=0; otherwise, j=j+1.</p><p>Step 5: If j n, then go back to step 2; otherwise stop the procedure.</p><p>The above local search algorithm is effective and efficient due to the following reasons. Firstly, the local search is performed to the trial individual U t i but not the target individual X t i , so the algorithm can avoid both cycling search and getting trapped in a non-global local optimum. Secondly, in the local search, the incumbent solution is updated only when a better solution is algorithm can rapidly reach a local solution. Lastly, by using the speed-up method proposed in Section 3, the insert neighbors can be evaluated efficiently. Thus, the local search algorithm tends to enhance the local exploitation of the DDE algorithm in a relatively short time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">The HDDE algorithm</head><p>Based on the DDE algorithm and the local search presented in Section 5.1, the basic procedure of the HDDE algorithm is given as follows:</p><p>Step 1: Initialization phase. Set the parameters PS, CR, Z, and P l . Initialize population. Let bestsofar be the best individual found so far, and t = 0.</p><p>Step 2: Mutation phase. Set t = t + 1, and generate PS mutant individuals by using the job-permutation-based mutation operator.</p><p>Step 3: Crossover phase. Generate PS trial individuals by using the job-permutation-based crossover operator.</p><p>Step 4: Local search phase. Perform the local search to U t i , i = 1, 2, . . . , PS, with probability P l .</p><p>Step 5: Selection phase. Select PS target individuals by one-to-one selection operator for next generation.</p><p>Step 6: Update bestsofar.</p><p>Step 7: If a stopping criterion is satisfied, then stop the procedure and output bestsofar; otherwise go back to Step 2.</p><p>It can be seen that the HDDE algorithm not only applies the DDEbased evolutionary searching mechanism to effectively perform exploration for promising solutions within the whole solution space, but it also employs the problem-dependent local search to perform exploitation for solution improvement in the local neighborhoods. Since both the balance of exploration and exploitation and efficiency of solution evaluation are stressed, it is expected to achieve good results for the blocking flow shop scheduling problems with makespan criterion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Computational results</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Experimental setup</head><p>To test the performance of the proposed DDE/HDDE algorithm, a comprehensive experimental evaluation and comparison with other powerful methods are presented based on the well-known flow shop benchmark set of Taillard <ref type="bibr" target="#b0">[1]</ref>. The benchmark set is composed of 12 subsets of given problems with the size ranging from 20 jobs and five machines to 500 jobs and 20 machines, and each subset consists of ten instances. We treat them as the blocking flow shop scheduling problems with makespan criterion. And, in our test, the proposed DDE/HDDE algorithm is coded in C + + and the experiments are executed on a Pentium P-IV 3.0 GHz PC with 512 MB memory. The parameters are set as follows: F = 0.2, CR = 0.2, PS = 20, P l = 0.2, and the maximum computational time is set as T = 5mn ms. Each instance is run 10 independent replications and in each replication we compute the percentage relative difference (PRD) as follows:</p><formula xml:id="formula_41">PRD = 100 × (C Ron -C A ) C Ron , (<label>20</label></formula><formula xml:id="formula_42">)</formula><p>where C Ron is the referenced makespan provided by Ronconi <ref type="bibr" target="#b3">[4]</ref>, and C A is the makespan found by the DDE/HDDE algorithm. Furthermore, average percentage relative difference (APRD), maximum percentage relative difference (MaxPRD), minimum percentage relative difference (MinPRD), and the standard deviation (SD) of PRD are calculated as the performance statistics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Comparison of the DDE/HDDE and DE/HDE algorithms</head><p>Recently, an effective HDE-based algorithm was developed by Qian et al. <ref type="bibr" target="#b2">[3]</ref> for solving multi-objective flow shop scheduling problems with limited buffers between consecutive machines. In the HDE algorithm, a largest-order-value rule was employed to convert the continuous values of individuals to discrete job permutations, and a very efficient local search algorithm was incorporated to emphasize exploitation. By the experimental simulations based on the wellknown benchmark instances collected from OR library, the authors demonstrated the effectiveness and efficiency of their HDE algorithm. In this paper, we modify the HDE algorithm for the blocking flow shop scheduling problem and code it in C + +. The parameters of the HDE algorithm is consistent with those in <ref type="bibr" target="#b2">[3]</ref>, and the maximum computation time is also set as T = 5mn ms. Computational simulations are carried out on the same PC as mentioned before on the same benchmarks. For each instance, 10 independent replications are also conducted to obtain statistics. The computational results produced by the DE (the HDE algorithm without local search) and HDE algorithms are reported in Tables <ref type="table" target="#tab_2">2</ref> and<ref type="table" target="#tab_3">3</ref>, respectively.</p><p>It can be seen from Table <ref type="table" target="#tab_2">2</ref> for the same computational time, the overall mean APRD and SD values yielded by the DDE algorithm are equal to 2.79% and 0.16%, respectively, which are much better than those (-3.84% and 0.33%) generated by the DE algorithm. More importantly, the DDE algorithm produced substantially better PRD values with smaller SD values than the DE algorithm for all the problem sizes and all instances as well. From these observations, it is concluded that the DDE algorithm is more robust, effective and efficient than the DE algorithm for blocking flow shop scheduling problems.</p><p>The results reported in Table <ref type="table" target="#tab_3">3</ref> indicate that the HDDE algorithm generates significantly better APRD values with smaller SD values than the HDE algorithm for each problem size using the same computational time. As the problem size increases, the superiority of the HDDE algorithm over the HDE algorithm increases. Thus, it is concluded that the HDDE algorithm can reach optimal or near-optimal solutions for blocking flow shop scheduling problems more robustly, effectively and efficiently than the HDE algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.">Comparison of the DDE and GA algorithms</head><p>To further show the effectiveness of the proposed DDE algorithm, we compare the DDE algorithm with the existing GA developed by Caraffa et al. <ref type="bibr" target="#b17">[18]</ref> for blocking flow shop scheduling problems with makespan criterion. The computational results of these algorithms are shown in Table <ref type="table" target="#tab_4">4</ref>.</p><p>From Table <ref type="table" target="#tab_4">4</ref>, it follows that the DDE algorithm produces significantly better APRD values than the GA algorithm for all groups. Though the maximum running time of the DDE algorithm is larger than that of the GA algorithm, it is still acceptable since the overall mean maximum running time of the DDE algorithm is less than 10 s, and for the group with the extreme case of 500 jobs and 20 machines, the maximum computational time is not greater than 50 s. It  should be noted that when the maximum running time of the GA algorithm is increased to 475.0 s for the extreme case, it still produced the much worse APRD value (-2.57) <ref type="bibr" target="#b1">[2]</ref> than the DDE algorithm. Therefore, we can conclude that the DDE algorithm outperforms the GA algorithm on the considered problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.">Comparison of the HDDE and TS/TS + M algorithms</head><p>In this section, the HDDE algorithm is compared with two TS algorithms (TS and TS + M) <ref type="bibr" target="#b1">[2]</ref> proposed by Grabowski and Pempera who concluded that the TS and TS + M algorithm were the best performing algorithms when compare to GA developed by Caraffa et al. <ref type="bibr" target="#b17">[18]</ref> and the heuristic presented by Ronconi <ref type="bibr" target="#b3">[4]</ref>. The computational results of these algorithms are reported in Table <ref type="table" target="#tab_5">5</ref>.</p><p>From Table <ref type="table" target="#tab_5">5</ref>, it follows that the HDDE algorithm performs significantly better than both the TS and TS + M algorithms, since the overall mean ARPD value yielded by the HDDE algorithm is equal to 3.54%, which is 4.37 and 2.11 times higher than those generated by the TS (0.81%) and TS + M (1.68%) algorithms, respectively. More importantly, the HDDE algorithm produces much better APRD value than both the TS and TS + M algorithms for all problem size and all instances as well. Even the MinPRD value produced by the HDDE algorithm is much better than the PRD value by the TS and TS + M algorithms. Especially, the HDDE algorithm is far superior to the TS and TS + M algorithms for problem sizes of 50 × 5 and 100 × 5. In terms of the computational time requirements, although the computer for the HDDE algorithm is about three times faster than the one used by Grabowski and Pempera <ref type="bibr" target="#b1">[2]</ref>, the average computation time of the HDDE algorithm is shorter than one third of that of both the TS and TS+M algorithms for each instances. It highlights the fact that the HDDE algorithm performed significantly better than the TS and TS+M algorithms. In addition, the mean SD value resulting from the HDDE algorithm is very small, demonstrating the robustness of the HDDE algorithm to the initialization. Table <ref type="table" target="#tab_6">6</ref> reports the makespan found by the HDDE algorithm. It should be noted that for 112 out of 120 instances, the HDDE algorithm has found better makespan values (highlighted in bold) than both the TS + M [2] and Ron's algorithms (here denoted as Ron) <ref type="bibr" target="#b3">[4]</ref>. All these results confirm the favorable performance of the proposed HDDE algorithm over the TS and TS + M algorithms in terms of average percent relative deviation value and computational time as well. Hence, we can concluded that the HDDE algorithm is more effective and efficient than both the TS and TS + M algorithms for solving blocking flow shop scheduling problems with makespan criterion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5.">Effectiveness of combining the DDE and local search algorithms</head><p>The computational experiments and comparisons are conducted between the HDDE algorithm with the DDE and multi-start random local search (denoted as MLS) algorithms to show the effectiveness of combining the DDE-based global search and problem-dependent local search. The MLS algorithm is presented by removing the DDEbased search from the HDDE algorithm, and its parameters are set as follows: PS = 20, P l = 0.2. The computational results are shown in Table <ref type="table" target="#tab_7">7</ref>.</p><p>It is easily observed from Table <ref type="table" target="#tab_7">7</ref> that the HDDE algorithm is the winner since the results generated by the HDDE algorithm are significantly better than those by the DDE and MLS algorithms. To better understand the performance of the HDDE algorithm, the typical convergence rate curves for these three algorithms based on benchmark instance ta 81 are shown in Fig. <ref type="figure">7</ref>. It can be easily seen from Fig. <ref type="figure">7</ref> that the HDDE algorithm converges much faster to reach lower levels than both the DDE and MLS algorithms. The conclusion is similar for other benchmark instances. Based on the above comparisons, it is concluded that the HDDE algorithm is superior to the DDE and MLS algorithms in terms of solution quality, robustness and convergence rate for the blocking flow shop scheduling problems with makespan criterion. This could be explained by the fact that in the HDDE algorithm, the DDE algorithm generates good start points for the local search algorithm by performing global exploration, while the local search algorithm further refines the obtained solutions by performing local exploitation, and guides the DDE algorithm to more promising search area. That is to say, the superiority in terms of searching quality and robustness of the HDDE algorithm should be attributed to the combination of global search and local search, i.e., the balance of exploration and exploitation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6.">Effect of the parameter P l</head><p>Clearly, P l is a key parameter for the HDDE algorithm. Hence, we further investigate the effect of P l on solution quality. We set P l from 0.05 to 1.0 with a step equal to 0.05 and fix other parameters. The similar computational experiments are conducted. The statistical results are presented in Fig. <ref type="figure" target="#fig_7">8</ref>.</p><p>From Fig. <ref type="figure" target="#fig_7">8</ref>, it follows that as P l increases, the APRD value produced by the HDDE algorithm varies within a very small range. This suggested that P l does not affect the searching quality of the HDDE algorithm too much. In other words, the HDDE algorithm is robust in regard to the parameter P l .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusions</head><p>By applying a job-permutation-based representation, a novel job-permutation-based mutation and crossover operators, and a problem-dependent local search, we first propose a novel hybrid discrete differential evolution (HDDE) algorithm for solving block-ing flow shop scheduling problems with makespan criterion. Due to the effective hybridization of the differential-evolution-based global search and insert-neighborhood-based local search, the global exploration and local exploitation of the HDDE algorithm are well balanced. Furthermore, the efficiency of the HDDE algorithm is stressed by using a speed-up method to evaluate whole insertion neighborhood. Simulation results and comparisons demonstrated the superiority of the proposed HDDE algorithm in terms of solution quality, robustness and effectiveness. The future work is to apply the HDDE algorithm to other kinds of combinatorial optimization problems and develop multi-objective HDDE algorithms for multi-objective scheduling problems.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Computation of ej,k.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>1 Fig. 2 .</head><label>12</label><figDesc>Fig. 2. Computation of fj,k.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. A graph model blocking flow shop scheduling problem [2].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>4 Fig. 4 .</head><label>44</label><figDesc>Fig. 4. Computation of makespan after inserting job 0 into position 4.</figDesc><graphic coords="4,224.96,91.25,121.03,53.65" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Mutation operator: (a) Xb -Xc; (b) i = Z ⊗ (Xa -Xb) with Z = 0.5 and (c) V t i = X t-1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Crossover operator: (a) Vi and Xi; (b) remove jobs from Vi (CR = 0.5); (c) let Ui = Xi and remove the jobs included in Vi from Ui and (d) obtain Ui by inserting jobs of Vi to the best position of Ui.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Effect of the parameter Pl.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>is one of the latest population-based and stochastic global optimizers. It adopts a floating-point encoding scheme and takes advantage of the differentiation information among the population to find the global optimum in the continuous search space. Starting from a random initialization of PS target individuals, it creates PS new candidate solutions by mutation and crossover operators, and then applies selection operator to determine the new target individuals in the next generation. individual, the ith mutant individual, and the ith trial individual at iteration t, respectively. Following the DE/rand/1/bin scheme</figDesc><table><row><cell>Let X t i = in denote i2 , ... , u t i1 , u t i = u t in and U t i2 , ... , v t i1 , v t i = v t in , V t i2 , ... , x t i1 , x t x t</cell></row><row><cell>the ith target</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1</head><label>1</label><figDesc>An example of the job-permutation-based representation.</figDesc><table><row><cell>Dimension j</cell><cell>1</cell><cell>2</cell><cell>3</cell><cell>4</cell><cell>5</cell><cell>6</cell><cell>7</cell></row><row><cell>xi,j</cell><cell>3</cell><cell>4</cell><cell>6</cell><cell>2</cell><cell>5</cell><cell>0</cell><cell>1</cell></row><row><cell>Job permutation</cell><cell>3</cell><cell>4</cell><cell>6</cell><cell>2</cell><cell>5</cell><cell>0</cell><cell>1</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2</head><label>2</label><figDesc>Computation results of the DDE and DE algorithms.</figDesc><table><row><cell>n × m</cell><cell>DDE</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3</head><label>3</label><figDesc>Computation results of the HDDE and HDE algorithms.</figDesc><table><row><cell>n × m</cell><cell>HDDE</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 4</head><label>4</label><figDesc>Computation results of the a GA and DDE algorithms.</figDesc><table><row><cell>n × m</cell><cell>GA</cell><cell></cell><cell>DDE</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>PRD</cell><cell>T (s)</cell><cell>APRD</cell><cell>MinPRD</cell><cell>MaxPRD</cell><cell>SD</cell><cell>T (s)</cell></row><row><cell>20 × 5</cell><cell>-6.36</cell><cell>0.1</cell><cell>0.34</cell><cell>0.18</cell><cell>0.45</cell><cell>0.10</cell><cell>0.50</cell></row><row><cell>20 × 10</cell><cell>-4.35</cell><cell>0.2</cell><cell>2.34</cell><cell>2.16</cell><cell>2.39</cell><cell>0.08</cell><cell>1.00</cell></row><row><cell>20 × 20</cell><cell>-1.26</cell><cell>0.4</cell><cell>3.25</cell><cell>3.15</cell><cell>3.30</cell><cell>0.06</cell><cell>2.00</cell></row><row><cell>50 × 5</cell><cell>-8.53</cell><cell>0.3</cell><cell>4.15</cell><cell>3.73</cell><cell>4.61</cell><cell>0.28</cell><cell>1.25</cell></row><row><cell>50 × 10</cell><cell>-5.97</cell><cell>0.5</cell><cell>5.36</cell><cell>4.94</cell><cell>5.83</cell><cell>0.28</cell><cell>2.50</cell></row><row><cell>50 × 20</cell><cell>-4.33</cell><cell>1.1</cell><cell>5.55</cell><cell>5.25</cell><cell>5.87</cell><cell>0.20</cell><cell>5.00</cell></row><row><cell>100 × 5</cell><cell>-14.40</cell><cell>0.5</cell><cell>0.37</cell><cell>0.03</cell><cell>0.79</cell><cell>0.24</cell><cell>2.50</cell></row><row><cell>100 × 10</cell><cell>-7.89</cell><cell>1.1</cell><cell>3.90</cell><cell>3.59</cell><cell>4.25</cell><cell>0.21</cell><cell>5.00</cell></row><row><cell>100 × 20</cell><cell>-5.64</cell><cell>2.1</cell><cell>3.62</cell><cell>3.36</cell><cell>3.88</cell><cell>0.16</cell><cell>10.00</cell></row><row><cell>200 × 10</cell><cell>-11.04</cell><cell>2.2</cell><cell>1.29</cell><cell>1.04</cell><cell>1.58</cell><cell>0.17</cell><cell>10.00</cell></row><row><cell>200 × 20</cell><cell>-7.00</cell><cell>4.3</cell><cell>2.17</cell><cell>1.99</cell><cell>2.35</cell><cell>0.11</cell><cell>20.00</cell></row><row><cell>500 × 20</cell><cell>-8.08</cell><cell>10.8</cell><cell>1.19</cell><cell>1.08</cell><cell>1.34</cell><cell>0.08</cell><cell>50.00</cell></row><row><cell>Mean</cell><cell>-7.07</cell><cell>1.97</cell><cell>2.79</cell><cell>2.54</cell><cell>3.05</cell><cell>0.16</cell><cell>9.15</cell></row><row><cell cols="2">a CPU times of GA on Pentium IV 1000 MHZ.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 5</head><label>5</label><figDesc>Computation results a of the TS, TS + M and HDDE algorithms. CPU times of TS and TS + M on Pentium IV 1000 MHZ.</figDesc><table><row><cell>n × m</cell><cell>TS</cell><cell></cell><cell>TS + M</cell><cell></cell><cell>HDDE</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>PRD</cell><cell>T(s)</cell><cell>PRD</cell><cell>T (s)</cell><cell>APRD</cell><cell>MinPRD</cell><cell>MaxPRD</cell><cell>SD</cell><cell>T (s)</cell></row><row><cell>20 × 5</cell><cell>-1.64</cell><cell>2.4</cell><cell>-0.34</cell><cell>2.7</cell><cell>0.43</cell><cell>0.33</cell><cell>0.46</cell><cell>0.05</cell><cell>0.50</cell></row><row><cell>20 × 10</cell><cell>1.45</cell><cell>4.1</cell><cell>1.76</cell><cell>4.6</cell><cell>2.38</cell><cell>2.36</cell><cell>2.40</cell><cell>0.02</cell><cell>1.00</cell></row><row><cell>20 × 20</cell><cell>2.88</cell><cell>7.1</cell><cell>2.94</cell><cell>7.6</cell><cell>3.29</cell><cell>3.24</cell><cell>3.30</cell><cell>0.02</cell><cell>2.00</cell></row><row><cell>50 × 5</cell><cell>-0.55</cell><cell>6.0</cell><cell>0.55</cell><cell>6.2</cell><cell>4.24</cell><cell>3.88</cell><cell>4.67</cell><cell>0.25</cell><cell>1.25</cell></row><row><cell>50 × 10</cell><cell>1.98</cell><cell>10.6</cell><cell>3.52</cell><cell>10.8</cell><cell>5.75</cell><cell>5.43</cell><cell>6.12</cell><cell>0.23</cell><cell>2.50</cell></row><row><cell>50 × 20</cell><cell>3.68</cell><cell>19.0</cell><cell>4.26</cell><cell>19.3</cell><cell>6.03</cell><cell>5.74</cell><cell>6.34</cell><cell>0.20</cell><cell>5.00</cell></row><row><cell>100 × 5</cell><cell>-3.03</cell><cell>12.2</cell><cell>-2.62</cell><cell>12.4</cell><cell>1.42</cell><cell>1.04</cell><cell>1.86</cell><cell>0.26</cell><cell>2.50</cell></row><row><cell>100 × 10</cell><cell>1.71</cell><cell>21.9</cell><cell>2.66</cell><cell>22.1</cell><cell>5.17</cell><cell>4.92</cell><cell>5.56</cell><cell>0.21</cell><cell>5.00</cell></row><row><cell>100 × 20</cell><cell>2.01</cell><cell>39.2</cell><cell>3.03</cell><cell>39.4</cell><cell>4.68</cell><cell>4.39</cell><cell>5.01</cell><cell>0.19</cell><cell>10.00</cell></row><row><cell>200 × 10</cell><cell>-0.60</cell><cell>44.1</cell><cell>0.58</cell><cell>44.3</cell><cell>3.09</cell><cell>2.80</cell><cell>3.47</cell><cell>0.20</cell><cell>10.00</cell></row><row><cell>200 × 20</cell><cell>1.24</cell><cell>79.2</cell><cell>2.31</cell><cell>79.4</cell><cell>3.57</cell><cell>3.31</cell><cell>3.86</cell><cell>0.17</cell><cell>20.00</cell></row><row><cell>500 × 20</cell><cell>0.63</cell><cell>207</cell><cell>1.47</cell><cell>209</cell><cell>2.47</cell><cell>2.16</cell><cell>2.78</cell><cell>0.20</cell><cell>50.00</cell></row><row><cell>Mean</cell><cell>0.81</cell><cell>37.73</cell><cell>1.68</cell><cell>38.15</cell><cell>3.54</cell><cell>3.30</cell><cell>3.82</cell><cell>0.17</cell><cell>9.15</cell></row></table><note><p>a</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 6</head><label>6</label><figDesc>Upper bounds produced by the HDDE algorithm.</figDesc><table><row><cell>HDDE</cell><cell>TS + M</cell><cell>RON</cell><cell>HDDE</cell><cell>TS + M</cell><cell>RON</cell><cell>HDDE</cell><cell>TS + M</cell><cell>RON</cell><cell>HDDE</cell><cell>TS + M</cell><cell>R O N</cell></row><row><cell>20 × 5</cell><cell></cell><cell></cell><cell>5 0 × 5</cell><cell></cell><cell></cell><cell>1 0 0 × 5</cell><cell></cell><cell></cell><cell>2 0 0 × 10</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 7</head><label>7</label><figDesc>Comparison of the HDDE, DDE and MLS algorithms. Convergence rate cure of the MLS, DDE and HDDE algorithms for problem ta 81.</figDesc><table><row><cell>n × m</cell><cell>HDDE</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>MLS</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>DDE</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>APRD</cell><cell>MinPRD</cell><cell>MaxPRD</cell><cell>SD</cell><cell>T (s)</cell><cell>APRD</cell><cell>MinPRD</cell><cell>MaxPRD</cell><cell>SD</cell><cell>T (s)</cell><cell>APRD</cell><cell>MinPRD</cell><cell>MaxPRD</cell><cell>SD</cell><cell>T (s)</cell></row><row><cell>20 × 5</cell><cell>0.43</cell><cell>0.33</cell><cell>0.46</cell><cell>0.05</cell><cell>0.50</cell><cell>-0.86</cell><cell>-1.60</cell><cell>-0.09</cell><cell>0.49</cell><cell>0.50</cell><cell>0.34</cell><cell>0.18</cell><cell>0.45</cell><cell>0.10</cell><cell>0.50</cell></row><row><cell>20 × 10</cell><cell>2.38</cell><cell>2.36</cell><cell>2.40</cell><cell>0.02</cell><cell>1.00</cell><cell>1.23</cell><cell>0.60</cell><cell>1.93</cell><cell>0.41</cell><cell>1.00</cell><cell>2.34</cell><cell>2.16</cell><cell>2.39</cell><cell>0.08</cell><cell>1.00</cell></row><row><cell>20 × 20</cell><cell>3.29</cell><cell>3.24</cell><cell>3.30</cell><cell>0.02</cell><cell>2.00</cell><cell>2.47</cell><cell>1.95</cell><cell>3.04</cell><cell>0.36</cell><cell>2.00</cell><cell>3.25</cell><cell>3.15</cell><cell>3.30</cell><cell>0.06</cell><cell>2.00</cell></row><row><cell>50 × 5</cell><cell>4.24</cell><cell>3.88</cell><cell>4.67</cell><cell>0.25</cell><cell>1.25</cell><cell>1.62</cell><cell>0.97</cell><cell>2.25</cell><cell>0.41</cell><cell>1.25</cell><cell>4.15</cell><cell>3.73</cell><cell>4.61</cell><cell>0.28</cell><cell>1.25</cell></row><row><cell>50 × 10</cell><cell>5.75</cell><cell>5.43</cell><cell>6.12</cell><cell>0.23</cell><cell>2.50</cell><cell>3.10</cell><cell>2.34</cell><cell>3.87</cell><cell>0.48</cell><cell>2.50</cell><cell>5.36</cell><cell>4.94</cell><cell>5.83</cell><cell>0.28</cell><cell>2.50</cell></row><row><cell>50 × 20</cell><cell>6.03</cell><cell>5.74</cell><cell>6.34</cell><cell>0.20</cell><cell>5.00</cell><cell>3.86</cell><cell>3.23</cell><cell>4.65</cell><cell>0.44</cell><cell>5.00</cell><cell>5.55</cell><cell>5.25</cell><cell>5.87</cell><cell>0.20</cell><cell>5.00</cell></row><row><cell>100 × 5</cell><cell>1.42</cell><cell>1.04</cell><cell>1.86</cell><cell>0.26</cell><cell>2.50</cell><cell>-0.70</cell><cell>-1.28</cell><cell>-0.12</cell><cell>0.38</cell><cell>2.50</cell><cell>0.37</cell><cell>0.03</cell><cell>0.79</cell><cell>0.24</cell><cell>2.50</cell></row><row><cell>100 × 10</cell><cell>5.17</cell><cell>4.92</cell><cell>5.56</cell><cell>0.21</cell><cell>5.00</cell><cell>3.06</cell><cell>2.49</cell><cell>3.69</cell><cell>0.38</cell><cell>5.00</cell><cell>3.90</cell><cell>3.59</cell><cell>4.25</cell><cell>0.21</cell><cell>5.00</cell></row><row><cell>100 × 20</cell><cell>4.68</cell><cell>4.39</cell><cell>5.01</cell><cell>0.19</cell><cell>10.00</cell><cell>2.77</cell><cell>2.39</cell><cell>3.17</cell><cell>0.25</cell><cell>10.00</cell><cell>3.62</cell><cell>3.36</cell><cell>3.88</cell><cell>0.16</cell><cell>10.00</cell></row><row><cell>200 × 10</cell><cell>3.09</cell><cell>2.80</cell><cell>3.47</cell><cell>0.20</cell><cell>10.00</cell><cell>1.64</cell><cell>1.04</cell><cell>2.28</cell><cell>0.39</cell><cell>10.00</cell><cell>1.29</cell><cell>1.04</cell><cell>1.58</cell><cell>0.17</cell><cell>10.00</cell></row><row><cell>200 × 20</cell><cell>3.57</cell><cell>3.31</cell><cell>3.86</cell><cell>0.17</cell><cell>20.00</cell><cell>2.29</cell><cell>1.88</cell><cell>2.79</cell><cell>0.28</cell><cell>20.00</cell><cell>2.17</cell><cell>1.99</cell><cell>2.35</cell><cell>0.11</cell><cell>20.00</cell></row><row><cell>500 × 20</cell><cell>2.47</cell><cell>2.16</cell><cell>2.78</cell><cell>0.20</cell><cell>50.00</cell><cell>2.25</cell><cell>1.87</cell><cell>2.58</cell><cell>0.24</cell><cell>50.00</cell><cell>1.19</cell><cell>1.08</cell><cell>1.34</cell><cell>0.08</cell><cell>50.00</cell></row><row><cell>Mean</cell><cell>3.54</cell><cell>3.30</cell><cell>3.82</cell><cell>0.17</cell><cell>9.15</cell><cell>1.89</cell><cell>1.32</cell><cell>2.50</cell><cell>0.38</cell><cell>9.15</cell><cell>2.79</cell><cell>2.54</cell><cell>3.05</cell><cell>0.16</cell><cell>9.15</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This research is partially supported by National Science Foundation of China under Grants 60874075, 70871065, 60834004, 60774082, National 863 Hi-Tech RandD Plan under Grant 2007AA04Z155, and Open Research Foundation from State Key Laboratory of Digital Manufacturing Equipment and Technology (Huazhong University of Science and Technology), the Projectsponsored by SRF for ROCS, SEM, and Postdoctoral Science Foundation of China under Grants 20070410791. QKP and PNS acknowledge the financial support offered by the A*Star (Agency for Science, Technology and Research, Singapore) under Grant #052 101 0020.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Benchmarks for basic scheduling problems</title>
		<author>
			<persName><forename type="first">E</forename><surname>Taillard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European Journal of Operational Research</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="page" from="278" to="285" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The permutation flow shop problem with blocking</title>
		<author>
			<persName><forename type="first">J</forename><surname>Grabowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pempera</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">A tabu search approach</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="302" to="311" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">An effective hybrid DEbased algorithm for multi-objective flow shop scheduling with limited buffers</title>
		<author>
			<persName><forename type="first">B</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">X</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and operations research</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="209" to="233" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A branch-and-bound algorithm to minimize the makespan in a flowshop problem with blocking</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Ronconi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Operations Research</title>
		<imprint>
			<biblScope unit="volume">138</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="53" to="65" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Scheduling: theory, algorithms and systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Pinedo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NJ</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An effective hybrid heuristic for flow shop scheduling</title>
		<author>
			<persName><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">Z</forename><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Advanced Manufacturing Technology</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="38" to="44" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">No-idle permutation flow shop scheduling based on a hybrid discrete particle swarm optimization algorithm</title>
		<author>
			<persName><forename type="first">Q-K</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Advanced Manufacturing Technology</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="796" to="807" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A discrete particle swarm optimization algorithm for the no-wait flowshop scheduling problem</title>
		<author>
			<persName><forename type="first">Q-K</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Tasgetiren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y-C</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and Operations Research</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="2807" to="2839" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A note on constructive heuristics for the flowshop problem with blocking</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Ronconi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Production Economics</title>
		<imprint>
			<biblScope unit="volume">87</biblScope>
			<biblScope unit="page" from="39" to="48" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Sequencing of jobs in some production system</title>
		<author>
			<persName><forename type="first">J</forename><surname>Grabowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pempera</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European Journal of Operational Research</title>
		<imprint>
			<biblScope unit="volume">125</biblScope>
			<biblScope unit="page" from="535" to="550" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A survey of machine scheduling problems with blocking and no-wait in process</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">G</forename><surname>Hall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sriskandarajah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="510" to="525" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Some heuristic algorithms for total tardiness minimization in a flowshop with blocking</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Tonconi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lrs</forename><surname>Henriques</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">OMEGA-International Journal of Management Science</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="272" to="281" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Sequencing in an assembly line with blocking to minimize cycle time</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Mccormich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Pinedo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wolf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="925" to="936" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Flowshop sequencing problems with limited buffer storage</title>
		<author>
			<persName><forename type="first">R</forename><surname>Leisten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Production Research</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="2085" to="2100" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Lower bounding schemes for flowshops with blocking in-process</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Ronconi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">A</forename><surname>Armentano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Operational Research Society</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="page" from="1289" to="1297" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A heuristic algorithm for the m-machine, n-job flow shop sequencing problem</title>
		<author>
			<persName><forename type="first">M</forename><surname>Nawaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eej</forename><surname>Enscore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Ham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">OMEGA-International Journal of Management Science</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="91" to="95" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Minimizing cycle time in a blocking flowshop</title>
		<author>
			<persName><forename type="first">Ink</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">G</forename><surname>Hall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sriskandarajh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="177" to="180" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Minimizing makespan in a blocking flowshop using genetic algorithms</title>
		<author>
			<persName><forename type="first">V</forename><surname>Caraffa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ianes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">P</forename><surname>Bagchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sriskandarajah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Production Economics</title>
		<imprint>
			<biblScope unit="volume">70</biblScope>
			<biblScope unit="page" from="101" to="115" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Differential evolution-a simple and efficient adaptive scheme for global optimization over continuous spaces</title>
		<author>
			<persName><forename type="first">R</forename><surname>Storn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Price</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Global Optimization</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="341" to="359" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Design of digital PID controllers for continuous-time plants with integral performance criteria</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hwang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Chinese Institute of Chemical Engineers</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="683" to="696" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Differential evolution training algorithm for feed-forward neural networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ilonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Kamarainen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lampinen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural Process Letters</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="93" to="105" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Designing digital filters with differential evolution</title>
		<author>
			<persName><forename type="first">R</forename><surname>Storn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">New ideas in optimization</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Corne</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Dorigo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Glover</surname></persName>
		</editor>
		<meeting><address><addrLine>London, UK</addrLine></address></meeting>
		<imprint>
			<publisher>McGraw-Hill</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Differential evolution in the earthquake hypocenter location</title>
		<author>
			<persName><forename type="first">B</forename><surname>Ruzek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kvasnicka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pure and Applied Geophysics</title>
		<imprint>
			<biblScope unit="volume">158</biblScope>
			<biblScope unit="page" from="667" to="693" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A hybrid differential evolution for permutation flowshop scheduling</title>
		<author>
			<persName><forename type="first">B</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Advanced Manufacturing Technology</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">7-8</biblScope>
			<biblScope unit="page" from="757" to="777" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Scheduling flow shops using differential evolution algorithm</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">C</forename><surname>Onwubolu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Davendra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European Journal of Operational Research</title>
		<imprint>
			<biblScope unit="volume">171</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="674" to="692" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A discrete differential evolution algorithm for the no-wait flowshop problem with total flowtime criterion</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Tasgetiren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><forename type="middle">K</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">N</forename><surname>Suganthan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">C</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2007 IEEE symposium on computational intelligence in scheduling</title>
		<meeting>the 2007 IEEE symposium on computational intelligence in scheduling</meeting>
		<imprint>
			<biblScope unit="page" from="251" to="258" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A particle swarm optimization and differential algorithm for job shop scheduling problem</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Tasgetiren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sevkli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">C</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Operations Research</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="120" to="135" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">An effective hybrid DE-based algorithm for flow shop scheduling with limited buffers</title>
		<author>
			<persName><forename type="first">B</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">X</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Production Research</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="209" to="233" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A novel differential evolution algorithm for the no-idle permutation flow shop scheduling problems</title>
		<author>
			<persName><forename type="first">Q-K</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European Journal of Industrial Engineering</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="279" to="297" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A discrete differential evolution algorithm for the permutation flowshop scheduling problem</title>
		<author>
			<persName><forename type="first">Q-K</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Tasgetiren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y-C</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Ninth annual conference on genetic and evolutionary computation</title>
		<meeting>the Ninth annual conference on genetic and evolutionary computation<address><addrLine>London, England</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="126" to="133" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">A discrete particle swarm optimization algorithm for the generalized traveling salesman problem</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Tasgetiren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q-K</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y-C</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ninth annual conference on genetic and evolutionary computation</title>
		<meeting>the ninth annual conference on genetic and evolutionary computation<address><addrLine>London, England</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="158" to="167" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Some local search algorithms for no-wait flowshop problem with makespan criterion</title>
		<author>
			<persName><forename type="first">J</forename><surname>Grabowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pempera</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and Operations Research</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="2197" to="2212" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Some efficient heuristic methods for the flow shop sequencing problems</title>
		<author>
			<persName><forename type="first">E</forename><surname>Taillard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European Journal of Operational Research</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="65" to="74" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A two-machine permutation flow shop scheduling problem with buffers</title>
		<author>
			<persName><forename type="first">C</forename><surname>Smutncki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">OR Spectrum</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Evolutionary extreme learning machine</title>
		<author>
			<persName><forename type="first">Q-Y</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">N</forename><surname>Suganthan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G-B</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pattern Recognition</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1759" to="1763" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
