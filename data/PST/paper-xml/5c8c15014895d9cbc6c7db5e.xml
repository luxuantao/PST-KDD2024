<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Distributed Approach for Constructing Generalized Suffix Tree on Spark by Using Optimized Elastic Range Algorithm</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yunhao</forename><surname>Li</surname></persName>
							<email>liyunhao@seu.edu.cn</email>
						</author>
						<author>
							<persName><forename type="first">Jiahui</forename><surname>Jin</surname></persName>
							<email>jjin@seu.edu.cn</email>
						</author>
						<author>
							<persName><forename type="first">Runqun</forename><surname>Xiong</surname></persName>
							<email>rxiong@seu.edu.cn</email>
						</author>
						<author>
							<persName><forename type="first">Junzhou</forename><surname>Luo</surname></persName>
							<email>jluo@seu.edu.cn</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science and Engineering</orgName>
								<orgName type="institution">Southeast University</orgName>
								<address>
									<settlement>Nanjing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Message Passing Interface</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">A Distributed Approach for Constructing Generalized Suffix Tree on Spark by Using Optimized Elastic Range Algorithm</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1109/CBD.2017.28</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2023-01-01T13:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Generalized Suffix Tree</term>
					<term>Spark</term>
					<term>Resilient Distributed Datasets</term>
					<term>String Matching</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The generalized suffix tree (GST) is a tree structure that is widely used by string-based applications such as DNA sequence pattern search, data compression and time series analysis. It can efficiently accelerate the string operations like matching approximate strings and finding the longest common substring. In the big data era, the applications processing large-scale strings (e.g., genomic sequences) are common, so it is important to design scalable approaches for constructing massive GSTs. In this paper, we introduce a distributed approach for constructing GSTs on top of Apache Spark, a general-purpose big data processing system. The framework of our approach is based on the Elastic Range Algorithm (ERA), a state-of-the-art GST construction algorithm. Different from the original ERA, our approach optimizes the structure of GST and the subtree construction, which greatly reduces the memory requirement of GST construction and storage. In addition, we propose serval optimization techniques to speed up our approach. Our experimental results show that our approach can index billion-symbol strings within 5 minutes on a 8-worker Spark cluster. Moreover, the optimization techniques get about 5x speedup on the overall indexing time.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>The generalized suffix tree (GST) <ref type="bibr" target="#b7">[8]</ref> is a tree structure that holds indexing information about all suffixes of a set of texts. In a GST, a path from the root node to the leaf node represents a suffix string of a text and the leaf node holds the position of the corresponding suffix in the text (see Fig. <ref type="figure" target="#fig_0">1</ref> for an example). The construction of GST can accelerate many string operations such as approximate string matching and finding the longest common substring of several texts, which are essential to the string-based applications such as DNA sequence pattern search <ref type="bibr" target="#b4">[5]</ref>, data compression <ref type="bibr" target="#b2">[3]</ref> and time series analysis <ref type="bibr" target="#b5">[6]</ref>.</p><p>In the big data era, the volumes of texts increase dramatically. For instance, the human genome has roughly 2.6G symbols, which is far beyond the capacity of traditional GST construction algorithms e.g., Ukkonen <ref type="bibr" target="#b8">[9]</ref>. To handle big texts, scalable GST construction algorithms, e.g., B 2 ST <ref type="bibr" target="#b0">[1]</ref>, WaveFront <ref type="bibr" target="#b1">[2]</ref>, and Elastic Range (ERA) <ref type="bibr" target="#b3">[4]</ref>, have been proposed in recent years.</p><p>ERA is a representative of the scalable algorithms, which divides the whole GST into many subtrees and then constructs each subtree independently. With ERA's novel vertical partition, it was shown that ERA achieved better efficiency than other GST construction algorithms. However, the existing ER- A system is a specialized system, which is based on MPI 1 and cannot efficiently collaborate with the general-purpose big data processing systems (e.g., Apache Hadoop <ref type="bibr" target="#b9">[10]</ref> and Apache Spark <ref type="bibr" target="#b11">[12]</ref>). Specially, to index the texts that are stored and analyzed by the general-purpose big data processing systems, the specialized ERA systems must perform unnecessary data movement and duplication, which comes at a cost.</p><p>In this paper we introduce a distributed approach for constructing GST on top of Apache Spark, a general-purpose big data processing system. Spark keeps intermediate data and variables in memory, so it is much faster than the diskbased big data processing frameworks e.g., Hadoop. The GST construction on Spark can make full use of the distribution of text sets and the high parallelism of the construction algorithm.</p><p>To construct GSTs on Spark, there are two main issues that need to be addressed. (1) All operations on Spark are carried out upon resilient distributed datasets (RDDs) <ref type="bibr" target="#b10">[11]</ref>. The design of RDDs affects the construction performance, but as far as we know, there are no specialized RDDs designed for GST construction. <ref type="bibr" target="#b1">(2)</ref> The memory requirements of indexing big texts can be huge. If the GST is stored on HDFS <ref type="bibr" target="#b6">[7]</ref> or disk rather than in memory due to the limited memory resources, the Spark-based GST applications will be inefficient. Therefore, we need to reduce the memory requirement of GST storage.</p><p>This paper shows a distributed approach, namely Spark-ERA, to address these issues. The key contributions of this paper are summarized as follows:</p><p>• We design RDDs with high parallelism about the implementation of ERA on Spark, which is a basis of the construction and of great importance to the performance. Furthermore, we reuse RDDs as much as possible and persist the RDDs frequently used to speed up the construction.</p><p>• We optimize the GST structure and the subtree construction algorithm to reduce the memory requirement of GST storage. With the optimized structure, much less symbols are read from the HDFS and less memory are used to store GST.</p><p>• We perform serval optimizations based on Spark to improve the performance of construction. The experiments carried out on six text sets show that our approach can index billion-symbol strings within 5 minutes on a 8-worker Spark cluster. Moreover, the optimization techniques get about 5x speedup on the overall indexing time.</p><p>The rest of this paper is organized as follows. Section 2 introduces the basic knowledge of RDDs and ERA. Section 3 furnishes the GST construction on Spark. Section 4 describes the optimizations of the GST structure and subtree construction algorithm to store GST. In Section 5, serval steps of the construction are optimized to achieve high performance. Section 6 discusses our experimental results and Section 7 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. BACKGROUND</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Spark and Resilient Distributed Datasets</head><p>Apache Spark is a fast and versatile computing engine designed for large-scale in-memory data processing. Resilient distributed dataset (RDD) is the core of Spark, which is a distributed memory abstraction that supports application with working sets. RDD retains the attractive properties of data flow models: automatic fault tolerance, locality-aware scheduling and scalability, which makes Spark deal with different applications in a consistent manner. All operations on Spark are carried out around RDDs, therefore the design of RDDs has an important impact on the performance of applications.</p><p>An RDD has enough information, which is called lineage, about how it was derived from other RDDs. Therefore, once some RDD is lost, Spark can rebuilt the RDD using its lineage. RDDs do not need to be materialized at all times. Instead, RDDs are only computed the first time they are used in an action (such as reduce, reduceByKey and flatMap). In addition, users can use the operation cache to keep an RDD in memory or on disk if there is not enough memory to accelerate computation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Elastic Range Algorithm</head><p>Elastic Range Algorithm (ERA) is a suffix tree construction algorithm that partitions the whole tree vertically into many The implementation of ERA can be summarized as the following steps:</p><p>1) Construct the alphabet.</p><p>2) Extend S-prefix according to the specific criterion.</p><p>3) Find out all suffixes corresponding to each S-prefix. 4) Construct the subtree for each S-prefix. 5) Merge all constructed subtrees. The S-prefix means the prefix of suffix. For example, all Sprefixes of {aba} are {a, ab, aba}. The alphabet is a collection of different symbols and their frequencies in the text set, where the symbols are equivalent to the original S-prefixes. The specific criterion about expending S-prefix is that the product of the max frequency of S-prefixes, denoted as FM, and the size of tree node cannot exceed the memory used to store the tree. If some S-prefix cannot satisfy the criterion, it will be extended by each symbol of the alphabet until the extended S-prefixes's frequencies are less than FM. The most important principles of designing RDDs are as follows: (1) avoid creating duplicate RDDs, (2) reuse the same RDD as much as possible, (3) persist RDDs that will be reused many times. The purpose of these principles is to reduce the overhead of jobs and the memory used to save RDDs. The RDDs we design are shown in Fig. <ref type="figure">3</ref>.</p><p>First of all, we use wholeTextFile to read the text set from HDFS and generate FileRDD[&lt;textname,content&gt;]. The rest RDDs are all created from FileRDD. Therefore, we keep FileRDD in memory with the operation cache to avoid reading the text set from HDFS repeatedly every time we generate a new RDD from FileRDD.</p><p>Next, we will introduce the methods and data structures used in each step corresponding to ERA. Construct the alphabet. At first, the FileRDD is traversed with the action flatMap to generate CharRDD[&lt;char,1&gt;], which means different symbols and theirs frequencies in the text set. Then the total frequency of each unique symbol can be calculated by the operation reduceByKey. Those symbols are equivalent to the S-prefixes whose length equal 1. The result is saved as FrenRDD[&lt;char,fren&gt;]. Extend S-prefix. In ERA, the S-prefix will be expended by each symbol of the alphabet if its frequency exceeds FM. And the FileRDD will be scanned repeatedly to calculate the frequencies of extended S-prefixes until all S-prefixes frequencies are less than FM. The final S-prefixes will be collected and saved as SpRDD[&lt;s-prefix&gt;]. Find out suffixes. In this step, FileRDD needs to be scanned again to find out all suffixes corresponding to each extended Sprefix. However, the total symbols of all suffixes are far more than the symbols of the original text set. For example, the sum of symbols in the text set 5000×1000<ref type="foot" target="#foot_1">2</ref> is 5×10 6 , but total number of symbols in all suffixes is 1.25×10 10 . When the size of texts increases sharply, the memory can not keep all suffixes. To avoid memory overflow, the positions of suffixes will be recorded in the structure of &lt;textname,pos&gt;. For example, the position of {anb} in the text set {A.txt:abab, B.txt:banb} is &lt;B.txt,1&gt;. The result will be saved in SuffixRDD.</p><p>Construct subtrees in parallel. Each subtree corresponding to an S-prefix will be treated as an independent task and processed by a CPU core in parallel. Before the construction, the suffixes will be sorted. The positions will be converted to suffixes in the progress of sorting. After all suffixes are orderly, the branching information between two neighboring suffixes will be calculated for the construction and kept in an array (see Table <ref type="table" target="#tab_0">I</ref> for an example). The subtree construction algorithm we used is different from ERA and will be introduced detailedly in next section. All constructed subtrees are saved in SubtreeRDD[&lt;s-prefix,subtree&gt;]. Merge all subtrees. On Spark, there is no need to transport and merge all subtrees because the contents of RDDs are distributed over all executors. In other words, the subtrees can be saved over all executors. The action filter can be used to find out the wanted subtree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. MEMORY-EFFICIENT SUBTREE CONSTRUCTION</head><p>Many operations of GST constructed for text sets require the tree saved in memory. If the GST can only be stored on HDFS or disk due to the limited memory, these operations will be inefficient. In addition, the depth of GST is usually much smaller than the length of texts. This results in the imbalance of GST because the edges connected to the leaf nodes keep most symbols. Therefore, all labels of edges have almost the same number of symbols as the suffixes, which is much larger than the original text set. For example, the human genome has roughly 2.6×10 9 symbols and the resulting suffix tree occupies around 67GB. Thus, we need to optimize the structure of GST to reduce memory requirement of keeping GST.</p><p>Notice that the edges connected to the leaf node are private to the suffixes, we can save the positions of the rest suffixes instead of full strings, except for the edges whose labels are "$". In order to distinguish these private edges, we also keep the first symbols of the private edges in their labels, which means the final structure is &lt;char, pos&gt;. Example 2 is a simulation of string matching with the new structure.  obvious that the optimized structure occupies less space than the structure without the optimization. Now we show a matching progress. S M , the string waiting to be matched, is {TGGTGGTGGTGCGGTGATGGTGC}.</p><p>After matched with the edges {TG}, {GTG} and {GTG}, the rest of S M is S' M {CGGTGATGGTGC}. Because the first symbol of S' M is {C}, the position of the suffix that is most possible to be same as S M is &lt;1,11&gt;. If the string read from the text set with &lt;1,11&gt; equals S' M , it can be claimed that the position of S M in the text set is &lt;1,3&gt;. Else, we can say that S M is not included in the text set.</p><p>The subtree construction algorithm of ERA is not suitable for the optimized structure of GST because it needs to read each private edge fully into memory. The algorithm we use in this paper is a recursive algorithm SUB-TREE CONSTRUCTION. The input parameters are: L is the array holds the positions of sorted suffixes; P is the array hold the branching positions, left and right is the the upper and lower boundary of recursive function and prebranch is the previous branching position. The outputs are the public edge among Algorithm 1 SUBTREE CONSTRUCTION end if 25:</p><p>return (E, N ) 26: end function the suffixes and the rest subtree of this recursive function. The first recursive call is CONSTRUCTION(L,P,0,L.length-1,0). Here we give an example of the Algorithm 1. Figure <ref type="figure" target="#fig_4">5</ref>(a) shows the position and the branch positions of the sorted suffixes with S-prefix {b}.</p><p>In the first round of recursion, the minimal branching position is 1, and the indexes of minimums are P[0], P <ref type="bibr" target="#b0">[1]</ref> and P <ref type="bibr" target="#b1">[2]</ref>. Then the suffixes are divided into three subarrays, L[0], L <ref type="bibr" target="#b0">[1]</ref> and L[2:3] as shown in Fig. <ref type="figure" target="#fig_4">5(b)</ref>. {b} is the public edge in this recursive function.</p><p>In the second round, L[2:3] is divided into two subarrays, L <ref type="bibr" target="#b1">[2]</ref> and L <ref type="bibr" target="#b2">[3]</ref>. And the public edge of L[2:3] is {a}. There is no need to divide L[0] and L <ref type="bibr" target="#b0">[1]</ref> because each of them only has one suffix. The private edges connected to the leaf node L[0] and L <ref type="bibr" target="#b0">[1]</ref> are labeled with "$". The progress will repeat until the tree has been constructed as Fig. <ref type="figure" target="#fig_4">5(c)</ref> The execution of Algorithm 1 is actually repeated traversal of the branching position array P. The upper bound of the time complexity is O(kn), k is the depth of GST. In the worst case that the depth of tree is n, the time complexity is O(n 2 ). However, in practice and in all application scenarios k ≪ n. Therefore, the average time complexity is O(n), which means the Algorithm 1 can scale linearly to n.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. OPTIMIZATION TECHNIQUES</head><p>There are some parameters like parallelism that can be optimized to achieve higher performance of applications on Spark. When the size of texts increases sharply, a subtree may contain millions or even more suffixes. Some operations like the sort of suffixes also need to be optimized to avoid stack overflow and memory overflow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Increase parallelism</head><p>All operations on Spark are processed around RDDs. An action like reduce on RDD will trigger a job that consists of many tasks. Each task corresponds to a partition of RDD and will be executed on a CPU core. To avoid the waste of CPU computing resources, the partitions of RDD should exceed the number of CPU cores to achieve high parallelism. In addition, it would be the best to set the number of partitions equal integer multiple of CPU cores to balance the load of cores.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Optimize Extending S-prefixes</head><p>Any S-prefix whose frequency exceeds FM should be extended to fit in memory. ERA appends each symbol of the alphabet at the end of S-prefix. It is obvious that not all symbols in the alphabet follow after the S-prefix. ERA will traverse the whole text set to calculate the frequencies of extended S-prefixes that do not exist in the text set, which results in the waste of time and computing resources.</p><p>In this paper, the different symbols next to the S-prefix and their frequencies will be calculated when FileRDD is scanned. The result of calculation is saved in the structure of &lt;sp,spfren,Array[&lt;char,charlen&gt;]&gt;. sp is an extended S-prefix and spfren is its frequency in the text set. Array <ref type="bibr">[&lt;char,charfren&gt;]</ref> holds the symbols next to sp and their frequencies. From the new structure, we not only can judge whether the frequency of sp exceed the FM, but also whether the sps extended by appending a symbol satisfy the criterion. Half of traversals can be reduced with the new structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Optimize Sorting Suffixes</head><p>The first step of subtree construction is the sorting of suffixes, which is the necessary preparation for calculating the branching information. The quick sorting is considered to have best performance at present among internal sorting algorithms. However, the quick sorting of millions or even more suffixes will result in some exceptions like stack overflow without optimization.</p><p>All of three steps in quick sorting need to be optimized:</p><p>1) Selection of pivot. The divide-and-conquer algorithm can achieve the best performance when the array is divided two same-length subarrays. The method we used in this paper is median-of-three. When the length of suffix array exceeds 1000, the array will be divided into ten parts. A random element will be taken from each part. And the median of these ten elements will be treated as the middle element in median-of-three. At last, the median of the first element, the middle element and the last element will be taken as the pivot. 2) Partition of array. The pivot is used to divide the array into three sub-arrays that are less than pivot, greater than pivot and equal the pivot. The less, greater and equal is based on comparison between suffixes. Three sub-arrays rather than two sub-arrays, less and no less, are generated to avoid the repetitive comparison among the elements that equal the pivot.  </p><p>3) Sorting of subarrays. On the one hand, the subarray that has less elements will be sorted first to reduce the depth of stack and avoid the stack overflow. On the other hand, when the subarray has few elements, for instance less than 10 or 20, the quick sorting has no advantage compared with other sorting algorithms and will be replaced by optimized bubble sorting to avoid frequent calls of recursive functions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. EXPERIMENTAL EVALUATION</head><p>This section presents the performance of Spark-ERA over multiple text sets and compares the performance with the optimizations against without. The experiment platform is a Spark cluster with 8 worker nodes. Each node has a quda-core Intel E5-2620v2 CPUs at 2.10GHz and 4GB memory. The text sets we used are the ASCII character sets taken from open datasets BASE<ref type="foot" target="#foot_2">3</ref> , ANC<ref type="foot" target="#foot_3">4</ref> and OTA <ref type="foot" target="#foot_4">5</ref> . Six textsets are numbered as S{1∼6} and shown in Table <ref type="table" target="#tab_2">II</ref>.</p><p>Table <ref type="table" target="#tab_3">III</ref> compares the total number of symbols in GST with the optimized structure of private edges against that without the optimization. It is obvious that the optimized structure reads far less symbols from HDFS and requires much far less memory for preservation, which means the whole GST can be held in memory. Many operations can benefit from the new structure such as approximate string matching and finding the longest common substring.</p><p>In this experiment, we tune the number of RDDs partitions that affects the performance of constructing the alphabet and extending S-prefixes (see Section 5.1). Less partitions mean that some CPU cores are idle because no tasks are allocated to them. More partitions may have longer execution time because it costs more time to create and schedule tasks. Fig. <ref type="figure" target="#fig_5">6</ref> proves that 16 partitions have the least running time, which means that it is the most appropriate to set the number of partitions equal the number of CPU cores.  The sort of suffixes is the most important part of the subtree construction. Fig. <ref type="figure" target="#fig_6">7</ref> shows that the optimization for quick sort can effectively reduce the sorting time. The sorting time with the optimizations is only 50% of that without the optimizations. In addition, the optimized quick sorting has more stable performance with the increase of records.</p><p>The last experiment shows that the optimizations we have conducted have significant effect over all six text sets. As shown in Fig. <ref type="figure" target="#fig_7">8</ref>, the optimized GST construction algorithm on Spark runs 5x faster than the algorithm without optimization. And the optimizations have more significant effect on the larger text sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. CONCLUSION</head><p>The GST can accelerate many string operations like approximate string matching, which are essential to many application such as DNA sequence pattern search, data compression, and time series analysis. With the the novel vertical partition, we design the RDDs with high parallelism to complete the GST construction on Spark. The structure of GST and the subtree construction algorithm are optimized to reduce the memory requirement of storing the whole GST. The other optimizations of some construction steps and parameters based on Spark can achieve 5x higher performance. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 :</head><label>1</label><figDesc>Fig. 1: Generalized suffix tree indexing two texts {A.txt:abab$, B.txt:banb$}. The symbol '$' denotes the end of a suffix. The leftmost leaf node indicates that the suffix {abab} starts from postition 0 of A.txt.</figDesc><graphic url="image-1.png" coords="1,337.24,230.22,191.88,91.79" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 :</head><label>2</label><figDesc>Fig. 2: The subtrees partitioned vertically by ERA</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Example 1 . 1 ) 3 ) 4 )Fig. 3 :</head><label>11343</label><figDesc>Fig. 3: The flow chart of RDDs on Spark</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Example 2 .Fig. 4 :</head><label>24</label><figDesc>Fig. 4: The structure of private edges verse (a) without the optimization. (b) with the optimization.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 :</head><label>5</label><figDesc>Fig. 5: The execution of Algorithm 1 on the suffixes started with S-prefix {b}. P denotes the branching position.</figDesc><graphic url="image-22.png" coords="4,57.19,335.09,239.31,85.86" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 :</head><label>6</label><figDesc>Fig. 6: The execution time of different partitions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 7 :</head><label>7</label><figDesc>Fig. 7: Effects of optimizations on sorting time</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 8 :</head><label>8</label><figDesc>Fig. 8: Effects of optimizations on overall performance</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>TABLE I :</head><label>I</label><figDesc>Branch positions of the sorted suffixes with {b}</figDesc><table><row><cell>The sorted suffixes</cell><cell>b$</cell><cell>b$</cell><cell>bab$</cell><cell>banb$</cell></row><row><cell>The suffix positions</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>The branching positions</cell><cell>1</cell><cell>1</cell><cell>1</cell><cell>2</cell></row></table><note>&lt;A.txt,3&gt; &lt;B.txt,3&gt; &lt;A.txt,1&gt; &lt;B.txt,0&gt;</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE II :</head><label>II</label><figDesc>The text sets</figDesc><table><row><cell cols="4">Text Set Symbols of a text Number of texts Total Symbols</cell></row><row><cell>S1</cell><cell>5000</cell><cell>1000</cell><cell>5×10 6</cell></row><row><cell>S2</cell><cell>50000</cell><cell>1000</cell><cell>5×10 7</cell></row><row><cell>S3</cell><cell>5000000</cell><cell>20</cell><cell>1×10 8</cell></row><row><cell>S4</cell><cell>1000000</cell><cell>100</cell><cell>1×10 8</cell></row><row><cell>S5</cell><cell>50000</cell><cell>5000</cell><cell>2.5×10 8</cell></row><row><cell>S6</cell><cell>500000</cell><cell>1000</cell><cell>5×10 8</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE III :</head><label>III</label><figDesc>Comparison of total symbols of suffixes, the nonoptimized GST and the optimized GST.</figDesc><table><row><cell>Text Set</cell><cell>Total symbols of suffixes</cell><cell>Total symbols of non-optimized GST</cell><cell>Total symbols of optimized GST</cell></row><row><cell>S1</cell><cell>9663×10 6</cell><cell>9615×10 6</cell><cell>39943</cell></row><row><cell>S2</cell><cell>42978×10 7</cell><cell>42910×10 7</cell><cell>584228</cell></row><row><cell>S3</cell><cell>8143×10 8</cell><cell>8122×10 8</cell><cell>84344</cell></row><row><cell>S4</cell><cell>70802×10 9</cell><cell>70801×10 9</cell><cell>36491</cell></row><row><cell>S5</cell><cell>3107×10 10</cell><cell>3106×10 10</cell><cell>78900</cell></row><row><cell>S6</cell><cell>3522×10 10</cell><cell>3521×10 10</cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0">Authorized licensed use limited to: Tsinghua University. Downloaded on December 31,2022 at 02:43:19 UTC from IEEE Xplore. Restrictions apply.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1">5000×1000 means that the text set has 1000 texts and each text has roughly 5000 symbols</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2">http://www2.warwick.ac.uk/fac/soc/al/research/collections/base/history/</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3">http://www.anc.org/data/</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4">http://ota.ox.ac.uk/catalogue/index.html</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>This work is supported by National Natural Science Foundation of China under Grants No.61572129, No.61320106007, No. 61632008, No.61602112, No.61502097, No.61370207, International S&amp;T Cooperation Program of China No. 2015D-FA10490, Jiangsu Provincial Key Laboratory of Network and Information Security under Grants No.BM2003201, Key Laboratory of Computer Network and Information Integration of Ministry of Education of China under Grants No.93K-9, and partially supported by Collaborative Innovation Center of Novel Software Technology and Industrialization and Collaborative Innovation Center of Wireless Communications Technology.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Suffix trees for very large genomic sequences</title>
		<author>
			<persName><forename type="first">M</forename><surname>Barsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Thomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Upton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM CIKM</title>
				<meeting>of ACM CIKM</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="1417" to="1420" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Serial and parallel methods for i/o efficient suffix tree construction</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ghoting</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Makarychev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SIGMOD</title>
				<meeting>of ACM SIGMOD</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="827" to="840" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Suffix tree based vf-coding for compressed pattern matching</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kida</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Data Compression Conference</title>
				<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="449" to="449" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Era: efficient serial and parallel suffix tree construction for very long strings</title>
		<author>
			<persName><forename type="first">E</forename><surname>Mansour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Allam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Skiadopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kalnis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Vldb Endowment</title>
				<meeting>the Vldb Endowment</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="49" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Suffix tree searcher: exploration of common substrings in large dna sequence sets</title>
		<author>
			<persName><forename type="first">D</forename><surname>Minkley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Whitney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">H</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">G</forename><surname>Barsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kelly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Upton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Research Notes</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="9" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Stnr: A suffix tree based noise resilient algorithm for periodicity detection in time series databases</title>
		<author>
			<persName><forename type="first">F</forename><surname>Rasheed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Alhajj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Applied Intelligence</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="267" to="278" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The hadoop distributed file system</title>
		<author>
			<persName><forename type="first">K</forename><surname>Shvachko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kuang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Radia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Chansler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on MASS Storage Systems and Technologies</title>
				<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">A generalized suffix tree and its (un)expected asymptotic behaviors</title>
		<author>
			<persName><forename type="first">W</forename><surname>Szpankowski</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Society for Industrial and Applied Mathematics</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">On-line construction of suffix trees</title>
		<author>
			<persName><forename type="first">E</forename><surname>Ukkonen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Algorithmica</title>
				<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="249" to="260" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Hadoop: The Definitive Guide</title>
		<author>
			<persName><forename type="first">T</forename><surname>White</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>O&apos;Reilly Media, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Resilient distributed datasets: a fault-tolerant abstraction for in-memory cluster computing</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zaharia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chowdhury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dav</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mccauley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Usenix Conference on Networked Systems Design and Implementation</title>
				<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="2" to="2" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Spark: cluster computing with working sets</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zaharia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chowdhury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Usenix Conference on Hot Topics in Cloud Computing</title>
				<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="10" to="10" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
