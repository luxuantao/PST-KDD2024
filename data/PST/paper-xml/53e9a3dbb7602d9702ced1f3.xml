<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Java-Based Agent Platform for Programming Wireless Sensor Networks †</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Francesco</forename><surname>Aiello</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electronics, Informatics and Systems (DEIS)</orgName>
								<orgName type="institution">University of Calabria</orgName>
								<address>
									<addrLine>Via P. Bucci, cubo 41c</addrLine>
									<postCode>87036</postCode>
									<settlement>Rende</settlement>
									<region>CS</region>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Giancarlo</forename><surname>Fortino</surname></persName>
							<email>g.fortino@unical.it</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electronics, Informatics and Systems (DEIS)</orgName>
								<orgName type="institution">University of Calabria</orgName>
								<address>
									<addrLine>Via P. Bucci, cubo 41c</addrLine>
									<postCode>87036</postCode>
									<settlement>Rende</settlement>
									<region>CS</region>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Raffaele</forename><surname>Gravina</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electronics, Informatics and Systems (DEIS)</orgName>
								<orgName type="institution">University of Calabria</orgName>
								<address>
									<addrLine>Via P. Bucci, cubo 41c</addrLine>
									<postCode>87036</postCode>
									<settlement>Rende</settlement>
									<region>CS</region>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Antonio</forename><surname>Guerrieri</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electronics, Informatics and Systems (DEIS)</orgName>
								<orgName type="institution">University of Calabria</orgName>
								<address>
									<addrLine>Via P. Bucci, cubo 41c</addrLine>
									<postCode>87036</postCode>
									<settlement>Rende</settlement>
									<region>CS</region>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Java-Based Agent Platform for Programming Wireless Sensor Networks †</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">2AE712E54A296CD144A5D11369ED1C3C</idno>
					<idno type="DOI">10.1093/comjnl/bxq019</idno>
					<note type="submission">Received 4 November 2009; revised 4 December 2009</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:22+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>agent systems</term>
					<term>mobile agents</term>
					<term>event-and state-based programming</term>
					<term>wireless sensor networks</term>
					<term>body sensor networks</term>
					<term>human activity monitoring</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Wireless sensor networks (WSNs) are emerging as powerful platforms for distributed embedded computing supporting a variety of high-impact applications. However, programming WSN applications is a complex task that requires suitable paradigms and technologies capable of supporting the specific characteristics of such networks which uniquely integrate distributed sensing, computation and communication. Mobile agents are a distributed computing paradigm based on code mobility that has already demonstrated high effectiveness and efficiency in IP-based highly dynamic distributed environments. Due to their intrinsic characteristics, mobile agents may provide more benefits in the context of WSNs than in conventional distributed environments. In this paper we present the design, implementation and experimentation of MAPS (Mobile Agent Platform for Sun SPOT), an innovative Java-based framework for wireless sensor networks based on Sun SPOT technology which enables agent-oriented programming of WSN applications. The MAPS architecture is based on components that interact through events. Each component offers a minimal set of services to mobile agents that are modeled as multi-plane state machines driven by ECA rules. In particular, the offered services include message transmission, agent creation, agent cloning, agent migration, timer handling and easy access to the sensor node resources (sensors, actuators, input switches, flash memory and battery). Agent programming with MAPS is presented through both a simple example related to mobile agent-based monitoring of a sensor node and a more complex case study for realtime human activity monitoring based on wireless body sensor networks. Moreover, a performance evaluation of MAPS carried out by computing micro-benchmarks, related to agent communication, creation and migration, is illustrated.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Due to recent advances in electronics and communication technologies, wireless sensor networks (WSNs) have been introduced and are currently emerging as one of the most disruptive technologies enabling and supporting next generation † Revised and extended version of the paper: Aiello, F., Fortino, G., Gravina, R. and Guerrieri, A. (2009) MAPS: A Mobile Agent Platform for Java Sun SPOTs. Proc. 3rd Int. Workshop on Agent Technology for Sensor Networks (ATSN-09), jointly held with the 8th Int. Joint Conf. Autonomous Agents and Multiagent Systems (AAMAS-09), <ref type="bibr">May 12,</ref><ref type="bibr">Budapest,</ref><ref type="bibr">Hungary.</ref> ubiquitous and pervasive computing scenarios. WSNs have a high potential to support a variety of high-impact applications such as disaster/crime prevention and military applications, environmental applications, health-care applications and smart spaces. However, programming WSNs is a complex task due to the limited capabilities (processing, memory and transmission range) and energy resources of each sensor node as well as the lack of reliability of the radio channel. Moreover, WSN programming is usually application-specific (or more generally domain-specific) and requires tradeoffs in terms of 440 F. <ref type="bibr">Aiello et al.</ref> task complexity, resource usage and communication patterns. Therefore the developed software, which usually integrates routing mechanisms, time synchronization, node localization and data aggregation, is tightly dependent on the specific application and scarcely reusable. Thus to support rapid development and deployment of WSN applications flexible, WSN-aware programming paradigms are needed, which directly provide proactive and on-demand code deployment at runtime as well as ease software programming at the application, middleware and network layers.</p><p>Among the programming paradigms proposed for the development of WSN applications <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref>, the mobile agentbased paradigm <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4]</ref>, which has already demonstrated its effectiveness in conventional distributed systems as well as in highly dynamic distributed environments, can effectively deal with the programming issues that WSNs have posed. In particular, a mobile agent is a software entity encapsulating dynamic behavior and able to migrate from one computing node to another to fulfill distributed tasks. We believe that mobile agents can provide more benefits in the context of WSNs than in conventional distributed environments. In particular, mobile agents can support the programming of WSNs at the application, middleware and network levels. At the application level, mobile agents can be used as design and programming abstractions through which WSN applications can be effectively designed and implemented. At the middleware level, mobile agents can be used for implementing WSN core services such as data aggregation/fusion/dissemination and query-based information retrieval, and for dynamically deploying new services through efficient code dissemination.At the network level, mobile agents can be used as the mobile capsules in active networks for smart multi-hop routing and other network services. A few trials have to date been devoted to the development of mobile agent systems (MASs) for wireless sensor networks (Agilla <ref type="bibr" target="#b4">[5]</ref>, actorNet <ref type="bibr" target="#b5">[6]</ref>, SensorWare <ref type="bibr" target="#b6">[7]</ref>); however, none of them has been specifically developed for the Sun SPOT sensor platform <ref type="bibr" target="#b7">[8]</ref>, which is completely programmable in Java, supported by the SquawkVM <ref type="bibr" target="#b8">[9]</ref> and compatible with J2ME. Indeed, a noteworthy agent-based framework for J2ME devices, agent factory micro edition (AFME) <ref type="bibr" target="#b9">[10]</ref>, has been recently ported on Sun SPOT; however, not being conceived specifically for Sun SPOT technology, AFME does not completely exploit its functionality.</p><p>In this paper, we propose MAPS (Mobile Agent Platform for Sun SPOT), an innovative Java-based framework for wireless sensor networks based on Sun SPOT technology which enables agent-oriented programming of WSN applications. The architecture of MAPS is component-based and offers a minimal set of services to mobile agents, including message transmission, agent creation, agent cloning, agent migration, timer handling and easy access to the sensor node resources (sensors, actuators, input switches, flash memory and battery). The dynamic behavior of mobile agents is modeled as multi-plane ECA-based state machines. MAPS therefore enables a highly effective application programming through an integration of three of the most important paradigms for WSN programming: agent-oriented, event-based and state-based programming. The effectiveness of MAPS is demonstrated by the development of simple example applications (e.g. mobile agent-based remote monitoring of sensors) as well as a more complex case study. While the former aims at testing MAPS and describing how to program an application with MAPS, the latter highlights the effectiveness and suitability of MAPS for developing a real-time system supporting human activity monitoring which is of enormous importance in the healthcare domain. However, great effectiveness usually implies performance penalties; to address such issues a performance evaluation of the basic mechanisms of MAPS and Sun SPOT (e.g. communication and migration) has been carefully carried out to quantify the unavoidable overhead introduced by MAPS.</p><p>The contributions that this work offers to the WSN programming research area are the following: (i) A novel Java-based agent platform for Sun SPOT that allows an effective Java-based development of agents and agent-based applications by integrating agentoriented, event-driven and state-based programming paradigms. Moreover, being based on a componentbased approach, which clearly separates component interfaces from their implementations, MAPS is easily portable on other Java sensor platforms (e.g. Sentilla JCreate sensors <ref type="bibr" target="#b10">[11]</ref>). (ii) The performance evaluation carried out allows evaluating not only MAPS per se but also the degree of maturity of the Sun SPOT technology for supporting (mobile) agent-based applications and systems. An interesting result is that migration is still an open issue since Sun SPOT mechanisms supporting migration still need to be improved (e.g. lack of dynamic class loading) and optimized (hibernation and serialization of Isolates are too time-consuming operations). (iii) The development of a real case study concerned with testing the effectiveness and the suitability of the agentbased approach featured by MAPS for the development of a complex application in the health-care domain such as the real-time monitoring of human activities.</p><p>The rest of the paper is organized as follows. Section 2 discusses related work and, in particular, currently available (mobile) agent systems/platforms for WSNs. Section 3 presents the requirements, architecture and the agent programming model of MAPS. Section 4 describes the implementation of MAPS based on the Java Sun SPOT library. In Section 5, a simple example is provided for exemplifying the agentbased application programming with MAPS. Section 6 shows the performance evaluation of MAPS carried out through micro-benchmarks, whereas Section 7 proposes a real case study developed through MAPS for the real-time monitoring of human activities based on wireless body sensor networks (WBSNs). Finally, conclusions are drawn and future work briefly anticipated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>Mobile agents are supported by MASs, which basically provide an agent server, an Application Programming Interface (API) for mobile agent programming and, sometimes, supporting programming and administration tools. In particular, the agent server is able to execute agents by providing them with basic services such as migration, communication and resource access. In the last decade, a significant number of MASs for IP-based distributed computing systems have been developed <ref type="bibr" target="#b2">[3]</ref>. The majority of them are Java-based (e.g. Aglets, Voyager, Ajanta, JADE etc.) and few others rely on other languages (D'Agents, ARA etc.).</p><p>In the context of WSNs it is challenging to develop MASs for supporting mobile agent-based programming <ref type="bibr" target="#b11">[12]</ref>. Due to the currently available resource-constrained sensor nodes and related operating systems, building flexible and efficient MASs is a very complex task. Very few MASs for WSNs have to date been proposed and actually implemented. The most significant ones are: SensorWare <ref type="bibr" target="#b6">[7]</ref>,Agilla <ref type="bibr" target="#b4">[5]</ref> and actorNet <ref type="bibr" target="#b5">[6]</ref>. A general mobile-agent-oriented sensor node architecture to which such MASs adhere is shown in Fig. <ref type="figure" target="#fig_0">1</ref>. The MAS relies on the services offered by the OS and the mobile agents are executed within the MAS, which supports their inter-node migrations, sensing capabilities and resource access, and interagent communications.</p><p>SensorWare <ref type="bibr" target="#b6">[7]</ref> is a general middleware framework based on agent technology, where the mobile agent concept is exploited. Mobile control scripts in Tcl model network participants' functionalities and behaviors, and routing mechanisms to destination areas. Agents migrate to destination areas performing data aggregation reliably. The script can be very complex and diffusion gets slower when it reaches destination areas. The replication and migration of such scripts in several sensor nodes allows the dynamic deployment of distributed algorithms into the network. SensorWare defines, creates, dynamically deploys and supports such scripts. SensorWare is designed for iPAQ devices with megabytes of RAM. The verbose program representation and on-node Tcl interpreter can be acceptable overheads; however, they are not yet on a sensor node.</p><p>Agilla <ref type="bibr" target="#b4">[5]</ref> is an agent-based middleware where each node supports multiple agents and maintains a tuple space and neighbor list. The tuple space is local and shared by the agents residing on the node. Special instructions allow agents to remotely access another node's tuple space. The neighbor list contains the address of all one-hop nodes. Agents can migrate carrying their code and state, but do not carry their own tuple spaces. Agilla is currently implemented on MICA2, MICAZ and TelosB motes.</p><p>While both Agilla and SensorWare rely on mobile agents they employ a different communication model: Agilla's agent interaction is based on local tuple spaces, whereas SensorWare's agent interaction is based on direct communication based on network messages. In <ref type="bibr" target="#b12">[13]</ref> another mobile agent framework is proposed. The framework is implemented on Crossbow MICA2DOT motes. In particular, it provides agent migration and agent interaction based both on local shared memory and network messages. In <ref type="bibr" target="#b13">[14]</ref> the authors propose an extension of Agilla to support direct communication based on messages. In particular, to establish direct communications, agents are mediated by a middle component (named landmark) that interacts with agents through zone-based registration and discovery protocols.</p><p>In <ref type="bibr" target="#b5">[6]</ref> actorNet, a mobile agent platform for WSNs based on the Actor model is proposed. In particular, it provides services such as virtual memory, context switching and multi-tasking to support a highly expressive yet efficient agent functional language. Currently, the sensor node actorNet platform is specifically designed for TinyOS on Mica2 sensors.</p><p>The above described MASs for WSNs <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b13">14</ref>] are all implemented for TinyOS-based sensor platforms and use ad hoc languages for agent programming (Agilla uses a micro-programming language, whereas actorNet employs a functional-oriented language). Although some supported operations (e.g. migration) are very efficient, programming complex tasks is not so straightforward and, moreover, developers need to learn another very specific language.</p><p>Finally, the Java-based AFME <ref type="bibr" target="#b14">[15]</ref>, a lightweight version of the agent factory framework purposely designed for wireless pervasive systems and implemented in J2ME, has been recently ported onto Sun SPOT and purposely used for exemplifying agent communication and migration in WSNs <ref type="bibr" target="#b9">[10]</ref>. However, AFME was not specifically designed for WSNs and, particularly, for Java Sun SPOT. MAPS, the Java-based agent platform proposed in this paper, is conversely specifically designed for WSNs and fully uses the release 4.0 (blue) of the Sun SPOT library to provide advanced functionality of communication, migration, sensing/actuation, timing and flash memory storage. Moreover, it allows developers to program agent-based application in Java according to the rules of the MAPS framework, and thus no translator and/or 442 F. <ref type="bibr">Aiello et al.</ref> interpreter need to be developed and no new language has to be learnt.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">MAPS ARCHITECTURE AND PROGRAMMING MODEL</head><p>In this section requirements, architecture (at system and agent level) and programming model of MAPS are described.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Requirements</head><p>The MAPS framework has been appositely defined for resourceconstrained sensor nodes; in particular its requirements are the following:</p><p>(i) Lightweight agent server architecture. The agent server architecture must be lightweight, which implies the avoidance of heavy concurrency models and, therefore, the exploitation of cooperative concurrency to run agents. (ii) Lightweight agent architecture. The agent architecture must also be lightweight so that agents can be efficiently executed and migrated. (iii) Minimal core services. The main core services must be: agent migration, sensing capability access, agent naming, agent communication and timing. The agent migration service allows an agent to be moved from one sensor node to another by retaining the code, data and execution state. The sensing capability access service allows agents to access the sensing capabilities of the sensor node and, more generally, its resources (actuators, input signalers, flash memory). The agent naming service provides a region-based namespace for agent identifiers and agent locations. The agent communication service allows local and remote onehop/multi-hop message-based communications among agents. The timing service allows agents to set timers for timing their actions. (iv) Plug-in-based architecture extensions. Any other service must be defined in terms of one or more dynamically installable components (or plug-ins) implemented as single mobile agents or cooperating mobile agents. (v) Layer-oriented mobile agents. Mobile agents may be natively characterized on the basis of the layer to which they belong: application, middleware and network layer. They should also be able to locally interact to enable cross-layering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Agent server architecture</head><p>The designed sensor node architecture is shown in Fig. <ref type="figure">2</ref>.</p><p>The architecture is based on components that interact through events. The choice to design the architecture according to a component-and event-based approach is motivated by the effectiveness that such a kind of architecture has demonstrated for sensor node programming. In fact, the TinyOS operating system <ref type="bibr" target="#b15">[16]</ref>, the de facto standard for motes, relies on this kind of architecture. In particular, the main components are the following:</p><p>(1) Mobile agent (MA). The MAs are computing components which are differentiated on the basis of the layer (application, middleware and network) at which they perform tasks.  <ref type="bibr" target="#b16">[17]</ref> to support the MAMM and MACC components in their operations. The MAN also manages the (dynamic) list of the neighbor sensor nodes. ( <ref type="formula">6</ref>) Timer manager (TM). The TM component provides the timer service that allows for the management of timers to be used for timing MA operations. <ref type="bibr" target="#b6">(7)</ref> Resource manager (RM). The RM component provides access to the sensor node resources: sensors/actuators, battery and flash memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Agent programming model</head><p>The architecture of an MA is modeled as a multi-plane state machine communicating through events (see Fig. <ref type="figure">3</ref>). This architecture allows exploiting the benefits derived from three paradigms for WSN programming: event-driven programming <ref type="bibr" target="#b15">[16]</ref>, state-based programming <ref type="bibr" target="#b18">[18]</ref> and agentbased programming <ref type="bibr" target="#b4">[5]</ref>. Moreover, it enables role-based programming, an important paradigm for agents, as agents behave differently according to the role they can assume during their lifecycle <ref type="bibr" target="#b19">[19]</ref>.</p><p>In particular the architecture consists of:</p><p>(i) Global variables (GV ). The GV component represents the data of the MA including the MA identity. holds. When the transition fires, A is first executed and, then, the state transition takes place. In particular, the atomic action can use GV, GF, LV and LF for performing computations and, particularly, invoking the core primitives (see Fig. <ref type="figure" target="#fig_2">4</ref>) to asynchronously emit one or more events. The delivery of an event is asynchronous and can occur only when the ECAA is idle, i.e. the handling of the last delivered event (ED) is completed.</p><p>(iv) Event dispatcher (ED). The ED component dispatches the event delivered by the MAEE to one or more planes according to the events that the planes are able to handle.</p><p>In particular, if an event must be dispatched to more than one plane, the event dispatching is appositely serialized.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">THE MAPS FRAMEWORK</head><p>The implementation of MAPS is a real challenge due to the constrained resources of the current sensor nodes. Nevertheless, due to recent advances in operating systems and virtual machines as well as sensor technologies, an actual implementation could be done in nesC/TinyOS on TelosB motes or in Java on Sun SPOT nodes <ref type="bibr" target="#b7">[8]</ref>. Although the implementations of the currently available mobile agent frameworks for WSN (see Section 2) have to date been carried out in nesC/TinyOS, by also using the Maté virtual machine <ref type="bibr" target="#b20">[20]</ref>, we believe that the object-oriented features offered by the Sun SPOT technology could provide more flexibility and extendability as well as easiness of development  for an efficient implementation of the proposed framework. The Sun SPOT sensor nodes are based on the Squawk VM <ref type="bibr" target="#b8">[9]</ref> which is fully Java compliant and CLDC 1.1-compatible. In particular, the offered features are the following:</p><p>(i) Java programming language. Sensor node software is programmed in the Java language by using Java MAPS is implemented on the basis of the aforementioned Java Sun SPOT features which fully provide support to the implementation of each component introduced in Section 3.2. In the following subsections the main MAPS classes (see Fig. <ref type="figure" target="#fig_3">5</ref>) and related functionalities are described (more implementation details as well as the MAPS framework code ver. 1.1 can be found in <ref type="bibr" target="#b21">[21]</ref>).</p><p>The sensor node components are threads that can be instantiated through a Factory class based on the Singleton pattern <ref type="bibr" target="#b22">[22]</ref>. Such components are actually created at the node bootstrap when the MobileAgentServer is instantiated by the main application MIDlet. The MobileAgentServer creates the MobileAgentExecutionEngine which, in turn, creates all the other components. As soon as the MobileAgentExecutio-nEngine starts, it activates an InterIsolateServer to communicate with mobile agent components and broadcasts a discovery publish event to announce itself to the neighbor agent-based sensor nodes. After the creation of the MobileAgentServer, mobile agent components can be added to it by the addAgent method.</p><p>The MobileAgentExecutionEngine is the core component which exposes the interface for supporting all the primitives defined in Section 3.3 (see Fig. <ref type="figure" target="#fig_2">4</ref>). The communication among agents, between agents and system components and, sometimes, among components are based on Event objects. An Event object is composed of: (i) sourceID, which is the agent/component identifier of the event source;</p><p>(ii) targetID, which is the agent/component identifier of the event target; (iii) typeName, which represents the name of the event types that are grouped according to their specific function/component (see Table <ref type="table" target="#tab_4">1</ref> for the most important ones); (iv) params, which include the event data organized as a chain of pairs &lt;key, value&gt;; (v) durationType, which specifies the event duration. It can assume the following three values:</p><p>(a) NOW, for instantaneous events; (b) FIRST_OCCURRENCE, for events that wait for the first occurrence of a specific value; (c) PERMANENT. In this case, the event is sent every time values set in the event parameters are met.</p><p>A mobile agent runs in a thread supported Isolate that is instantiated at agent creation time. It is composed of an event queue which contains the Event objects delivered to the agent by the Dispatcher but not yet processed, and the multi-plane state machine containing the dynamic agent behavior. Interaction between mobile agents and the MobileAgentExecutionEngine is made possible by the InterIsolate server and enabled by its RequestSender component (based on the Sun SPOT library).</p><p>Remote inter-agent communication is enabled by MACC-Sender and MACCReceiver component which, respectively, allows transmitting and receiving network messages according to the radiogram protocol.</p><p>The MANaming component allows managing the list of neighbor sensor nodes and agents by means of a lightweight beaconing-based announcement protocol based on broadcast messages supported by the radiogram protocol. Moreover, agent proxy components <ref type="bibr" target="#b13">[14]</ref> are used to route network messages to migrated mobile agents.</p><p>The MAMigrationMan component manages the migration process of a mobile agent from one sensor node to another. To this purpose, it uses the methods provided by the SquawkVM to hibernate/dehibernate and serialize/deserialize an isolate. However, as dynamic class loading is not yet supported by the current version (v4.0 blue) of the Sun SPOT libraries, the agent code should reside at the destination node. In particular, the migration process, which is single-hop and reliable, is implemented as follows: (i) the agent destination node is contacted through a specific message which causes the opening of a socket waiting for an incoming request based on the radiostream protocol; (ii) the agent destination node sends an ACK back to the agent source node; (iii) the source node therefore establishes a radiostream connection with the destination node; (iv) the mobile agent is paused, hibernated, serialized into a byte array and sent over the connection to the destination; and (v) at the destination node, the mobile agent is received, deserialized, dehibernated and reactivated. The TimerManager component handles Timer objects which can be requested by mobile agents to time their operations. Timers can be one-shot or periodic.</p><p>Finally the SensorManager component manages available sensors (accelerometer, light and temperature) and actuators (e.g. LEDs), whereas the IOManager component manages input from switches and the flash memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">A programming example: mobile agent-based remote sensor monitoring</head><p>The example agent-based application for monitoring remote sensors is structured in three agents:</p><p>(i) DataCollectorAgent, which collects data sensed from the temperature, light and accelerometer sensors, and the battery of the Sun SPOT node; (ii) DataMessengerAgent, which carries collected sensed data from the sensing node to the base station; (iii) DataViewerAgent, which displays the received collected data.</p><p>After application deployment and execution, the DataViewerAgent sends a message to the DataCollectorAgent to start its activity as soon as the user presses a switch on the Sun SPOT on which the DataViewerAgent is running. The DataCollectorAgent therefore begins its collecting activity and as soon as the user pushes a switch on the Sun SPOT on which the DataCollectorAgent is running, it creates the DataMessengerAgent with the collected data that migrates to the DataViewerAgent node for data visualization. Finally, the monitoring activity terminates when the user presses again a switch of the Sun SPOT on which the DataViewerAgent is running. The sequence of interactions among the three defined agents is shown in Fig. <ref type="figure" target="#fig_4">6</ref> through an M-UML sequence diagram <ref type="bibr" target="#b23">[23]</ref>. This simple yet effective application, deployed on just two sensor nodes, allows for testing the most important mechanisms provided by MAPS.</p><p>For the sake of illustrating MAPS-based programming, the state machine of the DataCollectorAgent plane along with the action code, which uses the MAPS library, is shown in Fig. <ref type="figure">7</ref> and briefly explained in the following. The AGN_Start event causes the transition from the creation state to the StartTimer state and the execution of an example operation on the flash memory (action A0), i.e. adding some data to the flash space of the agent. holds, a timer timing the sensing operations is set up to fire after 3 s, some actuation on the LEDs is requested and some input from the switches is ready to be read (action A1). When the timer fires (see TMR_Expired event), the sensing operations are requested (action A2). When such operations are completed (see actions A5-A8), the guard [dataColl = = numData] holds so that data are collected and, as a visual signal, an LED is actuated to blink blue (see action A9). When the switch is pressed by the user, a DataMessengerAgent is created (action A3) and the collected data are passed to it (action A10) when the AGN_Id event, containing the agent ID of the created agent, is received. When the event MSG is received and the guard [go = = false] holds, the agent is terminated (action A4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">PERFORMANCE EVALUATION</head><p>The used testbed for testing and evaluation consists of a Sun SPOT kit (two sensor nodes and one base station) with the SDK 4.0 version (blue). The MAPS framework has a memory occupation (without any running agent) of about 70 kB in central memory, keeping free a space of 378 kB. Such space can be exploited for agent execution. The agent developed for the agent migration benchmarking (see below) needs 22 kB of central memory. The space occupied by the jar of MAPS on the flash memory is 92 kB out of the 4 MB available <ref type="bibr" target="#b7">[8]</ref>. To evaluate the performance of MAPS three micro-kernel benchmarks have been defined according to <ref type="bibr" target="#b24">[24]</ref> for the following mechanisms:</p><p>(1) Agent communication.  <ref type="figure" target="#fig_0">10</ref>) are high due to the slowness of the SquawkVM operations supporting the migration process. In particular, serialization is a very costly operation: serialization of the ping-pong agent on an average takes 4.5 s. Moreover, radiostream connections are very slow to guarantee reliability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">A CASE STUDY: REAL-TIME HUMAN ACTIVITY MONITORING</head><p>The effectiveness of MAPS to support WBSNs applications <ref type="bibr" target="#b25">[25]</ref> is demonstrated by the development of a real-time activity recognition system prototype. Nowadays WBSNs have great potential to enable a broad variety of assisted living applications such as human biophysical/biochemical control for health care, human activity monitoring for health care, e-fitness and emergency detection, and emotional recognition for social networking, security and highly interactive games. It is therefore important to provide design methodologies and programming frameworks that enable rapid prototyping of WBSN applications. Several effective application development frameworks have been already proposed for WBSNs based on TinyOS-based sensor platforms, for example CodeBlue, signal processing in node environment (SPINE) and Titan.</p><p>In particular, SPINE <ref type="bibr" target="#b26">[26]</ref> is a domain-specific framework for collaborative WBSNs which provides effective APIs (libraries of protocols, utilities and data processing functions) and tools (remote configuration of sensors, data gathering and visualization) for signal processing-based applications for the analysis and the classification of sensor data. This provides application developers with an abstraction that improves (e.g. activity monitoring application) for issuing commands to the BSN. Moreover, the SPINE Manager is responsible of capturing low-level messages and node events through the SPINE Listener to notify registered applications with higher-level events and messages content. A SPINE Comm Module (currently implemented for TinyOS and Z-Stack) is internally composed of a send/receive interface and some components that implement such interface according to the specific sensor platform and formalize the highlevel SPINE messages in sensor platform-specific messages. In this work, The SPINE coordinator has been enhanced with a new MAPS/SunSpot communication module (named SunSPOTWSNConnection) to configure and communicate with MAPS-based sensor nodes. Such module translates high-level SPINE messages formatted according to the SPINE OTA (over-the-air) protocol <ref type="bibr" target="#b28">[28]</ref> into lower-level MAPS/SunSPOT messages (named SunSPOTMessage) through its transmitter component and vice versa through its receiver component (named SunSPOTReceiver). The SunSPOTReceiver also integrates an application-specific logic for the synchronization of the two sensors (see below). The activity monitoring application as well as the SPINE Manager was thus completely reused; only the SPINE Listener was modified by such an enhancement.</p><p>The sensor nodes based on the Java Sun SPOTs are, respectively, located on the waist and on the thigh of the monitored person. In particular, MAPS is deployed on the sensor nodes and supports the execution of the WaistSensorAgent and the ThighSensorAgent. The WaistSensorAgent and the ThighSensorAgent have similar behavior: (i) sensing the three axial accelerometer sensors according to a given sampling time (ST = 1/sampling_rate); (ii) computation of specific features (Mean, Max and Min functions) on the acquired raw data according to the window (W ) and shift parameters (S), i.e. W is the sample size on which features are computed, whereas S is the percentage of sliding on W ; and (iii) features aggregation and transmission to the coordinator. While the values of the W and S parameters are equally set for both agents, the agents differ in the specific computed features: the WaistSensorAgent computes the mean values for data sensed on the XYZ axes, the min and max values for data sensed on the X-axis, whereas the ThighSensorAgent calculates the min value for data sensed on the X-axis. The behavior of the sensor agents is specified through two planes: the sensing plane and the feature calculation and transmission plane. In Fig. <ref type="figure" target="#fig_5">12</ref> the behavior of the WaistSensorAgent is reported (the behavior of the ThighSensorAgent complies with the same structure but the computed features are different as discussed above).</p><p>With reference to Fig. <ref type="figure" target="#fig_5">12a</ref>, after an initialization action (A0) driven by the occurrence of the AGN_START event, the sensing plane goes into the Wait4Sensing state. The MSG.START event allows starting the sensing process by the execution of action A1: (i) sensing parameters (W , S, ST), data acquisition buffers for XYZ channels of the accelerometer sensor (windowX, windowY, windowZ) and data buffers for feature calculation (windowFE4X, window FE4Y, window FE4Z) are initialized (see initSensingParamsAndBuffers function); (ii) the timer is set for timing the data acquisition according to the ST parameter (see timerSetForSensing function; in particular the highly precise Sun SPOT timer is used instead of the timer provided by MAPS as in the example of Section 4. re sultsZ = meanM axMin((WaistSe nsorAgent)agen t.windowZ4FE); ms gToServer.setP aram("BodyPosi tion", "Waist" ); ms gToServer.setP aram("MeanX"," " + resultsX[0 ]); ms gToServer.setP aram("MeanY"," " + resultsY[0 ]); ms gToServer.setP aram("MeanZ"," " + resultsZ[0 ]); ms gToServer.setP aram("MaxY", " " + resultsY <ref type="bibr" target="#b0">[1 ]</ref>); ms gToServer.setP aram("MinY", " " + resultsX <ref type="bibr" target="#b1">[2 ]</ref>); (W aistSensorAgen t)agent.timest amp=((WaistSen sorAgent)agent .timestamp+1) %128; ms gToServer.setP aram("Timestam p", "" + (Wais tSensorAgent)a gent.timestam p); ag ent.send(agent .getId(), Cons tants.MSG_TO_B ASESTATION, ms gToServer, fa lse); and (iii) a data acquisition is requested by submitting the ACC_CURRENT_ALL_AXES event by the sense primitive (see doSensing function). Once the data sample is acquired, the ACC_CURRENT_ALL_AXES event is sent back with the acquired data and the action A2 is executed: (i) the buffers are circularly filled with the proper values (see bufferFilling function); (ii) the sampleCounter is incremented and the nextSampleIndex is incremented module W for the next data acquisition; (iii) if S samples have been acquired, features are to be calculated; thus sampleCounter is reset, samples in the buffers are copied into the buffers for computing features and the COMPFEATURES event is sent to itself for being processed by the other plane; (iv) the timer is reset; and (v) data acquisition is finally requested. In the AccelSensing state the MSG.RESYNCH might be received for resynchronization purposes (see below); it brings the sensing plane into the Wait4Sensing state. The MSG.RESTART brings the sensing plane back into the AccelSensing state for (reconfiguring and) continuing the sensing process. The MSG.STOP eventually terminates the sensing process.</p><p>The feature calculation and transmission plane (see Fig. <ref type="figure" target="#fig_5">12b</ref>) is much simpler than the sensing plane. After it is started, in the Wait4Data it waits for the reception of the MSG.COMPFEATURES state which will be sent by the sensing plane once S samples have been acquired (see above). Such an event triggers the calculation of the features through the meanMaxMin function and their transmission to the base station by sending the MSG_TO_BASESTATION event appropriately constructed.</p><p>An important issue is the synchronization between the operations of the two agents which is to be maintained within a maximum skew for not affecting the real-time monitoring: if such a skew is overtaken, the two agents are to be resynchronized. As the sensor agents compute a different number of features, when the sampling rate is high, the agent computing more features (i.e. the WaistSensorAgent) takes more time to complete its operations for each S sample acquisitions than the ThighSensorAgent. Resynchronization is driven by the Synch Module (see Fig. <ref type="figure" target="#fig_0">11</ref>), included in the developed MAPS/SunSpot comm module, which sends a resynchronization message (see Fig. <ref type="figure" target="#fig_5">12a</ref>) as soon as it detects that the synchronization skew is greater than a given threshold. Detection is based on the skew time between the receptions of two messages sent by the agents that contain features referring to the same interval of S sample acquisitions: if skew ≥ P * S * ST, where P is a percentage and S = W/2.</p><p>Figure <ref type="figure" target="#fig_7">13</ref> shows the results of some experiments aimed at evaluating the synchronization of the sensor agents and their monitoring continuity. In particular, the experiments are carried out by fixing ST (ms) = [25, 50, 100], W = [40, 20] and P = [5%, 10%, 25%]. The defined measurements are: (i) the packet pair average time (PPAT ), which is the average reception time between two consecutive pairs of synchronized packets (same logical timestamp; see the timestamp variable in Fig. <ref type="figure" target="#fig_5">12</ref>) containing the computed features (see MSG_TO_BASESTATION event in Fig. <ref type="figure" target="#fig_5">12b</ref>) sent by the sensor agents and (ii) the synch packet percentage (SPP), which is the percentage of resynchronization packets (see RESYNCH event in Fig. <ref type="figure" target="#fig_5">12a</ref>) that are sent by the coordinator for resynchronizing the sensor agents, calculated with respect to the total number of received feature packets. The PPAT should be ideally equal to ST * S, that is, the packet pair arrives during each monitoring period and so there is no desynchronization in the average, whereas the SPP should be as much as possible close to 0, that is, a few or no resynchronizations are carried out and thus the monitoring can be continuous as a resynch operation usually takes 600 ms.</p><p>As can be seen from Fig. <ref type="figure" target="#fig_7">13</ref>, the system cannot support an ST = 25 ms because the PPAT is always greater than the ideal value and the SPP is too high. This leads to non-continuous monitoring due to the very frequent resynchronization (SPP ≥ 25%). An ST = 50 ms can be supported for P = 25% as the SPP is almost 8%, thus slightly impacting upon the monitoring continuity. The best results are obtained with ST = 100 ms and P = 25% or 15%; they guarantee monitoring continuity due to an SPP ≈ 0% and regularity as the PPAT ≈ 1000 for S = 10 and the PPAT ≈ 2000 for S = 20. If P = 5%, also an ST = 100 ms is not a good value because a skew of 5% * S * ST frequently occurs. It is worth noting that even though a lower ST allows more accurate monitoring, the considered human activities can be well captured by an ST = 100 ms, as demonstrated by the experimental results obtained from the real-time human activity monitoring carried out (see below).</p><p>According to such considerations the parameters used by the activity monitoring application during the training and the real-time operating phases were fixed as follows: ST = 100 ms, W = 20 (S = 10), P = 25%. In particular, the activity monitoring application relies on a classifier that recognizes postures and movements defined in a training phase. The application integrates two different classifiers: one based on the K-Nearest Neighbor algorithm <ref type="bibr" target="#b29">[29]</ref> and the other based on J48 Decision Tree <ref type="bibr" target="#b30">[30]</ref>. They were set up through a training phase and tested considering the parameter setting for data acquisition reported above. According to this setting, the features (Min, Max and Mean) are computed on 20 sampled data every new 10 samples acquired by the sensors. In Table <ref type="table" target="#tab_9">2</ref> the obtained classification accuracy results are reported. The obtained results are good and encouraging if compared with other works in the literature, which use more than two sensors on the human body <ref type="bibr" target="#b31">[31]</ref>. Finally, the interested reader can refer to <ref type="bibr" target="#b26">[26]</ref> for viewing the snapshots related to the panels (Live Monitor panel visualizing the recognized human activity, Statistics panel reporting statistics about the human activity, Advanced panel for configuring the sensors and the sensing process) of the reference activity monitoring application.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSIONS</head><p>Programming WSN applications is a complex task that requires suitable programming paradigms and frameworks to cope with the WSN-specific characteristics. Several kinds of micro-and macro-programming techniques have to date been proposed.</p><p>Among them mobile agent-based programming, which has been formerly introduced for conventional distributed systems, can be more effectively exploited in the context of WSNs.</p><p>In this paper we have therefore proposed mobile agents as an effective paradigm to program WSN applications and, in particular, presented MAPS, a Java-based framework for the development of agent-based applications for Sun SPOT sensor platforms. By using MAPS, a WSN application can be structured as a set of stationary and mobile agents distributed on sensor nodes supported by a component-based agent execution engine that provides basic services such as message transmission, agent creation, agent cloning, agent migration, timer handling and easy access to the sensor node resources. MAPS programming has been exemplified through a simple</p><p>The Computer Journal, Vol. 54 No. 3, 2011 yet effective example that shows how to program the dynamic behavior of agents in terms of state machines on the basis of the MAPS library. Moreover, a complete case study concerning the development and testing of a real-time human activity monitoring system based on WBSNs has been described. It is emblematic of the effectiveness and suitability of MAPS to deal with the programming of complex applications. Finally, we have presented an evaluation of MAPS according to micro-kernel benchmarks (agent communication, migration and creation) usually employed for MASs. Evaluation shows some performance penalties mainly due to very time-consuming operations (Isolate hibernation/serialization and radiostreambased communications) provided by the Sun SPOT libraries and SquawkVM on which MAPS relies.</p><p>Ongoing research efforts are being devoted to: (i) further optimizing the communication and migration mechanisms of MAPS; (ii) introducing the fall detection, which allows raising an alarm on detecting that the monitored person has fallen, in the developed real-time human activity monitoring agentbased application; (iii) porting MAPS onto the Sentilla JCreate pervasive computers which are compliant to Java ME CLDC 1.1; (iv) developing an agent-based version of SPINE (named ASpine) through MAPS (a preliminary design of ASpine if reported here <ref type="bibr" target="#b32">[32]</ref>).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>FIGURE 1 .</head><label>1</label><figDesc>FIGURE 1.A general mobile-agent-oriented sensor node architecture.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>444F.</head><label></label><figDesc>Aiello et al. send(SourceMA, TargetMA, EventName, Params, Local) SourceMA = id of the transmitting MA TargetMA = id of the MA target | id of the Group target | ALL for event broadcast to neighbors EventName = name of the event to be sent Params = set of event parameters encoded as pairs &lt;attribute, value&gt; Local = local (true) or remote (false) scoped event create(SourceMA, MAId, MAType, Params, NodeLoc) MAId = id of the MA to be created MAType = type of the MA to be created Params = agent creation parameters NodeLoc = node location of the created agent clone(SourceMA, MAId, NodeLoc) MAId = id of the cloned MA NodeLoc = node location of the cloned agent migrate(SourceMA, NodeLoc) NodeLoc = target location of the MA | ALL neighbors sense(SourceMA, IdSensor, Params, BackEvent) IdSensor = id of the sensor Params = parameters for sensor readings BackEvent = notifying event containing the readings actuate(SourceMA, IdActuator, Params) IdActuator = id of the actuator Params = parameters for actuator writings input(SourceMA, BackEvent, Params) Params = parameters for switch selection BackEvent = event notifying the input captured from the selected switch(es) flash(SourceMA, Params, BackEvent) Params = flash memory access parameters BackEvent = event notifying the completion of the flash memory operation (if it is a read operation, it contains the read data) setTimer(SourceMA, Params, BackEvent) Params = timer parameters BackEvent = event notifying the timer firing resetTimer(SourceMA, IdTimer) IdTimer = id of the timer to reset</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>FIGURE 4 .</head><label>4</label><figDesc>FIGURE 4. The prototypal core primitives.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>FIGURE 5 .</head><label>5</label><figDesc>FIGURE 5. A simplified class diagram of the MAPS framework.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>FIGURE 6 .</head><label>6</label><figDesc>FIGURE 6. The M-UML sequence diagram of the interactions among the agents.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>LFFIGURE 12 .</head><label>12</label><figDesc>FIGURE 12. Two-plane behavior of the WaistSensorAgent: (a) sensing plane and (b) feature calculation and transmission plane.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>452F.</head><label></label><figDesc>Aiello et al.    </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>FIGURE 13 .</head><label>13</label><figDesc>FIGURE 13. Analysis of the synchronization of the sensor agents: PPAT and SPP for (a) P = 25%, (b) P = 15% and (c) P = 5%.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>In particular, the MAMM is able to: (i) serialize an MA into a message and send it to the target sensor node and (ii) receive a message containing a serialized MA, deserialize and activate it. The agent serialization format includes the code, data and execution state. (4) Mobile agent communication channel (MACC). The MACC component enables inter-agent communications based on asynchronous messages. Messages can be unicast, multicast or broadcast. (5) Mobile agent naming (MAN). The MAN component provides agent naming based on proxies and regions</figDesc><table /><note><p>Application layer MAs incorporate application-level logic performing sensor monitoring, actuator control, data filtering/aggregation, high-level event detection, application-level protocols etc. Middleware layer MAs perform middleware-level tasks such as distributed data fusion, discovery protocols for agents, data and sensors, scope management etc. Network layer MAs mainly implement transport (e.g. data dissemination) and network (e.g. multi-hop routing) protocols. Agents at different layers can locally interact to implement cross-layering. (2) Mobile agent execution engine (MAEE). The MAEE is the component that supports the execution of agents by means of an event-based scheduler enabling cooperative concurrency. The MAEE handles each event emitted by or to be delivered at MAs through decoupling event queues. The MAEE interacts with the other core components to fulfill service requests (message transmission, sensor reading, timer setting etc.) issued by the MAs. (3) Mobile agent migration manager (MAMM). The MAMM component supports the migration of agents from one sensor node to another.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Global functions (GF). The GF component consists of a set of supporting functions which can access GV but can invoke neither core primitives nor other functions. (iii) Multi-plane state machine (MPSM). The MPSM component consists of a set of planes. Each plane may represent the behavior of the MA in a specific role.</figDesc><table><row><cell>&lt;&lt;GV&gt;&gt;</cell><cell cols="3">ECAA Plane In E D ED MPSM particular a plane is composed of: (a) Local variables (LV ). The LV component represents the local data of a plane. (b) Local functions (LF). The LF component consists of a set of local plane supporting functions which can access LV but can invoke neither core primitives nor other functions. (c) ECA-based automata (ECAA). The ECAA compo-nent represents the dynamic behavior of the MA in that plane and is composed of states and mutually exclusive transitions among states. Transitions are labeled by ECA</cell></row><row><cell></cell><cell>&lt;&lt;LV&gt;&gt;</cell><cell>S1</cell><cell>t 1</cell></row><row><cell></cell><cell></cell><cell>t 3</cell><cell>S2</cell></row><row><cell></cell><cell></cell><cell>t 2</cell><cell></cell></row><row><cell>&lt;&lt;GF&gt;&gt;</cell><cell>&lt;&lt;LF&gt;&gt;</cell><cell>S3</cell><cell>t 4</cell></row><row><cell></cell><cell></cell><cell>core primitives</cell><cell></cell></row></table><note><p>i FIGURE 3. The mobile agent architecture. (ii) rules: E[C]/A, where E is the event name, [C] is a boolean expression based on the GV and LV variables, and A is the atomic action. A transition t is triggered if t originates from the current state (i.e. the state in which the ECAA component is), the event with the event name E occurs and [C]</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>The radiostream protocol provides reliable, buffered, stream-based communication between two devices. The radiogram protocol provides datagram-based communication between two devices and broadcast communications. This protocol provides no guarantees about delivery or ordering. Datagrams sent over more than one hop could be silently lost, be delivered more than once and be delivered out of sequence. Datagrams sent over a single hop will not be silently lost or delivered out of sequence, but they could be delivered more than once. The protocols are implemented on top of the MAC layer of the 802.<ref type="bibr" target="#b14">15</ref>.4 implementation. (iv) Easy access to the sensor node devices (sensors, flash memory, timer, battery). The Sun SPOT device libraries contains drivers to easily access and use the following: the on-board LED, the PIO, AIC, USART and Timer-Counter devices in the AT91 package, the CC2420 radio chip (in the form of an IEEE 802.15.4 Physical interface), an IEEE 802.15.4 MAC layer, an SPI interface (used for communication with the CC2420 and off-board SPI devices) and an interface to the flash memory. (v) Code migration support. An Isolate is a mechanism by which an application is represented as an object. In Squawk, one or more applications can run in the single JVM. Conceptually, each application is completely isolated from all other applications. The Squawk implementation has the interesting feature of Isolate migration, i.e. an Isolate running on one Squawk VM instance can be paused, serialized to a file or over a network connection and restarted in another Squawk VM instance.</figDesc><table><row><cell>standard libraries and specific Sun SPOT libraries</cell></row><row><cell>such as main Sun SPOT board classes, sensor board</cell></row><row><cell>transducer classes and Squawk operating environment</cell></row><row><cell>classes.</cell></row><row><cell>(ii) NetBeans IDE for software development. The IDE fully</cell></row><row><cell>supports code editing, compilation, deployment and</cell></row><row><cell>execution for Sun SPOTs. This enables a more rapid</cell></row><row><cell>software prototyping.</cell></row><row><cell>(iii) Single-hop/multi-hop and reliable/unreliable commu-</cell></row></table><note><p>nications. The current version of the Sun SPOT SDK uses the GCF (Generic Connection Framework) to provide radio communication between SPOTs, routed via multiple hops if necessary. Two protocols are available: the radiostream protocol and the radiogram protocol.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>TABLE 1 .</head><label>1</label><figDesc>Event types for functions and components.</figDesc><table><row><cell>Function/Component</cell><cell>Types</cell><cell>Usage description</cell></row><row><cell>Agent management</cell><cell>AGN_CREATION</cell><cell>Request an agent creation</cell></row><row><cell></cell><cell>AGN_ID</cell><cell>Signal the ID of the created agent</cell></row><row><cell></cell><cell>AGN_START</cell><cell>Start an agent</cell></row><row><cell></cell><cell>AGN_TERMINATED</cell><cell>Terminate an agent</cell></row><row><cell>Migration</cell><cell>MGR_EXECUTED</cell><cell>Reactivate a migrated agent</cell></row><row><cell></cell><cell>MGR_REQUEST</cell><cell>Request Migration an agent migration</cell></row><row><cell></cell><cell>MGR_ACK</cell><cell>Signal an accomplished migration</cell></row><row><cell>SPOT discovery</cell><cell>DSC_PUBLISH</cell><cell>Publish a node discovery message</cell></row><row><cell></cell><cell>DSC_ANSWER</cell><cell>Signal a discovered node</cell></row><row><cell></cell><cell>DSC_REFRESH</cell><cell>Refresh the neighbor nodes</cell></row><row><cell>Message send/receive</cell><cell>MSG</cell><cell>Request a msg transmission</cell></row><row><cell></cell><cell>MSG_TO_BASESTATION</cell><cell>Request a msg transmission to the BS</cell></row><row><cell>Timer</cell><cell>TMR_EXPIRED</cell><cell>Signal a timer expiration</cell></row><row><cell>Execution Engine</cell><cell>EXE_GET_LOCAL_AGENTS</cell><cell>Request the IDs of the local agents</cell></row><row><cell></cell><cell>EXE_GET_NEIGHBORS</cell><cell>Request the IDs of the neighbor agents</cell></row><row><cell>Led</cell><cell>LED_ON</cell><cell>Request a led to be turned on</cell></row><row><cell></cell><cell>LED_OFF</cell><cell>Request a led to be turned off</cell></row><row><cell></cell><cell>LED_BLINK</cell><cell>Request a led to blink</cell></row><row><cell>Switch</cell><cell>SWT_PRESSED_RELEASED</cell><cell>Prepare a reading from a switch</cell></row><row><cell>Temperature sensor</cell><cell>TMP_CURRENT</cell><cell>Request the current temp value</cell></row><row><cell>Light sensor</cell><cell>LGH_CURRENT</cell><cell>Request the current light value</cell></row><row><cell>Accelerometer sensor</cell><cell>ACC_CURRENT</cell><cell>Request the current acceleration value</cell></row><row><cell></cell><cell>ACC_TILT</cell><cell>Request the current tilt value</cell></row><row><cell>Flash</cell><cell>FLS_ADD</cell><cell>Request to write byte to the flash</cell></row><row><cell></cell><cell>FLS_GET</cell><cell>Request to read byte from the flash</cell></row><row><cell>Battery</cell><cell>BTR_CURRENT_LEVEL</cell><cell>Request the current battery level</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>ON WAIST Activity Monitoring Application SPINEManager SPINE COORDINATOR MAPS/SunSpot Comm Module SPINEListener</head><label></label><figDesc></figDesc><table><row><cell>CreaƟon Ɵme (ms)</cell><cell></cell></row><row><cell></cell><cell>Number of agent planes</cell></row><row><cell cols="2">FIGURE 9. Agent creation time.</cell></row><row><cell></cell><cell>TinyOSComm Module</cell></row><row><cell></cell><cell>Z-StackComm Module</cell></row><row><cell>WaistSensorAgent</cell><cell></cell></row><row><cell>MAPS</cell><cell>MAPS</cell></row><row><cell>Java Sun SPOTs</cell><cell>Java Sun SPOTs</cell></row><row><cell>Execution Environment</cell><cell>Execution Environment</cell></row><row><cell></cell><cell>SENSOR NODE ON THIGH</cell></row></table><note><p><p><p>Agent cargo (byte)</p>MigraƟon Ɵme (ms) FIGURE 10. Agent migration: ping-pong time.</p>SENSOR NODE</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>BASE STATION Synch Logic ThighSensorAgent FIGURE 11.</head><label></label><figDesc>Architecture of the agent-based real-time activity recognition system.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>TABLE 2 .</head><label>2</label><figDesc>Classification accuracy for classifiers based on K-NearestNeighbor and J48 Decision Tree.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell>Standing</cell><cell>Lying</cell></row><row><cell></cell><cell>Walking</cell><cell>Sitting</cell><cell>still</cell><cell>down</cell></row><row><cell>K-NN (%)</cell><cell>94</cell><cell>96</cell><cell>92</cell><cell>98</cell></row><row><cell>J48 D Tree (%)</cell><cell>92</cell><cell>98</cell><cell>94</cell><cell>94</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>The Computer Journal, Vol. 54 No. 3, 2011 at Maastricht University on June 30, 2014 http://comjnl.oxfordjournals.org/ Downloaded from</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>at Maastricht University on June 30, 2014 http://comjnl.oxfordjournals.org/ Downloaded from</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>The authors wish to thank the members of the SPINE project for their useful comments and feedback about the (re)design and implementation of the SPINE-based activity monitoring application through MAPS, and Alessio Carbone for his helpful support in carrying out the performance evaluation of MAPS.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FUNDING</head><p>This work has been partially carried out in the framework of CONET, the Cooperating Objects Network of Excellence, funded by the European Commission under FP7 with contract number FP7-2007-2-224053.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>448</head><p>F. <ref type="bibr">Aiello</ref>   <ref type="bibr" target="#b27">[27]</ref> and in Java (coordinator side). In this paper, the developed MAPS-based prototype, which relies on SPINE at the base station side, aims at recognizing human postures (e.g. lying down, sitting or standing still) and movements (e.g. walking). The architecture of the system, shown in Fig. <ref type="figure">11</ref>, is a typical star-based Body Sensor Network (BSN) composed of a base station and two sensor nodes.</p><p>On the base station the Java-based SPINE coordinator <ref type="bibr" target="#b26">[26]</ref>, developed in the context of the SPINE project <ref type="bibr" target="#b28">[28]</ref>, is resident. The SPINE Manager is used by end-user applications</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">A survey of Wireless Sensor Network technologies: research trends and middleware&apos;s role</title>
		<idno>UCAM-CL-TR-646</idno>
		<imprint>
			<date type="published" when="2005">2005</date>
			<pubPlace>University of Cambridge, UK</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Applications and design issues for mobile agents in wireless sensor networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">C M</forename><surname>Leung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Wirel. Commun</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="20" to="26" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Towards a reference model for surveying mobile agent systems</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Romao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Deugo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mira Da Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Auton. Agent Multi-Agent Syst</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="187" to="231" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A manifesto for agent technology: towards next generation computing</title>
		<author>
			<persName><forename type="first">M</forename><surname>Luck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcburney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Preist</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Auton. Agents Multi-Agent Syst</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="203" to="252" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Rapid Development and Flexible Deployment of Adaptive Wireless Sensor Network Applications</title>
		<author>
			<persName><forename type="first">C.-L</forename><surname>Fok</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G.-C</forename><surname>Roman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 24th Int. Conf. Distributed Computing Systems (ICDCS&apos;05)</title>
		<meeting>24th Int. Conf. Distributed Computing Systems (ICDCS&apos;05)<address><addrLine>Columbus, OH, USA; Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2005-06-06">2005. June 6-10</date>
			<biblScope unit="page" from="653" to="662" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">ActorNet:AnActor Platform for</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kwon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sundresh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Mechitov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Agha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Wireless Sensor Proc. 5th Int. Joint Conf. Autonomous Agents and Multiagent Systems (AAMAS)</title>
		<meeting><address><addrLine>Hakodate, Japan; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006-05-08">2006. May 8-12</date>
			<biblScope unit="page" from="1297" to="1300" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Design and Implementation of a Framework for Efficient and Programmable Sensor Networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Boulis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-C</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1st Int. Conf. Mobile Systems, Applications and Services (MobiSys)</title>
		<meeting>1st Int. Conf. Mobile Systems, Applications and Services (MobiSys)<address><addrLine>San Francisco, CA, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003-05-05">2003. May 5-8</date>
			<biblScope unit="page" from="187" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<ptr target="http://www.sunspotworld.com/" />
		<title level="m">Sun™ Small programmable object technology (Sun SPOT )</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The Squawk Java Virtual Machine: Java on the Bare Metal</title>
		<author>
			<persName><forename type="first">D</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Cifuentes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 20th Object-Oriented Programming, Systems, Languages and Applications (OOPSLA 2005)</title>
		<meeting>20th Object-Oriented Programming, Systems, Languages and Applications (OOPSLA 2005)<address><addrLine>San Diego, CA, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1920">2005. October 16-20</date>
			<biblScope unit="page" from="150" to="151" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Agent Migration and Communication in WSNs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Muldoon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M P</forename><surname>O'hare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>O'grady</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tynan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1st Int. Workshop on Sensor Networks and Ambient Intelligence, held in conjunction with the 9th Int. Conf. Parallel and Distributed Computing, Applications and Technologies</title>
		<meeting>1st Int. Workshop on Sensor Networks and Ambient Intelligence, held in conjunction with the 9th Int. Conf. Parallel and Distributed Computing, Applications and Technologies<address><addrLine>Dunedin, New Zealand; Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2008-12-01">2008. December 1-4</date>
			<biblScope unit="page" from="425" to="430" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title/>
		<ptr target="http://labs.sentilla.com/" />
	</analytic>
	<monogr>
		<title level="j">The Sentilla labs</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Using Mobile Agents as an Effective Technology for Wireless Sensor Networks</title>
		<author>
			<persName><forename type="first">F</forename><surname>Aiello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Fortino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Guerrieri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd IEEE/IARIA Int. Conf. Sensor Technologies and Applications (SENSORCOMM 2008)</title>
		<meeting>2nd IEEE/IARIA Int. Conf. Sensor Technologies and Applications (SENSORCOMM 2008)<address><addrLine>France; Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2008-08-25">2008. August 25-31</date>
			<biblScope unit="page" from="549" to="554" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Towards a Mobile Agent Framework for Sensor Networks</title>
		<author>
			<persName><forename type="first">L</forename><surname>Szumel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lebrun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Owens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd IEEE Workshop on Embedded Networked Sensors (EmNetS-TT )</title>
		<meeting>2nd IEEE Workshop on Embedded Networked Sensors (EmNetS-TT )<address><addrLine>Sydney, Australia; Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2005-05-30">2005. May 30-31</date>
			<biblScope unit="page" from="79" to="87" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Enabling Direct Communication Between Mobile Agents in Wireless Sensor Networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Suenaga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Honiden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1st Int. Workshop on Agent Technology for Sensor Networks (ATSN-07), jointly held with the 6th Int. Joint Conf. Autonomous Agents and Multiagent Systems (AAMAS-07)</title>
		<meeting>1st Int. Workshop on Agent Technology for Sensor Networks (ATSN-07), jointly held with the 6th Int. Joint Conf. Autonomous Agents and Multiagent Systems (AAMAS-07)<address><addrLine>Honolulu, HI</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-05-14">2007. May 14</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<ptr target="http://sourceforge.net/projects/agentfactory/files/" />
		<title level="m">Agent Factory Micro Edition (AFME)</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">The nesC Language: A Holistic Approach to Networked Embedded Systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Gay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Levis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Von Behren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Welsh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Brewer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Culler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGPLAN Conf. Programming Language Design and Implementation (PLDI 2003)</title>
		<meeting>ACM SIGPLAN Conf. Programming Language Design and Implementation (PLDI 2003)<address><addrLine>San Diego, CA, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003-06-09">2003. June 9-11</date>
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Programming Sensor Networks Using Abstract Regions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Welsh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Mainland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1st USENIX/ACM Symp. Networked Systems Design and Implementation (NSDI&apos;04)</title>
		<meeting>1st USENIX/ACM Symp. Networked Systems Design and Implementation (NSDI&apos;04)</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">F</forename><surname>Aiello</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Beyond Event Handlers: Programming Wireless Sensors with Attributed State Machines</title>
		<author>
			<persName><forename type="first">O</forename><surname>Kasten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Römer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th Int. Symp. Information Processing in Sensor Networks</title>
		<meeting>4th Int. Symp. Information essing in Sensor Networks<address><addrLine>Los Angeles, CA, USA; Piscataway, NJ, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2005-04-24">2005. April 24-27</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Towards Role-Based Programming</title>
		<author>
			<persName><forename type="first">H</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Alkins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CSCW&apos;06</title>
		<meeting>CSCW&apos;06<address><addrLine>Banff, AB, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-11-04">2006. November 4-8</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Maté: A Tiny Virtual Machine for Sensor Networks</title>
		<author>
			<persName><forename type="first">P</forename><surname>Levis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Culler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 10th Int. Conf. Architectural Support for Programming Languages and Operating Systems (ASPLOS X)</title>
		<meeting>10th Int. Conf. Architectural Support for Programming Languages and Operating Systems (ASPLOS X)<address><addrLine>San Jose, CA, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002-10-05">2002. October 5-9</date>
			<biblScope unit="page" from="85" to="95" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Mobile Agent Platform for Sun SPOT (MAPS)</title>
		<ptr target="http://maps.deis.unical.it" />
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Design Patterns: Elements of Reusable Object-Oriented Software</title>
		<author>
			<persName><forename type="first">E</forename><surname>Gamma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Helm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vlissides</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">An extension to UML for the modeling of mobile agent-based software systems</title>
		<author>
			<persName><forename type="first">K</forename><surname>Saleh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>El-Morr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M-Uml</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Softw. Technol</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="219" to="227" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Performance Evaluation of Mobile-Agent Middleware: A Hierarchical Approach</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dikaiakos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kyriakou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Samaras</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th IEEE Int. Conf. Mobile Agents</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>5th IEEE Int. Conf. Mobile Agents<address><addrLine>Atlanta, GA, USA; Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001-12-02">2001. December 2-4</date>
			<biblScope unit="volume">2240</biblScope>
			<biblScope unit="page" from="244" to="259" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Body Sensor Networks</title>
		<author>
			<persName><forename type="first">G.-Z</forename><surname>Yang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Development of Body Sensor Network Applications using SPINE</title>
		<author>
			<persName><forename type="first">R</forename><surname>Gravina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Guerrieri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fortino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Bellifemine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Giannantonio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sgroi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. Systems, Man, and Cybernetics (SMC 2008)</title>
		<meeting>IEEE Int. Conf. Systems, Man, and Cybernetics (SMC 2008)<address><addrLine>Singapore</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-10">2008. October</date>
			<biblScope unit="page" from="12" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Platform-Independent Development of Collaborative WBSN Applications: SPINE2</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bellifemine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Fortino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Giannantonio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Guerrieri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. Systems, Man, and Cybernetics (SMC 2009)</title>
		<meeting>IEEE Int. Conf. Systems, Man, and Cybernetics (SMC 2009)<address><addrLine>San Antonio, TX, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="11" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<ptr target="http://spine.tilab.com" />
		<title level="m">Signal Processing In Node Environment (SPINE)</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Nearest neighbor pattern classification</title>
		<author>
			<persName><forename type="first">T</forename><surname>Cover</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="21" to="27" />
			<date type="published" when="1967">1967</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Quinlan</surname></persName>
		</author>
		<title level="m">C4.5: Programs for Machine Learning</title>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Activity Recognition and Monitoring Using Multiple Sensors on Different Body Positions</title>
		<author>
			<persName><forename type="first">U</forename><surname>Maurer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Smailagic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Siewiorek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Deisher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd Int. Workshop on Wearable and Implantable Body Sensor Networks (BSN 2006)</title>
		<meeting>3rd Int. Workshop on Wearable and Implantable Body Sensor Networks (BSN 2006)<address><addrLine>Boston, MA, USA; Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2006-04-03">2006. April 3-5</date>
			<biblScope unit="page" from="113" to="116" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">ASPINE: An Agent-Oriented Design of SPINE</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bellifemine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Fortino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Workshop on Objects and Agents (WOA&apos;09)</title>
		<meeting>Workshop on Objects and Agents (WOA&apos;09)<address><addrLine>Parma, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-07-09">2009. July 9-10</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
