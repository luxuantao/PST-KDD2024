<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Inconsistency Detection and Resolution for Context-Aware Middleware Support</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Chang</forename><surname>Xu</surname></persName>
							<email>changxu@cs.ust.hk</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Hong Kong University of Science and Technology Clear</orgName>
								<address>
									<addrLine>Water Bay</addrLine>
									<settlement>Kowloon, Hong Kong</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Cheung</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Hong Kong University of Science and Technology Clear</orgName>
								<address>
									<addrLine>Water Bay</addrLine>
									<settlement>Kowloon, Hong Kong</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Inconsistency Detection and Resolution for Context-Aware Middleware Support</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">4BA5A2974A26C14EC64C4CBB92EBB40C</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T09:35+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.2.1 [Software Engineering]: Requirements/Specifications -Methodologies Algorithms</term>
					<term>Design</term>
					<term>Management</term>
					<term>Performance Pervasive Computing</term>
					<term>Context Modeling</term>
					<term>Context Consistency Management</term>
					<term>Semantic Matching</term>
					<term>Proactive Repairing</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Context-awareness is a key feature of pervasive computing whose environments keep evolving. The support of context-awareness requires comprehensive management including detection and resolution of context inconsistency, which occurs naturally in pervasive computing. In this paper we present a framework for realizing dynamic context consistency management. The framework supports inconsistency detection based on a semantic matching and inconsistency triggering model, and inconsistency resolution with proactive actions to context sources. We further present an implementation based on the Cabot middleware. The feasibility of the framework and its performance are evaluated through a case study and a simulated experiment, respectively.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Pervasive computing environments encompass a spectrum of computation and communication devices that seamlessly augment human thoughts and activities <ref type="bibr" target="#b20">[21]</ref>. Applications in this type of environments are often context-aware, using various kinds of context such as location and time to adapt to the evolving environments and provide smarter services. For example, a mobile phone would vibrate rather than beep in a concert if the system knows the user's location. Pervasive computing applications need to be context-aware in order to respond quickly to their dynamic computing environments. The growing demand of contextawareness poses an impending requirement on context consistency management.</p><p>In pervasive computing, the context of a computation task refers to the circumstances or situation in which the task takes place (e.g., user's current location and activity). Context consistency is maintained when there is no contradiction in a computation task's context; otherwise context inconsistency is said to occur. To understand the meaning of context contradiction, let us consider a scenario from the healthcare industry:</p><p>Peter is a doctor working for Hope Hospital. He carries a Personal Digital Assistant (PDA) as his agent for arranging daily activities. Many kinds of context, such as the environment in which Peter is working, the room in which Peter is located, and the condition of a patient being taken care of by Peter, may affect the agent's suggestion for Peter's next activity. Suppose that at some time the agent acquired three context pieces from different sources:</p><p>(1) Peter is in the operating theatre (user location);</p><p>(2) An operation is being performed in Room 3504 (room status);</p><p>(3) Peter is looking up medical resources (user activity).</p><p>From ( <ref type="formula">1</ref>) and ( <ref type="formula">2</ref>), the agent would probably conclude that Peter is occupied with an operation based on its pre-obtained information that Room 3504 is the operating theatre. However, from (3) the agent might draw another conclusion that Peter is not attending an emergency and therefore able to help patient Michael immediately if he becomes unconscious at any moment. The two opposite assessments reflect the contradiction in the current context, i.e., a conflicting understanding of the surrounding environment. Thus the agent might have difficulty in deciding whether to guide Peter to Michael to check his condition or forward this request to another doctor. As a result, the agent might fail to function correctly.</p><p>There are a number of reasons why context inconsistency occurs. In the above scenario, it could be inaccurate location detection (e.g., Peter is passing by instead of actually staying in the operating theatre) or incorrect activity reasoning (e.g., Peter is walking around his office desk on which are some medical resources instead of looking up them at that moment). However, regardless of which reason, the agent can hardly detect and resolve such inconsistencies by itself due to the lack of adequate reasoning capabilities, global situation assessment and effective repairing actions, which typically require considerable computing resources that are not available for portable pervasive computing agents.</p><p>An unfortunate observation is that context inconsistency is commonly found in real-life systems. ActiveCampus is a real-life example presented in <ref type="bibr" target="#b7">[8]</ref>. When context inconsistency occurs due to stale data, ActiveCampus is unable to correctly estimate a person's location, which could affect the normal functioning of some services. Our research shows that the occurrence of context inconsistency stems from the natural imperfectness of context:</p><p>-Highly dynamic environments make context easily obsolete <ref type="bibr" target="#b10">[11]</ref>: For example, the location context of a fast-moving subject (e.g., a doctor running to an emergency) is prone to errors. -Context can be offered by heterogeneous sources under different standards: Various sensing technologies and standards may lead to semantically contradicting context (e.g., "inside the room" vs. "near the door but outside the room"). -Context reasoning may introduce inaccurate information due to computing-resource limitation: The requirement of real-time response (i.e., time limitation) may result in partial consideration of available context in inferring high-level context such as user activity. -Network disconnection or failures lead to incomplete context <ref type="bibr" target="#b10">[11]</ref>: The mobility of pervasive computing increases the chances of context loss (e.g., "Peter and Michael enter the operating theatre" vs. "only Peter enters the operating theatre").</p><p>The natural existence of these imperfect sources makes context inconsistency a common phenomenon. It is difficult to guarantee the correctness, integrity and non-redundancy of context in pervasive computing. However, this problem has not been explicitly addressed by existing context-aware systems (e.g., Context Toolkit <ref type="bibr" target="#b5">[6]</ref>, EgoSpace <ref type="bibr" target="#b12">[13]</ref>, Gaia <ref type="bibr" target="#b20">[21]</ref> and Aura <ref type="bibr" target="#b24">[25]</ref>). To overcome this, we have identified two key issues:</p><p>-Inconsistency detection: Context inconsistency is a semantic phenomenon rather than a syntactic one, whose detection requires non-trivial reasoning work. For example, a context piece "free / not in an emergency" may contradict with "performing an operation", while it can coexist with "looking up medical resources". Usually, the detection is based on common sense and user-specified rules. -Inconsistency resolution: Context evolution in pervasive computing is dynamic and fast, which requires an automatic inconsistency resolution mechanism. Moreover, simple repairing on current context is inadequate for maintaining a stable running environment for applications. Proactive control or feedback to context sources is required to prevent future inconsistencies.</p><p>To the best of our knowledge in the existing work on pervasive computing, a systematic study of these two issues has not been conducted. Although it could be argued that they are similar to the evidence aggregation problem <ref type="bibr" target="#b23">[24]</ref> from the artificial intelligence (AI) discipline, the similarity only lies in that both of them relate to information inconsistency. The causes of inconsistency and the corresponding challenges in resolving it actually differ a lot (please refer to Section 2). Moreover, this paper aims at proposing a consistency management framework using software engineering methodology rather than working on sophisticated inconsistency detection algorithms using AI techniques.</p><p>The remainder of the paper is organized as follows. Sections 2 and 3 introduce related work of recent years and preliminary concepts on context modeling, respectively. Section 4 presents our framework for context consistency management by focusing on complex context and constraints modeling, and inconsistency detection and resolution. Section 5 briefly introduces the implementation of Cabot <ref type="bibr" target="#b25">[26]</ref> -a middleware that supports context consistency management. This is followed by a case study in Section 6 and a simulated experiment in Section 7. Section 8 discusses the feasibility of adapting existing technologies to our work. The last section concludes the paper. in <ref type="bibr" target="#b8">[9]</ref> propose a conceptual context model that is constructed using an entity-relationship based language. Henricksen et al. in <ref type="bibr" target="#b10">[11]</ref> comprehensively analyze context by covering temporal characteristics, information imperfection, various representations and high interrelation. These works are mostly concerned with context modeling techniques, while the problem of context inconsistency is not adequately addressed. Advanced issues about inconsistency detection and resolution are rarely discussed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>Some research projects, e.g., Gaia <ref type="bibr" target="#b20">[21]</ref>, Aura <ref type="bibr" target="#b24">[25]</ref> and EasyLiving <ref type="bibr" target="#b2">[3]</ref>, have been proposed to provide middleware support for pervasive computing. They are mainly concerned about the organization of and the collaboration among pervasive computing devices and services. Other infrastructure projects mostly focus on the context processing, reasoning and programming support. An earlier representative work is Context Toolkit presented in <ref type="bibr" target="#b5">[6]</ref>. It assists developers by providing abstract components (e.g., context widgets, interpreters and aggregators) that can be connected together to capture and process context data from sensors. Context Toolkit falls short in supporting highly-integrated context applications. To overcome this, Griswold et al. in <ref type="bibr" target="#b7">[8]</ref> propose to apply a hybrid mediator-observer pattern in the system architecture. Henricksen et al. in <ref type="bibr" target="#b9">[10]</ref> present a multi-layer framework which supports both branching and triggering programming models. Ranganathan et al. in <ref type="bibr" target="#b18">[19]</ref> discuss how to resolve potential semantic contradictions in context by reasoning based on first-order predicate calculus and Boolean algebra. In <ref type="bibr" target="#b19">[20]</ref> they extend the work to reasoning about context uncertainty using AI mechanisms like fuzzy logic. These works have tackled several challenges in context processing, reasoning and programming, and conducted preliminary research on context certainty representation and uncertainty reasoning, but inadequate attention has been paid to the repairing of inconsistent context.</p><p>Pervasive computing, a relatively new but fast growing discipline, shares many observations and technology with AI, active databases and software engineering disciplines. In the AI discipline, expert systems have been developed to support intelligent strategy making. Much effort has been made on the evidence aggregation problem so that the systems are able to make reasonable strategies based on contradicting evidences or rules, but the causes of inconsistency are rarely addressed. Composite event detection is an important issue in the active databases discipline for triggering pre-defined actions once desired events are detected. E-brokerage <ref type="bibr" target="#b13">[14]</ref> and Amit <ref type="bibr" target="#b0">[1]</ref> are two widely known projects aimed at detecting composite event occurrences or situation changes with complex timing constraints. The difference lies in the facts that the former is based on event instance modeling and the latter on event type modeling. In the software engineering discipline, CARISMA <ref type="bibr" target="#b3">[4]</ref> is proposed as reflective middleware support for mobile appli-cations. It focuses on policy conflict resolution that is similar to our work, but it assumes that accurate context information can be collected by probing sensors periodically, which is different from the basis on which our work is built. Nentwich et al. propose a framework for repairing inconsistent XML documents based on the xlinkit technology <ref type="bibr" target="#b14">[15]</ref>, which generates interactive repairing options from first order logical formulae that constrain the documents being checked <ref type="bibr" target="#b15">[16]</ref>. However, the framework does not support dynamic computing environments. Moreover, repairing documents alone is inadequate for resolving context inconsistency in pervasive computing. Although the above researches help provide similar experience in problem analysis and resolution, their technologies are inadequate for managing context consistency in two aspects:</p><p>-Inconsistency detection: Complex context constraints (e.g., timing, spatial and data constraints) cannot be directly modeled.</p><p>For example, the support of generation time, effective time and freshness requirement for context consistency management is beyond the modeling capabilities of existing technologies. In addition, the inconsistency detection algorithm differs due to these new complex constraints. -Inconsistency resolution: Interactive and simple repairing is unsuitable for dynamic and complex pervasive computing environments. The automatic repairing of current inconsistencies and the proactive preventing of future inconsistencies cannot be supported by any of existing technologies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">CONTEXT MODELING</head><p>Context can be roughly divided into physical context and logical context. The former is like evidence, recording various events arising in the physical world (e.g., an object's movement and location), while the latter is typically used for situation assessment, only existing in logical models (e.g., a user's intent and mood). Thus, a general data structure is required for context representation. However, we do not adopt a simple representation like namevalue pairs or tuple space <ref type="bibr" target="#b12">[13]</ref> for the sake of manageability because it often requires multiple tuples to represent a single context piece. On the other hand, neither do we want to list all context characteristics as proposed by Henricksen et al. <ref type="bibr" target="#b10">[11]</ref> because of the high management and computation cost.</p><p>We define context ctx = (subject, predicate, object, time, area, certainty, freshness) as a seven-field data structure, where:</p><p>-Subject, predicate and object give the content of the context, where subject and object are related by predicate (using simple English sentence structure), e.g., Peter (subject) enters (predicate) the operating theatre (object). -Time and area specify the temporal and spatial constraints relevant to the context: time represents the time or period in which the context keeps effective (e.g., "10am on Jun 7, 2005" or "from Apr 1 to Jul 1, 2005"); area is the place to which the context relates (e.g., "Hope Hospital"). -Certainty is a percentage evaluating the probability level of the context (e.g., "90%"), and freshness indicates the generation time of the context (e.g., "10 seconds ago").</p><p>There are two time-related fields in the structure: time and freshness. The former is a context's effective time, while the latter specifies a context's generation time. Normally they are different. For example, people relation context "Michael is taken care of by</p><p>Peter" may have a long effective time (say, two months) but its generation time may have been "two days ago". In pervasive computing, freshness is a basic requirement for evaluating context validness because computing environments tend to change fast and the current context may expire quickly. Such consideration is not supported in event detection related studies like <ref type="bibr" target="#b0">[1]</ref> and <ref type="bibr" target="#b13">[14]</ref>.</p><p>For the purpose of complex context recognition, two concepts context instance and context pattern are introduced: a context instance is defined by instantiating all fields of ctx, while a context pattern (or pattern for short) is defined by instantiating some of its fields. Each uninstantiated field (if any) is set to any, which is a special predefined value. Intuitively, each pattern represents a family of context instances. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">MANAGING CONTEXT CONSISTENCY</head><p>A key requirement in context consistency management is the ability to bridge the gap between the context recognized by the middleware and the inconsistency to which the middleware needs to react. This paper aims at bridging the gap by presenting a comprehensive consistency management framework for context in pervasive computing. Three requirements have been identified for this type of computing environments:</p><p>-Semantic reasoning: Context inconsistency is a semantic phenomenon, which requires necessary reasoning for inconsistency detection. -Automatic resolution: Context evolution is dynamic and fast, which requires an automatic resolution mechanism for any detected inconsistency. -Feedback control: Repairing on current context is inadequate, which requires feedback to context sources to prevent future inconsistencies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Model Complex Context and Constraints</head><p>Let us first take a look at an example of complex context:</p><p>A doctor enters the operating theatre, where an operation is going to be performed in ten minutes on a patient, who now looks a little nervous.</p><p>This example contains several context pieces, including physical ones (e.g., a doctor's location) and logical ones (e.g., a patient's state of mind), and some constraints, including timing constraints (e.g., "an operation will be performed in ten minutes"), spatial constraints (e.g., "the doctor and the patient are in the same room") and data constraints (e.g., "the person entering the room is a doctor"). To model such complex context, we begin with basic blocks (e.g., context instances and patterns in Section 3) and use operations (e.g., context matching) to connect them together. The match function is a kernel process of evaluating whether a given field of a context instance matches its counterpart of a pattern under some unification rule. The notation of unification rules is based on concept semantic relationships. Let E(c) denote the element set represented by concept c. Any two concepts c 1 and c 2 are subject to one of five semantic relationships <ref type="bibr" target="#b26">[27]</ref>:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Semantic Context Matching</head><formula xml:id="formula_0">-equivalent: if E(c 1 ) = E(c 2 ); -subsumed: if E(c 1 ) ⊂ E(c 2 ); -including: if E(c 1 ) ⊃ E(c 2 ); -disjoint: if E(c 1 ) ∩ E(c 2 ) = φ ; -intersecting: otherwise.</formula><p>Based on the above five semantic relationships, unification rules express the conditions under which a given context instance and a pattern can be matched. A matching is recognized if each field (except time) value v 1 in context instance ins is unifiable with its counterpart v 2 in pattern pat as follows:</p><p>If v 2 = any, or v 1 and v 2 satisfy one of six conditions: (1) identical condition (v 1 = v 2 ), (2) equivalent condition (v 1 and v 2 are equivalent), (3) plug-in condition (v 1 and v 2 are equivalent or subsumed), (4) covering condition (v 1 and v 2 are equivalent or including), <ref type="bibr" target="#b4">(5)</ref> overlapping condition (v 1 and v 2 have a non-disjoint relationship), or (6) unrelated condition (v 1 and v 2 are disjoint), then v 1 is unifiable with v 2 ; Otherwise, v 1 is not unifiable with v 2 .</p><p>Time is a special field following different unification rules including conditions like close to, before, after, within and covering. These all have intuitive interpretations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 3. A context matching example</head><p>Different fields in a pattern can apply different conditions. Figure <ref type="figure">3</ref> illustrates an example, which shows that context instance ins, "Peter enters the operating theatre", matches pattern pat, "A person goes into a 3rd-floor room". Note that the certainty field in pat has an "at least" interpretation. As such, certainty "90%" in ins is unifiable with certainty "80%" in pat under the plug-in condition. The same interpretation applies to the freshness field.</p><p>The above example assumes the following concept semantic relationships (which can be inferred from an ontology database that is maintained by the system administrator):</p><p>match("plug-in", "Peter", "person") = true match("equivalent", "enter", "go into") = true match("plug-in", "operating theatre", "3rd-floor room") = true Context matching relates context instances and patterns under semantic interpretations, supporting higher expressiveness in context queries than simple byte-by-byte comparisons. As such, it is also known as semantic context matching. In context inconsistency detection (see Section 4.2), automatic reasoning can be supported by semantic context matching. They are enforced at runtime. Each constraint takes the form of (rule, j, field j , k, field k ), meaning that if there are two context instances matched for pat j and pat k respectively, their values in fields field j and field k , respectively, should satisfy the given rule (unification rule). To make the whole complex context ccx assessed to be the current situation, there must be a group of context instances matching each pattern in ccx respectively, and these context instances must also satisfy all ccx's constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Complex Context and Constraints</head><p>Figure <ref type="figure" target="#fig_1">4</ref> illustrates the complex context example discussed at the beginning of Section 4.1. It consists of four patterns and eight constraints between them (including three timing constraints, three spatial constraints and two data constraints), represented by dashed lines. We explain three of them for illustration:</p><p>-Timing constraint ("+10 min close to", 1, "time", 3, "time"):</p><p>The time when a person enters such a place is 10 minutes before an operation is performed there. -Spatial constraint ("equivalent", 1, "area", 3, "area"): A person enters a place where an operation is going to be performed in ten minutes. -Data constraint ("equivalent", 1, "subject", 2, "subject"):</p><p>The person who enters some place is a doctor.</p><p>The enforcement of constraints over the "tables" derived from context matching is similar to the equi-join in relational databases <ref type="bibr" target="#b17">[18]</ref>. Each "table" contains matched context instances for each corresponding pattern, and the join "columns" are specified by constraints. The difference is that "columns" are related by semantics, in particular when we use the equivalent condition which connects two field values of similar meaning (e.g., and "go into"). This kind of join is called semantic-join.</p><p>The semantic matching and join used in our model is a major difference from other models. An advantage is that it simplifies the task of describing general context inconsistency (e.g., context "some person is performing two unrelated jobs at the same time" is considered inconsistent).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Detect and Resolve Context Inconsistency</head><p>We regard context inconsistency as a special kind of complex context, in which situation assessment is subject to inherent contradiction. Based on the previous model preparation, this subsection introduces inconsistency triggering which provides an effective mechanism for inconsistency detection and resolution. Our model of inconsistency triggers is adapted from the Event-Condition-Action (ECA) triggers in active database systems <ref type="bibr" target="#b17">[18]</ref>. We define an inconsistency trigger as tgr = (event, condition, action):</p><p>-Event is a context-related change that activates the trigger. It specifies a complex context description ccx that describes our interested situation. The change occurs when ccx is assessed to be the current situation. -Condition is a context-related query that is run when the trigger is activated. It includes a group of patterns that represent a series of tests.</p><p>Each pattern should match at least one context instance in the context repository such that the whole condition is satisfied. -Action is a procedure that is executed when the trigger is activated and its condition is satisfied.</p><p>Figure <ref type="figure">5</ref> illustrates how to use inconsistency triggering to describe the problematic situation discussed in Section 1 (the Action part is omitted). Please note that constraints also apply to conditions. The execution of an inconsistency trigger can be divided into three steps: (1) context detection, (2) condition evaluation, and (3) action execution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Inconsistency Detection Algorithm</head><p>Step 1 focuses on the monitoring of incoming time-stamped context events (mainly sensed or derived contexts);</p><p>Step 2 performs queries against stored history contexts (mainly domain contexts).</p><p>Context nature is a factor affecting the execution of inconsistency triggers. The detection buffer (or matching queues, please refer to the following algorithm) size is decided by the freshness requirements of related patterns in Step 1. To save memory, usually only sensed and derived contexts are monitored in this step. These contexts often have a strong freshness requirement, leading to short matching queues.</p><p>Compared to event detection, inconsistency detection often needs to consider various types of constraints (e.g., timing, spatial and data constraints). Even for timing constraints, inconsistency detection has to differentiate a context's generation time from its effective time, while event detection only focuses on an event's occurrence time. From the perspective of timing constraints, an event's occurrence time is analogous to a context's generation time. So the context inconsistency detection can subsume event detection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 5. An inconsistency trigger</head><p>We give the detection algorithm below:</p><p>( The algorithm consists of three threads: T 1 performs matching for each incoming context instance, and attaches a copy of it to each matched pattern's matching queue. T 2 monitors all matching queues to see whether there is a group of context instances able to activate a trigger with all its conditions and constraints satisfied. T 1 and T 2 work as a producer-consumer pair of context instances for inconsistency triggering purposes. T 3 manages all running timers and removes expired context instances from their located matching queues when necessary.</p><p>According to the classification from Snoop <ref type="bibr" target="#b4">[5]</ref> for instance consumption, the above algorithm adopts the continuous policy <ref type="bibr" target="#b0">[1]</ref>, i.e., maximizing the use of each context instance according to its relevant freshness requirement (see T 2 ). The freshness requirement of a pattern specifies the period in which a matched context instance for this pattern stays valid. Under this specification, the algorithm detects all possible inconsistencies among valid captured context instances. In implementation, freshness requirements can be enforced by timers.</p><p>The continuous policy for event detection is generally impractical because of its unlimited memory cost but such policy is feasible for our complex context detection. This is because one can control the memory cost by setting a reasonably strong freshness requirement, i.e., a short time period. The maximum memory cost of our implemented framework is below 23MB (including the Java VM's memory cost) under the experimental setting in Section 7.</p><p>Another consideration is delay time. New contexts have to be kept in matching queues for a period dependent on relevant patterns' freshness requirements. Fortunately, the delay time is also controllable (fully decided in the design phase by specifying freshness requirement). Users are urged to avoid unreasonably weak freshness requirements in Step 1. Weak freshness requirements should be moved to Step 2, which does not affect the delay time. Another solution is to allow access to these temporary context data (still in matching queues) at the cost of possible inconsistency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Inconsistency Resolution</head><p>The context matching and inconsistency triggering model contributes to inconsistency detection by semantically defining and discovering: (1) the relationships between context instances and patterns, and (2) the relationships between context instances (Figure <ref type="figure" target="#fig_2">6</ref>). Once an inconsistency is detected, proper repairing actions need be taken to guarantee the accuracy of context. Recently, a substantial amount of work has been made on active systems, which either react automatically to environment changes (reactive systems) or predict changes in their environments (proactive systems) <ref type="bibr" target="#b0">[1]</ref>. Concerning inconsistency resolution, the traditional accept/reject policies belong to reactive repairing actions, which work when actual inconsistencies have occurred.</p><p>Reactive repairing actions cannot effectively prevent future inconsistencies. To overcome this limitation, we propose a mechanism to support both reactive and proactive repairing actions:</p><p>-Reactive repairing actions are performed to repair context data in the context repository. This is analogous to the accept/reject policy except that we also support on-demand context update. -Proactive repairing actions are performed to repair context sources, e.g., to control or adjust problematic sensing devices to avoid further occurrences of inconsistent contexts.</p><p>Two policies are supported by reactive repairing actions:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Static policy:</head><p>-Delete pre-specified context instances (e.g., delete the instance matched by pattern pat 1 ). Primitive: delByPat(patternID)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Dynamic policy:</head><p>-Delete most uncertain context instances (e.g., delete the instance with the lowest uncertainty). Primitive: delByUct(LOWEST) -Re-query relevant context sources to get a new copy for some context instances. Primitive: uptByPat(patternID, queryTime)</p><p>By default, all context instances kept in the detection buffer will be moved to the context repository automatically when relevant timers expire except for those which have to be deleted according to the static policy. In the dynamic policy, the query time has to be enforced when executing uptByPat. Such time enforcement is usually reasonable and useful as discussed in <ref type="bibr" target="#b11">[12]</ref>, where in a location re-query example, a one-minute time limit indicates both that the user can afford to wait some time for the query to completed, and that the user desires the location provider to expend a sufficient amount of effort to locate a certain person. Although too long a time limit is unacceptable for the timely resolution of inconsistency, multi-thread technology for parallel processing of inconsistency can alleviate this problem.</p><p>Two policies are supported by proactive repairing actions:</p><p>1. Active policy:</p><p>-Control the lifecycle of a context source (after delayTime).</p><p>Primitive: srcCtrlByPat(patternID, PAUSE/ RESUME/RESTART/STOP/START, delayTime) -Count/get the inconsistency times for/of a context source.</p><p>Primitive: incCntByPat/getCntByPat(patternID)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Passive policy:</head><p>-Send feedback to a context source and allow it to adjust itself.</p><p>Primitive: fdbkByPat(patternID)</p><p>Most sensor devices and software programs support direct control from the middleware on their lifecycles, which makes possible for them to stop generating contexts or restart at a later time when necessary. The passive policy is based on the observation that some advanced context sources can adjust error/uncertainty by changing algorithm parameters (e.g., a location deriving algorithm). A practical example is Microsoft RADAR <ref type="bibr" target="#b1">[2]</ref> with a 50% uncertainty on its location calculation and a maximum error of 3 meters. The uncertainty can be lower if a greater error is allowed.</p><p>The following gives example repairing actions for the hospital scenario we discussed earlier (see Figure <ref type="figure">5</ref>):</p><p>Step 1: repairing context data (1) uptByPat(1,500) (2) uptByPat(4,500) (3) int pid = delByUct(LOWEST,{1,4})</p><p>Step 2: repairing context sources (4) incCntByPat(pid) (5) int t = getCntByPat(pid) (6) if (t&gt;2) fdbkByPat(pid) <ref type="bibr" target="#b6">(7)</ref> if (t&gt;5) srcCtrlByPat(pid,RESTART,1000) (8) if (t&gt;10) srcCtrlByPat(pid,STOP,200)</p><p>The above code tries to update the context instances matched for patterns p 1 and p 4 , and decide which one has the lower uncertainty. For the context source which generates this context instance, its inconsistency counter is increased, and then some action (e.g., feedback sending, restarting or stopping) is taken according to the counter value.</p><p>Supporting proactive repairing actions is non-trivial. Different context sources may vary in the support of inconsistency repairing, and a designer may have no knowledge about the context sources involved at runtime. Currently, illegal repairing actions are ignored automatically. For future extension, we are investigating a negotiation-based repairing mechanism which integrates the consideration of learning supported repairing actions at runtime.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">IMPLEMENTATION</head><p>The consistency management framework assumes the availability of an underlying context middleware. We have implemented the framework based on one of our research projects -Cabot. Cabot is a software infrastructure supporting Context-aware Applications Built on Ontology Technology developed by JDK 1.4.2. From Cabot's point of view, a pervasive computing environment is composed of an application layer, a middleware layer and a context source layer (Figure <ref type="figure">7</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 7. The Cabot system architecture</head><p>The middleware layer is the kernel part of Cabot. It includes five fundamental functionalities: application management, context management, context matching, semantic reasoning and thirdparty services management. A more detailed introduction to these functionalities can be found in <ref type="bibr" target="#b25">[26]</ref>.</p><p>Our consistency management framework is realized as a thirdparty service plugged into Cabot. When a new context instance arrives, all plug-in services are invoked one by one for context filtering purposes such that management tasks for like context consistency can be achieved. An editor in the framework enables application developers to customize their inconsistency triggers.</p><p>Repairing actions are also specified in the design phase. Currently, they are implemented through a callback mechanism in terms of user-designed java classes that use the framework primitives (see Section 4.2.2). The framework is responsible for maintaining a consistent context repository. Applications access context of interest via queries or topic subscription.</p><p>To support effective context matching and inconsistency detection, the Cabot kernel has been rewritten. Cabot's early version was built on the xlinkit technology in which computationally expensive checking consumed much processing time. Moreover, semantic-join and complex context detection were not supported in that version. Cabot's current version has increased expressive power for context capture and inconsistency detection. The new detection algorithm is based on the Amit technology (see Section 8).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CASE STUDY</head><p>This section takes an automatic vehicle (AV) system based on the Radio Frequency Identification (RFID) technology as a case study. AV system is one of our ongoing projects on contextawareness with a goal to provide continuous remote control on intelligent vehicles working for humans in an adverse environment (e.g., too dark, dangerous, hot or noisy).</p><p>To facilitate the location estimation of vehicles, some reference sites are chosen and installed with RFID tags. These tags together with those attached to vehicles are used for tracing each vehicle, routing them to perform designated tasks at different destinations.</p><p>AV system is context-aware in that it controls vehicles based on the environmental context and each vehicle's condition. Its typical tasks include automatic path selection and collision avoidance.</p><p>In practice, certain conditions may introduce incorrect data to AV system. For example, a fast moving RFID tag attached to a vehicle might be missed by RFID antennae (e.g., "detected" vs. "not detected"); overlapped RFID tags due to the close proximity of two vehicles could not be always distinguished (e.g., "tag A detected" vs. "tag B detected"); metal and electromagnetic goods would lead to reduced detection sensitivity (e.g., "no tag active"); and highlevel context reasoning services for inferring value-added context (e.g., "vehicle C enters area I" or "vehicle D is stopped in area II") might generate incorrect context (e.g., "leave" vs. "enter" or "moving" vs. "stopped").</p><p>As a result, context inconsistency naturally occurs in reality and affects the correct functioning of AV system. For example, automatic collision avoidance of multiple vehicles would fail if the existence of some RFID tags cannot be correctly identified or the current position of a moving vehicle cannot be precisely computed. In practice, multiple sensing technologies (e.g., infrared or ultrasonic) can be used for providing multiple data sources. However, this increases the probability of context redundancy and inconsistency because these technologies use different approaches and standards to compute related context data. AV system's strategies may be unexpectedly affected by inconsistent context and possibly generate incorrect control on vehicles.</p><p>Suppose that the following context sources have been set up (S: sensor devices, F: software programs, H: human operators (Figure <ref type="figure" target="#fig_3">8</ref>): H1: A console interface accepts user's inputs and generates onthe-fly goods conveying tasks.</p><p>We consider two major functions of AV system:</p><p>SELT: According to each vehicle's current location and activity, select the most suitable vehicle (e.g., close to the goods and free of tasks) to carry out a given task. CTRL: According to the environmental context feedback (e.g., the distance to other vehicles), adjust the controls on each moving vehicle to avoid collisions.</p><p>The SELT function may be affected by the precision of vehicle location computation, which is not always accurate (e.g., the LANDMARC algorithm has an average error of 1 meter under the experimental setting discussed in <ref type="bibr" target="#b16">[17]</ref>). The CTRL function depends much on the reports from two collision avoidance services, but sometimes they may report inconsistent situations (e.g., "vehi- Currently, the project is still under development. The feasibility of our consistency management framework needs further evaluation through practical studies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">PERFORMANCE MEASUREMENTS</head><p>The goal of performance measurement is to estimate the incoming context rate that Cabot can handle. Inspired by the scenario classifications in <ref type="bibr" target="#b0">[1]</ref>, we have designed four test scenarios:</p><p>Standby world: This is an empty scenario that does not define any inconsistency trigger. It gives an upper bound on the performance of Cabot's context processing.</p><p>Noisy world: This is a light scenario in which only a low percentage (12%) of the incoming context activates patterns in inconsistency triggers. The inconsistency triggers are not complex, i.e., no conditions or constraints.</p><p>Filtered world: This is a filtering scenario in which a high percentage (35%) of the incoming context activates the patterns in inconsistency triggers. However, the conditions of a high percentage (66%) of the activated inconsistency triggers are not satisfied. The inconsistency triggers are relatively complex (i.e., conditions are tested without constraints).</p><p>Complex world: This is a heavy scenario in which a quite high percentage (50%) of the incoming context activates the patterns in inconsistency triggers, and the conditions of a high percentage (66%) of these activated inconsistency triggers are satisfied. The inconsistency triggers are very complex (i.e., conditions are tested with constraints). (1) Cabot's upper bound was about 62500 context instances per minute. This rate was achieved when none of the incoming context instances takes part in any inconsistency detection.</p><p>(2) The lower bound was about 150 context instances per minute. This happened when quite complex inconsistency triggers were activated and evaluated frequently. This kind of case is unlikely to occur in reality.</p><p>(3) A relatively high percentage (88.5% for the filtered world and 83.7% for the complex world) of the total time was spent on condition pattern matching. This indicates that the condition evaluation (needs to query all history contexts) is computationally expensive. The reason is that our current implementation cannot utilize mature database technologies that do not support semantic matching and join.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">DISCUSSION</head><p>E-brokerage <ref type="bibr" target="#b13">[14]</ref> and Amit <ref type="bibr" target="#b0">[1]</ref> present two interesting solutions to the problem of event detection. Their solutions based on event modeling are similar to ours in that all three solutions focus on constraint specification and situation detection. E-brokerage <ref type="bibr" target="#b13">[14]</ref> is based on event instance modeling. Although it is impractical to adopt the continuous policy for event instance consumption be-cause of the lack of controllable constraints on instance freshness requirements (leading to unlimited memory cost), E-brokerage <ref type="bibr" target="#b13">[14]</ref> utilizes restricted instance relationships (e.g., the time interval between the i-th E 1 and E 2 instances) to limit the number of available event instances. However, context detection needs to maximize the use of each context instance within its valid period (specified by freshness requirement) in order to detect any possible inconsistency. The index of an available context instance, which is decided dynamically by its generation time and the relevant pattern's freshness requirement, cannot be modeled directly using restricted instance relationships which are essentially static.</p><p>The approach adopted by Amit <ref type="bibr" target="#b0">[1]</ref> is closer to ours. It is based on event type modeling since any event instance belonging to a relevant event type can participate in the target situation detection. In order to adapt to complex context detection in pervasive computing, Amit <ref type="bibr" target="#b0">[1]</ref> system's underlying data structures have to be modified to allow for more attributes such as effective time and area such that complex timing, spatial and data constraints can be modeled. Moreover, the detection algorithm has to be modified to enforce new complex constraints such as freshness requirement. Such adaptation work is non-trivial, and the adaptation result (plus our semantic matching and join for reasoning purposes) is equivalent to our proposed context model.</p><p>In inconsistency resolution, xlinkit <ref type="bibr" target="#b14">[15]</ref> is an excellent tool for XML document integrity checking. The major reason why xlinkit is not suitable for context consistency management is that it cannot adequately support the regular and frequent detection of information inconsistency. A direct application of xlinkit to inconsistency detection in dynamic pervasive computing environments requires repeatedly checking the entire context repository, which is computationally expensive. Our past experience of using it in Cabot's early version exhibited unsatisfactory performance because of the great amount of expensive checking. Cabot's current version outperforms its previous version by 3700%, 450%, 130% and 150% under the four simulated worlds, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">CONCLUSIONS AND FUTURE WORK</head><p>In this paper, we have studied the natural imperfectness of context in pervasive computing environments, and analyzed the hardness of context consistency management from two aspects: inconsistency detection and resolution. A formal semantic matching and inconsistency triggering model is proposed to capture inconsistent contexts. Then a proactive repairing mechanism is proposed to realize automatic inconsistency repairing. The whole framework has been implemented based on the Cabot middleware.</p><p>Our framework still has limitations in performance. We are considering more efficient matching algorithms built on mature database technologies. Moreover, the enumeration of all imaginable inconsistencies is somewhat impractical. So we are also working on incremental violation checking techniques for consistency constraints that are more feasible in practice. Other issues such as negotiation-based repairing mechanisms and scalability considerations will be incorporated into our improved framework.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .Figure 2 . A context patternFigure 1</head><label>121</label><figDesc>Figure 1. Two context instances</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. The complex context example Complex context ccx is defined as a group of patterns patterns = {pat 1 , pat 2 , … pat m } with a group of constraints constraints = {cns 1 , cns 2 , …, cns n }. Constraints are used to express the relationships between these patterns. They are enforced at runtime. Each constraint takes the form of (rule, j, field j , k, field k ), meaning that</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Context matching and inconsistency triggeringGenerally, when we detect inconsistency between new and old data stored in an information repository, common actions are to repair the repository based on two types of policies: (1) Accept policy: Accept new data into the repository and delete inconsistent old data for inconsistency-resolution; (2) Reject policy: Reject new data, and old data remain unchanged. For context, either policy solely focuses on the repairing on the repository, but pays little attention to repair the context sources. As such, the environment may still keep generating inconsistent contexts.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. AV system and context sources deployment S1: Four RFID detection systems provide signal strength information for the RFID tags detected in their sensing ranges. S2: The ultrasonic sensor installed in each vehicle provides the distance information to its adjacent barriers (e.g., vehicles and goods). S3: The accelerometer installed in each vehicle provides the tilt and vibration measurements of the vehicle.F1:The LANDMARC algorithm<ref type="bibr" target="#b16">[17]</ref> computes the real-time location of each vehicle (from S1). F2: A collision avoidance service reports possible collision when two vehicles are too close (from F1). F3: Another collision avoidance service reports possible collision between a vehicle and its adjacent barriers (from S2). F4: A vehicle status service provides each vehicle's current activity information (e.g., moving, loading or stopped) (from S3). F5: A task management program arranges everyday pre-scheduled goods conveying tasks.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>cle C is close to vehicle D" vs. "vehicles C and D are in different areas"). To alleviate the impact of possible context inconsistency, the following two inconsistency triggers are designed: SELT: If a vehicle's continuously computed locations vary largely (e.g., more than 2 meters) over a short period of time (e.g., 1 second), a possible location inconsistency occurs. Corresponding repairing actions: update the latest location (enforce query time &lt; 1 second) and delete the old one if they are too different. CTRL: If two collision reports from RFID-based and ultrasonicbased technologies are inconsistent, update the latter, and if they are still different, choose the former and increase the inconsistency counter for the latter. If the counter value reaches 5, restart the relevant ultrasonic sensor, and if the value has been already larger than 10, stop it and write system logs for suggested maintenance (possible damage).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Existing studies on context-awareness are mostly concerned with either the frameworks that support context abstraction or the data structures that support context queries. Pioneering work by Schilit et al.<ref type="bibr" target="#b21">[22]</ref> proposes using environment servers to manage context. The context model in this work is simple. Schmidt et al. present in<ref type="bibr" target="#b22">[23]</ref> a layered processing model in which sensor outputs are transformed into cues that comprise a set of values with certainty measurements. Gray et al. in<ref type="bibr" target="#b6">[7]</ref> are concerned with capturing context meta-information that describes features such as representation, quality, source, transformation and actuation. Harter et al.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Three context types are identified based on their context nature: sensed contexts (e.g., Peter enters the operating theatre) are collected by sensor devices; domain contexts (e.g., Peter takes care of Michael / Michelle was born in Jan 1977) are supplied by human operators; and derived contexts (e.g., Michael becomes unconscious) are computed by software programs based on existing contexts. Sensed and derived contexts typically change more frequently than domain contexts.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 1 . Performance measurement results</head><label>1</label><figDesc>Experiments were designed for comparing Cabot's performance in the four simulated worlds. They were performed on a Pentium IV 3.20-GHz machine running Windows XP Professional. A context source thread sent 2000 context instances to Cabot at 2 instances per second. Example contexts were generated and inconsistency triggers (3) were designed according to the requirement of each scenario (except the standby world).</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell cols="2">Each inconsistency</cell></row><row><cell cols="5">trigger contains 4 or 6 patterns and 11 constraints (if any). For</cell></row><row><cell cols="5">contrast, the repository contained fixed number (100) of history</cell></row><row><cell cols="5">context instances for condition testing for activated inconsistency</cell></row><row><cell cols="5">triggers. All freshness requirements of patterns in inconsistency</cell></row><row><cell cols="5">triggers were set to 10 seconds. Three parameters were monitored:</cell></row><row><cell cols="5">(1) Number of incoming context instances, activated triggers (i.e.,</cell></row><row><cell cols="5">all event patterns are matched) and triggered inconsistencies (i.e.,</cell></row><row><cell cols="4">all conditions are satisfied with constraint enforcement)</cell><cell></cell></row><row><cell cols="5">(2) Total time (sec), event pattern matching time (sec), condition</cell></row><row><cell cols="5">pattern matching time (sec), constraint enforcement time (sec) and</cell></row><row><cell cols="2">other overhead time (sec)</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">(3) Processed context instances (per min) and detected inconsis-</cell></row><row><cell>tency number (per min)</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>Sta.</cell><cell>Noi.</cell><cell>Fil.</cell><cell>Com.</cell></row><row><cell cols="2">World</cell><cell>World</cell><cell>World</cell><cell>World</cell></row><row><cell>Incoming Ctx.</cell><cell>2000</cell><cell>2000</cell><cell>2000</cell><cell>2000</cell></row><row><cell>Activated Tgr.</cell><cell>0</cell><cell>39</cell><cell>974</cell><cell>1310</cell></row><row><cell>Triggered Inc.</cell><cell>0</cell><cell>69</cell><cell>1632</cell><cell>2250</cell></row><row><cell>Total (s)</cell><cell>1.92</cell><cell>23.96</cell><cell>594.59</cell><cell>809.41</cell></row><row><cell>Event (s)</cell><cell>0</cell><cell>22.01</cell><cell>65.50</cell><cell>69.33</cell></row><row><cell>Condition (s)</cell><cell>0</cell><cell>0</cell><cell>526.04</cell><cell>677.39</cell></row><row><cell>Constraint (s)</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>59.39</cell></row><row><cell>Overhead (s)</cell><cell>1.92</cell><cell>1.95</cell><cell>3.05</cell><cell>3.30</cell></row><row><cell>Contexts / m</cell><cell cols="2">62565 5008.35</cell><cell>201.82</cell><cell>148.26</cell></row><row><cell>Inconsistencies / m</cell><cell>0</cell><cell>172.79</cell><cell>164.69</cell><cell>166.79</cell></row><row><cell cols="5">Table 1 presents the average results of performance measurements</cell></row><row><cell cols="5">of five executions with little difference among them, which show:</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>The work is supported by a grant of the Research Grants Council of Hong Kong (Project No. HKUST6167/04E). The authors would also like to thank Michael Liu (lrcomp@cs.ust.hk) for the case study from his led AV team.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Amit -The Situation Manager</title>
		<author>
			<persName><forename type="first">Asaf</forename><surname>Adi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Opher</forename><surname>Etzion</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB Journal</title>
		<imprint>
			<biblScope unit="issue">13</biblScope>
			<biblScope unit="page" from="177" to="203" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Enhancements to the RADAR User Location and Tracking System</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bahl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">N</forename><surname>Padmanabhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Balachandran</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000-02">Feb 2000</date>
			<publisher>Microsoft Research Technical Report</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Easy-Living: Technologies for Intelligent Environments</title>
		<author>
			<persName><forename type="first">B</forename><surname>Brumitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Meyers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Krumm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shafer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of the 2nd International Symposium on Handheld and Ubiquitous Computing (HUC 2000)</title>
		<meeting>eeding of the 2nd International Symposium on Handheld and Ubiquitous Computing (HUC 2000)<address><addrLine>Bristol, England</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">CARISMA: Context-Aware Reflective Middleware System for Mobile Applications</title>
		<author>
			<persName><forename type="first">Licia</forename><surname>Capra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wolfgang</forename><surname>Emmerich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cecilia</forename><surname>Mascolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="929" to="944" />
			<date type="published" when="2003-10">Oct 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Snoop: An Expressive Event Specification Language for Active Databases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chakravarthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mishra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Knowl Eng</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="26" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A Context-Based Infrastructure for Smart Environments</title>
		<author>
			<persName><forename type="first">K</forename><surname>Anind</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gregory</forename><forename type="middle">D</forename><surname>Dey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Abowd</surname></persName>
		</author>
		<author>
			<persName><surname>Salber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st International Workshop on Managing Interactions in Smart Environments</title>
		<meeting>the 1st International Workshop on Managing Interactions in Smart Environments<address><addrLine>Dublin, Ireland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999-12">Dec 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Modeling and Using Sensed Context Information in the Design of Interactive Applications</title>
		<author>
			<persName><forename type="first">Philip</forename><forename type="middle">D</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Salber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th IFIP International Conference on Engineering for Human-Computer Interaction</title>
		<meeting>the 8th IFIP International Conference on Engineering for Human-Computer Interaction<address><addrLine>Toronto, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-05">2001. May 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A Component Architecture for an Extensible, Highly Integrated Context-Aware Computing Infrastructure</title>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">G</forename><surname>Griswold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Boyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><forename type="middle">W</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Minh</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><surname>Truong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th International Conference on Software Engineering (ICSE 2003)</title>
		<meeting>the 25th International Conference on Software Engineering (ICSE 2003)<address><addrLine>Portland, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-05">May 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">The Anatomy of a Context-Aware Application. Mobile Computing and Networking</title>
		<author>
			<persName><forename type="first">Andy</forename><surname>Harter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andy</forename><surname>Hopper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pete</forename><surname>Steggles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andy</forename><surname>Ward</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Webster</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="59" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A Software Engineering Framework for Context-Aware Pervasive Computing</title>
		<author>
			<persName><forename type="first">Karen</forename><surname>Henricksen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jadwiga</forename><surname>Indulska</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications</title>
		<meeting>the 2nd IEEE Conference on Pervasive Computing and Communications<address><addrLine>Orlando, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-03">2004. Mar 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Modeling Context Information in Pervasive Computing Systems</title>
		<author>
			<persName><forename type="first">Karen</forename><surname>Henricksen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jadwiga</forename><surname>Indulska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andry</forename><surname>Rakotonirainy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st International Conference on Pervasive Computing</title>
		<meeting>the 1st International Conference on Pervasive Computing<address><addrLine>Zurich, Switzerland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-08">Aug 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Providing Contextual Information to Pervasive Computing Applications</title>
		<author>
			<persName><forename type="first">Glenn</forename><surname>Judd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Steenkiste</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st IEEE International Conference on Pervasive Computing and Communications</title>
		<meeting>the 1st IEEE International Conference on Pervasive Computing and Communications<address><addrLine>Dallas, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-03">2003. Mar, 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">Christine</forename><surname>Julien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gruia-Catalin</forename><surname>Roman</surname></persName>
		</author>
		<title level="m">Egocentric Context-Aware Programming in Ad Hoc Mobile Environments. Proceedings of the 10th International Symposium on the Foundations of Software Engineering (FSE 2002)</title>
		<meeting><address><addrLine>Charleston, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-11">Nov 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Specifying Timing Constraints and Composite Events: An Application in the Design of Electronic Brokerages</title>
		<author>
			<persName><forename type="first">Aloysius</forename><forename type="middle">K</forename><surname>Mok</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Prabhudev</forename><surname>Konana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guangtian</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chan-Gun</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Honguk</forename><surname>Woo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="841" to="858" />
			<date type="published" when="2004-12">Dec 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">xlinkit: A Consistency Checking and Smart Link Generation Service</title>
		<author>
			<persName><forename type="first">C</forename><surname>Nentwich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Capra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Emmerich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Finkelstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Internet Technology</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="151" to="185" />
			<date type="published" when="2002-05">May 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Consistency Management with Repair Actions</title>
		<author>
			<persName><forename type="first">C</forename><surname>Nentwich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Emmerich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Finkelstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th International Conference on Software Engineering (ICSE 2003)</title>
		<meeting>the 25th International Conference on Software Engineering (ICSE 2003)<address><addrLine>Portland, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-05">May 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">LANDMARC: Indoor Location Sensing Using Active RFID</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">Y C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Lau</surname></persName>
		</author>
		<author>
			<persName><surname>Patil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st IEEE International Conference on Pervasive Computing and Communications</title>
		<meeting>the 1st IEEE International Conference on Pervasive Computing and Communications<address><addrLine>Dallas, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-03">2003. March 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Database Management Systems</title>
		<author>
			<persName><forename type="first">Raghu</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Johannes</forename><surname>Gehrke</surname></persName>
		</author>
		<imprint>
			<publisher>McGraw-Hill Higher Education</publisher>
		</imprint>
	</monogr>
	<note>Third Edition</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">ConChat: A Context-Aware Chat Program</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ranganathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Campbell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ravi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mahajan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Pervasive Computing</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="51" to="57" />
			<date type="published" when="2002-09">Jul-Sep 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Reasoning about Uncertain Contexts in Pervasive Computing Environments</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ranganathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Al-Muhtadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Campbell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Pervasive Computing</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="62" to="70" />
			<date type="published" when="2004-06">Apr-Jun 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A Middleware Infrastructure for Active Spaces</title>
		<author>
			<persName><forename type="first">M</forename><surname>Roman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hess</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cerqueira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ranganathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Campbell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nahrstedt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Pervasive Computing</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="74" to="83" />
			<date type="published" when="2002-12">Oct-Dec 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Customizing Mobile Applications</title>
		<author>
			<persName><forename type="first">Bill</forename><forename type="middle">N</forename><surname>Schilit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marvin</forename><forename type="middle">M</forename><surname>Theimer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><forename type="middle">B</forename><surname>Welch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of USENIX Mobile &amp; Location-Independent Computing Symposium</title>
		<meeting>USENIX Mobile &amp; Location-Independent Computing Symposium<address><addrLine>Cambridge, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-08">Aug 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">Albrecht</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kofi</forename><surname>Asante Aidoo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Antti</forename><surname>Takaluoma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Urpo</forename><surname>Tuomela</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kristof</forename><surname>Van Laerhoven</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Walter</forename><surname>Van De Velde</surname></persName>
		</author>
		<title level="m">Advanced Interaction in Context. Proceedings of the 1st International Symposium on Handheld and Ubiquitous Computing (HUC 1999)</title>
		<meeting><address><addrLine>Karlsruhe, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999-09">Sep 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Database Aggregation of Imprecise and Uncertain Evidence</title>
		<author>
			<persName><forename type="first">Bryan</forename><surname>Scotney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sally</forename><surname>Mcclean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Sciences-Informatics and Computer Science: An International Journal</title>
		<imprint>
			<biblScope unit="volume">155</biblScope>
			<biblScope unit="page" from="245" to="263" />
			<date type="published" when="2003-10">Oct 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Aura: An Architectural Framework for User Mobility in Ubiquitous Computing Environments</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Sousa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Garlan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd Working IEEE/IFIP Conference on Software Architecture</title>
		<meeting>the 3rd Working IEEE/IFIP Conference on Software Architecture<address><addrLine>Montreal, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-08">Aug 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">On the Ontology for the Middleware Support of Context-Aware Pervasive Applications</title>
		<author>
			<persName><forename type="first">Chang</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cindy</forename><surname>Lo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">C</forename><surname>Leung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jun</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><surname>Cabot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IFIP Workshop on Building Intelligent Sensor Networks (BISON 2004)</title>
		<meeting>the IFIP Workshop on Building Intelligent Sensor Networks (BISON 2004)<address><addrLine>Wuhan, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-10">Oct 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Semantic Interpretation and Matching of Web Services</title>
		<author>
			<persName><forename type="first">Chang</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiangye</forename><surname>Xiao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd International Conference on Conceptual Modeling (ER 2004)</title>
		<meeting>the 23rd International Conference on Conceptual Modeling (ER 2004)<address><addrLine>Shanghai, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-11">Nov 2004</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
