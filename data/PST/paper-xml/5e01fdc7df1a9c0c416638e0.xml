<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Automated Playtesting with Procedural Personas through MCTS with Evolved Heuristics</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Christoffer</forename><surname>Holmg√•rd</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Art + Design</orgName>
								<orgName type="institution">Northeastern University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><roleName>IEEE</roleName><forename type="first">Michael</forename><surname>Cerny Green</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Antonios</forename><surname>Liapis</surname></persName>
						</author>
						<author>
							<persName><roleName>IEEE</roleName><forename type="first">Julian</forename><surname>Togelius</surname></persName>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Tandon School of Engineering</orgName>
								<orgName type="institution">New York University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Institute of Digital Games</orgName>
								<orgName type="institution">University of Malta</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Automated Playtesting with Procedural Personas through MCTS with Evolved Heuristics</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">A2DE8B33F0E2F3B7704119FC115680D2</idno>
					<idno type="DOI">10.1109/TG.2018.2808198</idno>
					<note type="submission">This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TG.2018.2808198, IEEE Transactions on Games 1</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:22+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Player Modeling</term>
					<term>Agent Controllers</term>
					<term>Automated Playtesting</term>
					<term>Play Persona</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper describes a method for generative player modeling and its application to the automatic testing of game content using archetypal player models called procedural personas. Theoretically grounded in psychological decision theory, procedural personas are implemented using a variation of Monte Carlo Tree Search (MCTS) where the node selection criteria are developed using evolutionary computation, replacing the standard UCB1 criterion of MCTS. Using these personas we demonstrate how generative player models can be applied to a varied corpus of game levels and demonstrate how different play styles can be enacted in each level. In short, we use artificially intelligent personas to construct synthetic playtesters. The proposed approach could be used as a tool for automatic play testing when human feedback is not readily available or when quick visualization of potential interactions is necessary. Possible applications include interactive tools during game development or procedural content generation systems where many evaluations must be conducted within a short time span.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>One of the challenges faced by game designers is predicting how different players will interact with the the systems and content that they are crafting. Most games are complex emergent systems that allow for a variety of interaction patterns, depending on the player's preference(s) and the interaction between player, game, and any other players. Game designers employ a variety of processes to imagine and observe how different types of players might respond to their content. The processes can be thought of as existing on a spectrum, ranging from the designer imagining what different types of players might do, to analyzing play data of beta testers or a portion of the player base in the case of continuously updated "live" games. Each approach has different strengths, weaknesses and costs, making it relevant for different game makers or different stages of the game making process <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b1">[2]</ref>.</p><p>In this paper we suggest and demonstrate a method taking a new position on this spectrum (illustrated in Figure <ref type="figure" target="#fig_0">1</ref>): using archetypal generative player models as critics for game content, enabling automated playtesting and evaluation of game content; here specifically levels. We identify this approach as the use of Procedural Personas for Playtesting.</p><p>We evolve artificially intelligent game playing agents for the game MiniDungeons 2 <ref type="bibr" target="#b2">[3]</ref>. The agents, or personas, are characterized by different utility functions for their decisionmaking. These utility functions capture various archetypal goals that players might hold in relation to the affordances and potential interactions of the particular game. To control the personas, we use a variant of Monte Carlo Tree Search (MCTS) which is well-suited to building biased search trees in large search spaces. However, rather than applying the Upper Confidence Bound 1 applied to Trees (UCB1) formula typically used for MCTS, we use genetic programming to evolve persona-specific evaluation formulas. This allows us to find mappings between persona utility functions and state evaluation algorithms. We evolve well-performing game-playing agents for all defined personas through this variant of MCTS.</p><p>Using the evolved personas, we show how different levels can be automatically evaluated in terms of their playability for players holding different preferences. This approach can be useful to game creators as it provides an insight into dynamic properties <ref type="bibr" target="#b3">[4]</ref> of their content as they are crafting the mechanics. For instance, such agents could eventually be added directly to a game engine's editor to allow for almost realtime feedback during content creation. The approach can also be used as an automated evaluation mechanism for procedural content generation of game content, where procedural personas can function as stand-ins for the game designer or different players when large amounts of content have to be evaluated.</p><p>This paper builds on our previous work on MCTS agents with hand-crafted utility scores for the MiniDungeons 2 game <ref type="bibr" target="#b4">[5]</ref>, expanding on those concepts by broadening the number and utility of personas (through human design) as well as discovering UCB-like criteria (through evolution) which outperform UCB1. More broadly, this paper enhances our earlier definitions of procedural personas <ref type="bibr" target="#b5">[6]</ref>- <ref type="bibr" target="#b7">[8]</ref> which were applied for simulation-based level generation <ref type="bibr" target="#b8">[9]</ref>. However, the MCTS agents used in this paper are more modular in their utility definitions and afford far faster runtimes when performing automated playtesting. Moreover, the MCTS agents in this paper are tested on MiniDungeons 2, a far more complex game than its predecessor MiniDungeons introduced in <ref type="bibr" target="#b5">[6]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. RELATED WORK</head><p>The approach taken in this paper draws on psychological decision theory, persona theory from design research, and player modeling and agent control from computational intelligence. The procedural persona approach draws all of these four strands of work together in one framework for automatic playtesting in order to create generative player models that to some extent decide and play like human players. This section briefly covers some of the foundational areas before describing prior work in bringing these approaches together.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Personas for Game Design</head><p>The use of computational methods to imbue computer game characters with personality has been a focus of game AI programming since the very beginning of the medium. As one instance, Short provides an overview of how non-player characters can be provided with human-like personalities under the heading of procedural personalties <ref type="bibr" target="#b9">[10]</ref>.</p><p>The use of personas has a long history within design in general and design for information technology in particular. The approach was pioneered for software development in the early 1990s <ref type="bibr" target="#b10">[11]</ref> as a method for structuring and operationalizing qualitative data gathered from design research, chiefly in the form of interviews. Based off interview data, a number of personas would be defined. Each of these would serve as a specific instantiation of groups of user concerns that tended to co-occur, expressed as an archetypal example user, fully fleshed out with names, back stories, concerns and preferences.</p><p>Canossa and Drachen transported this approach into the realm of game design <ref type="bibr" target="#b11">[12]</ref>, defining personas less in terms of general life concerns and more in terms of player interaction preferences within the space of the game. They call this new conceptualization play personas and operationalized their definition through data mining, suggesting how the persona design process could be supported by analyzing quantitative game data gathered via telemetrics <ref type="bibr" target="#b12">[13]</ref>. While play personas are archetypal models of player behavior inferred from experience or observed data, the re-projection into the game itself is something that is done imaginatively by the designer(s) of the game: i.e. play personas let us understand what players have done, but do not enact what players might do. Procedural personas <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b13">[14]</ref> extend the play persona idea by adding a game-playing, generative aspect. By capturing persona characteristics from designer specification or from observed data, and formalizing these as utility functions, procedural personas are implemented as agents that can act in the game, enabling automatic playtesting.</p><p>Other work in the literature has investigated game testing without natural player data, notably <ref type="bibr" target="#b14">[15]</ref>. The approach taken here differs from the approach taken in <ref type="bibr" target="#b14">[15]</ref> as it focuses on generating data from simulated players, rather than taking into account a larger number of potential metrics where some are not centered on player actions. As such, the procedural persona concept is a specialized case of player modeling.</p><p>The line of work leading to this paper has been inspired by the category of "Generative Action Models" in the survey on player modeling by <ref type="bibr" target="#b15">[16]</ref>. Until recently, this particular category has been underpopulated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Player Modeling</head><p>Player modeling is the learning and use of computational models of player preference, experience and/or behavior <ref type="bibr" target="#b16">[17]</ref>. Procedural personas, as generative player models, cover some of these aspects: behavior and preferences. Other work in player modeling take different approaches to modeling play behavior and preference generatively. Perhaps the most obvious approach is to use some form of supervised learning to derive a model from play traces <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b18">[19]</ref>. Cowley et al. developed the concept of behavlets, features of play derived from observed action sequences, structured through a topdown application of psychological temperament theory combined with machine learning <ref type="bibr" target="#b19">[20]</ref>. While behavlets can be used as generative models, they do not allow for the specification of player motivations without observations. In contrast, procedural personas are driven by utility functions that can be either specified in a top-down manner by game or persona designers or formulated from play data through methods like inverse reinforcement learning <ref type="bibr" target="#b20">[21]</ref> or evolution <ref type="bibr" target="#b13">[14]</ref>. The particular agent control method that is used to formulate a policy for procedural personas is technically arbitrary, as long as it can accept a utility function as a method of evaluation. The most appropriate method may depend on the game for which the personas are being implemented. Prior work has shown that evolutionary methods and MCTS have potential for defining personas for turn based roguelike games <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b13">[14]</ref>.</p><p>Devlin et al. showed how observations of human play data can be used to bias MCTS to play the card game Spades <ref type="bibr" target="#b21">[22]</ref>. They use a relative entropy measure to assess the similarity of playing styles to traces of human players. Zook et al. limited the computational resources of MCTS to simulate player skill for a number of games <ref type="bibr" target="#b22">[23]</ref> and similar findings were reported by Nelson et al. <ref type="bibr" target="#b23">[24]</ref>. Another approach to biasing the MCTS search process to be more similar to human players is described by Khalifa et al. <ref type="bibr" target="#b24">[25]</ref>. In the study described here, we take a similar approach and implement a variation of MCTS. We bias the search using evolution applying designerdefined utility outcomes as the fitness function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. MONTE CARLO TREE SEARCH</head><p>MCTS has shown considerable potential and flexibility as a game-playing algorithm <ref type="bibr" target="#b25">[26]</ref>. For our purposes, MCTS has several desirable properties which approximate how decision making occurs in humans: it evaluates the next best action based on a utility score for a predicted future state and operates under uncertainty of future outcomes. It also seems that by giving an MCTS algorithm more or less resources, you can simulate strategic depth in human decision-making <ref type="bibr" target="#b22">[23]</ref>, <ref type="bibr" target="#b23">[24]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Traditional MCTS</head><p>As discussed in Section I, MCTS is a tree search algorithm which creates biased search trees for decision processes. Unlike other tree search algorithms like Minimax, breadthfirst, or depth-first, MCTS focuses on exploiting the most promising moves to expand next, while balancing that by exploring more neglected branches of the tree. The balance of exploitation versus exploration is traditionally handled through the evaluation of the Upper Confidence Bound for Trees equation, which applies UCB1 to the tree <ref type="bibr" target="#b25">[26]</ref>. The tree is built incrementally, with each iteration following a simple formula:</p><p>1. Selection: MCTS chooses the next node to expand via the tree policy, starting at the root node and recursively picking the highest scoring child "until the most urgent expandable node is reached" <ref type="bibr" target="#b25">[26]</ref> or a terminal state (i.e. the game is won or lost). The score for traversing the tree in MCTS is termed tree policy, and in traditional MCTS approaches it is given by the Upper Confidence Bound (UCB1) equation:</p><formula xml:id="formula_0">U CB = w i n i + c‚Ä¢ ln(t) n i<label>(1)</label></formula><p>where w i is the number of wins which originate from taking move i, n i is the times move i was visited, c is the exploration constant. It is typically chosen that c = ‚àö 2, since this value has been shown to guarantee convergence to a value function within finite time for single-player games terminal states and rewards bounded to the range [0, 1] <ref type="bibr" target="#b25">[26]</ref>. t is the total number of simulations for the node considered and is equivalent to the sum of all n i for all possible moves. The UCB1 equation attempts to balance exploration (looking into paths not yet simulated) and exploitation (looking into paths previously simulated that show good results).</p><p>2. Expansion: unless the selected node is a terminal state (i.e. the game is over), a child node (W ) is created for the next action. Typically, this next action is randomly selected from all possible future actions.</p><p>3. Simulation: the default policy is used to simulate a random rollout from W . The rollout consists of performing actions at random until the game reaches a terminal state, or up to a fixed number of moves.</p><p>4. Backpropagation: the result (i.e. utility score) of the simulation is backpropagated to every node, from the expanded W to the root node. This affects future policy decisions, i.e. future selection steps.</p><p>These four steps are applied sequentially until the computational resources allocated for the agent's move are depleted. The agent then chooses the next move (i.e. the child of the root node) with the highest utility score.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Evolutionary Tree Policy</head><p>As discussed in Section III-A, selection in MCTS must balance between exploitation and exploration; UCB1 is traditionally used to maintain this balance. Changes to the UCB1 formula of eq. 1 are typically done in order to optimize it for a certain kind of game or to weigh certain kinds of game-play differently <ref type="bibr" target="#b24">[25]</ref>. Cazenave's work <ref type="bibr" target="#b26">[27]</ref> on evolving UCB1 alternatives for Go MCTS agents demonstrated that the resulting agent significantly outperformed peers that used traditional UCB equations, or even agents that used UCB1 alternatives specifically created for Go. In the General Video Game AI (GVGAI) framework, Bravi et al. explored the possibility of evolving UCB1 replacements that were not specialized for one particular game <ref type="bibr" target="#b27">[28]</ref>. In this work, we use the approach of Bravi et al. not to specialize the agent for particular games, but to bias its playstyle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. THE MINIDUNGEONS 2 GAME</head><p>MiniDungeons 2 is a deterministic, turn-based rogue-like game, first described in <ref type="bibr" target="#b2">[3]</ref>, in which the player takes on the role of a hero traversing a dungeon level, with the end goal of reaching the exit. The game stage is set on a 10 by 20 tile grid. Each tile is either an impassible wall or a passable floor. Floor tiles may contain objects that the hero can interact with, game characters such as the hero or non-player characters (NPCs), or nothing at all. Gameplay objects come in several varieties such as treasures, potions, portals, traps, and the exit of the level. To win, the player must reach the exit. All game characters have Hit Points (HP) and may deal damage. The player starts with 10 HP; the player loses when they run out of HP and die. Movement within the game is fairly simple. The player gets the first move every turn, and all NPCs move after. The NPCs move in turn according to their original position on the map, starting from the top left corner and moving row-wise leftto-right until the bottom right corner is reached. This initial move sequence is retained even if NPCs later move to other locations. On their turn, a game character may move in one of the four cardinal directions (North, South, East, West) so long as the tile in that direction is not a wall. The player is given one re-usable javelin at the start of every level. The player may choose to throw this javelin and do 1 damage to any monster within their unbroken line of sight. After using the javelin, the hero must traverse to the tile to which it was thrown in order to pick it up and use it again. A map contains many different objects the player can collide with. Different objects have different effects:</p><p>‚Ä¢ Potions are used to increase the HP of the hero by 1, up to the maximum of 10. When collided with by either the hero or blobs, they are consumed and may not be re-used. ‚Ä¢ Treasures are used to increase the treasure score of the hero. When collided with by either the hero or ogres, they are consumed and may not be re-used. ‚Ä¢ Portals come in pairs. If the hero collides with a portal, they are immediately (on the same turn) transported to the other paired portal. ‚Ä¢ Traps deal 1 damage to any game character moving through them, every time. While exploring a map, the hero may come across a variety of monsters, some of which have secondary goals in addition to attacking the player.</p><p>‚Ä¢ Goblins (or Melee Goblins) move 1 tile every turn towards the player if they have an unbroken line of sight to the player. They have 1 HP and deal 1 damage upon collision. Goblins avoid colliding with other goblins and goblin wizards.</p><p>‚Ä¢ Goblin Wizards (or Ranged Goblins) cast a spell at the hero if they have an unbroken line of sight within 5 tiles of the player that does 1 damage. If they are over 5 tiles from the player but have line of sight, they will move 1 tile towards the player. Wizards have 1 HP and deal no damage on collision. When an ogre collides with a treasure, they consume it, and their sprite becomes fancier to look at. Ogres have 2 HP and deal 2 damage to anything they collide with, including other ogres. ‚Ä¢ Minitaurs always move 1 step along the shortest path to the hero as determined by A* search, regardless of line of sight. Collision with the minitaur will deal 1 damage. A minitaur has no HP and is incapable of dying. If damage is done to it, the minitaur will be knocked out for 3 rounds (and can be passed through). The game is technically infinite with all current maps as they all contain areas where the player might move back and forth, continuously dealing with the Minitaur using the Javelin. However, in practice most maps are finished in 20-30 moves with goal directed play. The branching factor is estimated to 3.41 across the included maps <ref type="bibr" target="#b2">[3]</ref>, but depends on the map.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. PROCEDURAL PERSONAS IN MINIDUNGEONS 2</head><p>We identified four player archetypes which will become our procedural personas. These personas prioritize different interactions with the game and were defined from the four primary objects in the game. The following four archetypes were defined based on our design experience and intuition:</p><p>‚Ä¢ Runner aims to reach the exit.</p><p>‚Ä¢ Monster Killer wants to kill monsters.</p><p>‚Ä¢ Treasure Collector desires to collect treasure.</p><p>‚Ä¢ Completionist attempts to consume any game object that can be collected or killed (monsters, potions, treasures). Apart from the Completionist, these personas have been also featured in previous attempts at modeling personas via MCTS <ref type="bibr" target="#b2">[3]</ref> or in the simpler MiniDungeons game <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b6">[7]</ref>. Since the types of interactions with the game world are limited, these four single-minded personas capture a large part of the potential play space in MiniDungeons 2.</p><p>The personas all use MCTS to formulate a sequence of actions for play. Because MiniDungeons 2 is fully deterministic, each persona only builds one tree per map. It will immediately cease construction once a winning terminal state is discovered or it reaches timeout, wherein it will take the best sequence of actions it discovered. On average, trees will contain between two and five million nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Utility Formation</head><p>The four personas of MiniDungeons 2 are defined by their primary and secondary objectives, which calculate a move's utility score at the end of a simulation phase and is backpropagated to the rest of the tree in the next phase (see Section III-A). From preliminary experiments, it seems that MiniDungeons 2 maps are frequently too complex and long for MCTS to simulate rollouts to a terminal state, as games can become infinite if the hero moves back and forth in place. Therefore, in the rollout stage, our agents simulate 10 random moves before back-propagating the utility score. The different personas use metrics collected from the game's state after 10 random moves: Table <ref type="table">1</ref> describes the variable metrics used in this paper. Note that for P D, M S, T O, and IC the values represent the ratio out of all potions, monsters, treasures, and all non-monster game objects in the map, respectively.</p><p>Runner (R) has the primary objective of finding the exit in the fewest moves possible.</p><formula xml:id="formula_1">U R = P E -0.01 ‚Ä¢ ST if hero is alive P E -0.01 ‚Ä¢ ST -5 if hero is dead (2)</formula><p>Monster Killer (MK) has the primary objective of killing as many monsters as possible with the secondary objective of finding the exit.</p><formula xml:id="formula_2">U M K = 0.7 ‚Ä¢ M S + 0.3 ‚Ä¢ P E if hero is alive 0.7 ‚Ä¢ M S + 0.3 ‚Ä¢ P E -5 if hero is dead (3)</formula><p>Treasure Collector (TC) has the primary objective of consuming as much treasure as possible with the secondary objective of finding the exit.</p><formula xml:id="formula_3">U T C = 0.7 ‚Ä¢ T O + 0.3 ‚Ä¢ P E if hero is alive 0.7 ‚Ä¢ T O + 0.3 ‚Ä¢ P E -5 if hero is dead (4)</formula><p>Completionist (C) has the primary objective of consuming as many potions and treasures, and killing as many monsters as possible (thus "completing" a map), along with the secondary objective of reaching the exit.</p><formula xml:id="formula_4">U C = 0.7 ‚Ä¢ IC + 0.3 ‚Ä¢ P E if hero is alive 0.7 ‚Ä¢ IC + 0.3 ‚Ä¢ P E -5 if hero is dead (5)</formula><p>By studying how these personas traverse the game's maps, we can better evaluate how players will interact with the game.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Evolving the Policy of Personas</head><p>Genetic programming is used to evolve the mathematical formula that replaces UCB1. The Evolute C# source code 1 was modified to work as follows: The chromosome representation is a syntax tree where all nodes contain a binary operation and all leaves contain a variable or a constant. The four binary functions are addition, subtraction, multiplication, and division. Constant values are uniformly, randomly generated floats within [-1, 1]. Variable values are derived from the game-play metrics described in Table <ref type="table" target="#tab_1">I</ref>. The generator takes these variables and constant numbers and initializes equation trees with them, with an initial minimum depth of 2 and maximum of 5. During evolution, the maximum depth of a tree is set to 8 to avoid extremely long equations. This means that a equation can have as many as 2 8 (i.e. 256) elements.</p><p>Each persona has its own utility function, as per Eqs. (2-5), which evaluates the result to be back-propagated after the simulation step of MCTS. To test the candidate function, the UCB equation is completely replaced by the candidate as the tree policy. The agents are based on a fitness function calculated at the end of each playthrough, i.e. when the hero has reached the exit, when the hero is killed, or after a maximum allocated time has passed. Each persona uses the same fitness as the utility score (e.g. f M K = U M K ) calculated at the end of the playthrough. E.g. for the Monster Killer the fitness f M K evaluates how many monsters it killed in total in this map, how close it ended to the exit (P E = 0 if the exit was reached), and whether the playthrough ended because the hero was killed (which applies a penalty to the fitness).</p><p>Since MiniDungeons 2 maps can combine interactive tiles and monsters in many different ways, the fitness of each individual is based on their utility in different maps. Evolving agents are tested on maps 1, 2, 3, 4, 7, and 10 of Fig. <ref type="figure" target="#fig_1">2</ref>: these maps capture many different playstyle patterns of MiniDungeons 2. The overall fitness of a chromosome is calculated by averaging its fitness across all playthroughs in these six maps. This averaged fitness score was then used to select genes (i.e. UCB1 replacement functions) for recombination, mutation and replacement.</p><p>The initial population of 100 individuals is created via the initialization process described above. Evolution uses an islands model <ref type="bibr" target="#b28">[29]</ref> with 5 islands. Migration occurs in every generation. After migration, the five fittest individuals of each island are selected and placed into that island's mating pool. Based on preliminary experiments, elitism was set to 15% of the population. Before crossover, all individuals in the mating pool have a 10% chance of mutating. Mutation replaces the chromosome with a random chromosome via the same initialization process described above. After mutation, the mating pool undergoes crossover: two random chromosomes from the mating pool are crossed-over to create two offspring, formed by exchanging randomly selected sub-trees between the parents. During crossover, every individual in the mating pool has an equal chance to be selected, regardless of fitness. After this process is repeated for every island, a new population is generated and evaluated for fitness. 1 http://evolute-csharp.sourceforge.net</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. EXPERIMENTS</head><p>The purpose of evolving UCB1 replacement functions is to optimize the agents' behavior relative to the persona-defining utility function. Below, we describe the results of evolving the agents, comparing them with the standard UCB1 function and using the evolved agents to playtest maps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Experimental Protocol</head><p>For the purposes of evolving the four agents' tree policy equations, six maps are played by the agent and the fitness score is calculated as described in Section V-B. However, for evaluating the agents' performance a broader set of maps is used: all 11 maps of Fig. <ref type="figure" target="#fig_1">2</ref> are tested in Sections VI-C and VI-D. To cater for the stochastic nature of MCTS, each map is simulated in 50 trials by each agent. To cater for the stochastic nature of evolutionary algorithms, 3 independent evolutionary runs of 100 generations are performed with a population of 100 individuals, following the process described in V-B. The best performing run (based on the persona's core priority, e.g. monsters killed for the Monster Killer) is chosen among the three evolutionary runs and reported here.</p><p>For the purposes of assessing the performance of evolved personas, baseline MCTS agents using the UCB1 tree policy of Eq. 1 are used to simulate the 11 maps in 50 trials each. Each baseline persona uses UCB1 for its tree policy but then backpropagates the persona-specific utility of Eqs. (2-5) after each simulation. All reported significance testing is performed through Student's two-tailed t-tests, assuming unequal variance, with an error of 5%; when comparing between maps, the 50 playthroughs of each persona are tested for significance. Otherwise, 95% confidence intervals are calculated via the standard deviation of all playthroughs in all maps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Persona Evolution</head><p>For all personas, fitness starts converging after approximately 20 generations and from then on improves only marginally. The best evolved tree policy equation for each persona in its raw form often has duplicate variables and can be simplified. We simplified each of the fittest equations at the end of 100 generations and list them as eq. (6-9). Some of these equations are quite convoluted but some interesting patterns can be gleaned. The tree policy for the Runner in eq. ( <ref type="formula">6</ref>) strongly prioritizes the proximity to the exit variable but also has a negative factor for health left (i.e. it actively prefers reaching the exit with low health). The tree policy for the Monster Killer in eq. ( <ref type="formula">7</ref>) aggressively prioritizes monsters slain and proximity to the exit as these variables are multiplied to any other metric; interestingly this tree policy is the only one among eq. (6-9) which does not include R (the average reward). The tree policy for the Treasure Collector in eq. ( <ref type="formula">8</ref>) is the only linear equation (a weighted sum) which includes an added 0.19 constant which obviously does not affect the tree policy as it is added to all possible moves. More interestingly, the Treasure Collector policy puts more weight on potions drunk and monsters slain (2 for each) rather than on treasures opened (weight of 1). The Completionist has the most complex  tree policy in eq. ( <ref type="formula" target="#formula_5">9</ref>). It puts a surprising emphasis on steps taken (multiplied to most components), monsters slain and proximity to exit (despite the fact that it also subtracts P E); most surprisingly, it only includes treasures opened (T O) once and with a negative weight, meaning that it actively tries to reduce the number of treasures opened despite the fact that the utility (and fitness) of eq. ( <ref type="formula">5</ref>) actively rewards treasures as a member of the interactive objects set.</p><formula xml:id="formula_5">t R =6.235‚Ä¢ST ‚Ä¢P E 2 ‚Ä¢(P E + 1) + R‚Ä¢(1 -HL) (6) t M K =4‚Ä¢M S‚Ä¢P E‚Ä¢(M S + 2‚Ä¢HL‚Ä¢(P E -IC)) (7) t T C =2‚Ä¢P D + 2‚Ä¢M S + T O + 3‚Ä¢R + ST + P E + 0.19 (8) t C =ST ‚Ä¢M S‚Ä¢(ST 2 ‚Ä¢M S + IC) + R -T O + IC -P E + 2‚Ä¢ST ‚Ä¢P E‚Ä¢(ST ‚Ä¢M S‚Ä¢ + 1)<label>(9)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Comparing Personas</head><p>It is not sufficient to assess the evolved personas based on their fitness scores alone. This section tests the final best personas based on what types of content they interact with in all the maps of MiniDungeons 2. The focus is on comparisons with UCB1 MCTS personas (as baselines) regarding agents' efficiency in achieving their core priorities, but also on comparisons between different personas' play behavior.</p><p>1) Overall Performance: Table <ref type="table" target="#tab_2">II</ref> shows the ratio of game objects each agent has interacted with (i.e. monsters, potions, treasures) on average in the 11 testbed maps of MiniDungeons 2. At a high level, the Monster Killer kills more monsters on average than the other personas, while the Treasure Collector collects more treasure and drinks more potions. A more detailed analysis in Section VI-C3 will shed more light on the differences between personas, as there are substantial deviations between maps. Table II includes the win rate of different personas (i.e. instances where the agent reached the exit), as well as computation time to find a path (up to a maximum of 300 seconds). The evolved Runner persona is consistently able to reach the exit in all maps, and does so in far fewer steps and requiring far less computational time than all other personas, both evolved and baseline MCTS. Surprisingly, the evolved Completionist persona also completes all maps in all trials, despite the fact that it prioritizes interacting with as many game objects as possible; perhaps due to the latter strategy its computational time is double that of the evolved Runner. Since the Treasure Collector does not receive a large reward for finishing the level, it tends to roam around the map attempting to collect all treasures, and does not finish before a maximum allocated time in 46% of all trials. The Monster Killer has a similarly low reward for finishing the level, however it only roams around certain maps until the allocated time runs out (27% of all trials). It should be noted that the computation time is averaged from all playthroughs regardless of whether the agent reached the exit: if only won playthroughs are considered, the average computation time of the evolved Monster Killer (2.06 sec) is the lowest of all other evolved personas, while that of the evolved Treasure Collector remains high (at 23 sec). That said, considering only computation time of won games these values are still better than those of the baseline MCTS Runner (71 sec), Monster Killer (167 sec) and Completionist (133 sec); only the baseline Treasure Collector is relatively close (72 sec) to its evolved counterpart but it only wins in one map (map 8). Comparisons between baseline and evolved agents in the remaining game metrics of Table II will be detailed in Section VI-C2.</p><p>2) Differences from the Baseline: For the purposes of comparisons between evolved and baseline personas, the results of Table <ref type="table" target="#tab_2">II</ref> are too noisy due to the sensitivity of persona behavior in different maps of MiniDungeons 2. For a more thorough comparison, Table <ref type="table" target="#tab_3">III</ref> compares the number of maps (out of 11) in which the different metrics are significantly higher for the evolved persona than the baseline persona of the same type (E), or significantly lower (B). Significance is tested via twotailed Student's t-tests (p &lt; 5%) comparing 50 playthroughs of each map per persona (evolved or baseline). Table <ref type="table" target="#tab_3">III</ref> shows that evolved personas score significantly higher (or lower, for computation time) in the different metrics in more maps than their baseline counterparts. A notable exception is the treasure ratio for the Runner, Monster Killer, and Completionist, as the MCTS personas collect more treasure in a comparable number of maps; however, these baseline MCTS agents do not complete the level in far more cases. Especially regarding win rates, the evolved personas are always superior (or at least not inferior) in all maps and for all personas. In comparison, baseline personas need more computational time and do not finish a level far more often as shown by their win rates in Table <ref type="table" target="#tab_2">II</ref> (less than 15% for all personas).</p><p>3) Differences among Personas: Due to the large differences between MiniDungeons 2 maps in the different metrics of Table <ref type="table" target="#tab_2">II</ref>, to compare whether (and how) the procedural personas play the game differently we evaluate the number of maps in which one persona has a significantly higher value for one metric than another persona. This comparison is summarized in Table IV; significant differences are established from a t-test (p &lt; 5%) between 50 playthroughs of each persona in one map. We are interested in seeing whether the evolved personas, which have been shown to be more efficient and robust at gameplaying, still maintain differentiation in those game metrics that make them unique (e.g. a Monster Killer persona should kill more monsters than other personas).</p><p>Analyzing the general differences between the evolved Monster Killer and other evolved personas in Table <ref type="table" target="#tab_1">IV</ref>, we see that its killed monsters ratio is higher for this persona; no other persona has a higher ratio in any map. The evolved Treasure Collector collects significantly more treasure in most maps (8 or 9 out of 11); the baseline Treasure Collector is close but is not superior from other baseline personas in as many maps. Interestingly, the evolved Completionist is underperforming in all relevant metrics compared to the Treasure Collector: it interacts with more game objects only in 1 map (the Treasure Collector has more interactive objects in 8 maps) and generally drinks fewer potions and collects less treasure.</p><p>It is therefore obvious from Table <ref type="table" target="#tab_1">IV</ref> that the Completionist is inferior to the Treasure Collector apart from the fact that it kills more monsters in two maps. This is surprising due to the fact that this persona explicitly rewarded a high interactive objects ratio in the fitness for deciding its tree policy, and when scoring the default policy. On the other hand, the evolved Completionist persona is the only persona apart from the Runner which wins all 50 playthroughs in all 11 maps while still interacting with more game objects (primarily monsters) TABLE IV: Maps in which the shown metrics are significantly higher for the persona on the row than in the persona in the column.</p><formula xml:id="formula_6">Evolved Baseline R MK TC C R MK TC C Monster Ratio R - 0 3 1 R - 0 1 0 MK 8 - 6 3 MK 5 - 5 2 TC 7 3 - 3 TC 2 1 - 1 C 8 2 6 - C 3 0 2 - Potion Ratio R - 2 1 0 R - 0 1 0 MK 1 - 0 1 MK 0 - 1 0 TC 8 8 - 8 TC 3 3 - 3 C 0 2 1 - C 0 0 1 - Treasure Ratio R - 3 0 0 R - 1 0 1 MK 0 - 0 0 MK 2 - 0 0 TC 9 9 - 8 TC 6 7 - 6 C 2 3 0 - C 1 0 0 - Interactive Object Ratio R - 3 1 1 R - 0 0 0 MK 6 - 1 2 MK 4 - 0 1 TC 9 8 - 8 TC 6 5 - 6 C 8 4 1 - C 2 0 0 - Time R - 2 0 1 R - 0 0 2 MK 3 - 1 3 MK 1 - 1 3 TC 11 10 - 10 TC 2 1 - 2 C 6 4 0 - C 1 0 1 - Win Rate R - 3 7 0 R - 0 1 0 MK 0 - 4 0 MK 1 - 1 0 TC 0 1 - 0 TC 0 0 - 0 C 0 3 7 - C 1 1 1 -</formula><p>than the Runner. Even the baseline Completionist persona has a high win rate compared to the baseline Runner (see Table <ref type="table" target="#tab_2">II</ref> while other baseline personas interact with more objects. It is our assumption that using the interactive objects ratio for the utility score (and one would assume as a fitness) creates an imbalance between interacting with an object and approaching the exit. For instance, most maps have 5 to 8 treasure tiles and thus a Treasure Collector would have a higher utility gain by collecting a couple during a playthrough rather than by getting a few steps closer to the exit; instead, when maps have around 20 interactive objects then a completionist interacting with a couple of them will have a lower utility gain than approaching the exit. Completionist agents thus favor reaching the exit, although not as aggressively as the the Runner as there is some reward (however slight) for deviating from the path.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Evaluating Levels with Personas</head><p>Procedural personas can be used for many different purposes, such as modeling players based on the similarity of players' actions with a persona's action <ref type="bibr" target="#b7">[8]</ref>. However, personas can also be used to evaluate game levels by creating artificial playtraces; this can be used as feedback to a human designer when procedural personas test an authored level, but also as a way to improve computer generated levels in a searchbased approach driven by the artificial playtraces of personas in similuations <ref type="bibr" target="#b8">[9]</ref>. In this paper, the former approach is followed and we evaluate which patterns of game levels affect the performance of different personas. We will only use the evolved personas, as they are overall superior.</p><p>In order to first identify what the differences are between levels, Fig. <ref type="figure" target="#fig_2">3</ref> shows the number of interactive objects (i.e. potions, treasure, and the different types of monsters) contained in each map used in this analysis. Obviously, some maps have fewer interactive objects (map 1, map 9), and some maps have more potions and few treasures (e.g. map 5) or vice versa (e.g. map 9). There are also many differences in the types of monsters favored; while all maps include at least one minitaur (map 2 has two of them), some maps do not include ogres (map 1, map 9) and some maps have more ranged goblin enemies than melee goblin enemies (e.g. map 4, map 10) or vice versa (e.g. map 1). It should be noted that besides interactive objects, these maps differ in terms of other types of tiles, e.g. seven maps contain a set of portals allowing shortcuts through the level, while six maps contain one or more traps which deal damage when the tile is visited.</p><p>A broad range of metrics on the levels' structure alone (before simulation) were collected from the 11 maps of MiniDungeons 2. These include the number of interactive objects of Fig. <ref type="figure" target="#fig_2">3</ref>, the number of portals and traps, the number of wall tiles, choke points and dead ends (tiles with only two or one connected passable tiles, respectively), length of the shortest path between entrance and exit and many others. The metrics of all maps were then analyzed in terms of their correlations with the performance of each persona in the same map. For the sake of brevity, only correlations with each persona's win rate and core priority will be discussed: i.e. for the Runner computation time is the core priority, treasure ratio for Treasure Collector, monster ratio for Monster Killer and interactive object ratio for Completionist. While many of the level metrics were found to be correlated with these persona metrics, due the small sample size (11 maps) only a handful of significant correlations were found (p &lt; 0.05 of the Pearson's correlation coefficient, which is also reported as r) .</p><p>For the Runner, computation time was significantly correlated with the length of the shortest path between entrance and exit (r = 0.71). This is not surprising, since the Runner is efficient at finding a short route to the exit and thus requires less computation time if the exit is nearby. For the Treasure Collector, the ratio of collected treasures has a significant negative correlation with the number of walls (r = -0. Treasure Collector persona has a significant negative correlation with the shortest path length to the exit (r = -0.62), again pointing at this persona's poor performance in winding mazelike corridors. While no significant correlations were found for the Monster Killer, the Completionist's interactive object ratio is negatively correlated with the number of treasures in the map (r = -0.65). This is not surprising as the Completionist's evolved tree policy in eq. ( <ref type="formula" target="#formula_5">9</ref>) actively discourages opening treasure chests, so the more of those there are in the map the fewer the Completionist's interactions with game objects.</p><p>In order to see how the maps' layout can affect the diversity of playthroughs among personas, we choose two indicative maps to analyze; map 6 which has the most (significant) differences in all possible pairs of personas and for all metrics of Table <ref type="table" target="#tab_1">IV</ref>, and map 8 which has the fewest differences. The values of these metrics for different personas in each map are shown in Fig. <ref type="figure" target="#fig_3">4</ref>, averaged from 50 playthroughs.</p><p>In map 6, the Runner and Completionist reach the exit in all playthroughs while the Monster Killer and Treasure Collector never reach the exit as their computation time consistently reaches the timeout limit of 300 sec. Surprisingly, the Treasure Collector kills more monsters (66%), collects more treasure (38%), drinks more potions (36%) and generally interacts with more game objects (49%) than all other personas. The Runner persona manages to collect more treasure (15%) than both the Monster Killer (0%) and the Completionist (14%). The Completionist has the second highest interactive object ratio (32%). Based on the heatmaps of Fig. <ref type="figure" target="#fig_4">5</ref>, the Monster Killer and Treasure Collector are shown to roam around the map and then get blocked from taking a decision until the 300 sec timeout. The Runner and Completionist on the other hand follow a similar path to the exit (top right) which is actually the shortest path. Only the Treasure Collector gets the two unguarded treasures next to the entrance (bottom left), while the wounded Monster Killer (due to combat with the ogre and two blobs) ignores both unguarded potions along its path in Fig. <ref type="figure" target="#fig_4">5b</ref>. Interestingly, no persona uses the portal.</p><p>In map 8, all personas reach the exit in all playthroughs  with minimal computational time, and generally their other metrics are also similar. Again the monsters killed across 50 playthroughs are lower for the Monster Killer (11%), than for the Treasure Collector (19%) and slightly lower than the Completionist (12%). All personas drink no potions and collect one treasure (which is mandatory in order to reach the exit as shown in Fig. <ref type="figure" target="#fig_5">6</ref>); therefore the difference in interactive object ratio is solely due to more monsters killed by the Treasure Collector. It is worth noting that Fig. <ref type="figure" target="#fig_5">6c</ref> shows how the Treasure Collector may spend more time roaming around the map. On average, the Treasure Collector needs more computation time (2.8 sec) than the Monster Killer and Runner (0.8 sec for both). Indeed, the Treasure Collector takes on average 11.6 actions (the Runner takes 8, the Monster Killer 9 and the Completionist 9.2). This persona's behavior differs from playthrough to playthrough: in the one shown in Fig. <ref type="figure" target="#fig_5">6c</ref>, the Treasure Collector took 23 actions and killed 5 monsters, which simply walked towards the agent (without the agent needing to explore the map). Finally, it would be interesting to see if there are maps which are "preferred" by all personas. Using the priorities mentioned above (lowest computation time for Runner, highest treasure ratio for Treasure Collector, highest monster ratio for Monster Killer and highest interactive object ratio for Completionist), we find that the best map for the Monster Killer is map 9, in which it kills all monsters in all playthroughs, and the worst is map 8. Map 8 is also deemed the worst by the Completionist, while map 1 is deemed the best. In contrast, map 8 is deemed the best for the Runner, and map 1 the worst.</p><p>For the Treasure Collector map 5 is the best and map 10 is the worst. It is telling that often the worst map for one persona is the best for another, pointing to the fact that different priorities combined with different behaviors to achieve those priorities can saturate how each persona assesses the maps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. DISCUSSION</head><p>The experiments of Section VI demonstrated that the evolved personas were able to play the game more efficiently -requiring less computational time-than the baseline UCB1 agents, and were more robust in completing each map by reaching the exit. Despite being efficient in completing most levels (or all levels in the case of the Runner and Completionist), the evolved personas still differentiate their playstyle and in most maps perform better than other personas with regard to their core priority. The exception is the Completionist, which seems to be an inferior form of the Treasure Collector; however this persona has an important benefit in that it completes all the levels consistently while performing more interactions than the Runner. Looking at the effect that each map of MiniDungeons 2 had on each persona, we identify that different personas are sensitive to different level patterns. Such findings could influence the level design or game design of MiniDungeons 2 (i.e. creating more open areas and fewer winding corridors), or lead to a re-design of the fitness or utility functions e.g. as we find that treasures are not favored by Completionists. Finally, in most cases results differ in terms of which map from the set is best or worst for each persona according to their priorities and playstyles.</p><p>Since procedural personas are intended to be a design tool, they are inherently subjective in the sense that the utility functions should be constructed by a game or level designer interested in testing their content for the game. The experiments provided here support the persona concept as useful for fulfilling specific core priorities for a game of the scope and size of MiniDungeons 2. How the method scales to games of higher complexity is an open question; any game could in principle be tested using procedural personas, as long as it includes agent control methods that can be optimized towards a particular utility function. The specification of the utility function is a complex issue for the procedural persona method: the concept is useful from a design perspective only to the extent that game designers are capable of defining appropriate utility sources and ways of weighting them. One approach to solving this problem could be learning utility functions from demonstration: e.g. from groups of observed players or from designers playing in different styles to demonstrate what particular personas should play like. This could be enabled via methods such as inverse reinforcement learning, driven by evolution or other methods. Regardless, the proposed method is supported in general by the fact that the personas exhibit significantly different behaviors in the same environments, driven by simple utility functions; it is thus likely that game creators would be able to use the personas to inform their content creation process. It also suggests that personas could successfully be integrated as critics in a procedural level generation system; this was previously done for MiniDungeons, a simpler game with simpler persona implementations <ref type="bibr" target="#b8">[9]</ref>.</p><p>Another direction for future work is to validate a posteriori the ability of the defined personas and their behavior to map to real human playtraces. This could allow players to be mapped to one of the four personas based on the similarity of persona and player gameplay traces either on the action-by action-level or on a more macro-strategy level, as done in <ref type="bibr" target="#b7">[8]</ref>. However, the current experiments do not include human players as they test how our method can allow game/level designers to define archetypal personas a priori, before even showing the game or level to players. The experiments have demonstrated that different behaviors can be encoded in such a way, and that the persona's behaviors (in terms e.g. of monsters killed) largely match the designers' stated intentions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. CONCLUSION</head><p>This paper presented the general concept of procedural personas, a framework for generative player modeling for automatic playtesting. Procedural personas represent a potentially general framework for representing archetypal playstyles, based on decision theory, that could inform game designers about properties of their game content as it is being created. The experiments reported in this paper show that personas are capable of showing different interaction patterns in response to game content and can help map out the playspace afforded by game levels as those are being designed. By combining evolution and MCTS, we produce a set of personas that show what different play styles might look like in MiniDungeons 2. Evaluations can be run in a short amount of time, making it a feasible method in an iterative design process. Future research will investigate how procedural personas can be used as interactive inspirational tools in the content creation process and as automated critics in procedural content generation. Future work should also focus on ways to scale the procedural persona framework to games of larger complexity and on ways in which personas can learn from demonstration instead of having their utility functions specified directly.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 :</head><label>1</label><figDesc>Fig.1: Spectrum from simple to complex design testing methods in game development.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 :</head><label>2</label><figDesc>Fig. 2: All 11 maps in the MiniDungeons 2 game.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 :</head><label>3</label><figDesc>Fig. 3: Number of interactive objects in MD2 maps.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 :</head><label>4</label><figDesc>Fig. 4: Metrics of different personas in the same map.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 :</head><label>5</label><figDesc>Fig. 5: Heatmaps of persona behavior in map 6.</figDesc><graphic coords="9,3.51,56.07,148.65,128.56" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 :</head><label>6</label><figDesc>Fig. 6: Heatmaps of persona behavior in map 8.</figDesc><graphic coords="9,3.51,224.61,148.65,128.56" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>‚Ä¢</head><label></label><figDesc>Blobs do not move unless they have unbroken line of sight with either a potion or the hero. If they see either one, they will move 1 tile towards the closest one per turn, preferring potions over the hero in case of a tie. A blob colliding with a potion consumes it. Blobs colliding with other blobs merge into a more powerful blob. The lowest level blob has 1 HP and does 1 damage upon collision. The 2 nd level blob has 2 HP and does 2 damage. The most powerful blob has 3 HP and does 3 damage.‚Ä¢ Ogres also do not move unless they have unbroken line of sight with either a treasure or the hero. If they see either one, they will move 1 tile towards the closest per turn, preferring treasures over the hero in case of a tie.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE I :</head><label>I</label><figDesc>Gameplay metrics used as variables combined in the evolving equation trees, and their notation.</figDesc><table><row><cell>Steps Taken (ST)</cell><cell>Proximity to Exit (PE)</cell></row><row><cell>Potions Drunk (PD)</cell><cell>Treasures Opened (TO)</cell></row><row><cell>Minitaur Knockouts (MTK)</cell><cell>Monsters Slain (MS)</cell></row><row><cell>Javelins Thrown (JT)</cell><cell>Health Left (HL)</cell></row><row><cell>Teleports Used (TU)</cell><cell>Traps Spring (TS)</cell></row><row><cell>Average MCTS reward ( R)</cell><cell>Interactive Objects Consumed (IC)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE II :</head><label>II</label><figDesc>Average scores in several game metrics for evolved and baseline personas. Results are averaged from 50 independent playthroughs of the best personas in each of the 11 maps. Results include the 95% confidence interval.</figDesc><table><row><cell>Metric</cell><cell>R</cell><cell>MK</cell><cell>TC</cell><cell>C</cell></row><row><cell>Evolved</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Monsters</cell><cell cols="3">46%¬±2% 67%¬±2% 59%¬±2%</cell><cell>66%¬±3%</cell></row><row><cell>Potions</cell><cell>8%¬±1%</cell><cell cols="2">4%¬±1% 25%¬±2%</cell><cell>8%¬±1%</cell></row><row><cell>Treasures</cell><cell>10%¬±1%</cell><cell cols="2">7%¬±1% 35%¬±2%</cell><cell>10%¬±1%</cell></row><row><cell>Interactive Objects</cell><cell cols="3">25%¬±1% 33%¬±1% 41%¬±1%</cell><cell>34%¬±1%</cell></row><row><cell>Win Rate</cell><cell cols="4">100%¬±0% 73%¬±4% 54%¬±4% 100%¬±0%</cell></row><row><cell>Time (sec)</cell><cell>3.2¬±0.3</cell><cell>83¬±11</cell><cell>151¬±12</cell><cell>8.1¬±1.2</cell></row><row><cell>Baseline</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Monsters</cell><cell cols="3">25%¬±1% 29%¬±1% 25%¬±1%</cell><cell>28%¬±0%</cell></row><row><cell>Potions</cell><cell>5%¬±1%</cell><cell>5%¬±1%</cell><cell>6%¬±1%</cell><cell>5%¬±0%</cell></row><row><cell>Treasures</cell><cell>5%¬±1%</cell><cell cols="2">5%¬±1% 17%¬±2%</cell><cell>6%¬±0%</cell></row><row><cell>Interactive Objects</cell><cell cols="3">13%¬±1% 16%¬±1% 19%¬±1%</cell><cell>15%¬±0%</cell></row><row><cell>Win Rate</cell><cell cols="2">10%¬±3% 12%¬±3%</cell><cell>9%¬±2%</cell><cell>13%¬±0%</cell></row><row><cell>Time (sec)</cell><cell>277¬±6</cell><cell>285¬±4</cell><cell>279¬±5</cell><cell>278¬±0</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE III :</head><label>III</label><figDesc>Maps in which the shown metrics are significantly higher for the evolved persona (E) than the baseline persona of the same type, and maps in which the reverse is true (B).</figDesc><table><row><cell></cell><cell>R</cell><cell></cell><cell cols="2">MK</cell><cell>TC</cell><cell></cell><cell>C</cell><cell></cell></row><row><cell>Metric</cell><cell cols="2">E B</cell><cell cols="2">E B</cell><cell cols="2">E B</cell><cell cols="2">E B</cell></row><row><cell>Monster Ratio</cell><cell>8</cell><cell>1</cell><cell cols="2">10 0</cell><cell cols="2">10 1</cell><cell cols="2">10 0</cell></row><row><cell>Potion Ratio</cell><cell>2</cell><cell>0</cell><cell>2</cell><cell>1</cell><cell>8</cell><cell>1</cell><cell>2</cell><cell>0</cell></row><row><cell>Treasure Ratio</cell><cell>3</cell><cell>2</cell><cell>2</cell><cell>5</cell><cell>7</cell><cell>1</cell><cell>3</cell><cell>3</cell></row><row><cell>Interactive Objects Ratio</cell><cell>9</cell><cell>1</cell><cell cols="2">10 0</cell><cell cols="2">10 1</cell><cell cols="2">10 0</cell></row><row><cell>Time (sec)</cell><cell cols="2">0 11</cell><cell cols="2">0 11</cell><cell cols="2">0 10</cell><cell cols="2">0 11</cell></row><row><cell>Win Rate</cell><cell cols="2">10 0</cell><cell>7</cell><cell>0</cell><cell>7</cell><cell>0</cell><cell cols="2">10 0</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>We thank Abdallah Saffidine and Ahmed Khalifa for advice on tree search and evolving MCTS. Michael Green acknowledges financial support from the GAANN Program.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><surname>Fullerton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Swain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hoffman</surname></persName>
		</author>
		<title level="m">Game Design Workshop: Designing, Prototyping, and Playtesting Games</title>
		<imprint>
			<publisher>Focal Press</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Game Analytics: Maximizing the Value of Player Data</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>El-Nasr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Drachen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Canossa</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">MiniDungeons 2: An Experimental Game for Capturing and Modeling Player Decisions</title>
		<author>
			<persName><forename type="first">C</forename><surname>Holmg√•rd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Liapis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Togelius</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">N</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Foundations of Digital Games Conference</title>
		<meeting>the Foundations of Digital Games Conference</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">MDA: A formal approach to game design and game research</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hunicke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Leblanc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Zubek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the AAAI Workshop on Challenges in Game AI</title>
		<meeting>the AAAI Workshop on Challenges in Game AI</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">4</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Montecarlo tree search for persona based player modeling</title>
		<author>
			<persName><forename type="first">C</forename><surname>Holmg√•rd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Liapis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Togelius</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">N</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the AIIDE workshop on Player Modeling</title>
		<meeting>the AIIDE workshop on Player Modeling</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Generative agents for player decision modeling in games</title>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Foundations of Digital Games Conference</title>
		<meeting>the Foundations of Digital Games Conference</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Evolving personas for player decision modeling</title>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Conference on Computational Intelligence and Games</title>
		<meeting>the IEEE Conference on Computational Intelligence and Games</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Evolving models of player decision making: Personas versus clones</title>
	</analytic>
	<monogr>
		<title level="m">Entertainment Computing</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Procedural personas as critics for dungeon generation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Liapis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Holmg√•rd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">N</forename><surname>Yannakakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Togelius</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Applications of Evolutionary Computation</title>
		<imprint>
			<publisher>LNCS</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9028</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Maximizing the impact of procedural personalities</title>
		<author>
			<persName><forename type="first">T</forename><surname>Short</surname></persName>
		</author>
		<ptr target="http://www.gamasutra.com/blogs/TanyaShort/20170222/291312/MaximizingtheImpactofProceduralPersonalities.php" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Cooper</surname></persName>
		</author>
		<title level="m">The inmates are running the asylum: Why high-tech products drive us crazy and how to restore the sanity</title>
		<meeting><address><addrLine>Indianapolis, Ind</addrLine></address></meeting>
		<imprint>
			<publisher>Sams</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
	<note>new ed.</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Patterns of Play: Play-Personas in User-Centred Game Development</title>
		<author>
			<persName><forename type="first">A</forename><surname>Canossa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Drachen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the DiGRA International Conference</title>
		<meeting>the DiGRA International Conference</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Defining Personas in Games Using Metrics</title>
		<author>
			<persName><forename type="first">A</forename><surname>Tychsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Canossa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2008 Conference on Future Play: Research, Play, Share</title>
		<meeting>the 2008 Conference on Future Play: Research, Play, Share</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="73" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Personas versus clones for player decision modeling</title>
		<author>
			<persName><forename type="first">C</forename><surname>Holmg√•rd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Liapis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Togelius</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">N</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Entertainment Computing</title>
		<meeting>the International Conference on Entertainment Computing</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="159" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Game metrics without players: Strategies for understanding game artifacts</title>
		<author>
			<persName><forename type="first">M</forename><surname>Nelson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the AIIDE Workshop on Artificial Intelligence in the Game Design Process</title>
		<meeting>the AIIDE Workshop on Artificial Intelligence in the Game Design Process</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="14" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">An Inclusive Taxonomy of Player Modeling</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lewis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hullett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sullivan</surname></persName>
		</author>
		<idno>UCSC-SOE-11-13</idno>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
		<respStmt>
			<orgName>University of California, Santa Cruz</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Player Modeling</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">N</forename><surname>Yannakakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Spronck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Loiacono</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Andr√©</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Artificial and Computational Intelligence in Games</title>
		<meeting><address><addrLine>Saarbr√ºcken/Wadern</addrLine></address></meeting>
		<imprint>
			<publisher>Dagstuhl Publishing</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="45" to="55" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Imitating human playing styles in super mario bros</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ortega</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shaker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Togelius</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">N</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Entertainment Computing</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="93" to="104" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Towards automatic personalised content creation for racing games</title>
		<author>
			<persName><forename type="first">J</forename><surname>Togelius</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">De</forename><surname>Nardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Lucas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Conference on Computational Intelligence and Games</title>
		<meeting>the IEEE Conference on Computational Intelligence and Games</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Behavlets: a method for practical player modelling using psychology-based player traits and domain specific features</title>
		<author>
			<persName><forename type="first">B</forename><surname>Cowley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Charles</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">UMUAI</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<biblScope unit="page" from="257" to="306" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Learning policies for first person shooter games using inverse reinforcement learning</title>
		<author>
			<persName><forename type="first">B</forename><surname>Tastan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Sukthankar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the AAAI Artificial Intelligence for Interactive Digital Entertainment Conference. AAAI</title>
		<meeting>the AAAI Artificial Intelligence for Interactive Digital Entertainment Conference. AAAI</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Combining gameplay data with monte carlo tree search to emulate human play</title>
		<author>
			<persName><forename type="first">S</forename><surname>Devlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Anspoka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sephton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">I</forename><surname>Cowling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rollason</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the AAAI Artificial Intelligence for Interactive Digital Entertainment Conference</title>
		<meeting>the AAAI Artificial Intelligence for Interactive Digital Entertainment Conference</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Monte-carlo tree search for simulation-based strategy analysis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Zook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Riedl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Foundations of Digital Games Conference</title>
		<meeting>the Foundations of Digital Games Conference</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Investigating vanilla mcts scaling on the gvg-ai game corpus</title>
		<author>
			<persName><forename type="first">M</forename><surname>Nelson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Conference on Computational Intelligence and Games</title>
		<meeting>the IEEE Conference on Computational Intelligence and Games</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Modifying mcts for human-like general video game playing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Khalifa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Isaksen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Togelius</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nealen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IJCAI</title>
		<meeting>IJCAI</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A survey of monte carlo tree search methods</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">B</forename><surname>Browne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Powley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Whitehouse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Lucas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">I</forename><surname>Cowling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rohlfshagen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tavener</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Perez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Samothrakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Colton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on CI and AI in Games</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="43" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Evolving Monte-Carlo Tree Search Algorithms</title>
		<author>
			<persName><forename type="first">T</forename><surname>Cazenave</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Dept. Inform., Tech. Rep</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<date type="published" when="2007">2007</date>
			<pubPlace>Paris</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Univ</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Evolving gamespecific UCB alternatives for general video game playing</title>
		<author>
			<persName><forename type="first">I</forename><surname>Bravi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Khalifa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Holmg√•rd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Togelius</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Applications of Evolutionary Computation</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">The island model genetic algorithm: On separability, population size and convergence</title>
		<author>
			<persName><forename type="first">D</forename><surname>Whitley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Heckendorn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CIT. Journal of computing and information technology</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="33" to="47" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
