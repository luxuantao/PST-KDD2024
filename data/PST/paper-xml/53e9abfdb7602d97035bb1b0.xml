<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Careful with Composition: Limitations of the Indifferentiability Framework</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Thomas</forename><surname>Ristenpart</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Sciences</orgName>
								<orgName type="institution">University of Wisconsin-Madison</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Hovav</forename><surname>Shacham</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Dept. of Computer Science &amp; Engineering</orgName>
								<orgName type="institution">UC San Diego</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Thomas</forename><surname>Shrimpton</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Dept. of Computer Science</orgName>
								<orgName type="institution">Portland State University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Careful with Composition: Limitations of the Indifferentiability Framework</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">BDECBE81D84217E201CC13D455275077</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:24+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We exhibit a hash-based storage auditing scheme which is provably secure in the random-oracle model (ROM), but easily broken when one instead uses typical indifferentiable hash constructions. This contradicts the widely accepted belief that the indifferentiability composition theorem from [27] applies to any cryptosystem. We characterize the uncovered limitations of indifferentiability by showing that the formalizations used thus far implicitly exclude security notions captured by experiments that have multiple, disjoint adversarial stages. Examples include deterministic public-key encryption (PKE), password-based cryptography, hash function nonmalleability, and more. We formalize a stronger notion, reset indifferentiability, that enables a composition theorem covering such multi-stage security notions, but our results show that practical hash constructions cannot be reset indifferentiable. We finish by giving direct security proofs for several important PKE schemes.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The indifferentiability framework of Maurer, Renner, and Holenstein (MRH) <ref type="bibr" target="#b31">[27]</ref> supports modular proofs of security for cryptosystems. A crucial application of the framework has been to allow proofs in the random oracle model (ROM) <ref type="bibr" target="#b8">[8]</ref> to be transferred to other idealized models of computation, where a monolithic random oracle is replaced by a hash function constructed from (say) an ideal compression function. This happens via an elegant composition theorem, the usual interpretation of which is: A proof of security for an arbitrary cryptosystem using functionality F (e.g., a random oracle) continues to hold when the cryptosystem instead uses a second functionality F (e.g., a hash function built from an ideal compression function), so long as F is indifferentiable from F .</p><p>In this paper, we show that this interpretation is too generous. We uncover an application (in the context of secure distributed storage) for which composition fails completely. For this application there is a simple scheme provably secure in the ROM, and yet easily broken when using typical indifferentiable hash constructions. We then begin an exploration of the fall out.</p><p>Random oracles and indifferentiability. Let us give a bit more background on why indifferentiability has proved so useful. A wide range of practical, in-use cryptographic schemes enjoy proofs of security in the ROM <ref type="bibr" target="#b8">[8]</ref>; for some schemes, ROM proofs are the only ones known. But most in-use hash-function constructions are not suitable for modeling as a RO, even when assuming the primitive underlying the hash function is ideal (e.g., an ideal compression function), because they admit length-extension attacks <ref type="bibr" target="#b36">[32]</ref>. These attacks abuse the structure of the iterative modes-of-operation underlying hash functions such as MD5, SHA-1, and SHA-2. And the weakness they expose has led to practical insecurities <ref type="bibr" target="#b21">[18]</ref>. Of course, we can build hash functions that resist known lengthextension attacks, but it remains unclear whether the resulting functions would also prevent other, unforeseen structure-abusing attacks.</p><p>Coron et al. <ref type="bibr" target="#b16">[15]</ref> instead suggest an approach to design hash functions that "behave like" random oracles in a provable sense. Specifically, this requires that a hash function will provide security anywhere a random oracle would. The MRH composition theorem seems to give exactly this, taking F = RO and F = H f , the latter being a hash function constructed from an (ideal) primitive f . Thus the needed hash function property is that H f be indifferentiable from a RO. Importantly, this approach preserves proofs of security as well: the MRH theorem transports a cryptosystem's proof of security in the ROM to a proof of security when using an indifferentiable hash function. A number of recent works prove constructions to be indifferentiable from a RO (e.g., <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b17">16,</ref><ref type="bibr" target="#b19">17,</ref><ref type="bibr" target="#b24">21]</ref>), including many candidates for the NIST SHA-3 competition. Given all this, the consensus opinion appears to be that indifferentiability exactly captures "behaving like" a RO, rules out structure-abusing attacks, and that once a cryptosystem is proven in the ROM it is secure using any compatible indifferentiable hash construction.</p><p>Hash-based storage auditing. We now describe an application that shows this consensus opinion to be wrong. In the design of secure distributed systems, the following important problem arises: How can parties in a system verify that a storage server is actually storing the files that it should be? A malicious server might tamper arbitrarily with the data entrusted to it; a rational one might discard the file to save space if detection is unlikely. This problem has received much attention since being formalized in 2007 <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b25">22]</ref>. The particular example we consider in this paper is inspired by a proof-of-storage challenge-response protocol proposed as part of an earlier system, SafeStore <ref type="bibr" target="#b26">[23]</ref>. Consider the following protocol. The client sends a random challenge C to the server; the server proves possession of the file M by computing Z ← Hash(M C) using a cryptographic hash function Hash and sending Z to the client, who performs the same computation using her copy of M and compares the result to that sent by the server.</p><p>Suppose, for simplicity, that both the file M and the challenge C are d bits long, and consider the case that Hash = H f , where f is an ideal compression function outputting strings of length n &lt; d bits and H returns the first n/2 bits of f (f (IV, M ), C). (IV is a fixed constant string.) This construction was shown indifferentiable from a RO in <ref type="bibr" target="#b16">[15]</ref>. Thus, the MRH composition theorem combined with the fact that the protocol is secure in the ROM assuredly proves that the protocol is secure when using H f . Quite baffling, then, is the observation that the server can cheat! The server simply computes Y ← f (IV, M ) when it first gets M , and then deletes M and stores the (shorter) Y . To answer a challenge C, the server computes Z ← f (Y, C) and returns the first half of Z as its response. The client's check will succeed even though M is not stored.</p><p>The attack abuses a structural feature of typical hash functions that we call online computability. A hash function has this property when it can process its input in successive blocks, storing only a small amount of internal state between blocks. This property is desirable in practice and all indifferentiable hash constructions suggested for practical use have it (see, e.g., <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b17">16,</ref><ref type="bibr" target="#b24">21]</ref>). As our example shows, however, online computability can be abused.</p><p>Let us pause to take stock of the situation. In Section 4 we prove that the SafeStore-inspired auditing scheme is, indeed, secure in the ROM. The proof of indifferentiability for our Hash = H f provided by Coron et al. <ref type="bibr" target="#b16">[15]</ref> and the proof of the MRH composition theorem are also both correct. But the server is still somehow able to abuse the structure of H f . So what is going on here?</p><p>Characterizing the problem. The gap is that the MRH theorem does not apply. The problem is subtle. Carefully revisiting the MRH theorem and its proof, we find that (loosely speaking) they only apply when a cryptosystem's security is measured relative to a security game using a single, stateful adversary. For example, left-or-right indistinguishability <ref type="bibr" target="#b22">[19]</ref> for encryption schemes and unforgeability under chosen message attacks <ref type="bibr" target="#b23">[20]</ref> each use just a single, stateful adversary. But the security of the challenge-response auditing protocol we just described is fundamentally two-stage. In the first stage, the adversary (the server) receives the message M , derives from M some state st that is smaller than the size of M , and forgets M . In a second stage it attempts to answer challenges using just st. This is an example of what we call a multi-stage game, a notion we will make formal.</p><p>In prior treatments of indifferentiability, the restriction to single-stage games is implicit in the underlying formalization of cryptosystems and adversaries. This restriction has not been mentioned in the literature, and our sense is that no researchers (until now) realized it. For completeness, we restate the MRH indifferentiability composition theorem and give its proof for single-stage games (see Section 3).</p><p>Repercussions. We do not necessarily expect that practitioners would (or have) deployed the hash-based auditing scheme above. One can simply use H f (C M ) to achieve (provable) security, and in fact this is the actual protocol used in Safe-Store <ref type="bibr" target="#b26">[23]</ref>. But the flaw this example uncovers is that the common interpretation of composition actually encourages use of an insecure auditing mechanism. This is exactly the opposite of how provable security should guide protocol design.</p><p>All of this casts doubt on the security of any scheme relative to a multistage game. The scheme may well have provable security in the ROM, but this does not imply the inexistence of dangerous structure-abusing attacks, even when using indifferentiable hash constructions. And unfortunately the danger is widespread. The recent security notions for deterministic <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b12">12]</ref>, hedged <ref type="bibr" target="#b4">[4]</ref>, and efficiently searchable <ref type="bibr" target="#b2">[3]</ref> public-key encryption (PKE) are all multi-stage. When formalizing password-based cryptography (e.g. <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b37">33]</ref>) to allow arbitrary, hash-dependent password sampling algorithms, one uses multi-stage games. A recently proposed hash function nonmalleability security notion <ref type="bibr" target="#b11">[11]</ref> is multi-stage. Interestingly, this is the only notion (we are aware of) that formalizes security against lengthextension attacks, and so although we expect them to, we do not have proof that current indifferentiable hash constructions resist length-extension attacks.</p><p>So, we cannot generically use indifferentiability-based composition to modularly argue security in the context of multi-stage games. But it could be that indifferentiability remains a sufficient property to establish security in settings beyond hash-based challenge-response auditing. One might hope to prove, without relying on the MRH composition theorem, that a ROM proof of (say) a deterministic PKE scheme holds still when using any indifferentiable hash construction. This seems reasonable since for the applications just listed, online computability of the hash function does not obviously compromise security.</p><p>Yet we prove that such proofs do not exist. Namely, we show in Section 5 that indifferentiability does not imply security in the multi-stage settings mentioned above.</p><p>Reset indifferentiability. We present a new notion, reset indifferentiability, that does admit a composition theorem covering both single-stage and multistage games. In the indifferentiability framework, functionalities have both an honest and an adversarial interface, e.g. F.hon, F.adv and F .hon, F .adv. Functionality F is indifferentiable from F if there exists a simulator S such that no distinguisher can determine when it has access to oracles F.hon and F.adv or to F .hon and S F .adv . Reset indifferentiability asks that no distinguisher can differentiate those two sets of oracles, but when the distinguisher can reset the simulator to its initial state at arbitrary times. Randomized simulators use freshly-chosen coins after each reset.</p><p>The inability to distinguish when resets are allowed enables proving a composition theorem for multi-stage games because the resets allow one to restart the simulator for each stage. However, it is easy to see that reset indifferentiability is a strong property. While constructions that only require stateless, deterministic simulators can be easily shown to achieve reset indifferentiability, it is unclear if any non-trivial constructions requiring randomized, stateful simulators can meet it. Moreover, there is clear intuition that typical hash constructions are unlikely to be reset indifferentiable -they have the property of online computability. Still, that leaves open if other efficient constructions perform better. We answer this question in the negative, proving that a wide class of single-pass hash function domain extension constructions cannot be shown reset indifferentiable. We leave open the problem of proving the existence (or inexistence) of a domain extender, even an impractical one (i.e., one that makes two or more passes over the message), that is reset indifferentiable. Direct proofs. Having lost the MRH composition as a general way to transport ROM proofs of security for multi-stage games to the setting where one uses a hash constructed from an ideal primitive, we take up consideration of a specific security goal from public-key encryption. We prove a theorem establishing the chosen-distribution attack (CDA) security for a number of related, ROM-secure, PKE schemes when these are used with any indifferentiable hash function built according to a design paradigm introduced by Dodis, Ristenpart and Shrimpton <ref type="bibr" target="#b19">[17]</ref>. The CDA security notion <ref type="bibr" target="#b4">[4]</ref> captures message privacy of a PKE scheme when messages and randomness are (jointly) unpredictable, but otherwise adversarially controlled. In particular, this notion is the goal in the context of deterministic PKE <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b12">12]</ref>, hedged PKE (which provides message privacy even in the face of poor randomness) <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b35">31]</ref>, and efficiently searchable encryption (an extension of deterministic PKE) <ref type="bibr" target="#b2">[3]</ref>. As expected, this direct proof of security is complex because we have to work directly in the model of the ideal primitive underlying the hash function. This case study shows that direct security results are possible, restoring confidence that in some multi-stage settings security holds with proposed indifferentiable hash constructions.</p><p>Other limitations. In the course of understanding the hash-based auditing counter-example, we uncovered other subtle ways in which composition may fail to help one establish security; a discussion of these appears in the full version <ref type="bibr" target="#b33">[29]</ref>.</p><p>Universal composability. Our results have analogous repercussions for composition frameworks similar to indifferentiability, such as universal composability <ref type="bibr" target="#b13">[13]</ref>. We discuss other frameworks in the full version <ref type="bibr" target="#b33">[29]</ref>.</p><p>Discussion. We emphasize that we are not recommending that indifferentiability be dropped as a target of hash function design. The class of single-stage games includes many very important ones, and even after our results indifferentiabilitybased composition remains an elegant way to analyze security for these cases. Instead, we stress that one must be careful when using composition to perform a security analysis, ensuring that it does in fact apply as expected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>A code-based games framework. We formalize a version of the code-based games framework of Bellare and Rogaway <ref type="bibr" target="#b9">[9]</ref> for representing security experiments, indifferentiability, and the like. We find code-based games useful for formalizing security definitions, in particular, because they allow us to specify execution semantics (i.e. what runs what, and in what order). Here we give only the most important details, deferring others to the full version of this paper. A procedure is a sequence of statements together with zero or more inputs (variables) and zero or more outputs (variables). An unspecified procedure is one whose pseudocode, inputs, and outputs are understood from context. An adversary is an example of an unspecified procedure. Calling a procedure P means providing it with inputs and running its sequence of statements. During its execution P may itself call other procedures. Say that the code of P expects to be able to call k distinct procedures. We will write P Q1,Q2,...,Q k to denote that these calls are handled by Q 1 , Q 2 , . . . , Q k . Procedures P 1 and P 2 are said to export the proc. RO.hon(x):</p><formula xml:id="formula_0">If T[x] = ⊥ then T[x] ←$ {0, 1} r Ret T[x]</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>proc. RO.adv(x):</head><p>Ret RO.hon(x) proc. IP.hon(x):</p><formula xml:id="formula_1">Ret H P.hon (x)</formula><p>proc. IP.adv(x):</p><p>Ret P.adv(x) same interface if their inputs and outputs agree in number and type. This will typically be clear from context.</p><p>A main procedure is a distinguished procedure that takes no inputs and has some output. We mark it by main. No procedure may call main, and main can access all variables of other specified procedures. (But not other unspecified procedures.)</p><p>Variables are implicitly set initially to default values, i.e. integer variables are set to 0, arrays are everywhere ⊥, etc. Variables are by default local, meaning they can only be used within a single procedure. The variables used within a procedure maintain their state between calls. A collection of procedures is a set of one or more procedures that may instead share their variables. We denote a collection of procedures by using a common prefix ending with a period, e.g. (P.x, P.y, . . .) and we use the common prefix P to refer to the collection. We will sometimes refer to the unique suffixes, e.g. x, y, as interfaces of P .</p><p>Collections of procedures will sometimes implement particular abstract functionalities, for example that of some idealized primitive (e.g. a random oracle). A functionality is a collection F = (F.hon, F.adv); the names of these interfaces, hon and adv are suggestive as we will see in a moment. When games and adversaries are given access to a functionality a model of computation is induced, for example when the functionality is that of a random oracle, we have the random-oracle model. Thus one can think of functionalities and models somewhat interchangeably. For this work we specifically designate two models. First RO = (RO.hon, RO.adv), shown on the left-hand side of Figure <ref type="figure" target="#fig_0">1</ref>, implements a random oracle (with two interfaces) and will give rise to the random-oracle model. Second, let P = (P.hon, P.adv) implement some (ideal) primitive that underlies some understood construction H. Then IP = (IP.hon, IP.adv) shown on the right-side of Figure <ref type="figure" target="#fig_0">1</ref> gives rise to an (ideal) primitive model. For notational compactness, each time we use IP we will specify a construction H and a primitive P and assume these are the ones referred to in Figure <ref type="figure" target="#fig_0">1</ref>.</p><p>For any two functionalities F 1 , F 2 , we denote by (F 1 , F 2 ) the functionality that exposes a procedure that allows querying (F 1 .hon, F 2 .hon) and a procedure that gives access to (F 1 .adv, F 2 .adv).</p><p>A game G consists of a single main procedure, denoted "main G", together with a set of zero or more other specified procedures. (See for example Figure <ref type="figure" target="#fig_1">2</ref>.) A game can make use of a functionality F and a number of adversarial procedures A 1 , . . . , A m together referred to as the adversary. We denote this by G F,A1,...,Am . We fix the convention that the main and specified procedures of G can call F.hon and A 1 , . . . , A m (but may not call F.adv) while the adversarial procedures may call F.adv (but may not call F.hon). Thus F.adv is the adversarial interface of F , and F.hon is the honest interface. For any F 1 , A 1 , . . . , A m and F 1 , A 1 , . . . , A m such that F 1 .hon, F 2 .hon are interface compatible and A i , A i are interface compatible for 1 ≤ i ≤ m, we can write G F1,A1,...,Am to mean running game G with one set of external procedures and G F2,A 1 ,...,A m to mean running the same game but now with the second set of external procedures. Running a game G F,A1,...,Am means executing the sequence of statements of the game's main procedure and the output of G is the value returned by main. We denote by G F,A1,...,Am ⇒ y the event that the game's output is y, taken over the probability space defined by the coins used to execute G and the coins used in each invocation of the procedures F.hon, F.adv, A 1 , . . . , A m . Should G and the adversary not use F.hon, F.adv then we instead write G A1,...,Am ⇒ y. As examples, games that do not use a functionality F are given in Figure <ref type="figure" target="#fig_1">2</ref> while games that do are given in Figures <ref type="figure">3</ref> and<ref type="figure" target="#fig_2">4</ref>.</p><p>For any fixed functionality F and adversary A 1 , . . . , A m , two games G and H are equivalent if Pr G F A1,...,Am ⇒ y = Pr H F,A1,...,Am ⇒ y for all values y.</p><p>Resources. For simplicity, we fix the convention that each statement of a procedure runs in unit time. The running time of a procedure, then, is the maximum number of statements executed, where the maximum is taken over all possible inputs and over all coins used by the procedure. The number of queries of a procedure is the maximum number of procedure calls it makes in one execution, again with the maximum taken over all possible inputs and all possible coins used by the procedure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Indifferentiability Framework for Single-Stage Games</head><p>We describe the indifferentiablity framework <ref type="bibr" target="#b31">[27]</ref> using games, unlike prior treatments that used random systems <ref type="bibr" target="#b30">[26,</ref><ref type="bibr" target="#b31">27]</ref> or interactive Turing machines <ref type="bibr" target="#b16">[15]</ref>. We feel that using explicit code-based games makes understanding the limitations of indifferentiability easier, because it will enable expressing these limitations as syntactic conditions on the class of games considered. In addition to defining indifferentiability, we will provide a concrete version of the composition theorem given in <ref type="bibr" target="#b31">[27]</ref> and characterize its limitations.</p><p>Indifferentiability. Fix two functionalities F 1 and F 2 . When thinking of indifferentiability from random oracles, for example, we use F 1 = IP (for some understood H, P ) and F 2 = RO. A distinguisher D is an adversary that outputs a bit. A simulator is a procedure, usually denoted S. Figure <ref type="figure" target="#fig_1">2</ref> defines two games Real and Ideal. Fix some value y (e.g., y = 1). The indifferentiability advantage of D is defined as</p><formula xml:id="formula_2">Adv indiff F1,F2,S (D) = Pr Real F1,D ⇒ y -Pr Ideal F2,D S ⇒ y .</formula><p>We use a concrete security approach, i.e. not providing a strict definition of achieving indifferentiability. However, informally we will say that a functionality F 1 is indifferentiable from a functionality F 2 if for any "reasonable" adversary D there exists an "efficient" simulator S such that Adv indiff F1,F2,S (D) is "small". The meanings of "reasonable", "efficient", and "small" will be clear from context.</p><p>To get an asymptotic notion, we can assume an implicit security parameter k throughout, and then use the definition of <ref type="bibr" target="#b16">[15]</ref>: F 1 is indifferentiable from F 2 if there exists a PT simulator S such that for any PT D it is the case that Adv indiff F1,F2,S (D) is negligible in the security parameter. Note that in <ref type="bibr" target="#b31">[27]</ref> a different quantifier ordering was used. It said that for all PT D there must exist a PT simulator S such that Adv indiff F1,F2,S (D) is negligible in the security parameter. We refer to the <ref type="bibr" target="#b31">[27]</ref> notion as weak indifferentiability and to the <ref type="bibr" target="#b16">[15]</ref> notion as strong indifferentiability. We will focus on strong indifferentiability here since it implies weak.</p><p>Composition. One goal of indifferentiability is to allow the security analysis of a cryptographic scheme when using one functionality to imply security holds when using another. This is enabled by the following, which is a concrete security version of the original composition theorem of Maurer, Renner, and Holenstein <ref type="bibr" target="#b31">[27]</ref>.</p><p>Theorem 1. Let G be a game expecting access to a functionality and a single adversarial procedure. Let F 1 , F 2 be two functionalities with compatible honest interfaces. Let A be an adversary with one oracle. Let S be a simulator that exports the same interface as F 1 .adv. Then there exist adversary B and distinguisher D such that for all values y</p><formula xml:id="formula_3">Pr G F1,A ⇒ y ≤ Pr G F2,B ⇒ y + Adv indiff F1,F2,S (D) . Moreover: t B ≤ t A + q A • t S , q B ≤ q A • q S , t D ≤ t G + q G,1 • t A , and q D ≤ q G,0 +q G,1 •q A ,</formula><p>where t A , t B , t D are the maximum running times of A, B, D; q A , q B are the maximum number of queries made by A and B in a single execution; and q G,0 , q G,1 are the maximum number of queries made by G to the honest interface and to the adversarial procedure.</p><p>The proof of Theorem 1 is readily established by adapting the proof of <ref type="bibr" target="#b31">[27,</ref><ref type="bibr">Th. 1]</ref>. We provide a proof here to help support our upcoming discussion.</p><p>Proof. Fix any value y. Let F = (F.hon, F.adv) be some unspecified functionality that export the same interface as (F 1 .hon, F 1 .adv). Let indifferentiability adversary D be defined as follows. Adversary D runs game G. Whenever G calls its honest interface, adversary D queries F.hon and returns the result. Whenever G calls A, adversary D runs A for G using F.adv to answer any queries made by A. Finally D outputs whatever G outputs. Then by construction q D ≤ q G,0 +q G,1 q A ; t D ≤ t G + q G,1 t A ; and</p><formula xml:id="formula_4">Pr Real D ⇒ y = Pr G F1,A ⇒ y (1)</formula><p>in the case that F = F 1 . Now we define adversary B as follows. Adversary B runs A. When A queries its oracle, adversary B runs S using its F 2 .adv oracle to answer any queries S makes. Adversary B outputs whatever A outputs. By construction, then, we have that q B ≤ q A •q S ; t B ≤ t A + q A •t S ; and</p><formula xml:id="formula_5">Pr Ideal D S ⇒ y = Pr G F2,A S ⇒ y = Pr G F2,B ⇒ y (2)</formula><p>in the case that F = F 2 . By substituting according to Equations 1 and 2 into the definition of indifferentiability advantage we derive the advantage relation of the theorem statement.</p><p>Single-stage games. The theorem above explicitly restricts attention to games that only use a single adversarial procedure. At first glance, this restriction may seem artificial. Suppose a game G expects access to adversarial procedures A 1 , . . . , A m and now consider generalizing Theorem 1 to account for G. Recall that these adversarial procedures do not share state. In the proof, a key step is defining the adversary B. Following that proof, for this generalization we could define adversarial procedures B 1 , . . . , B m by B i = A S i for all i. One may think a proof has been arrived at. However S is only guaranteed to simulate properly when it maintains its state across all invocations throughout the course of the indifferentiability game. Technically, then, the problem is that the analogue of equation ( <ref type="formula">2</ref>) for this proof attempt would fail: Pr G F2,B1,...,Bm ⇒ y = Pr G F2,A S 1 ,...,A S m ⇒ y = Pr Ideal D S ⇒ y . This is true regardless of how we define D. In the next section, we provide a counterexample showing that there is no hope of a proof for this generalization.</p><p>All this means that indifferentiability-based composition can only apply to security notions defined via single-stage games, which we now define. Consider a game that has m procedures. We say that a game is stage minimal if all games G that are equivalent to G use the same number of adversarial procedures. We now restrict attention to stage minimal games. Then, an m-stage game is one that has m stages. A single-stage game is one for which m = 1 and a multi-stage game is one for which m &gt; 1. Let SG be the set of all single-stage games. Note that SG includes the games defining indifferentiability above, the classic notions of encryption security such as IND-CPA <ref type="bibr" target="#b22">[19]</ref> or IND-CCA <ref type="bibr" target="#b32">[28]</ref>, unforgeability under chosen message attack UF-CMA <ref type="bibr" target="#b23">[20]</ref>, and many others.</p><p>If G is the set of all games, then we let MG = G\SG be the set of games that are not single stage. We call any game in MG a multi-stage game. Examples of multi-stage games include chosen distribution attack security for public-key encryption <ref type="bibr" target="#b4">[4]</ref> (see Figure <ref type="figure" target="#fig_2">4</ref>), non-malleability of hash functions <ref type="bibr" target="#b11">[11]</ref>, passwordbased key exchange <ref type="bibr" target="#b6">[6]</ref>, and others.</p><p>Discussion. A game that uses multiple adversarial procedures, but is equivalent to a game with a single adversarial procedure, is not considered multi-stage by our definition above. Many experiments are formalized with multiple adversarial procedures, but the game forwards arbitrary adversarial state from one procedure to the next. It is clear such games are actually equivalent to one with a single adversarial procedure. Some games allow a small amount of state to be passed directly from one adversarial procedure to the next. See for example the hash auditing security property formalized in Figure <ref type="figure">3</ref>. Here, however, the state is not arbitrary -its length is a fixed constant-and so this game cannot be written with a single adversarial procedure.</p><p>We do note, however, that we may extend Theorem 1 to cover multi-stage games that directly share some limited amount of state, but an amount sufficient to enable composition. That is, the shared state must be large enough to transport the state of S between B i calls (in addition to whatever other state an adversary might use). We do not know of any examples of such multi-stage games, and so do not spell out the details of such an extension.</p><p>Note that there are other subtleties of composition that might lead to erroneous beliefs and claims. We provide a detailed discussion of these in the full version.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">A Practically Motivated Counterexample</head><p>In this section we define a simple hash function property that is met by a RO, but not met by a broad class of hash functions proven to be indifferentiable from a RO. Together these results give a counterexample disproving the desired generalization of Theorem 1 to multi-stage games.</p><p>Hash-based storage auditing. The property we study, denoted CRP, is motivated by challenge-response auditing protocols for secure distributed storage <ref type="bibr" target="#b26">[23]</ref>. Consider that a client wishes to store some data M on a remote server. It will later verify that M is in fact being stored by sending a random challenge C to the server, and then checking that the server's response matches the hash H(M C). Intuitively, if H is a random oracle, there is no way for the server to "cheat": It must actually store M , or guess the challenge in advance, if it is to respond correctly. (Drawing the challenges from a sufficiently large space or repeating the protocol will make the chance that the server guesses the challenges arbitrarily small.) In particular, if the server stores some state st instead of M , and |st| |M |, then we expect the server will fail to respond properly. The CRP experiment in Figure <ref type="figure">3</ref> captures a slightly simplified version of this example.</p><p>Informally, a CRP-secure hash function H should not admit the storage of a short string (much shorter than the file M ) that later allows the server to answer auditing challenges C, except with negligible probability. This guarantees that a rational server interested in saving storage space but subject to auditing will not store some short digest in place of the file.</p><p>The following theorem shows that, as expected, a random oracle possesses property CRP. The proof appears in the full version.</p><formula xml:id="formula_6">main CRP F,A1,A2 p,n,s M ←$ {0, 1} p st ←$ A F.adv 1 (M ) If |st| &gt; n then Ret false C ←$ {0, 1} s Z ←$ A F.adv 2 (st, C) Ret Z = F.hon(M C)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 3. Game capturing our challenge-response hash function property</head><p>Theorem 2. Fix p, n, s &gt; 0. Let A = (A 1 , A 2 ) be an adversary that makes a total of q calls. Then</p><formula xml:id="formula_7">Pr CRP RO,A1,A2 p,n,s ⇒ true ≤ q 2 p-n + 1 2 r + q 2 s</formula><p>where RO provides the functionality of a random oracle with range {0, 1} r .</p><p>Online computability and CRP. We now define a structural property of hash functions, which we refer to as online computability. Consider a hash function H f : {0, 1} * → {0, 1} r using some underlying primitive f . Then we say that H f is (p, n, s)-online computable if for p, n, s &gt; 0 there exist functions</p><formula xml:id="formula_8">H f 1 : {0, 1} p → {0, 1} n and H f 2 : {0, 1} n × {0, 1} s → {0, 1} r such that H f (M 1 M 2 ) = H f 2 (H f 1 (M 1 ), M 2 )) for any (M 1 , M 2 ) ∈ {0, 1} p × {0, 1} s .</formula><p>Moreover, we require that the time to compute H f 1 and H f 2 is within a small, absolute constant of the time to compute H f . In words, the hash function H f can be computed in two stages, processing M 1 and then M 2 sequentially.</p><p>We note that most iterative hash function constructions are online computable for a variety of values p, n, s. For example, the so-called NMAC construction from <ref type="bibr" target="#b16">[15]</ref>. It uses two underlying ideal objects f : {0, 1} 2n → {0, 1} n and g : {0, 1} n → {0, 1} n . Let f + : ({0, 1} n ) + → {0, 1} n be the mapping defined as follows: on input M = M 1 . . . M b , for each i ∈ {1, . . . , b} compute</p><formula xml:id="formula_9">V i = f (V i-1 M i )</formula><p>, where V 0 is some fixed n-bit string, and return</p><formula xml:id="formula_10">V b . Now, let H f,g (M ) = g(f + (M ))</formula><p>, where the domain is ({0, 1} n ) + . This construction is (p, n, s)-online computable for any p and s that are multiples of n. Say p = in for any i and s = n. Then let</p><formula xml:id="formula_11">H f 1 (M 1 ) = f + (M 1 ) and H f 2 (V, M 2 ) = g(f (V, M 2 )</formula><p>). Similarly, many other iterative constructions are online computable for such parameters, for example EMD <ref type="bibr" target="#b7">[7]</ref>, MDP <ref type="bibr" target="#b24">[21]</ref>, the Chop and so-called HMAC constructions <ref type="bibr" target="#b16">[15]</ref>, and numerous SHA-3 candidates.</p><p>It is clear to see that any (p, n, s)-online computable hash function cannot be CRP for those same parameters. For the NMAC example above, let</p><formula xml:id="formula_12">A 1 output st = H f 1 (M ) = f + (M ). Let A 2 output H 2 (st, C) = g(f (st, C)).</formula><p>The adversary wins with probability 1.</p><p>SafeStore and storage auditing in practice. The SafeStore protocol used exactly the opposite ordering of N and M , specifying that audit responses be computed by H f (N M ). This construction does indeed have CRP (though one cannot use composition to establish it). The point is that indifferentiability appears to imply that N M and M N are equivalently secure. Given the widespread use of hash functions as random oracles in practice (implicitly or explicitly), we must be careful to assess each application's security starting from the ideal primitive underneath the hash function and only use indifferentiabilitybased composition when it is truly applicable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Indifferentiability Fails for Multi-stage Games</head><p>In the last section we saw how indifferentiability-based composition fails for a particular game, this being the CRP game. Here we extend that negative result to show how indifferentiability-based composition fails for many multi-stage games, including ones covering security of password-based key exchange, deterministic public-key encryption, non-malleability of hash functions, and more. To do so, we give a general method to show that indifferentiability does not imply security for games G ∈ MG.</p><p>Our approach will be to show that one can augment any ideal primitive to include a storage interface. This will simply take (key,value) pairs from the adversary and allow retrieving values by looking up a key. This augmentation does not affect any existing indifferentiability results involving the primitive -as we show below, a simulator for the original ideal primitive is easily converted to a simulator for the augmented primitive. Finally, we will show how cryptosystems cannot meet some multi-stage notions of security in the augmented primitive model.</p><p>Formally, let F 1 be a functionality. Let St be the procedure that exposes a hash table T. That is, on input a pair of strings (X, Y ), it sets T[X] ← Y and returns nothing. On input a string (X, ⊥) it outputs T[X], which is ⊥ if T[X] has yet to be set to another value. Then the storage-augmented functionality F * 1 = (F 1 .hon, F * 1 .adv) has the same honest interface as F 1 but F * 1 .adv exposes both F 1 .adv and St. That is, F * 1 .adv = (F 1 .adv, St). The following theorem states that if F 1 is indifferentiable from some functionality F 2 , then F * 1 is also indifferentiable from F 2 . Its proof is straightforward and appears in the full version. Theorem 3. Let F 1 , F 2 be functionalities and F * 1 be the storage-augmented version of F 1 . Let S B be a simulator. Then there exists a simulator S A such that for all distinguishers A there exists a distinguisher B such that</p><formula xml:id="formula_13">Adv indiff F * 1 ,F2,SA (A) = Adv indiff F1,F2</formula><p>,SB (B) B runs in time that of A and uses the same number of queries; S A runs in time that of S B plus a small constant and uses the same number of queries.</p><p>What Theorem 3 shows is that, as far as indifferentiability is concerned, it does not matter if some portion of the distinguisher's state is exported to an oracle. The intuition behind this result is straightforward: distinguishers in indifferentiability maintain state throughout the experiment and so it hardly matters whether one stores its state in an oracle or locally. But the ability to store data in an oracle obviates security for many multi-stage games. Here are some examples of cryptographic security goals that are not achievable in a storage-augmented primitive model. Note that all these are feasible in the ROM.</p><p>Example: CDA security for public-key encryption. Public-key encryption (PKE) and the chosen-distribution attack (CDA) security goal are defined in Section 7. CDA generalizes deterministic PKE security notions <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b12">12]</ref>, and CDA-secure PKE is useful for efficiently search over encrypted data <ref type="bibr" target="#b2">[3]</ref> and defense-in-depth against randomness failures <ref type="bibr" target="#b35">[31]</ref>. It is easy to see that if one is working in the F * 1 model, this being a storage-augmented primitive model, then the security notion is unachievable. To attack any scheme, a first-stage adversary A 1 picks (m 0 , m 1 , r) uniformly, and queries St(0, (m 0 , m 1 , r)). The second-stage adversary A 2 queries St(0, ⊥) to retrieve (m 0 , m 1 , r), encrypts both messages under r, compares the results with the challenge ciphertext, and outputs the appropriate bit. This adversary wins with probability one.</p><p>In the full version, we give analogous results for nonmalleability of hash functions <ref type="bibr" target="#b11">[11]</ref>, password-based authenticated key exchange <ref type="bibr" target="#b6">[6]</ref>, and others. Interestingly, the hash function nonmalleability notion is the only formal notion that captures resistance to length-extension attacks. This is especially troubling because provable resistance to length extension attacks was a primary motivation for building indifferentiable hash constructions <ref type="bibr" target="#b16">[15]</ref>.</p><p>Discussion. The negative results presented in this section rely on augmenting primitives to incorporate a storage procedure. Of course in the context of hash function design, no one would consider using such a primitive (nor would there necessarily be any way to instantiate one!). Rather these results are used to show that indifferentiability cannot imply security in the context of the multi-stage games considered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Indifferentiability with Simulator Resets</head><p>We initiate the exploration of strengthenings of indifferentiability that support composition for multi-stage games. The counter-example of Section 4 indicates that typical indifferentiable hash constructions cannot enjoy such a notion. Indeed, no online computable hash function can meet a strengthening whose associated composition theorem covers the CRP game. Nevertheless, we may hope to design new hash functions that do meet stronger notions.</p><p>We propose a strengthening of indifferentiability, called reset indifferentiability, that immediately admits a composition theorem covering multi-stage games.</p><p>Reset indifferentiability. We define a version of indifferentiability that requires simulators function even under resets. For any simulator S we define the procedure pair S = ( S.S, S.Rst). The former procedure is simply a renaming of S. The latter procedure that takes no input and when run reinitializes all of S.S's internal variables to their initial values. Likewise, let F = (F.hon, F.adv) be any functionality. Let functionality -→ F = ( -→ F .hon, -→ F .adv) = (F.hon, (F.adv, nop)) where the procedure pair -→ F .adv = (F.adv, nop) includes a procedure nop that takes no input and does nothing. Let F 1 and F 2 be functionalities. Let D be an adversary that outputs a bit (the distinguisher). Let S be a simulator. Then we define the reset indifferentiability advantage of D as</p><formula xml:id="formula_14">Adv reset-indiff F1,F2,S (D) = Pr Real - → F 1 ,D ⇒ y -Pr Ideal F2,D S ⇒ y .</formula><p>For consistency with our definition of the games Real and Ideal (Figure <ref type="figure" target="#fig_1">2</ref>), we implicitly assume there is some distinguished symbol that, when received as input by the procedure Prim, causes the execution of nop or S.Rst, respectively.</p><p>We have the following composition theorem. Pr G F1,A1,...,Am ⇒ y ≤ Pr G F2,B1,...,Bm ⇒ y + Adv reset-indiff F1,F2,S (D) .</p><formula xml:id="formula_15">Moreover: t Bi ≤ t Ai + q Ai t S , q Bi ≤ q Ai • q S , t D ≤ m + t G + m i=1 q G,i • t Ai , and q D ≤ q G,0 + m i=1 q G,i •q Ai ,</formula><p>where t A , t B , t D are the maximum running times of A, B, D; q A , q B are the maximum number of queries made by A and B in a single execution; and q G,0 , q G,i are the maximum number of queries made by G to the honest interface and the i th adversarial procedure (respectively).</p><p>The proof of the above is readily established by adapting the proof of Theorem 1. For 1 ≤ i ≤ m, let B F2.adv i = A S F 2 .adv i . This means in particular that a separate instance of S is used in each procedure B i . Then define the distinguisher D, for any compatible functionality F = (F.hon, F.adv), by modifying D F.hon,F.adv = G F,A1,...,Am so that a reset call immediately precedes each A i call.</p><p>Reset indifferentiability can be achieved when one establishes (conventional) indifferentiability using a stateless and deterministic simulator. This is because it is clear resetting such a simulator does not affect its subsequent behavior. Unfortunately it seems challenging to achieve reset indifferentiability for all but trivial constructions, and we will show negative results for efficient constructions below. We leave finding non-trivial constructions, even inefficient ones, as an open question.</p><p>On practical domain extension under resets. As mentioned above, online computable hash functions cannot be reset indifferentiable. This is because the composition theorem would then imply such a hash function met the CRP property and the results of Section 4 rule this out. But some efficient hash constructions do meet the CRP property, and so the question remains if any efficient construction meets reset indifferentiability. We answer this question in the negative, ruling out a large class of "efficient" constructions from being reset indifferentiable from a RO.</p><p>Fix some p, n, s, r &gt; 0 such that p &gt; n and let N = p + s. Let P be an arbitrary ideal primitive. We restrict our attention to domain-extension constructions H f : {0, 1} N → {0, 1} r that can be written as</p><formula xml:id="formula_16">H P ( M 1 , M 2 ) = H P 2 (H P 1 (M 1 ) M 2 ) for any (M 1 , M 2 ) ∈ {0, 1} p × {0, 1} s .</formula><p>Here M 1 , M 2 represents a unique encoding of M 1 , M 2 into an N -bit string; H 1 : {0, 1} p → {0, 1} n ; and H 2 : {0, 1} n × {0, 1} s → {0, 1} r . Importantly, that p &gt; n means that H 1 is compressing. We require that the time to compute one each of the encoding, H 1 , and H 2 is within a small, absolute constant of the time to compute H P .</p><p>As concrete examples, all online computable functions are trivially included by setting M 1 , M 2 = M 1 M 2 . But the flexibility endowed by the arbitrary encoding also means we encompass a wider range of H that do not allow online computing. For example, any single pass hash function that can be written in the form above. On the other hand, constructions such as the zipper hash <ref type="bibr" target="#b28">[25]</ref> (which makes two passes over a message) are not considered.</p><p>The following theorem below shows that no construction fitting the form above is reset indifferentiable, no matter what underlying primitive P is used. Its proof appears in the full version. Theorem 5. Let integers p, n, s, r, N , functionality P , and construction H P be as just described. Let functionality RO implement a random oracle with range {0, 1} r . There exists a reset-indifferentiability adversary D such that for all simulators S asking at most q queries,</p><formula xml:id="formula_17">Adv reset-indiff IP,RO,S (D) ≥ 1 - q 2 s + q 2 p-n + 1 2 r .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Deterministic, Hedged, and Efficiently-Searchable Encryption</head><p>The results thus far reveal that schemes proven secure in the ROM may not be secure when using practical hash function constructions, when security is measured by a multi-stage game. As seen in Section 5 this includes numerous important cryptographic tasks. As a first step, we here take one example, that of deterministic, hedged, or efficiently-searchable public-key encryption, and provide a proof of security when using any one of a number of indifferentiable hash constructions. We choose this example due to the extensive use of the ROM in prior results and the practical importance of the schemes <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">4,</ref><ref type="bibr" target="#b35">31]</ref>. Of course we cannot rely on Theorem 1, so our proof is done directly in the ideal primitive model. Nevertheless, our main result covers a broad mix of PKE and hash functions.</p><p>We focus on the hash construction from <ref type="bibr" target="#b19">[17]</ref>, which composes a preimageaware function (see below) with a fixed-input-length RO. While we can do analysis without relying on preimage-awareness, doing so simplifies and modularizes our result. Let h f : {0, 1} * → {0, 1} n be a function using some underlying primitive f . Let g : {0, 1} n → {0, 1} n be a function. Let H f,g : {0, 1} * → {0, 1} n be defined by H f,g (M ) = g(h f (M )). We point out that many hash functions fall into this form, including the so-called NMAC construction <ref type="bibr" target="#b16">[15]</ref>, MCM <ref type="bibr" target="#b34">[30]</ref>, NIRP <ref type="bibr" target="#b27">[24]</ref>, and various SHA-3 competitors. CDA security. In Figure <ref type="figure" target="#fig_2">4</ref> we detail the security game for (non-adaptive) chosen-distribution attacks <ref type="bibr" target="#b4">[4]</ref>. This notion, orthogonal to the traditional notion of IND-CPA, captures the security of a PKE scheme when the randomness r used may not be a (sufficiently long) string of uniform bits. For the remainder of this section, fix a randomness length ρ ≥ 0 and a message length ω &gt; 0. An (μ, ν)-mmr-source M is a randomized algorithm that outputs a triple of vectors (m 0 , m </p><formula xml:id="formula_18">main CDA F,A 1 ,A 2 AE b ←$ {0, 1} (pk, sk) ←$ K (m0, m1, r) ←$ A F.adv 1 c ← E F.hon (pk, m b ; r) b ←$ A F.adv 2 (pk, c) Ret (b = b ) main IND-SIM F,A AE,S b ←$ {0, 1} (pk, sk) ←$ K b ← A RoS,F.adv (pk) Ret (b = b ) proc. RoS(m, r): If b = 1 then Ret E F.hon (pk, m ; r) Ret S F.hon (pk, |m|) main PrA F,A H,X x ←$ A Prim,Ext z ← H F.hon (x) Ret (x = V[z] ∧ Q[z] = 1) proc. Prim(m): c ← F.adv(m) α ← α (m, c) Ret c proc. Ext(z): Q[z] ← 1 V[z] ← X (z, α) Ret V[z]</formula><formula xml:id="formula_19">[i], r[i]) = (m , r ) | (m 0 , m 1 , r) ←$ M ] ≤ 2 -µ</formula><p>for all b ∈ {0, 1}, all 1 ≤ i ≤ ν, and all (m , r ).</p><p>A CDA adversary A 1 , A 2 is a pair of procedures, the first of which is a (μ, ν)mmr-source. The CDA advantage for an CDA adversary A 1 , A 2 against scheme AE is defined by</p><formula xml:id="formula_20">Adv cda AE,F (A 1 , A 2 ) = 2• Pr CDA F,A1,A2 AE ⇒ true -1 .</formula><p>Preimage awareness. Dodis, Ristenpart, and Shrimpton's preimage awareness notion <ref type="bibr" target="#b19">[17]</ref> generalizes collision resistance to include extractability. Game PrA is defined in Figure <ref type="figure" target="#fig_2">4</ref>. We associate to any functionality F , hash construction H, extractor X , and adversary A the PrA advantage defined by Adv pra H,F,X (A) = Pr PrA F,A H,X ⇒ true .</p><p>We point out that the game PrA does not abide by our convention that only the adversary queries F.adv. Thus Theorems 1 and 4 do not apply when G = PrA. This is not a problem for past results or for our results below, both of which do not attempt to conclude PrA via indifferentiability-based composition.</p><p>IND-SIM security. We define a new notion of encryption scheme security that is of technical interest because it is as an intermediate step in proving Theorem 6, shown below. An encryption simulator for a scheme AE = (K, E, D) is a procedure S that takes as input a public key and a message length and outputs a ciphertext. Game IND-SIM AE ,S is shown in Figure <ref type="figure" target="#fig_2">4</ref>. A IND-SIM adversary A can make multiple queries, but cannot repeat any queries. It measures the ability of an adversary to distinguish between encryptions of a chosen message under chosen randomness and the output of a simulator S. We define the IND-SIM advantage of an adversary A by Adv ind-sim AE,S (A) = 2• Pr IND-SIM A AE,S ⇒ true -1 . Note that the adversary can choose the message and also the randomness used to encrypt it. In the standard model this security goal is unachievable if E uses no further randomness beyond that input. However, we will use IND-SIM security in the ROM when the adversary does not make any RO queries. In the full version we show that for a variety of encryption schemes, IND-SIM security in the ROM against adversaries who do not query the RO is implied by IND-CPA security of an underlying (randomized) scheme.</p><p>CDA security for PKE. Theorem 6 below establishes CDA security of PKE schemes that, during encryption, apply g(h f (M )) once to hash an M including an encoding of the public key, as long as the scheme meets the IND-SIM notion above (in the ROM). The ROM schemes for deterministic, hedged, or efficientlysearchable encryption from <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">4,</ref><ref type="bibr" target="#b35">31]</ref> are of this form and have IND-SIM implied by the IND-CPA security of an underlying randomized encryption scheme. We make no assumptions about f , so the result applies both to hash functions based on an ideal cipher and ideal compression function.</p><p>We provide some brief intuition regarding the proof. The PrA security of f + means that, to learn anything about the value g(f + (M )), the adversary must query f in order to compute f + (M ). But the inclusion of the public key in the message hashed by E means that the source A 1 is unlikely to be able to query any of the messages used in computing the challenge ciphertexts. Essentially this means that E gets randomness via queries to g(f + (M )) that is hidden from the adversary, and this allows one to use the IND-SIM property of AE to show that ciphertexts leak no information about the challenge message, randomness pairs. This means that A 2 learns nothing about the coins used by A 1 , and so the min-entropy of A 1 implies that A 2 has little chance of learning g(f + (M )) outputs for M 's used in computing the challenges. The full proof appears in the full version. Theorem 6. Let f be a functionality and g be a FIL RO. Let H f,g (M ) = g(h f (M )) for some procedure h. Let AE be a PKE scheme that queries H f,g on a single message per E invocation, that message including (an encoding of ) the public key. Let A 1 , A 2 be a CDA adversary making at most q f queries to f and q g queries to g and where A 1 is a (μ, ν)-mmr-source. Then for any encryption simulator S and PrA extractor X there exists an IND-SIM adversary B and a PrA adversary C such that.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Adv cda</head><p>AE,(f,g) (A 1 , A 2 ) ≤ 4•Adv ind-sim AE,RO,S (B)+4•Adv pra h,f,X (C)+ 2νq g 2 µ +2q g •maxpk AE B makes no random oracle queries, makes ν RoS-queries, and runs in time that of (A 1 , A 2 ). C makes at most q f primitive queries and runs in time at most that of (A 1 , A 2 ).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Procedures implementing the functionality of the random oracle model (ROM) (left) and the ideal primitive model (IPM) (right). The number r is set as appropriate for a given context.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>mainFig. 2 .</head><label>2</label><figDesc>Fig. 2. The games that define indifferentiability. Adversary D and functionalities F1, F2 are unspecified. The simulator S is a parameter of the game.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. (Left) The non-adaptive CDA game. (Right) The IND-SIM and PrA games Public-key encryption. Recall that a public-key encryption (PKE) scheme AE = (K, E, D) consists of three algorithms. Key generation K outputs a public key, secret key pair. Encryption E takes a public key, a message m, and randomness r and outputs a ciphertext. Decryption D takes a secret key, a ciphertext, and outputs a plaintext or a distinguished symbol ⊥. Following [3], we define for any scheme AE the maximum public-key collision probability by maxpk AE = max w∈{0,1} * Pr [ pk = w : (pk, sk) ←$ K ].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>1 , r) such that |m 0 | = |m 0 | = |r| = ν, all components of m 0 and m 1 are bit strings of length ω, all components of r are bit strings of length ρ, and (m b [i], r[i]) = (m b [j], r[j]) for all 1 ≤ i &lt; j ≤ ν and all b ∈ {0, 1}. Moreover, the source has min-entropy μ, meaning Pr [ (m b</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Theorem 4 .</head><label>4</label><figDesc>Let G ∈ G. Let F 1 and F 2 be functionalities. Let A 1 , . . . , A m be an adversary and let S F2.adv be a simulator that exports the same interface as F 1 .adv. Then there exist an adversary B 1 , . . . , B m and distinguisher D such that for all values y</figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>Thomas Ristenpart was supported in part by Mihir Bellare's NSF grant CCF-0915675 and by a UCSD Center for Networked Systems grant. Hovav Shacham was supported by the MURI program under AFOSR Grant No. FA9550-08-1-0352 and (while at the Weizmann Institute) by a Koshland Scholars Program postdoctoral fellowship. Thomas Shrimpton was supported by NSF CAREER grant CNS-0845610. We thank Mihir Bellare, Mike Dahlin, Daniele Micciancio, and Moni Naor for helpful discussions about this work.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">On the indifferentiability of the grøstl hash function</title>
		<author>
			<persName><forename type="first">E</forename><surname>Andreeva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mennink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SCN 2010</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Prisco</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6280</biblScope>
			<biblScope unit="page" from="88" to="105" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Provable data possession at untrusted stores</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ateniese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Burns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Curtmola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Herring</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Kissner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Peterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CCS 2007</title>
		<editor>
			<persName><forename type="first">De Capitani Di</forename><surname>Vimercati</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Syverson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename></persName>
		</editor>
		<meeting>CCS 2007<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2007-10">October 2007</date>
			<biblScope unit="page" from="598" to="609" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Deterministic and efficiently searchable encryption</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Boldyreva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>O'neill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2007</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Menezes</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4622</biblScope>
			<biblScope unit="page" from="535" to="552" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Hedged public-key encryption: How to protect against bad randomness</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Brakerski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ristenpart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Segev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yilek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2009</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Matsui</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5912</biblScope>
			<biblScope unit="page" from="232" to="249" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Deterministic encryption: Definitional equivalences and constructions without random oracles</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fischlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>O'neill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ristenpart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2008</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5157</biblScope>
			<biblScope unit="page" from="360" to="378" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Authenticated key exchange secure against dictionary attacks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pointcheval</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2000</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1807</biblScope>
			<biblScope unit="page" from="139" to="155" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Multi-property-preserving hash domain extension and the EMD transform</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ristenpart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2006</title>
		<editor>
			<persName><forename type="first">X</forename><surname>Lai</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Chen</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4284</biblScope>
			<biblScope unit="page" from="299" to="314" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Random oracles are practical: A paradigm for designing efficient protocols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS 1993</title>
		<editor>
			<persName><forename type="first">V</forename><surname>Ashby</surname></persName>
		</editor>
		<meeting><address><addrLine>Fairfax, Virginia, USA; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1993-05">November 3-5. 1993</date>
			<biblScope unit="page" from="62" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The security of triple encryption and a framework for code-based game-playing proofs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2006</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Vaudenay</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4004</biblScope>
			<biblScope unit="page" from="409" to="426" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">On the indifferentiability of the sponge construction</title>
		<author>
			<persName><forename type="first">G</forename><surname>Bertoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Daemen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Peeters</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Van Assche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2008</title>
		<editor>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Smart</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">4965</biblScope>
			<biblScope unit="page" from="181" to="197" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Foundations of non-malleable hash and one-way functions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Boldyreva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Cash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fischlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Warinschi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2009</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Matsui</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5912</biblScope>
			<biblScope unit="page" from="524" to="541" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On notions of security for deterministic encryption, and efficient constructions without random oracles</title>
		<author>
			<persName><forename type="first">A</forename><surname>Boldyreva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Fehr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>O'neill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2008</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5157</biblScope>
			<biblScope unit="page" from="335" to="359" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Universally composable security: A new paradigm for cryptographic protocols</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">42nd FOCS</title>
		<meeting><address><addrLine>Las Vegas, Nevada, USA; Los Alamitos</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2001">October 14-17. 2001</date>
			<biblScope unit="page" from="136" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Improved indifferentiability security analysis of chopMD hash function</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Nandi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 2008</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Nyberg</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">5086</biblScope>
			<biblScope unit="page" from="429" to="443" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Merkle-damgård revisited: How to construct a hash function</title>
		<author>
			<persName><forename type="first">J.-S</forename><surname>Coron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Malinaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Puniya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2005</title>
		<editor>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3621</biblScope>
			<biblScope unit="page" from="430" to="448" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Indifferentiability of permutationbased compression functions and tree-based modes of operation, with applications to MD6</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Reyzin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 2009</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Dunkelman</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">5665</biblScope>
			<biblScope unit="page" from="104" to="121" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Salvaging merkle-damgård for practical applications</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ristenpart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Shrimpton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2009</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Joux</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">5479</biblScope>
			<biblScope unit="page" from="371" to="388" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">An Extension to HTTP: Digest Access Authentication</title>
		<author>
			<persName><forename type="first">J</forename><surname>Franks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hallam-Baker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hostetler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Leach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Luotonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Sink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Stewart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RFC</title>
		<imprint>
			<biblScope unit="volume">2069</biblScope>
			<date type="published" when="1997-01">January 1997</date>
			<publisher>Proposed Standard</publisher>
		</imprint>
	</monogr>
	<note>Obsoleted by RFC 2617</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Probabilistic encryption</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="270" to="299" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A digital signature scheme secure against adaptive chosen-message attacks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="281" to="308" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A simple variant of the merkle-damgård scheme with a permutation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hirose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2007</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Kurosawa</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4833</biblScope>
			<biblScope unit="page" from="113" to="129" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">PORs: Proofs of retrievability for large files</title>
		<author>
			<persName><forename type="first">A</forename><surname>Juels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kaliski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CCS 2007</title>
		<editor>
			<persName><forename type="first">De Capitani Di</forename><surname>Vimercati</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Syverson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename></persName>
		</editor>
		<meeting>CCS 2007<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2007-10">October 2007</date>
			<biblScope unit="page" from="584" to="597" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">SafeStore: A durable and practical storage system</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kotla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Alvisi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dahlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of USENIX Technical</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Chase</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Seshan</surname></persName>
		</editor>
		<meeting>USENIX Technical</meeting>
		<imprint>
			<date type="published" when="2007-06">2007. June 2007</date>
			<biblScope unit="page" from="129" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A Modular Design for Hash Functions: Towards Making the Mix-Compress-Mix Approach Practical</title>
		<author>
			<persName><forename type="first">A</forename><surname>Lehmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tessaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2009</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Matsui</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5912</biblScope>
			<biblScope unit="page" from="364" to="381" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Constructing an ideal hash function from weak ideal compression functions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Liskov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAC 2006</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Biham</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Youssef</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4356</biblScope>
			<biblScope unit="page" from="358" to="375" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Indistinguishability of random systems</title>
		<author>
			<persName><forename type="first">U</forename><forename type="middle">M</forename><surname>Maurer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2002</title>
		<editor>
			<persName><forename type="first">L</forename><forename type="middle">R</forename><surname>Knudsen</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2332</biblScope>
			<biblScope unit="page" from="110" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Indifferentiability, impossibility results on reductions, and applications to the random oracle methodology</title>
		<author>
			<persName><forename type="first">U</forename><forename type="middle">M</forename><surname>Maurer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Renner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Holenstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2004</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">2951</biblScope>
			<biblScope unit="page" from="21" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Public-key cryptosystems provably secure against chosen ciphertext attacks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">22nd ACM STOC</title>
		<meeting><address><addrLine>Baltimore, Maryland, USA; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1990">May 14-16. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Careful with composition: Limitations of the indifferentiability framework</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ristenpart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Shrimpton</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Full version of this paper</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">How to build a hash function from any collisionresistant function</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ristenpart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Shrimpton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2007</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Kurosawa</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4833</biblScope>
			<biblScope unit="page" from="147" to="163" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">When good randomness goes bad: Virtual machine reset vulnerabilities and hedging deployed cryptography</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ristenpart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yilek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Network and Distributed Systems Security -NDSS 2010</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Message authentication with one-way hash functions</title>
		<author>
			<persName><forename type="first">G</forename><surname>Tsudik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE INFOCOM 1992</title>
		<meeting>IEEE INFOCOM 1992<address><addrLine>Los Alamitos</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="2055" to="2059" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Design and analysis of password-based key derivation functions</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">F</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">L</forename><surname>Yin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CT-RSA 2005</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Menezes</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3376</biblScope>
			<biblScope unit="page" from="245" to="261" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
