<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">On the Limits of Information Flow Techniques for Malware Analysis and Containment</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Lorenzo</forename><surname>Cavallaro</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Dipartimento di Informatica e Comunicazione</orgName>
								<orgName type="institution">Universit√† degli Studi di Milano</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Prateek</forename><surname>Saxena</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of California at Berkeley</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">R</forename><surname>Sekar</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">Stony Brook University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">On the Limits of Information Flow Techniques for Malware Analysis and Containment</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">FC7A13D8C74CF2C7DB3F2D2B1E0B212D</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:38+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Taint-tracking is emerging as a general technique in software security to complement virtualization and static analysis. It has been applied for accurate detection of a wide range of attacks on benign software, as well as in malware defense. Although it is quite robust for tackling the former problem, application of taint analysis to untrusted (and potentially malicious) software is riddled with several difficulties that lead to gaping holes in defense. These holes arise not only due to the limitations of information flow analysis techniques, but also the nature of today's software architectures and distribution models. This paper highlights these problems using an array of simple but powerful evasion techniques that can easily defeat taint-tracking defenses. Given today's binary-based software distribution and deployment models, our results suggest that information flow techniques will be of limited use against future malware that has been designed with the intent of evading these defenses.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Information flow analysis has long been recognized as an important technique for defending against attacks on confidentiality as well as integrity <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b7">8]</ref>. Over the past quarter century, information flow research has been concentrated on static analysis techniques, since they can detect covert channels (e.g., so-called implicit information flows) missed by runtime monitoring techniques.</p><p>Static analyses for information-flow have been developed in the context of high-level, type-safe languages, so they cannot be directly applied to the vast majority of COTS software that is available only in binary form. Worse, software obfuscation and encryption techniques commonly employed in malware (as well as some benign software for intellectual property protection) render any kind of static analysis very difficult, if not outright impossible. Even in the absence of obfuscation, binaries are notoriously hard to analyze: even the basic step of accurate disassembly does not have solutions that are robust enough to work on large x86 binaries. As a result, production-grade tools that operate on binaries rely on dynamic (rather than static) analyis and instrumentation <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b25">26]</ref>.</p><p>Following this observations, several researchers have recently developed dynamic information-flow techniques for COTS binaries <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b35">36]</ref>. These techniques, along with source-to-source based transformation approaches, have enabled accurate detection of a wide range of attacks on trusted software <ref type="foot" target="#foot_0">1</ref> including those based on memory corruption <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b35">36]</ref>, format-string bugs, command or SQL injection <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b42">43]</ref>, cross-site scripting <ref type="bibr" target="#b39">[40]</ref>, and so on. More recently, researchers have reported significant successes in applying dynamic information flow techniques on existing malware, both from the perspective of understanding their behavior <ref type="bibr" target="#b0">[1]</ref>, and detecting runtime violation of policies <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b33">34]</ref>. Although dynamic taint analysis technique is quite robust for protecting trusted software, its application to untrusted (and potentially malicious) software is subject to a slew of evasion techniques that significantly limit its utility. We point out that understanding the limitations of defensive techniques is not just an academic exercise, but a problem with important practical consequences: emerging malware does not just employ variants of its payloads by using metamorphic/polymorphic techniques, but instead has begun to embed complex evasion techniques to detect monitoring environments as a means to protect its "intellectual property" from being discovered. For instance, W32/MyDoom <ref type="bibr" target="#b18">[19]</ref> and W32/Ratos <ref type="bibr" target="#b37">[38]</ref> adopt self-checking and code execution timing techniques to determine whether they are under analysis or not. Likewise, self-modifying techniques -among others -are used as well (W32/HIV <ref type="bibr" target="#b17">[18]</ref>) to make malware debugging sessions harder <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b38">39]</ref>. Thus, a necessary first step for developing resilient defenses is that of understanding the weaknesses and limitations of existing defenses. This is the motivation of our work. We have organized our discussion into three major sections as follows, depending on the context in which information flow is being used.</p><p>Stand-alone malware. When applied to malware, a natural question is whether the covert channels that were ignored by dynamic techniques could be exploited by adaptive malware to thwart information-flow based defenses. These covert channels were ignored in the context of trusted software since their "capacity" was deemed too small to pose a significant threat. More importantly, attackers do not have any control over the code of trusted software, and hence cannot influence the presence or capacity of these channels. In contrast, malware writers can deliberately embed covert channels since they have complete control over malware code. In this paper, we first show that it is indeed very easy for malware writers to insert such covert channels into their software. These evasion techniques are simple enough that they can be incorporated manually, or using simple, automated program transformation techniques. We show that it is very difficult to defeat these evasion techniques, unless very conservative reasoning is employed, e.g., assuming that any information read by a program could leak to any of its outputs. Unfortunately, such weak assumptions can greatly limit the purposes to which dynamic information flow analysis can be used. For instance, Stinson et al. <ref type="bibr" target="#b33">[34]</ref> use information flow analysis to detect "remote-control" behavior of bots, which is identified when arguments to security-critical system calls are tainted. If a conservative notion of tainting is used, then all programs that communicate over the network would have to be flagged as "bots," which would defeat the purpose of that analysis.</p><p>Malware plug-ins. Next, we consider recent evolution in software deployment models that has favored the use of plug-in based architechtures. Browser helper objects (BHOs), which constitute one of the most common forms of malware in existence today, belong to this category. Other examples include document viewer plug-ins, media codecs, and so on. We describe several novel attacks that are possible in the context of plug-ins: -Attacks on integrity of taint information. Malware can achieve its goal indirectly by modifying the variables used by its host application, e.g., modifying a file name variable in the host application so that it points to a file that it wants to overwrite. Alternatively, it may be able to bypass instrumentation code inserted for taint-tracking by corrupting program control-flow. -Attacks based on violating application binary interface, whereby malware violates assumptions such as those involving stack layout and register usage between callers and callees. -Race-condition attacks on taint metadata. Finally, we describe attacks where malware races with benign host application to write security-sensitive data. In a successful attack, malware is able to control the value of this data, while the taint status of the data reflects the write operation of benign code. While conservative notions of tainting could potentially be used to thwart these attacks <ref type="bibr" target="#b32">[33]</ref>, this would restrict the applicability of information-flow techniques even more.</p><p>Analyzing future behavior of malware. Today's malware is often packaged with software that seems to provide legitimate functionality, with malicious behavior exposed only under certain "trigger conditions", e.g., when a command is received from a remote site controlled by an attacker. Moreover, malware may incorporate anti-analysis features so that malicious paths are avoided when executed within an analysis environment. To uncover such malicious behavior, it is necessary to develop techniques that can reason about program paths that are not exercised during monitoring. While one may attempt to force execution of all program paths, such an approach is likely to be very expensive, and more likely to suffer from semantic inconsistencies that may arise due to forcing execution down branches that are not taken during execution. A more selective approach has been proposed by Moser et al. <ref type="bibr" target="#b0">[1]</ref> that explores paths guarded by tainted data, rather than all paths. This technique has been quite successful in the context of existing malware. The heart of this approach is a technique that uses a decision procedure to discover memory locations that could become tainted as a result of program execution, and explores branches that are guarded by such data. In Section 4, we show that these trigger discovery mechanisms (and more generally, the technique for discovering which data items can become tainted) can be easily evaded by purposefully embedding memory errors in malicious code.</p><p>Paper organization. Sections 2 through 4 describe our evasion techniques, organized along the lines described above. Where possible, mitigation of these evasions and their implications on information flow analyses are discussed as well. A summary of related work is provided in Section 5, followed by concluding remarks in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Stand-Alone Untrusted Applications</head><p>For the sake of concreteness, we discuss the impact of evasion attacks, as well as mitigation measures, in the context of the "remote control" behavior detection technique presented by Stinson et al. <ref type="bibr" target="#b33">[34]</ref>, although the evasion techniques themselves are applicable against other defenses as well, e.g., dynamic spyware detection <ref type="bibr" target="#b12">[13]</ref>.</p><p>Stinson et al. observed that bots receive commands from a central site ("bot-herder") and carry them out. This typically manifests a flow of information from an input operation (e.g., a read system call) to an output operation (e.g., the file named in an open system call). Their implementation relied on content-based tainting: i.e., taint was assumed between x and y if their values matched (identical or had large common substrings) or if their storage locations overlapped. As noted by the paper authors, content-based tainting is particularly vulnerable: it can easily be evaded using simple encoding/decoding operations, e.g., by XOR'ing the data with a mask value before its use. However, the authors suggest that a more traditional implementation of runtime information flow tracking <ref type="bibr" target="#b14">[15]</ref> would provide "thorough coverage" and hence render attacks much harder. Below, we describe simple evasion measures that allow malware to "drive a truck" through the gaps in most dynamic taint-tracking techniques, and proceed to discuss possible mitigation mechanisms and their implications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Evasion Using Control Dependence and Implicit Flows</head><p>Dynamic information flow techniques that operate on trusted software tend to focus on explicit flows that take place via assignments. It is well known that information can flow from a variable y to another variable x without any explicit assignments. Indeed, a number of covert channels for information flow have been identified by previous research in this area. We demonstrate the ease of constructing evasion attacks using these covert channels. We focus on two forms of non-explicit flow, namely, control dependences and implicit flows.</p><p>Control dependence arises when a variable is assigned within an if-then-else statement whose condition involves a sensitive (tainted<ref type="foot" target="#foot_1">2</ref> ) variable, e.g., if (y = 1) then x := 1; else x := 0; endif Clearly, the value of x is dependent on y, even though there is no assignment of the latter to the former. In particular, the above code snippet enables copying of a single bit from y to x without using direct assignments between them. Using an n-way branch (e.g., a switch statement with n cases) will allow copying of log n bits. A malware writer can propagate an arbitrarily large amount of information without using explicit flows by simply enclosing the above code snippet within a loop.</p><p>Implicit flows arise by virtue of semantic relationships that exist between the values of variables in a program. As an example, consider the following code snippet that allows copying of one bit of data from a sensitive variable y to w without using explicit flows or control dependences:</p><p>1. x := 0; z := 0; 2. if (y = 1) then x := 1; else z := 1; endif 3. if (x = 0) then w := 0; endif 4. if (z = 0) then w := 1; endif At line 2, if y = 1 then x is marked sensitive because of control-dependent assignment in the then-clause. Since there is no assignment to z in the then-clause of line 2, it is not marked sensitive. Moreover, the condition at line 3 will not hold because x was assigned a value of 1 at line 2. But the condition at line 4 holds, so w is assigned the value of 1, but it is not marked sensitive since z is not sensitive at this point. Now, consider the case when y = 0. Following a similar line of reasoning, it can be seen that w will be assigned the value 0 at line 3, but it will not be marked sensitive. Thus, in both cases, w gets the same value as y, but it is not marked as sensitive.</p><p>As with control dependences, a malware writer can copy an arbitrarily large number of bits using nothing but implicit flow by simply using a slightly more sophisticated example of the above code. It is thus trivial for a malware writer to evade taint-tracking techniques that track only direct data dependencies and control dependencies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Difficulty of Mitigating Evasion Attacks</head><p>To thwart control-dependence-based evasion, a taint-tracking technique can be enhanced to track control dependences. This is easy to do, even in binaries, by associating a taint label with the program counter (PC) <ref type="bibr" target="#b12">[13]</ref> <ref type="foot" target="#foot_2">3</ref> . Unfortunately, this will lead to an increase in false positives, i.e., many benign programs will be flagged as exhibiting remote-control behavior. To illustrate this, consider the following code snippet that might be included in a program that periodically downloads data from the network, and saves it in different files based on the format of the data. Such code may be used in programs such as weather or stock ticker applets:</p><p>Note that there is a control dependence between data read over the network and the file name opened, so a technique that flags bots (or other malware) based on such dependence would report a false alarm. More generally, input validation checks can often raise false positives, as in the following example.</p><p>int n = read(network, y, sizeof(y)); if (sanity check(y)) { fp = fopen("data", "w"); ... } else { ... // report error } In the context of benign software, false positives due to control dependence tracking can be managed using developer annotations (so-called endorsement or declassification annotations). We obviously cannot rely on developer annotations in untrusted software; it is also impractical for code consumers, even if they are knowledgeable programmers or system administrators, to understand and annotate untrusted code, especially when it is distributed in the form of binaries.</p><p>Mitigating implicit-flow based evasion is even harder. It has been shown that purely dynamic techniques cannot detect implicit flows <ref type="bibr" target="#b41">[42]</ref>. This is because, as illustrated by the implicit flow example above, it is necessary to reason about assignments that take place on unexecuted program branches. On binaries, this amounts to identify the memory locations that may be updated on program branches that are not taken. Several features of untrusted COTS binaries combine to make this problem intractable:</p><p>-Address arithmetic involving values that are difficult to compute statically -Indirect data references and indirect calls -Lack of information about types of objects -Absence of size information for stack-allocated and static objects (i.e., variables) -Possibility that malicious code may violate low-level conventions and requirements regarding the use of stack, registers, control-flow, etc.</p><p>As a result, it is unlikely that implicit flows can be accurately tracked for the vast majority of today's untrusted software that gets distributed as x86 binaries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Implications</head><p>Evasion measures described above can be mitigated by treating (a) all data written by untrusted code as tainted (i.e., not trustworthy), and (b) all data written by untrusted code as sensitive if any of the data it has read is sensitive. For stand-alone applications, these assumptions mean that all data output by an untrusted process is tainted, and moreover, is sensitive if the process input any sensitive data. In other words, this choice means that fine-grained taint-tracking (or information flow analysis) is not providing any benefit over a coarse-grained, conservative technique that operates at the granularity of processes, and does not track any of the internal actions of a process.</p><p>In the context of detecting remote-control behavior, we observe that in the absence of evasion measures, the use of dynamic information flow techniques enables us to distinguish between malicious behavior, which involves the use of security-critical system call arguments that directly depend on untrusted data, and benign behavior. The use of evasion techniques can easily fool taint-tracking techniques that only reason about explicit flows. If the technique is enhanced to reason about control dependences, evasion resistance is improved, but as illustrated by the examples above, many more false positives are bound to be reported, thus significantly diminishing the ability of the technique to distinguish between malicious and benign behaviors. If we further enhance evasion resistance to address all implicit flows, we will have to treat all data used by an untrusted application to be tainted, thereby completely losing the ability to distinguish between benign and malicious behavior.</p><p>In summary, the emergence of practical dynamic taint-tracking techniques for binaries enabled high-precision exploit detection on trusted code. This was possible because the presence of explicit information flow from untrusted source to a security-critical sink indicated the ability of an attacker to exert a high degree of control over operations that have a high risk of compromising the target application -a level of control that was unlikely to be intended by the application developer. It seemed that a similar logic could be applied to untrusted code, i.e., a clear distinction could be made between acceptable uses of tainted data that are likely to be found in benign applications from malicious uses found in malware. The discussion so far shows that this selectivity is lost once malware writers adapt to evade information flow techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Analyzing Runtime Behavior of Shared-Memory Extensions</head><p>A significant fraction of today's malware is packaged as an extension to large softwares such as client-side web applications or the operating system. Applications such as web browsers and email clients are attractive targets for malware authors, because of the ubiquitous use of these applications in online financial transactions and private information exchange.</p><p>Nearly all large web browsers have software extension mechanisms that that allow adding various forms of additional functionality, such as better GUI services, automatic form filling, and viewing various forms of multimedia content. We refer to such browser extensions as browser helper objects (BHOs) <ref type="foot" target="#foot_3">4</ref> . Perhaps surprisingly, almost all browsers today have extensibility mechanisms that allow extension packages to be shipped with third-party libraries in binary form. Due to the growing user trends towards installing off-the-shelf extensions and due to increasing drive-by-downloads, malware spread in form of BHOs has been rampant.</p><p>Recent works <ref type="bibr" target="#b12">[13]</ref> have proposed using information flow to track the flow of confidential data such as cookies, passwords and credentials in form-data as it gets processed by web browser. The idea is to monitor the actions of malware masquerading as benign BHOs, which is loaded in the address space of the browser, and to detect if confidential data is leaked by the BHOs. The crux of the problem is to selectively identify malware's actions. Essentially, their technique uses an attribution mechanism to classify actions that access system resources, to trusted and untrusted contexts. System calls or operations made directly by the BHO or by a host browser function called on its behalf, are attributed to the untrusted context, while those by the host browser itself belong to the trusted context. In the untrusted context, any sensitive data processed is flagged "suspicious." The presence of this data at output operations that perform writes to networks/files signals the leakage of confidential data effected by the BHO. Although these methods are successful in analysis and detection of current malware, they are not carefully designed to detect adaptive malware that employs evasion techniques against the specific mechanisms proposed in these defenses. Below, we present several such evasion attacks. We remind our readers that the techniques presented in the previous section continue to be available to malware that operates within the address space of a (benign) host application. In this section, our focus is on additional evasion techniques that become possible due to this shared address space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Attacks Using Arbitrary Memory Corruption</head><p>Corruption of untainted/insensitive data to effect leakage. By corrupting the memory used by the host application, a malicious BHO can induce the host application to carry out its tasks outside the untrusted context. For instance, a privacy-breaching malware does not necessarily need to read the confidential data itself and pass/copy it to external network interfaces. Instead, it could corrupt the data used by the browser (i.e., the host application) such that the browser unknowingly leaks this information. We present the basic idea for an attack that avoids direct manipulation of any sensitive data or sensitive pointers. Instead, it corrupts higher level untainted pointers that point to the sensitive data. Consider a pointer variable p in the browser code that refers to data items to be transmitted over the network. A malware can corrupt p to point to sensitive data (say s) of its choice, stored within the browser memory. This way a malicious BHO can arrange for s to be transmitted over the network, without being detected by techniques described in <ref type="bibr" target="#b12">[13]</ref>. Similarly, a BHO may corrupt a file descriptor as well, so that any write operation using this file pointer will result in the transmission of sensitive data over the network. Vulnerable pointers and data buffers needed for these attacks are rife in large systems. Moreover, they are easily forgeable because of the high degree of address space sharing between the host browser and extensions.</p><p>Optimistic assumptions about data originating from untrusted code. Another basic idea for attack involves using seemingly harmless data, such as constants, which are treated as untainted by most techniques <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b44">45]</ref> for corruption of browser data structures. Treating constants in untrusted code or any data under the control of the malware as untainted is anyway problematic, and specially so in binary code where constants may be addresses. The attack involves overwriting an untainted pointer p, that may initially point to a sensitive data s, with an untainted value such as constant memory address m. When the browser uses m for a critical operation, such as determining the destination for sending s, this threat becomes very significant as shown below.</p><p>A real attack. We now present an example that illustrates how a BHO can corrupt a data pointer to violate a policy that prevents leakage or tampering of sensitive information, like the user's cookies, by the BHO. The example has been tested on Lynx, a textual browser which does not have a proper plugin framework support <ref type="foot" target="#foot_4">5</ref> . However, it uses libraries to enhance its functionalities and, as they are loaded into Lynx's address space, they can be considered as untrusted components. In fact, the attack's result could be applied to a different browser application (e.g., Internet Explorer, FireFox) with a full-blown plug-in framework.</p><p>The attack consists of modifying the domain name in the cookie, and is illustrated in the figure below. In Lynx, all cached cookies are stored in a linked-list cookie_list (note that cookie_list is not sensitive as only the sequence of bytes containing cookies value is). Subsequently, when the browser has to send a cookie, the domain is compared using host_compare (not shown) which calls stringcasecmp. A plugin can traverse the linked list, and write its intended URL to the domain pointer field in cookie record. On enticing the user to visit a malicious web site, such as evil.com, these cookies would automatically be sent to the attacker web site, thereby subverting the implementation of the Same Origin Policy. The point to note in this example is that the domain pointer will be untainted; the object it points to will be tainted or sensitive. These higher level pointers themselves are not sensitive, therefore they can be corrupted without raising suspicion. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Implications</head><p>The above example shows how confidential data can leak without being read. The approach proposed in <ref type="bibr" target="#b12">[13]</ref> does not deal with this threat. Recall that sensitive data is marked "suspicious"(to use the terminology defined in <ref type="bibr" target="#b12">[13]</ref>), only when the untrusted BHO uses the sensitive data itself or propogates it to the external interfaces. Consequently, the malware can overwrite the domain pointer with an address value (which is untainted) of choice, without causing the suspicious flag to be set.</p><p>To detect the aforementioned evasion attacks, an information flow technique needs to incorporate at least the following two features. First, in order to detect the effect of pointer corruption (of pointers such as those used to point to data buffers), the technique must treat data dereferenced by (trusted) browser code using a tainted pointer as if it is directly accessed by untrusted code. Second, it must recognize corruption of pointers with constant values. Otherwise, the above attack will succeed since it overwrites a pointer variable with a constant value that corresponds to the memory location of sensitive data <ref type="foot" target="#foot_5">6</ref> . Considering every write performed by the untrusted BHO to be tainted, as suggested previously (therefore, considering everything written by the untrusted BHO as "suspicious"), may be a too conservative a strategy. It may yield high false positives in the cases where plugins access sensitive data but do not leak it. Though, applying conservative tainting specifically to recognize control data as done in <ref type="bibr" target="#b43">[44]</ref> seems reasonable, this may raise significant false positives when applied for identifying all data that is possibly controlled by the plugin.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Attacking Mechanisms Used to Determine Execution Context</head><p>In a shared memory setting, it is necessary to distinguish the execution of untrusted extension code from that of trusted host application code. To make this distinction, the detection approach needs to keep track of a code execution context. The logic used for maintaining this context is an obvious target for evasion attacks: if this logic can be confused, untrusted code could execute with the privileges of trusted code. A more subtle attack involves data exchanged between the two contexts. Since execution in trusted context affords more privileges, untrusted code could achieve its objectives indirectly by corrupting data (e.g., contents of registers and the stack) that is communicated from untrusted execution context to the trusted context.</p><p>Although the targets of evasion attack described above are generally independent of implementation details, the specifics of evasion attacks will need to rely on these details. Below, we describe how such evasion attacks can work in the specific context of <ref type="bibr" target="#b12">[13]</ref>.</p><p>Attacking context-switch logic. The approach proposed <ref type="bibr" target="#b12">[13]</ref> for context tracking uses the following algorithm. For each instruction, the system checks whether the instruction belongs to the BHO code region. If so, then it saves the value of the current stack pointer as esp saved , and the instruction is executed in untrusted context. Whenever the instruction pointer points outside the code region of the BHO, the system has to determine whether the instruction is executed on behalf of the BHO (i.e., untrusted context) or not. For this, the proposed technique utilizes the fact that on their platform the stack grows downwards and checks if the current stack pointer,esp current , is below the esp saved . The context identification logic implicitly assumes a benign call stack model -it assumes that the activation records are pushed on the stack, the stack data belonging to the caller is left unchanged by the callee, and that the callee function cleans up its activation leaving the stack pointer restored after its invocation. We point out that these assumptions are reasonable for calls across benign code modules only. Specifically, if the esp current is not less than esp saved , the context switching logic assumes that the last untrusted BHO code stack frame has been popped off the activation stack and the execution context does not belong to the BHO anymore. This attribution mechanism allows valid (benign) context switches (from untrusted to trusted context) at call/return function boundaries, when the last BHO function f is about to return and there are no other browser functions invoked by f .</p><p>Unfortunately, we show that this attribution mechanism is insecure. Malware may employ simple low-level attacks that subvert the control flow integrity of the application at the host-extension interface leading to devastating attacks. The taint analysis approach and the attribution mechanism employed in <ref type="bibr" target="#b12">[13]</ref> point out that the mechanism can deal with two threats that may circumvent context attribution -execution of injected code, and attempts to adjust the stack pointer above the threshold limit by changing the ESP register in its code. However, it does not protect against other low-level integrity violations, such as return-into-lib(c) style <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b34">35]</ref> attacks, which aim to eventually execute already present code.</p><p>To be concrete, consider the scenario where the malicious BHO corrupts control pointers, such as return addresses pushed by the calling host function, to refer to target locations in the browser or its trusted libraries. It could additionally create a compatible stack layout required for a return-into-lib(c) attack to perform intended action and let its last invoked function simply exit. Changing control pointers such as return address above the recorded threshold stack pointer value, without making any modification to ESP itself, is sufficient and touches no sensitive/tainted data. Such returns from untrusted code trigger control transfers to the attacker controlled target functions, and furthermore, with arbitrarily controlled parameters on the crafted stack layout. As no other BHO instructions are executed after such a return, subsequent code will be executed in the browser context fulfilling the attacker's objectives.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Implications</head><p>To counteract such a return-into-lib(c) style attack, a malware analysis has to strengthen the attribution mechanism, to allow information flow to be correctly captured for the different contexts.</p><p>Another work in this area, Panorama <ref type="bibr" target="#b44">[45]</ref>, proposes to label every write operation performed by a BHO for the purpose of being able to track dynamically generated code. But, it seems to rely on a similar attribution mechanism used in <ref type="bibr" target="#b12">[13]</ref>, and seems vulnerable to the attack presented in the previous section as the attribution mechanism can be circumvented. HookFinder <ref type="bibr" target="#b43">[44]</ref>, instead, is able to catch every hook implanted into the system by an untrusted binary. To do so, they use an approach which is similar to information flow-based techniques: they label every write operation performed by untrusted binaries, as they want to be able to analyze any hooking attempts (regardless it they are made by benign or potentially malicious modules). This seems to be a promising approach for the attribution problem. In fact, an extension to their strategy, as the one proposed in <ref type="bibr" target="#b32">[33]</ref>, which marks context as untrusted whenever control transfers involve tainted pointers resolves the issue of correctly attributing context.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Attacking Meta-data Integrity</head><p>Corrupting meta-data maintained by a dynamic information flow technique is another avenue for attack. Typically, meta-data consists of one or more bits of taint per word of memory, with the entire metadata residing in a memory-resident data structure in memory. An obvious approach for corrupting this data involves malware directly accessing the memory locations storing metadata. Most existing dynamic information flow techniques include protection measures against such attacks. Techniques based on emulation, such as <ref type="bibr" target="#b12">[13]</ref> can store metadata in the emulator's memory, which cannot be accessed by the emulated program. Other techniques such as <ref type="bibr" target="#b42">[43]</ref> ensure that direct accesses to metadata store will cause a memory fault. In this section we focus our attention on indirect attacks, that is, those that manifest an inconsistency between metadata and data values by exploiting race conditions.</p><p>Attacks based on data/meta-data races. Dynamic information flow techniques need to perform two memory updates corresponding to each update in the original program: one to update the original data, and the other to update the metadata (i.e., the taint information). Apart from emulation based approaches where these two updates can be performed "atomically" (from the perspective of emulated code), other techniques need to rely on two distinct updates. As a result, in a multithreaded program where two threads update the same data, it is possible for an inconsistency to arise between data and metadata values. Assume, for instance, that metadata updates precede data updates, and consider the following interleaved execution of two threads: time Benign Thread Malicious Thread t 1 set tag x to tainted t 2 set tag x to untainted t 3 write untainted value to x t k write tainted value to x Note that at the end, memory location x contains a tainted value, but the corresponding metadata indicates that it is untainted. Such an inconsistency can be avoided by using mandatory locks to ensure that the data and metadata updates are performed together. But this would require acquisition and release of a lock for each memory update, thereby imposing a major performance penalty. As a result, existing information flow tracking techniques generally ignore race conditions, assuming that it is very hard to exploit these race conditions. This can be true for untrusted stand-alone applications, but it is problematic, and cannot be ignored in the context of malware that share their address-space with a trusted application.</p><p>To confirm our hypothesis, we experimentally measured the probability of success for a malicious thread causing a sensitive operation without raising an alarm, against common fine-grained taint tracking implementations known today. The motivation of this attack is to show that, by exploiting races between data and metadata updates operations, it is possible to manipulate sensitive data without having them marked as sensitive. To demonstrate the simplicity of the attack, in our experiment we used a simple C program shown below (a) that executes as a benign thread. The sensitive operation open (line 10 (a) column) depends on the pointer fname which is the primary target for the attacker in this attack. We transform the benign code to track control-dependence and verified its correctness, since the example is small.  The attacker's thread (b) runs in parallel with the benign thread and has access to the global data memory pointer fname. The attacker code is transformed for taint tracking to mark all memory it writes as "unsafe" (i.e., tainted). We ran this synthetic example on a real machines using two different implementations of taint tracking. For conciseness, we only present the results for the taint tracking that uses 2 bits of taint with each byte of data, similar to <ref type="bibr" target="#b42">[43]</ref>, with all taint tracking code inlined, as this minimizes the number of instructions for taint tracking and hence the vulnerability window. Assuming that the get pref name call fails to return OK, on a quad-core Intel Xeon machine running Linux 2.6.9 SMP kernel, we found that chances that the open system call executes with the corresponding pointer fname marked "safe" (i.e., untainted) varies from 60%-80% across different runs. The reason why this happens is because the transformed benign thread reads the taint for fname on line 8 and sets the control context to tainted scope, before executing the original code for performing conditional comparison on line 9. The malicious thread tries to interleave its execution with the one of the benign thread, trying to achieve the following ordering of operations on the shared variable fname: </p><p>If such an ordering occurs, the tag fname read by the benign thread is marked untainted as the benign thread has cleared the taint previously, while the data happens to contain an attacker controlled value about user browser cookies. Consequently, contrary to the intention of the instrumentation of tracking control-dependence, the attacker manages to prevent control scope from switching to tainted scope at line 9 in the benign code. In practical settings, the window of time between t 1 and t 4 varies largely based on cache performance, demand paging, and scheduling behaviour of specific platform implementations. Finally, it is worth noting that the attacker could improve the likelihood of success by increasing the scheduling priority of the malicious thread and lower, where possible, those of benign thread.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Implications</head><p>Attacks on direct corruption of metadata has been studied before <ref type="bibr" target="#b42">[43]</ref> and thwarted by implementations using virtual machines and emulators which explicitly manage the context switches between threads or processors. However, much of the design of such metadata tracking monitors has not been carefully studied in the context of multithreaded implementations (or multi-processor emulators), and techniques in this section highlight the subtle importance of these.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Analyzing Future Behavior of Malware</head><p>Several strategies have been proposed to analyze untrusted software. Broadly speaking, these strategies can be divided in two main categories, the ones based on static analysis and the others which adopt a dynamic analysis approach. While static analysis has the potential to reason about all possible behaviors of software, the underlying computational problems are hard, especially when working with binary code. Moreover, features such as code obfuscation, which are employed by malware as well as some legitimate software, make it intractable in practice. As a result, most practical malware analysis techniques have been focussed on dynamic analysis.</p><p>Unfortunately, dynamic analysis can only reason about those execution paths in a program that are actually exercised during the analysis. Several types of malware do not display their malicious behavior unless certain trigger conditions are present. For instance, time bombs do not exhibit malicious behavior until a certain date or time. Bots may not exhibit any malicious behavior until they receive a command from their master, usually in the form of a network input.</p><p>In order to expose such trigger-based behavior, Moser et al. <ref type="bibr" target="#b0">[1]</ref> suggested an interesting dynamic technique that combines the benefits of a static and dynamic informationflow analyses. Specifically, they taint trigger-related inputs, such as calls to obtain time, or network reads. Then, dynamic taint-tracking is used to discover conditionals in the program that are dependent on these inputs. When one of the two branches of such a conditional is about to be taken, their technique creates a checkpoint and a snapshot of the analyzed process, and keeps exploring one of the branch. Subsequently, when the exploration of the taken branch ends or after a timeout threshold is reached, their technique forces the execution of the unexplored branch. Such forcing requires changing the value of a tainted variable v used in the conditional, so that the value of the condition expression is now negated. By leveraging on a decision procedure to generate a suitable value for v, the proposed approach also identifies any other variables in the program whose values are dependent on v, and modifies them so that the program is in a consistent state <ref type="foot" target="#foot_6">7</ref> . We observe that this analysis technique has applicability to certain kinds of anti-virtualization or sandbox-detection techniques as well. For instance, suppose that a piece of malware detects a sandbox (or a VM) based on the presence of a certain file, process, or registry entry. The approach proposed can then taint the functions that query for such presence, and proceed to uncover malicious code that is executed only when the sandbox is absent.</p><p>Since the underlying problems the analysis proposed by Moser et al. has to face are undecidable in general, their technique is incomplete, but seems to work well in practice against contemporary malware. However, this incompleteness can be exploited by a malware writer to evade detection. For instance, as noted by the authors of <ref type="bibr" target="#b0">[1]</ref>, a conditional can make use of one-way hash function. It is computationally hard to identify values of inputs that will make such a condition true (or false). More generally, malware authors can force the analysis to explore an unbounded number of branches, thereby exhausting computational resources available for analysis. However, the approach proposed in <ref type="bibr" target="#b0">[1]</ref> will discover this effort, and report that the software under analysis is suspicious. A human analyst can then take a closer look at such malware. Nonetheless, today's malware writer places high value on stealth, and hence would prefer alternative anti-analysis mechanisms that do not raise suspicions, and we describe such primitives next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Evasion Using Memory Errors</head><p>Binary code is generally hard to analyze, as briefly pointed out in Section 2.2. For instance, this is due to the absence of information about variables boundaries and types, which makes many source-based analyses inapplicable to binaries. We observe that given an arbitrary binary, it is hard to say whether it potentially contains a vulnerability such as a memory error (e.g., buffer overflow), and to determine the precise inputs to exploit it. Exhaustively running the binary on all possible inputs is often infeasible for benign code, leave alone malware which is expected to exploit the exponential nature of exhaustive searches to cause the worst-case hit each run.</p><p>Motivated by this observation, we present an attack against dynamic information flow-based analyses used to analyze malware behavior, similar to the one presented in <ref type="bibr" target="#b0">[1]</ref>. This attack is able to hide malicious code from being discovered and further strengthen it such that extensions to analysis employed in <ref type="bibr" target="#b0">[1]</ref> are unable to detect it. Our attack leverages on the introduction of memory errors, as shown in the following example. The introduced memory error is a plain stack-based buffer overflow vulnerability <ref type="foot" target="#foot_7">8</ref> . The attacker's goal is to write past the end of buf (line 7) and corrupt the pointer p to make it point to the variable trigger. Eventually, when the vulnerability will be exploited, the malware will set trigger to 1 (line 9) which in turn has the effect to disclose the malicious code represented by malcode() at line 12, guarded by trigger. It can be observed that the lack of proper bound checking in the code snipped shown above is not to be considered as a suspicious pattern by itself. The mere use of an unsafe function as my_gets <ref type="foot" target="#foot_8">9</ref> does not imply that there is a memory error. In fact, bound checking could have been performed elsewhere by the programmer (which justifies the use of an unsafe function), or the programmer knows that at that point the input can never be bigger than buf.</p><p>In order to disclose the malicious code during analysis, the variable trigger has to eventually be marked as tainted, so that the code it guards can be further analyzed. The variable trigger is never tainted unless p, which can potentially be corrupted ASCII value is 113 exceed a certain threshold. Only an exhaustive search over all the possible input values and combination would deterministically trigger this memory error. Unfortunately, such an enumeration would be extremely onerous if not impossible to perform. Similar to NP-complete problems which are hard to solve while verification of correct answers is easy, it is rather simple for the attacker to provide the right input which will cause dst to overflow so that p can be corrupted in such a way to eventually disclose the malicious behavior. From the analysis point of view, instead, an exhaustive search will probably start with a sequence of length 1, trying all the possible 256 ASCII values. This does not cause overflow as there is a safe padding of 128 bytes for dst. Following this reasoning, a sequence of length k and 256 k combination have to be tried. For instance, a k equal to 128 can reach the boundaries of dst. This, however, would roughly require to test 256 127 combinations to try out on average which is a fairly huge number.</p><p>Hiding malicious payload using interpreters. As a final point, we note that the malicious payload need not even to be included in the program. It can be sent by an attacker as needed. We can use the techniques described above to prevent the malware analyzer from identifying this possibility.</p><p>One common technique for hiding payload has been based on code encryption. Unfortunately, this technique involves a step that is relatively unusual: data written by a program is subsequently executed. This step raises suspicion, and may prompt a careful manual analysis by a specialist. Malware writers would prefer to avoid this additional scrutiny, and hence would prefer to avoid this step. This can be done relatively easily by embedding an interpreter as the body of the function malcode() in the attack described above. As a result, the body of the interpreter can escape analysis. Moreover, note that interpreters are common in many types of software: documents viewers such as PDF or Postscript viewers, flash players, etc, so their presence, even if discovered, may not be unusual at all. Finally, it is relatively simple to develop a bare-bones assembly language and write an interpreter for it. All of these factors suggest that malware writers can, with modest effort, obfuscate execution of downloaded code using this technique, with the final goal to hide malicious behavior without raising any suspect.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Implications</head><p>The implications on whether dynamic information flow-based techniques can help to disclose, analyze, and understand the behavior of the next-generation of malware is similar to the ones pointed out in the rest of this paper. In fact, to detect the evasion technique proposed in the previous section, an information flow-based approach should ideally be able to trigger any memory error which may be present in the analyzed software, and automatically exploit the vulnerability so that interesting (i.e., tainted) previously disabled conditions will be examined. In the previous section we have shown how this could be hard -if not impossible -at all to achieve, if directly faced. Alternatively, information flow analyses could taint any memory location, considering all the possible combinations, and see how information is propagated. While this would eventually taint trigger and thus disclose the malicious behavior, it would drop the benefits provided by taint-tracking mechanisms which focus the analysis on interesting data, as every paths would be forced to be explored. For instance, the resulting analysis would be similar to the one proposed in <ref type="bibr" target="#b8">[9]</ref> where, even if the underlying technique is different, the end result is that every path can potentially be explored, which of course is a hard task by itself. For instance, one may attempt to force execution of all program paths, but this is likely to be very expensive, and to suffer from semantic inconsistencies that may arise due to forcing execution down branches that are not taken during execution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Related Work</head><p>Information flow analysis has been researched for a long time <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b40">41]</ref>. Early research was focused on multi-level security, where fine-grained analysis was not deemed necessary <ref type="bibr" target="#b5">[6]</ref>. More recent work has been focused on language-based approaches, capable of tracking information flow at variable level <ref type="bibr" target="#b26">[27]</ref>. Most of these techniques have been based on static analysis, and assume considerable cooperation from developers to provide various annotations, e.g., sensitivity labels for function parameters, endorsement and declassification annotations to eliminate false positives. Moreover, they typically work with simple, high-level languages, while much of security-critical contemporary software is written in low-level languages like C that use pointers, pointer arithmetic, and so on. Finally, it can be noted that despite their benefits static analyses are generally vulnerable to obfuscation scheme, as recently remarked by <ref type="bibr" target="#b21">[22]</ref>. Therefore, it is reasonable to rely on dynamic or hybrid approaches, instead. As a result, information flow tracking for such software has been primarily based on run-time tracking of explicit flows that take place via assignments.</p><p>Recently, several different information flow-based approaches have been proposed in the literature <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b42">43]</ref>. They give good and promising results when employed to protect benign software from memory errors and other types of attacks, by relying on some implicit assumptions (e.g., no tainted code pointers should be dereferenced). The reason is because benign software is not designed to facilitate an attacker task, while malware, as we have seen, can be carefully crafted to embed evasion attacks, such as covert channels, and general memory corruption.</p><p>Probably, an ideal solution would require that untrusted binaries would carry proofs that some properties are guaranteed. This is achieved by proof-carrying code <ref type="bibr" target="#b24">[25]</ref>. To be successful, this technique relies on some form of collaboration between the code producer and consumer. For instance, Medel et al. <ref type="bibr" target="#b20">[21]</ref> and Yu et al. <ref type="bibr" target="#b45">[46]</ref> proposed information flow analyses for typed assembly languages. Likewise, Barthe et al. provided non-interference properties for a JVM-like language <ref type="bibr" target="#b3">[4]</ref> and dealt with timing attacks by using ACID transactions <ref type="bibr" target="#b4">[5]</ref>, as well. Unfortunately, it is unlikely that malware writers (i.e., the code producer, in this context) are going to give this form of collaboration which is necessary for the success of these approaches. Therefore, it is unlikely that these strategies would soon be adopted as is in the context of malicious software analysis and containment.</p><p>Driven by the recent practical success of information flow-based techniques, several researchers have started to propose solutions based on dynamic taint analysis to deal with malicious or, more generally, untrusted code <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b44">45]</ref>. During the last years, these techniques have been facing different tasks (e.g., classification, detection, and analysis) related to untrusted code analysis. Unfortunately, even if preliminary results show they are successful when dealing with untrusted code that has not been designed to stand and bypass the employed technique, as we hope the discussion in this paper highlighted, information flow is a fragile technique that has to be supported by new analyses to be more resilient to evasions purposely adopted by ever-evolving malware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>Information flow analysis has been applied with significant success to the problem of detecting attacks on trusted programs. Of late, there has been significant interest in extending these techniques to analyze the behavior of untrusted software and/or to enforce specific behaviors. Unfortunately, attackers can modify their software so as to exploit the weaknesses in information flow analysis techniques. As we described using several examples, it is relatively easy to devise these attacks, and to leak significant amounts of information (or damage system integrity) without being detected.</p><p>Mitigating the threats posed by untrusted software may require more conservative information flow techniques than those being used today for malware analysis. For instance, one could mark every memory location written by untrusted software as tainted; or, in the context of confidentiality, prevent any confidential information from being read by an untrusted program, or by preventing it from writing anything to public channels (e.g., network). Such approaches will undoubtedly limit the classes of untrusted applications to which information flow analysis can be applied. Alternatively, it may be possible to develop new information flow techniques that can be safely applied to untrusted software. For instance, by reasoning about quantity of information leaked (measured in terms of number of bits), one may be able to support benign untrusted software that leaks very small amounts of information. Finally, researchers need to develop additional analysis techniques that can complement information flow based techniques, e.g., combining strict memory access restrictions with information flows.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>1 char 3 ... 4 if</head><label>134</label><figDesc>* fname = NULL, old fname = NULL; 2 void check preferences () { (get pref name () == OK) 5 old fname = "/.../.mozilla/.../pref.js";</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>12 } 13 } 1 void</head><label>12131</label><figDesc>* malicious thread(void * q) { 2 int attempts = 0; 3 while (attempts++ &lt; MAX ATTEMPTS) 4 fname = "/.../.mozilla/.../cookies.txt";</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>In this paper, the term "trusted software" is used to refer to software that is trusted to be benign.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Typically, the term "taint" is used in the context of integrity, while "sensitive" is used in the context of confidentiality.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>Specifically, the PC is tainted within the body of a conditional if the condition involves tainted variables. Moreover, targets of assignments become tainted whenever the PC is tainted. Finally, the taint label of the PC is restored at the merge point following a conditional branch.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Browser extensions are named in different ways. Internet Explorer uses the terms "BHOs", "extensions" and "toolbars", while Gecko-based browsers (e.g., FireFox) use the terms "plugins" and "extensions". We use the term BHO for all these terms interchangeably in the paper.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>Lynx has been chosen to simplify the example.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>Such pointers reside often enough on global variables whose locations can be predicted in advance and hard-coded as constants in the malware.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>This is required, or else the program may crash or experience error conditions that would not occur normally. For instance, consider the code y = x; if (x == 0) z = 0; else z = 1/y; If we force the value of x to be nonzero, then y must also take the same value or else the program will experience a dive-by-zero exception.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_7"><p>It is important to note that there are no constraints on the type of vulnerability introduced. A generic buffer overflow, an integer overflow, or a (custom) format string vulnerability would have done as well.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_8"><p>This function resembles the well-known libc gets. The malware author can either use its own implementation or the one provided by the C library.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This research is supported in part by an ONR grant N000140710928 and an NSF grant CNS-0627687, and was carried out while the first two authors were at Stony Brook University.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>with tainted data by the malware, points to it. The problem of determining whether p could point to trigger is undecidable statically, thus augmentations to <ref type="bibr" target="#b0">[1]</ref> using some form of static analysis do not help. On the other end, one might argue that the dynamic approach proposed in <ref type="bibr" target="#b0">[1]</ref> could potentially accomplish the detection of the overflow, at least (while it is unlikely that the correct vulnerability exploitation can be achieved). In fact, given the aforementioned example, it is fairly easy for the analysis technique considered to generate a big-enough input which will eventually corrupt the pointer p. Even if such a technique is employed, we show that we can extend this example to make it even harder -if not unfeasible -to achieve this step.</p><p>To this end, it would be desirable to have a function f that is easy to compute, but hard to reason about some properties of it. By doing so, it is possible to modify the previous example in such a way to make it harder for the analyzer to even detect whether a memory error vulnerability is present or not. Such a situation is depicted by the following code snippet (the action performed by this code can be found in benign program as well). </p><p>It is worth noting that the function computespace is easy to compute, but is relatively hard to reason about some properties of it. For instance, by looking at the source code, it is easy to understand that at the end of the computation k holds the same value as the length of the data read into the buffer buf. On the other end, the same reasoning can be hard to do on binaries and in an automated way. Thus, it is hard to correlate n, the number of read bytes, to l, the minimum number of space to allocate to be sure the function decode does not cause overflow. The function decode presents a problem by itself, by deliberately introducing the condition for an overflow to occur. In fact, it can cause dst to overflow into p if the number of bytes given as input (buf) whose</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Exploring Multiple Execution Paths for Malware Analysis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Moser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kirda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Automatically Hardening Web Applications Using Precise Tainting</title>
		<author>
			<persName><forename type="first">A</forename><surname>Nguyen-Tuong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Guarnieri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Greene</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shirley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Evans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">20th IFIP International Information Security Conference</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Dynamo: a transparent dynamic optimization system</title>
		<author>
			<persName><forename type="first">V</forename><surname>Bala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Duesterwald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Banerjia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGPLAN Not</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">5</biblScope>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A certified lightweight non-interference java bytecode verifier</title>
		<author>
			<persName><forename type="first">G</forename><surname>Barthe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pichardie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rezk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Programming Languages and Systems</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Preventing timing leaks through transactional branching instructions</title>
		<author>
			<persName><forename type="first">G</forename><surname>Barthe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rezk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Warnier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 3rd Workshop on Quantitative Aspects of Programming Languages</title>
		<meeting>3rd Workshop on Quantitative Aspects of Programming Languages</meeting>
		<imprint>
			<date type="published" when="2005">QAPL 2005. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Secure computer systems: Mathematical foundations</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Bell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">J</forename><surname>Lapadula</surname></persName>
		</author>
		<idno>MTR-2547</idno>
		<imprint>
			<date type="published" when="1973">1973</date>
			<publisher>MITRE Corp</publisher>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Qemu, a fast and portable dynamic translator</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bellard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ATEC 2005: Proceedings of the USENIX Annual Technical Conference 2005 on USENIX Annual Technical Conference</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Integrity considerations for secure computer systems</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">J</forename><surname>Biba</surname></persName>
		</author>
		<idno>ESD- TR-76-372</idno>
	</analytic>
	<monogr>
		<title level="j">Hanscom Air Force Base</title>
		<imprint>
			<date type="published" when="1977">1977</date>
			<publisher>Massachusetts</publisher>
			<pubPlace>Bedford</pubPlace>
		</imprint>
		<respStmt>
			<orgName>USAF Electronic Systems Division</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Exe: automatically generating inputs of death</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cadar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Ganesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Pawlowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS 2006: Proceedings of the 13th ACM conference on Computer and communications security</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Defeating memory corruption attacks via pointer taintedness detection</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Nakka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Kalbarczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Iyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Dependable Systems and Networks (DSN)</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Defeating Memory Corruption Attacks via Pointer Taintedness Detection</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Nakka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Kalbarczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Iyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DSN 2005: Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN 2005</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Certification of programs for secure information flow</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Denning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Denning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">7</biblScope>
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Dynamic spyware analysis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Egele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kirda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Usenix Tech Conference</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Memoryless subsystems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Fenton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computing Journal</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Dynamic Taint Analysis for Automatic Detection, Analysis, and Signature Generation of Exploits on Commodity Software</title>
		<author>
			<persName><forename type="first">J</forename><surname>Newsome</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Network and Distributed System Security Symposium</title>
		<meeting>the Network and Distributed System Security Symposium</meeting>
		<imprint>
			<date type="published" when="2005">NDSS 2005. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Improving Software Security via Runtime Instruction-level Taint Checking</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Zou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASID 2006: Proceedings of the 1st workshop on Architectural and sys tem support for improving software dependability</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Pin: building customized program analysis tools with dynamic instrumentation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Luk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Klauser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lowney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Janapa Reddi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hazelwood</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>SIGPLAN Not</publisher>
			<biblScope unit="volume">40</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">W32/hiv</title>
		<author>
			<persName><surname>Mcafee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">virus information library</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">W32/mydoom@mm</title>
		<author>
			<persName><surname>Mcafee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">virus information library</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A general theory of composition for trace sets closed under selective interleaving functions</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mclean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Typed Assembly Languages for Software Security</title>
		<author>
			<persName><forename type="first">R</forename><surname>Medel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Stevens Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Limits of static analysis for malware detection</title>
		<author>
			<persName><forename type="first">A</forename><surname>Moser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kirda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACSAC 2007</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Choi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Y</forename><surname>Paek</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Cho</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4697</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">JFlow: Practical mostly-static information flow control</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM POPL</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="228" to="241" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">BIRD: Binary interpretation using runtime disassembly</title>
		<author>
			<persName><forename type="first">S</forename><surname>Nanda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Chiueh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Conference on Code Generation and Optimization</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Proof-carrying code</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">C</forename><surname>Necula</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Langauges</title>
		<meeting>the 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Langauges</meeting>
		<imprint>
			<date type="published" when="1997">1997. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Valgrind: A framework for heavyweight dynamic binary instrumentation</title>
		<author>
			<persName><forename type="first">N</forename><surname>Nethercote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Seward</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN 2007 Conference on Programming Language Design and Implementation</title>
		<imprint>
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Perl taint mode</title>
		<author>
			<persName><forename type="first">Perl</forename></persName>
		</author>
		<ptr target="http://www.perl.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Defending against injection attacks through context-sensitive string evaluation</title>
		<author>
			<persName><forename type="first">T</forename><surname>Pietraszek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">V</forename><surname>Berghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RAID 2005</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Valdes</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Zamboni</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">3858</biblScope>
			<biblScope unit="page" from="124" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Argos: an emulator for fingerprinting zero-day attacks for advertised honeypots with automatic signature generation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Portokalidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Slowinska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Bos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGOPS Oper. Syst. Rev</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">LIFT: A low-overhead practical information flow tracking system for detecting general security attacks</title>
		<author>
			<persName><forename type="first">F</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/ACM International Symposium on Microarchitecture</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">The Advanced return-into-lib(c) Exploits: PaX Case Study. Phrack Magazine 0x0b(0x3a)</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">N</forename><surname>Wojtczuk</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Phile #0x04 of 0x0e (2001</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Language-based information-flow security</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sabelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J. Selected Areas in Communications</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">A practical technique for integrity protection from untrusted plug-ins</title>
		<author>
			<persName><forename type="first">P</forename><surname>Saxena</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Puranik</surname></persName>
		</author>
		<idno>SECLAB08-01</idno>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
		<respStmt>
			<orgName>Stony Brook University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Characterizing bots&apos; remote control behavior</title>
		<author>
			<persName><forename type="first">E</forename><surname>Stinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DIMVA 2007</title>
		<editor>
			<persName><forename type="first">B</forename><forename type="middle">M</forename><surname>H√§mmerli</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Sommer</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4579</biblScope>
			<biblScope unit="page" from="89" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">RORIV&quot; Strife and Xdream ROJIV Blue. Ret onto Ret into Vsyscalls</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Secure Program Execution via Dynamic Information Flow Tracking</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Suh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS-XI: Proceedings of the 11th international conference on Architectural support for programming languages and operating systems</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">The Art of Computer Virus Research and Defense</title>
		<author>
			<persName><forename type="first">P</forename><surname>Szor</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>Symantec Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<author>
			<persName><surname>Trendmicro</surname></persName>
		</author>
		<author>
			<persName><surname>Bkdr</surname></persName>
		</author>
		<title level="m">surila.g (w32/ratos). virus encyclopedia</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">WiLDCAT: An Integrated Stealth Environment for Dynamic Malware Analysis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Vasudevan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<pubPlace>USA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>The University of Texas at Arlington</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Cross-Site Scripting Prevention with Dynamic Data Tainting and Static Analysis</title>
		<author>
			<persName><forename type="first">P</forename><surname>Vogt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Nentwich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Jovanovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kirda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of the Network and Distributed System Security Symposium (NDSS</title>
		<meeting>eeding of the Network and Distributed System Security Symposium (NDSS</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">A sound type system for secure flow analysis</title>
		<author>
			<persName><forename type="first">D</forename><surname>Volpano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Irvine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Security (JCS)</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Safety versus secrecy</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Volpano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAS 1999</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Cortesi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Fil√©</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1694</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Taint-enhanced policy enforcement: A practical approach to defeat a wide range of attacks</title>
		<author>
			<persName><forename type="first">W</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bhatkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sekar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Hookfinder: Identifying and understanding malware hooking behaviors</title>
		<author>
			<persName><forename type="first">H</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NDSS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Panorama: Capturing system-wide information flow for malware detection and analysis</title>
		<author>
			<persName><forename type="first">H</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Manuel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kirda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th ACM Conferences on Computer and Communication Security</title>
		<meeting>the 14th ACM Conferences on Computer and Communication Security</meeting>
		<imprint>
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">A typed assembly language for confidentiality</title>
		<author>
			<persName><forename type="first">D</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Islam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP 2006 and ETAPS 2006</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Sestoft</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">3924</biblScope>
			<biblScope unit="page" from="162" to="179" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
