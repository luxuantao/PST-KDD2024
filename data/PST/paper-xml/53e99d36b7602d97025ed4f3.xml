<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Hoare Logic for Java in Isabelle/HOL</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">David</forename><surname>Von Oheimb</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Institut für Informatik</orgName>
								<orgName type="institution">Technische Universität München</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Hoare Logic for Java in Isabelle/HOL</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D8309AA71021A82EAB0104909258F29D</idno>
					<note type="submission">Received 16 September 2000 Copyright c 2001 John Wiley &amp; Sons, Ltd. Revised 28 February 2001 Accepted 2 March 2001</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T02:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Hoare logic</term>
					<term>axiomatic semantics</term>
					<term>Java</term>
					<term>Isabelle/HOL</term>
					<term>verification</term>
					<term>soundness</term>
					<term>completeness</term>
					<term>auxiliary variables</term>
					<term>side effects</term>
					<term>mutual recursion</term>
					<term>dynamic binding</term>
					<term>exception handling</term>
					<term>type safety</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This article presents a Hoare-style calculus for a substantial subset of Java Card, which we call Java Ø . In particular, the language includes side-effecting expressions, mutual recursion, dynamic method binding, full exception handling, and static class initialization.</p><p>The Hoare logic of partial correctness is proved not only sound (w.r.t. our operational semantics of Java Ø , described in detail elsewhere) but even complete. It is the first logic for an object-oriented language that is provably complete. The completeness proof uses a refinement of the Most General Formula approach. The proof of soundness gives new insights into the role of type safety. Further by-products of this work are a new general methodology for handling side-effecting expressions and their results, the discovery of the strongest possible rule of consequence, and a flexible Call rule for mutual recursion. We also give a small but non-trivial application example.</p><p>All definitions and proofs have been done formally with the interactive theorem prover Isabelle/HOL. This guarantees not only rigorous definitions, but also gives maximal confidence in the results obtained.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.">Motivation and Aims</head><p>Since languages like Java <ref type="bibr" target="#b16">[17]</ref> are widely used even in safety-critical applications, verification of object-oriented programs is becoming more and more important. A crucial first step towards verification is developing a suitable axiomatic semantics (a.k.a. "Hoare logic") for such languages. The resulting proof system should be provably sound, easy to use, and complete. Due to the complexity of practical languages and the large amount of detail involved, support by mechanical theorem provers seems indispensable.</p><p>This article focuses on the meta-theory of program verification and its mechanization in a theorem prover. The work presented here is aimed to be a solid basis for further research and developments regarding methodological issues and tool support for actual program verification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2.">Related Work</head><p>Various sublanguages of Java have been formalized in theorem proving systems. Syme <ref type="bibr" target="#b54">[55]</ref> proves type soundness by directly mechanizing and improving the work of Drossopoulou and Eisenbach <ref type="bibr" target="#b12">[13]</ref>. Within the LOOP project <ref type="bibr" target="#b27">[28]</ref>, Jacobs et al. <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b24">25]</ref> translate Java classes to PVS or Isabelle/HOL theories and perform program verification with a Hoare-style logic proved sound within their system. Within project Oasis <ref type="bibr" target="#b5">[6]</ref>, Attali et al. <ref type="bibr" target="#b6">[7]</ref> give an executable transition semantics and develop a visualization tool for a large subset of Java within the Centaur system. Leino et al. <ref type="bibr" target="#b36">[37]</ref> translate (almost all of) Java 1.2 to a guarded-command-like language in order to generate verification conditions for extended static checking.</p><p>Many Hoare logics for object-oriented languages have been proposed meanwhile. Abadi and Leino <ref type="bibr" target="#b0">[1]</ref> describe a type-system-like core calculus that later has been formalized by Hofmann and Tang <ref type="bibr" target="#b20">[21]</ref> in LEGO. The OO logic work by Leavens focuses on behavioral subtyping, e.g. <ref type="bibr" target="#b34">[35]</ref>, and specification languages, in particular JML <ref type="bibr" target="#b33">[34]</ref>. The LOOP project mentioned above provides a formal semantics for JML <ref type="bibr" target="#b29">[30]</ref>. Poetzsch-Heffter et al. give a Hoare logic for a core language of Java <ref type="bibr" target="#b50">[51]</ref>, where Müller focuses on modular verification <ref type="bibr" target="#b39">[40]</ref>. All these logics have been proved sound (typically on paper). None of them has been proved complete. The Hoare logic for the language SPOOL by America and de Boer <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b11">12]</ref> has been proved complete (on paper), yet SPOOL implements only a quite weak form of object-orientation: it offers records and methods on them, but lacks subtyping and dynamic binding.</p><p>Other more specific references to related work are given where appropriate. Our logic has been developed within Project Bali <ref type="bibr" target="#b41">[42]</ref>. The proofs of soundness and completeness have been inspired by <ref type="bibr" target="#b50">[51]</ref> and <ref type="bibr" target="#b31">[32]</ref>, respectively. This article is essentially a slightly revised standalone version of [47, Ü5].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3.">Characteristics</head><p>Our Hoare logic for Java has the following characteristics.</p><p>Language Coverage Apart from static overloading and dynamic binding of methods as well as references to dynamically allocated objects, our language, called Java Ø , also covers full exception handling, static fields and methods, and static initialization of classes. The only important features still missing, name spaces and visibility control, will be added soon. Thus Java Ø is quite close to Java Card <ref type="bibr" target="#b53">[54]</ref> which is essentially the sequential part of Java.</p><p>Semantical Assertions Our semantic view of assertions identifies the assertion language with the underlying meta logic of our proof system. This simplifies the logics and makes the otherwise problematic issues of expressiveness of the assertion language and the completeness of the meta logic trivial. The dependency of assertions on the program state and auxiliary variables is made explicit, which is helpful for conducting meta-theory though a bit awkward for actual program verification.</p><p>First-class Expressions Instead of modeling expressions with side-effects as assignments to intermediate variables, it handles them first-class. Thus programs to be verified do not need to undergo artificial structural transformations. Jacobs et al. <ref type="bibr" target="#b25">[26]</ref> claim to deal with side-effecting expressions, too, though their paper does not reveal their approach and their WHILE rule does not allow side-effects in the loop condition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Isabelle Definitions</head><p>Types follow the syntax of ML. Type abbreviations are introduced simply as equations. Logical constants are declared by giving their name and type, separated by ' '. Both types and constants may receive additional general mixfix syntax (possibly with graphical symbols and user-defined precedences). We write non-recursive definitions and abbreviations with ' '.</p><p>The appearance of formulas is standard, e.g. ' ' is the (right-associative) infix implication symbol. Quantifications have very low syntactical precedence, i.e. their scope extends to the end of the given formula or until the next closing parenthesis. Terms are expressions of an extended -calculus similar to ML. Function application is written in curried style. Predicates are functions with Boolean result.</p><p>There are primitive and general recursive function definitions as well as inductive definitions of relations, which we use heavily. A free datatype is defined by listing its constructors together with their argument types, separated by ' '.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">HOL Library</head><p>By HOL we mean Isabelle/HOL, which is not to be confused with its nearest relative, Gordon's HOL system <ref type="bibr" target="#b13">[14]</ref>. The fundamentals of HOL are introduced in <ref type="bibr" target="#b42">[43]</ref>, whereas the latest version of HOL can be found in <ref type="bibr" target="#b21">[22]</ref>. A recent gentle introduction is <ref type="bibr" target="#b40">[41]</ref>.</p><p>In HOL there are simple types like bool and nat, as well as the polymorphic type ´«µset of homogeneous sets for any element type «. Occasionally we apply the infix 'image' operator lifting a function over a set, defined as f S f x x. x¾S .</p><p>The product type « ¢ ¬ comes with the projection functions fst and snd. Tuples are pairs nested to the right, e.g. ´a,b,cµ á,´b,cµµ. They may be used also as patterns like in ´x,yµ. f x y.</p><p>The sum type « • ¬ comes with the injections Inl and Inr. For the ternary sum « • ¬ • we assume the injections In1, In2 and In3.</p><p>We frequently use the datatype</p><p>´«µoption None Some «</p><p>It has an unpacking function the ´«µoption « such that the ´Some xµ x. (the None is left unspecified.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Java Ø Formalization</head><p>Our axiomatic semantics inherits all features, in particular declarations and the program state, from our operational semantics of Java Ø . Here we mention just the most important definitions used in the following sections. There are many other auxiliary type and function definitions which we cannot define here for lack of space. See <ref type="bibr" target="#b47">[48]</ref> and [47, Ü2 and Ü3] for a complete and more detailed description. The actual Isabelle/HOL theories and proof scripts may be obtained from http://isabelle.in. tum.de/Bali/src/Bali5/.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Declarations</head><p>A program, denoted by , consists of a list of interface and class declarations:</p><formula xml:id="formula_0">prog ídeclµlist ¢ ´cdeclµlist</formula><p>It serves as the context for most judgments. The well-formedness predicate wf prog states that a program fulfills all the sanity constraints typically checked by the compiler. The (much weaker) wellstructuredness predicate ws prog just states that the class and interface hierarchies are finite and acyclic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Terms and Results</head><p>A Java Ø term is either an expression, a statement, a variable, or an expression list, and has a corresponding result. It helps to handle all four classes of terms as uniformly as possible. Thus even statements are modeled to have a (dummy) result. The result of a variable has type vvar val ¢ ´val state stateµ, which is a value (for read access) and a state update function (for write access). This is reminiscent of L-values introduced by Strachey <ref type="bibr" target="#b52">[53]</ref>.</p><formula xml:id="formula_1">terms éxpr • stmtµ • var • éxprµlist vals val • vvar • val µlist</formula><p>We will use the functions</p><formula xml:id="formula_2">Val v In1 v Var v In2 v Vals v In3 v</formula><p>for injecting single values, variables and value lists into vals. The names Val, Var, and Vals will be used not only for the injections, but also as (destructor) patterns. For example, Val v. f v is a function on the result entry that expects a single value v and passes it to f. Statements in Java Ø are reduced to their essentials. The datatype definition gives the abstract syntax as follows. The artificial statement init C is used to model static initialization of a class C at the points of (potential) first active use. Java expressions, in particular method calls and object creation, do not only yield results but typically also cause side effects on the program state. A common modeling technique is to get rid of side effects by transforming the problematic expressions into a series of assignments (which are then considered as statements) to temporary variables. We believe that such a transformation is inadequate since it severely alters the structure of programs and has non-trivial semantical connections, e.g. to exception propagation. Therefore we handle expressions first-class, even if this causes inconveniences, above all for the axiomatic semantics (cf. Ü4.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The abstract syntax of Java</head><p>Ø expressions (and variables contained in them) is The subterms in braces are so-called type annotations: extra information typically added by the compiler.</p><p>The auxiliary expression Methd C m is employed within method calls (cf. Ü9.7). It denotes the implementation of method m of class C, a concept crucial for the axiomatic semantics, as will be motivated in Ü9.7.2. The unfolded version of a method implementation is its actual body, for which we introduce Body D c e, a further auxiliary term is a useful abstraction used for simplifying the Å Ø rule of the axiomatic semantics. Here D is the defining class, c is the (block of) statements in the body, and e is the result expression, used to emulate return statements.</p><p>See Ü12 for example program terms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Type System</head><p>We model the most important primitive types and all reference types, as well all type relations between them. Here we just mention the widening relation, where S T means that in the context a value of type S may be used in a place where a value of type T is expected.</p><p>The fact that a term t is well-typed and has type T is expressed via (inductively defined) typing judgments ´ ,£µ t T where ´ ,£µ is the type environment consisting of the program and a local part mapping variable names to types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">State</head><p>The program state is defined as None, which expresses that in state there is no pending exception, and write snd to refer to the state without the information on exceptions, typically denoted by s.</p><p>We further define functionals mapping an update of the exception or store part of the state to an update of the full state, </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.">Evaluation</head><p>The general evaluation judgment has the form prog state terms ´vals ¢ stateµ where t ´w, ¼ µ means that in the context of program evaluation of term t from the initial state terminates in state ¼ and yields the result w. There are specific variants of the evaluation judgment for all classes of terms, e.g. for expressions e with value v:</p><formula xml:id="formula_3">e-v ¼ In1 ´Inl eµ ´Val v, ¼ µ</formula><p>When developing the axiomatic semantics we had to adapt our model for method calls as given e.g. in <ref type="bibr" target="#b47">[48]</ref>. As will be motivated in Ü9.7.2, we distinguish the callee's side of method calls, the method implementation, from the caller's side and further handle the actual method body separately <ref type="bibr" target="#b48">[49]</ref>. This also helps to keep the complexity of the method call rule bearable.</p><p>Thus our adapted method call rule does not any more evaluate the statements and result expression of the method body directly but calls evaluation of the method implementation Methd C sig with signature sig of some class C. The method implementation rule then looks up the method according to this information and determines the information needed for the body:</p><formula xml:id="formula_4">Norm s¼ body C sig-v ½ Norm s¼ Methd C sig-v ½</formula><p>where body C sig let ´D, , ,c,eµ the ´cmethd C sigµ in Body D c e is an auxiliary function that looks up the the method with the given signature in the class hierarchy (starting from the class C) and inserts the method body where D is the defining class, the statement c represents the actual block of commands, and e is the result expression.</p><p>The evaluation of the body is just a sequential composition of initializing the current class (if required), executing the block of statements, and evaluating the result expression:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Assertions</head><p>In designing an axiomatic semantics the most critical notion is that of assertions, i.e. propositions describing the pre-and postconditions of term execution. The language of assertions and the underlying logic strongly determine the expressiveness and completeness of the resulting verification logic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Logical Language</head><p>As the assertion language and logic, we could use Peano Arithmetic, i.e. first-order predicate logic with equality, natural numbers, • and £. This is because we will quantify essentially just over (lists and finite mappings of) values. The program state can be encoded using lists of (lists of) values, the potentially problematic variable update functions (contained in type vvar) can be coded as a simple choice between the three possible cases (local, field, and array variables), and for lists standard encodings exist. Thus a rather minimal language would be sufficient, but at the expense of technically awkward encodings. Based on these observations, we could define a notion of expressiveness suiting our needs.</p><p>We could embed the assertion language, Peano Arithmetic or something less minimal, deeply in our meta logic HOL. This means defining as a first step the (abstract) syntax of the language and then assign semantics to it. Such deep embeddings <ref type="bibr" target="#b8">[9]</ref> are useful when doing meta-theory on the language in question since one can express properties of the syntactic structure and prove generic properties of the language. In particular, this would enable us to explicitly treat expressiveness and the whole issue of completeness (basically) along the lines of Cook <ref type="bibr" target="#b10">[11]</ref>, who did a good job separating concerns within the completeness affair. Yet as observed by Kleymann [32, Ü2.12], some of the known incompleteness results crucially depend on certain expressiveness properties and have been misinterpreted in the sense that they were attributed relevance for practical purposes, which they in fact do not have. Actually, we are not aware of any actual verification system based on Hoare logic where incompleteness of the underlying logic is an issue. Thus Kleymann and others follow Aczel's suggestion <ref type="bibr" target="#b1">[2]</ref> not to consider expressiveness when investigating the completeness of a Hoare-style logic. Moreover, compared to a shallow embedding, a deep embedding would complicate in particular the proofs of soundness and completeness as it requires talking explicitly about the syntactic level (i.e. terms and substitutions) and their semantic interpretation, which would just add clutter without giving us any benefit.</p><p>For the reasons given above we shallow-embed the assertion language in HOL, i.e. short-circuit both logical languages. This not only relieves us from defining (and using) the syntax, semantics and proof rules of the assertion language -we do not have to bother with expressiveness. Concerning derivability, we automatically only have to deal with relative completeness in the sense of Cook <ref type="bibr" target="#b10">[11]</ref>, i.e. completeness of the Hoare logic rule system itself modulo (in-)completeness of the underlying meta logic. In particular, within the rule of consequence, the derivability of an implication between assertions is replaced simply by its validity, i.e. mere implication in the meta logic HOL.</p><p>Since assertions depend on the program variables (including the heap), from the HOL perspective, they are essentially just predicates on the state. We use the state as an explicit parameter of the assertions, which is most appropriate when conducting meta-theory. Thus an example Hoare triple that is traditionally given as True c X 1 now reads as . True c . locals ´snd µ X Some ´Intg 1µ , where the rather cumbersome expression in the postcondition could of course be suitably abbreviated and the assertions pretty-printed. For actual program verification, a mechanism for hiding the state and directly referring to the program variable names, as given by Wenzel <ref type="bibr" target="#b55">[56]</ref>, would enhance readability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Auxiliary Variables</head><p>Program verification typically involves relating pre-and postconditions of program terms, in particular when stating that a certain portion of the state does not change or when giving input-/output specifications of methods (or general procedures). Such relations are easily expressed in VDM <ref type="bibr" target="#b30">[31]</ref> using "hooked" expressions within the postcondition to refer to the initial state. With plain Hoare logic, one cannot make such references, but one can extend the logic by so-called auxiliary variables, or logical variables, which are universally bound at a higher level. For example, the proposition that a procedure P does not change the contents of a program variable X may be formulated as the triple X Z Call P X Z , which should mean that whenever X has some value denoted by Z before calling P, after return it still has the same value, as given by Z. A potential interpretation for Z is to be a program variable not occurring in P, but this essential side condition cannot be expressed within the logic. A better and rather intuitive alternative is that Z be viewed as a free variable, which is thus implicitly universally quantified at the outermost logical level. Yet this gives the desired interpretation only if the triple occurs (implication-)positively, and thus is unsuitable when triples are used also in antecedents as required for verifying recursive methods (cf. Ü9.7.2).</p><p>Viewing Z as an arbitrary (yet fixed) constant preserves correctness, but this approach suffers from incompleteness: take a procedure triple like X Z Call SQ Y Z£Z as an example. Both for handling recursive calls during its proof and for different applications after it has been proved, different instantiations of Z may be required, which is impossible if Z is a constant. The classical but cumbersome and often incomplete way out, as described e.g. by Apt <ref type="bibr" target="#b3">[4]</ref>, is inventing some (more or less ad-hoc) set of substitution and adaptation rules involving sometimes intricate side-conditions on variable occurrences. A semantically satisfactory solution that we could adopt would involve (implicit or explicit) universal quantification at the level of triples like Z. P Z c Q Z , but this changes the outer structure of Hoare triples and makes them more difficult to handle, in particular if they occur in the antecedents.</p><p>We follow the approach promoted and applied by Kleymann £ [52]: implicit quantification of auxiliary variables at the level of triple validity. In order to abstract from the number and the names of the auxiliary variables used in different triples, assertions receive an extra parameter representing the collection of all required auxiliary variables. The type of the parameter is not specified and thus can be instantiated as appropriate, typically to a tuple of values (for actual program verification) or the whole state (for meta theory). With this extended notion of assertions, the motivating example X Z Call P X Z now reads as Z. locals ´snd µ X Z Call P Z. locals ´snd µ X Z where in this case the type of Z is of course the type of the variable X.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Result Values</head><p>We still need a further -orthogonal -extension of assertions, namely for handling the result values of side-effecting expressions. In contrast to most other axiomatic semantics given in the literature, and as already motivated in Ü3.2, we take such expressions seriously.</p><p>Homeier and Martin <ref type="bibr" target="#b22">[23]</ref> appear to have been the first ones to embed side-effecting expressions in a machine-checked axiomatic semantics. They transform expressions syntactically into the assertion language while using simultaneous substitutions to account for side-effects. This solution does not require special triples and result value entries. On the other hand, it is not general enough because it can handle only variable assignments (including e.g. incrementation operators) but not method calls within expressions which appear frequently in object-oriented programs.</p><p>We use triples not only to describe the behavior of statements, but also all other classes of terms, i.e. expressions, expression lists, and variables. This requires a mechanism for not only recording, but also for passing on the values produced by these terms. In an operational semantics, the (nameless) result values can be referred to and passed on via meta variables bound at the outermost logical level, but in an axiomatic semantics, such a simple technique is impossible: the behavior of a term has to be described solely by a suitable triple without any reference to its surroundings. Thus all variables occurring in the pre-and postconditions of the triple have to be logically bound to that triple. Violating this principle easily leads to unsound or incomplete rule systems.</p><p>Kowaltowski <ref type="bibr" target="#b32">[33]</ref> rather early pointed to the right direction giving a surprisingly simple (syntactic) solution: Within assertions there is a default reference, call it , to the result of the current expression. The rule for constant expressions, for example, then reads as</p><formula xml:id="formula_5">P c/ c P</formula><p>which is reminiscent of the well-known assignment rule applied to :=c. The rule for an arbitrary binary operator ¨reads as</p><formula xml:id="formula_6">P d Q / Q e R ¨ / P d ¨e R</formula><p>does not occur elsewhere and can be justified by simulating the the special result variables with intermediate program variables. Unfortunately these rules cannot be used directly in our rigorous semantical setting as they rely on syntactic substitutions and the problematic syntactic side condition of variable freshness.</p><p>Another early treatment of side-effects is due to Boehm <ref type="bibr" target="#b7">[8]</ref> who uses a kind of dynamic logic dividing between effects and values of expressions. This approach seems conceptually nice, but apparently leads to complex proofs.</p><p>After some experimentation we found and implemented a first solution of the result representation problem: let the assertions refer to a stack of result values. This not only gives a default reference, viz. the stack top, but also an arbitrary number of unique references for further intermediate results where the explicit syntactic shifting performed when having two or more intermediate results is handled by pushing and popping elements.</p><p>Later we noticed that there is a simpler solution: assertions receive the (single) current result value as a parameter. Thus substitution can be modeled simply by a combined abstraction and application, and the rule for constant expressions reads as . P c c P Note that the precondition effectively ignores the result parameter , i.e. P c does not depend on it, since it makes sense only in the postcondition. We will later (cf. Ü4.5) abbreviate the precondition to</p><formula xml:id="formula_7">P c.</formula><p>Multiple result values within a Hoare logic rule can be handled by suitable explicit universal quantification and substitution of all but the last value in the following way. First, observe that we may rewrite the rule for binary operators to</p><formula xml:id="formula_8">P d Q Q / e R ¨ / P d ¨e R</formula><p>for some not occurring elsewhere This form has two advantages: we only need substitution to and the side condition on can be made local to the second triple in the assumptions. Thus we can model the side condition semantically by universal quantification of around the second triple and end up with the rule</p><formula xml:id="formula_9">P d Q . . Q e . R ´ ¨ µ P d ¨e R</formula><p>Both subexpressions are evaluated in sequence, where Q as intermediate assertion typically involves the result of d. The final postcondition R is modified for the proof on e as follows: we take the second intermediate result , combine it with the first intermediate result as obtained from the precondition, and use the combined value as the overall result.</p><p>Huisman <ref type="bibr" target="#b24">[25]</ref> also deals with side-effecting expressions, though she is not explicit about the approach employed. Yet the rules given reveal that she uses a similar (though more complicated) semantical technique, namely existentially quantified result functions that depend on an universally quantified state parameter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Assertion Type</head><p>Having decided on the logical language, the use of auxiliary variables, and the result entry, we can finally give the type of assertions. It has a type parameter « for the auxiliary variables and is defined as a relation between a result value, the state and the auxiliary variables:</p><formula xml:id="formula_10">« assn vals state « bool See Ü12 for application examples.</formula><p>For implications between assertions we use the abbreviation</p><formula xml:id="formula_11">P µ Q Y Z. P Y Z Q Y Z</formula><p>As done here, we typically refer to the result parameter of an assertion as Y, the state as , and the auxiliary variables as Z.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.">Combinators</head><p>In order to keep the axiomatic rules short and thus more readable, we define several assertion (predicate) combinators hiding the state, result, and auxiliary variables in applications as far as possible.</p><p>¯ Note that the latter two combinators have (almost) inverse effect, in the following sense: ´´f .; Pµ ;. fµ µ P and P µ ´f .; ´P ;. fµµ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Another group of combinators provides abbreviations for producing and consuming results:</head><p>¯P w Y. P w means that P holds where w is substituted as the result. In successive substitutions the leftmost one prevails: P w v P w. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Triples</head><p>We define Hoare-style triples (as usual consisting of a term and two assertions as pre-and postconditions) via a datatype</p><p>´«µtriple with a single constructor with the mixfix syntax:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>« assn terms « assn</head><p>We give a variant for each class of terms, viz. expressions, variables, expression lists, and statements:</p><formula xml:id="formula_12">P e- Q P In1 ´Inl eµ Q P e Q P In2 e Q P e Q P In3 e Q P .c. Q P In1 ´Inr cµ Q</formula><p>In some triples of our Hoare logic rules given below the term parameter will be a (quantifierfree) meta-level expression such as if b then Skip else c rather than a pure term of (the abstract syntax of) Java Ø . This does not hinder the use of such rules since during application these expressions are reduced to pure Java Ø terms, in this case to either Skip or c. Another typical example is the expression body C sig which is ultimately replaced by the actual body of the given method.</p><p>Concerning the handling of recursive of methods, we take (a variant of) the standard approach: triples appear not only in the consequent, but sets of triples are used as antecedents within the validity and derivability judgments.</p><p>´«µtriples «µtriple set Furthermore, in order to handle mutual recursion, it is convenient to use sets of triples as (multiple) consequents as well, as further explained in Ü9.7.2. Semantically speaking, forming sets of triples always means conjunction of its members. Note that for simplicity we allow infinite sets here though only finite sets of triples are derivable.</p><p>Actually, the triple type should not have a type parameter and triples should be universally quantified over the type of the auxiliary variables instead: «. « assn terms « assn . This is not possible in HOL due to the weak (parametric) polymorphism. Thus all members of a set of triples and also the antecedents and consequents as a whole within a Hoare judgment, and thus all triples within a single derivation, are bound to have the same type of auxiliary variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Validity</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Single Triples</head><p>The validity of a single triple is a judgment of the form We define partial correctness as</p><formula xml:id="formula_13">n: P t Q Y Z. P Y Z type ok t ´ Y ¼ ¼ . t:n ´Y ¼ , ¼ µ Q Y ¼ ¼ Zµ</formula><p>Validity of P t Q (w.r.t. the recursive depth n explained in the next subsection) intuitively means that if P holds for some type-conforming starting state and the evaluation of the term t terminates, then Q holds for the result and the final state </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>T. ´ ,£µ t Tµ</head><p>´ ,£µ expresses that the term t is well-typed (at least if is a normal state) and that all values in conform to their static types, both w.r.t. the global environment and some local environment £. This additional precondition is required to ensure soundness, as will be discussed in Ü10.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Recursive Depth</head><p>The judgment</p><formula xml:id="formula_14">t:n ´Y ¼ , ¼</formula><p>µ above is a slight refinement of the evaluation judgment given in Ü3.5. The refinement does not alter the semantics of evaluation, i.e. the new parameter n is a mere annotation. It states that evaluation is done with a recursive depth bound by n. This notion is required for the proof of soundness and thus will be motivated in Ü10.2.</p><p>The inductive rules defining the extended judgment are exactly the same as in our basic operational semantics, except that the annotation :n is added above the long arrow and the rule for unfolding the method body is replaced by</p><formula xml:id="formula_15">Norm s¼ body C sig-v:n ½ Norm s¼ Methd C sig-v:n•1 ½</formula><p>reflecting the increase of the recursive depth due to method calls.</p><p>The original and refined versions are equivalent in the following sense:</p><formula xml:id="formula_16">t w ¼ iff n. t:n w ¼</formula><p>This can be shown by rule induction for each direction. The 'only if' direction relies on the fact that the recursive depth is monotone:</p><formula xml:id="formula_17">n m t:n w ¼ t:m w ¼</formula><p>Note that validity is monotone in the opposite direction:</p><p>m n n:t m:t</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.">Liftings</head><p>The validity of a single triple canonically carries over to sets of triples: meaning that a set of triples ts is valid up to any given recursive depth under the assumption that the set A is valid up to the same depth. Note the different type parameters for the sets of triples in the antecedent and in the consequent. This emphasizes that they may have different types of auxiliary variables. Unfortunately, due to the restriction mentioned in Ü5 and the rules ×Ñ and Å Ø (given below) which short-circuit the type variables, antecedents and consequents in the rules are restricted to identical types.</p><p>We abbreviate the validity of a single triple under a set of assumptions as</p><formula xml:id="formula_18">,A t ,A t</formula><p>Note that our definition for ,A ts is weaker than the version one might expect, viz.</p><p>´ n. n:Aµ</p><p>´ n. n:tsµ</p><p>Yet for an empty set of assumptions, both variants are equivalent, and , t gives the standard notion of validity in the sense that it effectively forgets about the recursive depth:</p><formula xml:id="formula_19">, P t Q iff n. n: n: P t Q iff n. t¾ P t Q . n:t iff Y Z Y ¼ ¼ . P Y Z type ok t t ´Y ¼ , ¼ µ Q Y ¼ ¼ Z</formula><p>The derivability judgments have the general form prog,´¬µtriples ´«µtriples but for the standard case of a single triple in the consequent we use the abbreviation ,A t ,A t</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Structural Rules</head><p>As for any Hoare-style logic, there are a number of structural rules applicable for any kind of term: rules for handling antecedents and multiple consequents, exceptions, and the rule of consequence. Many logics involve further rules handling variables and logical connectives within the assertions, but with a strong rule of consequence at hand they are not actually necessary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.">Handling Consequents</head><p>The first two rules deal with deriving finite sets of triples, which is done one by one, until finally the empty set is reached:</p><formula xml:id="formula_20">Ò× ÖØ ,A t ,A ts ,A t ts ÑÔØÝ ,A</formula><p>As opposed to introducing sets of triples in the consequent, one may throw away triples using Û Ò ,A ts ¼ ts ts ¼ ,A ts</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.">Handling Assumptions</head><p>Assumptions are introduced using the Å Ø rule (cf. Ü9.7.2) and exploited using the following rule:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>×Ñ ts A ,A ts</head><p>There is also a rule for throwing away assumptions, by shrinking the assumption set</p><formula xml:id="formula_21">A to A ¼ : ´Ø Òµ ,A ¼ ts A ¼ A ,A ts</formula><p>It does not need to be asserted, but can be derived (with rule induction) from the others Ý . If we had given the simpler but less convenient rule</p><p>´ ×Ñ ¼ µ</p><formula xml:id="formula_22">,A A</formula><p>for exploiting assumptions, the Ø Ò rule could no longer be derived.</p><p>The ÙØ rule is admissible (i.e. valid) but not derivable:</p><p>´ ÙØµ ,A ¼ ts ,A A ¼</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>,A ts</head><p>It could be added for convenience, yet we leave it out since it is not strictly necessary for completeness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.">Abrupt Termination</head><p>In Java, the concept of abrupt termination is used to describe the effects of break, continue and return statements as well as exceptions. Currently we treat only the most important one, exceptions. We provide result expressions to be evaluated at the end of each method body, and the three kinds of statements just mentioned have to be emulated by suitable conditional statements. Yet we plan to support them directly in the near future, as it should be straightforward to handle them using our exception mechanism, which would be an optimization of the approach given in <ref type="bibr" target="#b25">[26]</ref>: the type of exceptions xcpt just has to be generalized to include the three additional sources of abrupt termination, and suitable catching constructs have to be added to the rules for loops and method calls. The remainder of this subsection motivates and briefly describes our approach for dealing with exceptions.</p><p>Many axiomatic semantics in the literature leave out exceptions and thus cannot infer anything in case of exceptional states. Poetzsch-Heffter and Müller are extending their work <ref type="bibr" target="#b50">[51]</ref> to include them. If modeled, exceptions are often given a more exceptional state than they deserve. For instance, in the transition semantics of Drossopoulou and Eisenbach <ref type="bibr" target="#b12">[13]</ref> exceptions are regarded as a special form of terms. Thus, a syntactic trick called "expression contexts" has to be used to describe exception propagation in a uniform way. Huisman and Jacobs <ref type="bibr" target="#b25">[26]</ref> model the result state of expressions and statements with an outer distinction between hangup, normal completion, and abnormal completion, while giving the store as a parameter where appropriate. This violates the principle of uniformity and thus adds clutter through the omnipresence of case distinctions on the state in their model. Moreover, the axiomatic semantics based on this model uses special kinds of Hoare triples (each with its own version of validity) for reasoning about exceptions, which at least doubles the number of rule variants needed. The different versions of validity have recently been unified <ref type="bibr" target="#b29">[30]</ref>, but the redundancy within each rule remains. Leino <ref type="bibr" target="#b35">[36]</ref> distinguishes between normal and exceptional postconditions. This leads to repetition of (parts of) the assertions needed during program verification.</p><p>We deal with exceptions in a very simple and straightforward way: like in our operational semantics, the exception status is part of the program state. Thus it is available within the assertions basically the same way as any variable and heap contents are, and we may re-use predicates on the state like normal for the axiomatic semantics.</p><p>In order to describe the propagation of exceptions we use the generic rule ÔØ ,A P ´arbitrary3 tµ . Not AE normal t P stating that if an exception has occurred, the current command term t is ignored (as well as the result entry) and thus the state is not changed. Just a suitable dummy result is generated. All other rulesexcept for the ÄÓÓÔ rule -may assume that the initial state is normal (using the predicate transformer Normal), i.e. they have the general form</p><formula xml:id="formula_23">Normal P ¼ t½ Q Q t¾ Normal P t R</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4.">Rule of Consequence</head><p>Kleymann suggests [52, Ü4.1 and 4.3] a rule of consequence that is stronger than the usual one because it allows to adapt the values of auxiliary variables as required. In the context of recursion this helps to avoid incompleteness and introduction of ad-hoc rules of adaptation. Hofmann <ref type="bibr" target="#b18">[19]</ref> gives a rule that is even a bit stronger. After transforming his rule to our setting, simplifying it a bit and adding result value handling, it reads as</p><p>´ ÓÒ× Õ½¾µ</p><formula xml:id="formula_24">,A P ¼ t Q ¼ Y Z Y ¼ ¼ . P Y Z ´ Y Z ¼ . P ¼ Y Z ¼ Q ¼ Y ¼ ¼ Z ¼ µ Q Y ¼ ¼ Z ,A P t Q Copyright c</formula><p>2001 John Wiley &amp; Sons, Ltd.</p><p>Concurrency: Pract. Exper. 2001; 0:1-0 Prepared using cpeauth.cls For symmetry, its second premise can be formulated equivalently as</p><formula xml:id="formula_25">Y ¼ ¼ . ´ Y Z. P ¼ Y Z Q ¼ Y ¼ ¼ Zµ ´ Y Z. P Y Z Q Y ¼ ¼ Zµ</formula><p>Intuitively, it states that the validity of the triple involving P ¼ and Q ¼ implies the validity of the triple involving P and Q. To this end, the usual conditions P µ P ¼ and Q ¼ µ Q are sufficient but not necessary.</p><p>It will turn out that for completeness we further need (derivatives of) the rule</p><formula xml:id="formula_26">´ × Ô µ Y Z. P Y Z ,A Y ¼ ¼ Z ¼ . ´Y ¼ , ¼ µ Ý, µ t Y Z ¼ . Q Y Z ,A P t Q</formula><p>We call it × Ô rule since it enables extrusion of the result entry, state, and auxiliary variables from the triple's precondition such that P can be used as an assumption on the meta-logical level governing the rest of the triple. This is essential in particular when dealing with dynamic binding where code depends on the state. Simple consequences of the × Ô rule are the following two:</p><p>´ ÓÒ×Ø ÒØµ C ,A P t Q</p><formula xml:id="formula_27">,A P . ´ . Cµ t Q ´ ÑÔÓ×× Ð µ ,A Y Z. False t Q</formula><p>As already described in <ref type="bibr" target="#b43">[44]</ref>, we noticed that rather than asserting the rules ÓÒ× Õ½¾ and × Ô , it is possible to give an even stronger rule of consequence from which these two may be derived:</p><formula xml:id="formula_28">ÓÒ× Õ Y Z. P Y Z ´ P ¼ Q ¼ . ,A P ¼ t Q ¼ ´ Y ¼ ¼ . ´ Y Z ¼ . P ¼ Y Z ¼ Q ¼ Y ¼ ¼ Z ¼ µ Q Y ¼ ¼ Zµµ ,A P t Q</formula><p>This version is the strongest possible one since it directly reflects the semantics of the pre-and postconditions involved, as can be seen when conducting its soundness proof. Note that it allows choosing the pre-and postconditions of the inner triple, P ¼ and Q ¼ , under the assumption P and depending on its parameters Y, , and Z.</p><p>Common structural rules such as ´ØÖ Ú Ðµ</p><formula xml:id="formula_29">,A P t Y Z. True ´ × µ ,A P½ t Q½ ,A P¾ t Q¾ ,A Y Z. P½ Y Z P¾ Y Z t Y Z. Q½ Y Z Q¾ Y Z</formula><p>are no longer required at all and may be derived easily if desired. In contrast, two other derived rules are quite handy, namely the restriction of the rule of consequence to either the pre-or postcondition:</p><p>´ ÓÒ× Õ½µ ,A P</p><formula xml:id="formula_30">¼ t Q P µ P ¼ ,A P t Q ´ ÓÒ× Õ¾µ ,A P t Q ¼ Q ¼ µ Q ,A P t Q Copyright c</formula><p>2001 John Wiley &amp; Sons, Ltd.</p><p>Concurrency: Pract. Exper. 2001; 0:1-0 Prepared using cpeauth.cls</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Universal Quantification</head><p>In the rules given in the next section we will use several techniques introducing and exploiting universal quantification around triples in the rules' premises. Their common purpose is to extend the scope in which values are visible in order to reflect dependencies between different pre-and postconditions. The techniques may be nested and combined with each other: for instance, the rule for method calls (cf. Ü9.7) applies all of them on a single triple. We classify the techniques by the source of the values, as follows.</p><p>State Extrusion is of the form z. ,A P z .</p><p>´ . z f µ t z Q z , which means picking some part of the state (using some function f) in the precondition, binding it to a variable z, and using it anywhere within the triple. This technique is useful e.g. to save, modify locally to t, and restore local variables. It is very similar to a technique within the MGF approach that will be explained in Ü11.1, the difference being that there implicit quantification of auxiliary variables is used.</p><p>Result Extrusion, already introduced in Ü4. Value Passing involves two triples:</p><formula xml:id="formula_31">z. ,A P z t½ z Q z and z. ,A f ´Q zµ z t¾ z R z where f is an assertion transformer modifying Q z. It is logically equivalent to z. ,A P z t½ z Q z ,A f ´Q zµ z t¾ z R z</formula><p>and thus simply extends the scope of z to the second triple. This is useful for passing on previously obtained values to other triples.</p><p>An interesting issue is how the bound variables are actually used because this affects the usability and completeness of the resulting Hoare logic. There are again three cases:</p><p>State Transformation uses the bound variables to change the state within a pre-or postcondition, typically by applying the assertion transformer .; . Result Generation uses the values to compute results to be entered in the result component of a postcondition, typically by applying the assertion transformer . Term Dependence means, syntactically speaking, that the term between the pre-and postcondition is an expression actually referring to the bound variables.</p><p>The first two uses are harmless: in applications one has to derive triples of the form z. ,A P z t Q z (where t does not depend on z) for all potential values of z. Concerning the Hoare logic rules, this can be done in a uniform way for some fixed but arbitrary value z because the shape of the triple is the same for all z. Only the proofs of side conditions that possibly emerge when using the rule of consequence might require enhanced proof principles like a (local) induction over z. Yet for these proofs we can assume the full power of predicate logic anyway since we consider relative completeness, as motivated in Ü4.1.</p><p>The third use, dependent terms, is problematic because the triples involved have the form z. ,A P z t z Q z where the term t z does depend on z such that uniform rule application is not possible. The only other option for a finitary proof within Hoare logic is to explicitly enumerate all possible cases for z, where of course the variety has to be finite. Often this is easy because the type of z is bool (or some other finite type). The other option is to derive from the precondition P z, typically by applying the × Ô rule, that only finitely many values for z -commonly even just one -are actually possible. Then the proof proceeds by constructing a finite set (or superset) of the possible values and derive the triple for each of its members where the term expression t z, as well as the assertions P z and Q z, can be reduced to something not mentioning the variable z anymore.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Java-specific Rules</head><p>This section contains the main part of our axiomatic semantics, namely the Hoare-style rules for each kind of Java term.</p><p>We have designed each rule (except for ÄÓÓÔ) such that its final postcondition is given by a predicate variable only. Thus application of the rules in the typical "backward-proof" style of Hoare logic is simplified because we avoid the need for applying the rule of consequence in order to adapt the syntactical form of the postcondition, which normally requires awkward explicit instantiations. In other words, the weakest precondition of a given postcondition is typically generated automatically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.1.">Standard Statements</head><p>Thanks to our implicit exception propagation mechanism, the rules for the standard statements appear almost as usual.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ë Ô</head><p>,A Normal ´P ¯µ .Skip. P</p><p>In order to obtain soundness w.r.t. our notion of validity, here (and in a few other rules) we have to mention explicitly the dummy result of statements, ¯. In applications this is no harm since pre-and postconditions of statements do not refer to the result entry anyway.</p><p>ÓÑÔ ,A Normal P .c½. Q ,A Q .c¾. R ,A Normal P .c½;c¾. R For expression statements, the result of the expression is discarded using the operator:</p><formula xml:id="formula_32">ÜÔÖ ,A Normal P e-Q ¯ ,A Normal P .Expr e. Q</formula><p>For terms involving a condition we define the Boolean result substitution operator</p><formula xml:id="formula_33">P b Y Z. v. ´P Val vµ Z ´normal the Bool v bµ</formula><p>which is a variant of the operator expressing that, unless an exception has been thrown, the result of the preceding Boolean expression is b. Using it in conjunction with the result extrusion technique introduced in Ü8 and the meta-level conditional expression if b then else , we can describe both branches of conditional terms with a single triple, like in What is a notational convenience here (to avoid two triples, one for each branch), will be essential for the ÐÐ rule, given below (cf. Ü9.7).</p><p>Another application of the Boolean substitution for case distinctions is ÄÓÓÔ ,A P e-P ¼ ,A Normal ´P ¼ Trueµ .c. P ,A P .while´eµ c. ´P ¼</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Falseµ ¯</head><p>The loop body needs to be verified only if no exception has been thrown meanwhile and the Boolean expression e yields True. Upon termination e yields False (unless an exception has occurred). Here both P and P ¼ play the role of the loop invariant, where P ¼ is typically equivalent to P, at least if e does not have side-effects.</p><p>Here, in order to achieve completeness, we have to give P rather than Normal P as the precondition of the triple in the rule's conclusion because it should be the same as the invariant P and in general the invariant cannot maintain the absence of exceptions. Furthermore, also for ensuring completeness, here we have to deviate from the principle of having as the final postcondition a predicate variable only. Thus applying the rule of consequence will be necessary here, but this does not cause extra nuisance since finding and inserting suitable invariants P (and P ¼ ) requires manual engagement anyway.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.2.">Exception Handling</head><p>The rule for the throw statement modifies the postcondition Q by updating the exception component of the state with the reference just evaluated. Ì ÖÓÛ ,A Normal P e-Val a :. xupd ´throw aµ .; Q ¯ ,A Normal P .throw e. Q</p><p>If no exception has already occurred meanwhile and the evaluated reference a is not Null (in which case a NullPointer exception is raised), the auxiliary function throw a assigns the reference to the exception component of the state.</p><p>When describing the effect of the statement try c½ catch´C vnµ c¾ we have to distinguish whether in the state after executing c½ an exception of appropriate (dynamic) type, viz. a subclass of C, is present, as denoted by , catch C. Only if this is the case, the statement c¾ is considered with its exception parameter vn set (using the function new xcpt var) to the caught exception. Otherwise, the final postcondition R has to be implied immediately. where</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ÌÖÝ</head><formula xml:id="formula_34">SXAlloc P Y Z. ¼ . sxalloc ¼ P Y ¼ Z</formula><p>The auxiliary relation sxalloc is a peculiarity of our model used to describe the allocation of exception objects for standard exceptions.</p><p>The rule for the finally statement needs to transfer the exception status before executing the second substatement to the postcondition where it is combined with the current exception status, producing the final status: if one exception occurs in either clause, it is (re-)raised after the statement, and if both parts throw an exception, the first one takes precedence. In earlier versions of our axiomatic semantics, we employed a special result stack entry to transfer the exception status (denoted by fst here), but this is not necessary: it suffices to apply the state extrusion technique, as explained in Ü8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ò</head><p>,A Normal P .c½. Q x. ,A Q . ´ . x fst µ ;. xupd ´ x. Noneµ .c¾.</p><p>xupd ´ x ¼ . if x None x ¼ None then x else x ¼ µ .; R ,A Normal P .c½ finally c¾. R</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.3.">Class Initialization</head><p>The static initialization of classes is an unpleasant feature to model as its structure depends on the class hierarchy and it is not syntax-driven but rather triggered on demand. Thus at several places, e.g. field access and method calls, one has to consider potential initialization of some referenced class C, which we denote by the special statement init C.</p><p>If the class in question is already initialized, there is nothing to do: Note that the values of sc, ini and super depending on C are known statically and thus application of this rule simplifies immediately.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.4.">Simple Expressions</head><p>As already motivated in Ü4. Variable access is the first example where the result entry is a variable. Here we just need its first component, which is the current value of the variable. The rule for variable assignment uses the result extrusion technique to refer to the resulting of va. The rule for conditional expressions parallels the one for conditional statements:</p><p>ÓÒ ,A Normal P e¼-P ¼ b. ,A P ¼ b ´if b then e½ else e¾µ-Q ,A Normal P e¼ ? e½ : e¾-Q</p><p>A type cast merely evaluates its argument and raises an exception if the dynamic type of the result happens to be unsuitable:</p><formula xml:id="formula_35">×Ø ,A Normal P e-Val v :. s.. xupd ´raise if ´ ,s v fits Tµ ClassCastµ .; Q Val v ,A Normal P Cast T e- Q</formula><p>Similarly, the type comparison operator flags whether the type of its argument is assignable to the given reference type:</p><p>ÁÒ×Ø ,A Normal P e-Val v :. s.. Q Val ´Bool ´v Null ,s v fits RefT Tµµ ,A Normal P e instanceof T-Q</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.5.">Object Creation</head><p>Allocating an object on the heap requires lifting the halloc relation (allocating a fresh object with the given tag on the heap and initializing it) to the assertion level in analogy to the SXAlloc transformer given above. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>AE Û</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.7.">Method Call</head><p>A rather complex issue within an axiomatic semantics in general is mutual recursion. For an objectoriented language, dynamic binding in method calls gives a further challenge. This subsection motivates and describes the axiomatic semantics for method calls t,md,mode e..mn´ pTs argsµ where e is the receiver expression, mn the method name, args the argument list, mode the invocation mode, and the remaining parts in braces are type annotations: t is the type of e, md the defining class of the method found at compile time, and pTs the list of its parameter types, which is used to resolve static overloading.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.7.1.">Dynamic Binding</head><p>Handling dynamic binding for method calls is difficult for two reasons. First, the actual method to be called depends on the class D dynamically computed from the receiver e and thus in general cannot be inferred statically. The usual technique for dealing with term dependence, as done e.g. for the standard Hoare rule for conditional statements, is to statically enumerate all possible values. We cannot use it for D because the variety of possible values is large -but finite because it is bound by the total number of methods in the given program -and not fixed locally since it depends on the class hierarchy. We handle this problem with the state extrusion and term dependence technique introduced in Ü8, introducing universal quantification for D and the precondition</p><p>´ ´x,sµ. D target mode s a md µ binding D. An alternative solution is given by Poetzsch-Heffter and Müller in <ref type="bibr" target="#b50">[51]</ref>, where D is referred to via This and the possibly large range of values for D is handled by an abstraction which they call virtual methods. Verifying such methods amounts to show (in a cascadic way using two special rules) that all possible implementations fulfil the property required for the method call.</p><p>Second, one should be able to assume that for invocation mode interface or virtual the actual value D is a subtype of t, the (static) type of e. The intuitive -but absolutely non-trivialreason why the relation Class D RefT t holds is of course type safety. The problem here is how to establish this relation. The rules given in <ref type="bibr" target="#b50">[51]</ref>, for example, put the burden of verifying the relation on the user, which is a legal option, but in general not practically feasible. In contrast, our solution makes the relation available to the user as a helpful assumption, which transfers the proof burden once and for all to the soundness proof on the meta-level.</p><p>We write the subtype relation in the form A minor further complication is that we have to transfer the result a of the expression e not to the triple directly following but to the one after it. We can cope with this by combining the result extrusion and value passing techniques.</p><p>The remaining parts of the method call rule deals with the unproblematic issues of argument evaluation, setting up the local variables (including parameters) of the called method and restoring the previous local variables on return, for which we use the universally quantified variable l. The above rule is general enough to handle all sorts of method calls, also static ones and those relative to interfaces or super. One may derive simpler specialized versions of the ÐÐ rule, for example for static method calls:</p><p>´ ÐÐËµ Note that the rule can ignore (applying ) the value of e, and the free variable a acts as a dummy parameter of the function init lvars.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.7.2.">Mutual Recursion</head><p>We cope with recursive calls adopting the standard solution of introducing Hoare triples as antecedents within the derivation judgments. Thanks to the well-known recursion rule (see e.g. [4, Ü3.2] and <ref type="bibr" target="#b50">[51]</ref>), within an unfolded method body one may appeal to a suitable assumption catering for all further recursive calls. As discussed in <ref type="bibr" target="#b43">[44]</ref>, the recursion rule is sufficient for completeness, but its nested application required for mutual recursion in general gives rise to replication of proofs for part of the methods involved. This nuisance can be overcome with rules that allow simultaneous rather than nested verification. One such rule is given by Homeier and Martin in <ref type="bibr" target="#b23">[24]</ref>. Since they aim at verification condition generation, they designed a rule for verifying all procedures contained in a program simultaneously, which requires the user to identify in advance a single specification for each method suitable to cover all invocation contexts. Our rule can also be used to verify all methods at once, but is more flexible for interactive verification: each time a call to a cluster of mutually recursive procedures is encountered, it allows verifying simultaneously as many (and no more) procedures as desired and to identify the necessary specifications locally.</p><p>The Å Ø rule allows verifying the specifications of a set of methods ms (or to be exact, method implementations) simultaneously by verifying their expansions, that is, the corresponding method bodies <ref type="bibr" target="#b48">[49]</ref>. It is vital that when encountering recursive calls during the verification of the bodies, one can assume that the method implementations already fulfil their specifications. This explains why method implementations are separated from method bodies, something that would not be necessary for the underlying operational semantics itself.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Å Ø</head><formula xml:id="formula_36">,A P Methd-Q ms P body - Q ms ,A P Methd- Q ms where P tf-Q ms ´ ´C,sigµ. Normal ´P C sigµ tf C sig- Q C sig µ ms</formula><p>yields a family of method triples indexed by the set ms (consisting of pairs of a class and signature).</p><p>Both the assertions P and Q and the term function tf depend on the index values given by ms, such that members like</p><formula xml:id="formula_37">Normal ´P C sigµ Methd C sig- Q C sig</formula><p>are generated. The structural rules for handling antecedents and sets of triples in the consequent have been described in Ü7.</p><p>The function body (cf. Ü3.5) and the constructor Body for intermediate body terms have been introduced because the Å Ø rule above is already complex enough. After the function body has obtained a class name and a signature during applications of the Å Ø rule, handling the method body is the same as in the operational semantics: the expression body C sig calculates the intermediate term Body D c e with the entries for the defining class of the method, the actual method body, and the result expression. These are then processed sequentially using the rule Ó Ý ,A Normal P .init D. Q ,A Q .c. R ,A R e-S ,A Normal P Body D c e-S</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.7.3.">Virtual Methods, Specifications and Behavioral Subtyping</head><p>In our axiomatic semantics, interfaces play only an indirect role. This is due to the fact that in Java they have no semantics other than contributing to the type hierarchy on a purely syntactical basis, viz. the availability of methods. Furthermore, Java does not support method specifications nor behavioral subtyping, apparently because this is considered to be too difficult and to limit expressiveness.</p><p>From the methodological perspective it would be interesting to take into account behavioral subtyping. Doing so, one introduces specifications for all method declarations. The specification of a method declared within some class or interfaces type t has to be fulfilled by all method bodies implementing or overriding that method within t and any subtype of it. Then a derived rule for method calls can exploit the semantic subtyping as follows. For verifying calls to methods bound by the static type t of the receiver expression (as given in the type annotation of the call) one only has to show that the corresponding specification fulfils the requirements in question, rather than directly showing them for all method implementations in subclasses of t. This approach would be particularly helpful when addressing modularity for proofs: when adding new classes to an already verified program, none of the finished proofs has to be re-done; only the new implementation relations have to be verified.</p><p>Note that the "virtual methods" approach mentioned above (cf. Ü9.7.1) is similar in the sense that method calls and dynamic binding are decoupled, but does not impose the restrictions of behavioral subtyping. Thus this approach in itself cannot support modular verification in the way just given. However, when proof obligations on program extensions are added (in the form of assumptions to be eliminated after the program is freezed), as explained by Müller <ref type="bibr" target="#b38">[39]</ref>, modular verification is supported in a rather flexible way. A further source of flexibility is that the method specification to be proved for a given call may be generated from the call itself or may be derived from an independent general specification of that virtual method.</p><p>Our approach using the ÐÐ rule leads to essentially the same verification steps as the "virtual methods" approach and also allows the use of assumptions. Thus at least in principle the methodology developed by <ref type="bibr" target="#b38">[39]</ref> can be applied as well, though the "virtual methods" approach supports this more explicitly and conveniently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.8.">Expression Lists</head><p>Lists of expressions are dealt with canonically. Just note that in Isabelle/HOL the empty list is written and the 'cons' operator is the infix ' '.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>AE Ð</head><formula xml:id="formula_38">Normal P Vals P ÓÒ× ,A Normal P e- Q v. ,A Q Val v es</formula><p>Vals vs :. R Vals ´v vsµ ,A Normal P e es R</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.9.">Critical Review</head><p>The inductively defined Hoare logic rules given in this section precisely cover the axiomatic semantics of Java Ø . Unfortunately, they are not easy to read and to apply by hand. The reason for this is the inherent complexity of the language, requiring in particular non-trivial transformations of the state. On the other hand, the format of our rules should facilitate the construction of an automatic verification condition generator, and our experience with example proofs (Ü12) shows that even for rather complex assertions the theorem proving system deals with proof obligations mostly automatically.</p><p>One might also get the impression that our axiomatic semantics is rather close to the operational semantics. We believe that this similarity is not intrinsic but due to our use of the same state transformers as for the operational semantics. We do this for simplicity in conjunction with our semantical notion of assertions, but it should be possible to give a more syntactic notion of assertions and corresponding rules that do not refer to any concept of the operational semantics. The general advantages of a Hoare logic over the operational semantics for program verification, namely concentration on the actually relevant properties of the state and powerful tools for dealing with loops and recursion, are fully realized by our axiomatic semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">Soundness</head><p>A Hoare logic that is unsound would be useless since its very purpose is to verify correctness of programs. Thus after giving a Hoare logic the proof of its soundness is obligatory, in particular when -like in our case -the rules are rather involved and thus their correctness is by far not obvious.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.1.">General Approach</head><p>The ultimate goal for proving soundness of our axiomatic semantics w.r.t. the operational semantics is wf prog , t , t</p><p>i.e. any triple t that is derivable from the empty set of assumptions is valid. The additional premise that the program is well-formed is required to show soundness of the method call rule requiring type safety, as explained in Ü9.7.1 and 10.3.</p><p>The soundness goal is a direct instance of wf prog ,A ts ,A ts which can be shown as usual by rule induction on the derivation of . The different cases emerging in the induction are basically straightforward, with a few notable exceptions. Since the ÄÓÓÔ rule involves a loop invariant rather than unfolding the loop as done for the operational semantics, it requires an auxiliary rule induction on the derivation of the evaluation judgment as contained in the definition of validity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.2.">Method Implementation Rule</head><p>The Å Ø rule demands special treatment because it adds assumptions about recursive calls, such that an (inductive) argument on the depth of these calls is needed in order to avoid circularities. This could be achieved by syntactic manipulations that unfold procedure calls up to a given depth Ò, as done e.g. in <ref type="bibr" target="#b18">[19]</ref>. Instead, we prefer a semantic approach inspired by the proofs given in <ref type="bibr" target="#b50">[51]</ref> and <ref type="bibr" target="#b31">[32]</ref>: employing the notion of recursive depth already introduced in Ü6.2. Induction on the recursive depth boils down to showing in the base case</p><formula xml:id="formula_39">0: Normal P Methd C sig- Q</formula><p>and in the inductive step</p><formula xml:id="formula_40">n: Normal P body C sig-Q n•1: Normal P Methd C sig- Q</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.3.">Method Call Rule and Type safety</head><p>The ÐÐ rule is not only bulky (and thus it helps to treat this case separately from the main rule induction) but also raises major semantical complications. Interestingly, type safety plays a crucial role here: The important fact that for virtual method calls the relation mode D rt holds, can be derived in general only if the method call is well-typed and the state in which the class D has been dynamically looked up conforms to its environment.</p><p>In order to obtain the desired conformance property, one essentially has to keep it as an invariant. But rather than requiring the user to prove this property over and over for each program to be verified, we built it -together with well-typedness -into our notion of validity (cf. Ü6.1) in the form of the judgment type ok. This also gives rise to a new rule:</p><formula xml:id="formula_41">Þ Ö ,A P . Not AE type ok t t Q</formula><p>The rule, which will be required for the completeness proof, indicates that if at any time conformance was violated, anything could happen -something that is in line with our intuition on erroneous program execution.</p><p>Including conformance (and well-typedness) into validity complicates the proof of soundness, because now we have to show that it is an invariant property of any valid triple, affecting each case of the main rule induction, not only the one for method calls. Fortunately, we have already proved type soundness for the operational semantics, as described e.g. in <ref type="bibr" target="#b47">[48]</ref>:</p><formula xml:id="formula_42">wf prog t ´w, ¼ µ £ T.</formula><p>´ ,£µ ´ ,£µ t T ¼</p><p>´ ,£µ ´normal ¼ ,snd ¼ w Tµ</p><p>For a well-formed program, if evaluation of a well-formed term terminates and the initial state conforms to its environment, so does the final state, and the result conforms to the type of the term if no exception has been thrown. Making use of this theorem can be simplified -yet not hidden completely -by using for the main induction actually a variant of our validity notion, namely</p><formula xml:id="formula_43">n: P t Q Y Z. P Y Z £ T. ´ ,£µ ´normal ´ ,£µ t Tµ Y ¼ ¼ . t:n ´Y ¼ , ¼ µ Q Y ¼ ¼ Z ¼ ´ ,£µ</formula><p>One can show easily, exploiting type soundness, that for well-formed programs this variant is equivalent to the original one. Even with this variant, parts of the type soundness proof have to be repeated, e.g. to derive well-typedness of the static initializer invoked for class initialization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">Completeness</head><p>The proof of completeness, stating that the given Hoare logic is useful (at least from the theoretical perspective), is much more challenging than the proof of soundness. We give the outline of the proof in a bit more detail since it is the first such proof for an object-oriented language. We benefit heavily from the MGF approach which is described below. We extend this approach, which was given for only a single recursive procedure, to mutually recursive methods and static initialization using auxiliary inductions. As discussed in <ref type="bibr" target="#b43">[44]</ref>, when dealing with mutual recursion some complications arise, which could be overcome in three different ways, each with specific advantages and drawbacks. Here we implement the first two variants involving structural induction that either is nested as deep as the number of methods involved or handles all these methods simultaneously. The third variant, not used here, employs rule induction on the operational semantics, which is more powerful and would save a lot of effort avoiding the auxiliary inductions. On the other hand, it requires an unpleasant unfolding variant of the ÄÓÓÔ rule and an additional divergence rule. Thus it is probably too tightly connected to the operational semantics, and the employment of rule inductions makes its usability at least doubtful in the light of the proof-theoretical remarks given in Ü11.5.</p><p>Our ultimate goal for proving (relative) completeness is to show that for a well-structured program, any valid triple is derivable from the empty set of assumptions:</p><formula xml:id="formula_44">ws prog , t , t</formula><p>The well-known approach involving weakest preconditions wp t Q for a given term t and postcondition Q cannot be pursued here, because when verifying recursive method calls the postcondition changes such that structural induction on t does not go through.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.1.">MGF Approach</head><p>The Most General Formula (MGF) approach was introduced by Gorelick <ref type="bibr" target="#b15">[16]</ref> and promoted by Apt <ref type="bibr" target="#b3">[4]</ref>, Kleymann <ref type="bibr" target="#b31">[32]</ref> and others.</p><p>For partial correctness, the MGF of a term t gives for the most general precondition (which just remembers the initial state) the strongest postcondition, which is the operational semantics of t. More precisely, the MGF of t in the context of a program is defined as </p><formula xml:id="formula_45">Y ¼ ¼ . t:n ´Y ¼ , ¼ µ Q Y ¼ ¼ Zµµ ´ Y Z. P Y Z type ok t ´ Y ¼ ¼ . t ´Y ¼ , ¼ µ Q Y ¼ ¼ Zµµ</formula><p>which is a rather trivial predicate-logical theorem, exploiting the fact</p><formula xml:id="formula_46">t ´w, ¼ µ ´ n. t:n ´w, ¼ µµ</formula><p>The main lemma is proved basically by structural induction. Complications arise because for method calls as well as class initialization the terms involved do not become structurally smaller. To solve the problem we employ auxiliary inductions on the number of methods not yet verified and on the number of classes not yet initialized, as explained in the two following subsections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.2.">Mutual Recursion</head><p>The idea for handling mutual recursion is as follows. First prove derivability of the MGF under the assumption that it has already been proved for all methods:</p><formula xml:id="formula_47">Å ×Ñ ´ C sig. is methd C sig ,A Methd C sig- µ ,A t</formula><p>Then prove Å Ö Ú applying the lemma, the Å Ø rule, which supplies the required assumptions for the methods, and the ×Ñ rule for exploiting them. There are two alternatives for collecting the assumptions. Both alternatives rely on the fact that for a well-structured program the number of methods to consider is finite:</p><formula xml:id="formula_48">¬Ò Ø × Ñ Ø ws prog finite ´C,sigµ. is methd C sig</formula><p>It is interesting to note that for the whole proof of completeness -in contrast to soundness -wellformedness is not required at all, and the only occasion where we need well-structuredness is to ensure finiteness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.2.1.">Nested Version</head><p>One alternative is to use the classical recursion rule that adds just one assumption per application: The induction scheme has been inspired by Hofmann <ref type="bibr" target="#b19">[20]</ref>. His lecture notes <ref type="bibr" target="#b18">[19]</ref> further contain a proof of completeness using the MGF approach for the language IMP augmented by a single procedure, which we have simplified and extended for our purposes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.2.2.">Simultaneous Version</head><p>We invented the Å Ø rule that allows handling procedures simultaneously not only in order to simplify applications, but also to make the complicated nesting scheme of the first version dispensable for the meta-theoretic completeness proof. Using its power, the second version becomes rather straightforward. In this case, the ÙØ rule would be convenient, but it can be circumvented by employing the derived rule</p><formula xml:id="formula_49">F U finite U ´´ ´C,sigµ¾F. ,A f C sigµ ´ ´C,sigµ¾U. ,A g C sigµµ ,A ´ ´C,sigµ. f C sigµ F ,A ´ ´C,sigµ. g C sigµ F</formula><p>which is proved by induction on the size of U. On application, both F and U get instantiated to ´C,sigµ. is methd C sig , so finiteness of the number of methods is vital also here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.3.">Static Initialization</head><p>Now it remains to show ,A t under the assumption that the MGFs for all proper methods are derivable:</p><formula xml:id="formula_50">C sig. is methd C sig ,A Methd C sig-</formula><p>The precondition of the assumption can be discharged because due to the relation type ok in our notion of validity, we get the fact that Methd C sig is well-typed for free. Furthermore, all well-typed methods are proper, as follows easily from the corresponding definitions: </p><formula xml:id="formula_51">ÛØ Å Ø × Ñ Ø ´ ,£µ Methd C sig -T is methd C sig</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.4.">Main Induction</head><p>Finally, we have collected enough assumptions such that the main induction will go through. We show</p><p>´ n C sig. ,A :n Methd C sigµ</p><p>´ m. m n ´ t. ,A :m t µµ ,A :n t by structural induction on t. We comment on the most interesting cases.</p><p>The first premise is exploited for handling the Methd expression itself and its application in the ÐÐ case simply by assumption. We prove the case of the initialization statement as the separate lemma</p><p>´ m. m n t. ,A</p><formula xml:id="formula_52">:m t µ ,A :n .init C.</formula><p>because it is needed several times, namely for all terms that involve potential class initialization. When applying the lemma, we can of course make use of the second premise. The actual use of the premise</p><p>´ m. m n µ is in the proof of the lemma: for handling the initialization of the superclass and the static initializer of the current class where we know that the current class is actually being initialized and thus the number of classes not yet initialized decreases. This proof is one of the rare cases where we take advantage of the implicit precondition that the current term (init C here) is well-typed and thus C is a proper class.</p><p>For the ÄÓÓÔ case, we employ an alternative formulation of the MGF, augmented by a predicate p in the precondition:</p><formula xml:id="formula_53">,A Normal ´ . pµ t ,A Normal ´´ Y Z. w ¼ . t w ¼ w ¼ Zµ . pµ t Y s Z. ´Y,sµ Z</formula><p>In the second line the auxiliary variable Z stores the result and final -rather than initial -state, which allows formulating a suitable loop invariant. We make use only of the "if" direction of the above equivalence, which is also the more interesting one: its proof relies on the facts that evaluation is deterministic and that there are at least two different program states. Note that the alternative version of the MGF has a different type of auxiliary variable, namely vals ¢ state. Therefore, we have to apply the ÓÒ× Õ and ÄÓÓÔ rules with rather general types. Yet due to the type restrictions of HOL mentioned in Ü5, the original rules from the inductive definition are not general enough, and thus we have to state variants of them with identical propositions but generalized types as axioms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.5.">Proof-theoretical Remarks</head><p>One might wonder if the implication proved, ws prog , t , t really means relative completeness, in the sense that for any given concrete program and valid triple t there is a derivation for t, requiring only finitely many applications of the Hoare logic rules plus a complete predicate logic for dealing with side conditions like in the rule of consequence.</p><p>One potential problem is the fact that the rules Å Ø and ÁÒ Ø yield structural expansion of terms rather than reduction of subterms, as already noted and dealt with in the previous subsections. Furthermore, it is a general property of inductively defined sets S that any proof tree for a theorem</p><p>x ¾ S has a finite height but possibly infinite width, for example if the definition of S contains a rule y. f y¾S z¾S where y is of an infinite type. Since in particular for our inductively defined relation , there are rules involving universal quantifications on possibly infinite domains, for example parts of the program state, we cannot be sure a priori that any proof of ,A ts is finitary.</p><p>Thus we have to ensure ourselves of finiteness by other, more specific means, which we do in two different ways.</p><p>¯The formalistic answer is that in our proof of completeness we only use the Hoare rules mentioned in Ü7 and Ü9, structural induction on terms, and induction on the number of methods and the number of uninitialized classes (both of which are finite). All remaining steps are term rewriting and finitary predicate-logical derivations (involving e.g. the rules of the operational semantics in order to derive the postcondition of the MGF), and in particular we do not employ rule induction. ¯We additionally give a more constructive answer: a recursive procedure, inspired by our proof of completeness. It generates a proof outline for any (valid) goal , t, assuming that is wellstructured. We sketch the procedure (glossing over applications of the rules ÓÒ× Õ and ÔØ)</p><p>and argue informally that this procedure terminates and thus one can conclude that the proof is finitary.</p><p>Assume that M ´C,sigµ. is methd C sig is the set of methods in , the function spec tf ´C,sigµ. ´Pre C sigµ tf C sig-Post C sig forms a triple with the (most general) method specification, MSpecs spec Methd M abbreviates the set of all method specifications, and specb spec ´body µ gives the body of a method with its specification. Note that M and thus also MSpecs and specb M are finite. For showing , t we use the following initial proof tree. The program fragment consists of three simple but complete type declarations and a block of statements that might occur in any method body that has access to these declarations. All important features of Java Ø are taken into account.</p><p>We can prove that the test program fragment terminates (if at all -this is partial correctness) abruptly with an IndOutBound exception: That is, we derive from the empty set of assumptions that if initially there are at least four free locations on the heap and the classes Base and Ext are not initialized then after termination of the program the exception IndOutBound has been thrown. This property relies on a bunch of more or less implicit properties of the program control involving class initialization, dynamic binding, and actual values of method parameters. One could of course prove also other properties like ((Ext)e).vee == 0. This is because, taking dynamic binding into account, foo of Ext is called, which attempts to assign to the field vee through the null reference. The resulting exception is caught, and in the loop condition within the exception handler the static array arr, which has been initialized meanwhile, is accessed at a non-existing index.</p><p>We make our way through the control flow as directed by the syntax in the usual "backwards" style where the current postcondition is fully known and directs the instantiations of schematic variables typically contained in the precondition mostly automatically. That is, we can apply the syntax-directed Hoare logic rules mostly without making use of the rule of consequence and explicitly instantiating assertions. We have reached this desirable convenience by designing the rules such that the postcondition of the triple in their consequent consists (typically) solely of a free assertion variable that can always be instantiated as required in the application. Yet in a few places explicit instantiations are needed, and sometimes we deliberately use them in order to manually simplify assertions. This example proof takes about 130 steps, 50 of which are applications of syntax-directed Hoare logic rules. We apply the rule of consequence 13 times and do about 20 explicit instantiations of schematic assertion variables. The simplifier or classical reasoner (or their combination) is called about 40 times. One third of the proof deals with class initialization.</p><p>See [47, Ü6.3.4] for a commented proof outline. Unfortunately, many of the rules given are quite complex and thus apparently not easy to use. This is in part due to our semantical notion of assertions better suited for meta-theoretical investigations than for practical use. But the main point is that Java is an inherently difficult language, taking into account e.g. mutual recursion, dynamic binding, exception handling, and static initialization. This complexity inevitably carries over to the axiomatic semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Meta-theoretical Proofs</head><p>We have proven two main theorems.</p><p>Theorem 1. For well-formed programs our axiomatic semantics is sound w.r.t. its operational counterpart.</p><p>One interesting aspect of the proof of soundness is to find a suitable notion of validity capable of capturing an inductive argument on the recursive depth of procedure calls. The other noticeable thing is the insight that type safety is required to prove correct the rule for handling dynamic binding.</p><p>Theorem 2. For well-structured programs our axiomatic semantics is relatively complete.</p><p>The proof of completeness is non-trivial because next to structural induction it requires nested auxiliary inductions for handling mutual recursion and class initialization. The MGF approach has been successfully refined and applied. Well-formedness and well-typedness play only a minor role here.</p><p>Application As experience with our example shows, verifying programs heavily dealing with exceptions and class initialization is tedious, though further machine support might be a relief. Both our formalization and Isabelle itself as the underlying theorem proving system is tailored more towards meta-theory rather than proofs on concrete systems of realistic size. Thus largescale program verification would require adaptations of the model and extensions to the user interface and proof management, or possibly even transfer of the Hoare logic rules to a specialized integrated program development and verification tool like JIVE <ref type="bibr" target="#b37">[38]</ref>.</p><p>After all, using an axiomatic semantics like ours for program verification helps to concentrate on the interesting properties of a program (rather than fiddling with details of the state as with an operational semantics) and provides powerful tools for dealing with loops and recursion. This general experience carries over from procedural to object-oriented languages like Java.</p><p>Machine Support Both for formalizing the Hoare rules and conducting the meta-level proofs, the support of the theorem proving system was indispensable. With some 400 lines of theories and about 1600 lines of (already quite condensed) proof scripts on a highly complex subject, otherwise there would be plenty of opportunity for omissions and inaccuracies like type errors and inconsistencies. Moreover, the sheer number of definitions to keep in mind and inferences to perform by hand would be overwhelming. This is particularly true since within such a nontrivial project many iterations are performed, leading to frequent replay of the large proofs with often subtle, but possibly crucial differences. Due to the number of rules in the semantics, in the inductive proofs there are many cases involving a great amount of detail to be considered, for which the partial automation of the theorem prover is of great help.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="13.2.">Further Work</head><p>There are several ways in which this work can -and probably will -be extended and applied.</p><p>Extensions of the Model Two important features of the static semantics, name spaces and visibility control, are still missing. It should not be too difficult to add them to the formalization and adapt the proofs accordingly. This is part of the work to be done for the new European Project VerifiCard <ref type="bibr" target="#b28">[29]</ref>.</p><p>Program Verification Our Hoare logic is not yet fully suited for actual application in program verification. It should be helpful -and not difficult -to identify and deduce simpler specialized versions of many rules more convenient to apply in standard, e.g. exception-free, situations. Furthermore, better support by tailored verification tools like an automatic verification condition generator and an some advanced methodology for handling e.g. method specifications and object references will surely ease the pain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Support for Program Design</head><p>Within project Bali <ref type="bibr" target="#b41">[42]</ref>, work on verifying the implementation of high-level specifications is planned: formalizing the Object Constraint Language (OCL) of UML also within Isabelle/HOL and tightly connecting it with our axiomatic semantics. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Index</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>¯</head><label></label><figDesc>w :. P w Y. P Y Y peeks at the current result and passes it to P. ¯P Y Z. Y. P Y Z simply ignores the result. ¯P w Y :. P . ´ . Y wµ asserts that the current result is w and then ignores it. Copyright c 2001 John Wiley &amp; Sons, Ltd. Concurrency: Pract. Exper. 2001; 0:1-0 Prepared using cpeauth.cls</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Prepared using cpeauth.cls</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>,A</head><label></label><figDesc>Normal P va Var ´v,fµ :. Q Val v ,A Normal P Acc va-Q</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>prog inv mode tname ref ty and give it the definition mode D t mode IntVir is class D ´if ´ T. t ArrayT Tµ then D Object else Class D RefT tµ reflecting the knowledge on D required for program verification in case of virtual method invocation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>,A</head><label></label><figDesc>Normal P e-Q ,A Q args R vs l. ,A R Vals vs . ´ . l locals ´snd µµ ;. init lvars C ´mn,pTsµ Static a vs Methd C ´mn,pTsµ-set lvars l .; S ,A Normal P t,ClassT C,Static e..mn´ pTs argsµ-S</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Prepared using cpeauth.cls</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>1 .</head><label>1</label><figDesc>Summary and ExperienceExtensions of Hoare logic We have introduced a Hoare logic for a (rather extensive) subset of Java Card. Its design raised interesting general issues like representation of auxiliary variables and side-effecting expressions with their results, and the exact notion of validity. Furthermore, strengthened versions of the consequence and method call rule emerged as well as new solutions for handling exceptions and dependent code.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>In our model many situations arise where under a certain condition an exception should be raised, yet only if no exception is already present which has to take precedence. This behavior is captured by the function</figDesc><table><row><cell cols="3">xupd ´´xcptµoption</cell><cell cols="2">´xcptµoptionµ</cell><cell>state</cell><cell>state</cell></row><row><cell>supd ´st</cell><cell>stµ</cell><cell cols="2">state</cell><cell>state</cell></row><row><cell>xupd f</cell><cell></cell><cell></cell><cell></cell></row><row><cell>set lvars</cell><cell cols="2">locals</cell><cell>state</cell><cell>state</cell></row><row><cell cols="5">set lvars l ¼ supd ´ s. case s of st g l</cell><cell>st g l ¼</cell><cell>µ</cell></row><row><cell cols="2">raise if bool</cell><cell cols="2">xname</cell><cell>´xcptµoption</cell><cell>´xcptµoption</cell></row><row><cell>raise if c xn</cell><cell>x</cell><cell></cell><cell></cell></row></table><note><p>´x,sµ. ´f x,sµ supd f ´x,sµ. ´x,f sµ applied for instance when setting local variables: ¼ . if c x ¼ None then Some ´StdXcpt xnµ else x ¼</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>More interesting is the extension of validity to antecedents, defined as</figDesc><table><row><cell cols="3">prog nat:´«µtriples</cell><cell></cell></row><row><cell>n:ts</cell><cell>t¾ts.</cell><cell>n:t</cell><cell></cell></row><row><cell cols="3">prog,´¬µtriples ´«µtriples</cell><cell></cell></row><row><cell>,A ts</cell><cell>n.</cell><cell>n:A</cell><cell>n:ts</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>3, has the general form z. ,A P z Inj z t z Q z where Inj is one of the injections Val, Var or Vals. It means matching (and binding) the result of the previous triple and using it anywhere within the triple, typically in order to calculate a new result or let the term t depend on it.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>Normal ´P Val vµThe rule for super is similar, except that one has to peek at the state in order to get the value of</figDesc><table><row><cell>This:</cell></row><row><cell>ËÙÔ Ö</cell></row></table><note><p>3, the rule for literal values is Ä Ø ,A Normal ´P Val vµ Lit v-P It states that for a literal expression (i.e. constant) v the postcondition P can be derived if P -with the value v inserted -holds as the precondition and the (pre-)state is normal. An equivalent but typically less convenient alternative form would be ´Ä Ø¾µ ,A Normal P Lit v-,A Normal ´ s.. P Val ´val this sµµ super-P</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head></head><label></label><figDesc>Note that since the value of the assignment is the value of the right-hand side, it is not necessary to give the result substitution R Val v in the postcondition of e explicitly. The assignment takes place only if no exception is already present and the update function itself does not throw a new one, as implemented by</figDesc><table /><note><p>×× ,A Normal P va Q vf. ,A Q Var vf e-Val v :. assign ´snd vfµ v .; R ,A Normal P va:=e-R assign f v ´x,sµ. let ´x¼ ,s ¼ µ if x None then f v ´x,sµ else ´x,sµ in ´x¼ ,if x ¼ None then s ¼ else sµ</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head></head><label></label><figDesc>The rules for field and array variables have a common pattern: calling a variable-generating function vf on the state and applying a given assertion to the resulting variable and state. We capture this in the predicate transformerThe auxiliary function fvar C stat fn a calculates the vvar for field fn (which is static iff stat is True) of class C contained in the object at location a. It throws a NullPointer exception if necessary. Analogously, avar i a calculates the vvar (cf. Ü3.2) for the element i of the array at location a for a given state in the context of the program . It may not only throw a NullPointer, but also ArrStore and IndOutBound exception.</figDesc><table><row><cell>..; vf ..; P</cell><cell cols="3">´state Y . let ´v, ¼ vvar ¢ stateµ ´«µassn ´«µassn µ vf in P ´Var vµ ¼</cell></row><row><cell cols="3">Applying it, we obtain the two rules</cell></row><row><cell></cell><cell></cell><cell>Î Ö</cell></row><row><cell cols="2">Alloc otag P</cell><cell>Y Z. ¼ a. ,A</cell><cell>halloc otag a</cell></row></table><note><p>,A Normal P .init C. Alloc ĆInst Cµ Q ,A Normal P new C-Q where ¼ P ´Val ´Addr aµµ ¼ Z AE Û ,A Normal P .init comp ty T. Q ,A Q e-Val i :. xupd ´check neg iµ .; Alloc Árr T ´the Intg iµµ R ,A Normal P new T e -R where check neg i raise if ´the Intg i 0µ NegArrSize 9.6. Variables The rule for local variables is analogous to the rule for the super expression: ÄÎ Ö ,A Normal ´ s.. P Var ´lvar vn sµµ LVar vn P where lvar vn s calculates the semantical description of the local variable vn in the state s. ,A Normal P .init C. Q ,A Q e-Val a :. fvar C stat fn a ..; R ,A Normal P C,stat e..fn R Î Ö ,A Normal P e½-Q a. ,A Q Val a e¾-Val i :. avar i a ..; R ,A Normal P e½ e¾ R</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head></head><label></label><figDesc>´R a Vals vs . ´ ´x,sµ. D target mode s a md l locals sµ ;. init lvars D ´mn,pTsµ mode a vsµ . ´ . normalNote thatmode D t is asserted only if the current state is normal. Otherwise, an exception occurred evaluating e (or args) such that we cannot assume anything about D. For the same reason the welltypedness judgment in the definition of type ok (cf. Ü6.1) is guarded by normal since otherwise Methd D ´mn,pTsµ is not necessarily well-typed.</figDesc><table><row><cell></cell><cell>,A Normal P e-</cell><cell>Q</cell><cell>a. ,A Q Val a args</cell><cell>R a</cell></row><row><cell></cell><cell cols="4">a vs D l. ,A mode D tµ</cell></row><row><cell>ÐÐ</cell><cell cols="3">Methd D ´mn,pTsµ-,A Normal P t,md,mode e..mn´ pTs argsµ-set lvars l .; S</cell><cell>S</cell></row><row><cell>Copyright c</cell><cell>2001 John Wiley &amp; Sons, Ltd.</cell><cell></cell><cell cols="2">Concurrency: Pract. Exper. 2001; 0:1-0</cell></row><row><cell cols="2">Prepared using cpeauth.cls</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14"><head></head><label></label><figDesc>Note that here the auxiliary variables have the type state since they refer to the initial program state. In the precondition the state is stored in Z and retrieved in the postcondition in the form of the bound variable . Using it, the postcondition asserts that the result Y and state ¼ are exactly those obtained from the initial state by evaluating t. Thus the MGF is trivially valid, and the main task is to show that it is also derivable.A property of the MGF used often is that ,A Normal , i.e. restricting the precondition to normal states is sufficient, because the case of an exceptional state can be always dealt with the ÔØ rule.Once the derivability of the MGF has been proved, completeness is a rather simple consequence, as follows. We show (cf. Ü10.3), in order to obtain the extra precondition type ok t which is needed because this judgment is part of our notion of validity. Next, we apply the ÓÒ× Õ½¾ rule, and after unfolding the definitions of validity we are left with the proof obligation</figDesc><table><row><cell>t</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>where</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>P t</cell><cell></cell><cell></cell><cell>P t</cell><cell>Y ¼ .</cell><cell cols="2">t ´Y, ¼</cell><cell>µ</cell></row><row><cell></cell><cell></cell><cell></cell><cell>Y Z.</cell><cell>Z</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>t</cell><cell>can be interchanged freely with</cell></row><row><cell>,A</cell><cell>t</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="6">The main lemma of the MGF approach is</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>Å</cell><cell cols="2">Ö Ú ws prog</cell><cell></cell><cell>,</cell><cell>t</cell></row><row><cell>,</cell><cell>P t</cell><cell>Q</cell><cell>,</cell><cell>t</cell><cell></cell><cell></cell><cell>,</cell><cell>P t</cell><cell>Q</cell></row><row><cell cols="4">First, we apply the rule</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="5">´ÒÓ Þ Ö µ ,A P . type ok t t Q ,A P t Q</cell></row><row><cell cols="3">derived from Þ Ö ´ n Y Z. ´ t¾ .</cell><cell>n:tµ</cell><cell cols="2">P Y Z</cell><cell cols="3">type ok t</cell></row><row><cell>´</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_15"><head></head><label></label><figDesc>A minor advantage of this version is that it does not require the rules ÑÔØÝ and Ò× ÖØ for handling sets of triples in the consequents. The main disadvantage is that it requires a complicated scheme for induction on the number of methods not yet considered: which is proved by induction on n. It is applied instantiating U to ´C,sigµ. is methd C sig , n to U , and consequently A to , yielding the desired result. Note that without finiteness, calculations on cardinality like A uA -n would be meaningless.</figDesc><table><row><cell>,A</cell><cell cols="4">Normal P Methd C sig-</cell><cell>Q</cell><cell cols="2">Normal P body C sig-</cell><cell>Q</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="4">,A Normal P Methd C sig-</cell><cell>Q</cell></row><row><cell></cell><cell cols="4">finite U uA ´ ´C, sigµ.</cell><cell cols="2">Methd C sig-</cell><cell>µ</cell><cell>U</cell></row><row><cell></cell><cell>A. A uA</cell><cell>n</cell><cell>uA</cell><cell>A</cell><cell>uA -n</cell><cell cols="2">´ t. ,A</cell><cell>t</cell></row></table><note><p>µ</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_16"><head></head><label></label><figDesc>Static initialization requires an induction on the number of classes not yet initialized. To this end we define the auxiliary concepts such that nyinitcls is the set of classes not yet initialized, or to be more precise, whose initialization has not yet begun, in state . The triple :n t is a variant of the MGF with the extra precondition that the number of classes not yet initialized is not greater than n. nyinitcls is finite because it is a subset of the finite set of proper classes. It cannot grow (and thus increase its cardinality) during program execution, and it actually shrinks by one when a class is newly initialized.</figDesc><table><row><cell cols="2">nyinitcls prog</cell><cell>state</cell><cell cols="2">´tnameµset</cell></row><row><cell>nyinitcls</cell><cell></cell><cell cols="2">C. is class C</cell><cell cols="2">initd C</cell></row><row><cell>init</cell><cell>prog</cell><cell>nat</cell><cell>state</cell><cell>bool</cell></row><row><cell>init n</cell><cell cols="2">. nyinitcls</cell><cell></cell><cell>n</cell></row><row><cell>:</cell><cell></cell><cell>nat</cell><cell>term</cell><cell>prog</cell><cell>´stateµtriple</cell></row><row><cell>:n t</cell><cell></cell><cell>.</cell><cell cols="2">init n t</cell></row><row><cell>Since ,A</cell><cell></cell><cell>t</cell><cell cols="3">is equivalent to n. ,A</cell><cell>:n t</cell><cell>, it remains to show</cell></row><row><cell></cell><cell cols="3">n C sig. ,A</cell><cell cols="2">:n Methd C sig-</cell><cell>´ t. ,A</cell><cell>:n t</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_18"><head></head><label></label><figDesc>Pre Normal ´ Y Z. heap free 4 initd Base initd Ext µ tprg ´ ´HasFoo,HasFooIntµ , ´Base,BaseClµ,´Ext,ExtClµ @ standard classesµ arr viewed from C Base,True ´Cast ´Class Cµ Ĺit Nullµµ..arr test e :== new Ext; try Expr´ CTBase,CTBase,IntVir !!e..foo´ Class Base Lit Null µµ catch´´SXcpt NullPointerµ zµ ´while´Acc ´Acc ´arr viewed from Extµ Lit ´Intg 2µ µµ Skipµ</figDesc><table><row><cell>tprg,</cell><cell>Pre .test. Y Z. fst</cell><cell>Some IndOutBound</cell></row><row><cell>where</cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Concurrency: Pract. Exper. 2001; 0:1-0 Prepared using cpeauth.cls</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>Copyright c 2001 John Wiley &amp; Sons, Ltd. Concurrency: Pract. Exper. 2001; 0:1-0 Prepared using cpeauth.cls</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>Object Constraint Language (OCL), 39 op , 31 option, 4 Peano Arithmetic, 8 primitive types, 6 prog, 5 program, 5 raise if, 7 recursive depth, 14 reference types, 6 relative completeness, 8 result values, 10 set, 4 set lvars, 7 Skip, 5 snd, 4 Some, 4 statements, 5 stmt, 5 supd, 7 super, 6 SXAlloc, 21 term, 5 terms, 5 the, 4 throw, 5 triple, 13 triples, 13 triples, 13 try, 5 type annotations, 6 type relations, 6 type ok, 14 typing judgments, 6 Val, 5 validity, 13 Vals, 5 vals, 5 Var, 5 var, 6 variables, 6 virtual methods, 25 vvar, 5 weakest precondition, 20 wf prog, 5 while, 5 widening, 6 ws prog, 5 xupd, 7 Copyright c 2001 John Wiley &amp; Sons, Ltd. Concurrency: Pract. Exper. 2001; 0:1-0 Prepared using cpeauth.cls</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>This work was done within the Project Bali funded by the DFG. I thank Tobias Nipkow, Arnd Poetzsch-Heffter, Peter Müller, Thomas Kleymann, Martin Hofmann and Francis Tang for inspiring discussions on the topic. I furthermore thank Tobias Nipkow, Arnd Poetzsch-Heffter, Gerwin Klein, Marieke Huisman and some anonymous referees for their constructive comments on earlier versions of this article.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>all other universal quantifications: proceed recursively for any fixed but arbitrary value since the proof is uniform.</p><p>otherwise: use the canonical rule plus recursion.</p><p>The procedure ÔÖÓÚ ØÖ ÔÐ ´tµ terminates (assuming that the proofs of the emerging side conditions terminate) because for all recursive calls the number of quantifiers is reduced or the Java Ø terms involved become structurally smaller, except for init C where the number of uninitialized classes is reduced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="12.">Example</head><p>To illustrate our approach and for gaining experience how our Hoare logic behaves in practice, we use the following (artificial) example. </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A logic of object-oriented programs</title>
		<author>
			<persName><forename type="first">Martín</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rustan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Leino</surname></persName>
		</author>
		<idno>SRC-161</idno>
	</analytic>
	<monogr>
		<title level="j">Compaq SRC</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">A system of proof rules for the correctness of iterative programs -some notational and organisational suggestions</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Aczel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
	<note>Unpublished</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">A proof theory for a sequential version of POOL</title>
		<author>
			<persName><forename type="first">Pierre</forename><surname>America</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>De Boer</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Unpublished?</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Ten years of Hoare logic: A survey -part I</title>
		<author>
			<persName><forename type="first">R</forename><surname>Krzysztof</surname></persName>
		</author>
		<author>
			<persName><surname>Apt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Prog. Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="431" to="483" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">David</forename><surname>Aspinall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Healfdene</forename><surname>Goguen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Kleymann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dilip</forename><surname>Sequeira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proof General</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">Isabelle</forename><surname>Attali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Denis</forename><surname>Caromel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marjorie</forename><surname>Russo</surname></persName>
		</author>
		<ptr target="http://www-sop.inria.fr/oasis/java/java_sem.html" />
		<title level="m">Oasis project: Java semantics</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A formal executable semantics for Java</title>
		<author>
			<persName><forename type="first">Isabelle</forename><surname>Attali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Denis</forename><surname>Caromel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marjorie</forename><surname>Russo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA&apos;98 Workshop on Formal Underpinnings of Java</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Side Effects and Aliasing Can Have Simple Axiomatic Descriptions</title>
		<author>
			<persName><forename type="first">Hans-Juergen</forename><surname>Boehm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="637" to="655" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Experience with embedding hardware description languages in HOL</title>
		<author>
			<persName><forename type="first">Richard</forename><surname>Boulton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mike</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Herbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Van Tassel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theorem Provers in Circuit Design</title>
		<editor>
			<persName><forename type="first">V</forename><surname>Stavridou</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Melham</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">T</forename><surname>Boute</surname></persName>
		</editor>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="129" to="156" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A formulation of the simple theory of types</title>
		<author>
			<persName><forename type="first">Alonzo</forename><surname>Church</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="56" to="68" />
			<date type="published" when="1940">1940</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Soundness and completeness of an axiom system for program verification</title>
		<author>
			<persName><forename type="first">Stephen</forename><forename type="middle">A</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="70" to="90" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A WP-calculus for OO</title>
		<author>
			<persName><forename type="first">Frank</forename><surname>De</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boer</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Software Science and Computation Structures</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1578</biblScope>
			<biblScope unit="page" from="135" to="149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Describing the semantics of Java and proving type soundness</title>
		<author>
			<persName><forename type="first">Sophia</forename><surname>Drossopoulou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Susan</forename><surname>Eisenbach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Syntax and Semantics of Java</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Alves-Foss</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1523</biblScope>
			<biblScope unit="page" from="41" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Introduction to HOL: a theorem-proving environment for higher order logic</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">F</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><surname>Melham</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Edinburgh LCF: a Mechanised Logic of Computation</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robin</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P</forename><surname>Milner</surname></persName>
		</author>
		<author>
			<persName><surname>Wadsworth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lect. Notes in Comp. Sci</title>
		<imprint>
			<biblScope unit="volume">78</biblScope>
			<date type="published" when="1979">1979</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">A complete axiomatic system for proving assertions about recursive and non-recursive programs</title>
		<author>
			<persName><forename type="first">Gerald</forename><forename type="middle">A</forename><surname>Gorelick</surname></persName>
		</author>
		<idno>75</idno>
		<imprint>
			<date type="published" when="1975">1975</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Toronto</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">The Java Language Specification</title>
		<author>
			<persName><forename type="first">James</forename><surname>Gosling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bill</forename><surname>Joy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guy</forename><surname>Steele</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">An axiomatic basis for computer programming</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="576" to="580" />
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Semantik und Verifikation. Lecture notes</title>
		<author>
			<persName><forename type="first">Martin</forename><surname>Hofmann</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>German</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Handling mutual recursion. Personal Communication</title>
		<author>
			<persName><forename type="first">Martin</forename><surname>Hofmann</surname></persName>
		</author>
		<author>
			<persName><surname>David Von Oheimb</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999-04">April 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Implementing a program logic of objects in a higher-order logic theorem prover</title>
		<author>
			<persName><forename type="first">Martin</forename><surname>Hofmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Francis</forename><surname>Tang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theorem Proving in Higher Order Logics: 13th International Conference</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Harrison</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Aagaard</surname></persName>
		</editor>
		<meeting><address><addrLine>TPHOLs</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000. 2000</date>
			<biblScope unit="volume">1869</biblScope>
			<biblScope unit="page" from="267" to="282" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<ptr target="http://isabelle.in.tum.de/library/HOL/" />
		<title level="m">The Isabelle/HOL library</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A mechanically verified verification condition generator</title>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">V</forename><surname>Homeier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">F</forename><surname>Martin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Computer Journal</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="131" to="141" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Mechanical verification of mutually recursive procedures</title>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">V</forename><surname>Homeier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">F</forename><surname>Martin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th Int. Conference on Automated Deduction</title>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Mcrobbie</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Slaney</surname></persName>
		</editor>
		<meeting>the 13th Int. Conference on Automated Deduction</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1104</biblScope>
			<biblScope unit="page" from="201" to="215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Java program verification in Higher-order logic with PVS and Isabelle</title>
		<author>
			<persName><forename type="first">Marieke</forename><surname>Huisman</surname></persName>
		</author>
		<ptr target="http://www-sop.inria.fr/oasis/personnel/Marieke.Huisman/thesis.ps.gz" />
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
		<respStmt>
			<orgName>University of Nijmegen</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Java program verification via a Hoare logic with abrupt termination</title>
		<author>
			<persName><forename type="first">Marieke</forename><surname>Huisman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bart</forename><surname>Jacobs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fundamental Approaches to Software Engineering, volume 1783 of Lect. Notes in Comp. Sci</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="284" to="303" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Reasoning about Java classes (preliminary report)</title>
		<author>
			<persName><forename type="first">Bart</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joachim</forename><surname>Van Den</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marieke</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martijn</forename><surname>Huisman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ulrich</forename><surname>Van Berkum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hendrik</forename><surname>Hensel</surname></persName>
		</author>
		<author>
			<persName><surname>Tews</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM Symp. Object-Oriented Programming: Systems, Languages and Applications</title>
		<imprint>
			<biblScope unit="page" from="329" to="340" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<author>
			<persName><forename type="first">Bart</forename><surname>Jacobs</surname></persName>
		</author>
		<ptr target="http://www.cs.kun.nl/˜bart/LOOP/" />
		<title level="m">Loop project</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<author>
			<persName><forename type="first">Bart</forename><surname>Jacobs</surname></persName>
		</author>
		<ptr target="http://www.cs.kun.nl/VerifiCard/" />
		<title level="m">Project Verificard</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A logic for the Java Modeling Language JML</title>
		<author>
			<persName><forename type="first">Bart</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Poll</surname></persName>
		</author>
		<idno>CSI-R0018</idno>
		<ptr target="http://www.cs.kun.nl/csi/reports/info/CSI-R0018.html" />
	</analytic>
	<monogr>
		<title level="j">Ltd. Concurrency: Pract. Exper</title>
		<imprint>
			<biblScope unit="volume">0</biblScope>
			<biblScope unit="page" from="1" to="1" />
			<date type="published" when="2000">2000. 2001. 2001</date>
			<publisher>John Wiley &amp; Sons</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>CSI</note>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<author>
			<persName><forename type="first">Cliff</forename><forename type="middle">B</forename><surname>Jones</surname></persName>
		</author>
		<title level="m">Systematic Program Development Using VDM. International Series in Computer Science</title>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
	<note>2nd edition</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Hoare logic and VDM: Machine-checked soundness and completeness proofs</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Kleymann</surname></persName>
		</author>
		<idno>ECS- LFCS-98-392</idno>
	</analytic>
	<monogr>
		<title level="j">LFCS</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Axiomatic approach to side effects and general jumps</title>
		<author>
			<persName><forename type="first">Tomasz</forename><surname>Kowaltowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="357" to="360" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Preliminary design of JML: A behavioral interface specification language for Java</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Albert</forename><forename type="middle">L</forename><surname>Leavens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Clyde</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName><surname>Ruby</surname></persName>
		</author>
		<idno>98-06l</idno>
		<ptr target="http://www.cs.iastate.edu/˜leavens/JML.html" />
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Iowa State University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Subtyping, modular specification, and modular verification for applicative objectoriented programs</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">E</forename><surname>Leavens</surname></persName>
		</author>
		<author>
			<persName><surname>Weihl</surname></persName>
		</author>
		<idno>92-28</idno>
		<imprint>
			<date type="published" when="1992">1992. 1994</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Iowa State University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Toward reliable modular programs</title>
		<author>
			<persName><forename type="first">K</forename><surname>Rustan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Leino</surname></persName>
		</author>
		<idno>CS-TR-95-03</idno>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
		<respStmt>
			<orgName>California Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Checking Java programs via guarded commands</title>
		<author>
			<persName><forename type="first">K</forename><surname>Rustan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">B</forename><surname>Saxe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raymie</forename><surname>Stata</surname></persName>
		</author>
		<idno>251</idno>
		<ptr target="http://gatekeeper.dec.com/pub/DEC/SRC/technical-notes/abstracts/src-tn-1999-002.html" />
	</analytic>
	<monogr>
		<title level="m">Formal Techniques for Java Programs</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Jacobs</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><forename type="middle">T</forename><surname>Leavens</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Müller</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Poetzsch-Heffter</surname></persName>
		</editor>
		<imprint>
			<publisher>Fernuniversität Hagen</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">An architecture for interactive program provers</title>
		<author>
			<persName><forename type="first">Jörg</forename><surname>Meyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arnd</forename><surname>Poetzsch-Heffter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS00, Tools and Algorithms for the Construction and Analysis of Systems</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Graf</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Schwartzbach</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1785</biblScope>
			<biblScope unit="page" from="63" to="77" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Modular Specification and Verification of Object-Oriented Programs</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Müller</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
		<respStmt>
			<orgName>FernUniversität Hagen</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Universes: A type system for controlling representation exposure</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arnd</forename><surname>Poetzsch-Heffter</surname></persName>
		</author>
		<idno>263</idno>
		<ptr target="http://www.informatik.fernuni-hagen.de/pi5/publications.html" />
	</analytic>
	<monogr>
		<title level="m">Programming Languages and Fundamentals of Programming</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Poetzsch-Heffter</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Meyer</surname></persName>
		</editor>
		<imprint>
			<publisher>Fernuniversität Hagen</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Isabelle/HOL. The Tutorial</title>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Nipkow</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Nipkow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cornelia</forename><surname>David Von Oheimb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerwin</forename><surname>Pusch</surname></persName>
		</author>
		<author>
			<persName><surname>Klein</surname></persName>
		</author>
		<ptr target="http://isabelle.in.tum.de/Bali/" />
	</analytic>
	<monogr>
		<title level="j">Project Bali</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Isabelle&apos;s logics: HOL</title>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Nipkow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lawrence</forename><forename type="middle">C</forename><surname>Paulson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Wenzel</surname></persName>
		</author>
		<ptr target="http://isabelle.in.tum.de/doc/logics-HOL.pdf" />
	</analytic>
	<monogr>
		<title level="m">Isabelle: A Generic Theorem Prover</title>
		<title level="s">Lect. Notes in Comp. Sci</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">828</biblScope>
		</imprint>
	</monogr>
	<note>Up-to-date version</note>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Hoare logic for mutual recursion and local variables</title>
		<author>
			<persName><forename type="first">Oheimb</forename><surname>David Von</surname></persName>
		</author>
		<ptr target="http://isabelle.in.tum.de/Bali/papers/FSTTCS99.html" />
	</analytic>
	<monogr>
		<title level="m">Foundations of Software Technology and Theoretical Computer Science, volume 1738 of Lect. Notes in Comp. Sci</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Pandu Rangan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">V</forename><surname>Raman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Ramanujam</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="168" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Axiomatic semantics for Java Ø</title>
		<author>
			<persName><forename type="first">;</forename><forename type="middle">S</forename><surname>David Von Oheimb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Drossopoulou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Eisenbach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">T</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Leavens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Poetzsch-Heffter</surname></persName>
		</author>
		<idno>269, 5/2000</idno>
		<ptr target="http://isabelle.in.tum.de/Bali/papers/ECOOP00.html" />
	</analytic>
	<monogr>
		<title level="m">Formal Techniques for Java Programs</title>
		<imprint>
			<publisher>Fernuniversität Hagen, Fernuniversität Hagen</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Axiomatic semantics for Java Ø in Isabelle/HOL</title>
		<author>
			<persName><forename type="first">Oheimb</forename><surname>David Von</surname></persName>
		</author>
		<idno>CSE 00-009</idno>
		<ptr target="http://isabelle.in.tum.de/Bali/papers/TPHOLs00.html" />
	</analytic>
	<monogr>
		<title level="m">TPHOLs 2000 Supplemental Proceedings</title>
		<imprint>
			<publisher>Oregon Graduate Institute</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<author>
			<persName><forename type="first">Oheimb</forename><surname>David Von</surname></persName>
		</author>
		<ptr target="http://www4.in.tum.de/˜oheimb/diss/" />
		<title level="m">Analyzing Java in Isabelle/HOL: Formalization, Type Safety and Hoare Logic</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
		<respStmt>
			<orgName>Technische Universität München</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Machine-checking the Java specification: Proving type-safety</title>
		<author>
			<persName><forename type="first">Oheimb</forename><surname>David Von</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Nipkow</surname></persName>
		</author>
		<ptr target="http://isabelle.in.tum.de/Bali/papers/Springer98.html" />
	</analytic>
	<monogr>
		<title level="m">Formal Syntax and Semantics of Java, volume 1523 of Lect. Notes in Comp. Sci</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Alves-Foss</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">A technique for software module specification with examples</title>
		<author>
			<persName><forename type="first">L</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><surname>Parnas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="330" to="336" />
			<date type="published" when="1972">1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">For an up-to-date description</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lawrence</surname></persName>
		</author>
		<author>
			<persName><surname>Paulson</surname></persName>
		</author>
		<author>
			<persName><surname>Isabelle</surname></persName>
		</author>
		<ptr target="http://isabelle.in.tum.de/" />
	</analytic>
	<monogr>
		<title level="s">Lect. Notes in Comp. Sci</title>
		<imprint>
			<biblScope unit="volume">828</biblScope>
			<date type="published" when="1994">1994</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
	<note>A Generic Theorem Prover</note>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">A programming logic for sequential Java</title>
		<author>
			<persName><forename type="first">Arnd</forename><surname>Poetzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">-</forename><surname>Heffter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Müller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Programming Languages and Systems (ESOP &apos;99), volume 1576 of Lect. Notes in Comp. Sci</title>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Swierstra</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="162" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Auxiliary variables and recursive procedures</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Schreiber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theory and Practice of Software Development, volume 1214 of Lect. Notes in Comp. Sci</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="697" to="711" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Fundamental concepts in programming languages</title>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Strachey</surname></persName>
		</author>
		<ptr target="http://www.wkap.nl/oasis.htm/257993" />
	</analytic>
	<monogr>
		<title level="m">Higher-Order and Symbolic Computation</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="11" to="49" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Java</forename><surname>Card</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Technology</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><surname>Microsystems</surname></persName>
		</author>
		<ptr target="http://java.sun.com/products/javacard/" />
	</analytic>
	<monogr>
		<title level="j">Ltd. Concurrency: Pract. Exper</title>
		<imprint>
			<biblScope unit="volume">0</biblScope>
			<biblScope unit="page" from="1" to="1" />
			<date type="published" when="1999">1999. 2001. 2001</date>
			<publisher>John Wiley &amp; Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Formal Syntax and Semantics of Java</title>
		<author>
			<persName><forename type="first">Donald</forename><surname>Syme</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lect. Notes in Comp. Sci</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Alves-Foss</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1523</biblScope>
			<biblScope unit="page" from="83" to="118" />
			<date type="published" when="1999">1999</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
	<note>Proving Java type soundness</note>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<title level="m" type="main">A formulation of Hoare logic suitable for Isar</title>
		<author>
			<persName><forename type="first">Markus</forename><surname>Wenzel</surname></persName>
		</author>
		<ptr target="http://isabelle.in.tum.de/library/HOL/Isar_examples/Hoare.html" />
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Ltd. Concurrency: Pract. Exper</title>
		<imprint>
			<biblScope unit="volume">0</biblScope>
			<biblScope unit="page" from="1" to="1" />
			<date type="published" when="2001">2001. 2001</date>
			<publisher>John Wiley &amp; Sons</publisher>
		</imprint>
	</monogr>
	<note>Prepared using cpeauth.cls</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
