<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">OASIS: On Achieving a Sanctuary for Integrity and Secrecy on Untrusted Platforms *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Emmanuel</forename><surname>Owusu</surname></persName>
							<email>eowusu@cmu.edu</email>
						</author>
						<author>
							<persName><forename type="first">Jorge</forename><surname>Guajardo</surname></persName>
							<email>jorge.guajardomerchan@us.bosch.com</email>
							<affiliation key="aff1">
								<orgName type="institution">Bosch Research and Technology Center</orgName>
								<address>
									<settlement>Robert Bosch LLC</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jonathan</forename><surname>Mccune</surname></persName>
							<email>jonmccune@cmu.edu</email>
						</author>
						<author>
							<persName><forename type="first">Jim</forename><surname>Newsome</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Adrian</forename><surname>Perrig</surname></persName>
							<email>perrig@cmu.edu</email>
						</author>
						<author>
							<persName><forename type="first">Amit</forename><surname>Vasudevan</surname></persName>
							<email>amitvasudevan@cmu.edu</email>
						</author>
						<author>
							<persName><forename type="first">†</forename><surname>Cylab</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Carnegie Mellon University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">OASIS: On Achieving a Sanctuary for Integrity and Secrecy on Untrusted Platforms *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">1B1A7EF7D0D38402DCEF48174BC1C265</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:04+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C.0 [General]: Miscellaneous-Hardware/Software Interfaces</term>
					<term>Instruction Set Design; K.6.5 [Management of Computing and Information Systems]: Security and Protection-Physical Security</term>
					<term>Unauthorized Access Design</term>
					<term>Security Secure Execution</term>
					<term>Remote Attestation</term>
					<term>Instruction Set Extension</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present OASIS, a CPU instruction set extension for externally verifiable initiation, execution, and termination of an isolated execution environment with a trusted computing base consisting solely of the CPU. OASIS leverages the hardware components available on commodity CPUs to achieve a low-cost, low-overhead design.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Despite numerous attacks against a wide spectrum of organizations <ref type="bibr" target="#b4">[6,</ref><ref type="bibr" target="#b27">29]</ref>, secure execution environments protected by TCG have not seen widespread application -even in cloud computing, where customers want to verify execution <ref type="bibr" target="#b0">[2,</ref><ref type="bibr" target="#b39">41]</ref>. Perhaps this lack of application is due, in part, to the lack of end-to-end application software that benefit from TCG properties, lack of trust in the TPM vendors, lack of protection against local adversaries, and concerns over poor performance.</p><p>Many designs for an isolated execution environment (IEE) have been proposed, but an interesting question remains: What minimal additions do we need to add to a modern CPU to achieve a highly efficient isolated execution environment with remote attestation properties? This work investigates what minimal architectural changes are required to obtain the essential Trusted Computing Base (TCB) -an isolated execution environment completely contained inside a modern CPU -providing resilience against several classes of hardware attacks. In addition, we design this architecture such that minimal changes to a modern commodity CPU are required for deployment. In keeping with minimalist design, we provide a simple programming interface consisting of few instructions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contributions</head><p>• We present an instruction set for remotely verifiable, efficient code execution requiring a minimal TCB. • We propose an API where the CPU provides unique cryptographic keys to security-sensitive applications. • Our deployment model precludes the need for a distributor or manufacturer to protect platform secrets on behalf of the end-user or their customers. • Our system is designed for deployment on existing commodity CPUs with minimal modifications. • Contrary to prior approaches, our solution does not require on-chip non-volatile memory to store secrets. Thus, in addition to avoiding the strong assumption of secure non-volatile memory, our solution is cheaper to implement in practice as it leverages semiconductor processes already used in modern CPUs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PROBLEM DEFINITION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Model and Assumptions</head><p>Deployment Model. Our use case defines outsourced computation in the sense advocated by public cloud computing. Thus, we identify three key parties; and their different roles and levels of trust as a device moves from production to use: (i) The processor hardware manufacturer (HWM). The HWM is trusted to manufacture the CPU to initialize a cryptographic device key with a Physically Unclonable Function.</p><p>(ii) The service provider (or device owner) that offers the device as a platform to customers who wish to lease them for a certain amount of time or computation.</p><p>Finally, (iii) the user (or cloud customer) who wishes to lease computing resources. Users are interested in verifying the trustworthiness of devices leased to them, guaranteeing the integrity and confidentiality of their computations and data.</p><p>In the remainder of this paper, we refer to the service provider's device simply as the platform or P and to the user's device as the verifier or V .</p><p>Adversary Model. We assume a sophisticated adversary with physical access to the computing platform. In particular, the adversary can introduce malware into the computing platform (e.g., to compromise an application, the OS, or firmware), has access to the external ports of the platform to physically attach malicious peripherals to P . Similarly, the adversary can probe and tamper with low-speed and highspeed buses (e.g., to eavesdrop on a memory or PCI bus), and/or inject code and/or modify data. However, the adversary cannot perform attacks that require complete unscrutinized access to the CPU for extended periods of time. In particular, this implies that the service provider has organizational procedures in place to prevent attacks, but cannot guarantee the absence of a small set of rogue employees. <ref type="foot" target="#foot_0">1</ref>We consider denial-of-service, side-channel, and fault injection attacks beyond the scope of this paper.</p><p>Assumptions. With respect to the service provider, we assume that the CPU on the untrusted platform P is not malicious (i.e., we trust the processor). We assume that this CPU contains a Physically Unclonable Function that can only be accessed through the specified APIs. Additionally, we assume that the CPU has a true random number generator. We assume that the CPU is tamper-resistant. Thus, physical security is not a requirement. Finally, we assume that the verifier V has the correct public key of the provider's platform P .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Desired Properties</head><p>The following list contains the desired properties for OASIS. P 1 Secure. We would like the following security objectives to be satisfied: </p><formula xml:id="formula_0">P 1.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">HARDWARE BUILDING BLOCKS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">PUFs, Fuzzy Extractors, and TRNGs</head><p>Pappu et al. introduce the concept of Physical Unclonable Functions (PUFs), which are functions where the relationship between input (or challenge) C and output (or response) pe is defined via a physical system <ref type="bibr" target="#b13">[15,</ref><ref type="bibr" target="#b33">35]</ref>. The physical system has the additional properties of being random and unclonable. The system's unclonability originates from random variations in a device's manufacturing process, which even the manufacturer cannot control. In their most general form, PUFs can accept a large number challengeresponse pairs. Examples of PUF constructions include: optical PUFs <ref type="bibr" target="#b33">[35]</ref>, silicon PUFs <ref type="bibr" target="#b13">[15,</ref><ref type="bibr" target="#b12">14]</ref>, coating PUFs <ref type="bibr" target="#b43">[45]</ref>, SRAM PUFs <ref type="bibr" target="#b14">[16,</ref><ref type="bibr" target="#b15">17]</ref>, reconfigurable PUFs <ref type="bibr" target="#b21">[23]</ref>, and Flash memory-based PUFs <ref type="bibr" target="#b46">[48]</ref>.</p><p>Because of PUF variability across different environmental conditions (voltage, temperature, humidity, etc.), when a PUF is challenged with Ci, a response p ′ e (a noisy version of pe) is obtained. In applications where the PUF response is used as a cryptographic key this noisy response p ′ e is not acceptable. To solve this problem, algorithms known as fuzzy extractors leverage non-secret helper data to work around the noisy nature of physical measurements typical of PUF applications <ref type="bibr" target="#b19">[21,</ref><ref type="bibr" target="#b25">27,</ref><ref type="bibr" target="#b8">10]</ref>. We assume that the fuzzy extractor is implemented in a silicon block and is accessible as a function that is used (in combination with the PUF interface) to realize our instructions.</p><p>While stability is fundamental for PUFs, variation in unstable bits can be leveraged for random number generation <ref type="bibr" target="#b15">[17,</ref><ref type="bibr" target="#b42">44,</ref><ref type="bibr" target="#b46">48]</ref>. For the purposes of this paper, we focus on PUFs based on memory arrays, such as SRAM commonly used in CPU caches. SRAM memory can be used as the raw source for a PUF as well as the entropy source for a True Random Number Generator (TRNG). <ref type="foot" target="#foot_1">2</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Cache-as-RAM (CAR) Mode</head><p>Cache memory is ubiquitous across CPU architectures. Traditionally, SRAM is used to implement a cache. Modern CPUs often include several megabytes of memory on-die which can be leveraged to create a Cache-as-RAM (CAR) execution environment <ref type="bibr" target="#b26">[28]</ref>. Typically, CAR mode is used to perform system boot-up tasks while DRAM (external to the CPU) is initialized. Prior work has demonstrated that the CPU cache subsystem can be repurposed as a generalpurpose memory area for isolated code execution and data read/write operations <ref type="bibr" target="#b44">[46]</ref>. The CPU CAR environment offers an isolated execution environment using exclusively ondie hardware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">OASIS CPU INSTRUCTION SET</head><p>We first provide a high-level overview of the design, describing the requirements, execution model, and implementation rationale for the instruction set extension (ISE) proposed in the paper. The notation used in the remainder of the paper is summarized in Table <ref type="table" target="#tab_1">1</ref>.</p><p>Requirements. OASIS is a set of new CPU instructions that aim to enable an isolated execution environment contained entirely on chip by leveraging CAR mode execution, and by creating a secret key only available to the CPU (e.g., derived from an SRAM PUF). OASIS is designed for ease of adoption and deployment with respect to existing computing systems.</p><p>A central feature of OASIS is the PUF-derived secret key Kp only available within the CPU and which is used as the root of trust of the whole environment. OASIS is based on SRAM-PUFs <ref type="bibr" target="#b14">[16,</ref><ref type="bibr" target="#b15">17]</ref>. This has several advantages: (i) SRAM is already available on modern CPUs in the form of the cache, (ii) SRAM PUFs need to be powered to create the secret key material, thus, they cannot be read offline making them resistant against scanning electron microscope based attacks, (iii) because of their properties, PUFs are tamper-evident (and in some cases tamper-resistant), a property which other technologies do not offer <ref type="bibr" target="#b14">[16]</ref>, and (iv) SRAM is manufactured using the standard semiconductor process, which leads to decreased costs when compared to non-volatile memory.</p><p>OASIS assumes the availability of external non-secure nonvolatile memory. This memory is used to store public helper data as well as state and/or programs. External storage is plentiful and does not further complicate the OASIS design since no special security guarantees are assumed. In particular, alterations to the public helper data can be easily detected through the use of robust fuzzy extractors <ref type="bibr" target="#b3">[5,</ref><ref type="bibr" target="#b7">9]</ref>.</p><p>Root-of-Trust Instantiation. The SRAM-PUF response, pe, serves as a unique cryptographic secret which is used to bootstrap a unique device identity, per-application encryption and authentication keys, and random number generation. The resulting key material is unique not just per physical device, but per device owner. The SRAM-PUF response is used to derive the secret root key, Kp, which never leaves the processor and is never directly accessible by any party (including any software running on the processor).</p><p>The PUF-derived secret root key, Kp, enables the derivation of a key hierarchy as follows. The device owner derives a key (Kpo) unique to themselves and the device via a We distinguish between three stages in the life cycle of the CPU. The first stage is performed by the hardware manufacturer (Figure <ref type="figure" target="#fig_0">1(a)</ref>). After manufacture, the HWM initializes the master processor key Kp by calling init[]. The output of this operation is helper data he and a hash H(pe, he), which is published and available to anyone using the device. We assume that the function init[] can be called only once or a limited number of times to prevent attacks that exploit repeated invocations of the generator function f_init_PUF[] (described below) to learn pe <ref type="bibr" target="#b7">[9]</ref>. Given that the HWM does not have control of the PUF response pe (or by extension Kp as it is derived from pe), the init[] instruction enables the limited trust (P 1.5), low cost (P 2.1), self contained (P 2.2), and the minimal TCB (P 3.1) properties of Section 2.2.</p><p>The second stage corresponds to the set-up of the key hierarchy for OASIS, performed by the device owner (Figure <ref type="figure" target="#fig_0">1(b)</ref>). This is accomplished by calling the create[] instruction, whose main purpose is to derive symmetric and asymmetric keys. These keys will be used to exchange confidential and authenticated messages between the prover (device owner) and the verifier (user) and to guarantee external verifiability (P 1.1). The main output of the instruction is a public key, which has been derived from the PUF-based root key Kp and a seed So known only to the device owner. This allows for transferability of the platform (P 1.4) as a new device owner can create his/her own public/private keypair (K + po bind , K -1 po bind ) by choosing a different seed S ′ o . Furthermore, even though the device owner initiates generation of the public/private keypair, only the CPU can access the private key and thus decrypt messages encrypted with the public key.</p><p>The third and last stage corresponds to the execution of code on the device by the user (Figure <ref type="figure" target="#fig_0">1(c)</ref>). Users will launch the code to be executed by issuing the launch[] instruction. This instruction populates the CR. * registers with the symmetric keys derived from the PUF helper data he, the device owner's seed So, and the public key informa- tion generated using create[] in the previous stage. Then, the unbind[] instruction can be called to check the input's integrity with respect to a code-specific key and decrypt any input whose confidentiality is preserved by the verifier. The instruction provides two options, one using public-key and one using symmetric-key primitives. The asymmetric option is used the first time the application is called to transmit a secret symmetric key, KV P , only known to the verifier (user) of the platform P . After this initial set-up, the verifier can use fast symmetric-key operations to verify integrity and confidentiality of its data (P 3.3). At this point the code C can be executed in the isolated execution environment, state is saved (and encrypted if desired), and integrity information is computed on the state using bind[] (P 1.3). Finally, all OASIS memory and internal registers are cleared out, and control is returned to the OS. Observe that any program can in principle be executed in a secure environment using these last three instructions, providing for a minimal and simple programming interface (P 3.2). Furthermore, the bind[] and unbind[] instructions, together with the key hierarchy derived with the help of create[], enable external verifiability (P 1.1) and program state binding (P 1.2), not only to a particular program but also to a specific CPU, a property unique to OASIS.</p><formula xml:id="formula_1">IEE entry IEE entry IEE entry init[] create[] launch[] unbind[] bind[] IEE exit IEE exit IEE exit (a) (b) (c)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">OASIS Functions and Instructions</head><p>We describe the functions and instructions used in the design of OASIS. We make a distinction between functions (which are only internally available to instructions) and instructions, (which are externally available for call by executing software). <ref type="foot" target="#foot_2">3</ref> In practice, functions and instructions might be implemented as digital logic, integrity-checked firmware, microcode, or another process-specific mechanism.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Function Descriptions</head><p>We have omitted explicit pseudocode definitions for several functions where the specific implementation is left to the hardware manufacturer. Table <ref type="table" target="#tab_4">3</ref>   </p><formula xml:id="formula_2">K + po bind , K -1 po bind ← f_rsa_key_gen[p, q, e]</formula><p>The function f_read_PUF[] does not accept any inputs; it simply outputs the raw PUF response pe. We provide two functions to interact with a (robust) fuzzy extractor <ref type="bibr" target="#b3">[5,</ref><ref type="bibr" target="#b7">9]</ref> as is common in the literature: (1) The function f_init_ PUF[pe, rand] accepts a raw PUF response pe and a random value rand and outputs helper data he and a hash H(pe, he). The helper data he can be used to reconstruct a uniformly random value Kp from a noisy raw PUF response p ′ e . The hash is used to guarantee that only values of Kp constructed with the original helper data he are used for further processing in OASIS. <ref type="bibr" target="#b0">(2)</ref> The function f_fuzzy_extract_PUF[p ′ e , he, H(pe, he)] accepts a (noisy) raw PUF response p ′ e and helper data he and outputs a uniformly random value Kp which can be used as a cryptographic key. The function f_ fuzzy_extract_PUF[] checks for correctness in the value of H(pe, he) and outputs a special symbol ⊥ if the input does not correspond to the computed value. If the output is ⊥, the instruction calling f_fuzzy_extract_PUF[] should take appropriate action. In the case of OASIS, we clear all key registers and abort execution.</p><p>We assume the use of existing hardware-supported fuzzy extractor implementations <ref type="bibr" target="#b2">[4,</ref><ref type="bibr" target="#b28">30]</ref> and the hash H(pe, he) into memory. Next, the PUF is read and the fuzzy extractor is invoked to generate the platform symmetric secret key, Kp. Internally, the fuzzy extractor checks whether the inputs H(pe, he) and he correspond with the reconstructed value. A special symbol ⊥ is output should the values be different.</p><p>The key Kp and the (device owner) supplied seed So are used to derive the master processor secret, CR.Kpo. The seed value So allows the device owner to personalize the processor keys. The symmetric key CR.Kpo is used for the derivation of four symmetric platform keys: (i) CR.S po bind , the platform binding secret, (ii) CR.K po auth , the platform key used for authenticating data residing in untrusted storage from prior invocations (iii) CR.Kpo encr , the platform key used for encrypting data and (iv) CR.K po code , the platform key used to derive code-specific keys. In all cases, keys are derived via a KDF, which in turn may use pseudorandom functions (e.g., HMAC, CMAC) as building blocks. Constructions of key derivation functions accepting secret and public parameters are well-known <ref type="bibr" target="#b5">[7,</ref><ref type="bibr" target="#b20">22]</ref>. At the end of the process, the function checks if the fuzzy extractor returned the special symbol ⊥, which would indicate that either the PUF response was too noisy and therefore it was not possible to reconstruct Kp or H(pe, he) = H(p ′ e , h ′ e ). In either case, all OASIS registers are cleared and the function returns the special symbol ⊥ indicating failure. After the check, Kp is cleared and S po bind is returned.</p><formula xml:id="formula_3">Func 2a hP K ← f_create_asym_keys[S po_bind ] p, q, ← f_find_primes[S po_bind , RSAParam.size] K + po bind , CR.K -1 po bind ← f_rsa_key_gen[p, q, e] {K -1 po bind }CR.K po encr ← EncCR.K po encr (CR.K -1 po bind ) τ ← MACCR.K po auth ({K -1 po bind }CR.K po encr , K + po bind ) hP K ← {K -1 po bind }CR.K po encr , K + po bind , τ if S po bind =⊥ then Clear CR. * Clear hP K return hP K Function 2a</formula><p>. This function generates the processor asymmetric keys. The f_find_primes[] function picks a random seed value of size RSAParam.size and begins search until the first prime is found. The process is repeated for the second prime using a new seed value. f_find_primes[] returns secret primes, p and q. The function f_rsa_key_gen[] takes the primes and a public exponent as inputs and generates the keypair K + po bind , K -1 po bind . Notice that the RSA private key K -1 po bind is composed of p, q, and the inverse of the RSA public exponent modφ(N ), where N = p • q. Methodologies to generate primes are well-understood and standardized <ref type="bibr" target="#b16">[18]</ref>. The RSA private key K -1 po bind is encrypted using CR.Kpo encr , and a message authentication code τ is computed over this value and the corresponding public key K + po bind . Finally, a data store hP K , containing the asymmetric keys and τ , is returned.</p><formula xml:id="formula_4">Func 2b hP K ← f_create_asym_keys[S po_bind ] K + po bind , CR.K -1 po bind ← f_ecc_key_gen[S po_bind , ECCParam] {K -1 po bind }CR.K po encr ← EncCR.K po encr (CR.K -1 po bind ) τ ← MACCR.K po auth ({K -1 po bind }CR.K po encr , K + po bind ) hP K ← {K -1 po bind }CR.K po encr , K + po bind , τ if S po bind =⊥ then Clear CR. * Clear hP K return hP K Function 2b.</formula><p>We describe an alternative implementation of the f_create_asym_keys[] (Function 2a) using elliptic curves in Function 2b. The implementation of this function is analogous but much more efficient than its RSA counterpart, since there is no prime search step. Key generation is a single elliptic curve multiplication, which in general is efficient. In addition, this version has the advantage of small area overhead, if support for asymmetric operations is implemented at the hardware level. These advantages come at the cost of a significant increase in the time required to perform a signature verification operation (when compared to RSA). It is up to the HWM to decide which implementation is more appropriate based on its own requirements and constraints.</p><formula xml:id="formula_5">Func 3 K + po bind ← f_read_asym_keys[hP K ] τ ′ ← MACCR.K po auth hP K . {K -1 po bind }CR.K po encr , K + po bind if hP K .τ = τ ′ then Clear CR. * Clear hP K .K + po bind else CR.K -1 po bind ← DecCR.K po encr (hP K .{K -1 po bind }CR.K po encr ) return hP K .K + po bind</formula><p>Function 3. This function is very efficient as it only requires symmetric cryptographic operations. In particular, f_read_asym_keys[] checks tag hP K .τ to ensure that input data has not been tampered with. If this verification passes, the function decrypts the private binding key to CR.K -1 po bind , using the symmetric key CR.Kpo encr . Note that the corresponding read functions, for create functions 2a and 2b, are the same except for the sizes of the operands, outputs, and registers required to store private and public keys.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Instruction Descriptions</head><formula xml:id="formula_6">Inst 1 {he, H(pe, he)} ← init[] pe ← f_read_PUF[] rand R ←-{0, 1} ℓ {he, H(pe, he)} ← f_init_PUF[pe, rand]</formula><p>Clear pe, rand return {he, H(pe, he)} Instruction 1. This instruction initializes the helper data he used to de-noise the raw SRAM PUF value pe. The functions f_read_PUF[] and f_init_PUF[] read the raw PUF value and instantiate the helper data, as described in Section 4.1.1. The hash value H(pe, he) will be used by later instructions to prevent modified helper data from being used in attempts to learn information about the PUF. Observe that a hardware-generated random number, rand, is used to introduce entropy in the resulting helper data's value.</p><p>The variable rand needs to remain secret and exposed only inside the processor. It is also assumed that he can only be set once (or a limited number of times) to prevent exposing the output of the fuzzy extractor. This can be achieved during the initialization, which is performed by the HWM. Because of our use of robust fuzzy extractors <ref type="bibr" target="#b3">[5,</ref><ref type="bibr" target="#b7">9]</ref>, we do not require any secure non-volatile memory. All data is stored outside the chip, either locally or externally published on a website. An additional step, not shown and not performed as part of Instruction 1 is the signing of he||H(pe, he) by the HWM or a TTP with output σ he ← Sign K -1 T T P (he||H(pe, he)). This guarantees to any third party (users, system integrators, device owners, etc.) that the helper data was created by the HWM and not some other (untrusted) party. Notice this is done only once during the lifetime of the device. Observe that hP K is encrypted and contains authentication information, which is verified internally by OASIS using a key derived from the internal PUF key and the seed So. Lastly, note that verification of the signature σ he is most efficient if the signature algorithm is based on RSA using a small exponent (e.g., 3, 17, or 2 16 + 1). Regardless of the latency due to signature verification, we expect that this step is performed rarely -e.g., whenever the device changes ownership or if a user desires to setup the environment for future use.   A possible optimization is to conditionally invoke f_cre-ate_sym_keys[] and f_read_asym_keys[]. For example, launch[] can be modified to only invoke f_create_sym_ keys[] once after the processor reboots and maintain the resulting keys in CR.* during successive OASIS sessions. This optimization must be carefully considered and constructed by the implementer to manage the security trade-off (PUFderived secrets persisting between invocations). Addition-To avoid the expensive operations performed in create[] for asymmetric key generation (e.g., prime generation), an encrypted data store hP K is returned by f_create_asym_ keys[] and f_read_asym_keys[hP K ] is used on subsequent invocations. This function's overhead is equivalent to a few efficient symmetric-key operations.</p><formula xml:id="formula_7">Inst 2 hP K ← create[So,</formula><p>Observe that if we want to make the public binding key available outside the environment, Instruction 2 must be called first. Also note that Instruction 2 verifies the signature σ he every time it executes, whereas Instruction 3 does not. We expect that signature verification will be performed at most once per session, where each session might call the launch[] instruction multiple times. Notice that even if the signature verification function is performed every time, the overhead should be minimal, assuming RSA signatures. Refer to Figure <ref type="figure" target="#fig_0">1</ref> for details on when instructions are called.</p><p>Next, launch[] stores a hash of the target code C to the platform configuration register CR.P CR. Finally, a symmetric key KC is generated using a key derivation function based on CR.K po code and a hash of target code C. KC is used for encrypting and authenticating the executing code's state for local storage to untrusted memory.</p><p>At the end of launch[], the following registers have been populated: CR.Kpo, CR.K po auth , CR.Kpo encr , CR.K po code , CR.K -1 po bind , CR.P CR, and CR.KC .</p><formula xml:id="formula_8">Inst 4 X ← unbind[{X1, P CR_ver} K + po_bind , {X2, P CR_ver}K C ] if {X1, P CR ver} K + po bind = N U LL then X, P CR ver ← Dec CR.K -1 po bind ({X1, P CR ver} K + po bind ) else if {X2, P CR ver}K C = N U LL then X, P CR ver ← AuthDecCR.K C ({X2, P CR ver}K C ) else X ←⊥</formula><p>if CR.P CR = P CR ver then X ←⊥ return X Instruction 4. Inputs X1 and X2 contain data values that should only be released to the code that generated the data. The unbind instruction provides assurance to the verifier that the inputs will only be released to the code with measurement P CR ver. Note that unbind[] can decrypt data encrypted under either of the binding key K + po bind or the application secret key KC .</p><p>In the protocol described in Section 5, included in X2 is a symmetric key KV P , which is generated by the verifier V for bulk encryption of data to be transferred between V and the platform P . Notice that we do not suggest using the public binding key, K + po bind , for bulk encryption. Instead, symmetric keys should be used for bulk encryption operations and the public binding key for storing bulk encryption keys. This is a common practice used to avoid the performance cost of public key cryptography.</p><p>In choosing the asymmetric encryption scheme, some care must be taken to prevent an attacker from using the ciphertext {X, P CR ver} K + po bind , which is intended to be decrypted only by the code with measurement P CR ver, to ally, the call to f_read_asym_keys[] may be skipped for sessions that only require symmetric keys. generate a related ciphertext {X, P CR ver ′ } K + po bind , which the device would be willing to decrypt for different code with measurement P CR ver ′ . To prevent this, the encryption scheme must be non-malleable -i.e., an attacker cannot use one ciphertext to generate a second ciphertext that decrypts to a plaintext related to the original plaintext. The formal definition of non-malleable is known as Chosen Ciphertex Attack of type 2 or CCA2. Examples of CCA2 (non-malleable) asymmetric encryption schemes include RSA-OAEP and RSA-OAEP+ <ref type="bibr" target="#b37">[39]</ref>. 5 An alternative strategy to using a non-malleable public-key encryption scheme is to use the secret encrypted with the asymmetric primitive to derive two keys: an encryption key and a MAC key. The MAC key should be used to compute a MAC over the bulkencrypted ciphertext, and the receiver should reject ciphertexts with an inconsistent MAC. This is the strategy used in the Integrated Encryption Scheme <ref type="bibr" target="#b36">[38]</ref>. In this work, we simply assume that we are using a CCA2 public-key encryption scheme regardless of its particular implementation.</p><p>Inst 5 out ← bind[KV P , stateOS, hashInputs, resultV, update]</p><formula xml:id="formula_9">if update = N U LL then C ′ ← AuthDecK V P (update) if C ′ =⊥ then CR.P CR ← H (C ′ ) CR.KC ← KDFCR.K po code (CR.P CR) out.OS ← AuthEncCR.K C (stateOS, CR.P CR) V.hosstate ← H(stateOS) V.hinp ← hashInputs V.encK ← AuthEncCR.K C (KV P , CR.P CR) V.res ← resultV out.V ← AuthEncK V P (V )</formula><p>Clear CR. * Clear all state return out Instruction 5. The bind[] instruction prepares data for transfer to the untrusted code. This instruction should be called by the executing code right before returning. Inputs to this instruction include a shared secret KV P , the application state stateOS, a hash of application input hashInputs, and the application results results. The variables out.OS and out.V are ciphertext to be stored in local memory and sent to the verifier, respectively. Please note that out.OS and V.encK bind stateOS and KV P to the launch point measurement of executing code C. Finally, observe that bind[] enables program code C updates. This is enabled by checking whether the update has been encrypted and authenticated with the shared secret KV P and upon successful verification, updating CR.P CR and CR.KC , accordingly. 5 Note that it is possible for an encryption scheme to be semantically secure while still being malleable <ref type="bibr" target="#b9">[11]</ref>. For example, in a hybrid scheme where RSA is used to encrypt a symmetric key, which is in turn used in a block cipher to encrypt the bulk data, then clearly the last block of the bulk-encrypted data can be modified without changing the decryption of the preceding plaintext blocks. This could allow the attacker to change the specified PCR if it appears at the end of bulk encrypted data. Even if the authorized PCR is at the beginning, the attacker would still be able to modify the end of the bulk data without changing the value of the preceding ciphertext.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">SECURE REMOTE EXECUTION</head><p>Figure <ref type="figure">2</ref> shows the protocol for the initial and subsequent executions of security sensitive application f oo(). We assume that the remote verifier V has a copy of the public platform binding key, K + po bind . Similarly, the verifier can keep a certificate that is used to confirm the authenticity of the public key it receives from the platform. We also assume that the verifier has access to the plaintext code.</p><p>In Step 1, the verifier V initiates an isolated execution session with the platform. V generates an encryption key KV P , and binds the hash of the code f oo() with KV P . Bind allows the verifier to encrypt data using the public part of the platform key while ensuring that only the correct code running in a correctly setup execution environment can access the data. The inputs along with the code are sent to the platform.</p><p>In Step 2, the OS calls the hardware instruction launch[] using the plaintext code f oo(), the verifier inputs V.inp, and the previously stored state OS.inp as inputs. If it is the first code execution OS.inp is empty.</p><p>In Step 3, the isolated execution environment IEE first checks inputs received from the verifier. If a "setup" command was received from the verifier the IEE attempts to unbind the encrypted inputs from V as follows. The IEE releases shared encryption key KV P , using the unbind[] instruction, and decrypts any private inputs, aborting execution if either operation fails. These checks prevent unauthorized code from proceeding. After the checks, the application logic is executed. For example, if the application is a secure counter, during the first iteration the counter is set to zero. In the case of an encrypted database, the first records could be stored in the database or all records could be initialized to zero.</p><p>Steps 4 and 5 show the parameters returned to the OS and the verifier, respectively. Step 5 is critical as it provides evidence to the verifier that the computation has been performed on the correct inputs and, in particular, that the inputs have not been manipulated prior to entering OASIS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">DISCUSSION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Linkable Code Blocks</head><p>So far, we have presented how an application C that is fully contained within the CPU cache is executed in OASIS. Recall that the unbind[] instruction guarantees that only C can access its protected state during future invocations by verifying that the loaded application has measurement H(C) before decrypting. Now we consider the case of an application that has size greater than the cache (e.g., application C = C0|C1| . . . |Cn where Ci refers to the i th application code block). Execution of more complex applications is achieved by computing a Merkle hash tree over the entire program, and binding the resulting tree's root value to the application state. The loaded code block Ci is accepted if and only if the hash tree validation succeeds.</p><p>The hash tree construction provides several nice properties. First, it extends state protection and load-time integrity checking to applications of arbitrary size. Second, it maintains a small TCB. Third, it enables efficient execution because code block Ci may be safely executed before the entire application C has been hashed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Rollback Prevention</head><p>A rollback attack occurs when old state is presented to the isolated execution environment. Since the stale state is cryptographically consistent, an isolated execution environment implemented without rollback prevention will incorrectly accept it -potentially bypassing stateful protection mechanisms to, for example, undo the append-only property of an audit log. Thus, rollback resistance is needed to guarantee state continuity of the executing application.</p><p>One technique for ensuring state continuity is to include a protected monotonic counter as part of the state <ref type="bibr" target="#b31">[33]</ref>. Another technique for rollback prevention is to keep a trusted summary (e.g., a hash) of the expected state. Parno et al. include a summary of the state history to permit reverting to a safe state in the case of an unexpected crash <ref type="bibr" target="#b34">[36]</ref>. These methods can be achieved by using protected nonvolatile memory for persistent storage of data describing the expected state. However, we seek a rollback prevention mechanism that enables OASIS to remain stateless between invocations. Additionally, we rule out using a trusted third party for state management.</p><p>What follows is a description of how the verifier can confirm state continuity using the OASIS instruction set. During the execution protocol, the unbind[] instruction is invoked to decrypt any state belonging to code C (Figure <ref type="figure">2</ref> step 3). After executing code C, the bind[] instruction is invoked to protect state destined for the OS as well as output destined for the verifier. Included in the output for the verifier is a summary of the current state, H (stateOS). The verifier output is encrypted under key KV P before transferring control to untrusted OS code for delivery to the verifier. The verifier includes this state summary as an input during the next invocation. If the state presented by the untrusted OS matches the expected state, the code executes and the new state summary is communicated to the verifier as acknowledgment. Otherwise, the protocol aborts. In this fashion, we achieve rollback prevention without requiring persistent application state in the OASIS TCB.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Distributed Deployment</head><p>We have presented cryptographic techniques for data secrecy, authenticity, and freshness. Still, the rollback prevention mechanism described thus far is insufficient if we consider the distributed deployment model where multiple verifiers collaborate through a remote service provider. In this asynchronous context, even if cryptographic techniques prevent forged responses and data snooping, a compromised OS can launch forking attacks by concealing the operations of one verifier from another. For example, a compromised server may simply omit the current state and replay an old state to the other verifiers.</p><p>Fork consistency ensures that all verifiers see the same operations log before an omission but no verifier can see any other verifier's operations after an omission fault (fork). Furthermore, the fork consistency condition enables the verifiers to detect a misbehaving service provider after a single omission.</p><p>Li et al. present a protocol for achieving fork consistency where each verifier maintains a signed version structure list <ref type="bibr" target="#b23">[25]</ref>. Each verifier signs increasing version numbers and appends these to their respective lists, allowing them to compare lists and detect a fork attack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Version Updating</head><p>To support version updating (i.e., updating code C to legitimate new code C ′ ), the application must implement an update command which calls bind[] with parameter update set (where the update parameter contains the new code version C ′ encrypted under key KV P ). The bind[] instruction first checks parameter update for authenticity and then updates CR.P CR and CR.KC using the new code version C ′ (refer to Table <ref type="table" target="#tab_2">2</ref> for definitions of variables and Instruction 5 for details on bind[]). In this way the application state of the current software version C is bound to the new software version C ′ . Accordingly, the next invocation of unbind[] will release the application state to C ′ .</p><p>The decryption and authentication operations prove to OASIS that the software originated from the verifier V as she is the only one in possession of the key KV P . It is possible to design an alternative update mechanism based on asymmetric operations which has the advantage that an entity different from V can provide an update C ′ , thus granting it access to the current OASIS state. However, this comes at the cost of requiring certification which would add complexity and computational overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Device Transferability</head><p>Recall that the device owner selects seed value So during key generation (refer to Function 1 for details). The seed value So enables derivation of owner-specific processor keys. Customization, via the owner-generated seed So, precludes previous device owners, including the manufacturer, from generating the same platform secret as the current owner. Thus, the device can be safely transferred. This protects the owners of new devices by limiting the ability of malicious parties (e.g., along the supply chain) to learn the platform secrets of the end user. This allows, for example, a device to be repurposed at a new business unit or sold to a new owner.</p><p>Please note that the owner-generated seed So effectively disassociates any resulting key material from the device manufacturer. Nevertheless, the owner needs a mechanism to prove the authenticity of their processor to a third party. A default seed value that is fixed for the life of the device may be included to support secure device transfer while still providing a mechanism for proving the authenticity of the executing platform. We refer to this default seed value as the identity seed value or So * . Next, a master signing key is derived from root secret Kp and identity seed So * . Certification can be handled by a third party for further unlinkability. In this way, secrets linked to the hardware are derived from the fixed identity seed So * whereas secrets exclusive to the owner are derived from the custom owner seed So.</p><p>Allowing the owner to choose any So as often as they like may allow an attacker to leak the root platform key Kp through cryptanalysis. This can be mitigated by ratelimiting requests for a fresh So. Upon request, the device generates a fresh seed value So and computes a MAC over it using a key derived from the root secret Kp and the identity seed value So * . This ensures that chosen values of So cannot be correlated with a response, during device initialization, to learn the root platform key Kp.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">PERFORMANCE EVALUATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">System Configuration</head><p>We model our proposed processor instruction set using Simics, a full-system simulator <ref type="bibr" target="#b29">[31]</ref>. We build a prototype system by adding our new instructions to the x86-hammer model. 6 We model a 2 GHz processor with non-unified L1 cache (64 KB data and instruction caches). We use a modified Linux 2.6.32 kernel as our target operating system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Microbenchmark Results</head><p>To evaluate micro-and macro-level benchmarks, we measure the performance of our implementation against TCGstyle implementations of common security-sensitive code operations. We use a pessimistic benchmark for the OASIS isolated execution environment and compare it to an optimistic benchmark for TCG 1.2. See Table <ref type="table" target="#tab_8">4</ref> for a list of the platform primitives and their associated costs. See Table <ref type="table" target="#tab_9">5</ref> for a comparison of performance overheads for OASIS and DRTM-based implementations. 7  We base the median performance costs associated with the cryptographic primitives by leveraging open source libraries LibTomCrypt and OpenSSL. 8 It is likely that these functions further increase in performance with a hardware implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Performance Advantages</head><p>We now present the performance advantages of our architecture as compared to a TPM implementation.</p><p>In terms of processor speed, cryptographic applications benefit from running on a processor core instead of a TPM. For example, the Infineon TPM co-processor operates at 33 MHz, which pales in comparison to even mid and low-end commodity processor speeds.</p><p>In terms of communication overhead, we avoid costly communication overheads by implementing cryptographic functions on chip instead of on a co-processor. For example, the TPM interfaces using the Low Pin Count (LPC) bus. The LPC is used to connect low-bandwidth devices to the CPU (4-bit-bus on a 33 MHz clock).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">RELATED WORK</head><p>Architecture Extensions. Hardware-based security mechanisms have been proposed and implemented by both commercial and academic groups. In terms of commercial hardwarebased IEE technologies, the main components are the Trusted Execution Environment (TEE) which provides capabilities for isolated execution and ensuring software is in a known good state before launch, and the Trusted Platform Module (TPM) which provides remote attestation, binding, and sealing capabilities. Popular TEE implementations include ARM Trust Zone [1], and Intel TXT <ref type="bibr" target="#b1">[3]</ref>. More recently, Intel has improved on the TXT architecture with the development of Intel SGX <ref type="bibr" target="#b17">[19]</ref>. These techniques can be combined with the OASIS API. For example, Enclaves from SGX would 6 x86-hammer is a hardware model representing a generic 64-bit AMD Operteron processor sans on-chip devices <ref type="bibr" target="#b45">[47]</ref>. 7 We have based performance overheads in Table <ref type="table" target="#tab_9">5</ref> on TPM benchmarks from <ref type="bibr" target="#b35">[37]</ref> where the reference DRTM implementation does not provide performance numbers for 2048-bit RSA operations. 8 LibTom: www.libtom.org. OpenSSL: www.openssl.org.  <ref type="bibr" target="#b11">[13]</ref>. SMART focuses on remote embedded devices (in particular, low-end microcontroller units (MCUs)) whereas we are applicable to high-end processors. Additionally, SMART investigates the usage of secret key material to establish a root of trust, assuming the existence of secure non-volatile memory to store the secret. In contrast, OASIS is based on the use of SRAM memory-based PUFs <ref type="bibr" target="#b14">[16,</ref><ref type="bibr" target="#b15">17]</ref>.</p><p>Previous work has explored hardware extensions designed for an adversary model where software and physical attacks are possible. Lie et al. present XOM, a hardware implementation of eXecute-only-memory <ref type="bibr" target="#b24">[26]</ref>. Similar to our adversary model, XOM assumes a completely untrusted OS. Unlike OASIS, XOM assumes a secure manufacturing process, allows secure XOM applications to access the platform secret, and requires secure non-volatile memory. Lee et al. present SP, a processor architecture for isolated execution <ref type="bibr" target="#b22">[24,</ref><ref type="bibr" target="#b10">12]</ref>. Similar to OASIS, SP does not require a secure manufacturing process; however, SP includes no immutable device secret which makes it a challenge to prove the authenticity of the executing platform to a third party.</p><p>Memory cloaking provides secrecy and integrity of application data while allowing the OS to carry on most of its memory management tasks by limiting the OS's data access to ciphertext. More recently, Williams et al. (Secure Exe- unbind[] with KC Set-up and HV Quote of PAL encrypted input cutables <ref type="bibr" target="#b47">[49]</ref>) and Chhabra et al. (SecureMe <ref type="bibr" target="#b6">[8]</ref>) propose an isolated execution environment using hardware-based memory cloaking. Secure Executables uses CPU-protected memory regions to store the register set (e.g., while a Secure Executable is suspended during a system call). This solution has the advantage of avoiding cryptographic operations; however, direct memory attacks may be possible (e.g., by a DMA-enabled hardware component). The root of trust in Secure Executables is based on a public/private keypair that is installed in the CPU during manufacturing. In our design, the manufacturer and the device owner (or system integrator) both contribute to initializing a root of trust. This reduces the possibility of any large-scale data breaches and also facilities repurposing the device for new owners. Se-cureMe improves upon previous cloaking methods by ensuring that the entire address space of the application remains protected at all times. OASIS differs from SecureMe in its usage model. Unlike SecureMe, OASIS enforces isolation in the strictest sense by suspending the OS for the duration of its sessions.</p><p>PUF-Based Secrets. Similar to our work, Suh et al. propose a secure processing architecture, AEGIS, that makes use of Physical Unclonable Functions for creating and protecting secrets <ref type="bibr" target="#b40">[42]</ref>. AEGIS consigns security-sensitive OS functionality (e.g., context switching and virtual memory management) to a security kernel. However, this approach faces the same problem as the trusted OS model -the resulting TCB can be quite large.</p><p>Alternate Deployment Models. Our ISE is inspired by the recommendations of McCune et al. <ref type="bibr" target="#b32">[34]</ref> but in contrast to previous approaches that use a TPM as the root of trust, we use a PUF-derived key, integrated within the processor. This integration increases performance and diminishes the possibility of attacks on the buses connecting the platform to the TPM.</p><p>We use hardware instructions to ensure strong isolation properties during the execution of self-contained securitysensitive code. Another alternative is to use a special-purpose hypervisor instead of additional hardware instructions. The hypervisor provides a less expensive alternative to hardware instruction set extensions and is significantly smaller than a full OS. Nonetheless, a disadvantage of this approach is that the hypervisor is trusted to enforce memory isolation and DMA protection for executing code and, accordingly, must be included in the TCB.</p><p>An alternative to extending functionality to the CPU is to use a secure co-processor <ref type="bibr" target="#b38">[40]</ref>. A dedicated TPM is the approach endorsed by the TCG. In terms of manufacturing, this approach has the advantage of decoupling system security from the production of traditional processors. A drawback of using co-processors, however, is a reduction of physical security due to the exposed bus. Additionally, the performance hit due to communicating over the bus is not suitable for minimal TCB execution where sessions are repeatedly setup and torn down. Alternatively, a co-processor could be included as an IP on a SoC which would provide speed, tighter control, and enhanced security. The motivation for extending the processor ISA rather than a SoC TPM implementation is cost savings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">CONCLUSION</head><p>Currently, TPM-based solutions have not reached widespread application in security-sensitive contexts, perhaps because TCG solutions lack protection against a more resourceful adversary, lack sufficient properties for end-to-end application protection, lack architectural safeguards against supply-chain compromises, or concerns over poor performance. OASIS offers a stronger degree of protection through highly efficient isolated execution with no hardware dependencies outside the CPU.</p><p>We have explored the extent to which minimal modifications to commodity CPUs can support isolated code execution. The ISA extensions explored in this research enable compute service providers and application developers to provide high-security assurance at low cost in terms of platform and software complexity.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: OASIS session during (a) initialization by the manufacturer, (b) setup by the device owner, and (c) code execution by the user.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>4</head><label>4</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>4</head><label>4</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Low-cost.  No substantial increase of manufacturing cost or complexity (e.g., by requiring non-volatile memory within the CPU). P 2.2 Self-contained. No requirement for additional hardware support such as secure co-processors or TPMs.</figDesc><table><row><cell>P 3 Essential. We aim for a balanced and simple design:</cell></row><row><cell>P 3.1 Minimal TCB. On-die isolated execution environ-</cell></row><row><cell>ment with trustworthy computing primitives en-</cell></row><row><cell>tirely within the CPU package.</cell></row><row><cell>P 3.2 Minimal Interface. Minimal interface with min-</cell></row><row><cell>imal controls, which presents a usable program-</cell></row><row><cell>ming abstraction.</cell></row><row><cell>P 3.3 Minimal Setup. Efficient environment setup where</cell></row><row><cell>expensive operations are bypassed during repeated</cell></row><row><cell>invocation.</cell></row><row><cell>P 1.3 Program State Binding. The ability to bind data</cell></row><row><cell>to code.</cell></row><row><cell>P 1.4 Device Transferability. The ability to transfer own-</cell></row><row><cell>ership of a chip without exposing the secrets of the</cell></row><row><cell>previous owner.</cell></row><row><cell>P 1.5 Limited Trust. The HWM should not have access</cell></row><row><cell>to any device secrets.</cell></row></table><note><p><p><p>1 Externally Verifiable. Attestable code execution that guarantees platform integrity, code integrity, launch point integrity, and unmodified code execution on the untrusted platform. P 1.2 Key Code Binding. Ensure that a unique cryptographic key is available to each distinct code module that executes in the isolated environment.</p>P 2 Economical. We would like the following economic objectives to be satisfied:</p>P 2.1</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Notation used in Instruction Set and Protocol</figDesc><table><row><cell cols="3">Notation</cell></row><row><cell></cell><cell cols="3">hw_inst[]</cell><cell>hardware instructions that make up the OA-</cell></row><row><cell></cell><cell></cell><cell></cell><cell>SIS programming interface are denoted using</cell></row><row><cell></cell><cell></cell><cell></cell><cell>a fixed-width font</cell></row><row><cell cols="4">f_hw_func[]</cell><cell>hardware functions are only accessible by OA-</cell></row><row><cell></cell><cell></cell><cell></cell><cell>SIS hardware instructions and are denoted us-</cell></row><row><cell></cell><cell></cell><cell></cell><cell>ing a fixed-width font identifier starting with</cell></row><row><cell></cell><cell></cell><cell></cell><cell>the letter f</cell></row><row><cell></cell><cell></cell><cell cols="2">y ← x</cell><cell>the value of x is assigned to variable y</cell></row><row><cell></cell><cell></cell><cell></cell><cell>⊥</cell><cell>this symbol is used to denote a failed platform</cell></row><row><cell></cell><cell></cell><cell></cell><cell>operation</cell></row><row><cell></cell><cell></cell><cell></cell><cell>x||y</cell><cell>concatenation of x and y</cell></row><row><cell></cell><cell cols="3">x.param</cell><cell>returns parameter param of variable x</cell></row><row><cell></cell><cell></cell><cell></cell><cell>x. *</cell><cell>data element formed by concatenating all pa-</cell></row><row><cell></cell><cell></cell><cell></cell><cell>rameters of variable x</cell></row><row><cell cols="4">A → B : m</cell><cell>A sends message m to B</cell></row><row><cell>r</cell><cell cols="3">R ←-{0, 1} ℓ</cell><cell>assigns a random integer of ℓ bits to r</cell></row><row><cell></cell><cell></cell><cell></cell><cell>KX</cell><cell>party X's symmetric key</cell></row><row><cell></cell><cell cols="3">K + X , K -1 X</cell><cell>party X's public and private asymmetric key pair</cell></row><row><cell></cell><cell></cell><cell cols="2">{P }K</cell><cell>the resulting ciphertext of plaintext P en-</cell></row><row><cell></cell><cell></cell><cell></cell><cell>crypted using key K</cell></row><row><cell></cell><cell></cell><cell cols="2">H (x)</cell><cell>cryptographic hash function with input x</cell></row><row><cell></cell><cell cols="3">EncK(P )</cell><cell>encrypt plaintext P using key K</cell></row><row><cell></cell><cell cols="3">DecK(C)</cell><cell>decrypt ciphertext C using key K</cell></row><row><cell></cell><cell cols="3">KDFK(x)</cell><cell>key derivation function of key K and non-</cell></row><row><cell></cell><cell></cell><cell></cell><cell>secret parameter x</cell></row><row><cell></cell><cell cols="3">MAC K (x)</cell><cell>message authentication code of x under key K</cell></row><row><cell cols="3">Sign K -1 X</cell><cell>(m)</cell><cell>sign message m with party X's private key K -X</cell></row><row><cell cols="2">Verify K + X</cell><cell cols="2">(m, σ)</cell><cell>verify signature σ on message m using party X's public key K + X</cell></row><row><cell cols="4">Certy(x, K + X )</cell><cell>certificate issued by y that binds the identity x to the public key K + X</cell></row><row><cell cols="4">key derivation function (KDF), which accepts as inputs an</cell></row><row><cell cols="4">owner supplied seed, So, and the PUF-derived secret root</cell></row><row><cell cols="4">key, Kp. This master processor secret, Kpo, can then be</cell></row><row><cell cols="4">used, in turn, to derive symmetric keys for bulk encryption,</cell></row><row><cell cols="4">authentication, and asymmetric operations. The details are</cell></row><row><cell cols="4">provided in Section 4.1.</cell></row><row><cell cols="4">All keys are stored inside the CPU in a set of special pur-</cell></row><row><cell cols="4">pose cache registers (CR. * ) which are only available within</cell></row><row><cell cols="4">the OASIS environment and only accessible by the OASIS</cell></row><row><cell cols="4">instructions. Table 2 lists the keys stored in CR. * . Observe</cell></row><row><cell cols="4">that the root key, Kp, is only used for the derivation of the</cell></row><row><cell cols="4">master processor secret. More importantly, the entire key</cell></row><row><cell cols="4">hierarchy is based on an owner seed (So), enabling person-</cell></row><row><cell cols="4">alization and device transferability.</cell></row><row><cell cols="4">ISE Overview and Flow. Next, we describe how the</cell></row><row><cell cols="4">PUF-based root-of-trust is used to enable the desired secu-</cell></row><row><cell cols="4">rity objectives of Section 2.2 by defining five new instruc-</cell></row><row><cell cols="4">tions: init[], create[], launch[], unbind[], and bind[].</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>Variables used in Instruction Set and Protocol.</figDesc><table><row><cell cols="2">Hidden Variables: values accessible by processor</cell></row><row><cell>pe</cell><cell>Raw PUF response</cell></row><row><cell>Kp</cell><cell>Root key generated from PUF</cell></row><row><cell>So</cell><cell>Secret seed value set by platform owner</cell></row><row><cell>p  *  ,q  *</cell><cell>Primes corresponding to an RSA private key</cell></row><row><cell>CR.Kpo</cell><cell>Master platform secret for a specific owner</cell></row><row><cell></cell><cell>seed</cell></row><row><cell>CR.K po auth</cell><cell>Platform key for authenticating data from un-</cell></row><row><cell></cell><cell>trusted storage</cell></row><row><cell>CR.Kpo encr</cell><cell>Platform key for encrypting data before trans-</cell></row><row><cell></cell><cell>fer to untrusted storage</cell></row><row><cell>CR.K po code</cell><cell>Platform key used to derive code specific keys</cell></row><row><cell>CR.S po bind</cell><cell>Platform binding secret used to derive asym-</cell></row><row><cell></cell><cell>metric binding keys</cell></row><row><cell>CR.K -1 po bind</cell><cell>Platform private binding key, derived deter-ministically from CR.S po bind</cell></row><row><cell>CR.P CR</cell><cell>Platform configuration registers</cell></row><row><cell>CR.KC</cell><cell>Unique cryptographic key for code C</cell></row></table><note><p><p><p><p><p>′</p>Visible Variables: values accessible by software</p>K + po bind</p>Platform public binding key, derived deterministically from CR.S po bind he</p>Helper data used for noise reduction of pe hP K Helper data used for generating asymmetric keys</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>lists these functions.</figDesc><table /><note><p>The functionality of f_read_PUF[], f_init_PUF[] and f_ fuzzy_extract_PUF[] is briefly discussed next.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 :</head><label>3</label><figDesc>Hardware Manufacturer Implemented Functions</figDesc><table><row><cell>pe</cell><cell>← f_read_PUF[]</cell></row><row><cell>he, H(pe, he)</cell><cell>← f_init_PUF[pe, rand]</cell></row><row><cell>Kp</cell><cell>← f_fuzzy_extract_PUF[pe, he, H(pe, he)]</cell></row><row><cell>p, q</cell><cell>← f_find_primes[S po_bind , RSAParam.size]</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>. The functions f_read_ PUF[], f_init_PUF[] and f_fuzzy_extract_PUF[] are only available to the OASIS hardware instructions defined in Section 4 and they cannot be accessed by any software directly. KDFK p (So) S po bind ← KDFCR.K po ("bind") CR.K po auth ← KDFCR.K po ("auth") CR.Kpo encr ← KDFCR.K po ("encr") CR.K po code ← KDFCR.K po ("code") if Kp =⊥ then</figDesc><table><row><cell>Clear CR. *</cell></row><row><cell>S po bind ←⊥</cell></row><row><cell>Clear Kp</cell></row><row><cell>return S po bind</cell></row><row><cell>Function 1. This function loads the helper parameter h ′ e</cell></row></table><note><p>Func 1 S po bind ← f_create_sym_keys[So, he, H(pe, he)] p ′ e ← f_read_PUF[] Kp ← f_fuzzy_extract_PUF[p ′ e , he, H(pe, he)] Clear p ′ e CR.Kpo ←</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>he, H(pe, he), σ he , K + T T P ]</figDesc><table><row><cell>(he||H(pe, he), σ he ) = accept then S po bind ← f_create_sym_keys[So, he, H(pe, he)] if Verify K + T T P</cell></row><row><cell>hP K ← f_create_asym_keys[S po_bind ]</cell></row><row><cell>Clear S po bind</cell></row><row><cell>return hP K</cell></row><row><cell>else</cell></row><row><cell>ABORT</cell></row><row><cell>Instruction 2. This instruction generates a hierarchy of</cell></row><row><cell>cryptographic keys from the raw PUF response pe. Symmet-</cell></row><row><cell>ric and asymmetric keys are generated by f_create_sym_</cell></row><row><cell>keys[] (Function 1) and f_create_asym_keys[] (Function 2a</cell></row><row><cell>or 2b), respectively.</cell></row><row><cell>The hP K variable is assigned the {K + po bind , K -1 po bind } key-pair generated by f_create_asym_keys[].</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>Inst 3 launch[C, C.inputs, So, he, H(pe, he), hP K ]</figDesc><table><row><cell>Configure CPU into CAR Mode</cell></row><row><cell>Load C into the CPU cache</cell></row><row><cell>S po bind ← f_create_sym_keys[So, he, H(pe, he)]</cell></row><row><cell>K + po bind ← f_read_asym_keys[hP K ]</cell></row><row><cell>CR.P CR ← H (C)</cell></row><row><cell>CR.KC ← KDFCR.K po code (H (C))</cell></row><row><cell>if (S po bind =⊥) then</cell></row><row><cell>Clear CR. *</cell></row><row><cell>ABORT</cell></row><row><cell>Clear S po bind</cell></row><row><cell>Transfer control to C's entry point</cell></row><row><cell>Instruction 3. The launch[] instruction is designed to</cell></row><row><cell>setup the OASIS environment for code C and populate all</cell></row><row><cell>necessary registers. It begins by setting up a clean-slate</cell></row><row><cell>CAR environment, including disabling interrupts and hard-</cell></row><row><cell>ware debugging access. It then reads and loads CR. *  regis-</cell></row><row><cell>ters with cryptographic key material for further processing</cell></row><row><cell>by other instructions.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 4 :</head><label>4</label><figDesc>Performance overheads for platform operations used to instrument the OASIS isolated execution environment hardware simulation. Times are based on a 2 GHz processor clock.</figDesc><table><row><cell></cell><cell></cell><cell cols="2">avg (of 2 10 executions)</cell></row><row><cell></cell><cell></cell><cell>cycles</cell><cell>time(ms)</cell></row><row><cell cols="2">Platform Support</cell><cell></cell><cell></cell></row><row><cell>rand</cell><cell>R ←-{0, 1} ℓ</cell><cell>1.6 K</cell><cell>7.91 • 10 -4</cell></row><row><cell cols="2">f_read_PUF</cell><cell cols="2">˜2.55 • 10 -5</cell></row><row><cell cols="2">f_init_PUF</cell><cell cols="2">˜2.40 • 10 -5</cell></row><row><cell cols="2">f_fuzzy_extract_PUF</cell><cell cols="2">˜3.30 • 10 -5</cell></row><row><cell cols="2">Crypto</cell><cell></cell><cell></cell></row><row><cell cols="2">H(pe)</cell><cell>4.9 K</cell><cell>2.49 • 10 -3</cell></row><row><cell cols="2">KDFCR.K po</cell><cell>20.9 K</cell><cell>1.04 • 10 -2</cell></row><row><cell cols="2">f_sym_encrypt</cell><cell>1.2 K</cell><cell>6.02 • 10 -4</cell></row><row><cell cols="2">f_sym_decrypt</cell><cell>1.2 K</cell><cell>6.12 • 10 -4</cell></row><row><cell cols="2">f_rsa_key_gen</cell><cell>3.2 B</cell><cell>1.61 • 10 +3</cell></row><row><cell cols="2">f_rsa_encrypt</cell><cell>3.08 M</cell><cell>1.54 • 10 +0</cell></row><row><cell cols="2">f_rsa_decrypt</cell><cell>65.7 M</cell><cell>3.29 • 10 +1</cell></row><row><cell cols="2">(m) X Sign K -1 X Verify K + (m, σ)</cell><cell>65.9 M 3.1 M</cell><cell>3.30 • 10 +1 1.53 • 10 +0</cell></row><row><cell cols="2">OASIS Functions</cell><cell></cell><cell></cell></row><row><cell cols="2">f_create_sym_keys</cell><cell>104 K</cell><cell>5.21 • 10 -2</cell></row><row><cell cols="2">f_create_asym_keys</cell><cell>3.7 B</cell><cell>1.84 • 10 +3</cell></row><row><cell cols="2">f_read_asym_keys</cell><cell>18.5 K</cell><cell>9.26 • 10 -3</cell></row><row><cell cols="2">OASIS Instructions</cell><cell></cell><cell></cell></row><row><cell>init</cell><cell></cell><cell>7.2 K</cell><cell>3.58 • 10 -3</cell></row><row><cell cols="2">create</cell><cell>4.3 B</cell><cell>2.16 • 10 +3</cell></row><row><cell cols="2">launch</cell><cell>137 K</cell><cell>6.84 • 10 -2</cell></row><row><cell cols="2">unbind with asym</cell><cell>68.1 M</cell><cell>3.40 • 10 +1</cell></row><row><cell cols="2">unbind with sym</cell><cell>17.9 M</cell><cell>8.95 • 10 +0</cell></row><row><cell>bind</cell><cell></cell><cell>3.12 M</cell><cell>1.56 • 10 +0</cell></row><row><cell cols="4">replace CAR mode based memory isolation to support ap-</cell></row><row><cell cols="3">plications of much larger size.</cell><cell></cell></row><row><cell cols="4">Similar to our work, Defrawy et al. propose SMART, an</cell></row><row><cell cols="4">architecture for establishing a dynamic root of trust in re-</cell></row><row><cell cols="2">mote devices</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table 5 :</head><label>5</label><figDesc>Comparison of performance overheads by invocation scenario.</figDesc><table><row><cell>Scenario</cell><cell>OASIS</cell><cell></cell><cell>DRTM</cell><cell></cell></row><row><cell></cell><cell>operation(s)</cell><cell>time</cell><cell>operation(s)</cell><cell>time</cell><cell>ref.</cell></row><row><cell>One Time</cell><cell>init[]</cell><cell>3.6 µsec</cell><cell>NV Write, TPM 2048 Root Key Generation</cell><cell cols="2">&gt; 25 sec [37]</cell></row><row><cell>One Time per Owner</cell><cell>create[]</cell><cell>2.6 sec</cell><cell>TrustVisor-modeled AIK Generation:</cell><cell cols="2">&gt; 25 sec [37]</cell></row><row><cell></cell><cell></cell><cell></cell><cell>TPM and µT P M 2048 AIK Generation</cell><cell></cell></row><row><cell>Per Module Launch</cell><cell>launch[] and</cell><cell>34.1 msec</cell><cell>TrustVisor-modeled DRTM:</cell><cell cols="2">&gt; 1.8 sec [32]</cell></row><row><cell>(First Time)</cell><cell>unbind[] with K + po bind encrypted input</cell><cell></cell><cell>Transfer SLB over LPC, Unseal µT P M keys, quote SLB, µT P M HV Quote of PAL</cell><cell></cell></row><row><cell>Per Module Launch</cell><cell>launch[] and</cell><cell>9.0 msec</cell><cell>TrustVisor-modeled DRTM:</cell><cell cols="2">22 msec [32]</cell></row><row><cell>(Repeated Invocation)</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>For example, a cloud service provider may unintentionally grant datacenter access to malicious<ref type="bibr" target="#b18">[20]</ref> or negligent<ref type="bibr" target="#b41">[43]</ref> employees.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>The new Intel random number generator is based on the instability of a couple of cross-coupled inverters, which are the basic building block of an SRAM cell<ref type="bibr" target="#b42">[44]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>Instructions and functions are denoted using a fixed-width identifier. Functions begin with 'f_'. See Table1.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">ACKNOWLEDGMENTS</head><p>We are thankful to Olatunji Ruwase, Chen Chen, Yanlin Li, and Siddhartha Chhabra for their insightful discussions and for making valuable suggestions for completing this work, and to the anonymous reviewers for their detailed comments and valuable feedback.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"> *   <p>This research was supported in part by CyLab at Carnegie Mellon under grants DAAD19-02-1-0389 from the Army Research Office, and by a gift from Robert Bosch LLC. The views and conclusions contained here are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of ARO, Robert Bosch LLC, CMU, CyLab, or the U.S. Government or any of its agencies.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>During the initial invocation the verifier V uses the public platform key K + po bind to establish shared secret KV P which is used for repeat invocations.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m">The CDW 2011 Cloud Computing Tracking Poll, 2011. Available at www.cdw.com</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Intel Trusted Execution Technology (Intel TXT) -Software Development Guide</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>Document Number: 315168-009 Available at www.intel.com</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Efficient Helper Data Key Extractor on FPGAs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bösch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Guajardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-R</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shokrollahi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Tuyls</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Cryptographic Hardware and Embedded Systems (CHES)</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Secure Remote Authentication Using Biometric Data</title>
		<author>
			<persName><forename type="first">X</forename><surname>Boyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology (EUROCRYPT)</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">Brian</forename><surname>Krebs</surname></persName>
		</author>
		<ptr target="http://krebsonsecurity.com" />
		<title level="m">Coordinated ATM Heist Nets Thieves $13M, 2011</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Recommendation for Key Derivation Using Pseudorandom Functions (Revised)</title>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NIST Special Publication</title>
		<imprint>
			<biblScope unit="page" from="800" to="108" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">SecureME: A Hardware-Software Approach to Full System Security</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chhabra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Rogers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Solihin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Prvulovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM International conference on Supercomputing (ICS)</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Robust Fuzzy Extractors and Authenticated Key Agreement from Close Secrets</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Reyzin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology</title>
		<imprint>
			<publisher>CRYPTO</publisher>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Fuzzy Extractors: How to Generate Strong Keys from Biometrics and Other Noisy Data</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Reyzin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology (EUROCRYPT</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Non-Malleable Cryptography</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dolev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Dwork</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Hardware-rooted trust for secure key management and transient trust</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Dwoskin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM conference on Computer and communications security (CCS</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">SMART: Secure and Minimal Architecture for (Establishing a Dynamic) Root of Trust</title>
		<author>
			<persName><forename type="first">K</forename><surname>El Defrawy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Francillon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Perito</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Tsudik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Network and Distributed System Security Symposium</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Controlled Physical Random Functions</title>
		<author>
			<persName><forename type="first">B</forename><surname>Gassend</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Van Dijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Annual Computer Security Applications Conference (ACSAC)</title>
		<meeting>Annual Computer Security Applications Conference (ACSAC)</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Silicon Physical Random Functions</title>
		<author>
			<persName><forename type="first">B</forename><surname>Gassend</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Van Dijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM conference on Computer and Communications Security (CCS</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">FPGA Intrinsic PUFs and Their Use for IP Protection</title>
		<author>
			<persName><forename type="first">J</forename><surname>Guajardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G.-J</forename><surname>Schrijen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Tuyls</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Cryptographic Hardware and Embedded Systems (CHES)</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Power-Up SRAM State as an Identifying Fingerprint and Source of True Random Numbers</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Holcomb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">P</forename><surname>Burleson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Fu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>IEEE Trans. Computers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><surname>Ieee</surname></persName>
		</author>
		<ptr target="www.ieee.org" />
		<title level="m">Standard Specifications for Public-Key Cryptography -IEEE Std 1363 T M -2000, 2000</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Innovative Technology for CPU Attestation and Sealing</title>
		<author>
			<persName><forename type="first">Ittai</forename><surname>Anati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Shay Gueron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Hardware Architecture for Security and Privacy</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Google Confirms That It Fired Engineer For Breaking Internal Privacy Policies</title>
		<author>
			<persName><forename type="first">Jason</forename><surname>Kincaid</surname></persName>
		</author>
		<ptr target="http://techcrunch.com" />
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A Fuzzy Commitment Scheme</title>
		<author>
			<persName><forename type="first">A</forename><surname>Juels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wattenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM conference on Computer and Communications Security (CCS)</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Cryptographic Extraction and Key Derivation: The HKDF Scheme</title>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology</title>
		<imprint>
			<publisher>CRYPTO</publisher>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Reconfigurable Physical Unclonable Functions -Enabling Technology for Tamper-Resistant Storage</title>
		<author>
			<persName><forename type="first">K</forename><surname>Kursawe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-R</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Schellekens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Skoric</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Tuyls</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE International Workshop on Hardware-Oriented Security and Trust</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Architecture for Protecting Critical Secrets in Microprocessors</title>
		<author>
			<persName><forename type="first">R</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kwan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mcgregor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dwoskin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Computer Architecture (ISCA)</title>
		<meeting>the International Symposium on Computer Architecture (ISCA)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Secure Untrusted Data Depository (SUNDR)</title>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mazières</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Shasha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Symposium on Operating Systems Design &amp; Implementation (OSDI</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Architectural Support for Copy and Tamper Resistant Software</title>
		<author>
			<persName><forename type="first">D</forename><surname>Lie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Thekkath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Horowitz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>ACM SIGPLAN Notices</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">New Shielding Functions to Enhance Privacy and Prevent Misuse of Biometric Templates</title>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Linnartz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Tuyls</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International conference on Audio and Video Based Biometric Person Authentication (AVBPA)</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">CAR: Using Cache as RAM in LinuxBIOS</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L.-T</forename><surname>Lo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Watson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Minnich</surname></persName>
		</author>
		<ptr target="http://rere.qmqm.pl/mirq" />
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">One year after DigiNotar breach, Fox-IT details extent of compromise</title>
		<author>
			<persName><forename type="first">Lucian</forename><surname>Constantin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note>wired.com</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Low-Overhead Implementation of a Soft Decision Helper Data Algorithm for SRAM PUFs</title>
		<author>
			<persName><forename type="first">R</forename><surname>Maes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Tuyls</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Verbauwhede</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Cryptographic Hardware and Embedded Systems (CHES)</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Simics: A full system simulation platform</title>
		<author>
			<persName><forename type="first">P</forename><surname>Magnusson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Christensson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Eskilson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Forsgren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hallberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hogberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Larsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moestedt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Werner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">TrustVisor: Efficient TCB Reduction and Attestation</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Mccune</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Qu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Datta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">D</forename><surname>Gligor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Flicker: An Execution Infrastructure for TCB Minimization</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Mccune</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Isozaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM European Conference in Computer Systems (EuroSys)</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">How Low Can You Go? Recommendations for Hardware-Supported Minimal TCB Code Execution</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Mccune</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Seshadri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Physical One-way Functions</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Pappu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Recht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Gershenfeld</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Available at web.media</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>mit.edu</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Memoir: Practical state continuity for protected modules</title>
		<author>
			<persName><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Lorch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Douceur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Mickens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Mccune</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">TPM-SIM: A Framework for Performance Evaluation of Trusted Platform Modules</title>
		<author>
			<persName><forename type="first">J</forename><surname>Schmitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Loew</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Elwell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Ponomarev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">B</forename><surname>Abu-Ghazaleh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Design Automation Conference</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">A Proposal for an ISO Standard for Public Key Encryption</title>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Version 2.1, 2001. Available at www.shoup.net</note>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
		<author>
			<persName><surname>Reconsidered</surname></persName>
		</author>
		<title level="m">Advances in Cryptology (CRYPTO) (2001). Available at www.shoup.net</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">building a high-performance, programmable secure coprocessor</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Weingart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Networks</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Cloud data protection for the masses</title>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Shankar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">AEGIS: A Single-Chip Secure Processor</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Suh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>O'donnell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>Information Security Technical Report</note>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">Symantec-Sponsored Ponemon Report Finds Negligent Employees Top Cause of Data Breaches in the U.S. While Malicious Attacks Most Costly</title>
		<author>
			<persName><surname>Symantec</surname></persName>
		</author>
		<ptr target="www.symantec.com" />
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Behind Intel&apos;s New Random-Number Generator</title>
		<author>
			<persName><forename type="first">G</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Cox</surname></persName>
		</author>
		<ptr target="http://spectrum.ieee.org" />
	</analytic>
	<monogr>
		<title level="j">IEEE Spectrum</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Read-Proof Hardware from Protective Coatings</title>
		<author>
			<persName><forename type="first">P</forename><surname>Tuyls</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G.-J</forename><surname>Schrijen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Skoric</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van Geloven</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Verhaegh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wolters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Cryptographic Hardware and Embedded Systems (CHES)</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">CARMA: A Hardware Tamper-Resistant Isolated Execution Environment on Commodity x86 Platforms</title>
		<author>
			<persName><forename type="first">A</forename><surname>Vasudevan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mccune</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Newsome</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Van Doorn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Information, Computer and Communications Security</title>
		<imprint>
			<publisher>ASIACCS</publisher>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">Simics x86-440BX Target Guide</title>
		<author>
			<persName><surname>Virtutech</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Flash Memory for Ubiquitous Hardware Security Functions: True Random Number Generation and Device Fingerprints</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Kei Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Malysa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Suh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">C</forename><surname>Kan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">CPU Support for Secure Executables</title>
		<author>
			<persName><forename type="first">P</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Boivie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Trust and Trustworthy Computing</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
