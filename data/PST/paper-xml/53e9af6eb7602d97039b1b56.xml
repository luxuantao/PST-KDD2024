<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Automated Verification of Remote Electronic Voting Protocols in the Applied Pi-calculus</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Michael</forename><surname>Backes</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Saarland University</orgName>
								<address>
									<settlement>Saarbrücken</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">MPI-SWS</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Cȃtȃlin</forename><surname>Hriţcu</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Saarland University</orgName>
								<address>
									<settlement>Saarbrücken</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Matteo</forename><surname>Maffei</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Saarland University</orgName>
								<address>
									<settlement>Saarbrücken</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Automated Verification of Remote Electronic Voting Protocols in the Applied Pi-calculus</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">B0070C4B2F3D559416787E6216F0E4F9</idno>
					<idno type="DOI">10.1109/CSF.2008.26</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T10:23+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present a general technique for modeling remote electronic voting protocols in the applied pi-calculus and for automatically verifying their security. In the first part of this paper, we provide novel definitions that address several important security properties. In particular, we propose a new formalization of coercion-resistance in terms of observational equivalence. In contrast to previous definitions in the symbolic model, our definition of coercion-resistance is suitable for automation and captures simulation and forcedabstention attacks. Additionally, we express inalterability, eligibility, and non-reusability as a correspondence property on traces. In the second part, we use ProVerif to illustrate the feasibility of our technique by providing the first automated security proof of the coercion-resistant protocol proposed by Juels, Catalano, and Jakobsson.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Electronic voting is receiving increasing attention from governments, mass media, and the scientific community. On the one hand, electronic voting promises to simplify the voting procedure, to automate the count of votes, to guarantee the correctness of elections, and to prevent voter coercion. On the other hand, the errors in protocol design and the vulnerabilities in implementations <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b9">10]</ref> raise considerable concerns about the reliability and safety of electronic voting systems <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b22">23]</ref>. This is not particularly surprising since designing security protocols has long been known to be errorprone. The distributed system aspects of multiple interleaved protocol runs render security analyses of such protocols awkward to make for humans. Formal methods, and in particular language-based techniques, e.g., <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b21">22]</ref>, constitute salient tools for reliably analyzing security protocols. The main advantage of these techniques is automation: the human effort is limited to the specification of the protocol in a process calculus and the analysis is fully automated.</p><p>Coming up with a careful formalization and techniques for automated verification of electronic voting systems is arguably of paramount importance for the widespread acceptance of such systems in the scientific community, and hence might ultimately facilitate their successful deployment. While attention has been traditionally focused on the problem of supervised voting, where voters interact with a computing device under the supervision of election authorities, the more general and harder problem to solve is the problem of remote voting, where no supervision of voters or computing devices is in place <ref type="bibr" target="#b15">[16]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.">Contributions</head><p>In this paper, we devise a general technique for modeling remote voting protocols in the applied pi-calculus <ref type="bibr" target="#b4">[5]</ref> and for automatically analyzing their security properties. Our contributions can be summarized as follows.</p><p>First, we formalize three fundamental properties of electronic voting protocols, namely inalterability (votes are not modified), eligibility (only eligible voters can vote), and nonreusability (every voter can vote only once). To the best of our knowledge, this is the first formalization of these properties by means of correspondence assertions <ref type="bibr" target="#b30">[31]</ref>, in contrast to previous formalizations as control-flow properties <ref type="bibr" target="#b27">[28]</ref>.</p><p>Second, we devise a novel formalization of coercionresistance for remote voting protocols. The formalization is given in terms of observational equivalence and is thus accessible to an automated analysis. Additionally, we formalize receipt-freeness and resistance to forced-abstention attacks in our setting, and we prove that under reasonable assumptions these properties are implied by coercion-resistance. Our formalizations are inspired by the seminal work of Delaune, Kremer, and Ryan <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b18">19]</ref>, which provides the first definitions in the symbolic model of vote-privacy, receiptfreeness, and coercion-resistance. In contrast to our formalization, however, their definitions of coercion-resistance are not amenable to automation since the one presented in <ref type="bibr" target="#b16">[17]</ref> is based on a new notion of adaptive simulation, while the one later proposed in <ref type="bibr" target="#b18">[19]</ref> uses a universal quantification over an infinite set of contexts. Furthermore, the former exhibits some undesirable properties, as the authors point out themselves <ref type="bibr" target="#b18">[19]</ref>, whereas the latter constrains the attacker to interact with the voter so that she casts a certain valid vote, i.e., the attacker is forced to essentially follow the intended protocol behavior. Additionally, these definitions do not consider forced-abstention attacks and do not apply to remote voting protocols.</p><p>Finally, we apply our technique to analyze the Juels, Catalano, and Jakobsson protocol <ref type="bibr" target="#b24">[25]</ref>. The protocol is specified in the applied pi-calculus and the analysis is successfully conducted by ProVerif <ref type="bibr" target="#b11">[12]</ref>, for an unbounded number of honest and corrupted voters. This protocol is particularly important since it was the first protocol in the literature to satisfy a formal definition of coercion-resistance, it serves as the basis for the development of many modern election schemes for remote voting, e.g., <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b26">27]</ref>, and it is the protocol underlying the recently proposed Civitas system <ref type="bibr" target="#b15">[16]</ref>. The Juels, Catalano, and Jakobsson protocol includes complex zero-knowledge proofs that so far have rendered an automated analysis of this protocol impossible. We solve the problem by exploiting a recently proposed technique <ref type="bibr" target="#b8">[9]</ref> to express protocols based on zero-knowledge proofs in the applied pi-calculus and to analyze them using ProVerif.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2.">Overview</head><p>Section 2 of the paper briefly reviews the applied picalculus and introduces the notation we use in the remainder of the paper. Section 3 explains how we model electronic voting protocols as applied pi-calculus processes. Section 4 presents the formalizations of several important security properties for remote voting protocols. In Section 5 we use our formal framework to model and analyze the security of the Juels, Catalano, and Jakobsson protocol using ProVerif. Section 6 concludes and provides directions for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">A Brief Review of the Applied Pi-calculus</head><p>We briefly recall the syntax and operational semantics of the applied pi-calculus from <ref type="bibr" target="#b4">[5]</ref>, and define the additional notation used in this paper. Terms are defined by means of a signature Σ, which is a set of function symbols, each with an arity. The set of terms is the term algebra built from names, variables, and function symbols in Σ applied to arguments. Let a, b, c range over channel names, and n, m over names of any sort. Also, let x, y, z range over variables and u range over both names and variables.</p><p>Terms are equipped with an equational theory E, i.e., an equivalence relation on terms that is closed under substitution of terms for variables and under application of term contexts (terms with a hole). We write E M = N for equality and E M = N and for inequality modulo E.</p><p>Plain processes are defined as follows. The null process 0 does nothing and is usually omitted from process specifications; νn.P generates a fresh name n and then behaves as P ; if M = N then P else Q behaves as P if E M = N , and as Q otherwise; a(x).P receives a message N from channel a and then behaves as P {N/x}; a N .P outputs message N on channel a and then behaves as P ; P | Q executes P and Q in parallel; !P generates an unbounded number of copies of P .</p><p>As usual, the scope of names and variables is delimited by restrictions and inputs. We write fv(P ) for the free variables and fn(P ) for the free names in a process P . We let M denote an arbitrary sequence M 1 , . . . , M k of terms, ν n a sequence νn 1 . . . νn k of name restrictions, and c M .P (resp. c( x).P ) the output (resp. input) of a tuple of terms, which can be encoded in the equational theory by the usual functions for pairs. Finally, for the sake of readability, we also use the processes let x = M in P and let x ∈ M in P , formally defined as νa.(a M | a(x).P ) and νa.(a M 1 | . . . | a M k | a(x).P ), with a / ∈ fn(P ), respectively.</p><p>A plain context is a plain process with a hole. Sequential contexts are plain contexts that do not include replications and parallel compositions. If C is a context, then let captured(C) be the sequence of names and variables that are in scope for the hole, ordered according to their position in C. When this causes no confusion we will abbreviate the process C[0] as C.</p><p>As for the pi-calculus, the operational semantics of the applied-pi calculus is defined in terms of structural equivalence (≡) and internal reduction (→). Structural equivalence captures rearrangements of parallel compositions and restrictions, and the equational rewriting of the terms in a process. Internal reduction defines the semantics of process synchronizations and conditionals. Additionally, observational equivalence (≈) captures the equivalence of processes with respect to their dynamic behavior. Two processes are observationally equivalent if no context can distinguish them. For the formal definitions of these relations, we refer to Appendix A.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Formalizing Electronic Voting Protocols</head><p>We define an election process as an unbounded number of voters and trusted election authorities that are running in parallel and are sharing certain secrets. We distinguish three kinds of voters: honest, corrupted, and ad-hoc. Honest voters are issued an identity by a special authority and behave according to the protocol specification. In the setting considered in this paper, where the registration phase is trusted but the voting phase is not, corrupted voters will register and then simply output all their registration secrets on a public channel, so that the attacker can impersonate them in order to mount any sort of attack. Finally, ad-hoc voters can behave arbitrarily; they do not necessarily follow the protocol, but are also not necessarily corrupted. They have predefined public identities that allow one to track them across different instances of an election process. For this reason they are very useful when formalizing security properties as observational equivalences between election processes (e.g., we will use them to define coercion-resistance, receipt-freeness, etc.). We give the formal definition of election processes below, followed by additional explanations. Definition 3.1 (Election Process) An election process is a closed plain process</p><formula xml:id="formula_0">EP ≡ ν n.(!V hon | !V cor | V id1 | . . . | V id k | ID | A 1 | . . . | A m )</formula><p>such that 1. there exist a private channel c id ∈ n and two sequential contexts V reg and V vote such that</p><formula xml:id="formula_1">V hon ≡ c id (x id ).V reg [let x v ∈ v in V vote ], captured(V reg ) ∩ captured(V vote ) = ∅</formula><p>, and v ⊆ fn(EP). We define v to be the set of valid votes;</p><p>2. there exists a process V c such that V cor ≡ c id (x id ).V c ;</p><p>3. there exists a process ID , and a public channel c id-pub ∈ n such that ID ≡ (!νid .c id id .c id-pub id .let</p><formula xml:id="formula_2">x id = id in ID ) | let x id = id 1 in ID | . . . | let x id = id k in ID ;</formula><p>where for all 1 ≤ i ≤ k we have id i / ∈ n, for all j = i we have id i = id j , and</p><formula xml:id="formula_3">c id ∈ fn(V reg ) ∪ fn(V vote ) ∪ fn(V c ) ∪ ( k i=1 fn(V idi )) ∪ fn(ID ) ∪ ( m i=1 fn(A i )) 4. there exist i ∈ [1, m], a public channel c votes ∈ n, a</formula><p>variable x, a process P , and a context C such that A i ≡ C[c votes x .P ] and c votes does not occur anywhere else in EP.</p><p>The restricted names n model the secrets (e.g., some private channels) shared between the voters, denoted by V , and the election authorities, denoted by A.</p><p>An honest voter process is denoted by V hon . It first receives an identity on the private channel c id , registers, selects one of the valid vote choices non-deterministically, and then casts this vote (Condition 1). Corrupted voters receive an identity and are then under the control of the attacker (Condition 2). Since they are replicated, the number of honest and corrupted voters is not bounded. The ad-hoc voter processes V idi denote voters with a predefined identity id i that do not necessarily follow the protocol, and are not replicated.</p><p>The ID process is an identity issuer that assigns to each voter a name that uniquely identifies her (Condition 3). These identities are public and hence known to attackers. They are used to make voter processes unique, and each voter holding a valid identity will be considered eligible in the election. Having public identities for voters is crucial when defining privacy properties, where the link between a vote and the identity of its originator has to be hidden, but both the votes and the identities of eligible voters have to be public. In addition, there exists some authority process A i that is in charge of tallying the valid votes and outputting them on a special channel c votes (Condition 4). These outputs constitute the result of the election.</p><p>Finally, we define an election context S as an election process with a hole that is in parallel composition with the voters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Formalizing the Security Properties</head><p>This section devises novel formalizations in the applied pi-calculus for several important security properties of electronic-voting protocols. We start by defining a soundness property that entails inalterability, eligibility, and nonreusability. Then, we propose a novel formalization of coercion-resistance based on the standard notion of observational equivalence. We prove that, under reasonable assumptions, our notion of coercion-resistance implies immunity to forced-abstention attacks, vote-privacy and receipt-freeness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Soundness</head><p>Correspondence assertions <ref type="bibr" target="#b30">[31]</ref> are a natural way to formulate the soundness of an electronic voting protocol. The idea is to impose a causality relation among certain protocol events in execution traces. We refer the interested reader to <ref type="bibr" target="#b3">[4]</ref> for the formal definition of events and execution traces in the applied pi-calculus. For our purpose, we annotate the election process EP with the following events: newid(id ) is triggered by the identity issuer after giving the identity id to an eligible voter; startid(id ) and startcorid(id ) mark the start of the registration phase for an honest or corrupted voter id , respectively; beginvote(id , v) records the start of the voting phase for the honest voter id with the intention to vote for candidate v, while corrupted voters cast votes without asserting any event; endvote(v) indicates the tallying of vote v by the authority responsible for this. Ad-hoc voters may be annotated as corrupted or honest, depending on their behavior. </p><formula xml:id="formula_4">EP ≡ ν n.(!V hon | !V cor | V id1 | . . . | V id k | ID | A 1 | . . . | A m ).</formula><p>annotated as follows:</p><p>1. V hon ≡ c id (x id ).startid(x id ).</p><p>V reg [let x v ∈ v in beginvote(x id , x v ).V vote ] and neither V reg nor V vote contain any event;</p><p>2. V cor ≡ c id (x id ).startcorid(x id ).V c where V c does not contain any event;</p><p>3. for each i we have that either V idi ≡ startid(id i ).V i with V i containing at most one beginvote(id i , v) event for some v, or V idi ≡ startcorid(id i ).V i where V i does not contain any event;</p><formula xml:id="formula_5">4. ID ≡ (!νid .newid(id ).c id id .c id-public id . let x id = id in ID ) | newid(id 1 ).let x id = id 1 in ID | . . . | newid(id k ).let x id = id k in ID where newid(•)</formula><p>does not occur anywhere else in EP, and ID does not contain any event;</p><p>5. A i ≡ C[endvote(x).c votes x .P ] and C, P and A j for j = i do not contain any event.</p><p>In the literature, soundness is typically defined as three separate properties: inalterability (no one can change anyone else's vote), eligibility (only eligible voters are able to vote) and non-reusability (every voter can vote only once). We define a single notion of soundness that encompasses these three properties. An annotated election process EP guarantees soundness if and only if all its possible traces guarantee soundness.</p><p>Inalterability is modeled by requiring that every counted vote matches a vote cast by some voter, either honest (Condition 1a) or corrupted (Condition 1b). Non-reusability is modeled by requiring that the matching between the events endvote(v) and beginvote(id , v) is injective. Notice that the structure of election processes described in Definition 4.2 guarantees that the events startid(id ) and startcorid(id ) depend on distinct ids (Condition 2). Similarly, Condition 3, which captures eligibility, is enforced syntactically by the shape of the process. Condition 1 can be checked automatically by ProVerif.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Coercion-resistance</head><p>As described in <ref type="bibr" target="#b24">[25]</ref>, coercion-resistance captures four different properties:</p><p>Receipt-freeness. A coercer cannot force a voter to cast a certain vote and to provide a receipt that would certify her vote.</p><p>Immunity to simulation attacks. A voter cannot be forced into providing all the secrets required for a coercer to impersonate her, since there is no way for the coercer to tell the difference between real and fake secrets.</p><p>Immunity to forced-abstention attacks. A coercer should not be able to tell whether a particular voter has voted or not, so that he cannot force the voter to abstain.</p><p>Immunity to randomization attacks. A voter cannot be forced to divulge or nullify her vote by using random messages received from the coercer.</p><p>We define coercion-resistance as immunity to simulation attacks and later prove that this definition implies immunity to forced-abstention attacks and receipt-freeness. Although our definition considers an arbitrary attacker, we do not formally address randomization attacks in this paper and leave this topic as future work. Our definition is based on observational equivalence and is similar in spirit to the cryptographic definition proposed in <ref type="bibr" target="#b24">[25]</ref>.</p><p>We call a voting protocol coercion-resistant if an attacker cannot distinguish a coerced voter providing him with secret material and abstaining from voting, from a voter providing him with fake secrets and actively participating in the vote. In the first case, we assume that the coercer can effectively mount a simulation attack and impersonate the voter, and for example cast whatever vote he wants on her behalf, or abstain from voting. Since we reason about remote voting protocols, we assume that the process V vote , by which an honest voter casts his vote, uses public channels.</p><p>We first define a voter process V coerced(c) i that complies with the demands of the coercer, so it takes part in the registration phase, forwards all generated or received secrets to the coercer on channel c, and then abstains from voting:</p><formula xml:id="formula_6">V coerced(c) i ≡ let x id = i in V reg [c u ] ,</formula><p>where u = captured(V reg ). If a protocol is coercionresistant, then there exists a strategy for the voter to fake registration secrets and cheat the coercer: this strategy is modeled as a plain context V fake . This context has to satisfy two simple well-formedness conditions: captured(V reg ) ⊆ captured(V fake ) and V reg V fake [0] ≈ V reg [0], which we implicitly assume satisfied in the following. To satisfy the first condition, bound names and variables can be reassigned by the νn and let x = M in constructs, respectively. These conditions allow us to replace the registration secrets by the fake ones and use the context</p><formula xml:id="formula_7">V reg [V fake ] in place of V reg .</formula><p>As mentioned before, the context V fake models the strategy used to cheat a coercer, so it is of course dependent on the particular election protocol being analyzed. The process V cheat(c) i (v ) registers and votes as a normal voter, but cheats a coercer by providing him with fake secrets.</p><formula xml:id="formula_8">V cheat(c) i (v ) ≡ let x id = i in V reg [let x v = v in V vote | V fake [c u ]], where u = captured(V reg ). Intuitively, an election context S is coercion- resistant if S[V coerced(c) i ] is observationally equivalent to S[V cheat(c) i (v )],</formula><p>i.e., the two processes are indistinguishable for any attacker. However, this does not hold, since in the first case the coerced voter abstains, while in the second it casts a vote. The coercer can thus distinguish the two election processes since both the votes published in the final tally and the number of messages exchanged in the voting phase are different.</p><p>In order to compensate for the vote of the voter cheating the coercer, we add one more voting process V j on each side of the observational equivalence. The voter that complies with the demands of the coercer and abstains will run in parallel with a voting process that votes v , while the voting process that cheats the coercer and casts a vote v will run in parallel with an abstaining voter. This models a scenario where the adversary is not certain about the behavior of at least one additional voter. We define a voter V j (v) having identity j and casting a valid vote v as</p><formula xml:id="formula_9">V j (v) ≡ let x id = j in V reg [let x v = v in V vote ] .</formula><p>Additionally, we formalize the behavior of a voter V abs j participating in the registration phase and then abstaining from voting as follows:</p><formula xml:id="formula_10">V abs j ≡ let x id = j in V reg [0] .</formula><p>Therefore, we could try to define coercion-resistance in terms of the following observational equivalence:</p><formula xml:id="formula_11">S[ V coerced(c) i | V j (v ) ] ≈ S[ V cheat(c) i (v ) | V abs j ].</formula><p>Even though the number of messages exchanged in the voting phase is now the same and the vote of V i is compensated by the additional voter V j , observational equivalence still does not hold. On the left-hand side, the coercer gets hold of real registration secrets that he can use to cast a valid vote, while on the right-hand side the coercer gets fake registration secrets, so any vote he will cast using them will be invalid. If we assumed that the coercer would cast a fixed valid vote v, then we could balance both sides of the equivalence by adding an additional voter k, which on one side casts a vote with fake registration secrets while on the other casts the vote v:</p><formula xml:id="formula_12">S[ V coerced(c) i | V j (v ) | V inv-reg k ] ≈ S[ V cheat(c) i (v ) | V abs j | V k (v?) ]<label>(1)</label></formula><p>where V inv-reg k is defined as follows:</p><formula xml:id="formula_13">V inv-reg k = let x id = k in V reg [V fake [let x v ∈ v inV vote ]].</formula><p>Intuitively, this models a scenario where the coercer does not know the exact distribution of votes and cannot tell whether the third voter casts an invalid ballot or a valid vote that balances the outcome of the election processes. Note that in all coercion-resistant protocols (e.g., <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b26">27]</ref>) casting a ballot with invalid registration secrets is guaranteed to nullify the vote inside, without an eavesdropper being able to tell any difference other than the final result of the tally. This is not the case with other ways of nullifying the vote such as casting an invalid vote, since the ballot may contain a proof that the vote inside is valid <ref type="bibr" target="#b24">[25]</ref>.</p><p>In any case, the vote the coercer chooses to cast is not known beforehand, in general. Even more, the coercer could just abstain, or try to vote more than once. Since the coercer is modeled as an arbitrary context, balancing his vote is not easy at all. In <ref type="bibr" target="#b16">[17]</ref>, Delaune, Kremer and Ryan define a new notion of adaptive simulation in an attempt to solve this problem. However, we want to use the standard notion of observational equivalence in order to take advantage of the automation support in ProVerif.</p><p>We now examine the equivalence (1) more carefully. In case of duplicate votes it is up to the tallying authority to decide which one of these votes to consider in the tally. So identifying the relevant vote cast by the coercer on behalf of V i requires the collaboration of both V i and the tallying authority. However, in most election protocols the tallying authority processes the votes only in a special tallying phase, when new votes are no longer accepted. So even if we have a way to find out the vote of the coercer after duplicate elimination, this will happen most likely too late for the voter k to be able to cast another vote that would balance the result of the tally.</p><p>Even if we ignored the problem and assumed a way to identify the vote of the coercer early enough so that k can still cast a ballot, equivalence (1) would still not hold until certain synchronization problems are solved. In particular, on the left-hand side the vote cast by the coercer can be processed even if no other voter performs visible actions, while in the right-hand side at least the balancing voter k has to participate in the voting phase until the vote of the coercer can be output. This means that the replicated instance of the tallying authority processing the coercer's vote needs to synchronize with the instance processing k's vote, which would further complicate the framework.</p><p>In order to keep things both simple and general we do not model the third voter explicitly, but replace it by a process which "extracts" the vote the coercer casts on behalf of V i and tallies it directly. This extractor registers as k, gets the same (real or fake) secrets received by the coercer from the coerced voter V i , receives from the tallying authority all the votes considered after duplicate elimination and identifies the vote cast by the coercer on behalf of V i . On the righthand side the extractor outputs the vote cast by the coercer on channel c votes , the special channel on which the result of the tally is published, while on the left-hand side the extractor does not output anything, thus abstracting voter k casting a vote with invalid registration secrets. Letting the extractor directly balance the coercer's vote is an abstraction that considerably simplifies the structure of the election process and the definition of coercion-resistance.</p><p>The extractor is dependent on the construction of the particular electronic voting protocol and has to be provided by the user. In order to achieve its goal, the extractor has additionally access to the secrets of the election authorities so that it can distinguish the vote of the coercer from the other votes. Since it has access to all this information, we need to ensure that it cannot leak it and can only use it in the way described above. We hence impose syntactic restrictions on the shape of the extractor, which will later be strengthened with semantic restrictions on its behaviour.</p><formula xml:id="formula_14">Definition 4.3 (Extractor) A context E c1,c2,z k is an extrac- tor if and only if E c1,c2,z k = let x id = k in V reg [ν m.(c 1 (x).P 1 | !c 2 (y).P 2 | C [if z ∈ v then [ ]])]</formula><p>for some plain processes P 1 , P 2 and a sequential context C such that c 1 , c 2 / ∈ fn(P 1 )∪fn(P 2 )∪fn(C), z ∈ captured(C), all inputs and outputs in P 1 , P 2 , and C occur on the private channels in m, and such channels are never output.</p><p>The channels c 1 and c 2 are the channels shared by the extractor with the coerced voter and the tallying authority, respectively. If the coercer casts a vote, then the variable z should hold this vote. The context C is required to be sequential so it does not contain any replications, which means that E c1,c2,z k [c votes z ] can tally at most one vote.</p><p>For convenience we define the process V coerced(c,c1) i that complies with the demands of the coercer but outputs its secrets on two channels c and c 1 , the first for the coercer and the second for the extractor.</p><formula xml:id="formula_15">V coerced(c,c1) i ≡ let x id = i in V reg [c u | c 1 u ] where u = captured(V reg ). The process V cheat(c,c1) i (v) is defined from V cheat(c) i</formula><p>(v) in a very similar way. We can now express coercion-resistance as the observational equivalence between the following election processes:</p><formula xml:id="formula_16">S [ V coerced(c,c1) i | V j (v ) | E c1,c2,z k [0] ] ≈ S [ V cheat(c,c1) i (v ) | V abs j | E c1,c2,z k [c votes z ] ]</formula><p>The first process contains the voter V i that complies with the demands of the coercer, running in parallel with the voter V j casting a vote v , and the process E c1,c2,z k [0], that is intuitively equivalent to a voter nullifying her vote. In the second election process the voter V i cheats the coercer by providing him with fake registration secrets and then votes v , the voter V j participates in the registration phase and then abstains, and the extractor process E c1,c2,z k [c votes z ] tallies the vote the coercer casts on behalf of V i . </p><formula xml:id="formula_17">2. S [ V coerced(c,c1) i | V j (v ) | E c1,c2,z k [0] ] ≈ S [ V cheat(c,c1) i (v ) | V abs j | E c1,c2,z k [c votes z ] ]</formula><p>where v ∈ v is a valid vote;</p><formula xml:id="formula_18">3. νc.S [!c(x) | V cheat(c,c1) i (v )|V abs j | E c1,c2,z k [c votes z ]] ≈ S[ V i (v ) | V abs j | V abs k ]; 4. Let P = c( x).let x v = v in V vote { x/ u}, v ∈ v, u = captured(V reg ), and x ∩ u = ∅ then νc.S [P | V cheat(c,c1) i (v )|V abs j | E c1,c2,z k [c votes z ]] ≈ νc.S [P | V cheat(c,c1) i (v )|V abs j | E c1,c2,z k [c votes v ]]; 5. S[V inv-reg i ] ≈ νc votes .(!c votes (x) | S[V i (v)]), where v is a valid vote.</formula><p>The definition of coercion-resistance uses a modified election context S that only differs from S in that the tallying authority additionally outputs messages on the channel c 2 shared with the extractor (Condition 1). The main equivalence in the definition was already given and discussed (Condition 2). We additionally impose two restrictions that characterize the intended behaviour of the process E c1,c2,z k [c votes z ]. If the cheated coercer abstains, then the extractor needs to abstain as well (Condition 3); and if the cheated coercer casts a valid vote using the fake registration secrets he received from V i , then the extractor needs to tally precisely this vote (Condition 4). Finally, we pose an additional restriction that justifies the abstraction of the third voter by the extractor (Condition 5): votes with invalid registration secrets are silently discarded by the tallying authority. If this was not the case a coercer could easily distinguish real from fake registration secrets.</p><p>There are two reasons why this definition of coercionresistance is suitable for our purpose. First, it only uses the standard notion of observational-equivalence, and no universal quantification over processes or contexts, which makes it suitable for automation. Second, this definition is strong, as it considers an arbitrary attacker and an unbounded number of honest and corrupted participants, and it captures immunity to simulation and forced-abstention attacks, voteprivacy and receipt-freeness. In the next two subsections we study these other properties formally.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Immunity to Forced-abstention Attacks and Vote-privacy</head><p>We call an election process immune to forced-abstention attacks if no attacker is able to distinguish a voter that casts a vote from a voter that abstains. In order to balance the votes and the number of messages sent on the network, we define this property using two different voters: one that casts a vote and one that abstains. The protocol is immune to forced-abstention attacks if the attacker is not able to tell which one of the two voters actually casts the vote.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4.5 (Immunity to Forced-abstention Attacks)</head><p>An election context S is immune to forced-abstention attacks if for a valid vote v we have that</p><formula xml:id="formula_19">S V i (v) | V abs j ≈ S V abs i | V j (v) .</formula><p>In <ref type="bibr" target="#b16">[17]</ref> an election protocol is defined to guarantee voteprivacy if an attacker is not able to distinguish between a process in which two voters cast one vote each, from the same process where these two votes are swapped. </p><formula xml:id="formula_20">S [V i (v) | V j (v )] ≈ S [V i (v ) | V j (v)] .</formula><p>We show that, under a very reasonable assumption -there exists at least one additional abstaining voter, coercionresistance implies immunity to forced-abstention attacks, which in turn implies vote-privacy. Theorem 4.7 If S guarantees coercion-resistance, then S guarantees immunity to forced-abstention attacks, assuming that there is at least one additional abstaining voter, i.e.,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S[ V abs</head><formula xml:id="formula_21">i | V j (v ) | V abs k ] ≈ S[ V i (v ) | V abs j | V abs k ].</formula><p>Theorem 4.8 Immunity to forced-abstention attacks implies vote-privacy, assuming that there is at least one additional abstaining voter, i.e.,</p><formula xml:id="formula_22">S V i (v) | V j (v ) | V abs k ≈ S V i (v ) | V j (v) | V abs k .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Receipt-freeness</head><p>Intuitively, a protocol guarantees receipt-freeness if a voter does not gain any information that can be used to prove to a coercer that she voted in a certain way. This definition thus refers to an attacker that does not try to vote by impersonating the coerced voter, as in coercion-resistance, but just tries to get a proof that the voter voted in a certain way. In <ref type="bibr" target="#b16">[17]</ref> receipt-freeness is defined as follows: Definition 4.9 (DKR-Receipt-freeness) An election context S is receipt-free if there exists a closed plain process V such that</p><formula xml:id="formula_23">1. νc.!c(x) | V ≈ V i (v ) 2. S [V c i (v) | V j (v )] ≈ S [V | V j (v)]</formula><p>The process V c i (v) behaves as a regular voting process, with the exception that all the secrets are revealed on a public channel c as soon as they are generated or received from private channels. This definition is only suitable for protocols where the votes are cast on private channels, which are set up in advance and never leaked. In the setting studied in this paper, namely remote voting protocols, the channels used to cast the votes are public. If a voter reveals her registration secrets, then an attacker can effectively impersonate her, and cast a vote on her behalf. So the second condition clearly fails for any protocol we would consider, since the vote chosen dynamically by an attacker is not statically predictable. This is also the reason why the definition of coercion-resistance proposed in <ref type="bibr" target="#b18">[19]</ref> does not apply to remote voting protocols.</p><p>We model receipt-freeness in our setting by letting the coerced voter reveal all her secrets only after the voting phase. This is consistent with the literature on electronic voting <ref type="bibr" target="#b10">[11]</ref>, and intuitively provides weaker capabilities to an attacker than in the case of coercion-resistance, where the secrets are revealed right after the registration phase and can be used by the attacker to impersonate the coerced voter. While this solution is conceptually elegant, it requires us to extend the applied pi-calculus with primitives modeling protocol phases. Following <ref type="bibr" target="#b2">[3]</ref>, we extend the syntax of with the process t : P : intuitively, t is a number model-ling a global synchronization clock and t : P is a process behaving as P at phase t and getting stuck in the other phases. For more detail on the semantics of phases, we refer to Appendix A.3. We remark that the phase command is supported by ProVerif.</p><p>In the remainder of this section, we only consider election processes where each output on channel c votes made by the tallying authority or the extractor is of the form t votes : c votes M , for some fixed phase t votes that intuitively corresponds to the election result publication phase. For instance the extractor is now defined as:</p><formula xml:id="formula_24">E c1,c2,z k = let x id = k in V reg [ν m.(c 1 (x).P 1 | !c 2 (y).P 2 | C [if z ∈ v then t votes : [ ]])]</formula><p>A voter that provides a receipt to a coercer first registers, then votes v as requested by the coercer, and finally, once the voting phase is over, reveals all the secrets she generated or received. Formally, the process V receipt(c) i (v) voting v and outputting a receipt on channel c is defined as follows:</p><formula xml:id="formula_25">V receipt(c) i (v) ≡ let x id = i in V reg [let x v = v in V vote [t votes : c u ]], where u = captured(V vote ) ∪ captured(V reg )</formula><p>We could try to define receipt-freeness as in Definition 4.9, where in the second condition we just replace V c i (v) by V receipt(c) i (v). However, such a definition would be too restrictive, since the voter cheating the coercer has to provide a fake receipt but otherwise has to act exactly like an honest voter.</p><p>This rules out the following generic strategy to provide a fake receipt in coercion-resistant protocols. The voter V registers, casts her real vote, and in parallel she generates fake secrets, casts the vote the coercer asked for using these fake secrets, and finally provides the receipt of this invalid voting. Intuitively, if there was a way for a receipt-freeness attacker to tell whether this receipt is fake or not, then we could construct a coercion-resistance attacker that would be able to tell whether some registration secrets are fake or not. This coercion-resistance attacker would first get the registration secrets from a coerced voter, use them to cast a vote and obtain a receipt, then forward this receipt to the receipt-freeness attacker. If the secrets he received are fake, the coercion-resistance attacker we constructed is basically simulating a voter cheating a receipt-freeness attacker, which by our assumption would be able to tell whether the receipt is fake or not. So by using the receipt-freeness attacker as an oracle, we could build an attacker against coercionresistance.</p><p>In our opinion this is a valid strategy for providing fake receipts in a coercion-resistant protocol. However, such a strategy is not captured by Definition 4.9 because in order to avoid coercion the voter has to cast two votes, one of which is invalid, thus violating the first condition. We therefore devise a definition tailored towards this particular strategy of providing fake receipts. Definition 4.10 (Receipt-freeness for Remote Voting) An election context S is receipt-free if there exists a plain process V such that</p><formula xml:id="formula_26">1. νc.(!c(x) | V ) ≈ let x id = i in V reg let x v = v in V vote |V fake [let x v ∈ v in V vote ] 2. S[ V receipt(c) i (v) | V j (v ) | V inv-reg k ] ≈ S[ V | V j (v) | V abs k ]</formula><p>The main difference with respect to Definition 4.9 is that the voter V does not only vote v as a regular voter, but additionally uses V fake to generate fake secrets, casts an extra vote using them, and provides a receipt of this invalid voting (Condition 1). In order to balance this additional noise we add an additional voter k that votes with fake registration secrets in case the voter i complies with the request of the coercer (left-hand side of Condition 2), and simply abstains if i cheats the coercer by casting a vote with fake secrets (right-hand-side of Condition 2).</p><p>We can finally state that coercion-resistance implies receipt freeness up to the abstraction of the third voter by the extractor, as inherited from the definition of coercionresistance.</p><p>Theorem 4.11 If S is an election context that guarantees coercion-resistance then there exists V such that</p><formula xml:id="formula_27">1. νc.(!c(x) | V ) ≈ let x id = i in V reg [let x v = v in V vote | V fake [let x v ∈ v in V vote | c 1 u ]] 2. S[ V receipt(c) i (v) | V j (v ) | V abs k ] ≈ S [ V | V abs j | E c1,c2,z k [c votes v ] ]</formula><p>where u = captured(V reg )</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Analysis of the Juels, Catalano, and Jakobsson Protocol</head><p>This section presents the first analysis in the formal model of the Juels, Catalano, and Jakobsson protocol <ref type="bibr" target="#b24">[25]</ref>. The importance of this protocol is twofold: it was the first protocol in the literature to satisfy a formal definition of coercionresistance, and it laid the basis for the development of many modern election schemes for remote voting (e.g., <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b26">27]</ref> and the recently proposed Civitas <ref type="bibr" target="#b15">[16]</ref>).</p><p>The protocol involves a registrar in charge of issuing secret credentials to voters, a set of tallying authorities responsible for processing ballots, jointly counting votes, and publishing the final tally, a set voters, and a bulletin board. A threshold encryption systems guarantees the safety of the protocol even if a minority of the tallying authorities is corrupted.</p><p>The protocol is divided into three phases: registration, voting, and tallying. In the registration phase, voters receive a credential from the registrar. This credential constitutes a proof of eligibility, which is then used in the voting phase. Additionally, the registrar publishes on the digitally signed bulletin board the credential encrypted by the tallying authority's public key. The protocol assumes the registrar to be trustworthy and the channel between the registrar and the voter to be untappable. The registration phase is depicted below:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Voter</head><p>Registrar BB</p><formula xml:id="formula_28">{cred} pk(kT ) / / o o cred</formula><p>In the voting phase, voters cast their vote on an anonymous public channel. Voters output on the channel the vote and the credential encrypted by the tallying authority's public key and a zero-knowledge proof of knowledge of the credential and of validity of the vote. The protocol assumes a fixed number of candidates and the proof guarantees that the vote is for one of these candidates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Voter Tallier</head><p>{cred} pk(kT ) ,{vote} pk(kT ) ,ZK</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>/ /</head><p>Finally, the tallying authorities check the proofs, eliminate duplicates, check the credentials and eventually publish the set of valid votes. A plaintext equivalence test (PET) between the encrypted credential received from the voter and the encrypted credential read from the digitally signed bulletin board allows the tallying authorities to jointly check the validity of the credentials without decrypting them, thus preserving their secrecy.</p><p>Tallier BB votes / /</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Equational Theory</head><p>The base equational theory considered in this paper includes function symbols for constructing and destructing pairs, encrypting and decrypting messages using asymmetric cryptography, signing messages, verifying signatures, and performing PETs. The binary functions eq, ∧, and ∨ model equality test, conjunction, and disjunction, respectively, thus allowing for expressing monotone Boolean formulas. For the sake of readability, we shall often use infix notation for eq, ∧, and ∨ and replace eq by =.</p><p>eq(x, x) = true ∧(true, true)</p><p>= true ∨(true, x) = true ∨(x, true) = true pet(enc(x, pk(y), z), enc(x, pk(y), w), sk(y)) = true fst(pair(x, y))</p><p>= x snd(pair(x, y))</p><p>= y dec(enc(x, pk(y), z), sk(y))</p><p>= x msg(sign(x, sk(y)))</p><p>= x ver(sign(x, sk(y)), x, pk(y))</p><p>= true</p><p>The equational theory also contains the function symbols and equational rules recently introduced in <ref type="bibr" target="#b8">[9]</ref> for abstractly reasoning about non-interactive zero-knowledge proofs in the applied pi-calculus. A non-interactive zero-knowledge proof is represented as a term of the form ZK i,j ( M , N , F ).</p><p>The statement preserves the secrecy of the terms M , called the statement's private component, while the terms N , called the statement's public component, are revealed to the verifier and to the adversary. The formula F constitutes a term without names and variables, which is built upon distinguished nullary functions α i and β i with i ∈ N. Hence ZK i,j is a function of arity i + j + 1, but we shall often omit arities and write this statement as ZK( M ; N ; F ), letting semicolons separate the respective components. The values α i and β j in F constitute placeholders for the terms M i and N j , respectively. For instance, the term</p><formula xml:id="formula_29">ZK( sk(k) ; m, pk(k) ; β 1 = dec(enc(β 1 , β 2 ), α 1 ) )</formula><p>denotes a zero-knowledge proof of knowledge of the secret key sk(k) corresponding to the public key pk(k). More precisely, the statement reads: "There exists a secret key such that the decryption of the ciphertext enc(m, pk(k)) with such a key yields m". As mentioned before, m and pk(k) are revealed by the proof while sk(k) is kept secret. This is formalized in general terms by the following infinite set of equational rules:</p><formula xml:id="formula_30">Public p (ZK i,j ( M , N , F )) = N p with p ∈ [1, j] Formula(ZK i,j ( M , N , F )) = F</formula><p>where Public p and Formula constitute functions of arity 1.</p><p>Since there is no destructor associated to the statement's private component, the terms M are kept secret. We define a statement ZK i,j ( M , N , F ) to hold if F is an (i, j)-formula and the formula obtained by substituting all α k 's and β l 's F with the corresponding values M k and N l is true. Verification of a statement ZK i,j with respect to a formula is modeled as a function Ver i,j of arity 2 that is defined by the following equational rule:</p><formula xml:id="formula_31">Ver i,j (F, ZK i,j ( M , N , F )) = true iff 1) E F { M / α}{ N / β} = true 2) F is an (i, j)-formula</formula><p>where { M / α}{ N / β} denotes the substitution of each α k with M k and of each β l with N l . This rule guarantees in the abstract model the soundness and correctness of zeroknowledge protocols. As shown in <ref type="bibr" target="#b8">[9]</ref>, we can compile this infinite equational theory into a finite and equivalent one, which is suitable for automated analysis by ProVerif.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Protocol Specification</head><p>The protocol specification in the applied pi-calculus is reported in Table <ref type="table" target="#tab_1">1</ref>. Process voter models honest voters: they receive an identifier from process identityissuer, receive a credential on the private channel chVR shared between voters and the registrar, choose a vote, and output a zero-knowledge proof conveying the encrypted credential and the encrypted vote. The statement</p><formula xml:id="formula_32">enc(α 3 , β 3 , α 4 ) = β 1 ∧ enc(α 1 , β 3 , α 2 ) = β 2 ∧ (α 3 = β 4 ∨ α 3 = β 5 ∨ α 3 = β 6 )</formula><p>of the zero-knowledge proof says that the first and second public component are a credential and a vote, both are encrypted by the tallying authority's public key and the vote is one among v A , v B , and v C . For the sake of simplicity, we consider an election with three candidates. Process corvoter models corrupted participants leaking their credentials. Process identityissuer generates a new identifier, which is then sent to the voter and to the registrar. Process registrar receives an identifier, generates a credential, sends the credential to the voter, signs and publishes the encrypted credential, and finally sends the encrypted credential to the tallying authority on an internal channel. This corresponds to the tallying authority reading the encrypted credentials from the bulletin board.</p><p>In our model, we consider a single tallying authority and abstract the threshold encryption scheme by the standard equational theory for asymmetric cryptography: as a consequence, we assume the trustworthiness of the tallying authority. Process tallier receives a ballot which is a zero-knowledge proof, checks its validity, and, if the plaintext equivalence test between the encrypted credential in the ballot and one of the encrypted credentials on the bulletin board succeeds 1 , decrypts and publishes the vote. We remark 1 In our model the PET is used just for consistency with the original that each encrypted credential is processed by the tallying authority only once and this guarantees the non-reusability property.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Security Analysis</head><p>We first verified the soundness property stated in Definition 4.2 (Condition 1). This required us to annotate the processes as specified in Table <ref type="table" target="#tab_1">1</ref>. The analysis was performed by ProVerif and succeeded. As a result, the Juels, Catalano, and Jakobsson Protocol is proved to guarantee inalterability, eligibility, and non-reusability for an unbounded number of honest voters and an unbounded number of corrupted participants. Notice that non-reusabity crucially relies on certain messages being sent only once on internal channels (e.g., the credential sent on channel chRT). To guarantee this, our implementation in ProVerif uses nonce handshakes. This does not affect the observable semantics of the system, but is necessary to counter the over-approximation of the static analysis.</p><p>The analysis of coercion-resistance relies on the additional processes reported in Table <ref type="table">2</ref>, namely the extractor and the three processes for the coerced, cheating, and abstaining voter. Notice that the faking strategy of the cheating voter consists in generating a fresh credential and sending it to the coercer. Finally, the modified tallying authority sends the encrypted credential and the encrypted vote received from the network together with the encrypted credential received from the registrar on the channel c 2 shared with the extractor.</p><p>We verified Definition 4.4 using ProVerif. The tool supports observational equivalence proofs expressed as biprocesses <ref type="bibr" target="#b12">[13]</ref>: as an example, νn.a n ≈ νn.a h(n) , where h is free in the equational theory, is written νn.a choice[n, h(n)] . Therefore the proof is automated, but some human effort is still required to transform each equivalence of Definition 4.4 into a biprocess. The transformation is mostly straightforward and the only interesting condition is 2, which requires that JCJ-CR1 ≈ JCJ-CR2 (see Table <ref type="table">2</ref>).</p><p>Understanding why this condition holds is crucial for expressing the equivalence in the form of a biprocess. The two sides of the equivalence differ because of the two voters and the extractor, as defined in Definition 4.4. At run-time, each of them is associated to a replicated instance of the tallying authority in charge of processing their vote, say T 1 for the coerced voter i, T 2 for the additional voter j, and T 3 for the extractor k. However, the equivalence between the two sides is not straightforward since in the left-hand side the vote v chosen by j is processed by T 2 , while in the right-hand side, it is processed by T 1 . Similarly, the vote cast by the protocol specification. This cryptographic primitive is more meaningful in a setting where the threshold encryption system is modeled explicitly. coercer is processed by T 1 on the left-hand side, while it is processed by T 3 on the right-hand side: remember that the tallying authority is responsible for passing the encrypted vote received from the network to the extractor. This scenario is depicted below, where T i (x) means that the tallying authority T i processes credential x: For more details on the ProVerif specification of the Juels, Catalano, and Jakobsson protocol and on the analysis thereof, we refer the interested reader to <ref type="bibr" target="#b7">[8]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions</head><p>In this paper we present a general technique for modeling remote voting protocols in the applied pi-calculus and for automatically verifying their security for an unbounded number of honest and corrupted voters. In particular, we give a new definition of coercion-resistance in terms of observational equivalence. This definition captures immunity to simulation and forced-abstention attacks, vote-privacy and receipt-freeness, and is suitable for automation. In addition, we formalize inalterability, eligibility, and non-reusability as a correspondence property on traces, which can also be analyzed automatically. We illustrate the proposed theoretical framework by modeling and analyzing the Juels, Catalano, and Jakobsson protocol using ProVerif.</p><p>This paper essentially reduces the problem of verifying coercion-resistance to checking observational equivalence. This property can be automatically verified by ProVerif, but </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Definition 4 . 1 (</head><label>41</label><figDesc>Annotated Election Process) An annotated election process is an election process</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Definition 4 . 4 (</head><label>44</label><figDesc>Coercion-resistance) An election context S guarantees coercion-resistance if there exist channels c, c 1 , and c 2 , a sequential process V fake , an extractor E c1,c2,z k , and an election context S , such that 1. there exist an election context S and two authority processes A, A such that S ≡ S [A | [ ]], S ≡ νc 1 , c 2 .S [A | [ ]], and νc 2 .(A | !c 2 (x)) ≈ A;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Definition 4 . 6 (</head><label>46</label><figDesc>Vote-privacy) An election context S guarantees vote-privacy if for two valid votes v and v we have</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Definition 5 . 1 (</head><label>51</label><figDesc>(i, j)-formulas) We call a term an (i, j)formula if the term contains neither names nor variables, and if for every α k and β l occurring therein, we have k ∈ [1, i] and l ∈ [1, j].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>The analysis done by ProVerif relies on an overapproximation of the process semantics that enforces the same synchronizations on the two sides of the equivalence. For instance, if the vote of the coercer is received by T 1 in the left-hand side, then the same holds in the right-hand side. Furthermore, each process in the left-hand side has to simulate the behavior of its syntactic counterpart in the right-hand side (and vice-versa): for example the equivalence νn.a m |a h(n) ≈ νn.a n |a m holds, but the proof of νn.a choice[m, n] | a choice[h(n), m] does not succeed in ProVerif. The solution is to replace the left-or the right-hand side by a structurally equivalent process, which corresponds to encoding the proof strategy in the biprocess. For instance, if we swap the two processes on the right-hand side of the previous equivalence, we obtain the biprocess νn.a choice[m, m] | a choice[h(n), n] and now the proof succeeds. In our case, we have to explicitly encode in the biprocess the proof strategy described before, which requires to swap the credentials processed by each tallying authority: T1(choice[cri, cr k ]) T2(choice[crj, cri]) T3(choice[cr k , crj]) v? O O v O O</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1</head><label>1</label><figDesc>Juels, Catalano, and Jakobsson in the Applied Pi-calculus voter c id (id). startid(id). chVR(cred). let vote ∈ {vA, vB, vC } in beginvote(id, vote). = va then if Public5(proof) = v b then if Public6(proof) = vc then let encvote = Public1(zkp) in let enccred = Public2(zkp) in chRT(enccred1). if pet(enccred, enccred1, sk(kT )) then let vote = dec(encvote, sk(kT )) in cvotes vote . JCJ νc id .νchIR.νchVR.νchRT.νkT.νkR.pub pair(pk(kT ), pk(kR)) . (!voter | !corvoter | !identityissuer | !registrar | !tallier) zk = ZK4,6( cred, r2, vote, r1; enc(vote, pk(kT ), r1), enc(cred, pk(kT ), r2), pk(kT ), va, v b , vc; proof ) proof = enc(α1, β3, α2) = β2∧ enc(α3, β3, α4) = β1∧ (α3 = β4 ∨ α3 = β5 ∨ α3 = β6)</figDesc><table><row><cell>corvoter</cell><cell>identityissuer</cell><cell>registrar</cell></row><row><cell>c id (id).</cell><cell>νid.</cell><cell>chIR(id).</cell></row><row><cell>startcorid(id).</cell><cell>newid(id).</cell><cell>νcred.</cell></row><row><cell>chVR(cred).</cell><cell>c id id .</cell><cell>νr.</cell></row><row><cell>pub cred</cell><cell>chIR id .</cell><cell>chVR cred .</cell></row><row><cell></cell><cell>pub id</cell><cell>pub sign(enc(cred, pk(kT ), r), sk(kR)) .</cell></row><row><cell>νr1.νr2.</cell><cell></cell><cell>chRT enc(cred, pk(kT ), r)</cell></row><row><cell>pub zk</cell><cell></cell><cell></cell></row><row><cell>tallier</cell><cell></cell><cell></cell></row><row><cell>pub(zkp).</cell><cell></cell><cell></cell></row><row><cell>if Ver4,6(proof, zkp) then</cell><cell></cell><cell></cell></row><row><cell>if Public4(proof)</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>3</head><label></label><figDesc>Syntax of the Applied Pi-calculus Terms M, N ::= a, b, c, i, j, k, n, m names x, y, z variables f(M1, . . . , M k ) functions where f ∈ Σ and k is the arity of f.</figDesc><table><row><cell></cell><cell>Plain Processes</cell><cell></cell></row><row><cell>P, Q</cell><cell>::= 0</cell><cell>nil</cell></row><row><cell></cell><cell>νn.P</cell><cell>name restriction</cell></row><row><cell></cell><cell cols="2">if M = N then P else Q conditional</cell></row><row><cell></cell><cell>u(x).P</cell><cell>input</cell></row><row><cell></cell><cell>u N .P</cell><cell>output</cell></row><row><cell></cell><cell>P | Q</cell><cell>parallel</cell></row><row><cell></cell><cell>!P</cell><cell>replication</cell></row><row><cell></cell><cell>Extended Processes</cell><cell></cell></row><row><cell>A, B</cell><cell>::= P</cell><cell>plain process</cell></row><row><cell></cell><cell>A | B</cell><cell>parallel</cell></row><row><cell></cell><cell>νu.A</cell><cell>restriction</cell></row><row><cell></cell><cell>{M/x}</cell><cell>active substitution</cell></row><row><cell cols="3">Computer Science, pages 115-134. Elsevier Science</cell></row><row><cell cols="2">Publishers Ltd., 2005.</cell><cell></cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments We thank the anonymous reviewers for their valuable comments and Catherine Howell for her insightful remarks.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>this still requires non-negligible human effort to transform process specifications into biprocesses. Extending the scope of ProVerif to a wider class of process equivalences is subject of active research <ref type="bibr" target="#b19">[20]</ref>. Notice, however, that our approach is not tailored to a specific tool and could in principle rely on other techniques, such as the one based on symbolic bisimulation that has been recently proposed in <ref type="bibr" target="#b17">[18]</ref>.</p><p>As future work, we plan to analyze other protocols for remote voting, such as <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b26">27]</ref>, and the protocol underlying the recently proposed Civitas system <ref type="bibr" target="#b15">[16]</ref>. It would also be interesting to formalize in the symbolic model other interesting security properties such as immunity to randomization attacks, individual and universal verifiability, completeness, and resilience to denial-of-service attacks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Review of the Applied Pi-Calculus</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 Syntax</head><p>The complete syntax of the applied pi-calculus <ref type="bibr" target="#b4">[5]</ref> is given in Table <ref type="table">3</ref>. In addition to what is presented in Section 2 we define extended processes, frames, and evaluation contexts.</p><p>Extended processes consists of plain processes, parallel compositions, restrictions and active substitutions {M/x}, i.e., floating substitutions that may apply to any process that they come into contact with. To control the scope of</p><p>an active substitution {M/x}, we can restrict the variable x. Intuitively, νx.(P | {M/x}) restricts the scope of the substitution {M/x} to process P and has the same semantics as a let construct. If the variable x is not restricted, as it is the case in the process (P | {M/x}), then the substitution is exported by the process and the environment has immediate access to M .</p><p>A context</p><p>e., it does not contain free variables). An evaluation context E is a context of the following form:</p><p>A frame is an extended process built up from 0 and active substitutions by parallel composition and restriction. We let φ and ψ range over frames. The domain dom(φ) of a frame φ is the set of variables that φ exports, i.e., those variables x for which φ contains a substitution {M/x} not under a restriction on x. Every extended process A can be mapped to a frame φ(A) by replacing every plain process embedded in A with 0. The frame φ(A) can be viewed as an approximation of A that accounts for the static knowledge A exposes to its environment, but not for A's dynamic behavior.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Semantics</head><p>The operational semantics of the applied-pi calculus is defined in terms of structural equivalence (≡) and internal reduction (→). Structural equivalence captures rearrangements of parallel compositions, restrictions and active substitutions, and the equational rewriting of the terms in a process.</p><p>Definition A.1 (Structural Equivalence) Structural equivalence (≡) is the smallest equivalence relation on extended processes that satisfies the rules in Table <ref type="table">4</ref> and that is closed under α-renaming of names and variables, and under application of evaluation contexts.</p><p>Internal reduction defines the semantics of the communication primitives and conditionals. </p><p>is the smallest relation on extended processes that satisfies the rules in Table <ref type="table">5</ref> and that is closed under structural equivalence and under application of evaluation contexts.</p><p>We write A ⇓ a to denote that A can send a message on a, i.e., A → * E[a M .P ] for some evaluation context E that does not bind a.</p><p>We write A ⇓ a to denote that A can send a message on a, i.e., A → * E[a M .P ] for some evaluation context E that does not bind a. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3 Protocol Phases</head><p>Following <ref type="bibr" target="#b2">[3]</ref>, we extend the syntax of processes with the form t : P , where the phase prefix t is a number and the process P can only contain numbers bigger than t. Intuitively, this models a global synchronization clock where P is active only at phase t. </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Secrecy by typing in security protocols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="749" to="786" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Secrecy types for asymmetric communication</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Blanchet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th International Conference on Foundations of Software Science and Computation Structures (FOSSACS)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>4th International Conference on Foundations of Software Science and Computation Structures (FOSSACS)</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2030</biblScope>
			<biblScope unit="page" from="25" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Automated verification of selected equivalences for security protocols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Blanchet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fournet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic Algebric Programming</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
	<note>To appear in</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Just fast keying in the pi calculus</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Blanchet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fournet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Information and System Security</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">9</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Mobile values, new names, and secure communication</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fournet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 28th Symposium on Principles of Programming Languages (POPL)</title>
		<meeting>28th Symposium on Principles of Programming Languages (POPL)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="104" to="115" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Receipt-free homomorphic elections and write-in ballots</title>
		<author>
			<persName><forename type="first">A</forename><surname>Acquisti</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2004">2004/105, 2004</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Causality-based abstraction of multiplicity in cryptographic protocols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Backes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cortesi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maffei</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 20th IEEE Symposium on Computer Security Foundations (CSF)</title>
		<meeting>20th IEEE Symposium on Computer Security Foundations (CSF)</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="355" to="369" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">ProVerif scripts for the Juels, Catalano, and Jakobsson protocol</title>
		<author>
			<persName><forename type="first">M</forename><surname>Backes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hriţcu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Maffei</surname></persName>
		</author>
		<ptr target="www.infsec.cs.uni-sb.de/~maffei/ev.zip" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Zero-knowledge in the applied pi-calculus and automated verification of the direct anonymous attestation protocol</title>
		<author>
			<persName><forename type="first">M</forename><surname>Backes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Maffei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Unruh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Hack-a-vote: Security issues with electronic voting systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bannet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Price</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rudys</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Singer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Wallach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Security &amp; Privacy</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="32" to="37" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Receipt-free secret-ballot elections (extended abstract)</title>
		<author>
			<persName><forename type="first">J</forename><surname>Benaloh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tuinstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 26th Annual ACM Symposium on Theory of Computing</title>
		<meeting>26th Annual ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="544" to="553" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">An efficient cryptographic protocol verifier based on Prolog rules</title>
		<author>
			<persName><forename type="first">B</forename><surname>Blanchet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th IEEE Computer Security Foundations Workshop (CSFW)</title>
		<meeting>14th IEEE Computer Security Foundations Workshop (CSFW)</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="82" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Automated verification of selected equivalences for security protocols</title>
		<author>
			<persName><forename type="first">B</forename><surname>Blanchet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fournet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 20th Annual IEEE Symposium on Logic in Computer Science (LICS)</title>
		<meeting>20th Annual IEEE Symposium on Logic in Computer Science (LICS)</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="331" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Static validation of security protocols</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bodei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Buchholtz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Degano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Nielson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">R</forename><surname>Nielson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Security</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="347" to="390" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Dynamic types for authentication</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bugliesi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Focardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Maffei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Security</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="563" to="617" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Civitas: A secure voting system</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Clarkson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">To appear in IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Coercionresistance and receipt-freeness in electronic voting</title>
		<author>
			<persName><forename type="first">S</forename><surname>Delaune</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kremer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ryan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 19th IEEE Computer Security Foundations Workshop (CSFW)</title>
		<meeting>19th IEEE Computer Security Foundations Workshop (CSFW)</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="28" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Symbolic bisimulation for the applied pi calculus</title>
		<author>
			<persName><forename type="first">S</forename><surname>Delaune</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kremer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ryan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Foundations of Software Technology and Theoretical Computer Science, 27th International Conference (FSTTCS 2007)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>of Foundations of Software Technology and Theoretical Computer Science, 27th International Conference (FSTTCS 2007)</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="133" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Verifying privacytype properties of electronic voting protocols</title>
		<author>
			<persName><forename type="first">S</forename><surname>Delaune</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kremer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ryan</surname></persName>
		</author>
		<idno>LSV-08-01</idno>
	</analytic>
	<monogr>
		<title level="s">Laboratoire Spécification et Vérification</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<pubPlace>ENS Cachan, France</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Research Report</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Automatic verification of privacy properties in the applied pi calculus</title>
		<author>
			<persName><forename type="first">S</forename><surname>Delaune</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ryan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Smyth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">To appear in 2nd Joint iTrust and PST Conferences on Privacy, Trust Management and Security (IFIPTM&apos;08)</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Voting and technology: who gets to count your vote?</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schneier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Simons</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="29" to="31" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Searching for shapes in cryptographic protocols</title>
		<author>
			<persName><forename type="first">S</forename><surname>Doghmi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Guttman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Thayer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 13th International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>13th International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS)</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="523" to="538" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Election security: Perception and reality</title>
		<author>
			<persName><forename type="first">D</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Paul</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Security &amp; Privacy</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="24" to="31" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Types and effects for asymmetric cryptographic protocols</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jeffrey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Security</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="435" to="484" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Coercionresistant electronic elections</title>
		<author>
			<persName><forename type="first">A</forename><surname>Juels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Catalano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jakobsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4nd ACM Workshop on Privacy in the Electronic Society (WPES)</title>
		<meeting>4nd ACM Workshop on Privacy in the Electronic Society (WPES)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="61" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Analysis of an electronic voting system</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kohno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Stubblefield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Rubin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Wallach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 25th IEEE Symposium on Security &amp; Privacy</title>
		<meeting>25th IEEE Symposium on Security &amp; Privacy</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="27" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Robust coercion-resistant registration for remote e-voting. IAVoSS Workshop On Trustworthy Elections (WOTE 2007)</title>
		<author>
			<persName><forename type="first">T</forename><surname>Krivoruchko</surname></persName>
		</author>
		<ptr target="http://research.microsoft.com/conferences/WOTE2007/papers/09.pdf" />
		<imprint>
			<date type="published" when="2007-06">June 2007</date>
		</imprint>
	</monogr>
	<note>Available at</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Static validation of a voting protocol</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Nielsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">H</forename><surname>Andersen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">R</forename><surname>Nielson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automated Reasoning for Security Protocol Analysis (ARSPA 2005)</title>
		<title level="s">Electronic Notes on Theoretical</title>
		<imprint>
			<biblScope unit="volume">135</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Security considerations for remote electronic voting</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Rubin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="39" to="44" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">On coercionresistant electronic elections with linear work</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Araujo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Buchmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ARES &apos;07: Proceedings of the The Second International Conference on Availability, Reliability and Security</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="908" to="916" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">A semantic model for authentication protocols</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Y C</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Lam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th IEEE Symposium on Security &amp; Privacy</title>
		<meeting>14th IEEE Symposium on Security &amp; Privacy</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="178" to="194" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
