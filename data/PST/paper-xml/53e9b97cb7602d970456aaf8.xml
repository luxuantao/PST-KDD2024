<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">BIO logical agents: Norms, beliefs, intentions in defeasible logic</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2008-02-15">15 February 2008</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Guido</forename><surname>Governatori</surname></persName>
						</author>
						<author role="corresp">
							<persName><forename type="first">Antonino</forename><surname>Rotolo</surname></persName>
							<email>rotolo@cirsfid.unibo.it</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Springer Science+Business Media</orgName>
								<address>
									<postCode>LLC 2008</postCode>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">School of ITEE</orgName>
								<orgName type="institution">The University of Queensland</orgName>
								<address>
									<postCode>4072</postCode>
									<settlement>Brisbane</settlement>
									<region>QLD</region>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">CIRSFID-Law Faculty</orgName>
								<orgName type="institution">University of Bologna</orgName>
								<address>
									<addrLine>Via Galliera 3</addrLine>
									<postCode>40121</postCode>
									<settlement>Bologna</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">BIO logical agents: Norms, beliefs, intentions in defeasible logic</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2008-02-15">15 February 2008</date>
						</imprint>
					</monogr>
					<idno type="MD5">BD16BE24032C18EC0C005A35137967E3</idno>
					<idno type="DOI">10.1007/s10458-008-9030-4</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:28+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Defeasible logic</term>
					<term>Intention and obligation</term>
					<term>Agent types</term>
					<term>Social agents</term>
					<term>Computational complexity</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper we follow the BOID (Belief, Obligation, Intention, Desire) architecture to describe agents and agent types in Defeasible Logic. We argue, in particular, that the introduction of obligations can provide a new reading of the concepts of intention and intentionality. Then we examine the notion of social agent (i.e., an agent where obligations prevail over intentions) and discuss some computational and philosophical issues related to it. We show that the notion of social agent either requires more complex computations or has some philosophical drawbacks.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction and motivation</head><p>Reasoning about mental attitudes is a traditional issue in philosophy and has been widely investigated in the field of AI. Some classical agent systems based on mental attitudes such as beliefs, desires and intentions are, for example, those presented in <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b31">32]</ref>.</p><p>More recent works on cognitive agents tried combine two apparently independent perspectives <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b16">17</ref>]: (a) a classical cognitive account of agents that specifies their mental attitudes; (b) modelling agents' behaviour by means of normative concepts. For the first approach, the background is basically the belief-desire-intention (BDI) architecture, where mental attitudes are taken as primitives to give rise to a set of Intentional Agent Systems <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b31">32]</ref>. This view is interesting especially when the behaviour of agents is the outcome of a rational balance among their (possibly conflicting) mental states. The normative aspect is rather based on the assumption that normative concepts play a role to characterise the idea of social co-ordination of autonomous agents <ref type="bibr" target="#b30">[31]</ref>. The nice result of this combination of perspectives is that of leading to an account of agents' deliberation and behaviour in terms of the interplay between mental attitudes and normative (external) factors such as obligations.</p><p>A crucial aspect in this recent trend is that reasoning about agents can be embedded in frameworks based on non-monotonic logics, as one the most interesting problems concerns the cases where the agent's mental attitudes are in conflict or when they are incompatible with obligations and other deontic provisions. In this specific perspective, the relation between mental attitudes and non-monotonicity should not sound surprising: works such as Thomason's <ref type="bibr" target="#b34">[35]</ref> and BOID <ref type="bibr" target="#b7">[8]</ref> confirm this trend. Of particular interest is the BOID architecture, which in fact provides a number of strategies for solving conflicts among mental attitudes and obligations. BOID specifies logical criteria (i) to retract agent's attitudes with the changing environment, and so (ii) to settle conflicts by stating different general policies corresponding to the agent type considered. Agent types correspond to the different ways through which conflicts are detected and solved: a realistic agent thus corresponds to a conflict-resolution type in which beliefs override all other factors, while other agent types, such as simple-minded, selfish or social ones adopt different orders of overruling.</p><p>Following <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b16">17]</ref>, in this paper we take advantage of this research line and discuss how the combination of mental attitudes and obligations can be framed in Defeasible Logic (DL). As is well-known, DL is based on a logic programming-like language and it is a simple, efficient but flexible non-monotonic formalism able to deal with many different intuitions of non-monotonic reasoning and recently applied in many fields. In addition, several efficient implementations have been developed <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b23">24]</ref>. Here we discuss and extend some aspects of a non-monotonic logic of agency, based on the framework of <ref type="bibr" target="#b1">[2]</ref>, developed in <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>.</p><p>Why DL? Indeed, DL is one of the most expressive languages that allows for the definition of large sets of agent types. In particular, the aim of this article is to address the following issues:</p><p>1. We will devise an extension of DL able to cover a number of different agent types, but which, despite its expressiveness, is computationally feasible. We will prove that it is possible to compute the complete set of consequences of a given theory in linear time, thus preserving the nice computational features of standard DL. 2. On the other hand, we will argue that the notion of agent type can be problematic. The discussion will be devoted to some philosophical and computational aspects of the notion of "social agent", by which we mean a norm-complying agent. 1 However, we will argue that similar considerations also apply to other agent types.</p><p>Our system, which considers here three components-Beliefs, Intentions, and Obligations (BIO agents)-has some substantial peculiarities that make it different from other frameworks such as BOID's. 2 In particular, 1 The term "social agent" is taken from previous literature, and in particular from works on the BOID architecture and from some of our earlier papers. We preferred not to change this terminology to avoid confusion. Other terms could be used, such as "respectful" or "obedient". However, "social" does not have here any moral connotations and does not imply that a norm-complying agent has some positive attitude towards others. (Of course this may be the case, but we do not necessarily suggest this intuitive reading for norm-complying agents.) The term "social" simply stresses the contrast with other agent types, such as "selfish agent" (internal vs. external motivations). Analogously, the term "deviant" does not have, too, any moral connotation: it is taken from social sciences to denote precisely what we describe in our paper. 2 The choice of excluding desires is only motivated by offering a simpler presentation of the logic. Social agents, according to the previous literature (e.g., <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b10">11]</ref>), are minimally those for which obligations override conflicting intentions. The inclusion of desires would not substantially change the inference mechanism presented in Sect. <ref type="bibr" target="#b2">3</ref>. In addition, adding desires would not affect the computational results presented in the paper. All results applicable to the relation between intentions and obligations hold for a similar relation between obligations and desires.</p><p>• the system develops a constructive account of those modalities that correspond to mental states and obligations; rules are thus meant to devise suitable logical conditions for introducing modalities; if so, rules may also contain modalised literals; • possible conversions of a modality into another can be accepted, as when the applicability of rule leading to derive, for example, OBL p ( p is obligatory) may permit, under appropriate conditions, to obtain INT p ( p is intended).</p><p>We believe that both these aspects are necessary to account for some relatively simple, but important reasoning patterns. In particular, we maintain that conversions are required to capture some aspects of agents' rationality. In fact, conversions permit to derive, for example, intentions from beliefs. As we shall see, these reasoning patterns are suitable for modelling the so-called side-effect problem. Usually, side effects are not considered as a part of the intentional sphere of agents, but this analysis is not always satisfactory when we have to check effects against obligations and possible normative violations. In presence of obligations regulating agent's behaviour, a satisfactory model for agent's rationality should suggest that some side effects (but not all) are intended. Indeed, conversions correspond to an inferential mechanism that is precisely meant to capture this fact. But, at this point, the conclusion will be that the notion of social agent gets problematic (point 2 above). The layout of the paper is as follows. Section 2 provides the theoretical background of our system. In particular, since the concept of social agent focuses on the interplay between obligations and intentions, we will discuss which kind of intentions have to be considered in this regard. Section 3 will present our logical framework, based on DL, which will embed our intuitions and permit to deal with BIO agents. Section 4 presents a first discussion of the notion of agent type; in particular, we will argue that conversions, too, are relevant in identifying specific cognitive profiles for the agents; the section ends with an open problem concerning the feasibility of agent types based on the strategies for solving conflicts. Section 5 deals with the computational complexity of social agency. A concluding section on related work completes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Norms, beliefs and intentions</head><p>The focus of this paper is on the so-called policy-based attitudes. The term was coined by Bratman <ref type="bibr" target="#b6">[7]</ref> with specific reference to the idea of intention. For example, I have a policy to patch up and reboot the Unix server in the department once every month. This morning, on the basis of this policy, I form the intention to reboot the machine at 7.00 PM in the evening. My intention this morning to reboot the machine this evening is a policy-based intention. This specific intention will play a major part in my planning process for the day, as it will pose problems about means and constrain my other options.</p><p>Hence, intentions of this type concern potentially recurring circumstances in an agent's life. A policy-based intention is such that it is not simply a case of retaining an intention previously formed. Neither is it based on a full-blown deliberation where an attempt is made to weigh pros and cons for and against conflicting options. It also differs from an intention in favour of necessary means, i.e., an intention in favour of a specific end, in the sense that the defeasibility of general policies makes it possible to block the application of the policy to the particular case without abandoning the policy. Otherwise one could abandon the intention in favour of the end. The peculiarity policy-based intentions is that in each case the policy concerns a kind of circumstance that is expected to recur in the agent loop and in each case the agent might well have a general intention to act in the particular circumstances. Whether the agent is able to perform that action or not depends on the circumstances.</p><p>As argued in detail elsewhere <ref type="bibr" target="#b15">[16]</ref>, it may happen that a policy-based intention needs to be re-considered if not blocked for the application to particular cases. But this does not mean that the agent should know all such conditions in a scenario, but only those she considers necessary for the intended outcome and that she is not confident of their being satisfied. To intend the necessary consequence the agent has to make sure that all the evidence to the contrary has been defeated, which is basically a defeasible conclusion.</p><p>The starting point of this paper is to extend the policy-based approach to other attitudes and motivational factors such as beliefs and obligations (see <ref type="bibr" target="#b19">[20]</ref> for a similar idea). In this way, all motivational factors are naturally represented within a rule-based system: intentions and beliefs are viewed as constituting the internal constraints (based on policies) of an agent while obligations are her external constraints (based on rules). As constraints they are defeasible. Notice, in particular, that such an extension to obligations can capture the well-known defeasible character of deontic reasoning. In this last case, a policy-based obligation-conceived of as an external motivational attitude-turns out to be simply a conditional obligation, namely, a rule that allows for the inference of an obligation whenever the antecedent of this rule holds <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b32">33]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Expected side effects and agents' rationality</head><p>As we mentioned in Sect. 1, a satisfactory model for agent's rationality sometimes requires that a side effect should be intended, even though we cannot properly say it was directly wanted by the agent.</p><p>It is quite common to distinguish between actions performed intentionally and unintentionally. But it is philosophically hard to explain what the distinction precisely amounts to. For instance, some philosophers argued that an action is not properly intentional if the agent does not have the intention to perform it <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b24">25]</ref>. On the other hand, it is somehow reasonable to say that an agent, who did not specifically intend to perform an action, intentionally performed it. This idea is more clear when we just have a look at the philosophical debate on the problem of side effects. Imagine an agent does A to achieve B and knows that A will also produce some other result C. If the agent's motivation is only the desire to obtain B, can we say that the agent's action was fully intentional with respect to C? Some philosophers argued that, insofar as the side effect is viewed as dangerous or somehow unpleasant ("it is harming the environment"), people are psychologically inclined to think that the agent acted intentionally; when the side effect is "helping the environment", most people are inclined to think the contrary ( <ref type="bibr" target="#b20">[21]</ref>; for a general discussion see, e.g., <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b33">34]</ref>). Of course, it is outside the scope of this paper to provide the reader with a philosophical answer to these thorny questions. But there is a lesson that we can learn from this debate: we may sometimes have good reasons to include in the intentional sphere of agents some side effects. In the remainder, we will not offer substantial criteria to establish what effects should be accepted as intentional (a problem for which no real consensus has emerged among philosophers). We will simply offer a logical analysis of this idea and justify the inclusion of side effects when an agent is acting in an environment where obligations regulate her behaviour.</p><p>Let us examine Michael Bratman's idea of agent's rationality. Bratman plays an important role in our case: Not only he was the first who introduced the notion of policy-based intention, but, also, his theory is traditionally considered as one of the main philosophical references for modelling cognitive agents in MAS. As is well known, Bratman admits that, in some cases, an action is intentionally performed even though the agent did not specifically intend to perform it. On the other hand, according to him, rational agents can be basically modelled as follows <ref type="bibr" target="#b6">[7]</ref>:</p><p>• agents are goal-directed without being necessarily aware of their activity;</p><p>• intentions are used to choose partial plans for the realisation of a goal;</p><p>• not all consequences are intended but only some initial intentions and the goal as a result of the plan; if some side-effects occur, they are never intended.</p><p>According to this view, side effects should be in principle excluded from the intentional sphere of goal-directed agents. From the logical point of view, this idea makes it necessary to avoid several variants of logical omniscience: omniscience arises when the agent is required to know all the truths defined by her logic, or when the logic that depicts the agent automatically includes all the logical truths of classical logic, or, finally, if the agent knows all the logical consequences of the known propositions <ref type="bibr" target="#b14">[15]</ref>. In this perspective, the expected side-effects problem seems to depend on the interactions between the reasoning mechanism for the propositional inferences and the mechanism ruling the introduction and the behaviour of the modal operators representing mental states. A simple and rather unsatisfactory solution would be to consider two completely unrelated consequence relations, one for the propositional part and the second one for the modal operators. The consequence relation for a modal operator is meant to give the condition under which one can prove a modal formula. For example the pair |∼ X α, where X is a modal operator, means that if we can prove all the formulas in then we can deduce X α. In what follows we will develop a system for mental states and motivational attitudes based on this idea. However, we will allow the consequence relation for intentions and obligations to interact with the propositional module and we will also consider possible interactions between the modal operators. To this end we have to show that the expected side-effects phenomenon is not a drawback for policy-based agents: such a kind of agents must accept the expected-side effects unless they have some reasons to reject the consequences corresponding to them.</p><p>In effect, though our proposed theory does not entertain many of the properties leading to logical omniscience, some aspects of the side-effects problem are accepted. Consider</p><formula xml:id="formula_0">INTGoToDentist, GoToDentist ⇒ Pain |∼ INTPain (1) INTGoToRome, GoToRome ⇒ GoToItaly |∼ INTGoToItaly<label>(2)</label></formula><p>The first inference says that, if the agent intends to go to the dentist, and going to the dentist will cause pain, then the agent intends to have pain. The second inference states that, if the agent intends to go to Rome, and Rome is in Italy, then the agent intends to go to Italy. Actually, whereas the first case is clearly unacceptable, the second should be accepted by a rational agent. In this perspective the side-effects problem is similar to the substitution of indiscernible in opaque contexts. An agent may have the intention to visit Rome and not to visit Italy. But if the agent knows that Rome is the capital of Italy then it would be irrational for the agent not to have the intention to go to Italy given the intention to visit Rome.</p><p>Accordingly, some cases of the side-effects problem are not necessarily a weakness of a theory. This holds in particular if we assume that our agents are aware of their activities, which means that they know (or believe in) the policies regulating their own deliberation. This implies that awareness is nothing but a form of epistemic introspection: accordingly, the example above can be reframed as follows:</p><formula xml:id="formula_1">INTGoToDentist, BEL(GoToDentist ⇒ Pain) |∼ INTPain (3) INTGoToRome, BEL(GoToRome ⇒ GoToItaly) |∼ INTGoToItaly<label>(4)</label></formula><p>In our view, modelling rational agents corresponds to the following assumptions:</p><p>• agents are aware of their activities, and policies;</p><p>• some cases of the side-effects problem can be accepted;</p><p>• if a case has to be rejected this means that some of its consequences should not be intended; • when some consequences are not intended, this only means that they are blocked by conflicting attitudes or facts.</p><p>The theory an agent is equipped with can be understood as the specification of the behaviour of the agent. If the agent is aware that B is an unavoidable/indisputable consequence of A and the agent intends A, then B is a consequence of the agent's intentions and the agent must accept it as part of her intentions. Suppose we have that "raising one's hand at an auction counts as making a bid". Thus, if the agent (aware of this policy) intends to raise her hand, then she intends to bid in the auction, and her action will be understood as making a bid. In other words, in our system we will try to balance and moderate some unpleasant aspects of the side-effects problem with the equally important need for modelling rational agents. Of course, according to our view, we may have that something is intended even if it is causally distant with respect to the original derived intentions. But this is not necessarily a drawback if we conceive agents as rational and, as such, being aware of the policies which are related with the environment and with their interests: even a causally distant behaviour can be rationally intended unless it is removed in the meantime from deliberation. But this case is indeed considered within our analysis because we may have concrete contexts in which some policy-based intentions, as soon as they are applicable, turn out to be overridden by other policies: we may have reasons to argue that, if an agent intends A and believes that B is a consequence of A, this is not a reason for necessarily intending B; in fact, the derivation of B as an intention may be blocked, in our view, by competing attitudes or made non-applicable by concrete facts.</p><p>According to the previous discussion it should be clear that, though inspired by Bratman's <ref type="bibr" target="#b6">[7]</ref> analysis, the notion of intention we study in this paper is slightly different, as it focuses on the idea of intentionality. In Bratman's view intentions are used to choose partial plans for the realisation of a goal; in this way they have a close relation to means-ends. In our view intentions should be related not only to means-ends but also to the their consequences.</p><p>This concept of intention is particularly relevant in conjunction with deontic and normative notions, for example if we want to say that an agent is legally or morally responsible for A if the agent did A with the intention to do A. In other words, that an agent can be qualified as responsible for a normative violation (i.e., to act in contrast with some normative provisions) requires that agent's behaviour is performed intentionally (see the discussion in <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b25">26]</ref>). Of course, we may identify different degrees of responsibility by checking, for instance, whether the agent has a direct, or only an indirect, control over the consequences of her actions. But, in the legal perspective, in particular, responsibility is usually associated with some minimal form of intentionality: only in case of an agent acting completely unintentionally, the the law usually excludes that the agent is responsible. In other words, we have the following options:</p><formula xml:id="formula_2">Th = {INTa, BEL(a ⇒ b), OBL¬b} responsible not responsible Th |∼ INTb T h |∼INTb</formula><p>In one option the agent is not responsible, as we do not derive any conflicting intention with respect to the prohibition to do b; in the other case, the agent is responsible, as she intends to do b. On account of this logical analysis, since we have sometimes to accept some side effects, the agent has to include in the set of her intentions not only her intentions in Bratman's sense but also some of their consequences. It is worth noting that our intuition is compatible with von Wright's <ref type="bibr" target="#b35">[36]</ref>   <ref type="bibr" target="#b6">[7]</ref> in this perspective. The basic scenario runs as follows: Strategic Bomber intends to bomb a munition plant of the enemy being aware that the resulting explosion will kill innocent children in a nearby school. Bratman argues that Strategic Bomber does not have the intention to kill the children. Formally, Bratman's scenario can be represented as follows: if</p><formula xml:id="formula_3">Th = {INTbomb, BEL(bomb ⇒ kill), INTbomb ⇒ INT¬kill, OBL¬kill} then Th |∼INTkill</formula><p>Let us expand the scenario by supposing that, despite the bombing, Strategic Bomber loses the war, and that there is a process for war crimes against him. Civil casualties are a sad but almost unavoidable consequence of war, but usually the killing of civilians does not constitute a war crime if there was no intention to kill. According to Bratman, Strategic Bomber did not commit a war crime since he did not have such an intention (see above). However, let us assume that Strategic Bomber did not do anything to prevent or minimise civil casualties (let us say by a movement of troops that might have resulted in an evacuation of the area surrounding the munition plant). In this extended scenario the killing of children is brought about by a (successful) intentional act of Strategic Bomber. Accordingly, he must be held responsible for the killing of innocent civilians.</p><p>Formally, this means that the intention to minimise civil casualties is a condition for not obtaining the intention to kill innocents and, conversely, intending not to minimise causalties permits to derive the intention to kill. Hence, if</p><formula xml:id="formula_4">Th = {INTbomb, INT¬minimise, OBL¬kill, BEL(¬minimise ⇒ kill), INTbomb ⇒ INT¬kill} then Th |∼ INTkill</formula><p>Clearly, under this reading we assume that we can derive the intention to kill from the fact that the agent intended not to minimise civil causalties. Accordingly, the agent is responsible for the killing. Note that this can be captured only if we adopt defeasible reasoning: Th would prima facie also imply INT¬kill, a conclusion which should be blocked in this context. Given this interpretation of intentions, we will see in the rest of this paper that some standard accounts of agent types, and of social agents in particular, are not satisfactory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">BIO agents in defeasible logic</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Basics of defeasible logic</head><p>Defeasible logic (DL) was originally proposed by Nute <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b27">28]</ref> with a particular concern about computational efficiency and developed over the years notably by <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b4">5]</ref>. DL is suitable for implementations <ref type="bibr" target="#b23">[24]</ref>, is flexible <ref type="bibr" target="#b1">[2]</ref> (it has a constructively defined and easy to use proof theory), and it is modular <ref type="bibr" target="#b2">[3]</ref> (it can be easily extended to cover different logical components: besides the current contribution, see, e.g., <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>). In addition, DL is efficient: it is possible to compute the complete set of consequences of a given theory in linear time <ref type="bibr" target="#b22">[23]</ref>. As we will see, this result also applies to the logical framework presented in this paper. Knowledge in DL can be represented in two ways: facts and rules.</p><p>Facts are indisputable statements and are represented by predicates. We only use a propositional language. Facts containing free variables are interpreted as the set of their variable-free instances. For example, "the price of the spam filter is $50" is represented by Price(SpamFilter, 50).</p><p>A rule, on the other hand, describes the relationship between a set of literals (premises) and a literal (conclusion), and we can specify how strong the relationship is. As usual, rules allow us to derive new conclusions given a set of premises. As far as the strength of rules is concerned we distinguish between strict rules, defeasible rules and defeaters.</p><p>Strict rules, defeasible rules and defeaters are represented, respectively, by expressions of the form A 1 , . . . ,</p><formula xml:id="formula_5">A n → B, A 1 , . . . , A n ⇒ B and A 1 , . . . , A n B,</formula><p>where {A 1 , . . . , A n } is a possibly empty set of prerequisites and B is the conclusion of the rule. <ref type="foot" target="#foot_0">3</ref> We only consider rules that are essentially propositional. Rules containing free variables are interpreted as the set of their ground instances.</p><p>Strict rules are rules in the classical sense: whenever the premises are indisputable then so is the conclusion. Thus they can be used for definitional clauses. An example of a strict rule is "A 'Premium Customer' is a customer who has spent $10,000 on goods":</p><formula xml:id="formula_6">TotalExpense(x, 10000) → PremiumCustomer(x).</formula><p>Defeasible rules are rules that can be defeated by contrary evidence. An example of such a rule is "Premium Customer are entitled to a 5% discount":</p><formula xml:id="formula_7">PremiumCustomer(x) ⇒ Discount(x).</formula><p>The idea is that if we know that someone is a Premium Customer, then we may conclude that she is entitled to a discount unless there is other evidence suggesting that she may not be (for example if she buys a good in promotion).</p><p>Defeaters are a special kind of rules. They are used to prevent conclusions not to support them. For example:</p><formula xml:id="formula_8">SpecialOrder(x), PremiumCustomer(x) ¬Surcharge(x).</formula><p>This rule states that premium customers placing special orders might be exempt from the special order surcharge. This rule can prevent the derivation of a "surcharge" conclusion. On the other hand, it cannot be used to support a "not surcharge" conclusion. DL is a "skeptical" non-monotonic logic, meaning that it does not support contradictory conclusions. Instead DL seeks to resolve conflicts. In cases where there is some support for concluding A but also support for concluding ¬A, DL does not conclude either of them (thus the name "skeptical"). If the support for A has priority over the support for ¬A then A is concluded.</p><p>As we have alluded to above, no conclusion can be drawn from conflicting rules in DL unless these rules are prioritised. The superiority relation among rules is used to define priorities among rules, that is, where one rule may override the conclusion of another rule. For example, given the defeasible rules</p><formula xml:id="formula_9">r : PremiumCustomer(x) ⇒ Discount(x) r : SpecialOrder(x) ⇒ ¬Discount(x)</formula><p>which contradict one another, no conclusive decision can be made about whether a Premium Customer who has placed a special order is entitled to the 5% discount. But if we introduce a superiority relation &gt; with r &gt; r , then we can indeed conclude that special orders are not subject to discount.</p><p>Informally, conclusions can be drawn in DL according to the following intuition. Let D be a theory in DL (i.e., a collection of facts, rules and a superiority relation over the set of rules). A conclusion of D is a tagged literal and can have one of the following four forms: + q meaning that q is definitely provable in D (i.e., using only facts and strict rules).</p><p>q meaning that we have proved that q is not definitely provable in D. +∂q meaning that q is defeasibly provable in D.</p><p>-∂q meaning that we have proved that q is not defeasibly provable in D.</p><p>Strict derivations are obtained by forward chaining of strict rules, while a defeasible conclusion p can be derived if there is a rule whose conclusion is p, whose prerequisites (antecedent) have either already been proved or given in the case at hand (i.e., facts), and any stronger rule whose conclusion is ¬ p has prerequisites that fail to be derived. In other words, a conclusion p is derivable when:</p><p>• p is a fact; or • there is an applicable strict or defeasible rule for p, and either -all the rules for ¬ p are discarded (i.e., not applicable) or -every applicable rule for ¬ p is weaker than an applicable strict <ref type="foot" target="#foot_1">4</ref> or defeasible rule for p.</p><p>In the next sections we will see how the basic machinery of DL can be extended to deal with the multi-modal logic required to model BIO agents.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Modal defeasible logic</head><p>Our purpose is to account for policy-based motivations of BIO agents, which requires to capture at least some basic facets of the modal notions of belief, intention, and obligation. Usually modal logics are extensions of classical propositional logic with some intensional operators. Thus, any modal logic should account for two components: (1) the underlying logical structure of the propositional base and (2) the logic behaviour of the modal operators. Alas, as is well-known, classical propositional logic is not well suited to deal with real life scenarios. The main reason is that the descriptions of real-life cases are, very often, partial and somewhat unreliable. Our discussion in Sect. 2 is in line with this intuition as far as agents' motivational attitudes are concerned. Accordingly, in such circumstances classical propositional logic might produce counterintuitive results insofar as it requires complete, consistent and reliable information. Hence any modal logic based on classical propositional logic is doomed to suffer from the same problems.</p><p>On the other hand, the logic should specify how modalities can be introduced and manipulated. Some common rules for modalities are, e.g.,</p><formula xml:id="formula_10">ϕ ϕ Necessitation ϕ ⊃ ψ ϕ ⊃ ψ RM</formula><p>Both dictates conditions to introduce modalities based purely on the derivability and structure of the premise. These inference rules are related to the problem of logical omniscience: if corresponds either to INT, BEL, or OBL, they put unrealistic assumptions on the cognitive capabilities of an agent. In effect, although some aspects of the expected side-effects problem should be accepted in modelling rational agents, rules such as Necessitation and RM are clearly too demanding: both in general permit to derive that an agent believes or intends something, or that something is obligatory for her, assuming that she knows all the truths defined by her logic, or that the logic that depicts her behaviour automatically includes all the logical truths of classical logic, or that she knows all the logical consequences of known propositions.</p><p>The point is thus to avoid these difficulties by only admitting the side effects for which no contrary reason can be advanced. Our strategy is twofold. First, we take a constructive interpretation of : we have that if an agent can build a derivation of ϕ then she can build a derivation of ϕ. We want to maintain this intuition, but also to replace derivability in classical logic with a practical and feasible notion like derivability in DL. Thus the intuition behind this work is that we are allowed to derive p if we can prove p with the mode in DL.</p><p>To extend DL with modal operators we have two options: (1) to use the same inferential mechanism as basic DL and to represent explicitly the modal operators in the conclusion of rules <ref type="bibr" target="#b29">[30]</ref>; (2) introduce new types of rules for the modal operators to differentiate between modal and factual rules.</p><p>For example the "deontic" statement "The Purchaser shall follow the Supplier price lists" can be represented as</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>AdvertisedPrice(X, Y ) ⇒ OBL purchaser Pay(X, Y )</head><p>if we follow the first option and AdvertisedPrice(X, Y ) ⇒ OBL purchaser Pay(X, Y ) according to the second option, where ⇒ OBL purchaser denotes a new type of defeasible rule relative to the modal operator OBL purchaser . In both cases the meaning of the rule is that given that the price of the item X advertised by the supplier is Y , then the purchaser has the obligation to pay Y for item X .</p><p>The differences between the two approaches, besides the fact that in the first approach there is only one type of rules while the second accounts for factual and modal rules, is that the first approach has to introduce an additional machinery for introducing and reasoning with modal operators. Hence, explicitly representing the modal operators in the conclusion of rules does not follow the basic intuition we have suggested above. In fact, in this case we would have to provide a definition of p-incompatible literals (i.e., a set of literals that cannot hold when p holds.) for every literal p. For example we can have a modal logic where p and ¬ p cannot be both true at the same time. Moreover the first approach is less flexible than the second: in particular in some cases it must account for rules to derive ♦ p from p; similarly conversions-which permit to use a rule for a certain modality as it were for another modality (see infra)-require additional operational rules in a theory, thus the second approach seems to offer a more conceptual tool than the first one. It seems that the second approach can use different proof conditions based on the modal rules to offer a more fine grained control over the modal operators and it allows for interaction between modal operators.</p><p>If we label the arrows of the rules (i.e., agent's policies) of our rule-based system by the different modalities we want to deal with, then this solution leads to distinguishing different modes through which the literals can be derived using rules. How such types of derivation are related to the introduction of the corresponding modalised literals can be expressed as follows: if X ∈ {BEL, INT, OBL}, then</p><formula xml:id="formula_11">⇒ X ψ |∼ X ψ MI</formula><p>As we will see, we do make an exception when rules for belief are concerned since we will state that X ∈ {INT, OBL}. The reason for this is that we assume that beliefs are conceived of as the knowledge the agent has of the environment, and so they are used by the agent to make inferences about how the world is: in this perspective, belief conclusions correspond to factual knowledge and do not need to be modalised. But besides this exception, which can be removed if required, schema MI captures the basic logical behaviour of our modal rules. However, if nothing is done besides labelling the rules of DL, what we have in our hands is nothing but a simple treatment of modalities: what we obtain is that the conditions for introducing modalities (and in particular intentions and obligations) collapse into those for deriving literals in standard DL. Hence, the next step is to allow the consequence relations to interact with the propositional module and with each other. Indeed, we could in theory define sets of many interaction patterns, but what we need for the purposes of our paper are only two interaction strategies: one that permits to use rules for a modality X as they were for another modality Y (rule conversions), and one that considers conflicts between rules (conflict-detection and conflict-resolution).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Rule Conversions</head><p>The notion of rule conversion allows us to model peculiar interactions between different modal operators. In general, notice that in many formalisms it is possible to convert from one type of conclusion into a different one. Take for example the right weakening rule of non-monotonic consequence relations (see, for example, <ref type="bibr" target="#b21">[22]</ref>)</p><formula xml:id="formula_12">B C A |∼ B A |∼ C</formula><p>which allows for the combination of non-monotonic and classical consequences. Suppose that a rule of a specific type is given and also suppose that all the literals in the antecedent of a rule are provable in one and the same modality. If so, is it possible to argue that the conclusion of the rule inherits the modality of the antecedent? To give an example, suppose we have that ψ ⇒ BEL φ and that we derive ψ using a rule labelled by INT. Can we conclude INTφ? If the answer is positive, on the basis of MI this can be represented as follows:</p><formula xml:id="formula_13">|∼ INTψ ψ ⇒ BEL φ , INTψ |∼ INTφ Conversion</formula><p>In many cases this is a reasonable conclusion to obtain. Indeed, this is the inference pattern we discussed in Sect. 2: if an agent believes to visit Italy if she visits Rome, and she has the intention to visit Rome, then it seems rational that she has the intention to visit Italy. Thus, conversions are ways through which some rational side effects can be derived. An additional example can help us illustrate the notion of conversion. Consider the following formalisation of the Yale Shooting Problem. <ref type="foot" target="#foot_2">5</ref>load_live_ammo, shoot ⇒ BEL kill</p><p>This rule encodes the knowledge of an agent who knows that loading the gun with live ammunitions, and then shooting will kill her friend. This example clearly shows that the qualification of the conclusions depends on the modalities relative to the individual acts "load" and "shoot". In particular, if we obtain that the agent intends to load and to shoot the gun (INT(load), INT(shoot)), then, since she knows that the consequence of these actions is the death of her friend, she intends to kill him. However, if shooting was not intended, then we have prima facie to say that killing, too, was not intentional.</p><p>To define the admitted conversions we introduce a binary relation "Convert" over the modalities of the language. When we write Convert(BEL, INT) this means that a belief rule r can be used to derive an intention (of course, provided that all its antecedents are derived as intentions): r can thus be converted into a rule for intention. Notice that we do not impose any specific constraint on Convert. In particular, we do not require Convert to be irreflexive. In fact, rule conversions can be viewed as corresponding, in a multi-modal setting, to the following inference schema:</p><formula xml:id="formula_14">X ψ Y (ψ → φ) X φ<label>(5)</label></formula><p>If we have Convert(X, Y ) and X = Y , we do not obtain something necessarily odd. As is well-known, in deontic logic, for example, this inference pattern corresponds to the so-called deontic detachment:</p><formula xml:id="formula_15">OBLψ OBL(ψ → φ) OBLφ (6)</formula><p>Although ( <ref type="formula">6</ref>) is far from being uncontroversial, it seems that the same philosophical reasons that lead to accept it may support, for example, the adoption of its counterpart for intentions. Thus, even though we do not want in general to accept <ref type="bibr" target="#b4">(5)</ref> when X = Y , we believe that this case cannot be excluded, and so, a fortiori, that Convert(X, X ) be always rejected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Conflicts</head><p>As was mentioned in the previous sections, conflict-detection and conflict-resolution play an important role in the current context. It is in fact crucial to establish criteria for detecting and solving conflicts between the different components which characterise the cognitive profiles of agent's deliberation. In a multi-modal setting, we can establish which modalities can be incompatible with each other, and, also, we can impose various forms of consistency, such as the following:</p><formula xml:id="formula_16">X φ → ¬Y ¬φ (7) (X φ ∧ Y ¬φ) → ¬Z ¬φ<label>(8)</label></formula><p>Criteria for conflict-detection and -resolution in DL can capture the rationale of schemata such as <ref type="bibr" target="#b6">(7)</ref> and <ref type="bibr" target="#b7">(8)</ref>. However, their precise definition makes it necessary to take care of the peculiar approach adopted. In particular, various forms of consistency between agents' motivations require to define incompatibility relations between the modalities by referring to rule types as well as to specific methods to solve conflicts between the rules. Many complex conflict patterns can be identified <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b16">17]</ref>. For the purpose of this paper, we introduce a binary and asymmetric relation Conflict over the set of modalities that defines which types of rules are in conflict and which are the stronger ones (the formal definition of Conflict is given in Sect. 3.4). Suppose, for example, that we have</p><formula xml:id="formula_17">r : a ⇒ BEL q s : b ⇒ OBL ¬q t : c ⇒ INT q</formula><p>If we only have Conflict(BEL, OBL), this means that rule r is in conflict with rule s and that r is stronger than s: for this reason, if applicable, r will defeat s. Suppose now to drop r . Nothing is said about the relation between obligations and intentions, and so about rules s and t. This means that there is no incompatibility relation between INT and OBL and we are free to derive both INTq and OBL¬q.</p><p>The relation Conflict is explicitly linked to that of agent type. Classically, agent types are characterised by stating conflict resolution types in terms of orders of overruling between rules <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b16">17]</ref>. In this perspective, agent types are meaningful within a non-monotonic setting and are nothing but general strategies to detect and solve conflicts between the different components of the cognitive profiles of agent's deliberation. In <ref type="bibr" target="#b7">[8]</ref> 24 possible types are identified while, in <ref type="bibr" target="#b10">[11]</ref>, based on a different framework, 20 combinations are proposed. Typically, rational agents are assumed to be at least realistic: a realistic agent, in fact, is such that rules for beliefs override all other components, as beliefs correspond to agent's account of how the environment is. If the realistic condition is abandoned, we may have situations where intentions and desires override beliefs, thus leading to various forms of wishful thinking. Given the minimal assumption that a rational agent should be realistic, we may further constrain agent's deliberation in order not to violate obligations: a social agent type requires that obligations are stronger than the other motivational components with the exception of beliefs. Other agent types can be specified, for which see Sect. 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">A summary of our intuitions</head><p>Before providing a detailed presentation of the logical system for BIO agents, let us briefly summarise the logical intuitions previously presented and check them against the conceptual discussion we have developed in Sect. 2.</p><p>The main intuitions characterising our logical approach are the following:</p><p>1. The rules aim to capture policy-based motivations. For example, the rule ¬SunShining ⇒ BEL Raining says that, if the sun is not shining, then the agent believes that it is raining; the rule SunShining ⇒ INT Jogging says that the agent intends to do jogging if the sun is shining; the rule Order ⇒ OBL Pay says that, if the agent sends a purchase order, then she will be obliged to pay. 2. Rules for intention and obligation are meant to introduce modalities: for example, if we have a ⇒ INT b and we derive a, then we obtain INTb. 3. Rules labelled with BEL are an exception to the intuition under point 2 above. In the perspective of a single agent, agent's beliefs describe how things effectively stand in the world. Hence, they are taken as true beliefs, and so we do not need to derive in this case modalised literals. For instance, if we have a ⇒ BEL b and derive a, then we simply get b. 4. For the sake of simplicity, modal literals can only occur in the antecedent of rules. This is in line with our idea that the applicability of rules labelled with a modality X is the condition for deriving literals modalised with X . In other words, we do not admit rules such as a ⇒ OBL INTb. 5. We introduce conversions, which allow to derive modalised literals using rules labelled with different modalities. For example, if we have a ⇒ BEL b, derive INTa, and Convert(BEL, INT) holds, then we obtain INTb. 6. We devise methods (in particular, the relation Conflict) for detecting and solving conflicts between rules. This is in the spirit of standard DL, but here conflict resolution has a peculiar role, given the specific defeasible nature of policy-based motivations and the possibility of identifying different agent types.</p><p>It is worth noting that INT and OBL are not simple labels: they are modalities. In fact, in contrast with BEL, we model INT and OBL as non-reflexive modalities. <ref type="foot" target="#foot_3">6</ref> In addition, conversions provide complex interaction patterns between modalities which regulate various form of modal detachment. Secondly, we do not admit iterated modalities. Clearly, this is a simplification aimed at keeping the system manageable, but it does not pose severe limits for our purposes. <ref type="foot" target="#foot_4">7</ref> Since literals modalised with BEL never occur, we only fail to treat structures such as INT(INTa), OBL(OBLa), OBL(INTa), and INT(OBLa). While iterations of the same modality have a little significance, the last two structures express cases which are not needed for our discussion: INT(OBLa) makes sense when the agent is a sort of law-giver; OBL(INTa) establishes the obligation to intend, which is something that normative systems usually do not state (especially in the law).</p><p>How do these intuitions match with the conceptual points discussed in Sect. 2? Two questions are worthy of comment here: the fact that an agent is assumed to be aware of her policies, and the side-effect problem.</p><p>As regards the first question, awareness can be modelled as a kind of epistemic introspection. In other words, for any policy such as a ⇒ b, the agent is aware of it if we have BEL(a ⇒ b). However, rules are implictly assumed to be believed, exactly as we assume that non-modal literals derived via belief rules are also believed (remember that we take beliefs as true beliefs). Making explicit modalities for belief, in our framework, would be strictly necessary only if we considered more than one agent: only in this case, we would need to mark the fact that some a is believed by one or another agent. On the other hand, it is worth noting that a reasoning schema such as</p><formula xml:id="formula_18">INTa BEL(a ⇒ b) INTb (<label>9</label></formula><formula xml:id="formula_19">)</formula><p>is captured in our framework by stating that, if we have a ⇒ BEL b, derive INTa and Convert(BEL, INT) holds, then we obtain INTb. This reconstruction of (9) allows us to account for the inclusion of some side effects. Let us provide a possible formalisation of the revised Strategic Bomber scenario we discussed in Sect. 2.1:</p><formula xml:id="formula_20">Th = {INTbomb, INT¬minimise, OBL¬kill, INTbomb ⇒ INT ¬kill), ¬minimise ⇒ BEL kill}</formula><p>By default it is assumed that the intention to bomb does not imply the intention to kill innocents. But, if we assume that Convert(BEL, INT) holds and the agent is realistic (beliefs override all other factors), since we derive INT¬minimise (it is a fact), through the belief rule in Th we obtain INTkill. In other words, under this interpretation, the side effect kill is intended.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">The language of modal defeasible logic</head><p>The inference process derives factual knowledge (through belief rules), intentions and obligations based on existing facts, intentions and obligations. Thus, rules allow for the derivation of new motivational factors of an agent. As was mentioned, we divide the rules into rules for beliefs, intentions, and obligations. Provability for beliefs does not generate modalised literals, since in our view beliefs concern the knowledge an agent has about the world and corresponds to the basic inference mechanism of the agent.</p><p>A defeasible agent theory consists of a set of facts or indisputable statements, three sets of rules for beliefs, intentions, and obligations, a set of conversions saying when a rule of one type can be used also as another type, a set of conflict relations saying when two rule types can be in conflict and which rule type prevails, and a superiority relation &gt; among rules saying when a single rule may override the conclusion of another rule. For X ∈ {BEL, INT, OBL}, we have that φ 1 , . . . , φ n → X ψ is a strict rule such that whenever the premises φ 1 , . . . , φ n are indisputable so is the conclusion ψ. φ 1 , . . . , φ n ⇒ X ψ is a defeasible rule that can be defeated by contrary evidence. φ 1 , . . . , φ n X ψ is a defeater that is used to defeat some defeasible rules by producing evidence to the contrary. It is worth noting that modalised literals can occur only in the antecedent of rules: the reason of this is that the rules are used to derive modalised conclusions while we do not conceptually need to iterate modalities. This limitation makes the system more manageable.</p><p>Definition 1 (Language) Let PROP be a set of propositional atoms, MOD = {BEL, INT, OBL} be the set of modal operators, and Lab be a set of labels. The sets below are the smallest sets closed under the following rules:</p><formula xml:id="formula_21">Literals Lit = PROP ∪ {¬p| p ∈ PROP}</formula><p>If q is a literal, ∼q denotes the complementary literal (if q is a positive literal p then ∼q is ¬ p; and if q is ¬ p, then ∼q is p); Modal literals ModLit = {Xl, ¬Xl|l ∈ Lit, X ∈ {INT, OBL}};</p><formula xml:id="formula_22">Rules Rule = Rule s ∪ Rule d ∪ Rule dft , where for X ∈ MOD Rule s = {r : φ 1 , . . . , φ n → X ψ| r ∈ Lab, {φ 1 , . . . , φ n } ⊆ Lit ∪ ModLit, ψ ∈ Lit} Rule d = {r : φ 1 , . . . , φ n ⇒ X ψ| r ∈ Lab, {φ 1 , . . . , φ n } ⊆ Lit ∪ ModLit, ψ ∈ Lit} Rule dft = {r : φ X ψ| r ∈ Lab, {φ 1 , . . . , φ n } ⊆ Lit ∪ ModLit, ψ ∈ Lit}</formula><p>We use some obvious abbreviations, such as superscript for mental attitude, subscript for type of rule, and Rule[φ] for rules whose consequent is φ, for example:</p><formula xml:id="formula_23">Rule BEL = {r : φ 1 , . . . , φ n BEL ψ| (r : φ 1 , . . . , φ n BEL ψ) ∈ Rule, ∈ {→, ⇒, }} Rule s [ψ] = {φ 1 , . . . , φ n → X ψ| {φ 1 , . . . , φ n } ⊆ Lit ∪ ModLit, ψ ∈ Lit, X ∈ MOD} Rule sd = Rule s ∪ Rule d</formula><p>We use A(r ) to denote the set {φ 1 , . . . , φ n } of antecedents of the rule r , and C(r ) to denote the consequent ψ of the rule r .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2 (Conversion and conflict relations). The conversion relation Convert is defined as follows:</head><formula xml:id="formula_24">Convert ⊆ MOD × MOD The conflict relation Conflict ⊆ MOD × MOD is such that ∀X, Y ∈ MOD, Conflict(X, Y ) ⇒ ¬(Conflict(Y, X )) (asymmetry)</formula><p>Definition 3 (Defeasible agent theory) A defeasible agent theory is a structure</p><formula xml:id="formula_25">D = (F, R BEL , R INT , R OBL , &gt;, C , V )</formula><p>where</p><formula xml:id="formula_26">• F ⊆ Lit ∪ ModLit is a finite set of facts; • R BEL ⊆ Rule BEL , R INT ⊆ Rule INT ,</formula><p>R OBL ⊆ Rule OBL are three finite sets of rules such that each rule has a unique label;</p><formula xml:id="formula_27">• The superiority relation &gt; is such that &gt;=&gt; sm ∪ &gt; Conflict , where &gt; sm ⊆ R X × R X such that if r &gt; s, then if r ∈ Rule X [ p] then s ∈ Rule X [∼ p] and &gt; is acyclic; and &gt; Conflict is such that ∀r ∈ Rule X [ p], ∀s ∈ Rule Y [∼ p], if Conflict(X, Y ), then r &gt; Conflict s • C ⊆ {Convert(X, Y )|X, Y ∈ MOD} is a set of conversions; • V ⊆ {Conflict(X, Y )|X, Y ∈ MOD} is a set of conflict relations.</formula><p>The construction of the superiority relation combines two components: the first &gt; sm considers pairs of rules of the same mode. This component is usually given by the designer of the theory and captures the meaning of the single rules, and thus encodes the domain knowledge of the designer of the theory. The second component, &gt; Conflict , is obtained from the rules in a theory and depends on the meaning of the modalities.</p><p>The following running example illustrates the defeasible agent theory.</p><p>Example 1 (Running example). Frodo, our Tolkienian agent, is entrusted by Elrond to be the bearer of the ring of power, a ring forged by the dark lord Sauron. Frodo has the task to bring the ring to Mordor, the realm of Sauron, and to destroy it by throwing it into the fires of Mount Doom. However, Frodo loves the place where he was born, the Shire, and intends to go there.</p><formula xml:id="formula_28">F = {INTGoToShire, EntrustedByElrond} R = {r 1 : EntrustedByElrond ⇒ BEL RingBearer r 2 : RingBearer ⇒ OBL DestroyRing r 3 : INTGoToShire ⇒ INT ¬GoToMordor r 4 : ¬GoToMordor ⇒ BEL ¬DestroyRing} &gt; = {r 4 &gt; r 2 } C = {Convert(BEL, INT)} V = {Conflict(BEL, OBL)}</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Inferences with BIO agents</head><p>Proofs are sequences of literals and modal literals together with so-called proof tags + , -, +∂ and -∂. Given a defeasible agent theory D, + X q means that literal q is provable in D using only facts and strict rules for modality X , -X q means that it has been proved in D that q is not definitely provable in D, +∂ X q means that q is defeasibly provable in D, and -∂ X q means that it has been proved in D that q is not defeasibly provable in D.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4</head><p>Given an agent theory D, a proof in D is a linear derivation, i.e, a sequence of labelled formulas of the type + X q, -X q, +∂ X q and -∂ X q, where the proof conditions defined in the rest of this section hold.</p><p>We start with some terminology. As was explained, the following definition states the special status of belief rules, and that the introduction of a modal operator corresponds to being able to derive the associated literal using the rules for the modal operator. Definition 5 Let # ∈ { , ∂}, and P = (P(1), . . . , P(n)) be a proof in D. A (modal) literal q is #-provable in P if there is a line P(m) of P such that either 1. q is a literal and P(m) = +# BEL q or 2. q is a modal literal X p and P(m) = +# X p or 3. q is a modal literal ¬X p and P(m) = -# X p.</p><p>A literal q is #-rejected in P if there is a line P(m) of P such that 1. q is a literal and P(m) = -# BEL q or 2. q is a modal literal X p and P(m) = -# X p or 3. q is a modal literal ¬X p and P(m) = +# X p.</p><p>The definition of X describes just forward chaining of strict rules:</p><formula xml:id="formula_29">+ X : If P(n + 1) = + X q then (1) q ∈ F if X = BEL or Xq ∈ F or (2) ∃r ∈ R X s [q] : ∀a ∈ A(r ) a is -provable or (3) ∃r ∈ R Y s [q] : Convert(Y, X ) ∈ C , ∀a ∈ A(r ) Xa is -provable. -X : If P(n + 1) = -X q then (1) q / ∈ F if X = BEL and Xq / ∈ F and (2) ∀r ∈ R X s [q] ∃a ∈ A(r ) : a is -rejected and (3) ∀r ∈ R Y s [q] : if Convert(Y, X ) ∈ C then ∃a ∈ A(r ) Xa is -rejected.</formula><p>For a literal q to be definitely provable with the mode X we need to find a strict rule for X with head q, whose antecedents have all been definitely proved previously. And to establish that q cannot be definitely proven we must establish that for every strict rule with head q there is at least one antecedent which has been shown to be non-provable. Condition (3) says that a rule for Y can be used as a rule for a different modal operator X in case all literals in the body of the rule are modalised with the modal operator we want to prove. For example, given the rule p, q → BEL s, we can derive + INT s if we have + INT p, + INT q, and the conversion Convert(BEL, INT) holds in the theory.</p><p>Conditions for ∂ X are more complicated. We define when a rule is applicable or discarded. A rule for a belief is applicable if all the literals in the antecedent of the rule are provable with the appropriate modalities, while the rule is discarded if at least one of the literals in the antecedent is not provable. As before, for the other types of rules we have to take conversions into account. We have thus to determine conditions under which a rule for Y can be used to directly derive a literal q modalised by X . Roughly, the condition is that all the antecedents a of the rule are such that +∂ X a. Definition 6 Given a derivation P, P(1 . . . n) denotes the initial part of the derivation of length n. Let X, Y, Z ∈ MOD.</p><p>• A rule r ∈ R sd is applicable in the proof condition for ±∂ X iff 1. r ∈ R X and ∀a ∈ A(r ), +∂ BEL a ∈ P(1 . . . n) and ∀Za ∈ A(r ), +∂ Z a ∈ P(1 . . . n), or 2. r ∈ R Y , Convert(Y, X ) ∈ C , and ∀a ∈ A(r ), +∂ X a ∈ P(1 . . . n).</p><p>• A rule r is discarded in the condition for ±∂ X iff 1. r ∈ R X and ∃a ∈ A(r Example 3 If we have a type of agent that allows a deontic rule to be converted into a rule for intention, Convert(OBL, INT), then the definition of applicable in the condition for ±∂ INT is as follows: a rule r ∈ R sd [q] is applicable iff (1) r ∈ R INT and ∀a ∈ A(r ), +∂ BEL a ∈ P(1 . . . n) and ∀Xa ∈ A(r ), +∂ X a ∈ P(1 . . . n), (2) or r ∈ R OBL and ∀a ∈ A(r ), +∂ INT a ∈ P(1 . . . n). In this second case, for example, given the rule p, q ⇒ OBL s, we can derive +∂ INT s if we have +∂ INT p and +∂ INT q.</p><formula xml:id="formula_30">) such that -∂ BEL a ∈ P(1 . . . n) or ∃Za ∈ A(r ) such that -∂ Z a ∈ P(1 . . . n); or 2. r ∈ R Y and, if Convert(Y, X ), then ∃a ∈ A(r ) such that -∂ X a ∈ P(1 . . . n), or 3. r ∈ R Z and either ¬Convert(Z , X ) or ¬Conflict(Z , X ).</formula><p>As a corollary of the definition of applicability, we can establish when a literal is supported (see Sect. 5.2 for the use of this notion): Definition 7 Given a theory D, a literal l is supported in D iff there exists a rule r ∈ R[l] such that r is applicable, otherwise l is not supported. For X ∈ MOD we use + X l and -X l to indicate that l is supported / not supported by rules for X .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>123</head><p>We are now ready to provide proof conditions for ±∂ X :</p><formula xml:id="formula_31">+∂ X : If P(n + 1) = +∂ X q then (1) + X q ∈ P(1 . . . n) or (2) (2.1) -X ∼q ∈ P(1 . . . n) and</formula><p>(2.2)∃r ∈ R sd <ref type="bibr">[q]</ref> such that r is applicable, and</p><formula xml:id="formula_32">(2.3)∀s ∈ R[∼q] either s is discarded, or (2.3.1)∃t ∈ R[q] such</formula><p>that t is applicable and t &gt; s, and either</p><formula xml:id="formula_33">t, s ∈ R Z , or Convert(Y, X ) and t ∈ R Y -∂ X : If P(n + 1) = -∂ X q then (1) -X q ∈ P(1 . . . n) and either (2) (2.1) + X ∼q ∈ P(1 . . . n) or (2.2)∀r ∈ R sd [q], either r is discarded, or (2.3)∃s ∈ R[∼q],</formula><p>such that s is applicable, and</p><formula xml:id="formula_34">(2.3.1)∀t ∈ R[q] either t is discarded, or t &gt; s, or t ∈ R Z , s ∈ R Z , Z = Z and, if t ∈ R Y then ¬Convert(Y, X ).</formula><p>To show that q is defeasibly provable we have two choices: <ref type="bibr" target="#b0">(1)</ref> We show that q is already definitely provable; or (2) we need to argue using the defeasible part of a theory D. For this second case, three (sub)conditions must be satisfied. First, we need to consider possible reasoning chains in support of ∼q, and show that ∼q is not definitely provable (2.1). Second, we require that there must be a strict or defeasible rule for q which can be applied (2.2). Third, we must consider the set of all rules which are not known to be inapplicable and which permit to get ∼q (2.3). Essentially, each such a rule s attacks the conclusion q. For q to be provable, s must be counterattacked by a rule t for q with the following properties: (i) t must be applicable, and (ii) t must be stronger than s. Thus each attack on the conclusion q must be counterattacked by a stronger rule. In other words, the rules r and t form a team (for q) that defeats the rules s. However, since we can have rules for different modes, we have to ensure we have the appropriate relationships among the rules. Thus clause (2.3.1) prescribes that either the rule that attacks the conclusion we want to prove (s) and the rule used to counterattack it (i.e., t) have the same mode (i.e., s, t ∈ R Z ), or that t can be used to produce a conclusion of the mode we want to prove (i.e., t ∈ R Y and Convert(Y, X )).</p><p>-∂ X q is defined in an analogous manner.</p><p>Example 4 (Running example; continued) Below is the set C of all conclusions we get using the rules in R:</p><formula xml:id="formula_35">C = {RingBearer, INT¬GoToMordor, INT¬DestroyRing}</formula><p>As facts, we know that Frodo has the primitive intention to go to the Shire and that he has been entrusted by Elrond. These facts make applicable rules r 3 and r 1 , which permit to derive that Frodo is the ring bearer and that he has the intention not to go to Mordor. At this point we have a conflict, as we have Conflict(BEL, OBL) and Convert(BEL, INT). In effect, given the conversion, r 4 permits to derive that Frodo has the intention not to destroy the ring while rule r 2 should lead to the obligation to destroy it. However, r 4 is stronger than r 2 and so we only get +∂ INT ¬DestroyRing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Agent types</head><p>Classically, agent types are characterized by stating conflict resolution types in terms of orders of overruling between rules <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b16">17]</ref>. For example, an agent is realistic when rules for beliefs override all other components; she is social when obligations are stronger than the other motivational components with the exception of beliefs, etc. As suggested in <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>, agent types can be characterised in DL as follows:</p><p>Definition 8 (Agent type (1)) An agent type is defined by a set of pairs (X, Y ), X, Y ∈ {BEL, OBL, INT}, such that for every r and r such that r ∈ R X [q] and r ∈ R Y [∼q], we have that r &gt; r .</p><p>For example, while realistic agents are such that X = BEL and Y ∈ {INT, OBL}, social agents are such that X = OBL and Y = INT. It is clear that the notion of agent type is defined in terms of the relation Conflict we have previously introduced.</p><p>Let us see the agent types that can be identified in the framework we have defined so far. Table <ref type="table" target="#tab_1">1</ref> shows all possible cases and, for each kind of rule, indicates all attacks on it. It should be read as follows. Each of the three main columns identifies a possible kind of conflict between two types X, Y of applicable rules that would permit to infer the literals p and ∼ p labelled by X and Y respectively. The first row from the top in the three main columns specifies the case where both literals are derived (i.e., there is no conflict, which indeed corresponds to the case where the modalities involved are not in Conflict); the second and third rows from top identify the cases where we have a conflict and one rule prevails over the other. The third sub-column in each main column defines the agent type for which each conflict-detection and -resolution policy is appropriate. (To save space, in Table 1 "indep." abbreviates "independent", "wish. th." "wishful thinking", and "real." "realistic".) Independent agents are free to adopt intentions for p in presence of derivations for OBL∼ p. This is possible in our framework when we have that ¬Conflict(OBL, INT) and ¬Conflict(INT, OBL): this means that the system admits both conclusions, as they are not in conflict. As expected, for social agents obligations override intentions and so Conflict(OBL, INT); the opposite case is when an agent is deviant and her intentions override the obligations, Conflict(INT, OBL). Where beliefs are defeated either by obligations or by intentions we have classical examples of wishful thinking. Notice that in Table <ref type="table" target="#tab_1">1</ref> also the cases +∂ OBL p/ + ∂ BEL ∼ p and +∂ INT p/ + ∂ BEL ∼ p have been classified as wishful thinking, given the basic nature of beliefs we adopted in our framework. However, we are aware that this reading is debatable: in effect, if we can derive both conclusions, this means that there is no real conflict. Last, it is worth noting that we do not consider here the case where -∂ X p/ -∂ Y ∼ p: we would have that X and Y are incompatible, but that it is not possible to establish what rule is the strongest one, thus leading to a mutual defeating of the rules involved. This case-which is discussed in <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b16">17]</ref> and permits to identify other agent types-is excluded here, as the relation Conflict both identifies conflicts and solves them by establishing what rule type must prevail.  It is possible to integrate the above classifications by referring to the notion of conversion. Conversions do not have a direct relation with conflict resolution because they simply affect the condition of applicability of rules. However, they indeed contribute to define the cognitive profile of agents because they allow to obtain conclusions modalised by a certain X through the application of rules which are not modalised by X . Table <ref type="table" target="#tab_2">2</ref> shows the conversions and specify new agent types with respect to which each conversion seems to be appropriate.</p><p>A preliminary remark before commenting Table <ref type="table" target="#tab_2">2</ref>. We do not consider here conversions Convert(X, Y ) where X = Y . In fact, even though they can be admitted, they do not seem to characterise a specific cognitive profile for the agents. Consider Convert(BEL, OBL) and Convert(BEL, INT). Both seem appropriate for some types of realistic agent. Indeed, for a realistic agent beliefs correspond to her basic reasoning mechanism. Accordingly, if we have</p><formula xml:id="formula_36">r : ¬open_umbrella ⇒ BEL wet +∂ INT ¬open_umbrella +∂ OBL ¬open_umbrella</formula><p>it is reasonable to derive both that the agent has the intention to be wet, and that it is obligatory for her to be wet. Other conversions look more appropriate for other agent types. For example, we may have agent types for which Convert(OBL, INT) holds. This means that from r : kill ⇒ OBL kill_gently +∂ INT kill we can derive that the agent has the intention to kill gently. But this derivation is conceptually meaningful only if we assume a kind of norm regimentation, by which we impose that all agents intend what is prescribed by deontic rules.</p><p>The peculiarity of Convert(INT, OBL) is that the simple fact that something is derived as obligatory can permit to obtain through a rule for intention that something else is obligatory as well. Consider this case:</p><formula xml:id="formula_37">r : help_needy_people ⇒ INT save_money +∂ OBL help_needy_people</formula><p>If Convert(INT, OBL) holds, then we can derive that it is obligatory for the agent to save money: an intention supports the derivation of an obligation. In other papers <ref type="bibr" target="#b16">[17]</ref>, this case has been classified as an example of an agent legislator. Here, we prefer to consider it as a case of a deviant agent <ref type="bibr" target="#b10">[11]</ref>, due to its structural similarity to Conflict(INT, OBL).</p><p>Finally, notice that the conversions Convert(OBL, BEL) and Convert(INT, BEL), which are marked in the table by a "NO", seem meaningless. They say that a rule for obligation and for intention may respectively be used to derive a belief. This sounds odd, at least adopting the interpretation of beliefs of this paper. In fact, since the belief modality captures the basic knowledge the agent has about the environment, it is treated as its logic were reflexive (namely, that BELψ → ψ holds). Consider, for example, the following:</p><formula xml:id="formula_38">r : help_needy_people ⇒ INT save_money +∂ BEL help_needy_people</formula><p>If Convert(INT, BEL) holds, then we obtain that the agent in fact saves money, which is odd: beliefs, according to our interpretation should be independent from agent's deliberation, even though they are used to derive motivational attitudes such as intentions and obligations. In addition, adopting both Convert(OBL, BEL) and Convert(INT, BEL) would determine a collapse of our logic, as we could dispense with explicit modalities in the antecedent of rules.</p><p>Since our logic system is characterised by Conflict as well as by Convert, and conversions indeed contribute to define the cognitive profile of an agent, it seems that an agent type should take both parameters into account: Definition 9 (Agent type (2)) An agent type is defined by a pair ( , ), where</p><formula xml:id="formula_39">⊆ {Conflict(X, Y )|X, Y ∈ MOD} and ⊆ {Convert(Z , W )|Z , W ∈ MOD}.</formula><p>It is easy to see that the notion of agent type of Definition 8 (proposed in <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>) is captured by Definition 9.</p><p>This completes our picture of the notion of agent types. However, a serious difficulty is around the corner when we focus on the notion of agent type based on defining criteria for conflict-detection and -resolution. Are we sure that this view is sufficient, given the account of policy-based attitudes we previously discussed? In the reminder we will consider only the interaction between intentions and obligations, event though similar remarks can be easily extended to all other agent types presented in Table <ref type="table" target="#tab_1">1</ref>. But, even confining the problem to these components, the question at stake is: How to deal with social agents? The simplest solution is the classical one, corresponding to adopting schema <ref type="bibr" target="#b6">(7)</ref> and that we have adopted so far: when we have two rules, one leading to INTφ and the other to OBL∼φ, the former is blocked. As we shall see, this strategy is not enough.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Social agents</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">The problem</head><p>The idea of social agent based on the intuition of Definition 8-which is also adopted in <ref type="bibr" target="#b7">[8]</ref>-does not guarantee that agent's deliberation is oriented to fully complying with obligations. The same holds when Definition 9 is used. In effect, to our view a social agent can be defined by the following pair</p><formula xml:id="formula_40">({Conflict(BEL, INT), Conflict(BEL, OBL), Conflict(OBL, INT)}, {Convert(BEL, OBL), Convert(BEL, INT)})</formula><p>according to which the agent is realistic (beliefs override the other components, and the appropriate conversions hold) and obligations prevail over conflicting intentions.</p><p>In both cases, the drawback is mainly due to the introduction of conversions. Since conversions allow to obtain conclusions modalised by a certain X through the application of rules which are not modalised by X , they are fundamental in order to capture the fact that some side-effects should be accepted insofar as they are consequences of policies of which the agent is aware. Moreover, some conversions seem useful to integrate the basic idea of social agency.</p><p>It is clear that our system admits three different types of intentions and obligations. First, we have primitive intentions and obligations when these are facts of the theory. But we can also have what we may call primary and secondary intentions and obligations, depending on whether we accept at least basic conversions via belief rules.</p><p>Let us consider Example 1. INTGoToShire is a primitive intention. On the other hand, OBLDestroyRing-if it were derived from rule r 2 -and INT¬GoToMordor are primary obligations and intentions as they would be obtained without the use of conversions (see <ref type="bibr">Example 4)</ref>. Finally, INT¬DestroyRing is a secondary intention because it is obtained from the rule r 4 : ¬GoToMordor ⇒ BEL ¬DestroyRing and from +∂ INT ¬GoToMordor (again, see Example 4). It should be noted that OBLDestroyRing cannot be derived because r 4 &gt; r 2 , but this just amounts to assuming that the agent is realistic: r 4 is a belief rule whereas r 2 is a deontic rule. In other words, when we have in general that</p><formula xml:id="formula_41">a ⇒ OBL q b ⇒ BEL ∼q +∂ BEL a +∂ INT b</formula><p>we are doomed to have social agents who cannot be truly social since some of their (primitive) intentions lead to behaviours against what would be otherwise obligatory for the agents. However, this issue is not a matter of a direct conflict between rules for intentions and obligations. Thus, to deal with norm-complying agents in these scenarios and to restore their sociality we are required to change the notion of agent type. We cannot anymore define it in terms of an order of overruling between rules, but we have to focus on how the conflicting literals are derived during the proof. Indeed, this is feasible, but has a high computational cost, and even then we cannot guarantee the sociality of an agent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">The cost of social agents</head><p>In this section we investigate the complexity of the defeasible logic for BIO agents where we assume the conversions Convert(BEL, OBL) and Convert(BEL, INT) and then we turn our attention to the complexity of social agents. We first introduce some notions to make precise the definition of the issues at hand.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 10</head><p>Let # be one of the proof tags. Given a theory D, D ±# p iff there is a derivation P in D such that, for some n, P(n) = ±# p. Definition 11 Given a theory D, the universe of D (U D ) is the set of all the atoms occurring in D; the extension of D (E D ), is defined as follows:</p><formula xml:id="formula_42">E D = ( + , -, ∂ + , ∂ -)</formula><p>where for X ∈ {BEL, INT, OBL}</p><formula xml:id="formula_43">+ = {Xl : D + X l}; -= {Xl : D -X l}; ∂ + = {Xl : D +∂ X l}; ∂ -= {Xl : D -∂ X l}.</formula><p>Two theories D and D are equivalent if and only if they have the same extension, namely</p><formula xml:id="formula_44">D ≡ D iff E D = E D .</formula><p>We now prove the main theorem about the complexity of our defeasible logic. We show that the logic has linear complexity if we compute the whole set of conclusions, i.e., the extension, of a given theory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1 For every theory D, E D can be computed in time linear to the size of the theory, i.e., O(|U D | * |R|).</head><p>Proof The proof is based on a modification of the algorithm given by Maher <ref type="bibr" target="#b22">[23]</ref> to show that propositional defeasible logic has linear complexity.</p><p>The main idea of the proof is to build appropriate data structures to implement a series of transformations reducing the complexity of the rules, and where each literal and modal literal is examined only once. The focal point of the transformations is based on the following properties:</p><formula xml:id="formula_45">• Let D +∂ p then D ∪ {r : p 1 , . . . , p n , p ⇒ q} ≡ D ∪ {r : p 1 , . . . , p n ⇒ q}. • Let D -∂ p then D ∪ {r : p 1 , . . . , p n , p ⇒ q} ≡ D.</formula><p>The properties allow us (1) to remove already proved literals from the body of rules and (2) to remove rules which have been discarded.</p><p>The algorithm has three phases. (1) A pre-processing phase where we use similar transformations to those given in <ref type="bibr" target="#b2">[3]</ref> to transform a theory into an equivalent theory without superiority relation and defeaters; the transformation is linear. We will propose two linear transformations, one to empty the superiority relation and one to remove defeaters. We will show that these transformations are correct, that is, they produce the same sets of conclusions in the language of the theory they transform (Theorem 2 and Theorem 3). ( <ref type="formula" target="#formula_0">2</ref>) A rule loader that parses the theory obtained in the first phase and generates the data structure that encodes the theory. <ref type="bibr" target="#b2">(3)</ref> The inference engine applies transformations to the data structure, where at every step it reduces the complexity of the data structure.</p><p>(1) Transformations Theory transformations are important tools to study properties of defeasible logic. In <ref type="bibr" target="#b2">[3]</ref> we extensively used transformations to show under which conditions it is possible to simplify the presentation of basic defeasible logic by dispensing defeaters and the superiority relation. In what follows we are going to give transformations that allow us to remove defeaters and the superiority relation from modal defeasible theories for BIO agents. </p><formula xml:id="formula_46">)={A(r ) → BEL ¬in f (r ), ¬in f (r ) → X C(r ) : A(r ) → X C(r ) ∈ R sd }</formula><p>For each rule r ∈ R, in f (r ) is a new atom, i.e., it does not appear in . Furthermore all new atoms generated are distinct.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2 The transformation elimsup is correct.</head><p>Proof The proof by induction on the length of derivations is similar to that given in <ref type="bibr" target="#b2">[3]</ref>. Here we give in full the case of strict derivations and we outline the main part of the case of defeasible derivations.</p><p>Case if D + X p then elimsup(D) + X p. For a proof of length 1 of + X p, i.e., P(1) = + X p, then we have two cases: (1) X p ∈ F, (2) ∃r ∈ R X s [ p], A(r ) = ∅. The first case is trivial since F is the same in D and elimsup(D). For (2) we have that elimsup(D) contains the rules r a :→ BEL ¬in f (r ), and r c : ¬in f (r ) → p. r a is applicable, so we have + BEL ¬in f (r ), then this makes r c applicable and then we have elimsup(D) + X p.</p><p>For the inductive step, we assume as usual that the property holds for proofs whose length is up to n, and then we consider P(n + 1) = + X p. Beside the cases for the inductive base, we have two additional cases to consider here: (a</p><formula xml:id="formula_47">) ∃r ∈ R X s [ p], ∀a ∈ A(r ), + Y a ∈ P(1 . . . n); (b) Convert(X, Y ) and ∃s ∈ R Y s , + X a ∈ P(1 . . . n).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>For (a) by inductive hypothesis, ∀a ∈ A(r ), elimsup(D)</head><p>+ a, thus the rule r a : A(r ) → BEL ¬in f (r ) is applicable, thus elimsup(D) + BEL ¬in f (r ), which makes rule r c : ¬in f (r ) → X p applicable as well, and we can conclude elimsup(D) + X p.</p><p>For (b) by inductive hypothesis ∀a ∈ A(r ), elimsup(D) + X a, thus we can use the rule s a : A(r ) → BEL ¬in f (s) to derive + X ¬in f (s). Since we have Convert(Y, X ), we can apply conversion to the rule s c : ¬in f (s) → Y p to derive elimsup(D) + X p.</p><p>For the other direction, i.e., elimsup(D) + X p (for p ∈ ) then D + X p, the proof is again by induction on the length of derivations.</p><p>The inductive base is trivial since the only possible derivation for a modal literal X p in is only when X p ∈ F, and thus X p is also a fact in D.</p><p>For the inductive bases, P(n +1) = + X p we have that for every literal in which is not a fact, ∃r ∈ R such that either (i) ¬in f (r ) → X p or (ii) ¬in f (r ) → Y p is in elimsup(D). In addition we have a rule A(r ) → BEL ¬in f (r ).</p><p>For (i) in the proof we have ∀a ∈ A(r ), + a ∈ P(1 . . . n), thus by inductive hypothesis D + a, which makes applicable the rule r : A(r ) → X p. For (ii) to derive + X p from ¬in f (r ) → Y p, we must have + X ¬in f (r ) ∈ P(1 . . . n), which means that we have + X a ∈ P(1 . . . n) for all a ∈ A(r ). Again by inductive hypothesis we have D + X a for all a ∈ A(r ), and r is A(r ) → Y p where Convert(Y, X ). Therefore D + X p.</p><p>The proof for -X is analogous and uses the same ideas of conversion from the case for + and the basic structure from the proof for the transformation that removes the superiority relation from <ref type="bibr" target="#b2">[3]</ref>.</p><p>The proof of the case for +∂ is essentially the same as that given in <ref type="bibr" target="#b2">[3]</ref>. The only difference is in the iterative construction of the sets of maximal applicable rules, the existence of such sets is guaranteed by the clause of the proof conditions saying t &gt; s. If a rule r is maximal applicable then either ∀a ∈ A(r ), +∂a or ∀a ∈ A(r ), +∂ X a (applicable condition), and there is no applicable rule s such that s &gt; r . Thus all rules ¬in f (s) → BEL in f (r ) are discarded while the rule A(r ) → BEL ¬in f (r ) is applicable, thus we prove either +∂ BEL ¬in f (r ) or +∂ X ¬in f (r ). Thus every rule ¬in f (r ) ⇒ BEL in f (t), is applicable, and so we prove -∂ Z ¬in f (t) for all Z ∈ MOD. The main points here is that BEL converts universally and that there are conflicts between all pairs of modalities. Accordingly the rule t c , attacking a rule for p is discarded. Using all rules in the maximal applicable sets we can show that all rules attacking p are discarded, and that we have at least one applicable rule for p. The proof for -∂ has the same structure of that given in <ref type="bibr" target="#b2">[3]</ref> for the same case and the construction just outlined for the case +∂. </p><formula xml:id="formula_48">)= ⎧ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎩ {r + : A(r ) → BEL p + , r -: A(r ) → BEL ¬ p -, r : p + → X p} r ∈R X sd [ p] {r -: A(r ) → BEL p -, r + :A(r ) → BEL ¬ p + , r : p -→ X ¬ p} r ∈R X sd [¬ p] {r :A(r ) ⇒ BEL ¬ p -} r ∈R dft [ p] {r :A(r ) ⇒ BEL ¬ p + } r ∈R dft [¬ p]</formula><p>and the superiority relation &gt; is defined by the following conditions:</p><formula xml:id="formula_49">∀r , s ∈ R (r &gt; s ⇐⇒ ∃r, s ∈ R : r ∈ elimdft(r ), s ∈ elimdft(s), r &gt; s)</formula><p>where r and s are conflicting.</p><p>For each atom p ∈ , p + and p -are new atoms, i.e., they do not appear in . Furthermore all new atoms generated are distinct.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 3 The transformation elimdft is correct.</head><p>Proof Notice that the transformation elimdft is essentially the same transformation as that given in <ref type="bibr" target="#b2">[3]</ref>. The only difference is that the rules p + → X p and p -→ X ¬ p are modalised with X instead of BEL. However, this difference is flattened by the definition of social agents, where BEL converts universally and all the modalities are involved in conflicts.</p><p>(2) Rule loader The rule loader builds a data structure as follows: for every atom α ∈ U D we create three entries α, INTα and OBLα. Each entry has associated to it a list of hash tables:</p><p>For α we have</p><p>• +h is a list of (pointers to) rules in R BEL where α appears in the head;</p><p>• -h is the list of rules in R BEL where ∼α appears in the head;</p><p>• +b is the list of rules in R where α occurs in the body;</p><p>• -b is the list of rules in R where ∼α occurs in the body.</p><p>For X α, X ∈ {INT, OBL} we have</p><p>• +h is a list of rules in R X where α appears in the head;</p><p>• -h is the list of rules in R X where ∼α appears in the head;</p><p>• +h B is a list of rules in R BEL where α appears in the head;</p><p>• -h B is a list of rules in R BEL where ∼α appears in the head;</p><p>• +b is the list of rules in R where X α occurs in the body;</p><p>• -b is the list of rules in R where X ∼α occurs in the body.</p><p>• +b ∼ is the list of rules in R where ∼X α occurs in the body;</p><p>• -b ∼ is the list of rules in R where ∼X ∼α occurs in the body.</p><p>To each rule in R X , X = BEL, we associate a structure consisting of a (modal) literal (the head of the rule) and a set of pointers to the modal literals in the body of the rule, implemented as an hash table; while for belief rules we create the same structure as the other types of rules plus two other structures, one for INT and one for OBL, the single pointer refers to the modal literal and the set of pointers corresponds to the literals in the body modalised, respectively, with INT and OBL.</p><p>(3) The inference engine The Inference Engine is based on an extension of the Delores algorithm/implementation proposed in <ref type="bibr" target="#b23">[24]</ref> as a computational model of Basic Defeasible Logic. In turn 1. It asserts each fact (as an atom) as a conclusion and removes the atom from the rules where the atom occurs positively in the body, and it "deactivates" the rules where either the atom occurs negatively in the body, or incompatible modal literals occur in the body. 2. It scans the list of active rules for rules where the body is empty. It takes head and searches for rule (of the appropriate type) where the head is the negation of the atom or a modal literal incompatible with it. If there are no such rules then, the atom is appended to the list of facts, and removed from the rules. 3. It repeats the first step. 4. The algorithm terminates when one of the two steps fails. On termination the algorithm outputs the set of conclusions. <ref type="foot" target="#foot_5">8</ref>It is immediate to see that the algorithm runs in linear time. Each (modal) atom/literal in a theory is processed exactly once and every time we have to scan the set of rules, thus the complexity of the above algorithm is O(|U D | * |R|).</p><p>Given the above result it might seem that social agents are computationally feasible. However, as we have seen in the previous sections there are situations (let us call them deviant situations) where social agents do not behave as expected. First of all, we have to identify when we have a deviant situation and what are the reasons why we have them, and what kind of control an agent has over them. Here we assume that a deviant situation depends on some primitive intentions of an agent (i.e., intentions given as facts). Since these intentions are independent of the policy the theory describes the only alternative a social agent has is to give up some of them. In the rest of the section we study whether this is possible and what price an agent has to pay to be social. The answer is negative; we will provide a theory that is essentially deviant, and we will show that social agents are (computationally) expensive.</p><p>A precise definition of the problem is provided in the next section. The specification of the problem is meant to formalise the situation we have described in the previous sections. The combination of the proof tags in the specification of the instance is only possible in case there is an applicable deontic rule for p (+ OBL p) such that (i) would be otherwise unchallenged -i.e., there are no deontic rules to support ∼ p (-OBL ∼ p); (ii) there are no reasons to believe the opposite of the conclusion of the deontic rule; (iii) but the deontic rule is defeated, against the sociality of the agent, by the intentionality of ∼ p obtained as a consequence of an intention of the agent (this means that it has been obtained by converting a belief rule into an intention rule). In other terms a potentially valid obligation is blocked by a consequence of an intentional behaviour.</p><p>Example 5 Let us the consider the theory consisting of</p><formula xml:id="formula_50">F = {INT p, INTs} R = {r 1 : p, s ⇒ BEL q r 2 : ⇒ OBL ∼q r 3 : ⇒ BEL s} &gt; = {r 1 &gt; r 2 }</formula><p>r 1 is a belief rule and so the rule is stronger than the deontic rule r 2 . In addition we have that the belief rule is not applicable (i.e., -BEL q) since there is no way to prove +∂ BEL p. There are no deontic rules for q, so -∂ OBL q. However, rule r 1 behaves as an intention rule since all its antecedent can be proved as intentions, i.e., +∂ INT p and +∂ INT s. Hence, since r 1 is stronger than r 2 , the derivation of +∂ OBL ∼q is prevented against the sociality of the agent.</p><p>The related decision problem is whether it is possible to avoid the "deviant" behaviour by giving up some primitive intentions, retaining all the (primary) obligations, and maintaining a set of primitive intentions as close as possible to the original set of intentions.</p><p>Example 5 (continued) When we examine the theory we notice that both primitive intentions concur to the prevention of the derivation of +∂ OBL ∼q. These intentions are under the control of the agent. The agent has the opportunity to avoid the deviant behaviour if she gives up at least one of her primitive intentions. Accordingly, the agent has three alternatives: to give up INT p, to give up INTs, or to give up both. The first two options minimise the difference between the original theory and the resulting theory.</p><p>There could be cases where, no matter what intentions are removed, the theory will result in a deviant situation. The simplest case is where there are intentions that are at the same time primitive and primary.</p><p>Example 6 Let the theory D be</p><formula xml:id="formula_51">F = {INT p} R = {r 1 : ⇒ INT p r 2 : p ⇒ BEL q r 3 : ⇒ OBL ∼q} &gt; = {r 2 &gt; r 3 }</formula><p>In this theory we have only one primitive intention and therefore the only way to see whether it is possible to avoid the problem is to give up that intention. However, we have that r 1 is an intention rule for p, and thus we can use it to derive +∂ INT p, which allows r 2 to be used to derive an intention instead of a belief, and consequently to prevent the derivation of an obligation against the sociality of the agent.</p><p>Notice that, given the non-monotonic nature of defeasible logic, it is possible that a solution to the problem is given by a superset of the original set of intentions instead of a subset. 123 literals for ¬load(u), the computation of the rule INTload(u) ⇒ BEL load(u) can be computed independently of the rest of the theory thanks to the modularity of DL <ref type="bibr" target="#b2">[3]</ref>, thus the sums in the antecedent of the second and third rule can be considered as "facts" in the theory. In case one of the condition of the knapsack problem is not satisfied we have exactly a deviant situation as in the restoring sociality problem. The encoding of the knapsack problem in DL is clearly linear, thus any algorithm that solves the restoring sociality problem in polynomial time will solve the knapsack problem in polynomial time. Therefore the restoring sociality problem is NP-complete.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Revising deviant situations</head><p>In this paper we focused on what we called social agents, i.e., agents who refrain from planning activities which may result in a violation of existing obligations. However, we would like to stress out that the so called "restoring sociality problem", and the computational complexity results associated with it, is not specific to social agents, but it depends on the structure of an agent type. In particular any agent type defined by the following parameters</p><formula xml:id="formula_52">Convert(X, Y ), Conflict(X, Z ), Conflict(X, Y ), Conflict(Z , Y )</formula><p>suffers from the same problem (of course with a different intuitive reading of the problem).</p><p>In a similar way the transformations to remove defeaters and to empty the superiority relation, as well as the general complexity result for the logic obtain for all agent types (modal defeasible logic variants) isomorphic to social agents.</p><p>A first solution to the complexity of social agents is to avoid conversions. However, we believe that this is a rather unsatisfactory approach for agents with both internal (intentions) and external (obligations) motivational attitudes. It is not possible to capture the notion of intentionality which is of paramount importance when we deal with agents situated in normative contexts.</p><p>A second solution would be to assume that belief rules behaving as intention rules (i.e., obtained from the conversion Convert(BEL, INT)) are always weaker than deontic rules or belief rules behaving as deontic rules (i.e., where the conversion Convert(BEL, OBL) applies). In this case the problem is with theory like</p><formula xml:id="formula_53">r 1 : a ⇒ BEL q r 2 : b ⇒ BEL ∼q +∂ INT a +∂ OBL b r 1 &gt; r 2</formula><p>where r 1 is at the same time stronger and weaker than r 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related work</head><p>This article provides an extensive proposal of how DL can be extended to model cognitive agents interacting with obligations. In this sense, it is the final result of a series of earlier works <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b18">19]</ref>. In <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref> DL is extended by introducing the ⊗ operator to represent explicit violations and contrary-to-duty reasoning. Cognitive profiles of agents are characterised by their beliefs, desires, intentions and obligations. A large agent type classification is developed accordingly. In <ref type="bibr" target="#b16">[17]</ref> a similar picture of agents is presented but desires are defined as literals supported by (but not necessarily derived from) reasoning chains of rules for intention. In addition, an operator for intentional and successful action is introduced. In all these works conflicts are simply modelled by using standard superiority relation (&gt;) of DL, and so it is never admitted that we can derive, for example, INTa and OBL¬a. Moreover, conversions are not discussed in connection with the problem of side effects and no complexity result is offered. In <ref type="bibr" target="#b18">[19]</ref>, too, conflicts are simply modelled via the standard superiority relation. However, some preliminary discussion on the side-effect problem is developed and complexity results about the logic and social agents are sketched. Hence, the present article directly extends the analysis of <ref type="bibr" target="#b18">[19]</ref>: it offers a more comprehensive discussion on intentional side effects and conversions, adopts a different and more general method for dealing with conflicts, proposes full proofs for complexity results, and suggests hints about how the problem of social agents also concerns other agent types.</p><p>Reasoning about mental attitudes is a central issue in philosophy and AI. Despite the plethora of proposals devoted to this topic, the related work that is directly relevant for this paper is mainly the BOID architecture. In fact, the basic calculation scheme used in BOID <ref type="bibr" target="#b7">[8]</ref> is similar to the one proposed in this paper: as done in BOID, we distinguish conflicts between rules for the same modality and for different modalities. In the second case, the relation Conflict(X, Y ) assumes that X rules are always stronger than Y 's.</p><p>The BOID framework has four components representing respectively the beliefs (B), obligations (O), intentions (I) and desires (D) of the agent. The behaviour of each component is specified by sets of propositional logical formulas often in the form of defeasible rules. BOID identifies two general types of conflicts that could arise either within each component (internal conflicts) or between the components (external conflicts). These two types of general conflicts are further subdivided into different subtypes which gives rise to several possible conflicts among the mental attitudes. In order to solve possible conflicts among the attitudes an ordering function (ρ) is defined on rules based on the agent type. An agent type is determined by allowing one component to overrule others. For example, a realistic agent type can be defined by having an ordering in which the belief component overrules any other component (BOID, BODI, BDIO etc.). This means that in BOID a conflict resolution type is an order of overruling and in general the order of derivation can be used to identify different types of agents. Agent types like simple-minded (agent type where prior intentions overrule desires and obligations), social (agent type where obligations overrule desires) etc. could be defined in a similar manner. Formally an agent type is defined as a function, ρ that assigns a unique integer to each rule. It should be noted that the ordering function ρ assigns unique values to the rules of all components such that the values of all rules from one component are either smaller or greater than the values of all rules from another component.</p><p>Besides the specific result discussed in Sect. 5.3, the general aspects that differentiate the current framework from BOID's are the following:</p><p>• our proof conditions permit to derive modalised literals; accordingly, in addition to labelling rules by the elements of MOD, modalities are also made explicit in rule antecedents, thus enriching the expressive power of the logic; • conversions are introduced to capture some fundamental reasoning patterns which, in most cases, should be admitted or which may in any case contribute to characterise agent types; • we admit that Conflict may cover only some modalities; this makes it possible that, for any rule types X and Y that are not covered by Conflict, we can obtain +∂ X p and +∂ Y ∼ p; • our logic for BIO agents has linear complexity, whereas to our knowledge there is no analogous result for BOID.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Summary</head><p>In conclusion, let us summarise step by step the aims and results of this article. Our preliminary step was to describe agent's deliberation by considering her policy-based motivations, which are triggered by potentially recurring circumstances in agent's life. In particular, we extended Bratman's model of policy-based intentions to also cover beliefs and obligations. It turned out that this type of motivations are easily captured by a rule-based approach to cognitive agents.</p><p>Secondly, on account of this definition of motivations, we discussed some aspects of the so-called side-effect problem. In contrast with the idea that side effects are never intended, we argued that there are conceptual reasons for arguing that some side effects should be intended, at least according a realistic model of agent's rationality. We maintained that the inclusion of some side-effects in the intentional sphere of agents does not endanger the logical analysis but, on the contrary, is beneficial to explain notions, such as intentionality and responsibility, of paramount importance for agents situated in normative and legal contexts.</p><p>Thirdly, the logical framework has been presented. Before providing a rigorous definition of the formal language and proof conditions, we informally introduced the concept of rule conversion, according to which we can derive some motivations by using rules devised for inferring different motivations. In addition, we discussed methods for dealing with rule conflicts. An intermediate summary was provided to outline our logical intuitions and match them with the conceptual issues regarding the side-effect problem. We argued that conversions are a natural way to include or exclude side effects.</p><p>Fourthly, we illustrated the notion of agent type. Classically, agent types are characterised by stating conflict resolution types in terms of orders of overruling between rules. For example, an agent is realistic when rules for beliefs override all other components; she is social when obligations are stronger than the other motivational components with the exception of beliefs. We argued that agent types are not only useful in devising mechanisms for solving conflicts, but are of theoretical interest, as they define the cognitive profile of agents. We focused in particular on social agents.</p><p>Fifthly, we investigated the computational properties of our logical framework. First of all, we showed the computational feasibility of the logic: we have demonstrated that it has linear complexity. As far as we know this is the first result of this kind for cognitive agents. We then moved to critically examining the concept of social agent, but we argued that our considerations can be easily applied to the other agent types: in fact, the analysis was mainly formal and independent of what motivational factors (such as intentions and obligations) are considered. In particular, we proved that the classical notion of agent type is not satisfactory: in presence of conversions, which seem necessary to deal with the side-effect problem, conflict resolutions cannot be limited to examining pairs of rules having complementary literals in their heads, but we need to consider all possible reasoning chains supporting conclusions. This problem turned out to be very expensive from the computational point of view. Again, this is the first result of this kind we are aware of. In addition, although we showed that this difficulty formally holds for DL only, we also argued that similar problems affect any rulebased defeasible formalism which incorporates conversions or analogous inferential mechanisms.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Example 2</head><label>2</label><figDesc>The rule a, INTb ⇒ BEL c is applicable if we can prove both +∂ BEL a and +∂ INT b.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Definition 12</head><label>12</label><figDesc>Let # be one of the proof tags. Two modal defeasible theories D 1 and D 2 are equivalent (written D 1 ≡ D 2 ) iff ∀ p, D 1 # p iff D 2 # p, i.e., they have the same consequences. Similarly D 1 ≡ D 2 means that D 1 and D 2 have the same consequences in the language . Definition 13 A transformation is a mapping from modal defeasible theories to modal defeasible theories. A transformation T is correct iff for all modal defeasible theories D, D ≡ T (D) where is the language of D. Definition 14 Let A = {l 1 , . . . , l n } ⊆ Lit and X ∈ MOD, then X A = {Xl i : l i ∈ A}. Definition 15 Let D = (F, R, &gt;) be a defeasible theory such that R d f t = ∅. Let be the language of D. Define elimsup(D) = (F, R , ∅), where R = {¬in f (r ) ⇒ BEL in f (s) : (r, s) ∈&gt;} r ∈R elimsup(r ) and elimsup(r</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Definition 16</head><label>16</label><figDesc>Let D = (F, R, &gt;) be a modal defeasible theory, and be the language of D. Define elimdft = (F, R , &gt; ) where R = r ∈R elimdft(r ) and elimdft(r</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Example 7</head><label>7</label><figDesc>Given a theory D as followsF = {INTa, INTb} R BEL = {r 1 : INTa ⇒ BEL d, r 2 : INTb ⇒ BEL d,r 3 : INTc ⇒ BEL ∼d, r 4 : d ⇒ BEL e} R INT = {r 5 : ⇒ INT a, r 6 ⇒ INT b}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>classical theory of normative actions. Von Wright's problem is to identify what should be the content of norms. He argues that norms should deal with actions.</figDesc><table><row><cell>Roughly, actions can be described in terms of state transitions and as the sets of all changes</cell></row><row><cell>of world that follow from them. It is not our purpose discussing here von Wright's theory</cell></row><row><cell>of action. It should be noted, however, that he considers the related problem of intentions.</cell></row><row><cell>On the one hand, von Wright is clear when he says that any action may have an arbitrary</cell></row><row><cell>number of consequences and not all of them are intended. On the other hand, he provides a</cell></row><row><cell>very broad concept of action, according to which all actions in norms, strictly speaking, are</cell></row><row><cell>intentional. If so, what are the boundaries of intentions to be considered when they interplay</cell></row><row><cell>with obligations?</cell></row><row><cell>Let us see how to recast Bratman's Strategic Bomber scenario</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1</head><label>1</label><figDesc>Conflict: agent types</figDesc><table /><note><p>⇒ OBL p / ⇒ INT ∼ p ⇒ OBL p / ⇒ BEL ∼ p ⇒ INT p / ⇒ BEL ∼ p +∂ OBL p +∂ INT ∼ p indep. +∂ OBL p +∂ BEL ∼ p wish. th. +∂ INT p +∂ BEL ∼ p wish. th. +∂ OBL p -∂ INT ∼ p social +∂ OBL p -∂ BEL ∼ p wish. th. +∂ INT p -∂ BEL p wish. th. -∂ OBL p +∂ INT ∼ p deviant -∂ OBL p +∂ BEL ∼ p real. -∂ INT p +∂ BEL ∼ p real.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2</head><label>2</label><figDesc></figDesc><table><row><cell>Conversions</cell><cell cols="3">Convert(BEL, OBL) c-realistic Convert(INT, OBL) c-deviant</cell></row><row><cell></cell><cell>Convert(BEL, INT)</cell><cell cols="2">c-realistic Convert(OBL, BEL) NO</cell></row><row><cell></cell><cell cols="2">Convert(OBL, INT) c-social</cell><cell>Convert(INT, BEL)</cell><cell>NO</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>We will drop set notation for the antecedents of rules.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>Notice that a strict rule can be defeated only when its antecedent is defeasibly provable.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>Here we will ignore all temporal aspects and we will assume that the sequence of actions is done in the correct order.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_3"><p>As is well-known, in a non-reflexive modal logic a does not follow from Xa, where X is a modal operator.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_4"><p>However, notice that it does not seem hard to extend the framework of Sects. 3.4 and 3.5 to cover nested modalities. It is sufficient to modify some language definitions, revise the definition of conflict, and make a few changes in the proof conditions. For a treatment in DL of nested modalities, even though applied to the logic of agency, see<ref type="bibr" target="#b17">[18]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_5"><p>This algorithm outputs ∂ + ; ∂ -can be computed by an algorithm similar to this with the "dual actions". For + we have just to consider similar constructions where we examine only the first parts of step 1 and 2. - follows from + by taking the dual actions.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments Antonino Rotolo was supported by the European project for Standardized Transparent Representations in order to Extend Legal Accessibility (ESTRELLA, IST-4-027655).</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>R OBL = {r 7 : ⇒ OBL ∼e} &gt; = {r 3 &gt; r 1 , r 3 &gt; r 2 , r 4 &gt; r 7 }</p><p>As we have seen in the previous example, throwing away the two primitive intentions is of no avail, since they are reinstated by the intention rules r 5 and r 6 . However, to block the side effect d of the two intentions we can introduce a further primitive intention, INTc.</p><p>If we replace the theory D by a theory D obtained from D by emptying the set of intention rules, then we have two alternatives to avoid the deviance. The first is to drop both the primitive intentions INTa and INTb, or we can form a new primitive intention INTc. In this case the theory obtained from adding the new intention is, intuitively, more similar to the original theory than the theory obtained from dropping the two primitive intentions.</p><p>Variations of the problem can be obtained by changing other parameters of the specification. Some of these can define new types of agents. For example a pro-active social agent might try to recover from a deviant situation by changing the raw facts (facts that are neither primitive intentions nor primitive obligations). Thus a pro-active social agent tries to adapt the environment to her goals (intentions). A legalistic social agent, on other the hand, might change the set of primitive obligations, while a cheating social agent might change the rules. However, it is important to realise that all these variations have a structure isomorphic to the specification we discuss in this paper. In addition it is possible to generalise the problem to the case of multiple deviant behaviours.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 4 The Restoring Sociality Problem is NP-complete.</head><p>Proof We have to show that the problem is both NP and NP-hard. For the NP part all we have to do is to notice that we can guess a theory, we compute the extension of the theory in linear time (Theorem 1) and then verify in linear time whether the restore conditions are satisfied.</p><p>For the NP-hard part we have to map a known NP-complete problem to the Restoring Sociality Problem. Here we use the knapsack problem <ref type="bibr" target="#b13">[14,</ref><ref type="bibr">Problem MP9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Knapsack problem</head><p>Instance: Given a finite set U , for each u ∈ U a size s(u) ∈ Z + and a value v(u) ∈ Z + , and integer B and K . Question: Is there a subset U ⊆ U such that u∈U s(u) ≤ B and u∈U v(u) ≥ K ?</p><p>The knapsack problem is encoded by a defeasible theory D where R is as follows:</p><p>The theory of the above construction has several interesting properties. First of all D +∂ BEL load(u) iff INTload(u) ∈ F, which means u ∈ U ; then D +∂ OBL good iff either of the two conditions of the knapsack problem are satisfied; notice that since there are no</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Intention and intentional action: The simple view</title>
		<author>
			<persName><forename type="first">F</forename><surname>Adams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mind and Language</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="281" to="301" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A flexible framework for defeasible logics</title>
		<author>
			<persName><forename type="first">G</forename><surname>Antoniou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Billington</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Governatori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Maher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of American National Conference on Artificial Intelligence (AAAI-2000</title>
		<meeting>American National Conference on Artificial Intelligence (AAAI-2000<address><addrLine>Menlo Park, CA</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI/MIT Press</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="401" to="405" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Representation results for defeasible logic</title>
		<author>
			<persName><forename type="first">G</forename><surname>Antoniou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Billington</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Governatori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Maher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computational Logic</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="255" to="287" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">2nd Workshop on Principles and Practice of Semantic Web Reasoning</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bassiliades</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Antoniou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Vlahavas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Ohlbach</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Schaffert</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">3208</biblScope>
			<biblScope unit="page" from="134" to="148" />
			<date type="published" when="2004">2004</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>DR-DEVICE: A defeasible logic system for the Semantic Web</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Defeasible logic is stable</title>
		<author>
			<persName><forename type="first">D</forename><surname>Billington</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic and Computation</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="379" to="400" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Plans and resource-bounded practical reasoning</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Bratman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Israel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Pollack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Intelligence</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="349" to="355" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Intentions, plans and practical reason</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Bratman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
			<publisher>Harvard University Press</publisher>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Goal generation in the BOID architecture</title>
		<author>
			<persName><forename type="first">J</forename><surname>Broersen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dastani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hulstijn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Van Der Torre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cognitive Science Quarterly</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="428" to="447" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Intention is choice with commitment</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Levesque</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="213" to="261" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Preferences of agents in defeasible logic</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dastani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Governatori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rotolo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Van Der Torre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Australian AI05</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Zhang</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Jarvis</surname></persName>
		</editor>
		<meeting>Australian AI05</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3809</biblScope>
			<biblScope unit="page" from="695" to="704" />
		</imprint>
		<respStmt>
			<orgName>LNAI</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Programming cognitive agents in defeasible logic</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dastani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Governatori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rotolo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Van Der Torre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings LPAR 2005</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Sutcliffe</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</editor>
		<meeting>LPAR 2005</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3835</biblScope>
			<biblScope unit="page" from="621" to="636" />
		</imprint>
		<respStmt>
			<orgName>LNAI</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Autonomous agents with norms</title>
		<author>
			<persName><forename type="first">F</forename><surname>Dignum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence and Law</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="69" to="79" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Towards socially sophisticated BDI agents</title>
		<author>
			<persName><forename type="first">F</forename><surname>Dignum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Morley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Sonenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cavedon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICMAS 4th International Conference on Multi-Agent Systems</title>
		<meeting>ICMAS 4th International Conference on Multi-Agent Systems<address><addrLine>Boston</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="111" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Computers and intractability: A guide to the theory of NP-completeness</title>
		<author>
			<persName><forename type="first">M</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Johnson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<publisher>W. H. Freeman and Company</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Modal logic and philosophy</title>
		<author>
			<persName><forename type="first">R</forename><surname>Girle</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<pubPlace>Acumen, Teddington</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A defeasible logic of policy-based intention</title>
		<author>
			<persName><forename type="first">G</forename><surname>Governatori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Padmanabhan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of AI 2003</title>
		<meeting>AI 2003</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Defeasible logic: Agency, intention and obligation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Governatori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rotolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Deontic logic in computer science, number 3065 in LNAI</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Lomuscio</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Nute</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="114" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A computational framework for institutional agency</title>
		<author>
			<persName><forename type="first">G</forename><surname>Governatori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rotolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence and Law. (Forthcoming)</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The cost of social agents</title>
		<author>
			<persName><forename type="first">G</forename><surname>Governatori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rotolo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Padmanabhan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">5th International Conference on Autonomous Agents and Multi-Agent Systems (AAMAS06)</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="513" to="520" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Modeling conversation policies using permissions and obligations</title>
		<author>
			<persName><forename type="first">L</forename><surname>Kagal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Finin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Autonomous Agents and Multi-Agent Systems</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="187" to="206" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Intentional action and side effects in ordinary language</title>
		<author>
			<persName><forename type="first">J</forename><surname>Knobe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Analysis</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="page" from="190" to="193" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Nonmonotonic reasoning, preferential models and cumulative logics</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lehmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Magidor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="167" to="207" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Propositional defeasible logic has linear complexity</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Maher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory and Practice of Logic Programming</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="691" to="711" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Efficient defeasible reasoning systems</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Maher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Antoniou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Billignton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Artificial Intelligence Tools</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="483" to="501" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Rationality and the range of intention</title>
		<author>
			<persName><forename type="first">H</forename><surname>Mccann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Midwest Studies in Philosophy</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="191" to="211" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Intention, intentional action, and moral responsibility</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sverdlik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Philosophical Studies</title>
		<imprint>
			<biblScope unit="volume">82</biblScope>
			<biblScope unit="page" from="265" to="287" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Defeasible reasoning</title>
		<author>
			<persName><forename type="first">D</forename><surname>Nute</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 20th Hawaii International Conference on System Science</title>
		<meeting>20th Hawaii International Conference on System Science</meeting>
		<imprint>
			<publisher>IEEE press</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="470" to="477" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Defeasible logic</title>
		<author>
			<persName><forename type="first">D</forename><surname>Nute</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of logic in artificial intelligence and logic programming</title>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="353" to="395" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Defeasible deontic logic</title>
		<author>
			<persName><forename type="first">D</forename><surname>Nute</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Kluwer</publisher>
			<pubPlace>Dordrecht</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Norms, priorities, and defeasible logic</title>
		<author>
			<persName><forename type="first">D</forename><surname>Nute</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Norms, ogics and information system</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Mcnamara</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Prakken</surname></persName>
		</editor>
		<meeting><address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>IOS Press</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="201" to="218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m">Open agent societies</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Pitt</surname></persName>
		</editor>
		<meeting><address><addrLine>Chichester</addrLine></address></meeting>
		<imprint>
			<publisher>Wiley</publisher>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Modelling rational agents within a BDI-architecture</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Georgeff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;91</title>
		<meeting>the Second International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;91</meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="473" to="484" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Legal reasoning: A cognitive approach to the law</title>
		<author>
			<persName><forename type="first">G</forename><surname>Sartor</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>Springer</publisher>
			<pubPlace>Dordrecht</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Intentionality</title>
		<author>
			<persName><forename type="first">J</forename><surname>Searle</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983">1983</date>
			<publisher>Cambridge University Press</publisher>
			<pubPlace>Cambridge</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Desires and defaults: A framework for planning with inferred goals</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Thomason</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KR2000</title>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Cohn</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Giunchiglia</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Selman</surname></persName>
		</editor>
		<meeting><address><addrLine>San Francisco</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">H</forename><surname>Von Wright</surname></persName>
		</author>
		<title level="m">Norm and action</title>
		<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<publisher>Routledge</publisher>
			<date type="published" when="1963">1963</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
