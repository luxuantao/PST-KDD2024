<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">MASON: A Multiagent Simulation Environment</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Sean</forename><surname>Luke</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Center for Social Complexity George Mason University</orgName>
								<address>
									<addrLine>4400 University Drive</addrLine>
									<postCode>22030</postCode>
									<settlement>Fairfax</settlement>
									<region>VA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Claudio</forename><surname>Cioffi-Revilla</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Center for Social Complexity George Mason University</orgName>
								<address>
									<addrLine>4400 University Drive</addrLine>
									<postCode>22030</postCode>
									<settlement>Fairfax</settlement>
									<region>VA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Liviu</forename><surname>Panait</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Center for Social Complexity George Mason University</orgName>
								<address>
									<addrLine>4400 University Drive</addrLine>
									<postCode>22030</postCode>
									<settlement>Fairfax</settlement>
									<region>VA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Keith</forename><surname>Sullivan</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Center for Social Complexity George Mason University</orgName>
								<address>
									<addrLine>4400 University Drive</addrLine>
									<postCode>22030</postCode>
									<settlement>Fairfax</settlement>
									<region>VA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Gabriel</forename><surname>Balan</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Center for Social Complexity George Mason University</orgName>
								<address>
									<addrLine>4400 University Drive</addrLine>
									<postCode>22030</postCode>
									<settlement>Fairfax</settlement>
									<region>VA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">MASON: A Multiagent Simulation Environment</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">735426FD01EE553B48177F6BA1E5A98A</idno>
					<idno type="DOI">10.1177/0037549705058073</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:59+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Agent-based modeling</term>
					<term>simulation</term>
					<term>multi-agent systems</term>
					<term>computational social science</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>MASON is a fast, easily extensible, discrete-event multi-agent simulation toolkit in Java, designed to serve as the basis for a wide range of multi-agent simulation tasks ranging from swarm robotics to machine learning to social complexity environments. MASON carefully delineates between model and visualization, allowing models to be dynamically detached from or attached to visualizers, and to change platforms mid-run. This paper describes the MASON system, its motivation, and its basic architectural design. It then compares MASON to related multi-agent libraries in the public domain, and discusses six applications of the system built over the past year which suggest its breadth of utility.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>MASON is a single-process, discrete event simulation core and visualization library written in Java, designed to be flexible enough to be used for a wide range of simple simulations, but with a special emphasis on swarm multiagent simulations of many agents (up to millions). We developed the MASON simulation toolkit to meet the needs of computationally demanding "swarm"-style multiagent systems (MAS) research. The system is open-source and free and is a joint effort of George Mason University's Computer Science Department and the George Mason University Center for Social Complexity. MASON may be downloaded at http://cs.gmu.edu/∼eclab/projects/mason/.</p><p>Multiagent systems are receiving increasing research attention as affordable computer brawn makes simulation of these environments more feasible. One source of interest has come from social and biological models, notably ones in economics, land use, politics, and population dynamics (e.g., <ref type="bibr" target="#b1">[1]</ref><ref type="bibr" target="#b2">[2]</ref><ref type="bibr" target="#b3">[3]</ref>). Another source stems from the swarm robotics community, particularly as homeland security and defense interests have bolstered investigations of large numbers of "U * Vs" (unmanned aerial vehicles, unmanned underwater vehicles, etc.) for collaborative target observation, reconnaissance, mapping, and so on <ref type="bibr" target="#b4">[4]</ref><ref type="bibr" target="#b5">[5]</ref><ref type="bibr" target="#b6">[6]</ref><ref type="bibr">[7]</ref>. Swarm multiagent simulation is also a common technology in the game and movie industries.</p><p>MASON was built from first principles to serve the needs of these research areas. Our design philosophy was to build a fast, orthogonal, minimal model library to which an experienced Java programmer could easily add features, rather than one with many domain-specific, intertwined features that are difficult to remove or modify. To this minimal model we have added those visualization and graphical user interface (GUI) facilities we have found useful for various simulation tasks.</p><p>We began work on MASON because we needed a simulation toolkit that made it relatively easy for us to create a very wide range of multiagent and other simulation models and to run many such models efficiently in parallel on back-end cluster machines. Domains to which we intended to apply the simulator ran the gamut from robotics and machine learning to multiagent models of social systems (political science, historical development, land use, economics, etc.). Our previous research in these areas had either relied on a heavily modified robotics simulator (notably TeamBots <ref type="bibr" target="#b8">[8]</ref>); a compiled social complexity toolkit such as SWARM <ref type="bibr" target="#b9">[9]</ref>, Ascape <ref type="bibr" target="#b10">[10]</ref>, or RePast <ref type="bibr" target="#b11">[11]</ref>; or an interpreted rapid-development library such as StarLogo <ref type="bibr" target="#b12">[12]</ref>, NetLogo <ref type="bibr" target="#b13">[13]</ref>, or Breve <ref type="bibr" target="#b14">[14]</ref>.</p><p>We needed to run many (&gt;100,000) simulation runs to optimize model parameters or perform machine learning in a multiagent problem domain. In such cases, we had to "cook" the simulations on multiple back-end servers (in Linux, Solaris, and MacOS X) while occasionally viewing the results on a front-end MacOS X or Windows workstation. This required speed, the ability to migrate a simulation run from platform to platform, and (for our purposes) guaranteed platform independence. Furthermore, we needed to be able to customize the simulator to different multiagent simulation problems and applications. The aforementioned systems did not meet these needs well because they tied the model to the GUI too closely, could not guarantee platform-independent results, or, being written in an interpreted language, were slow. In addition, several such systems, particularly the robotics simulators, were by and large geared to a particular problem domain. Rather than remove special-purpose code from an existing system (potentially introducing bugs), we instead hoped to build on top of a more general-purpose simulator.</p><p>Given these research needs, MASON's design goals were as follows:</p><p>• A small, fast, easily understood, and easily modified core • Separate, extensible visualization in 2D and 3D • Production of identical results independent of platform • Checkpointing any model to disk such that it can be resumed on any platform with or without visualization • Efficient support for up to a million agents without visualization • Efficient support for as many agents as possible under visualization (limited by memory) • Easy embedding into larger existing libraries, including having multiple instantiations of the system coexisting in memory There were three design goals we explicitly did not make for MASON. First, we did not intend to include parallelization of a single simulation across multiple networked processors. Such an architecture is radically different from a single-process architecture. Second, we intended the MASON core to be simple and small and so did not provide built-in features special to social agents or robotics simulators. We felt such things were more appropriately offered as optional domain-specific modules in the future. Third, although we tried to be reasonably memory efficient, this was not a priority.</p><p>We recognize that speed, model detachment, checkpointing and portability, and strong visualization are all common in the simulation community at large. However in the "swarm"-style simulation community, MASON's combination of architecture and these features is essentially unique. In this article, we discuss the architectural design of the system and then detail six applications of MASON presently under way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Architecture</head><p>MASON is written in Java to take advantage of its portability, strict math and type definitions (to guarantee duplicable results), and object serialization (to checkpoint out simulations). Java has an undeserved reputation for slowness, and our past experience in developing the ECJ evolutionary computation toolkit <ref type="bibr" target="#b15">[15]</ref> suggests that carefully written Java code can be surprisingly fast.</p><p>The toolkit is written in three layers: the utility layer, the model layer, and the visualization layer. The utility layer consists of classes that may be used for any purpose. These include a random-number generator, data structures more efficient than those provided in the Java distribution, various GUI widgets, and movie-and snapshot-generating facilities. Next comes the model layer, a small collection of classes consisting of a discrete event schedule, schedule utilities, and a variety of fields that hold objects and associate them with locations. This code alone is sufficient to write basic simulations running on the command line.</p><p>The visualization layer permits GUI-based visualization and manipulation of the model. Figure <ref type="figure">1</ref> shows a simplified diagram relating basic objects in the model and visualization layers. For most elements in the model layer, down to individual fine-grained objects in the model, there is an equivalent "proxy" element in the visualization layer responsible for manipulating the model object, portraying it on-screen, and inspecting its contents. A bright line separates the model layer from the visualization layer, which allows us to treat the model as a self-contained entity. We may at any time separate the model from the visualization, checkpoint the model to disk, move it to a different platform and let it continue to run, or attach an entirely different visualization collection. Figure <ref type="figure">2</ref> shows this procedure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The Model Layer</head><p>MASON's model layer has no dependencies on the visualization layer and can be separated from it. A MA-SON model is entirely contained within a single instance of a user-defined subclass of MASON's model class (SimState). This instance contains a discrete event Schedule, a MersenneTwister random-number generator, and zero or more fields.</p><p>Agents and the Schedule. MASON employs a specific usage of the term agent: a computational entity that may be scheduled to perform some action and that can manipulate the environment. Note that we do not explicitly state that the agent is physically in the environment, though it may be; in this case, we would refer to the agent as an embodied agent. Agents are brains which may or not be embodied. MASON does not schedule events to send to an agent; rather, it schedules the agent itself to be stepped (pulsed or called) at some time in the future. Hence, MASON's agents implement the Steppable interface, as shown in Figure <ref type="figure">1</ref>. Scheduling an agent multiple times for different functions is easily done with an anonymous wrapper class.</p><p>MASON can schedule Steppable objects to occur at any real-valued time in the future. Furthermore, the Schedule may be divided into multiple orderings that further subdivide a given time step: agents scheduled at a given time but in an earlier ordering will be stepped prior to agents scheduled at the same time but in a later ordering. MASON also provides various Steppable wrappers that can group agents together, iterate them, perform them in parallel on separate threads, and so on. Agents may be scheduled to run in their own thread asynchronous with the schedule. This thread may run until completion, loop indefinitely, or run until the Schedule reaches some later time step.</p><p>Fields. MASON's fields relate arbitrary objects or values with locations in some notional space. Some of these fields are little more than wrappers for simple 2D or 3D arrays. Others provide sparse relationships. An object may exist in multiple fields at one time, and in some fields, the same object may appear multiple times. The use of fields is entirely optional, and the user may add additional fields of his or her own devising. MASON provides fields for the following:</p><p>• 2D and 3D bounded arrays of objects, integers, or doubles that may be bounded or toroidal and with hexagonal, triangular, or square layouts • 2D and 3D sparsely populated object grids that are bounded, unbounded, or toroidal and with hexagonal, triangular, or square layouts • 2D and 3D sparse continuous (real-valued) space, that may be bounded, unbounded, or toroidal • Networks (graphs), whose edges may be directed or undirected and optionally weighted or labeled</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>When running the model without visualization, MASON has an intentionally primitive top-level simulation loop. MASON begins by either creating a new</head><p>SimState or loading one from a Java-serialized checkpoint file. MASON then enters the following loop. First, it checks to see if the Schedule has any agents remaining to step. If not, or if some maximum time step has been exceeded, MASON exits the loop, finishes the SimState, and quits. Otherwise, the Schedule advances the time to the minimum agent-scheduled time step, then steps all agents scheduled at that time (sorted by ordering and shuffled randomly within an ordering). If a checkpoint is desired (typically every so many Schedule steps), it is done so at this time: asynchronous agents are first requested to pause their threads, then a checkpoint of the entire model is written out, then asynchronous agents resume their threads, and the loop continues.</p><p>Agents have full access to the SimState and may manipulate its fields, Schedule, and random-number generator. MASON imposes few restrictions on the actions they may perform and provides no simplifying protocols for agent design. For example, MASON does not provide a rule language for stipulating agent behaviors. We imagine such things can be included in forthcoming MASON module extensions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">The Visualization Layer</head><p>Objects in the visualization layer may examine modellayer objects only with the permission of a gatekeeper wrapper around the SimState, called a GUIState. When running with a GUI, it is this class that is responsible for attaching the SimState to visualization (or detaching it) and for checkpointing the SimState to or from disk. As certain objects in the visualization world need to be scheduled (notably, windows need to be refreshed to reflect changes in the model), such elements may "schedule" themselves with the GUIState to be updated whenever the underlying Schedule is pulsed but not be scheduled on the Schedule itself. This allows the visualization layer to be separate from the model.</p><p>In addition to the SimState, the GUIState also maintains zero or more displays, GUI windows that provide 2D and 3D views of underlying fields. Displays operate by holding zero or more field portrayals, associating each one with a different field in the model. Each field portrayal is responsible for drawing the field on-screen and for responding to user requests to inspect features of the field. Field portrayals do this by associating simple portrayals with individual objects or values stored in the fields. A field portrayal may associate a simple portrayal with a specific object stored in the field, with a class of objects, with all objects in the field, and so on. The user may choose from a number of provided simple portrayals, the user may design the simple portrayal himself, or the object may portray itself instead. Some examples of visualized fields are shown in Figure <ref type="figure" target="#fig_1">3</ref>. Simple portrayals can also, on request, call up inspectors (what SWARM would call "probes") of underlying model objects. Inspectors are GUI panels that allow the user to inspect or modify object parameters. The user can provide custom inspectors for objects or use the basic ones provided (which use Java's Bean Properties facility). Models and fields may also have inspectors. Drawing and inspection follow similar paths: when a display is redrawn, it asks each of its field portrayals to redraw their fields, and in turn, the field portrayals call up simple portrayals to draw elements in the field. Likewise, when a user clicks on a display to request inspection of objects, the display asks the field portrayals to provide inspectors for these objects, and the field portrayals in turn call up the relevant simple portrayals and ask them to provide the inspectors.</p><p>The GUIState also contains a top-level controller GUI window, usually the provided Console. The Console's is to allow the user to start/stop/pause/step the Schedule, but it also provides the GUI functionality to load and save checkpointed models, to show and hide displays, to view inspectors, and to load additional simulations (each with their own SimStates, GUIStates, and Consoles).</p><p>Running the model under visualization is a more involved process than without visualization, and not just because things must now be displayed. The underlying model runs in its own thread separate from the GUI's main thread. Since both the model thread and the GUI thread must have access to underlying model data, they enter into a synchronization procedure that guarantees that only one is operating on these data at any given time. The general procedure is as follows. When a GUIState is constructed, it creates a Console, various displays, and the underlying SimState. When the user presses "play" in the Con sole to start a simulation, the Console starts the SimState, then spawns the model thread. The model thread enters into a loop that it exits only if asked to shut down by the Console or if no further agents are scheduled. In this loop, the GUIState performs any pre-schedule items, then the Schedule advances to the minimum agent-scheduled time and steps any agents at that time, then postschedule items are performed (typically requests to redraw the displays), and finally the thread defers to the GUI thread to give it access to the model before finishing the loop. While the model thread is waiting, the GUI thread can finish redrawing the displays, complete any requests made by the user to inspect the model, and checkpoint out the model (or read a new one in from checkpoint to replace it). When the user presses "stop," the thread is asked to shut down, and the Console finishes the SimState. When the Console is closed, the GUIState, SimState, and displays are destroyed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">MASON Usage and Extensions</head><p>Because of the separation of the model from visualization, MASON models are usually created in two stages (refer again to Figure <ref type="figure">1</ref>). First, the author develops the model proper as a self-contained subclass of SimState. After this code is completed, the MASON model should be able to run on the command line as a GUI-less application. Next, the author creates a GUIState to encapsulate the Sim State, attaching portrayals and displays. At this point, the simulation can be visualized. The author can create further GUIStates to visualize the SimState in different ways. A GUIState can also be used in combination with a special class, SimApplet, to generate online MASON applets. MASON comes with several tutorial and example applications to show how these are done.</p><p>The basic MASON distribution provides only those core tools common to most simulation and visualization needs. We have several extensions to MASON available or in development, each of which is distributed as a separate module or online tutorial: As MASON development continues, we expect further extensions as well, depending on research Possible future directions include OpenGL visualization (in addition to MASON's presently used Java3D), high-level interpreted agent development tools, packet network simulation, and a Geographic Information Systems (GIS) library.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Comparison to Other Simulation Environments</head><p>MASON's original inspiration came from a desire to reimplement more cleanly some of the problem domains we had constructed in the Teambots <ref type="bibr" target="#b8">[8]</ref> simulator. Teambots is an early Java-based lightweight robotics simulation environment that provides minimal physics and robot sensor facilities, a graphic display, and a very simple schedule procedure. Teambots is useful for behavior-based robotics experiments, though its lack of a real physics model is a hindrance. Teambots also makes a hard distinction between the objects in the world (including the robots) and the agents that drive some of them (such as the robot software). MASON's similar distinction was inspired by this. Teambots makes this delineation because this design allows the experimenter to port software robot behaviors to real robots using provided real-robot application protocol interfaces (APIs). A more recent family of simulators, called Player/Stage <ref type="bibr" target="#b18">[19]</ref>, has moved toward more realistic robots and environments.</p><p>The robotics simulators discussed above are capable but understandably geared to a very specific problem set. We found that implementing nonrobotics multiagent simulations in these simulators involved considerable modifications of the simulators to provide extra-robot functionality or to remove unneeded functionality that would otherwise slow the experiment. Such modifications had a strong likelihood of introducing bugs, particularly given the size and complexity of these simulators.</p><p>Compiled Multiagent Simulators. Instead we chose to construct MASON to be usable for a broad scope of lightweight simulation functions, with a general-purpose schedule and fields. In this vein, MASON is most closely comparable to compiled multiagent simulation libraries such as SWARM <ref type="bibr" target="#b9">[9]</ref>, Ascape <ref type="bibr" target="#b10">[10]</ref>, and RePast <ref type="bibr" target="#b11">[11]</ref>. SWARM is the earliest such system and originally required the user to write in Objective-C and Tcl/Tk. SWARM applications may now be written in Java using special libraries that communicate with Objective-C. Oddly, SWARM does not take advantage of by far the foremost Objective-C system: the OpenStep GUI specification embodied in MacOS X and the open-source GNUstep library. We believe the use of an unusual language but not its primary environment has proven a challenge to SWARM's continued extensibility and maintainability.</p><p>To remedy this, RePast was envisioned to reimplement much of the SWARM philosophy entirely in Java or .NET, and it has been the center of considerable community interest in recent years. The RePast distribution has a large footprint: included in the package are neural networks, genetic algorithms, social network modeling, system dynamics modeling, logging, GIS, and graphs and charts.</p><p>Ascape is a multiagent simulation toolkit inspired by the Sugarscape model <ref type="bibr" target="#b2">[2]</ref>. Ascape tries to be as rule oriented as possible within a Java framework: agents have rule-based behaviors that fire based on specific environmental conditions, and these agents are grouped into larger structures that have their own behaviors and fire their subsidiary agents in a user-specified order. This framework simplifies model development in some cases, but it also imposes considerable constraints on simulation design as a whole, particularly on simulations requiring arbitrary event handling.</p><p>Like MASON, these three multiagent system toolkits all provide graphical visualization, inspection of simulation objects, stochastic event ordering, and the generation of various forms of media. But there are some important differences. Stemming from its design goal as a generalpurpose agent simulation environment, MASON provides 3D fields, visualization of both 2D and 3D fields in 3D, and somewhat more sophisticated and flexible 2D visualization. MASON is also somewhat faster than the toolkits described above both in underlying model and in visualization, and it is expressly designed to produce duplicable results if necessary.</p><p>But most important, MASON is capable of separating the model from visualization dynamically. While some of the above frameworks can run "headless," this is generally an either/or proposition, and furthermore, migration of a headless process from one machine to another is generally not possible, much less visualization of the headless process mid-run (except through analysis of its statistical output). These systems lack these features largely because they were originally designed for single-shot models that the experimenter would construct, run once, and then analyze. MASON instead was designed to be executed a very large number of times on different machines as part of a model optimization procedure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Interpreted Multiagent Simulators.</head><p>Another approach is to build a simulation toolkit in which the user manipulates the world through an interpreted, online programming language such as Logo. By eliminating the compile-run cycle, the experimenter is free to make small changes in the code, even at runtime, to experiment with its effects. This is the design philosophy behind StarLogo <ref type="bibr" target="#b12">[12]</ref> and later NetLogo <ref type="bibr" target="#b13">[13]</ref>. These systems provide basic functionality similar to SWARM but impose a modified version of Logo as the experimenter's model implementation language. A related simulator is Breve <ref type="bibr" target="#b14">[14]</ref>, which provides 2D and 3D worlds with which the user may manipulate objects using the ODE physics engine and a proprietary language called Steve.</p><p>These simulators offer many benefits for rapid prototyping by enabling immediate feedback on code changes, encouraging tweaking of the model mid-run, and (in Breve's case) wrapping a powerful physics environment with a simple, easy-to-learn library. Furthermore, in theory, an interpreted-language design can more easily be ported midrun from platform to platform and to dynamically add and remove visualization tools. The primary downside of these simulators is that, for our purposes, they are slow. The language features that make them so attractive for rapidly building a model also make them less appropriate for complex simulations with long runtimes. In addition, simulations built with these tools tend to be bound by the constraints imposed by their respective graphical interfaces. For example, Breve generally assumes visualization of a single space, and NetLogo constrains simulation tools to fit within a single window.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Applications</head><p>MASON has existed for 2 years at George Mason University, but we have already used it for a number of simulation tasks ranging from micro-air vehicle coordination and virus propagation to models of collective behavior in simple societies. Here we will mention a few of interest. We describe these systems primarily to demonstrate the depth of applicability of MASON. The models shown use a wide range of MASON features, including its square and hexagonal grids, sparse discrete fields, continuous fields, network facilities, 2D and 3D environments, real-valued and discrete schedules, added charts and graphs, and capability to be embedded in a larger external toolkit.</p><p>Four of these simulations-cooperative target observation, ant foraging, urban traffic, and "wetlands"-are computationally intensive and require many runs in batch. It is for such tasks that MASON is particularly well suited. Two simulations-network intrusion and anthrax propagation-were originally written in other simulation packages and were ported to MASON to take advantage of agent inspection features and as tests of porting difficulty.</p><p>Network Intrusion and Countermeasures. Network intrusion is an agent-based model designed to study computer network security issues, first developed inAscape and then ported to MASON by an inexperienced MASON developer to test the difficulty and speed of porting to the new system (with, we felt, very positive results). The current version models a network of 2500 computer systems connected via two overlaid grid topologies: IP address space (or physical space) and remote login space. In these spaces live two kinds of agents: computer systems and one or more hackers. Each computer system has a set of security policies implemented when the system is believed to be compromised. A computer may be classified as secure, threatened (in the sense that a nearby computer has been compromised), compromised at a user level, or compromised at the super-user level. The parameters of the model allow one to understand the effects of changes in security policies as well as the effects of changes in hacker behavior. Figure <ref type="figure">4</ref> shows a snapshot of a simulation. Urban Traffic Simulation. We have developed a lightweight urban traffic simulation in MASON to examine traffic flow from a multiagent perspective and hope to apply derived algorithms to other environments such as packet routing. A small simulation is shown in Figure <ref type="figure">5</ref>. The simulation uses a network field in MASON with intersections as nodes and roads as graph edges. Cars and traffic lights are scheduled using MASON's real-valued time schedule. Cars beginning travel along a road are scheduled to appear at the intersection at the end of the road at some time in the future, depending on road length and car speed. When a car reaches an intersection, it is placed in another queue to wait at the intersection's stoplight. While a light is green, some N waiting cars are allowed through the intersection at a given time step.</p><p>Using this simulation, we are investigating how to maximize both global and per car mean travel time, variance in wait time, and other factors. Of particular interest to us is how the system can adapt to "smooth out" sudden unexpected floods of traffic (after a sporting event ends, for example), in addition to handling regular "rush-hour" style floods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Cooperative Target Observation in Unmanned Aerial</head><p>Vehicles. In recent experiments <ref type="bibr" target="#b19">[20]</ref>, we examined the effectiveness of various algorithms that direct mobile UAV agents (called observers) to collectively stay within an "observation range" of as many randomly moving targets as possible. Observers and targets live in a sparse continuous 2D or 3D field in MASON. The cooperative target observation environment is shown in Figure <ref type="figure" target="#fig_3">6</ref>. We used this environment to examine "tunably decentralized" cooperative algorithms, where by changing a parameter, we could gradually shift the algorithm from one global decision-making procedure to individual per agent procedures. We examined two such algorithms for controlling the observers based on K-means clustering and hill climbing.</p><p>Ant Foraging. We have recently examined how to augment ant-like robot swarm behaviors with pheromones to perform "central place food foraging," in which agents leave a nest to search for food, then return to the nest laden with food. Figure <ref type="figure" target="#fig_4">7</ref> shows a typical 100 × 100 cell environment with 1000 ants, a nest (bottom right), a food source (top left), and two large elliptic obstacles. The ants cooperatively discover and optimize a minimum-length trail. Our experiments in this environment <ref type="bibr" target="#b20">[21]</ref> suggested that pheromones bear a strong resemblance to utility value functions found in dynamic programming and reinforcement learning.</p><p>This environment was implemented using 2D sparse grids and value grids in MASON and is notable in that, in some cases, MASON served as a subsidiary object within the ECJ evolutionary computation system <ref type="bibr" target="#b15">[15]</ref>. This allowed us to use ECJ to optimize ant behaviors: ECJ would iteratively consider a candidate ant behavior, then fire up MASON to test the behavior in simulation and assess its quality. More details on these experiments are reported in Panait and Luke <ref type="bibr" target="#b21">[22]</ref>. Anthrax Propagation in the Human Body. The interaction between pathogens and infected hosts is usually investigated using laboratory and live studies. But for some diseases, such as inhalation anthrax, live studies are not possible due to their deadly effects. After examining laboratory studies, the spread of anthrax in human organs was modeled as a series of discrete events that map out a time course for infection in the human body. Different systems in the human body that play a role in inhalation anthrax were modeled as spatial entities to show how the anthrax disease flows through the body. The dynamics of these interactions was implemented using 2D sparse grids, one per system. The model also displayed statistics on the interactions of the systems and on the patient's health and disease state.</p><p>The anthrax model was developed originally using SWARM in Objective-C but was rewritten in its entirety in MASON to take advantage of MASON's speed and its control and inspection features. The individual performing the port had no previous knowledge of MASON at all but reported that the port was fairly easy as MASON has a similar scheduling mechanism to SWARM. Figure <ref type="figure" target="#fig_5">8</ref> shows before-and-after screenshots showing an anthrax panel as displayed in SWARM and in MASON.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Wetlands: A Model of Memory and Primitive Social</head><p>Behavior. Using the MASON wetlands model <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b23">24]</ref>, we investigated the effect of memory, forgetfulness, and simple hierarchical group organization on the emergent patterns of agent interactions in a primitive human society. Groups of agents look for food, which is generated by a moisture layer in the simulated landscape, and seek shelter when they get too wet. In addition, groups of the same culture share information about food and shelter location to mimic some minimal social in-group versus out-group behaviors. The system was implemented using MASON's hexagonal grid facilities in multiple layers, as shown in Figure <ref type="figure" target="#fig_6">9</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Conclusion</head><p>In this article, we presented MASON, a multiagent simulation library written in Java. MASON is fast and portable, has a small core, and produces guaranteed duplicable results. MASON is also designed to completely separate the model from the visualization dynamically or reattach it, migrate the simulation to another platform in the middle of a run, and provide visualization in 2D or in 3D. We also showed six applications of MASON, highlighting the broad applicability of the toolkit. Two of the applications are ports of previous simulation models from Ascape and SWARM.</p><p>We plan to position MASON as a principled foundation for future multiagent simulation systems to build upon.</p><p>MASON is free open source under a BSD-style license and is available at http://cs.gmu.edu/∼eclab/projects/mason/.  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .Figure 2 .</head><label>12</label><figDesc>Figure 1. Highly simplified UML diagram of the basic classes in the model and visualization layers. Items in parentheses indicate sets from which numerous class are available.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Examples of visualized fields in MASON, showing various forms of 2D and 3D continuous and discrete space</figDesc><graphic coords="6,83.75,86.33,104.94,104.54" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 .Figure 5 .</head><label>45</label><figDesc>Figure 4. Network intrusion model: the physical (left) and logical (center) spaces, together with statistics on intrusions and compromised systems (right)</figDesc><graphic coords="9,107.99,86.33,388.87,144.14" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Cooperative target observation model. Small doubly circled dots are observers. Outer circles are their observation ranges. Large dots are targets. Straight lines connect observers with newly chosen destinations.</figDesc><graphic coords="9,328.55,304.01,201.87,201.74" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Foraging sequence with two obstacles. Nest is in bottom-right quadrant, and food source is in top-left quadrant. Left to right: (a) ants leave the nest while depositing a pheromone. (b) Ants discover the food source and begin return to nest along the pheromone while depositing a second pheromone. (c) Trail is established. (d) Ants perform trail optimization.</figDesc><graphic coords="10,68.99,86.33,108.87,108.14" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. Panels from the anthrax propagation model: (left) original SWARM model and (right) MASON replication</figDesc><graphic coords="11,145.31,101.81,152.77,159.26" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. Wetlands initial visualization and layers. Composite visualization (a) consisting of moisture layer (b), food sites layer (c), shelter sites layer (d), and agents layer (e)</figDesc><graphic coords="11,308.63,500.93,108.99,124.34" type="bitmap" /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>at UQ Library on November 12, 2014 sim.sagepub.com Downloaded from</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="518" xml:id="foot_1"><p>SIMULATION Volume 81, Number 7 at UQ Library on November 12, 2014 sim.sagepub.com Downloaded from</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>Volume 81, Number 7 SIMULATION 519 at UQ Library on November 12, 2014 sim.sagepub.com Downloaded from</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="520" xml:id="foot_3"><p>SIMULATION Volume 81, Number 7 at UQ Library on November 12, 2014 sim.sagepub.com Downloaded from</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_4"><p>Volume 81, Number 7 SIMULATION 521 at UQ Library on November 12, 2014 sim.sagepub.com Downloaded from</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="522" xml:id="foot_5"><p>SIMULATION Volume 81, Number 7 at UQ Library on November 12, 2014 sim.sagepub.com Downloaded from</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_6"><p>Volume 81, Number 7 SIMULATION 523 at UQ Library on November 12, 2014 sim.sagepub.com Downloaded from</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="524" xml:id="foot_7"><p>SIMULATION Volume 81, Number 7 at UQ Library on November 12, 2014 sim.sagepub.com Downloaded from</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_8"><p>Volume 81, Number 7 SIMULATION 525 at UQ Library on November 12, 2014 sim.sagepub.com Downloaded from</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="526" xml:id="foot_9"><p>SIMULATION Volume 81, Number 7 at UQ Library on November 12, 2014 sim.sagepub.com Downloaded from</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_10"><p>Volume 81, Number 7 SIMULATION 527 at UQ Library on November 12, 2014 sim.sagepub.com Downloaded from</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Acknowledgments</head><p>Funding for MASON development has been provided by the GMU Center for Social Complexity and by DARPA/IXO/PCAS grant no. 200748. Our thanks to Ken De Jong and Jayshree Sarma for their assistance in the development of the article. Thanks also to additional MA-SON developers: Christian Thompson is developing the physics engine, and Daniel Kuebrich wrote applications and Quicktime support. Thanks also to application writers for their assistance: the network intrusion model was written by Elena Popovici, the anthrax model was written by Jayshree Sarma and Elena Popovici, and the wetlands model was written by Sean Paus. Earlier versions of this article were presented at the SwarmFest04, Ann Arbor, Michigan, and at the RC33 Workshop of the International Sociological Association, Amsterdam. We thank Nick Gotts, Nigel Gilbert, Gary Polhill, Klaus Troitzsch, and Scott Moss for their comments. Last, we must blame MASON: A MULTIAGENT SIMULATION ENVIRONMENT John Grefenstette for coming up with the MASON name. It stands for "Multi-Agent Simulation of Networks" . . . or "Neighborhoods" . . . or something like that. Ns are hard.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Social science as computation</title>
		<author>
			<persName><forename type="first">Robert</forename><surname>Axtell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Center for Economic and Social Dynamics</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<pubPlace>Brookings Institution, Washington, DC</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Growing artificial societies: Social science from the bottom up</title>
		<author>
			<persName><forename type="first">Joshua</forename><forename type="middle">M</forename><surname>Epstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Axtell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Simulation for the social scientist. 2nd ed</title>
		<author>
			<persName><forename type="first">Nigel</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Klaus</forename><forename type="middle">G</forename><surname>Troitzsch</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>Open University Press</publisher>
			<pubPlace>Buckingham, UK</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Evolving behaviors for cooperating agents</title>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">K</forename><surname>Bassett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kenneth</forename><forename type="middle">A De</forename><surname>Jong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings from the Twelfth International Symposium on Methodologies for Intelligent Systems</title>
		<editor>
			<persName><forename type="first">Z</forename><surname>Ras</surname></persName>
		</editor>
		<meeting>from the Twelfth International Symposium on Methodologies for Intelligent Systems<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="157" to="165" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Learning in large cooperative multi-robot domains</title>
		<author>
			<persName><forename type="first">F</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lynne</forename><surname>Parker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Robotics and Automation</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="217" to="226" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Distributed algorithms for multi-robot observation of multiple moving targets</title>
		<author>
			<persName><forename type="first">Lynne</forename><surname>Parker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Autonomous Robots</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="231" to="255" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The effect of heterogeneity in teams of 100+ mobile robots</title>
		<author>
			<persName><forename type="first">Lynne</forename><forename type="middle">E</forename><surname>Parker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">In Multi-robot systems</title>
		<editor>
			<persName><forename type="first">Alan</forename><forename type="middle">C</forename><surname>Schultz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Lynne</forename><forename type="middle">E</forename><surname>Parker</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">II</biblScope>
			<biblScope unit="page" from="205" to="215" />
			<date type="published" when="2003">2003</date>
			<publisher>Kluwer</publisher>
			<pubPlace>Dordrecht, the Netherlands</pubPlace>
		</imprint>
	</monogr>
	<note>From swarms to intelligent automata</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">TeamBots simulation and real robot execution environment</title>
		<author>
			<persName><forename type="first">Tucker</forename><surname>Balch</surname></persName>
		</author>
		<ptr target="http://www-2.cs.cmu.edu/∼trb/TeamBots/" />
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">Paul</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Lancester</surname></persName>
		</author>
		<title level="m">Swarm User Guide: Swarm Development Group</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">Miles</forename><surname>Parker</surname></persName>
		</author>
		<ptr target="http://www.brook.edu/dybdocroot/es/dynamics/models/ascape/" />
		<title level="m">Ascape</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">Nick</forename><surname>Collier</surname></persName>
		</author>
		<ptr target="http://repast.sourceforge.net" />
		<title level="m">Repast: An agent based modelling toolkit for Java</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">Michael</forename><surname>Resnick</surname></persName>
		</author>
		<ptr target="http://education.mit.edu/starlogo/" />
		<title level="m">Turtles, termites, and traffic jams: Explorations in massively parallel microworlds</title>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Uri</forename><surname>Wilensky</surname></persName>
		</author>
		<ptr target="http://ccl.northwestern.edu/netlogo/" />
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">BREVE: A 3D environment for the simulation of decentralized systems and artificial life</title>
		<author>
			<persName><forename type="first">Jon</forename><surname>Klein</surname></persName>
		</author>
		<ptr target="http://www.spiderland.org/breve/" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of Artificial Life VIII, 8th International Conference on the Simulation and Synthesis of Living Systems</title>
		<meeting>Artificial Life VIII, 8th International Conference on the Simulation and Synthesis of Living Systems</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<author>
			<persName><forename type="first">Sean</forename><surname>Luke</surname></persName>
		</author>
		<ptr target="http://cs.gmu.edu/∼eclab/projects/ecj/" />
	</analytic>
	<monogr>
		<title level="m">A Java evolutionary computation library</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">11</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<author>
			<persName><forename type="first">Russell</forename><surname>Smith</surname></persName>
		</author>
		<ptr target="http://www.jfree.org/jfreechart/" />
	</analytic>
	<monogr>
		<title level="m">The open dynamics engine</title>
		<meeting><address><addrLine>Gilbert, David</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004">2004. 2004</date>
			<biblScope unit="volume">17</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">Bruno</forename><surname>Lowagie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paulo</forename><surname>Soares</surname></persName>
		</author>
		<ptr target="http://www.lowagie.com/iText/" />
		<title level="m">iText Java PDF generation library</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">Brian</forename><surname>Gerkey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><forename type="middle">T</forename><surname>Vaughan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Howard</surname></persName>
		</author>
		<ptr target="http://playerstage.sourceforge.net" />
		<title level="m">Player/Stage robotics simulator</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Tunably decentralized algorithms for cooperative target observation</title>
		<author>
			<persName><forename type="first">Sean</forename><surname>Luke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keith</forename><surname>Sullivan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Liviu</forename><surname>Panait</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gabriel</forename><surname>Balan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourth International Joint Conference on Autonomous Agents and Multi Agent Systems</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Dignum</surname></persName>
		</editor>
		<meeting>the Fourth International Joint Conference on Autonomous Agents and Multi Agent Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="911" to="917" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A pheromone-based utility model for collaborative foraging</title>
		<author>
			<persName><forename type="first">Liviu</forename><surname>Panait</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sean</forename><surname>Luke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third International Joint Conference on Autonomous Agents and Multi Agent Systems (AAMAS-2004)</title>
		<meeting>the Third International Joint Conference on Autonomous Agents and Multi Agent Systems (AAMAS-2004)</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Evolving ant foraging behaviors</title>
		<author>
			<persName><forename type="first">Liviu</forename><surname>Panait</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sean</forename><surname>Luke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Ninth International Conference on the Simulation and Synthesis of Living Systems</title>
		<meeting>the Ninth International Conference on the Simulation and Synthesis of Living Systems</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Floodland: A simple simulation environment for evolving agent behavior</title>
		<author>
			<persName><forename type="first">Sean</forename><surname>Paus</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<pubPlace>Fairfax, VA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, George Mason University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Mnemonic structure and sociality: A computational agent-based simulation model</title>
		<author>
			<persName><forename type="first">Claudio</forename><surname>Cioffi-Revilla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sean</forename><surname>Paus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sean</forename><surname>Luke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Olds</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jason</forename><surname>Thomas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Agent 2004 Conference on Social Dynamics</title>
		<meeting>the Agent 2004 Conference on Social Dynamics</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Sean</forename><surname>Luke</surname></persName>
		</author>
		<imprint>
			<pubPlace>Fairfax, Virginia</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science at George Mason University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Liviu Panait is a PhD candidate in the Department of</title>
		<imprint>
			<pubPlace>Fairfax, Virginia</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Computer Science at George Mason University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Keith Sullivan is a PhD student in the Department of</title>
		<imprint>
			<pubPlace>Fairfax, Virginia</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Computer Science at George Mason University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Gabriel Balan is a PhD student in the Department of</title>
		<imprint>
			<pubPlace>Fairfax, Virginia</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Computer Science at George Mason University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
