<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Automatic Package Coupling and Cycle Minimization</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Hani</forename><surname>Abdeen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">RMoD team</orgName>
								<orgName type="laboratory">UMR 8022</orgName>
								<orgName type="institution" key="instit1">INRIA -Lille Nord Europe</orgName>
								<orgName type="institution" key="instit2">USTL -CNRS</orgName>
								<address>
									<settlement>Lille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Stéphane</forename><surname>Ducasse</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">RMoD team</orgName>
								<orgName type="laboratory">UMR 8022</orgName>
								<orgName type="institution" key="instit1">INRIA -Lille Nord Europe</orgName>
								<orgName type="institution" key="instit2">USTL -CNRS</orgName>
								<address>
									<settlement>Lille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Houari</forename><surname>Sahraoui</surname></persName>
							<email>sahraoui@iro.umontreal.ca</email>
							<affiliation key="aff1">
								<orgName type="laboratory">DIRO</orgName>
								<orgName type="institution">Université de Montréal</orgName>
								<address>
									<settlement>Montréal</settlement>
									<region>QC)</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ilham</forename><surname>Alloui</surname></persName>
							<email>ilham.alloui@univ-savoie.fr</email>
							<affiliation key="aff2">
								<orgName type="laboratory">LISTIC</orgName>
								<orgName type="institution">Université de Savoie</orgName>
								<address>
									<settlement>Annecy</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Automatic Package Coupling and Cycle Minimization</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">B20F848C6D922D37079998A2EE453D5C</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:28+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Reverse engineering</term>
					<term>Re-engineering</term>
					<term>Software modularization</term>
					<term>Search algorithms</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Object-oriented (OO) software is usually organized into subsystems using the concepts of package or module. Such modular structure helps applications to evolve when facing new requirements. However, studies show that as software evolves to meet requirements and environment changes, modularization quality degrades. To help maintainers improve the quality of software modularization we have designed and implemented a heuristic search-based approach for automatically optimizing inter-package connectivity (i.e., dependencies). In this paper, we present our approach and its underlying techniques and algorithm. We show through a case study how it enables maintainers to optimize OO package structure of source code. Our optimization approach is based on Simulated Annealing technique.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>In object-oriented languages such as Java, Smalltalk and C++, package structure allows people to organize their programs into subsystems. A well modularized system enables its evolution by supporting the replacement of its parts without impacting the complete system. A good organization of classes into identifiable and collaborating subsystems eases the understanding, maintenance, test and evolution of software systems <ref type="bibr" target="#b5">[6]</ref>.</p><p>However code decays: as software evolves over time with the modification, addition and removal of new classes and dependencies, the modularization gradually drifts and looses quality <ref type="bibr" target="#b7">[8]</ref>. A consequence is that some classes may not be placed in suitable packages <ref type="bibr" target="#b11">[12]</ref>. To improve the quality of software modularization, optimizing the package structure and connectivity is required.</p><p>Software modularization is a graph partitioning problem <ref type="bibr" target="#b26">[27]</ref>, <ref type="bibr" target="#b27">[28]</ref>. Since this last is known as a NP-hard problem <ref type="bibr" target="#b8">[9]</ref>, searching for good modularization by using deterministic procedures or exhaustive exploration of the search space is not feasible without additional heuristics <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b26">[27]</ref>. We chose then an alternative approach based on heuristic search procedures to identify a good solution within a reasonable amount of computing time <ref type="bibr" target="#b9">[10]</ref>.</p><p>Heuristic search methods have already been successfully applied to the software modularization problem <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b12">[13]</ref>,</p><p>for example, to automatically decompose and modularize software systems. They are mainly based on clustering <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b21">[22]</ref>, <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b31">[32]</ref>, <ref type="bibr" target="#b27">[28]</ref> and evolutionary algorithms <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b18">[19]</ref>, <ref type="bibr" target="#b19">[20]</ref>, <ref type="bibr" target="#b25">[26]</ref>, <ref type="bibr" target="#b26">[27]</ref>, <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b30">[31]</ref>.</p><p>Few of these works address the problem of optimizing software modularization <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b26">[27]</ref>, <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b30">[31]</ref>, <ref type="bibr" target="#b32">[33]</ref>. Often existing approaches change (to various degrees) the existing package structure of an application. In such a case, it can be difficult for a software engineering to understand the resulting structure and to map it back to the situation he knows. Our approach is to support remodularisation of existing package structure by explicitly taking it into account and avoiding creating new package or related abstractions.</p><p>In this paper, we present an approach for automatically optimizing existing software modularizations by minimizing connectivity among packages, in particular cyclic-connectivity. The objective of the optimization process is inspired by well known package cohesion and coupling principles already discussed in <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b22">[23]</ref>. We limit ourselves to direct cyclic-connectivity and restrict our optimization actions to moving classes over existing packages. By definition, there is a direct cyclic-connectivity between two packages if they mutually depend on each other.</p><p>Our approach is based on Simulated Annealing <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b15">[16]</ref>, which is a neighborhood (local) search-based technique. Simulated Annealing is inspired by the annealing process in metallurgy <ref type="bibr" target="#b15">[16]</ref>. We chose this technique because, it suits well our problem, i.e., local optimization of an existing solution. Moreover, it has been shown to perform well in the context of automated OO class design improvement <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b29">[30]</ref> and more generally, in the context of software clustering problems <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b26">[27]</ref>.</p><p>Contribution: we present an approach, using simulated annealing technique, for automatically reducing package coupling and cycles by only moving classes over packages while taking into account the existing class organization and package structure. In our approach, maintainers can define <ref type="bibr" target="#b0">(1)</ref> the maximal number of classes that can change their packages, <ref type="bibr" target="#b1">(2)</ref> the maximal number of classes that a package can contain, and (3) the classes that should not change their packages or/and the packages that should not be changed.</p><p>Section II defines the terminology we use and gives an overview about challenges in optimizing package structure. Section III presents the metrics used in evaluation functions of both modularization and package quality. We detail our optimization algorithm in Section IV. We validate our approach using real large applications and discuss the results in Section V. In Section VI we position our approach with related works, before concluding in Section VII.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. BACKGROUND AND VOCABULARY</head><p>In this section, we introduce the terminology used in this paper and give an overview of some challenging issues we address. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Terminology</head><p>Before all, we define OO software Modularization M as a decomposition of the set of software classes M C into a set of packages M P . Fig. <ref type="figure" target="#fig_0">1</ref> shows two modularizations, both consists of 9 classes distributed over 3 packages: where Package represents an entity that only contains classes, where every class c belongs to only one package c p . We define package size p size by the number of its classes.</p><p>Every class c can be related to other classes, in consequence to their packages, through a set of Dependencies (c D ). This set consists of two subsets: Outgoing Dependencies (c Out.D ) and Incoming Dependencies (c Inc.D ). We denote a dependency that goes from a class c i to another one c j by the pair (c i , c j ). A dependency might be either method calls, class access, or class inheritance.</p><p>Every dependency is either internal if it is related to two classes belonging to the same package, or external if not. The set of dependencies related to a package p (p D ) represents the union of the set of internal dependencies (p Int.D ) and the set of external dependencies (p Ext.D ) relatively to p C , the set of p classes. The set p Ext.D consists of two subsets: dependencies that are either exiting p (p Ext.Out.D ) or that are pointing to p (p Ext.Inc.D ). The sets p Ext.Out.D and p Ext.Inc.D respectively relate p to its provider packages (p P ro.P ) and its client packages (p Cli.P ). M odularization 1 in Fig. <ref type="figure" target="#fig_0">1</ref> shows that there is one dependency exiting p1 and three dependencies pointing to p1: p1 To determine connectivity at the package level, we say that there is a Connection from a package y to another one z if there is n (n &gt; 0) outgoing dependencies y pointing to z. M odularization 1 in Fig. <ref type="figure" target="#fig_0">1</ref> shows that there are two connections going from p2 to its provider packages: p2 Out.Con = [(p2, p1), (p2, p3)]; and there is one connection going to p2: p2 Inc.Con = [(p1, p2)].</p><p>Dependencies can form direct cyclic dependencies/connections between packages. If package y plays the role of client and provider for package z then we consider involved dependencies and connections between y and z as cyclic. We denote the set of cyclic dependencies related to a package p by p Cyc.D . The set p Cyc.D consists also of two subsets: cyclic-dependencies that are either exiting p (p Out.Cyc.D ) or pointing to p (p Inc.Cyc.D ). p Out.Cyc.D and p Inc.Cyc.D are dependencies causing cycles between packages (and not classes) in the context of the client-provider relation. Similarly we denote the set of cyclic connections related to p by p Cyc.Con : p Cyc.Con = p Out.Cyc.Con ∪ p Inc.Cyc.Con . M odularization 1 in Fig. <ref type="figure" target="#fig_0">1</ref> shows that p1 has one outgoing cyclic-dependency [(c 3 , c 6 )] and two incoming cyclic-dependencies [(c 7 , c 1 ), (c 7 , c 2 )]. Those cyclic-dependencies produce two cyclic-connections: p1 Cyc.Con = p2 Cyc.Con = [(p1, p2), (p2, p1)].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Challenges in Optimizing Package Structure</head><p>Optimizing package structure in existing large applications is a difficult problem because of the following reasons:</p><p>Large applications are usually very complex: they contain thousands of heavily inter-connected classes. Many of the dependencies are between classes belonging to different packages, which increases the inter-package connectivity. In such situation, the optimization problem is more difficult.</p><p>Classes usually are not well distributed over packages: in real applications, some packages contain large sets of classes and other packages contain few number of classes. As consequence, most application packages depend on those large packages. Furthermore, it is difficult to determine an ideal package size since it may depend on external factors such as the team structure, domain, or coding practice...</p><p>Optimizing some criteria may degrade others: minimizing inter-packages dependencies/connections may increase the number of noncyclic ones. e.g., Fig. <ref type="figure" target="#fig_0">1</ref> shows two modularizations, M odularization 1 and M odularization 2 . Both are composed of the same set of classes and packages. The difference between them is c 7 that is moved from p2 to p3 in M odularization 2 . In M odularization 2 there are 2 cyclic-dependencies [(c 7 , c 6 ), (c 6 , c 9 )] compared to 3 in M odularization 1 [(c 3 , c 6 ), (c 7 , c 1 ), (c 7 , c 2 )]. Thus moving c 7 has reduced the number of cyclic-dependencies. On the other hand, moving c 7 increases the number of inter-package dependencies. In M odularization 2 , there are 6 interpackage dependencies compared to 5 for M odularization 1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. MODULARIZATION QUALITY</head><p>Our goal is to automatically optimize the decomposition of software system into packages so that the resulting organization of classes/packages, mainly, reduces connectivity and cyclic-connectivity between packages. This goal is inspired from well known quality principles already discussed in <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b22">[23]</ref> and in particular from the following principle: packages are desired to be loosely coupled and cohesive to a certain extent <ref type="bibr" target="#b10">[11]</ref>. In such a context, we need to define measures that evaluate package cohesion and coupling.</p><p>In addition, cyclic dependencies between packages are considered as an anti-pattern for package design <ref type="bibr" target="#b22">[23]</ref>. In this section we define two suites of measures: the first is used when evaluating modularization quality and the second is used when evaluating modularity quality of single package. Note that all measures we define in this section take their value in the interval [0..1] where 1 is the optimal value and 0 is the worst value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Measuring Modularization Quality</head><p>Inter-Package Dependencies: according to Common Closure Principle (CCP) <ref type="bibr" target="#b22">[23]</ref>, classes that change together should be grouped together. In such a context, optimizing modularization requires reducing the sum of inter-package dependencies (IP D = </p><formula xml:id="formula_0">CCQ(M) = 1 -IP D ICD</formula><p>Inter-Package Connections: according to Common Reuse Principle (CRP) <ref type="bibr" target="#b22">[23]</ref>, classes that are reused together should be grouped together. In such a context, optimizing modularization requires reducing the sum of inter-package connections (IP C = <ref type="bibr" target="#b10">[11]</ref>. We define the measure CRQ to evaluate the Common Reuse Quality of a modularization M as follows:</p><formula xml:id="formula_1">|M P | i=1 |p i Out.Con |) [3],</formula><formula xml:id="formula_2">CRQ(M) = 1 -IP C ICD</formula><p>Inter-Package Cyclic-Dependencies: according to Acyclic Dependencies Principle (ADP) <ref type="bibr" target="#b22">[23]</ref>, dependencies between packages must not form cycles. In such a context, optimizing modularization requires reducing the sum of inter-package cyclic-dependencies (IP CD =</p><formula xml:id="formula_3">|M P | i=1 |p i Out.Cyc.D |).</formula><p>We define the measure ADQ to measure the Acyclic Dependencies Quality of a modularization M as follows:</p><formula xml:id="formula_4">ADQ(M) = 1 -IP CD ICD</formula><p>Inter-Packages Cyclic-Connections: as for cyclic dependencies between packages, reducing cyclic connections between packages is required. For example, in M odularization 1 in Fig. <ref type="figure" target="#fig_0">1</ref>, there are 3 cyclic dependencies [(c 3 , c 6 ), (c 7 , c 1 ), (c 7 , c 2 )] and 2 cyclic connections [(p1, p2), (p2, p1)]; moving c 7 to p 3 will reduce the number of cyclic-dependencies: in modularization 2 there are only 2 cyclic dependencies [(c 6 , c 9 ), (c 7 , c 6 )], but it remains 2 cyclic connections [(p2, p3), (p3, p2)]. We thus deduce that reducing inter-package cyclic dependencies does not necessarily reduce inter-package direct cyclic-connections (IP CC =</p><formula xml:id="formula_5">|M P | i=1 |p i Out.Cyc.Con |).</formula><p>We define the measure ACQ to evaluate the Acyclic Connections Quality of a modularization M as follows:</p><formula xml:id="formula_6">ACQ(M) = 1 -IP CC ICD B.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Measuring Package Quality</head><p>In addition to measures presented in Section III-A, we define a set of measures that help us determine and quantify the quality of a single package within a given modularization. To normalize the value of those measures we use the number of dependencies related to the considered package</p><formula xml:id="formula_7">(|p D |) with |p D | &gt; 0.</formula><p>Package Cohesion: we relate package cohesion to the direct dependencies between its classes. In such a context, we consider that the cohesion of a package p is proportional to the number of internal dependencies within p (|p Int.D |). This is done according to the Common Closure Principle (CCP) <ref type="bibr" target="#b22">[23]</ref>. We define the measure of package cohesion quality similarly to that in <ref type="bibr" target="#b0">[1]</ref> as follows:</p><formula xml:id="formula_8">CohesionQ(p) = |p Int.D | |p D |</formula><p>Package Coupling: we relate package coupling to its efferent and afferent coupling (Ce, Ca) as defined by Martin in <ref type="bibr" target="#b23">[24]</ref>. Package Ce is the number of packages that this package depends upon (|p P ro.P |). Package Ca is the number of packages that depend upon this package (|p Cli.P |). According to the common reuse principle, we define the measure of package coupling quality using the number of package providers and clients as follows:</p><formula xml:id="formula_9">CouplingQ(p) = 1 -|p P ro.P ∪p Cli.P | |p D |</formula><p>Package Cyclic-Dependencies: for automatically detecting packages that suffer from direct-cyclic dependencies we define a simple measure that evaluates the quality of package cyclic dependencies (CyclicDQ) using the number of package cyclic dependencies:</p><formula xml:id="formula_10">CyclicDQ(p) = 1 - |p Cyc.D | |p D |</formula><p>Similarly we define another measure that evaluates package cyclic connections quality (CyclicDQ) using the number of package cyclic connections:</p><formula xml:id="formula_11">CyclicCQ(p) = 1 - |p Cyc.Con | |p D |</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. OPTIMIZATION TECHNIQUE (METHODOLOGY)</head><p>To optimize package connectivity, we use an optimization procedure that starts with a given modularization and gradually modifies it, using small perturbations. At each step, the resulting modularization is evaluated to be possibly selected as an alternative modularization. The evaluation of modularization quality is based on measures defined in Section III-A. This section describes our optimization approach and algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Technique Overview</head><p>To address the problem of optimizing modularization, we use heuristic optimization technique based on simulated annealing algorithm <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b15">[16]</ref>. Simulated annealing is an iterative procedure that belongs to the category of Neighborhood Search Techniques (N ST ). Algorithm 1 shows an overview of the optimization algorithm. The optimization process performs series of local searches with the global search parameter T current . T current represents in simulated annealing technique the current temperature of the annealing procedure which started with the value T start . A local search consists of num (num ≥ 1) searches of suboptimal solution. At each of them, a new modularization M trial is derived from a current one M current by applying to this later a modification. The derivation of M trial from M current is performed by the neighborhood function. Then, the algorithm evaluates the M trial and M current fitness using the fitness function F, where the bigger is the value of F(M), the better is modularization M: if M trial is better than M current then M trial becomes the M current ; then, if M current is better than the current best modularization M best , M current becomes the M best . At the end of each local search, the parameter T current decreases and another local search starts with the new value of T current . Decreasing T current is the responsibility of CoolingSchedule function. This latter is defined according to Keeffe etal. discussion <ref type="bibr" target="#b29">[30]</ref> using a geometric cooling scheme: CoolingSchedule(T ) = 0.9975 * T . Local searches are repeated until reaching T stop (T current ≤ T stop ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 Optimization Algorithm</head><p>To circumvent the problem of local optima <ref type="bibr" target="#b9">[10]</ref>, a lessgood modularization can be accepted with some probability: a less-good modularization M trial can replace M current under some conditions AcceptanceCondition. Simulated annealing technique defines acceptance conditions in a way that the probability of accepting a less-good modularization decreases over time. We define AcceptanceCondition as follows: r &gt; e - </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Evaluating Modularization Quality (Fitness)</head><p>As for any search-based optimization problem, the definition of the fitness function represents a central concern as it guides the search. We define our fitness function as a combination of the measures defined in Section III-A. We define dependency quality (DQ) for a modularization M as the weighted average of Common Closure Quality (CCQ) and Acyclic Dependencies Quality (ADQ); and we define connection quality (CQ) for M as the weighted average of Common Reuse Quality (CRQ) and Acyclic Connections Quality (ACQ). To give higher intention to cyclic dependencies/connections between packages we define a factor of importance γ (γ = β α , β &gt; α ≥ 1):</p><formula xml:id="formula_12">DQ(M) = α * CCQ(M)+β * ADQ(M) α+β CQ(M) = α * CRQ(M)+β * ACQ(M) α+β</formula><p>Both functions DQ and CQ take their values in the interval [0..1] where 1 is the optimal value. The final fitness function is defined by the average of DQ and CQ:</p><formula xml:id="formula_13">F(M) = DQ(M)+CQ(M)<label>2</label></formula><p>Our hypothesis is: optimizing F will reduce inter-package dependencies and connections, particularly cyclic ones. Furthermore, in addition to AcceptanceCondition for lessgood modularizations we defined in Section IV-A, the optimization process may accept a less-good resulting modularization only if the number of inter-package dependencies decreases (i.e., DQ increases). We expect such a decision facilitates the reduction of inter-package cyclic dependencies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Modularization Constraints</head><p>In addition to the fitness function, our approach allows maintainers to define distinct constraints that should complete the evaluation process and guarantee maintainers' requirements. The rationale behind those constraints is to control the optimization process when optimizing a given modularization. e.g., putting a major partition of classes into one package can effectively reduce inter-package (cyclic-) dependencies/connections; such an approach is clearly not the best one to optimize software modularization. This section presents three constraints allowing control the optimization process. Section IV-D explains how the optimization process favors these constraints when deriving new modularizations.</p><p>1) Controlling package size: to avoid having very large and dominant packages, we introduce the following constraint: the size of every package (p size ) should always be smaller than a predefined number (size max ). We define size max for every package p relatively to its size in the original modularization p size V 0 : size max = δ + p size V 0 , δ ≥ 0. Maintainers can define δ according to the context of the concerned software system. We cannot determine upfront the good interval in which δ should be taken. In the scope of this paper, we define δ as the theoretical package size in M 0 which equals to the ratio:</p><formula xml:id="formula_14">|M0 C | |M0 P | .</formula><p>It is worth to note that maintainers can define a different δ for each package: e.g., for a large package p, δ may be defined to 0; this way, p will never be larger than before.</p><p>2) Controlling modularization modification: maintainers should be able to define the limit of modifications that the optimization process can apply on the original modularization M 0 when it proceeds. In other words, the optimization process must take into account the maximal authorized distance (distance max ) between resulting modularizations and M 0 . In our context, for two modularizations that entail the same set of classes, we define the distance between them by the number of classes that changed packages. This way, distance max can be defined simply as the maximal number of classes that can change their packages.</p><p>3) Controlling modularization structure: moreover, we found that it is very helpful to allow maintainers decide whether some classes should not change their package and/or whether given packages should not be changed. We say that such classes/packages are frozen. This constraint is particularly helpful when maintainers know that a given package is well designed and should not be changed: e.g., if a small package p contains a couple of classes that extend classes from other package, p may be considered a well designed package, even if it is not cohesive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Deriving New Modularization (Neighbor)</head><p>The neighborhood function (N ) is the second main concern of the optimization process. Defining N requires: (1) the definition of the set of modifications that N can use to derive new modularizations, (2) and the definition of a process that derives a new modularization from another one. This section presents our definition of N .</p><p>Since we search near optimal modularization by applying near minimal modification to the original modularization, we limit the set of modifications that N can use to only: moving a class c from its current package p source to another one p target . In this context, we say that c is the modification actor (c actor ). To minimize search-space we reduce the selectionspace of p target to the set of client and provider packages of c actor : p target ∈ (c actor P ro.P ∪ c actor Cli.P ).</p><p>We specify the derivation of a neighbor modularization of a modularization M by 4 sequential steps: (1) selecting p source , (2) selecting c actor , (3) selecting p target and then (4) moving c actor to p target . Selections in the first three steps are done arbitrary using a probability function. The probability function gives higher probability to the worst package into M P to be selected as p source , to the worst class into p source to be selected as c actor and to the nearest package to c actor to be selected as p target . The selection mechanism performs similarly to a roulette wheel selection, where each class/package is given a slice proportional to its probability to be selected and then we randomly take a position in the roulette and pick the corresponding class/package.</p><p>It is worth to note that packages and classes that are defined as frozen (Section IV-C3), do not belong to the selection spaces: a frozen package will never be a p source or p target , and a frozen class will never be a c actor .</p><p>The following subsections explain our definition of the probability of being selected as p source , c actor or p target . Note that in our definition of this probability we use the factor γ, as defined in the fitness function (Section IV-B), to pay more intention to cyclic dependencies/connections. 1) Selecting p source : the worst package in M P is, the highest probability to be selected it has. We relate package badness to the quality of its cohesion, coupling and of its external dependencies (i.e., the density of cyclic dependencies/connections related to the concerned package). We define the badness of package by using the measures: CohesionQ, CouplingQ, CyclicDQ and CyclicCQ (Section III-B): where we relate CohesionQ and CyclicDQ to package dependency quality (DQ). Also we relate CouplingQ and CyclicCQ to package connection quality (CQ). We define package quality functions, similarly to modularization quality functions defined in Section IV-B :</p><formula xml:id="formula_15">DQ(p) = α * CohesionQ(p)+β * CyclicDQ(p) α+β CQ(p) = α * CouplingQ(p)+β * CyclicCQ(p) α+β</formula><p>Both functions DQ and CQ take their values in the interval [0..1] where 1 is the optimal value. Finally, we define package badness basing on the average of DQ and CQ:</p><formula xml:id="formula_16">Badness(p) = 1 -DQ(p)+CQ(p)</formula><p>In addition to satisfy constraints discussed in Section IV-C, we define the probability of selecting a package p as p source by: ρ * Badness(p), where ρ is a factor takes its value in the interval [0..1]. It is the average of two sub-factors (ρ 1 , ρ 2 ):</p><p>• ρ 1 is based on p size : relatively to p size in the original modularization M 0 (p 0size ), a package whose size increased has a higher probability to be selected than a package whose size decreased. By doing so, we expect that the package size in resulting modularizations will be similar to that in the original modularization; • ρ 2 is based on the number of new classes into p: relatively to p 0 , a package that acquired the largest number of new classes (i.e., classes are not packaged in p 0 ) has the highest probability to be selected. By doing so, we favor moving classes that already changed their packages until they find their optimal package. 2) Selecting c actor : the worse a class in p source is, the highest probability to be selected it has. We relate class badness to the number of external dependencies related to the class (|c Ext.D |) and to the number of its external cyclicdependencies (related to its package p):</p><formula xml:id="formula_17">Badness(c) = α * |c Ext.D |+β * |c Ext.D ∩p Cyc.D | α+β</formula><p>In addition, to satisfy the constraint of distance max (Section IV-C2), when the distance (d) between resulting modularizations and the original one increases, classes that have already changed their packages have higher probability to be c actor . In this context, we use the factor ρ = 1 -d distancemax . If ρ ≤ 0 then only classes which already changed their original packages can move. Only if 0 &lt; ρ ≤ 1 then the optimization process can move more classes over packages but with a probability ρ. Thus we define the probability of selecting a class c as c actor as following:</p><formula xml:id="formula_18">0 ρ ≤ 0, not(isM oved(c)) ρ * Badness(c) ρ &gt; 0, not(isM oved(c)) Badness(c) isM oved(c)</formula><p>Where the predicate isM oved(c) is true if c is already moved from its original package.</p><p>3) Selecting p target : the nearest package to c actor is, the highest probability to be selected it has. We simply relate the nearness of a package p To satisfy the constraint on p size (size max defined in Section IV-C1), when package size increases its probability to be selected as p targert decreases. In this context, we use the factor ρ = 1-psize sizemax . If ρ ≤ 0 then the package size should not increase anymore. Only if 0 &lt; ρ ≤ 1 then the package size can increase but with a probability ρ which decreases when p size increases. Thus we define the probability of selecting a package p as p target for a class c, as following:</p><formula xml:id="formula_19">0 ρ ≤ 0 ρ * N earness(p, c) 0 &lt; ρ ≤ 1</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. EXPERIMENTS AND VALIDATION</head><p>To validate our optimization approach, we applied it to several software applications that differ in terms of: number of classes (|M C |), number of packages (|M P |), number of inter-class dependencies (ICD); number of interpackage dependencies (IP D), connections (IP C), cyclic dependencies (IP CD) and cyclic connections (IP CC). Table <ref type="table" target="#tab_1">I</ref> shows information about the original modularization of those software applications.</p><p>Since the search process is not deterministic, we applied our algorithm 10 times for each software application and we calculated the average of modularization parameters cited in Table <ref type="table" target="#tab_1">I</ref>. We used the parameters T start , T stop and num (Algorithm 1) with value 50, 1 and 30 respectively. On another hand, we weighted cyclic dependencies/connections to be three times more important than noncyclic dependencies/connections. We performed our experience twice: the first time, we did not used the constraint distance max . In the second time, we limited distance max to 5%, which means that only 5% of classes can change their original packages.</p><p>General optimization: Table <ref type="table" target="#tab_3">III</ref> shows optimization results. In the resulting modularization for JEdit (JEdit 1 ), 10.2% of inter-package dependencies IP D, 23.3% of inter-package cyclic-dependencies IP CD, 24% of interpackage connections IP C and 37.2% of inter-package cyclicconnections IP CC have been removed. This significant improvement of inter-package connectivity was obtained by moving only 8.9% of the classes (d = 8.9%). Similarly for other case studies, the optimization process has improved original modularizations by moving a relatively small number of their classes. When limiting distance max to 5%, the algorithm obtained similar results.</p><p>Class distribution and package size: Table <ref type="table" target="#tab_4">IV</ref> shows that some packages were empty in resulting modularizations -since their classes moved to other packages. For example, in ArgoU M L 1 , 25.4% of packages were empty. By inspecting packages in the original modularization we found that those empty packages are packages which have originally very small sizes (i.e., in average two or three classes) and have low quality for cohesion, coupling and/or cyclic dependencies. This conclusion were also true for the other case studies.</p><p>Fig. <ref type="figure" target="#fig_5">2</ref> shows an overview about package size and cohesion for the original modularization of ArgoU M L and for the resulting modularizations (Table <ref type="table" target="#tab_3">III</ref>). We can see that empty packages in the resulting modularizations are packages whose sizes are small and whose cohesion is relatively worse. On another hand, Fig. <ref type="figure" target="#fig_5">2</ref> shows also that the size of some small packages, annotated by small packages, is increased in the resulting modularization. Dominant packages, annotated by dominant packages, is a main cause of bad distribution of classes: moving classes from  dominant packages to small ones generally produces more dependencies and connections among packages. Maintainers can avoid moving classes from small packages to dominant ones by limiting the size max (Section IV-C1) of dominant packages to their original size: p sizemax = p size V 0 . This way, the dominant package size will never increase and the optimization process will search better modularizations by moving classes among/to smaller packages.</p><p>Fortunately, in the case of JEdit 1 , only 10.5% (2/19) of packages are empty (Table <ref type="table" target="#tab_4">IV</ref>), where Table <ref type="table" target="#tab_3">III</ref> shows that our optimization process has effectively optimize package connectivity in JEdit 1 . Now as a future work, we have to perform a deep manual validation since in presence of late-binding and frameworks, some small packages may extend larger ones and as such may have a real reason to exist. Note that defining such packages as f orzen (Section IV-C3) will keep those packages existing.</p><p>While some packages became empty, Table <ref type="table" target="#tab_4">IV</ref> shows that the average package size ( |M C | |M P | ) for the resulting modularizations is really close to the average package size for the original ones Table <ref type="table" target="#tab_1">I</ref>. Similarly, we can see that for the maximum package size (maxP size ). This shows that the optimization algorithm conserves the original system shape.</p><p>Package quality optimization: Table <ref type="table" target="#tab_4">V</ref> shows that package quality average is also optimized: cohesion quality average (CohesionQ Avg ), coupling quality average (CouplingQ Avg ) and cyclic-dependency quality average (CyclicsDQ Avg ) for resulting packages are also almost all optimized, even if distance max is limited to only 5%. This can be seen also in Fig. <ref type="figure" target="#fig_5">2</ref>.</p><p>In only one case (JEdit 1 and JEdit 2 ), the package coupling quality (CouplingQ) decreased with a very good improvement of CyclicsDQ and CohesionQ. We explain this by the fact that the optimization process gives more importance to inter-packages cyclic-dependencies. Indeed, CyclicDQ had a very bad value in the original modularization JEdit (Table <ref type="table" target="#tab_1">II</ref>): the ratio of inter-package cyclic-dependencies ( IP CD ICD ) shows that 38.4% of inter-class dependencies form cyclic-dependencies between packages. Moreover there are 802 classes distributed over only 19 packages, so that the search space for generating new modularization is limited.  Consistency of resulting modularizations: since our optimization approach uses random selection, different executions produce different modularizations. To evaluate the consistency of our optimization approach, we have applied it 10 times on each case study (Table <ref type="table" target="#tab_1">I</ref>). As a result, each application has 10 modularizations [M 1 ..M 10 ]. Table <ref type="table" target="#tab_4">VI</ref> shows the average distance between every pair (M i , M j ). For example, between resulting modularizations for JEdit, there are, in average, only 3% of classes that have not the same packages. For Jboss, only 5.6% of the classes have different packages in distinct resulting modularizations.</p><p>We mainly relate this very good consistency of resulting modularizations to the improvements we introduced to the neighbor function N Section IV-D (i.e., the probability function to being selected).</p><p>In conclusion, the obtained results are very convincing. For all the case studies, the new modularizations are clearly better than the original ones. Moreover, our optimization process produces very similar results.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. RELATED WORKS</head><p>Our work is mostly related to work on software modularization and decomposition <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b21">[22]</ref>, <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b25">[26]</ref>, <ref type="bibr" target="#b26">[27]</ref>, <ref type="bibr" target="#b30">[31]</ref>.</p><p>Mitchell etal. <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b21">[22]</ref>, <ref type="bibr" target="#b24">[25]</ref> introduced a search-based approach based on hill-climbing clustering technique to cluster software modules (classes in our context). Their approach starts with an initial population of random modularizations. The clustering algorithm clusters each of the random modularization and selects the result with the largest quality as the suboptimal solution. Recently, they used Simulated Annealing technique to optimize resulting clusters <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b25">[26]</ref>, <ref type="bibr" target="#b26">[27]</ref>. Their optimization approach creates new modularizations by moving randomly some classes (a block of classes) to new clusters. The goal of their approach is increasing cluster internal dependencies.</p><p>Harman etal. <ref type="bibr" target="#b14">[15]</ref> introduces a non-exhaustive hill climbing approach to optimize and determine a sequence of class refactorings. Similarly to our approach, they also restricted their approach to only move methods (classes in our context) over existing classes (packages in our context). The goal of their approach is reducing the class coupling, basing on the Coupling Between Objects (CBO) metric <ref type="bibr" target="#b2">[3]</ref>. To avoid having a very large classes, they also used the dispersion of methods over classes (the standard deviation of methods per class metric) as a factor to measure the quality of resulting class refactoring sequences.</p><p>Abreu etal. <ref type="bibr" target="#b0">[1]</ref> used hierarchical agglomerative clustering methods to decompose software classes into packages. Their clustering methods starts with a set of classes considering that each class is placed within a singleton cluster.</p><p>The goal of their approach is also increasing package internal dependencies (i.e., package cohesion). In addition to the package cohesion, they used the dispersion of classes over packages (i.e., package size dispersion) as a factor to measure the modularization quality.</p><p>Seng etal. <ref type="bibr" target="#b30">[31]</ref> and Harman etal. <ref type="bibr" target="#b13">[14]</ref> proposed genetic algorithms to partition software classes into subsystems (packages). Their algorithms start with an initial population of modularizations. These algorithms apply genetic operators on packages to modify current modularizations and/or create new modularizations into the population. The goal of both works is increasing package internal dependencies. Seng etal. consider also cyclic-dependencies between packages as anti-pattern for package design quality.</p><p>Our approach has several advantages compared to those works.</p><p>Considering explicitly the original modularization and controlling the optimization process: our approach tackles the problem of optimizing existing software modularizations rather than the problem of software re-modularization. Indeed, our optimization approach starts from one original modularization instead of an initial population of modularizations or a flat set of classes. Although we use an optimization technique similar to that in Mitchell etal. work, we restrict ours to moving classes over existing packages rather than creating new packages since we want to minimize the distance for a maintainer between the initial situation and the resulting one. Even if some prior works support the notion of importing a defined clustering <ref type="bibr" target="#b32">[33]</ref> and restrict modifications to only moving classes over existing packages <ref type="bibr" target="#b14">[15]</ref>, we did not found, in the software re-modularization literature, approaches that explicitly take into account the original modularization structure as we do. Our approach allows maintainers to specify a set of constraints (e.g., the number of classes that may change their package, the package maximal size and the packages/classes which should not be changed/moved) and therefore make them control the optimization process. Although those constraints are simple, they are very important and helpful for the automatic optimization of software modularization.</p><p>Searching better modularizations by doing near-minimal modifications: differently of those cited works, which search good modularizations without considering the distance between resulting modularizations and the original ones, we introduce a probability function that improves the derivation of neighbor modularizations by taking into account the distance between resulting modularizations and the original one, in addition to other constraints (Section IV-C) and package quality parameters (Section III-B). The great advantage of the probability function is finding better modularization by doing near-minimal modifications (Section V, the distance between resulting modularizations and the original one is very small).</p><p>Reducing package coupling and cycles in two levels (inter-package dependencies and connections): another advantage of our approach is that we use an evaluation function consisting of a combination of multiple measures. This allows us to have a much richer quality model than the approaches cited above which are mostly based on the unique goal of maximizing package internal dependencies. Although those approaches aim at reducing the global number of interpackage dependencies (e.g., the fitness measure MQ used by Mitchell etal. <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b25">[26]</ref>, <ref type="bibr" target="#b26">[27]</ref>), they do not take into account the number of coupled packages (i.e., the number of inter-package connections). As consequence, they do not check whether package coupling is reduced or not along the optimization process. In addition, those cited prior works do not consider package cycles. Excepted Seng etal. <ref type="bibr" target="#b30">[31]</ref>, they consider inter-package cyclic-dependencies, without taking in account inter-package cyclic-connections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. CONCLUSION AND FUTURE WORK</head><p>In this paper, we addressed the problem of optimizing existing modularizations by reducing the connectivity, particularly the cyclic-connectivity, among packages. We proposed an optimization algorithm and a set of measures that our optimization process uses to automatically evaluate the quality of a modularization. When designing our optimization approach, we exploited several principles of package design quality to guide and to optimize the automatic derivation of new modularizations from an existing one. We limited the optimization process to only moving classes over existing packages. We also introduced constraints related to package size, to the number of classes that are allowed to change their packages and to the classes/packages that should not be moved/changed. The results obtained from 4 case studies on real large applications shown that our optimization algorithm has been able to reduce, significantly, package coupling and cycles, by moving a relatively small number of classes from their original packages. These results are important because the chosen applications have radically different original modularizations (in terms of number of classes/packages, inter-class/inter-package dependencies, etc.).</p><p>As future work, we intend to enhance our approach by: (1) supporting indirect cyclic-dependencies among packages, (2) taking into account visibility of classes and particular cases of classes (e.g., inner classes in Java). Indeed in this paper, we considered that classes are always public and then can change their packages, (3) setting up a real validation supported by proper statistics and qualitative analyses of resulting source code structures. We also envisage a deep comparison with the closest related work (e.g., Bunch).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Example of two modularizations: different decompositions of the set of classes [c1..c9] into 3 packages [p1, p2, p3].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Ext.Out.D = [(c 3 , c 6 )]; p1 Ext.Inc.D = [(c 7 , c 1 ), (c 7 , c 2 ), (c 8 , c 2 )]. It also shows that p1 has one provider package and two client packages: p1 P ro.P = [p2]; p1 Cli.P = [p2, p3].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>|M P | i=1 |p i Ext.Out.D |) [3], [11]. Since we do not change the dependencies between classes during our optimization process, we use the sum of inter-class dependencies (ICD = |M C | j=1 |c j Out.D |) as normalizer. We define the measure CCQ to evaluate the Common Closure Quality of a modularization M as follows:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>T current T start , r ∈ [0..1]. The value of r is generated randomly in the interval [0..1]. The function e -T current T start takes its value in the interval [0..1] ∀T current ≥ 0, and T current ≤ T start . It increases along the optimization process -since T current decreases. By doing so, the probability of accepting a less-good modularization decreases over time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>to a class c to the number of dependencies that c has with p classes (|c D ∩ p D |) and to the number of dependencies related to c and present cyclic dependencies between c p and p (|c D ∩ p Cyc.D |): N earness(p, c) = α * |c D ∩p D |+β * |c D ∩p Cyc.D | α+β</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Package size and cohesion into ArgoUML original (dark gray) and resulting (light gray) modularizations. Packages have the same order in diagrams.</figDesc><graphic coords="7,127.38,288.09,358.42,128.03" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Tstop ≥ 1, Tstart &gt; Tstop, num &gt; 1 and M original Ensure: M best M best ← M original Mcurrent ← M</figDesc><table><row><cell>M best ← Mcurrent</cell></row><row><cell>end if</cell></row><row><cell>else if AcceptanceCondition then</cell></row><row><cell>-accepting a worse modularization-</cell></row><row><cell>Mcurrent ← M trial</cell></row><row><cell>end if</cell></row><row><cell>end for</cell></row><row><cell>-end of local search-</cell></row><row><cell>Tcurrent ← CoolingSchedule(Tcurrent)</cell></row><row><cell>end while</cell></row><row><cell>-end of global search-</cell></row><row><cell>Return M best .</cell></row></table><note><p><p><p>Require: best</p>Tcurrent ← Tstart -starting global searchwhile Tcurrent &gt; Tstop do -starting local searchfor i = 1 to num do -generating a new modularization and evaluating it-</p>M trial ← N eighborhood(Mcurrent) if F(M trial ) &gt; F(Mcurrent) then Mcurrent ← M trial if F(Mcurrent) &gt; F(M best ) then</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table I INFORMATION</head><label>I</label><figDesc>ABOUT USED SOFTWARE APPLICATIONS.</figDesc><table><row><cell cols="2">Original |MC |</cell><cell>ICD</cell><cell>|MP |</cell><cell>IP D</cell><cell cols="4">IP CD IP C IP CC maxPsize</cell><cell>|M C | |M P |</cell></row><row><cell>JEdit</cell><cell>802</cell><cell>2683</cell><cell>19</cell><cell>1430</cell><cell>1032</cell><cell>110</cell><cell>26</cell><cell>173</cell><cell>42.2</cell></row><row><cell>ArgoUML</cell><cell>1671</cell><cell>7432</cell><cell>76</cell><cell>5661</cell><cell>1406</cell><cell>517</cell><cell>63</cell><cell>156</cell><cell>22</cell></row><row><cell>Jboss</cell><cell>3094</cell><cell>8859</cell><cell>455</cell><cell>7219</cell><cell>296</cell><cell>1898</cell><cell>41</cell><cell>80</cell><cell>6.8</cell></row><row><cell>Azureus</cell><cell>4212</cell><cell>13945</cell><cell>380</cell><cell>10929</cell><cell>1319</cell><cell>2037</cell><cell>136</cell><cell>213</cell><cell>11</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table III OPTIMIZATIONS</head><label>III</label><figDesc>ON INTER-PACKAGE CONNECTIVITY. THE TOP TABLE SHOWS THE PERCENT OF REDUCTION OF IPD, .. , IPCC (TABLE I) INTO RESULTING MODULARIZATIONS. THE BIGGEST NEGATIVE VALUE IS, THE BEST OPTIMIZATION IS. THE BOTTOM TABLE SHOWS THESE INFORMATION WHEN distancemax IS SPECIFIED AND LIMITED TO 5%.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table V OPTIMIZATIONS</head><label>V</label><figDesc>ON PACKAGE QUALITY. THE TOP TABLE SHOWS THE AVERAGE OPTIMIZATIONS ON PACKAGE QUALITY INTO RESULTING MODULARIZATIONS. VALUES ARE BASED ON TABLE II. THE BIGGEST POSITIVE VALUE IS, THE BEST OPTIMIZATION IS. THE BOTTOM TABLE SHOWS THESE INFORMATION WHEN distancemax IS SPECIFIED AND LIMITED TO 5%.</figDesc><table><row><cell cols="4">Optimization1 CohesionQAvg CouplingQAvg CyclicsDQAvg</cell></row><row><cell>JEdit1</cell><cell>+06.1%</cell><cell>-00.8%</cell><cell>+10.4%</cell></row><row><cell>ArgoU M L1</cell><cell>+08.1%</cell><cell>+07.4%</cell><cell>+00.4%</cell></row><row><cell>Jboss1</cell><cell>+08.5%</cell><cell>+11.6%</cell><cell>+01.8%</cell></row><row><cell>Azureus1</cell><cell>+05.8%</cell><cell>+03.6%</cell><cell>+05.4%</cell></row><row><cell cols="4">Optimization2 CohesionQAvg CouplingQAvg CyclicsDQAvg</cell></row><row><cell>JEdit2</cell><cell>+05.4%</cell><cell>-02.2%</cell><cell>+05.2%</cell></row><row><cell>ArgoU M L2</cell><cell>+06.0%</cell><cell>+07.4%</cell><cell>+00.1%</cell></row><row><cell>Jboss2</cell><cell>+04.0%</cell><cell>+09.4%</cell><cell>+00.5%</cell></row><row><cell>Azureus2</cell><cell>+03.9%</cell><cell>+04.6%</cell><cell>+02.2%</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>TABLE SHOWS THE AVERAGE DISTANCE BETWEEN TEN RESULTING MODULARIZATIONS FOR EACH APPLICATION.</figDesc><table><row><cell cols="2">Optimization1 DistanceAvg</cell></row><row><cell>JEdit1</cell><cell>3%</cell></row><row><cell>ArgoU M L1</cell><cell>4.1%</cell></row><row><cell>Jboss1</cell><cell>5.6%</cell></row><row><cell>Azureus1</cell><cell>4.9%</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>We gratefully acknowledge the financial support of the french ANR (National Research Agency) for the project "COOK: Réarchitecturisation des applications industrielles objets" (JC05 42872).</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Optimization1</head><p>IP D IP CD IP C IP CC JEdit1(d = 8.9%) -10.2% -23.3% -24.0% -37.2% ArgoU M L1(d = 8.3%) -04.4% -09.0% -  </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Coupling and cohesion as modularization drivers: are we being over-persuaded?</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">B</forename><surname>Abreu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Goulao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CSMR &apos;01</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="47" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Architecture-aware adaptive clustering of OO systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Trifu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CSMR &apos;04</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="3" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A unified framework for cohesion measurement in object-oriented systems</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Briand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Daly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wüst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Empirical Software Engineering: An International Journal</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="65" to="117" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">System design is an np-complete problem: Correspondence</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">L</forename><surname>Chapman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rozenblit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">T</forename><surname>Bahill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Systems Engineering</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="222" to="229" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Reformulating software engineering as a search problem</title>
		<author>
			<persName><forename type="first">J</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Dolado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lumkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rees</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Roper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In IEEE Proceedings on Software</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="161" to="175" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Programming in the large versus programming in the small</title>
		<author>
			<persName><forename type="first">F</forename><surname>Deremer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">H</forename><surname>Kron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TSE</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="80" to="86" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Automatic clustering of software systems using a genetic algorithm</title>
		<author>
			<persName><forename type="first">D</forename><surname>Doval</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mancoridis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STEP &apos;99</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">73</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Does code decay? assessing the evidence from change management data</title>
		<author>
			<persName><forename type="first">S</forename><surname>Eick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Graves</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Karr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Marron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mockus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TSE</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="12" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Vertex-partitioning into fixed additive inducedhereditary properties is np-hard</title>
		<author>
			<persName><forename type="first">A</forename><surname>Farrugia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Electronic Journal of Combinatorics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Heuristic search methods for combinatorial programming problems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Ferland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Costa</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Reducing coupling</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fowler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Automated assistance for program restructuring</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">G</forename><surname>Griswold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Notkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Softw. Eng. Methodol</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="228" to="269" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The current state and future of search based software engineering</title>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOSE &apos;07</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="342" to="357" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A new representation and crossover operator for search-based optimization of software modularization</title>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hierons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Proctor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GECCO &apos;02</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="1351" to="1358" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Pareto optimal search based refactoring at the design level</title>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Tratt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GECCO&apos;07</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="1106" to="1113" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Optimization by simulated annealing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kirkpatrick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D G</forename><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Vecchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">220</biblScope>
			<biblScope unit="issue">4598</biblScope>
			<biblScope unit="page" from="671" to="680" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Using evolutionary algorithms to tackle large scale grouping problems</title>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tucker</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note>In GECCO &apos;01</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Program restructuring using clustering techniques</title>
		<author>
			<persName><forename type="first">C.-H</forename><surname>Lung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zaman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Srinivasan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Syst. Softw</title>
		<imprint>
			<biblScope unit="volume">79</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1261" to="1279" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Evolving good hierarchical decompositions of complex systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Lutz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Systems Architecture</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="613" to="634" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Genetic algorithms for graph partitioning and incremental graph partitioning</title>
		<author>
			<persName><forename type="first">H</forename><surname>Maini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Mehrotra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Mohan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ranka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Supercomputing &apos;94</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="449" to="457" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Using automatic clustering to produce high-level system organizations of source code. In IWPC &apos;98</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mancoridis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Mitchell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>IEEE Computer Society Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Bunch: A clustering tool for the recovery and maintenance of software system structures</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mancoridis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">R</forename><surname>Gansner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSM &apos;99</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Martin</surname></persName>
		</author>
		<title level="m">Agile Software Development. Principles, Patterns, and Practices</title>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">The tipping point: Stability and instability in OO design</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Martin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>Software Development</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Using heuristic search techniques to extract design abstractions from source code</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mancoridis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GECCO &apos;02</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="1375" to="1382" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">On the automatic modularization of software systems using the bunch tool</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mancoridis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TSE</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="193" to="208" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">On the evaluation of the bunch search-based software modularization algorithm. Soft Computing -A Fusion of Foundations</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mancoridis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Methodologies and Applications</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="77" to="93" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Using interconnection style rules to infer software architecture relations</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mancoridis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Traverso</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
	<note>In GECCO &apos;04</note>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Search-based software maintenance</title>
		<author>
			<persName><forename type="first">M</forename><surname>O'keeffe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Cinnéide</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">0</biblScope>
			<biblScope unit="page" from="249" to="260" />
		</imprint>
	</monogr>
	<note>In CSMR &apos;04</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Search-based refactoring for software maintenance</title>
		<author>
			<persName><forename type="first">M</forename><surname>O'keeffe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Cinnéide</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Systems and Software</title>
		<imprint>
			<biblScope unit="volume">81</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="502" to="516" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Search-based improvement of subsystem decompositions</title>
		<author>
			<persName><forename type="first">O</forename><surname>Seng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Biehl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pache</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GECCO &apos;05</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="1045" to="1051" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Restructuring software systems using clustering. ISCIS&apos;07</title>
		<author>
			<persName><forename type="first">G</forename><surname>Serban</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">G</forename><surname>Czibula</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">The orphan adoption problem in architecture maintenance</title>
		<author>
			<persName><forename type="first">V</forename><surname>Tzerpos</surname></persName>
			<affiliation>
				<orgName type="collaboration">Reverse Engineering</orgName>
			</affiliation>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Holt</surname></persName>
			<affiliation>
				<orgName type="collaboration">Reverse Engineering</orgName>
			</affiliation>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page">76</biblScope>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
