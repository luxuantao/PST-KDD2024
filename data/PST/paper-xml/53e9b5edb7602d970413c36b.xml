<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Low Latency and Cheat-proof Event Ordering for Peer-to-Peer Games *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Chris</forename><surname>Gauthierdickey</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science 1202</orgName>
								<orgName type="institution" key="instit1">University of Oregon</orgName>
								<orgName type="institution" key="instit2">University of Oregon Eugene</orgName>
								<address>
									<postCode>97403-1202</postCode>
									<region>OR</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Daniel</forename><surname>Zappala</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science 1202</orgName>
								<orgName type="institution" key="instit1">University of Oregon</orgName>
								<orgName type="institution" key="instit2">University of Oregon Eugene</orgName>
								<address>
									<postCode>97403-1202</postCode>
									<region>OR</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Virginia</forename><surname>Lo</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science 1202</orgName>
								<orgName type="institution" key="instit1">University of Oregon</orgName>
								<orgName type="institution" key="instit2">University of Oregon Eugene</orgName>
								<address>
									<postCode>97403-1202</postCode>
									<region>OR</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">James</forename><surname>Marr</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science 1202</orgName>
								<orgName type="institution" key="instit1">University of Oregon</orgName>
								<orgName type="institution" key="instit2">University of Oregon Eugene</orgName>
								<address>
									<postCode>97403-1202</postCode>
									<region>OR</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Low Latency and Cheat-proof Event Ordering for Peer-to-Peer Games *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D46D3935C1F01B233350FF43B78A1D97</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:41+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C.2.4 [Distributed Systems]:Distributed applications</term>
					<term>I.6.8 [Types of Simulation]:Gaming Algorithms</term>
					<term>Performance</term>
					<term>Security low-latency</term>
					<term>cheat-proof</term>
					<term>peer-to-peer</term>
					<term>distributed</term>
					<term>interactive</term>
					<term>games</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We are developing a distributed architecture for massivelymultiplayer games. In this paper, we focus on designing a low-latency event ordering protocol, called NEO, for this architecture. Previous event ordering protocols prevent several types of cheats at the expense of operating at the latency of the slowest player. We broaden the definition of cheating to include four common protocol level cheats and demonstrate how NEO prevents these cheats. At the same time, NEO has a playout latency independent of network conditions and adapts to network congestion to optimize performance.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Traditionally, multi-player games have used a client/server communication architecture. This architecture has the advantage that a single authority orders events, resolves conflicts in the simulation, acts as a central repository for data, and is easy to secure. On the other hand, this architecture has several disadvantages. First, it introduces delay because messages between players are always forwarded through the server. Second, traffic at the server increases with the number of players, creating localized congestion. Third, with small multi-player games, the server is hosted by one player, and the others must trust that the server is not tainted. Last, this architecture is limited by the computational power of the server. While we can throw technology at most of these problems in the form of more servers and higher bandwidth lines, this solution incurs significant cost.</p><p>To address these problems, we are developing a fully distributed, peer-to-peer architecture for massively-multiplayer online games (MMOGs). This architecture allows peers to send messages directly to each other, reducing the delay for messages and eliminating localized congestion. It allows players to start their own games without the incredible investment in resources required by a client/server architecture. Furthermore, this architecture allows games to overcome the bottleneck of sever-only computation by harnessing the processing power of the players' machines through peer-to-peer computing.</p><p>To build a distributed game, we must first overcome the fundamental problem of preventing cheating in an untrusted environment. Specifically, how can players trust each other to accurately represent when a given event has occurred? Accordingly, the first component we have designed for this architecture is the New-Event Ordering (NEO) protocol, which provides low latency event ordering while still preventing common protocol-level cheats. NEO provides much lower latency than previous event ordering protocols, which are limited by the latency of the slowest player to any other player in the game. NEO divides time into "rounds" and uses the round duration to bound the maximum latency of a player from a majority of other players in the game. This means that it is acceptable to be slow to some players, as long as most players get your updates in a timely fashion. While NEO dramatically improves performance, it does not compromise trust. We show how NEO can prevent five common protocol-level cheats, under a broader definition of cheating than has been previously used.</p><p>In this paper, we describe our peer-to-peer game architecture and the motivation behind designing a new architecture. We then describe the NEO protocol and show how it can provide low latency event ordering for distributed games, while also preventing cheating at the protocol level. We finish by extending NEO with several enhancements that allow players to react to network congestion and improve game play when congestion is low.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">A TAXONOMY OF CHEATING</head><p>In order to understand the problems that arise when designing a distributed event ordering protocol, we present a short taxonomy of cheating. We define a cheat as any action by a player that gives her an unfair advantage over another player. Cheats can be categorized by the layer in which they occur: game, application, protocol, or network. The cheats are described in the context of the cheating player named Eve and a competing player named Alice.</p><p>Game level cheats occur by breaking the rules of the game. For example, Eve discovers that by dropping an object while casting a spell allows her to keep a copy of the object in her inventory, even though she just dropped it (granting her the ability to duplicate any object in the game). Application level cheats occur by modifying the code of the game or operating system. A common example is modifying the rendering code so that walls in a game are invisible, making it easy to locate hidden players. Protocol level cheats occur by modifying the protocol, such as changing the contents of packets. Network level cheats occur because of properties inherent in the network layer. A denial-of-service attack is an example of a network level cheat.</p><p>Our focus in this paper is preventing protocol level cheats. We define five common protocol level cheats, based on our experience with distributed games:</p><p>Fixed-Delay Cheat: In the fixed-delay cheat, Eve adds a fixed amount of delay to her outgoing packets, allowing Eve to receive packets faster than she is sending them. Eve gains the advantage of being able to react quicker to other players than they can react to her delayed packets.</p><p>Timestamp Cheat: Because events must be ordered for consistency purposes, a global clock is often used for time stamping. In the timestamp cheat, Eve waits to receive an update from Alice and then sends her update with a timestamp that is before Alice's. For example, Eve could send out a move with a timestamp earlier than the 'Alice shoots Eve' update just received. To other players, Eve's message appears to be delayed and the shot misses.</p><p>Suppressed Update Cheat: In this cheat, Eve suppresses all updates to one or more players, while continuing to receive their updates. This cheat allows Eve to 'hide' from other players, since they are no longer receiving her updates, but she is receiving theirs. Eve sends a new packet with her current position before she is dropped from the game.</p><p>Inconsistency Cheat: In the inconsistency cheat, Eve sends different updates to different players in the game. We describe this cheat in the context of Alice, a competing player. Eve sends her 'real' update to every player while sending a different update to Alice at time t. Now Alice thinks Eve is in a different location than she really is, but every other player will disagree with Alice on Eve's location. Later, Eve can send updates to Alice that merge the two differing opinions on her location in order to hide her cheat. In the worse case scenario, Alice can corrupt an entire game, but Alice can also corrupt a single player, eliminating them from the game. The inconsistency cheat arises from the Byzantine General's Agreement problem <ref type="bibr" target="#b10">[10]</ref>, but in this case we are trying to have an agreement on everyone's game state.</p><p>Collusion Cheat: A collusion cheat occurs by having several players collude and either share packets or modify them in some way to gain an advantage over other players. For example, Eve is colluding with Mallory and is trying to catch Alice. Mallory sees Alice, even though Eve cannot, so Mallory can simply inform Eve of Alice's location. Recall that this occurs at the protocol level-in other words, Mallory can simply forward Alice's positional updates to Eve even though she shouldn't receive them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">MOTIVATION</head><p>Besides overcoming the limitations of the client/server architecture, we are motivated to develop a fully distributed architecture for MMOGs because of the past research related to distributed games.</p><p>Diot, Gautier and Kurose described the first protocol for distributed games in <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b8">8]</ref> and built a game called MiMaze to demonstrate its feasibility. Their work is important because they developed a technique called bucket synchronization, in which game time is divided into 'buckets', in order to maintain state consistency among players. The MiMaze protocol uses multicast to exchange packets between players, resulting in a low latency; however, it does not address the problem of cheating.</p><p>At the other end of the spectrum, Baughman and Levine designed the lockstep protocol to address the problem of protocol level cheats <ref type="bibr" target="#b1">[1]</ref>. Lockstep uses rounds for time, which are broken into two steps: first, everyone reliably sends a cryptographic hash of their move, then everyone sends the plain-text version of their move. This forces everyone to commit their move, without revealing it, thereby preventing anyone from knowing someone else's move ahead of time.</p><p>To mitigate the problem of delay introduced by reliable transport, Baughman and Levine added event scoping (called asynchronous synchronization in <ref type="bibr" target="#b1">[1]</ref>). Event scoping requires that players exchange updates only when their actions might intersect. To do this with lockstep, each player associates a sphere of influence with every other player. When a player receives or misses an update from another player during a round, the associated sphere is contracted or dilated respectively. This allows players to progress in rounds asynchronously until their sphere intersects with another player's sphere-at which point they must engage in lockstep (and wait for each other's messages).</p><p>Lockstep is a major advance in distributed protocols because it is provably secure against the fixed-delay and timestamp cheats. It gains this security by forcing moves to occur in lockstep-no player can receive a plain-text move before they commit their move.</p><p>Unfortunately, lockstep has several drawbacks. First, its playout latency, which is the time from when an update is sent out to when the update can be displayed to other players, has a minimum bound of three times the latency of the slowest link between any two players. This bound is due to the use of reliable transport for sending the hashed update, followed by sending the plain-text update. Event scoping does not help to reduce latency because players that are close in the virtual world of a game may in fact incur significant propagation and queueing delay. Second, lockstep is vulnerable to the suppressed update cheat-a malicious player can stop sending updates, stopping round progression until other players drop her from the game. Last, lockstep is vulnerable to collusion when event scoping is used. Since rounds no longer progress synchronously, a player can receive a plain-text update from another player and forward the update on to other players who have not yet committed their move for that round.</p><p>Cronin et al. designed the Sliding Pipeline (SP) protocol <ref type="bibr" target="#b4">[4]</ref> in order to improve the lockstep protocol. They add an adaptive pipeline that allows players to send out several moves in advance without waiting for ACKs from the other players, reducing the time that is dead-reckoned between rounds. The pipeline depth is designed to grow with the maximum latency between players so that jitter, or interpacket arrival time, is reduced.</p><p>While the SP protocol reduces jitter and dead-reckoning, it still has the same playout latency as lockstep. In terms of security, the protocol prevents the timestamp cheat, but allows a player to use the fixed-delay cheat <ref type="bibr" target="#b4">[4]</ref> because a player can artificially increases her delay to receive a plaintext move before committing her move for a given round. The adaptive pipeline helps detect this cheat, but it can falsely label someone with an increased delay as a cheater. Furthermore, a cheater can use the fixed-delay update cheat every other round and not be detected.</p><p>Bharambe et al. have proposed Mercury, a distributed publish-subscribe communication architecture <ref type="bibr" target="#b3">[3]</ref>. Mercury provides channels, which can be of any subject, uses a subscription language (that is a subset of relational database query languages), and uses rendezvous points (RPs) to gather and disseminate publications. Unfortunately their results show that it cannot meet the performance requirements for MMOGs due to the routing delay introduced by their architecture <ref type="bibr" target="#b3">[3]</ref>.</p><p>In the game industry, very few networked games are fully distributed. One notable exception is Age of Empires (AoE) <ref type="bibr" target="#b2">[2]</ref>, in which games are synchronized across clients and peerto-peer communication is used. AoE's protocol is similar to bucket synchronization, except that unicast is used. While AoE is a commercial success for distributed game protocols, it is subject to all but the inconsistency cheat (because players periodically exchange hashes of the game state with other players to detect inconsistencies).</p><p>Finally, we note that the area of distributed interactive simulation (DIS) addresses some of the same issues, but all participants are trusted, so the DIS protocols do not attempt to prevent packet-level cheating.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">TOWARDS A PEER-TO-PEER GAME ARCHITECTURE</head><p>We are developing a fully distributed MMOG architecture based on four components. First, an authenticating component is responsible for allowing or denying players access to the game. Second, a communication component determines how players send messages to each other. Third, the storage component provides long-term storage for world state. Last, the computation component determines how computations are distributed to players in the game. Figure <ref type="figure" target="#fig_0">1</ref> shows our architecture.</p><p>The authenticating component provides several necessary functions. First, every player is uniquely identified in the game, through a mechanism such as a public-key system or registration in the game with something such as a credit card number. This feature allows the system to determine if any two identifiers belong to the same individual. Further, it allows the game to permanently remove players and prevents a single player from joining the game simultaneously with multiple identities. Second, we assume the authenticating component can generate keys for the game and authenticate  players. We call this function the authenticating directory (AD) service, which allows an authenticated player to locate current players and allows authenticated players to present proof that a player was cheating in order to permanently ban another player from the game.</p><p>The communication component uses a self-organizing hierarchy that mirrors the structure of the virtual world. This model works well with games because events in one part of the world do not affect other parts of the world. In each part of the virtual world, players form a peer-to-peer network in order to exchange event messages. These networks are at a very small granularity, such as a room within a building, as determined by how far events must propagate to reach the affected players. Some events affect multiple groups, such as the lights going off in a building; in these cases, the event is propagated through the world hierarchy by group leaders in each peer-to-peer network.</p><p>The storage component, which stores long-term game state, is comprised of a distributed hash table (DHT), such as CAN <ref type="bibr" target="#b13">[13]</ref> or Chord <ref type="bibr" target="#b14">[14]</ref>, and security and reliability services. A large amount of research is currently being performed on peer-to-peer file systems (such as OceanStore <ref type="bibr">[9]</ref> or CFS <ref type="bibr" target="#b5">[5]</ref>), and we hope to leverage this work and determine how it meets the needs of a distributed MMOG. Particular concerns include long-term persistent storage and fast and secure updates.</p><p>The last component, the computation component, is used to schedule game computations among the players. We are currently researching scheduling techniques <ref type="bibr" target="#b11">[11]</ref> to determine efficient algorithms to schedule computations on players' processors, though games have unique requirements. For example, the artificial intelligence (AI) of a monster should be activated when a player approaches it within some distance. However, the players directly interacting with the monster cannot be trusted to accurately compute the AI of the monster. On the other hand, the AI should be verified by several other players to make sure that collusion doesn't occur between distant players. The implication of these needs is that a scheduler must be able to make decisions about who can execute processes in the game and results must be verified to prevent cheating.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">LOW DELAY EVENT ORDERING</head><p>Our current focus is on designing the communications component for our distributed game architecture. In particular, we are focusing on event ordering at the lowest level in the communications hierarchy-within a group of players that may be in the same room of a building. To provide this local ordering, we use a global clock to mark when events occur, but this leads to the challenging problem of trusting whether an event actually occurred at the time a player asserts that it has. In the rest of this paper, we focus on this problem in isolation; we recognize that several challenging problems remain, such as splitting and merging groups of players, and propagating events along the communications hierarchy.</p><p>Lockstep is the first event-ordering protocol to address the issue of cheat prevention. To guarantee that events have occurred at the stated time, lockstep orders events by rounds, incrementing a round only after every player has committed their move for that round. The price of this total ordering of events is a delay that is proportional to the largest delay between any two players.</p><p>To understand this problem more clearly, let us assume we have a multi-player game with a group of players located in the US and all in the same virtual location in the game. Under the lockstep protocol, the players must all exchange messages. At time t, a new player arrives in the same virtual location, but is connecting from Mongolia. A quick measurement shows the average round-trip time from the US to Mongolia is 728ms. This new player will force all players to proceed in lockstep, which requires 3 times the longest delay between players (due to the use of reliable transport). Assuming links are symmetric, rounds will progress at the rate of 1 round per 1,092ms, assuming that no packets are lost. Typically, the desired round time is an order of magnitude smaller <ref type="bibr" target="#b6">[6]</ref>.</p><p>Our protocol, inspired by bucket synchronization in <ref type="bibr" target="#b6">[6]</ref>, uses rounds to order events. The length of a round is bounded by a maximum latency, ensuring that players can receive updates in a timely fashion. To prove that an event occurred at its stated time, a player must be able to send her update to a majority of other players within the round duration. This proof is communicated to all the players through a round of voting, indicating which messages each user has received during the round duration. As long as a majority of players receive updates on time, then with the situation above, the slow player from Mongolia will not affect the round duration. The tradeoff is that a player who is slow to most other players will also not be able to play in this area of the virtual world. However, we feel this tradeoff is preferable to making the game unplayable for everyone.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">NEW-EVENT ORDERING PROTOCOL</head><p>The New-Event Ordering (NEO) protocol is the first protocol that totally orders events generated by a distributed group, avoids five common protocol level cheats, has a playout latency that is independent of network conditions, and adapts to changing network conditions to optimize its performance.</p><p>NEO is purposely agnostic regarding the underlying message propagation system. Unicast, multicast, or some type of overlay could be used to send messages, though the use of something other than unicast or native multicast could introduce new ways of cheating (such as not forwarding messages). However, this flexibility allows us to have alternatives when considering the extreme case of everyone in a game going to the same location in the virtual world and having to exchange messages. In this case, group density could be used to trigger a switch to multicast, for example.</p><p>With NEO, the majority always rules. This has the benefit that the protocol will adapt so that the majority of players are receiving the best possible performance. However, this also means that if a majority of players can collude and cheat, then NEO will not be able to prevent it. We address this problem under Collusion Cheats below.</p><p>In our discussion of NEO, we assume that all players are in the same location of a virtual world, that all players know of each other and communicate via UDP over unicast, that any player can authenticate the message of another player through signatures, and that game time is synchronized between players using a time synchronizing protocol such as NTP <ref type="bibr" target="#b12">[12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Basic NEO Protocol</head><p>For simplicity, we start with a basic NEO protocol that prevents only the suppressed update and timestamp cheats. We later extend this protocol to address the other three protocol level cheats.</p><p>In NEO, time is broken into equal intervals, called rounds, in which each player sends an update to all other players. Each update is encrypted, and in the following round, each player sends the key for the previous update to all other players.</p><p>NEO uses rounds in order to bound the maximum delay that any player can have for sending their update. Late updates are considered invalid, unless a majority of other people have received them. This means that unlike the lockstep or sliding pipeline protocol, which have playout latencies bounded by 3 times the maximum latency between any two players, NEO bounds its playout latency by only 2d, where d is the round length and is independent of any player's latency. This allows game developers to choose how big or small the round length is, and therefore the responsiveness of the game.</p><p>Presumably, the maximum round length is the maximum amount of time a round can be for a game to be playable. Thus, any player who cannot reach a majority of players within the maximum round length cannot play the game with those players. This is acceptable, since the game is unplayable when a player's delay is beyond the maximum round length.</p><p>Each message contains a time-stamped, signed, encrypted update, a key for the previous round, and a signed bit-vector of messages received from the previous round. For example, a message M from player A at round r has the following format:</p><formula xml:id="formula_0">M r A = E(SA(U r A )), K r-1 A , SA(V r-1 A ) (1) In this message, E(x) is an encrypted x, SA(x) represents A's signature on x, U r</formula><p>A is the update from player A for round r, K r-1 A is A's key for the update from round r -1, and V r-1 is the bit vector of votes for messages (defined shortly) received during round r -1.</p><p>Because a player releases her key for an update immediately after the end of the round, she cannot accept any late updates. However, each player may have a different set of updates that arrived on time for a given round. To maintain consistency, players accept an update only if a majority of players received the update on time.</p><p>Consistency is achieved through a distributed voting mechanism. A player votes positive for another player if the other player's update was received on time; otherwise, she votes negative. An update is considered valid only if a majority</p><formula xml:id="formula_1">Table 1: Player A's Table of Votes Player Bit-vector A 1 1 0 1 0 B 0 1 0 1 0 C 1 1 1 0 0 D 1 1 1 1 1 E packet lost Voting tally 3 4 2 3 1</formula><p>of the players send a positive vote. Each round the players tally the votes they have and decide which updates are considered valid. Any votes which are not received are considered abstentions; however, a majority of votes must be received for the vote to be considered valid. If not enough votes are received, the players must attempt to contact the players that abstained from the vote.</p><p>To understand how voting works, assume five players are in a game, and player A is tallying the votes from the previous round. Also assume that a majority is greater than 50%. Table <ref type="table">1</ref> lists the voting bit-vectors that each player has sent to player A. From the tally, we can conclude that a majority received A, B and D's updates, while a majority did not receive E's update (so it is considered invalid). As for player C, player A cannot determine what the outcome of the vote is, so she must contact another player to determine the outcome.</p><p>The primary reason for voting is that it allows rounds to progress without needing to hear from every player every round. This decouples the playout latency from the players' latency because round progression no longer relies on reliable communication. Assuming that a majority of players are receiving updates and votes, NEO will continue to progress through rounds<ref type="foot" target="#foot_0">1</ref> . On the other hand, with lockstep and the sliding pipeline protocols, if just one player drops an update, all players must wait until that update is recovered before the game can progress to the next round.</p><p>The secondary reason for using voting is that we only want to reconcile a minority of players at any time in order to keep the majority of players happy. Recall that dead-reckoning is being used between rounds so that if a player has to adjust their simulation, it is because she is with a minority of players whose game state differs from the majority.</p><p>In <ref type="bibr" target="#b7">[7]</ref>, we prove the safety and liveness of NEO, but omit the proof here due to space constraints. The safety and liveness proof tells us that the fixed-delay and timestamp cheats are not possible under NEO and that NEO always progresses. Safety can be understood intuitively because a key is never sent until the round is over, at which point no new moves for the round can be generated. We prove liveness by showing that round numbers increase monotonically with real time and that NEO does not halt for any reason, even in the face of inadequate votes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">NEO with Pipelined Rounds</head><p>In the basic protocol, the delay from each player to the majority of other players is bounded by the duration of the round. Increasing the round length increases the frequency with which the game must dead-reckon the positions and actions of other players. During this period of dead-reckoned time, the game is inconsistent and unresponsive. To address these problems, NEO pipelines its rounds, similar to the technique of pipelining instructions in a processor and to the SP protocol <ref type="bibr" target="#b4">[4]</ref>. The pipeline depth is related to the round duration and the round arrival delay, as seen in Figure <ref type="figure" target="#fig_1">2</ref>. This relationship can be expressed in the following formula:</p><formula xml:id="formula_2">pipeline depth = round duration arrival delay<label>(2)</label></formula><p>Using pipelined rounds does not significantly change our basic protocol, except with regard to sending out the key to our encrypted update and how often updates are sent out. A dependency exists between the end of the round that an encrypted update is sent out and the beginning of the round that the key is sent out (see Figure <ref type="figure" target="#fig_1">2</ref>). Similar to a dependency in a processor pipeline where we must wait until the dependency has passed to execute a new instruction, we must wait until the round with the update has passed before we can send the key for the update. For example, if a round starts at t=80ms and the round duration is 120ms, then the key must not be sent until t=200ms. We can now generalize Equation 1 using the pipeline depth d and round number r for player A in the following equation:</p><formula xml:id="formula_3">M r A = E(SA(U r A )), K r-d A , SA(V r-d A )<label>(3)</label></formula><p>As the sending rate of updates increases, the responsiveness and visual smoothness of the game increase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Security</head><p>Now we explain how NEO prevents the cheats from Section 2:</p><p>Fixed-Delay Cheat: NEO addresses this cheat through the use of bounded round lengths. Late updates are simply ignored by everyone.</p><p>Timestamp cheat: NEO prevents this cheat through the use of bounded round lengths. Once a round has passed, a player can no longer submit a move for that round; therefore it is impossible to receive a decrypted update before submitting the move for the previous round.</p><p>Suppressed Update Cheat: NEO adjusts the sending rate of Eve's opponents, as described in Section 7. Eve's missing packets signal congestion to NEO, so that her opponents will stop sending their updates to her. Thus, she no longer has an advantage by suppressing updates since she will no longer receive her opponent's updates either. If a player crashes, they will simply be ignored by other players until they are removed from the system.</p><p>Inconsistency Cheat: NEO addresses this cheat through the use of digital signatures and state comparison. Players periodically audit game state by performing a state comparison. When two players discover different state, the trail of packets they have received can be used as evidence against a cheating player. Using the authentication component of our architecture, cheating players can be permanently removed from the game once this proof is provided.</p><p>Collusion Cheat: NEO addresses collusion at the architectural and protocol levels. First, NEO can adjust the majority value sufficiently high to prevent collusion. Second, the AD service prevents players from logging in multiple times and artificially gaining a majority. Third, the communication component of our architecture can randomly select witnesses for a NEO group. As the number of witnesses increase, the probability that a group of colluding players can form a majority decreases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">PERFORMANCE ENHANCEMENTS</head><p>In order to improve performance and to react to network congestion, we modify NEO to dynamically adjust the round duration and sending rate. To prevent synchronization problems and to re-synchronize disconnected players who have returned, NEO updates include the starting time of the round, the round duration, and the current sending rate. Over the long term, if any player consistently receives late messages, she can re-synchronize her game state with the other players (as when joining the game).</p><p>Adjusting the round duration and sending rate is a tradeoff in performance and overhead. Shorter rounds allow games to be more responsive to players, and higher sending rates decrease the dead-reckoned time and jitter. NEO uses peerto-peer voting to find a consensus for adjustment; more frequent voting produces quicker reaction to network conditions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Adjusting the Round Duration</head><p>Because players send out their updates at the start of each round, each player can record the delay from other players to herself. Early updates indicate that the round duration can be decreased, from the perspective of that player, while late updates indicate that the round duration should be increased. NEO uses a weighted average over the last several rounds to avoid reacting to transient congestion. Once votes are collected and a majority of votes are for an adjustment, the new round duration and the time for the round change are advertised to all players.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Adjusting the Sending Rate</head><p>In addition to adjusting the round length, NEO should react to congestion as indicated by dropped packets. Every player in the game can measure her own loss rate and other players' late packets. Players can adjust the sending rate locally and globally, to react to short-term and long-term congestion.</p><p>A player adjusts her sending rate locally by purposely skipping updates. Skipped updates decrease responsiveness in the game, but due to the voting mechanism in NEO, other players will not need to retrieve her skipped update. Players vote to globally adjust the sending rate in response to long term congestion. Each player keeps a weighted average of their local loss rate. When a majority of votes for a global rate adjustment is collected, the new rate and time of the rate change is advertised to the players.</p><p>A player may also adjust her local sending rate in order to prevent the suppressed update cheat. Because a cheater may purposely skip updates, we want to ensure that a player never sends more updates than she is receiving. To achieve this, each person may skip updates to a particular player whenever her rate exceeds that player's rate. Any player that attempts to suppress packets to another player will find that the other player will immediately begin to suppress messages in return.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">FUTURE WORK</head><p>While we can analyze the performance of NEO, certain aspects of NEO are difficult to characterize. We plan to explore NEO's performance through simulation and implementation, comparing NEO's performance with both the lockstep and sliding pipeline protocols. We plan to test NEO's adaptive qualities. Considering the amount of traffic that online games generate as they become more popular each year, we feel that any communication protocol for games should "play fair" with TCP. Beyond NEO, we plan to continue developing our architecture. The next step is to design the protocols for group management and event propagation to test their feasibility. After that, we will design the storage and computation components.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Our peer-to-peer game architecture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Pipelining rounds in NEO.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>If a majority of players are not receiving updates from each other, then the game is unplayable. But this holds true for any game, distributed or not!</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* This work was supported in part by the National Science Foundation under grant ANI-9977524. † Supported by an NSF Graduate Research Fellowship ‡ Supported by an NSF Research Experience for Undergraduates grant</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Cheat-proof Playout for Centralized and Distributed Online Games</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">E</forename><surname>Baughman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">N</forename><surname>Levine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Infocom</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">1500 archers on a 28.8: Network Programming in the Age of Empires and Beyond</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bettner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Terrano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Game Developer&apos;s Conference</title>
		<imprint>
			<date type="published" when="2001-03">March 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Mercury: A Scalable Publish-Subscribe System for Internet Games</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Bharambe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Seshan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">1st workshop on Network and System Support for Games</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="3" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Cheat-Proofing Dead Reckoned Multiplayer Games</title>
		<author>
			<persName><forename type="first">E</forename><surname>Cronin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Filstrup</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jamin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Intl. Conf. on Application and Development of Computer Games</title>
		<imprint>
			<date type="published" when="2003-01">January 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Wide-area Cooperative Storage with CFS</title>
		<author>
			<persName><forename type="first">F</forename><surname>Dabek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Karger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SOSP</title>
		<meeting>SOSP</meeting>
		<imprint>
			<date type="published" when="2001-10">Oct 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A Distributed Architecture for Multiplayer Interactive Applications on the Internet</title>
		<author>
			<persName><forename type="first">C</forename><surname>Diot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Gautier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Networks</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1999-08">July/August 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Low-Latency and Cheat-Proof Event Ordering for Distributed Games</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gauthierdickey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zappala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Marr</surname></persName>
		</author>
		<idno>CIS-TR-2004-2</idno>
		<imprint/>
		<respStmt>
			<orgName>University of Oregon</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">End-to-End Transmission Control Mechanisms for Multiparty Interactive Applications on the internet</title>
		<author>
			<persName><forename type="first">L</forename><surname>Gautier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Diot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kurose</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Infocom</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">OceanStore: An Architecture for Global-Scale Persistent Storage</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kubiatowicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bindel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Czerwinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Eaton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Geels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gummadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rhea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Weatherspoon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wells</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM ASPLOS</title>
		<imprint>
			<date type="published" when="2000-11">November 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The Byzantine Generals Problem</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Shostak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pease</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="page" from="382" to="401" />
			<date type="published" when="1982-07">July 1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Cluster Computing on the Fly: P2P Scheduling of Idle Cycles in the Internet</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zappala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IPTPS</title>
		<imprint>
			<date type="published" when="2004-03">March 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Postel</surname></persName>
		</author>
		<title level="m">Network Time Protocol. RFC 1305</title>
		<imprint>
			<date type="published" when="1992-03">March 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A Scalable Content-Addressable Network</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ratnasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Francis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Handley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Karp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Schenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGCOMM</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Chord: A Scalable Peer-to-Peer Lookup Service for Internet Applications</title>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Karger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGCOMM</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="149" to="160" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
