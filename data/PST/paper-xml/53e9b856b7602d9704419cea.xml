<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An extension of the Burrows-Wheeler Transform $</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">S</forename><surname>Mantaci</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Dipartimento di Matematica ed Applicazioni</orgName>
								<orgName type="institution">University of Palermo</orgName>
								<address>
									<addrLine>Via Archirafi 34</addrLine>
									<postCode>90123</postCode>
									<settlement>Palermo</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">A</forename><surname>Restivo</surname></persName>
							<email>restivo@math.unipa.it</email>
							<affiliation key="aff0">
								<orgName type="department">Dipartimento di Matematica ed Applicazioni</orgName>
								<orgName type="institution">University of Palermo</orgName>
								<address>
									<addrLine>Via Archirafi 34</addrLine>
									<postCode>90123</postCode>
									<settlement>Palermo</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">G</forename><surname>Rosone</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Dipartimento di Matematica ed Applicazioni</orgName>
								<orgName type="institution">University of Palermo</orgName>
								<address>
									<addrLine>Via Archirafi 34</addrLine>
									<postCode>90123</postCode>
									<settlement>Palermo</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">M</forename><surname>Sciortino</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Dipartimento di Matematica ed Applicazioni</orgName>
								<orgName type="institution">University of Palermo</orgName>
								<address>
									<addrLine>Via Archirafi 34</addrLine>
									<postCode>90123</postCode>
									<settlement>Palermo</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">An extension of the Burrows-Wheeler Transform $</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">4E7EA1A5513345AC0BE6C6B153FAADE8</idno>
					<idno type="DOI">10.1016/j.tcs.2007.07.014</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:15+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Burrows-Wheeler transform</term>
					<term>Sequence comparison</term>
					<term>Alignment-free distance measure</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We describe and highlight a generalization of the Burrows-Wheeler Transform (bwt) to a multiset of words. The extended transformation, denoted by ebwt, is reversible. Moreover, it allows to define a bijection between the words over a finite alphabet A and the finite multisets of conjugacy classes of primitive words in A * . Besides its mathematical interest, the extended transform can be useful for applications in the context of string processing. In the last part of this paper we illustrate one such application, providing a similarity measure between sequences based on ebwt.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="0.">Introduction</head><p>In 1994 Michael Burrows and David Wheeler introduced (cf. <ref type="bibr" target="#b0">[1]</ref>) a reversible transformation on words (called the Burrows-Wheeler Transform after their names, and denoted by bwt) that aroused considerable interest and curiosity in the field of Data Compression.</p><p>Almost at the same time, in 1993, Ira M. Gessel and Christophe Reutenauer produced a paper in the field of combinatorics on permutations (cf. <ref type="bibr" target="#b6">[7]</ref>), where a technique was introduced in order to find a bijection between words over a given alphabet and multisets of conjugacy classes of primitive words, over the same alphabet.</p><p>In <ref type="bibr" target="#b3">[4]</ref> Crochemore, Désarménien and Perrin show the strict connection between the Burrows-Wheeler transformation and the Gessel-Reutenauer bijection. In fact they remarked that the Burrows-Wheeler Transform is connected to a particular case of the bijection given by Gessel and Reutenauer. This important remark has inspired the extension of the Burrows-Wheeler Transform (denoted by ebwt) to a multiset of primitive words that we introduce in the present paper. Notice that this is not the only extended version of the bwt. In fact, for instance, in <ref type="bibr" target="#b5">[6]</ref> Ferragina et al. formalize an extension of the Burrows-Wheeler Transform to trees.</p><p>The heart of this paper is mainly devoted to describing the formal definition of the extended Burrows-Wheeler transformation and to give its algorithmic construction. As for bwt, we show, by providing a suitable algorithm, that such an extended transformation is reversible, that is, it is possible to recover the original multiset S, once that its image by ebwt is known. We also show some of the properties of ebwt, in particular that, differently from the classical bwt, any word can be obtained as output of ebwt. The study of ebwt allows also to highlight and realize some distinctive features of bwt.</p><p>We remark that such an extended transformation, besides being an interesting combinatorial tool for the study of properties of sets of words, is also motivated by a couple of application. In <ref type="bibr" target="#b12">[13]</ref> the authors show that such an extended transformation can be used as a preprocessing step for a new compression method, that in some cases is more effective than the technique used by most bwt-based compressors.</p><p>In the last part of this paper we illustrate a second application of ebwt, consisting in a new method for comparing sequences. This method is based on the observation that a special feature of ebwt is that the greater is the number of segments shared by two words u and v, the greater is the mixing of symbols coming from u and v in the output of the transformation, applied on the set {u, v}. Therefore, ebwt can be applied in order to define a new combinatorial method for comparing sequences, that, intuitively, takes into account how much the characters of the words to be compared are shuffled by the transformation ebwt. The implementation of this intuitive idea can have several different formalizations. In order to give the flavor of the applicative aspect of this transformation, in Section 5 we give one possible formalization of the comparison method based on the extended transformation, expressed by the distance measure δ. A deeper study of the comparison method based on ebwt has been developed in <ref type="bibr" target="#b14">[15]</ref>, where different formalizations of distance measures are given. Note that the distance measures based on ebwt can be placed in the context of alignment-free distances (cf. <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b8">9]</ref>), and it is particularly suitable, for instance, to capture evolutionary relations between biological sequences of different species.</p><p>In the last section the comparison method described here is validated by applying the distance δ to the whole mitochondrial genome phylogeny problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Preliminaries</head><p>The Burrows-Wheeler transform (bwt from now on) was introduced in 1994 by <ref type="bibr">Burrows and</ref> Wheeler <ref type="bibr" target="#b0">[1]</ref> and it represents an extremely useful tool for textual lossless data compression. The idea is to apply a reversible transformation in order to produce a permutation of the characters of an input string w, defined over an alphabet A, so that the string becomes easier to compress. Actually the transformation leads to group characters together so that the probability of finding a character close to another instance of the same character is substantially increased. The goal of this section is to give the description of the working of bwt in order to introduce the notation and some properties that will be used in next sections.</p><p>Let A be a finite ordered alphabet. We denote by A * the set of words over A. We say that two words x, y ∈ A * are conjugate if x = uv and y = vu for some u, v ∈ A * . A word x is called a cyclic shift or a cyclic rotation of y if x and</p><formula xml:id="formula_0">y are conjugate. A word v ∈ A * is primitive if v = u n implies v = u and n = 1.</formula><p>The transformation bwt processes a word w = w 1 • • • w n by constructing all n cyclic rotations of w and sorting them lexicographically. The output of bwt(w) consists of the pair (L, I ), where L is the sequence of the last character of each rotation in the sorted list and I is the position of the original word in the list.</p><p>For instance, suppose we want to compute bwt(w) where w = abraca. Consider the matrix M, shown in Fig. <ref type="figure" target="#fig_0">1</ref>, which consists of all cyclic shifts of w, lexicographically sorted.</p><p>The last column L = caraab of the matrix and I = 2 are the output of bwt. The first column F, instead, contains the sequence of the characters of w lexicographically sorted.</p><p>In <ref type="bibr" target="#b0">[1]</ref> the following properties concerning bwt have been proved:</p><p>(1) For all i = 1, . . . , n, i = I , the character L[i] is followed by F[i] in the original string;</p><p>(2) for each character z, the ith occurrence of z in F corresponds to the ith occurrence of z in L.</p><p>From the above properties it follows that the Burrows-Wheeler transform is reversible in the sense that, given L and the index I , it is possible to recover the original string w. Actually, according to Property 2, we can define a permutation τ : {1, . . . , n} → {1, . . . , n} giving the correspondence between the positions of characters of the first and the last column of the matrix M. The function τ represents also the order in which we have to rearrange the elements of F to reconstruct the original word w. Hence, starting from the position I , we can recover the word w as follows:</p><formula xml:id="formula_1">w i = F[τ i-1 (I )]</formula><p>, where τ 0 (x) = x, and τ i+1 (x) = τ (τ i (x)).</p><p>We show, for instance, how the reconstruction works for the example in Fig. <ref type="figure" target="#fig_0">1</ref>:</p><formula xml:id="formula_2">τ = 1 2 3 4 5 6 2 4 5 6 1 3 , w 1 = F[2] = a w 2 = F[4] = b w 3 = F[6] = r w 4 = F[3] = a w 5 = F[5] = c w 6 = F[1] = a.</formula><p>If we do not care about the index I , the Burrows-Wheeler Transform defines a map BWT from A * to itself such that if w is a words of A * , BWT (w) is the word L obtained by concatenating the characters in the last column of the matrix of sorted cyclic rotations. Proposition 1. Two words x, y ∈ A * are conjugate if and only if BWT (x) = BWT (y).</p><p>Proof. Note that if x and y are conjugate then bwt(x) = (L , I x ) and bwt(y) = (L , I y ). So, BWT (x) = BWT (y). Conversely, if BWT (x) = BWT (y), since the permutation τ for the inverse transformation is univocally defined, the only difference between bwt(x) and bwt(y) can be in the choice of the index, corresponding to the choice of different conjugates. Then either x = y (if I x = I y ) or x is a conjugate of y (if I x = I y ).</p><p>The proposition stated below shows that there exists a relation between the image by BWT of a word and the power of the word itself. The proof of this proposition can be found in <ref type="bibr" target="#b15">[16]</ref>:</p><formula xml:id="formula_3">Proposition 2. For u, v ∈ A * , u is a conjugate of v d if and only if BWT (v) = a 1 • • • a n and BWT (u) = a d 1 • • • a d n .</formula><p>By Proposition 1, it follows that BWT is not injective, but it defines an injective mapping from the set of all conjugacy classes of words in A * to A * . However, the following example shows that BWT is not surjective.</p><p>Example 3. Let us consider the sequence u = bccaaab. By applying the reverse of bwt, it is easy to verify that there exists no sequence w such that BWT (w) = u.</p><p>Note that the function BWT has been recently studied from a combinatorial point of view (see <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b15">16]</ref>). For instance in <ref type="bibr" target="#b15">[16]</ref> it is proved that BWT provides a further characterization of Standard Words (cf. <ref type="bibr" target="#b11">[12,</ref><ref type="bibr">Chapter 3]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">The Extended Burrows-Wheeler Transformation</head><p>This section is devoted to describe an extension of the Burrows-Wheeler Transform to a multiset of words and to illustrate some of its properties. Such an extension is strictly related to a bijection, introduced by Gessel and Reutenauer in 1993, between the multisets of words over a finite alphabet A and the words of A * . In a recent paper <ref type="bibr" target="#b3">[4]</ref> Crochemore, Désarménien and Perrin have shown that the Burrows-Wheeler Transform is connected to a particular case of the bijection given by Gessel and Reutenauer. This important remark has inspired the definition of the extension of the Burrows-Wheeler Transform (denoted by ebwt) to a multiset of primitive words, described in the present paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">A new order relation between words</head><p>In order to define the extended transformation we need to introduce an order relation between words, that is different from the usual lexicographical one.</p><p>Recall that (cf. <ref type="bibr" target="#b10">[11]</ref>) every word v ∈ A * can be written in a unique way as a power of a primitive word, i.e. there exists a unique primitive word w and a unique integer k such that v = w k . We denote w by root(v) and k by exp(v).</p><p>If u is a word in A * , we denote by u ω the infinite word obtained by infinitely iterating u, i.e. u ω = uuuuu . . .. The lexicographic ordering &lt; lex is naturally defined on infinite words. Given two infinite words x = x 1 x 2 . . . and y = y 1 y 2 . . ., with x i , y i ∈ A, we say that x &lt; lex y if there exists an index j ∈ N such that x i = y i for i = 1, 2, . . . , j -1 and x j &lt; y j . Note that if x = y, the relation &lt; lex is not defined. Remark that u ω = v ω if and only if root(u) = root(v). Definition 4. Let u, v be two words over a finite alphabet A. We say that</p><formula xml:id="formula_4">u ω v ⇐⇒ exp(u) ≤ exp(v) if root(u) = root(v) u ω &lt; lex v ω otherwise.</formula><p>It is easy to verify that ω is a total order. We also remark that this order relation is different from the lexicographic one. For instance ab &lt; lex aba but aba ω ab. Although when root(u) = root(v) the ω -order of u and v is defined by using infinite words, the following proposition shows that it is possible to decide their mutual ω -ordering by extending them up to the length |u| + |v| -gcd(|u|, |v|). Such a bound is a consequence of a well-known result of Periodicity on Words, the Fine and Wilf Theorem (cf. <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b10">11]</ref>). For a given finite or infinite word w, we denote by pr e f k (w) the prefix of w of length k. Proposition 5. Given two words u and v, with root(u) = root(v),</p><formula xml:id="formula_5">u ω v ⇐⇒ pr e f k (u ω ) &lt; lex pr e f k (v ω ),</formula><p>where k = |u| + |v| -gcd(|u|, |v|).</p><p>Proof. If neither u is a prefix of v nor v is a prefix of u, then u ω v if and only if u &lt; lex v. So it suffices to consider the length of the shortest sequence, in order to decide the mutual ω -ordering of u and v. Let us consider the case where one sequence is a prefix of the other one, for instance u is a prefix of v. In this case we need to iterate u and v, respectively, until we find out the first index i such that the ith character of u ω is different from the ith character of v ω . The Fine and Wilf theorem guarantees that i ≤ |u| + |v| -gcd(|u|, |v|). In fact, if we had that u ω equals v ω up to the length |u| + |v| -gcd(|u|, |v|), then we would have that the prefix of u ω of length |u| + |v| -gcd(|u|, |v|) would be a sequence having two periods, |u| and |v|, but not their greatest common divisor, since u and v are not powers of the same sequence.</p><p>The bound given in Proposition 5 is tight: this is a consequence of the tightness of such a bound in the Fine and Wilf Theorem. Example 6. We can consider the words u = abaab and v = abaababa. One can see that v ω u and u ω and v ω differ for the character in position 12</p><formula xml:id="formula_6">= 5 + 8 -1. Remark also that u &lt; lex v. u abaab u abaab u ab • • • abaababa v abaa • • • v 2.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">The Extended Burrows-Wheeler Transform</head><p>We introduce now the transformation ebwt under the hypothesis that the words considered are primitive. Actually this hypothesis is not very restrictive, since in practice almost all the processed texts are primitive (or become primitive by adding an end-of-string symbol). Let S = {u 1 , . . . u k } be a multiset of (not necessarily distinct) primitive words of A * . We denote by</p><formula xml:id="formula_7">M C pr e f 6 M L M χ M F 1 abac abacab c 1 a 2 abc abcabc c 0 a 3 abcb abcbab b 0 a 4 acab acabac b 0 a 5 acb acbacb b 0 a 6 babc babcba c 0 b 7 baca bacaba a 0 b 8 bac bacbac c 0 b 9 bca bcabca a 1 b 10 bcba bcbabc a 0 b 11 caba cabaca a 0 c 12 cab cabcab b 0 c 13 cbab cbabcb b 1 c 14 cba cbacba a 1 c</formula><formula xml:id="formula_8">S = k i=1 |u i |</formula><p>and by</p><formula xml:id="formula_9">H = max{|u i | + |u j | -gcd(|u i |, |u j |) | i, j = 1, . . . , k}.</formula><p>Consider the set C(S) of all the conjugates of the words in S. We can associate to each w ∈ C(S) the triplet ( pr e f H (w ω ), L(w), χ S (w)), where pr e f H (w ω ) is the prefix of w ω of length H , L(w) denotes the last character of w and χ S is the characteristic function of S, that is</p><formula xml:id="formula_10">χ S (w) = 1 if w ∈ S 0 otherwise.</formula><p>Consider the set of all these triplets and sort it by taking as sorting key the first field and using the &lt; lex relation. By Proposition 5, this sorting induces on the words of C(S) the same order as obtained by applying the ω -order relation on the words of C(S). We can arrange this sorted list in a table M(S). We denote by M L (S) and M χ (S) the sequences obtained by concatenating the second and the third components, respectively, of the triplets of the table M(S). Note that where there is no danger of ambiguity, we will use M, M L and M χ instead of M(S), M L (S) and M χ (S), respectively. If we denote by M C the sorted list, with respect to the ω -order, of the words in C(S), M L is the word obtained from the concatenation of the last characters of elements in M C and M χ is the characteristic vector saying which elements in the list are coming from S. Definition 7. The Extended Burrows-Wheeler Transform of a multiset S, denoted by ebwt(S), is the pair (M L , M χ ).</p><p>Remark 8. We note that, since in the word M χ the number of occurrences of 0's is larger than 1's, it could be more reasonable, from a computational point of view, to define ebwt(S) as the pair (M L , I), where I is the set of indices i such that M χ [i] is equal to 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>We can extend the table M by adding a new column</head><formula xml:id="formula_11">M F , such that M F [i] contains the first character of M C [i].</formula><p>Notice that since the elements in M C are ω -sorted, then the characters in M F are alphabetically sorted.</p><p>Example 9. Let S = {abac, cbab, bca, cba}. We represent in Fig. <ref type="figure" target="#fig_1">2</ref> the table M after the lexicographic sorting on the pr e f 6 's component (the second column) of its rows. For sake of clearness we add also the column (the first one) M C containing the ω -ordered list of all w ∈ C(S). The second column contains the &lt; lex -sorted list of prefixes of length H = 6, the third column the word M L and the fourth column the characteristic array of S, M χ .</p><p>The complexity of the algorithm for computing ebwt is upper bounded by the time needed to get the sorted list of the conjugates of the words in S, that can be handled by a suitable generalization of the suffix array. A generalization of the "skew algorithm" (cf. <ref type="bibr" target="#b7">[8]</ref>) for the construction of the generalized suffix array, allows to obtain such a sorted list in linear time on the total size of the set S. Then the algorithm has complexity O(||S||).</p><p>The following proposition shows two important properties connecting the characters of M L and M F .</p><p>Proposition 10. Let S be a multiset of primitive words and let ebwt(S) = (M L , M χ ). Let M F be the sequence of the first characters of the sorted list. The following properties hold:</p><formula xml:id="formula_12">(1) For every i such that M χ [i] = 0, M F [i] follows M L [i] in one word in S.</formula><p>(2) For a fixed character a ∈ A, its occurrences in M F appear in the same order as in M L , i.e. its kth instance of a in M F corresponds to its kth instance of a in M L .</p><p>Proof. The proof of Item 1 is quite straightforward. Since</p><formula xml:id="formula_13">M χ [i] = 0 then M C [i] ∈ S.</formula><p>Then it is a conjugate of one of the original words w ∈ S. This means that in w the character M L [i] is followed by the character M F [i]. In order to prove Item 2 we can consider the sequence M of words such that M [i] is obtained by rotating M C [i] one character to the right, so that the sequence M L appears as the concatenation of the first characters of the words in M . Notice that the words of M are ω -sorted starting from the second character. So for those words beginning with the same character a in M it is true that they must appear in ω -order to one another, since they are ω -sorted starting from the second character, and they all begin by a. So for any character a, the words in M C that begin with a are in the same relative order as the words in M that begin with a. This proves that the relative order of the different occurrences of a in M F and in M L are the same.</p><p>Remark 11. We note that, when the set S contains only one element, the extended transformation works exactly as the Burrows-Wheeler Transform. In fact, the ω -ordering of the cyclic shifts of a word is equivalent to the lexicographic one, because all the words have the same length. Moreover, according to Remark 8, the set of indices contains a single value. So, if S = {w}, then ebwt(S) = bwt(w).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">The inverse transformation</head><p>In this section we show that the extended transformation is reversible, that is, we can recover the original set S from ebwt(S).</p><p>Given the table M obtained in the computation of the ebwt, we can define a permutation θ on {1, . . . , S } as follows: θ (i) = j if M F [i] and M L [ j] correspond to the same character in a word of S, according with the Item 2 of Proposition 10. In other words, if M F [i]z is a conjugate of a word w 0 ∈ S, for some z ∈ A * , then the permutation θ associates i to the integer j corresponding to the position in the sorted list of the next left rotation of w 0 , that is</p><formula xml:id="formula_14">z M F [i] = z M L [ j].</formula><p>Remark 12. Notice that the construction of the permutation θ does not depend on the knowledge of M C but only on the knowledge of M L . In fact for each position i ∈ {1, . . . , S }, we can consider the symbol a</p><formula xml:id="formula_15">= M F [i]: if M F [i]</formula><p>is the hth occurrence of a in M F , then θ (i) = j, where j is the position where the hth occurrence of a appears in M L . Notice that Item 2 of Proposition 10 has as consequence that this permutation relates all and only the positions where the conjugates of the same word appear in the sorted list. This translates to the fact that the permutation θ can be decomposed into as many cycles as the number of words in the multiset S. This fact is of fundamental relevance for the invertibility of ebwt.</p><p>Theorem 13. The transformation ebwt that associates to a multiset S the pair (M L (S), M χ (S)) is injective.</p><p>Proof. Let S and T two multisets such that it holds (M L (S), M χ (S)) = (M L (T ), M χ (T )). Since M L (S) = M L (T ) then also M F (S) = M F (T ). This implies that the permutations θ S and θ T obtained by associating each character of M L (S) and M L (T ) with the same occurrence of that character in M F (S) and M F (T ), respectively, are equal. We recall also the well-known combinatorial property, that for any permutation there exists a unique decomposition into disjoint cycles:</p><formula xml:id="formula_16">θ S = θ T = σ 1 σ 2 • • • σ k .</formula><p>From Item 1 of Proposition 10, as noticed in Remark 12, one can derive that k is equal to the cardinality of the multiset, so S and T have the same number of words. Recall also that each σ i corresponds to a conjugacy class of a word in S and in T . We can reconstruct the words of S as described in the following. Because of primitivity of words in the multiset S, for every j = 1, . . . , k, there exists a unique index i such that M χ (S)[i] = 1, that is moved by σ j . Let i 1 , i 2 , . . . , i k be the indices where</p><formula xml:id="formula_17">M χ (S)[i 1 ] = M χ (S)[i 2 ] = • • • = M χ (S)[i k ] = 1.</formula><p>So, one can reconstruct each word in S by using Item 2 of Proposition 10:</p><formula xml:id="formula_18">u 1 = M F [i 1 ]M F [θ S (i 1 )]M F [θ 2 S (i 1 )] • • • M F [θ l 1 S (i 1 )], u 2 = M F [i 2 ]M F [θ S (i 2 )]M F [θ 2 S (i 2 )] • • • M F [θ l 2 S (i 2 )], • • • u k = M F [i k ]M F [θ S (i k )]M F [θ 2 S (i k )] • • • M F [θ l k S (i k )],</formula><p>where l 1 , l 2 , . . . , l k are the lengths of the cycles σ 1 , σ 2 , . . . , σ k , respectively. Since T is also a multiset of primitive words, θ T = θ S and M χ (T ) = M χ (S), we can easily deduce that T = S.</p><p>The previous proposition allows us to define the algorithm REVERSE that, given the extended transform of a multiset S of primitive words ebwt(S) = (M L , M χ ), is able to recover S. u := ; { is the empty word} 7.</p><p>j := i; 8. repeat 9.</p><p>u := u + M F [ j]; {+ is concatenation between strings} 10.</p><p>j := θ ( j); 11.</p><p>until j = i; 12.</p><p>S := S ∪ {u}; 13. Return S;</p><p>The following example describes the working of the algorithm REVERSE. By starting from the indices i = 1, 9, 13, 14 for which M χ [i] = 1, we get respectively the words Proof. Both M F in line 1 and θ in line 2 can be obtained by applying a counting sort algorithm, keeping the information of the corresponding positions of the elements in the unsorted and in the sorted arrays, during the construction of the sorted array. This is obtained in time O(||S||).</p><formula xml:id="formula_19">u 1 = M F [1]M F [7]M F [4]M F [11] = abac, u 2 = M F [9]M F [12]M F [2] = bca, u 3 = M F [13]M F [6]M F [3]M F [10] = cbab, u 4 = M F [14]M F [8]M F [5] = cba.</formula><p>Regarding to the cycle in line 4, the cost on the i's such that M χ [i] = 0 is constant (giving approximately a time O(||S||) on all of such elements), whereas for each j's such that M χ [ j] = 1, the cost is proportional to the length of the word recovered starting from j. By summing up on all these j's we get O(||S||). Then the total complexity of the algorithm REVERSE is O(||S||).</p><formula xml:id="formula_20">M C M L M χ M F 1 a a b b 0 a 2 a b b 1 a 3 a b a a 1 a 4 b a a 0 b 5 b a a a 0 b</formula><p>Fig. <ref type="figure">3</ref>. The table M associated to the set S = {ab, aba}, when the lexicographic order is applied for sorting the conjugates of the words in S.</p><p>Remark 16. Algorithm REVERSE does not work if we use, in the computation of ebwt, the lexicographic order instead of the ω -order because the Item 2 of Proposition 10 might not be true. For instance, if the lexicographic order is applied for the computation of the transformation on the set S = {ab, aba} (see the table M in Fig. <ref type="figure">3</ref>), one can notice that the first occurrence of b in M F would correspond to the second occurrence of b in M L . In this way the permutation θ would not satisfy Item 2 of Proposition 10, and the algorithm REVERSE would not work correctly. In fact the application of the algorithm REVERSE on (M L , M χ ) = (bbaaa, 01100) with this permutation θ would not recover the original set S. Actually REVERSE((bbaaa, 01100))={abaab, ababa}.</p><p>One can note that in order to assure the surjectivity of ebwt, we need the transformation to be defined on a multiset S and not simply on a set. Example 17 describes the working of algorithm REVERSE when some words of the recovered multiset are equal.</p><p>Example 17. Let M L = bbbbbaaaaabaaa and M χ = 00011001000000 be the input of algorithm REVERSE. We can obtain M F = aaaaaaaabbbbbb and the permutation θ defined as follows: The algorithm reconstructs the word abaab twice, by using the index 4 and the index 5, and the word abba by using the index 8. So, we get the multiset S = {abaab, abaab, abba}.</p><formula xml:id="formula_21">θ = 1 2<label>3</label></formula><p>Remark 18. According to the notation used in Remark 8, if ebwt(S) = (M L , I) and θ is the permutation defined between M F and M L , the set I should contain exactly one integer for each cycle in which θ is decomposed. Since ebwt(S) = bwt(w) when S = {w} (see <ref type="bibr">Remark 11)</ref>, it is easy to see that the words that are obtained as output of the Burrows-Wheeler Transform are exactly the ones where the permutation θ is a unique cycle. In this case the set I contains only one integer. For a characterization of the permutations defined by bwt see <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b11">[12,</ref><ref type="bibr">Chapter 11]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Combinatorial properties of the extended transformation</head><p>In this section we consider some properties of the extended transformation when we do not consider the characteristic vector M χ . In particular we prove the bijectivity that such a transformation induces between the family of the multisets of conjugacy classes and the set A * .</p><p>If we do not care about M χ in the output of ebwt, then we can define a map EBWT such that if S is a multiset of primitive words of A * , then EBWT (S) = M L (S), where M L (S) is the word obtained by concatenating the characters of the column M L of the table M obtained by ω -sorting the set C(S), as in the computation of ebwt(S).</p><p>The following lemma (cf. Proposition 1) shows that EBWT is not injective, but in the next theorem it is proved that this map induces a bijection on conjugacy classes. Such a result, that plays an important role both in Combinatorics on Words and in the study of Free Lie Algebras, was firstly synthesized in a theorem, due to Gessel and Reutenauer (cf. <ref type="bibr" target="#b6">[7]</ref>), and re-proved below by using the concepts and the notation introduced in the present paper.</p><p>We say that two multisets S and T are conjugate if there exists a bijection ϕ: S → T such that for each u ∈ S, ϕ(u) is a conjugate of u. Proof. If T and S are conjugate, then C(S) = C(T ). It follows, by the definition of the transformation ebwt, that EBWT (S) = EBWT (T ). Conversely, if EBWT (S) = EBWT (T ), then M L (S) = M L (T ). So, by using the same reasoning as in the proof of Theorem 13, we can deduce that θ S and θ T are equal, then they have the same decomposition in cycles, i.e. θ S = θ T = φ 1 φ 2 • • • φ k . From Item 1 of Proposition 10, as noticed in Remark 12, one can derive that k is equal to the cardinality of the multiset, so S and T must have the same number of words. Recall also that each φ i corresponds to a conjugacy class of a word in S and a word in T . Notice that, in the algorithm REVERSE, the role of M χ consists in characterize a representative in each conjugacy class. If we choose for each cycle an integer moved by the cycle itself, then by applying the algorithm REVERSE we can reconstruct a multiset of primitive words {w 1 , . . . , w k }, that is conjugate both to T and S. Then by transitivity, T and S are conjugate.</p><p>Theorem 20. The Extended Burrows-Wheeler Transform defines a bijection between A * and the family F of finite multisets of conjugacy classes of primitive words in A * .</p><p>Proof. Let S = {u 1 , . . . , u k } be a multiset of primitive words in A * . Let us denote by S the multiset of the conjugacy classes represented by the words in S, i.e. S = {[u 1 ], . . . , [u k ]} where [u] denotes the conjugacy class represented by u. Consider the function Φ: F → A * that is defined as follows: Φ( S) = EBWT (S). By previous lemma, it follows that Φ is well defined. Moreover, it also follows that Φ is injective. We prove that Φ is also surjective. In fact given any word L ∈ A * , it is always possible to obtain the sorted sequence F of the characters in L and determine the permutation θ associated to L and F. The permutation allows to apply the lines 3-13 of the Algorithm REVERSE in order to reconstruct a representative element of each conjugacy class belonging to S, by constructing M χ as follows. If θ = σ 1 σ 2 • • • σ k and σ 1 moves 1, we have to choose k integers i 1 , . . . , i k where i 1 = 1 and, for j = 2, . . . , k, i j is the smallest integer moved by σ j and initialize M χ [i j ] = 1 for j = 1, . . . , k. So we can always find a multiset S = {u 1 , . . . , u k } whose image by EBWT is L. It follows Φ( S) = L.</p><p>Where no confusion arises, we can identify EBWT and the bijection Φ defined in the proof of the previous theorem. So, where there is no danger of ambiguity, we will apply indifferently EBWT both to words and to conjugacy classes.</p><p>We can note that, as described in Remark 11 for ebwt, if the set S consists of only one word w then EBWT (S) = BWT (w). Nevertheless, differently from BWT , the function EBWT is also surjective. Actually, while there exist words that are not image by BWT of any word, it is always possible, for any word, to find a multiset S of conjugacy classes of primitive words such that the image of S by EBWT is equal to that word. An instance is given in the following example.</p><p>Example 21. Let w = bccaaab as in Example 3. It is easy to verify that w is the word obtained by applying EBWT to the conjugacy classes of the words ab and abcac.</p><p>Remark 22. The injectivity of the function EBWT on conjugacy classes defined in Theorem 20 does not hold if we use the lexicographic order instead of the ω -order. In fact, if we consider the conjugacy classes of the set S = {ab, aba} and the set T = {abaab}, and the lexicographic ordering between the conjugates is applied, we get in both case to the same sequence of "last symbols" bbaaa, as shown in Fig. <ref type="figure">4</ref>. The problem is that if we lexicographically sort the cyclic shifts of the words in S, Item 2 of Proposition 10 is not verified. Actually, as shown in Fig. <ref type="figure">4</ref>(a), the first occurrence of the character b in M F (S) corresponds to the second occurrence of b in M L (S).</p><p>Recall that a word u is a subword of a word</p><formula xml:id="formula_22">v = a 1 a 2 • • • a n , if there exist some indices 1 ≤ i 1 &lt; i 2 &lt; • • • &lt; i k ≤ n such that u = a i 1 a i 2 • • • a i k .</formula><p>The following propositions describe some interesting combinatorial properties of the transformation EBWT .</p><p>Proposition 23. Let S 1 and S 2 be two multisets of primitive words of A * . If S 1 ⊆ S 2 then EBWT (S 1 ) is a subword of EBWT (S 2 ).</p><p>Proof. It easily comes from the fact that the ω -ordering of elements in S 2 preserves the ω -ordering of elements in S 1 .</p><p>Recall that, given two words u, v ∈ A * , the shuffle of u and v, denoted by u • v, is the subset of A * defined as:</p><formula xml:id="formula_23">{u 1 v 1 u 2 v 2 • • • u n v n | n ≥ 0, u i , v i ∈ A * , u = u 1 u 2 • • • u n , v = v 1 v 2 • • • v n }.</formula><p>Proposition 24. Let X and Y be two multisets of primitive words of A * . If S = X ∪ Y , then EBWT (S) belongs to the set EBWT (X ) • EBWT (Y ).</p><p>Proof. Since X, Y ⊆ S, from Proposition 23 it follows that EBWT (X ) and EBWT (Y ) are subwords of EBWT (S). So, by definition of the shuffle operator, the thesis follows.</p><p>The shuffle is an associative operation, so we can trivially define the shuffle of a sequence of words.</p><p>Corollary 25. Given S = {u 1 , . . . , u k }, then EBWT (S) is an element of the shuffle BWT (u 1 )</p><formula xml:id="formula_24">• BWT (u 2 ) • • • • • BWT (u k ).</formula><p>Proof. The proof comes from the previous proposition and from the fact that, by using Remark 11, if the multiset S consists of only one word w, then EBWT (S) = BWT (w).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Comparing sequences by using ebwt</head><p>In this section we apply our extended transformation ebwt in order to introduce a new method for comparing sequences. The new distance between words defined here is simple and efficient to compute, and it is particularly advantageous in the case of comparison of a set of sequences. We remark that our distance is not based on sequence alignment. Several alignment-free distance measures have recently been introduced (see for instance <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b8">9]</ref> and references therein) since they better fit with the problem of comparing genomic sequences than the methods based on sequence alignment. In fact, alignment-based methods compare sequences by considering only local edit operations on their fragments. Instead, the recent developments in genome sequences technologies have allowed to handle the complete genome of many different species, and have highlighted that, in order to capture evolutionary and functional mechanisms of different species, we need to consider a new set of sequence modifications, that involve recombination or shuffling of segments of genome. The distance we define takes into account such kind of modifications and therefore it can be successfully applied to compare genomic sequences, as shown in Section 6.</p><p>We define a new notion of distance between two sequences. Such a notion is based on the following intuitive idea: when ebwt is applied to the set S = {u, v}, if the same segment s occurs both in u and v, then the conjugates of u and v starting by s are likely to be close in the ω -sorted list of conjugates. This implies that the greater is the number of segments shared by u and v, the greater is the mixing of the conjugates of u and v in the sorted list. The comparison method based on transformation ebwt will measure how similar u and v are, by taking into account how much their conjugates are mixed. In this section, in order to show an application of the extended Transformation, we define a distance measure that computes the number of alternations in the above list between the conjugates of u and those of v. A more detailed study of the class of distance measures based on ebwt can be found in <ref type="bibr" target="#b14">[15]</ref>, where other different formalizations of distance measures based on ebwt are given.</p><p>Formally, let S = {u 1 , u 2 , . . . , u k } be a multiset of primitive words in A * , let m = k i=1 |u i | and let M C = w 1 , w 2 , . . . , w m be the sorted list of the conjugates of the elements of S obtained during the computation of ebwt(S). Consider the new alphabet Σ = {U 1 , U 2 , . . . , U k }. The coloring of ebwt(S) is the map γ : {1, 2, . . . , m} → Σ defined, for as:</p><formula xml:id="formula_25">γ (i) = U j if w i is a conjugate of u j .</formula><p>We denote by M γ the word over Σ * such that M γ [i] = γ (i).</p><p>The following example describes the coloring of ebwt, by adding the sequence M γ as a column to the table M associated to the computation of ebwt, as shown in Fig. <ref type="figure">5</ref>.</p><formula xml:id="formula_26">M C M L M γ M χ 1 aaabbbb b U 1 2 aabbbab b V 0 3 aabbbba a U 0 4 abaabbb b V 1 5 abababb b Z 1 6 ababbab b Z 0 7 abbabab b Z 0 8 abbbaba a V 0 9 abbbbaa a U 0 10 baaabbb b U 0 11 baabbba a V 0 12 babaabb b V 0 13 bababab b Z 0 14 bababba a Z 0 15 babbaba a Z 0 16 bbaaabb b U 0 17 bbabaab b V 0 18 bbababa a Z 0 19 bbbaaab b U 0 20 bbbabaa a V 0 21 bbbbaaa a U<label>0</label></formula><p>Fig. <ref type="figure">5</ref>. The table M associated to ebwt(S) in which the column M γ of the coloring is added.</p><p>Example 26. Let S = {u, v, z}, where u = aaabbbb, v = abaabbb and z = abababb. Let U, V, Z be the colors associated, by the map γ , to u, v, z, respectively. As one can see in Fig. <ref type="figure">5</ref>,</p><formula xml:id="formula_27">M γ = U V U V Z Z Z V UU V V Z Z ZU V ZU V U .</formula><p>The definition of coloring allows us to introduce a new notion of distance measure between two sequences that takes into account the alternation of the symbols coming from different sequences in the output of the transformation ebwt.</p><p>Definition 27. Let u, v ∈ A * be two sequences and let us consider</p><formula xml:id="formula_28">M γ (u, v) = U n 1 V n 2 U n 3 • • • V n k . We define the measure δ(u, v) as follows: δ(u, v) = k i=1, n i =0 (n i -1)</formula><p>A description of the computation of distance δ is given in the Example 29. The following proposition provides some properties of the measure δ.</p><p>Proposition 28. The following statements hold:</p><p>(1) δ(u, v) = δ(v, u), i.e. the measure δ is symmetric.</p><p>(2) If u and v are conjugate, then δ(u, v) = 0.</p><p>(3) If u is a conjugate of u and v is a conjugate of v, then δ(u, v) = δ(u , v ). Therefore, δ is a distance measure for conjugacy classes.</p><p>then we can prove that BWT (u) = BWT (v). In fact, since M L (u, v) = EBWT (u, v) ∈ BWT (u) • BWT (v), we can deduce that the elements of M L (u, v) are taken alternatively one from BWT (u) and one from BWT (v). Let us suppose that 1 ≤ j ≤ n is the first index such that s j = x y, where x, y ∈ A and x = y. Then there should be an integer i such that M F (u, v)[2i] = y. Since w and v are Parikh-equivalent, each character a i has the same number of occurrences both in w and v. So M F (u, v) contains an even number of occurrences of y, we have that M F (u, v)[2i -1] = y. So, by Item 2 of Proposition 14, there exists 2k -1 &lt; 2 j such that θ (2i -1) = 2k -1. Since x = y, then 2k -1 &lt; 2 j -2. We note that in M L (u, v) the character y cannot appear between positions 2k and 2 j -1. So, s k = yz with y = z appears in M L (u, v) and k &lt; j and this fact contradicts the minimality of j. The thesis follows by using Proposition 1.</p><p>We note that given two words u and v having the same length n, the fact that δ(u, v) = 0 does not imply in general that u and v are conjugate (see Example 31). In case of words over a binary alphabet {a, b}, the equality of the length implies the Parikh-equivalence.</p><p>Proposition 33. Let u and v be two words over the alphabet {a, b} having the same length n. If δ(u, v) = 0 then u and v are conjugate.</p><p>Proof. As in the proof of previous proposition, δ(u, v) = 0 and |u| = |v| imply that M γ (u, v) = (U V ) n or (V U ) n and its length is 2n. Let θ be the permutation on {1, . . . , 2n} defined as in Section 2 from  Example 34. We note that, even if we consider Parikh-equivalent words, the measure δ is a semi-metric, i.e. it does not satisfy the triangle inequality. In fact, let u = aaaaaabbbb, v = aaabaababb and w = aaabaabbba be three Parikh-equivalent words. One can verify that δ(u, v) = 9, δ(u, w) = 5 and δ(w, v) = 3.</p><formula xml:id="formula_29">M F (u, v) to M L (u, v). It is easy to see that θ is decomposable into two disjoint cycles σ = (i 1 i 2 • • • i n ) and τ = ( j 1 j 2</formula><p>We remark that the computation time of the distance δ(u, v) linearly depends on the computation time of the extended transform of u and v. Therefore its computation is performed in O(|u|+|v|). This distance is then very simple to compute, differently from other alignment-free distance measures, such as, for instance, the Block-Edit distance, whose computation is an NP-Complete problem (cf. <ref type="bibr" target="#b9">[10]</ref>). We recall that the Block-Edit distance between two words u and v computes the number of character insertion, deletion and substitution and block insertion, deletion and relocation needed in order to obtain v from u. One can wonder whether the distance δ can be considered an approximation of the Block-Edit distance. Unfortunately this is not the case. In fact, consider, for instance, the alphabet A ∪ {$ 1 , $ 2 , $ 3 , $ 4 } such that, for all a ∈ A, a &lt; $ 1 &lt; $ 2 &lt; $ 3 &lt; $ 4 and consider the words u = a 1 a 2 • • • a n $ 1 a 1 a 2 • • • a n $ 2 and v = a 1 a 2 • • • a n $ 3 a 1 a 2 • • • a n $ 4 , a i ∈ A for all i = 1, . . . , n. It is easy to see that just two character substitutions allow to obtain v from u, so their Block Edit distance is 2. On the other side one can notice that for a fixed character a i , its two occurrences in u are close in the transformation, followed by its two occurrences in v. So each block of characters coming from the same word have length 2, which give a distance δ(u, v) = |u|.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Experimental results</head><p>The distance introduced in previous section measures the dissimilarity between two cyclic sequences (cf. Item 3 of Proposition 28). <ref type="foot" target="#foot_0">1</ref> So, in order to test our method, in this section we describe the results of the application of the normalized version of our distance to the whole mitochondrial genome phylogeny, since the mitochondrial DNA can be considered as a cyclic sequence. Notice the length of the mitochondrial DNA of the different species considered are almost the same (around 16 kbytes). In the experiment described in this section we construct a phylogeny of the Eutherian orders (i.e. placental mammals) using complete unaligned mitochondrial genomes. We choose our group of sequences by using the mtDNA genomes of 20 mammals from GenBank, as listed in Fig. <ref type="figure" target="#fig_7">7</ref>. Such a set of species contains placental mammals, and, as outgroups, marsupials and monotremes. As shown in the dendrogram obtained by using a single linkage clustering (see Fig. <ref type="figure" target="#fig_7">7</ref>), our method allows to classify the analyzed species into Primates, Ferungulates, Rodents, Marsupial and Monotremes. Moreover, we obtain a phylogeny that is very close to the ones described in most of the papers in which the species considered are almost the same (cf. <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b2">3]</ref>). Our resulting phylogeny proposes the following grouping of the placental mammals: (Primates, (Ferungulates, Rodents)). A more detailed analysis and further experiments using different ebwt-based distance measures can be found in <ref type="bibr" target="#b13">[14]</ref> and <ref type="bibr" target="#b14">[15]</ref>.</p><p>Nevertheless, the goal of this experiment is not to confirm or refute previous phylogenetic studies but rather to show that the method introduced here can be a helpful tool for the comparative genomics research community.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. The matrix of all cyclic rotations of the word w = abraca.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. The output of ebwt(S) is the pair (M L , M χ ) where M L = ccbbbcacaaabba and M χ = 10000000100011.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Algorithm</head><label></label><figDesc>REVERSE (ebwt(S) = (M L , M χ )); 1. Create M F by alphabetically sorting the characters of M L ; 2. Build the permutation θ; 3. S := ∅; N := length(M L ); 4. for i = 1, . . . , N do 5. if M χ [i] = 1 then 6.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Example 14 .</head><label>14</label><figDesc>Given M L = ccbbbcacaaabba and M χ = 10000000100011 as obtained in Example 9, one can construct M</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Proposition 15 .</head><label>15</label><figDesc>The algorithm REVERSE recovers the original multiset S in time O(||S||).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Lemma 19 .Fig. 4 .</head><label>194</label><figDesc>Let S = {u 1 , u 2 , . . . , u k } and T = {v 1 , v 2 , . . . , v h } be two multisets of primitive words of A * . Then EBWT (S) = EBWT (T ) if and only if T and S are conjugate. (a) The table M (S) associated to the lexicographic ordering of the conjugates of words in S. (b) The table M (T ) associated to the lexicographic ordering of the conjugates of T . For each table M , the column M C represent the sorted list of the conjugates, the column M L the sequence of their last symbols and the column M F the sorted characters of M L .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>+ 1 and |u| b + 1 = |v| b then the first occurrence of b in M F (u, v) should appear at an even position 2i. So, by definition of θ and since b must appear as first symbol in M L (u, v), we should have θ (2i) = 1 and this contradicts the fact that σ and τ are disjoint. Since |u| a = |v| a and |u| b = |v| b , u and v are Parikh-equivalent. By Proposition 32, it follows that u and v are conjugate.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 7 .</head><label>7</label><figDesc>Fig.7. The evolutionary tree built from complete mammalian mtDNA sequences of the 20 species analyzed in<ref type="bibr" target="#b1">[2]</ref>.</figDesc><graphic coords="14,146.06,62.65,248.40,222.84" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>• • • j n ) where i h and j h are even and odd integers, respectively, for each 1 ≤ h ≤ n. Denoted by |u| a the number of occurrences of the character a in u, we note that since u and v are words over a binary alphabet we can deduce that |u| a = |v| a . Note that if |u| a ≥ |v|</figDesc><table /><note><p>a + 2, then there would be two consecutive U 's in M γ (u, v), a contradiction. Then we can state that ||u| a -|v| a | ≤ 1. Actually, if |u| a = |v| a</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Recall that in order to consider not cyclic sequences, it suffices to add an end-of-string symbol # to the sequences.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>$ Partially supported by the Italian MIUR PRIN project "Automi e Linguaggi Formali: aspetti matematici ed applicativi" and by MIUR FIRB Italy-Israel project "Pattern Matching and Discovery in Discrete Structures, with applications to Bioinformatics".</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Proof. The Item 1 follows from the symmetry of the transformation ebwt. The proof of Item 2 comes from the fact that if u and v are conjugate then M γ (u, v) = (U V ) |u| , hence for every i = 1, . . . , k one has that n i = 1. Note that we use a stable ordering of the cyclic rotations of u and v in the computation of ebwt(u, v). Item 3 holds because the definition of δ uses the transformation ebwt but does not depend on the sequence M χ .</p><p>Example 29. Let us consider the sequences u = bcaa and v = ccbab. In Fig. <ref type="figure">6</ref> the sorted list of conjugates of u and v and the coloring of ebwt(u, v) are shown. In this case</p><p>Actually, even if we refer to δ as a "distance" between conjugacy classes, it is not a metric because neither it does obey the triangle inequality (see Example 30) nor the condition δ(u, v) = 0 implies that u and v are conjugate (see Example 31).</p><p>Example 30. Consider the sequences</p><p>. Such sequences show that δ does not satisfy the triangle inequality. In fact δ(u 1 , u 2 ) = 6, δ(u 2 , u 3 ) = 3 and δ(u 1 , u 3 ) = 2.</p><p>Example 31. Let u = aabc and v = abbc. Although the two sequences are not conjugate, δ(u, v) = 0 since</p><p>The following two propositions show that if we endow A * with an equivalence relation called Parikh-equivalence, that we define in the following, then the measure δ is a semi-metric on conjugacy classes.</p><p>Let A = {a 1 , a 2 , . . . , a t } be a finite ordered alphabet. We can associate to a word w ∈ A * its Parikh-vector P(w), i.e. a t-tuple of non-negative integers (i 1 , i 2 , . . . , i t ) such that each i j counts how many a j 's occur in w.</p><p>Two words u, v ∈ A * are called Parikh-equivalent if P(u) = P(v). We note that if two words are Parikh-equivalent then they have the same length. In this section we show that if we consider the Parikh-equivalent words in A * , then measure δ becomes a semi-metric, i.e. it is a positive measure that satisfies the symmetry, the identity of indiscernibles but not the triangle inequality (see Example 34).</p><p>Proposition 32. Let u, v be two Parikh-equivalent words in A * . If δ(u, v) = 0 then u and v are conjugate.</p><p>Proof. We denote by n the length of w and v. Let us consider</p><p>from definition of δ it follows that n 1 = 0 or 1 and n i = 1 for each i ≥ 2. Moreover, since |u| = |v| then n 1 = 0 if and only if n k = 0, i.e. M γ (u, v) = (U V ) n or (V U ) n of length 2n. Let θ be the permutation on {1, . . . , 2n} defined as in Section 2 from M F (u, v) to M L (u, v). It is easy to see that θ is decomposable into two disjoint cycles σ = (i 1 i 2 • • • i n ) and τ = ( j 1 j 2 • • • j n ) where i h and j h are even and odd integers, respectively, for each 1 ≤ h ≤ n. Let M L (u, v) = s 1 s 2 • • • s n be the extended transformation, where s i ∈ A 2 . In order to prove that u and v are conjugate it suffices to show that s i is a square, for each i ≥ 1. This is equivalent to proving that θ(2i -1) = h ⇒ θ (2i) = h + 1. If we prove such statement the thesis follows because, if we use the Proposition 25</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">A block sorting data compression algorithm</title>
		<author>
			<persName><forename type="first">M</forename><surname>Burrows</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Wheeler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
		<respStmt>
			<orgName>DIGITAL System Research Center</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Conflict among individual mitochondrial proteins in resolving the phylogeny of eutherian orders</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Janke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Waddell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Westerman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Takenaka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Murata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Okada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pääbo</surname></persName>
		</author>
		<author>
			<persName><surname>Hasegawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Evol</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="307" to="322" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Clustering by compression</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cilibrasi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Vitányi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1523" to="1545" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A note on the Burrows-Wheeler transformation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Crochemore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Désarménien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Perrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">332</biblScope>
			<biblScope unit="page" from="567" to="572" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Comparing sequences with segment rearrangements</title>
		<author>
			<persName><forename type="first">F</forename><surname>Ergun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Muthukrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sahinalp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the FSTTCS&apos;03</title>
		<title level="s">Lecture Notes in Comput. Sci</title>
		<meeting>of the FSTTCS&apos;03<address><addrLine>Bombay, India</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="183" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Structuring labeled trees for optimal succinctness, and beyond</title>
		<author>
			<persName><forename type="first">P</forename><surname>Ferragina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Luccio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Manzini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Muthukrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 45th Annual IEEE Symposium on Foundations of Computer Science</title>
		<meeting>of the 45th Annual IEEE Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="198" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Counting permutations with given cycle structure and descent set</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">M</forename><surname>Gessel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Reutenauer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Combin. Theory Ser. A</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="189" to="215" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Simple linear work suffix array construction</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kärkkäinen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sanders</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICALP</title>
		<meeting>ICALP</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="943" to="955" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The similarity metric</title>
		<author>
			<persName><forename type="first">M</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Vitányi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="3250" to="3264" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Block edit models for approximate string matching</title>
		<author>
			<persName><forename type="first">D</forename><surname>Lopresti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tomkins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">181</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="159" to="179" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<author>
			<persName><forename type="first">M</forename><surname>Lothaire</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Combinatorics on Words</title>
		<title level="s">Encyclopedia of Mathematics</title>
		<meeting><address><addrLine>Reading, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1983">1983. 1997</date>
			<biblScope unit="volume">17</biblScope>
		</imprint>
	</monogr>
	<note>Reprinted in the Cambridge Mathematical Library</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Algebraic Combinatorics on Words</title>
		<author>
			<persName><forename type="first">M</forename><surname>Lothaire</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An extension of the Burrows Wheeler transform and applications to sequence comparison and data compression</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mantaci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Restivo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rosone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sciortino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Combinatorial Pattern Matching, 16th Annual Symposium, CPM 2005</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Alberto</forename><surname>Apostolico</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Maxime</forename><surname>Crochemore</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Kunsoo</forename><surname>Park</surname></persName>
		</editor>
		<meeting><address><addrLine>Jeju Island, Korea</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005-06">June. 2005. 2005</date>
			<biblScope unit="volume">3537</biblScope>
			<biblScope unit="page" from="178" to="189" />
		</imprint>
	</monogr>
	<note>Proceedings</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A new combinatorial approach to sequence comparison</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mantaci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Restivo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rosone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sciortino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICTCS 2005, Theoretical Computer Science, 9th Italian Conference, ICTCS 2005, 12-14 October</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Mario</forename><surname>Coppo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Elena</forename><surname>Lodi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><forename type="middle">Michele</forename><surname>Pinna</surname></persName>
		</editor>
		<meeting>ICTCS 2005, Theoretical Computer Science, 9th Italian Conference, ICTCS 2005, 12-14 October<address><addrLine>Siena, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005. 2005</date>
			<biblScope unit="volume">3701</biblScope>
			<biblScope unit="page" from="348" to="359" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A new combinatorial approach to sequence comparison</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mantaci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Restivo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rosone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sciortino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Theory Comput. Syst.</title>
		<imprint/>
	</monogr>
	<note>journal version. in press</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Burrows-Wheeler transform and Sturmian words</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mantaci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Restivo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sciortino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="page" from="241" to="246" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Uniqueness theorem for periodic functions</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">S</forename><surname>Wilf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">J</forename><surname>Fine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Amer. Math. Soc</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="109" to="114" />
			<date type="published" when="1965">1965</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A new sequence distance measure for phylogenetic tree construction</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">H</forename><surname>Otu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sayood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">16</biblScope>
			<biblScope unit="page" from="2122" to="2130" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Alignment-free sequence comparison -a review</title>
		<author>
			<persName><forename type="first">S</forename><surname>Vinga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Almeida</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="513" to="523" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
