<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Implicit Hints: Embedding Hint Bits in Programs without ISA Changes</title>
				<funder ref="#_MAXM2QP">
					<orgName type="full">Ghent University</orgName>
				</funder>
				<funder>
					<orgName type="full">European Network of Excellence on High-Performance Embedded Architectures and Compilation</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Hans</forename><surname>Vandierendonck</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electronics and Information Systems Ghent University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Koen</forename><surname>De Bosschere</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electronics and Information Systems Ghent University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Implicit Hints: Embedding Hint Bits in Programs without ISA Changes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T09:40+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>There is a large gap in knowledge about a program between the compiler, which can afford expensive analysis, and the processor, which by nature is constrained in the types of analysis it can perform. To increase processor performance, ISAs have been extended with hint bits to communicate some of the compiler's knowledge to the processor. In this paper, we propose and analyze a technique for adding or removing hints to a processor without changing the ISA, i.e. without breaking binary compatibility. Our technique exploits the freedom of allocating values to registers. We divide the registers in disjoint sets and assign one hint value to each set of registers. We implement our technique in the GCC compiler. Evaluation on two very different instruction sets, the Alpha ISA and the x86-64 ISA, shows that these hints can be encoded with high accuracy, although the accuracy varies strongly between instruction sets. We demonstrate that it is possible to encode multiple hints in register names and that the quality of register allocation is not degraded.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>In the quest for higher performance, the boundary between compilers and architecture has faded: On one hand architectural details have been exposed to the compiler and on the other hand compilers communicate some of their analysis results to the architecture by means of hint bits. Hint bits are embedded in the instruction encoding. But instead of defining what the architecture must do (the semantics of the instruction) the hint bits give directions on how the architecture can best accomplish a task. The recent Itanium ISA <ref type="bibr" target="#b0">[1]</ref>, contains hint bits to steer branch prediction and hint bits to predict locality of memory reference.</p><p>Hint bits are a powerful tool to enhance the cooperation between compilers and architectures. Adding hint bits to an existing ISA is, however, a difficult task because of binary compatibility issues. Indeed, the instruction format must be changed to house the new hint bits but programs compiled for the old ISA must still execute correctly. Extending an ISA with hint bits may be possible a few times during the lifetime of an ISA, but not with every new processor generation.</p><p>We propose and analyze a technique to encode hints in existing instruction sets that requires no ISA changes. Our technique uses a degree of freedom in instruction encoding, namely the choice of register name, to encode hint bits. Hereby, the specification of hint bits is not part of the ISA per se and can change without breaking binary compatibility. This property makes it easier to introduce new hints in processors, but also to remove hints if they become obsolete.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Principle</head><p>Instruction set architectures use registers to store intermediate results. In many cases, it is legal to substitute the use of one register for another register. Due to this property, it is possible to divide the set of registers into multiple register classes, where each register class encodes for a particular hint. When an instruction references a register, we can use the register name to deduce a hint for this instruction.</p><p>Consider, for example, encoding a branch bias hint in conditional branch instructions (i.e. is the branch most likely taken or not-taken?). Hereto, we divide the set of registers in two register classes, e.g., the even registers to encode not-taken and the odd registers to encode taken. Using this scheme, it is hinted that the instruction bge r1, target is a likely taken branch while the instruction bge r2, target is a likely not-taken branch. Figure <ref type="figure">1</ref> illustrates the effect of this hint encoding when compiling the SPEC CPU2006 gcc benchmark for the Alpha ISA. The graph shows the percentage of time that conditional branches are taken (taken rate) averaged per register name. On the left, we show the taken rate when compiling gcc using an unmodified compiler. There is hardly any correlation between taken rate and register name. On the right, we see that the techniques presented in this paper force a low taken rate for even register names and a high taken rate for odd register names.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Contributions</head><p>We present an algorithm for encoding hints in register names. As the hints affect what registers are used by what instructions, the encoding of hints must be integrated into register allocation: the assignment of values (program variables, intermediate values or live ranges) to registers. We demonstrate in this paper that it is quite feasible to extend register allocation to encode hints and that the quality of register allocation is not degraded. Furthermore, we discuss the architectural support necessary for decoding hint bits and we discuss the reconfiguration of this hardware in order to change the set of hints that are decoded.</p><p>The goal of this paper is to show the feasibility of encoding hints in register names. Hereto, we present case studies on encoding conditional branch hints and cache hit/miss hints in register names. We experimentally evaluate the accuracy of these hints on two very different instruction sets: the orthogonal RISC Alpha ISA and the CISC x86-64 ISA In future work we will consider other hints to encode in instructions and evaluate the overall speedup or energy reduction that can be achieved with these hints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Paper Organization</head><p>The remainder of this paper is organized as follows. Section II cites related work on this topic. Then, we discuss the extensions to register allocation that are necessary for encoding hints in Section III. We discuss the issues related to backward compatibility in Section IV. Following, we evaluate the proposed hint encoding in Section V. Finally, we conclude the paper and provide directions for future research in Section VI.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. RELATED WORK</head><p>The literature provides ample evidence that there is a real practical need for encoding hints in instructions. Many processors already contain mechanisms to convey hints on, e.g., branch directions [2], <ref type="bibr" target="#b1">[3]</ref>, branch targets <ref type="bibr" target="#b2">[4]</ref> and memory locality <ref type="bibr" target="#b3">[5]</ref>. On the other hand, researchers have indicated that hint bits are an enabling mechanism for hardware improvements such as value prediction <ref type="bibr" target="#b4">[6]</ref>, <ref type="bibr" target="#b5">[7]</ref>, early register release <ref type="bibr" target="#b6">[8]</ref> and criticallity-aware processors <ref type="bibr" target="#b7">[9]</ref>. Unfortunately, there are is no generic way to actually provide these hints to the processor.</p><p>Recent ISAs have reserved the necessary bits in instructions to encode hints. It is, however, not possible to make ISA changes for every new processor generation. Thus, a technique is required that allows to encode hint bits without making ISA changes. This paper presents such a technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. IMPLICIT HINTS</head><p>The compiler and the processor must both follow a set of conventions on the implicit hints. In particular, an implicit hint is specified by the following properties:</p><p>1) The instructions (opcodes) where the hint is present, e.g. a branch bias hint is only present in conditional branch instructions. 2) The operands where the hint is encoded, e.g. a hint attached to load/store instructions may be encoded in the value register operand, i.e. r4 in ldq r4,0(r1).</p><p>3) The hinted value attached to each register, e.g. taken/not-taken. Multiple hints may be simultaneously encoded, e.g. a program may carry a branch bias hint in conditional branch instructions and a memory locality hint in load/store instructions <ref type="foot" target="#foot_0">1</ref> . Furthermore, the absence of a hint can be encoded by adding a register class to signify this situation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Encoding Hints with the Register Allocator</head><p>Our algorithm for encoding hints in register names builds upon the notion of register classes. Register classes are used in many register allocators to express what registers are interchangeable and independent. Registers are interchangeable when either may be used in the same program context. Registers are independent when modifying one cannot modify the other. It turns out that commercial instruction sets do not respect the properties of interchangeability and independence <ref type="bibr" target="#b8">[10]</ref>. To solve this problem, registers are grouped in register classes such that all registers in the same class are interchangeable and independent.</p><p>Figure <ref type="figure" target="#fig_0">2</ref> shows the register class hierarchy for a regular architecture such as the Alpha (full lines). The register class hierarchy is an acyclic graph where each node in the graph corresponds to a register class and edges denote the subset relationship. There are three register classes: the floatingpoint registers (FP), the integer registers (INT) and the class of all registers, which is the union of the previous two.</p><p>Additional register classes signify hints. In Figure <ref type="figure" target="#fig_0">2</ref>, we specialize the integer registers in two classes: the registers encoding a taken branch direction (INT-T) and the registers encoding a not-taken branch direction (INT-NT). Further refinement of these register classes allows one to encode also the strength of the branch bias: whether the branch is very likely taken (strong taken) or whether it is weakly biased towards taken (weak taken). A similar refinement is performed on the not-taken branch direction. Multiple register classes may be legal candidates for holding a value. In such situations, it is beneficial to steer register selection by means of register class preference. When the most preferred register class has no free registers, the register allocator searches the next preferred register class for a free register, and so on. This approach is followed, amongst others, by GCC which tracks two preferred register classes per register-allocatable value.</p><p>This mechanism is used to select registers with the correct hint. E.g. the sequence of register classes INT-WNT, INT-NT, INT specifies that a value should be encoded with the "weak bias" and "taken" hints. If however all registers in the INT-WNT class are occupied, then we prefer to drop the "weak bias" hint and select a register from the larger INT-NT class. If this also fails, we select a generic INT register.</p><p>The approach outlined here has several advantages. First, we do not have to interfere with the register allocator itself as we only change the preferred register class to encode hints in register names. As such, our approach works with any register allocator. Second, it allows for a simple way to discard hints if registers encoding the correct hint are unavailable. In particular, we give preference to register classes that encode the correct hint, but when these register classes are exhausted, we fall back to the larger generic register classes. Hereby, erroneous hints may be encoded, but the value is placed in a register, which helps performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Application to Branch Bias Hints</head><p>The algorithm described above applies to most common cases of encoding hints. For branch bias hints, however, we need to apply two additional tricks.</p><p>The first problem stems from assigning branch bias hints during register allocation while the branch bias may be changed by subsequent control flow optimization and code layout. Our solution to this problem is to change the encoding of the hint: instead of directly encoding taken/not-taken information, we encode the branch bias conditionally on the branch condition. We define for every branch condition a toggle value and encode the following hint: hint = branch bias XOR toggle(branch condition) where the taken branch bias is represented by 1 and the nottaken branch bias is represented by 0. The power of this encoding is in the choice of the toggles: when a branch bias is reversed, then the condition toggle reverses too. A possible assignment of toggles is listed in Table <ref type="table" target="#tab_1">I</ref>.</p><p>The second problem concerns instructions where all used registers are implicitly named, e.g., the flags or condition code register in many ISAs. It is not possible to directly encode hints in the register arguments. Instead, we select another instruction to act as a proxy for encoding the hint. We select the instruction that produces the implicitly named register. Consider the following sequence of x86 instructions:</p><formula xml:id="formula_0">cmp %rax,%rdx # compare, proxy inst. bne target # branch if not equal</formula><p>The cmp instruction allows choice in the register names of its operands. We encode the hint in its first register operand.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. DECODING IMPLICIT HINTS</head><p>A compiled program where hints are encoded in register names is not directly distinguishable from a program without hints, as both use the same ISA. It is therefore necessary to inform the processor about the presence of hints. The processor can then look for these hints as it decodes the instructions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Decoding Mechanism</head><p>The processor decodes hints during instruction decode. Depending on the opcode and on the types of register operands, it determines what register operand encodes a hint and it extracts the hint from the register name. This process is very simple and can be implemented by means of a combinatorial circuit.</p><p>Figure <ref type="figure" target="#fig_1">3</ref> shows the hint decoding hardware. A hint configuration register determines what hint may be encoded in register names. Based on this information, one can deduce from the opcode if the hint is present in this instruction and one can extract the hint from register names (bottom). Extracting the hint requires the opcode in order to correctly re-apply branch condition toggles (Section III-B). When hints are encoded in instructions that read only implicitly named registers, e.g. as in branch instructions that check a flags register, then we encode the hint in a proxy instruction (Section III-B). This makes the decoding process a little more complicated, as the hint must be decoded from the proxy instruction and remembered until the dependent instruction is encountered. Hereto, we track dependencies on the flags register. When decoding an instruction that writes the flags register, the decoder logic generates a signal to store the hint in the "next-hint" register. When decoding an instruction that reads the implicit register, the hint is pickedup from the next-hint register.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Configurable Hints</head><p>Figure <ref type="figure" target="#fig_1">3</ref> contains a user-programmable hint configuration register to specify what hints have been encoded in the currently executing code. Only the hints indicated in the hint configuration register are actually decoded and used by the processor. This register adds a level of configurability to the presence of hints. The hint configuration register is however architecturally visible.</p><p>Configurable hints have some useful applications. First, making hints configurable allows a smooth transition path for adding hints to a processor and for removing them. When a processor implements a new hint, then programs compiled for older processors have the new hint turned off by default. The hint will be encoded in freshly compiled programs, where the hint is turned on. Furthermore, hints may become redundant in which case it is straightforward to reclaim the hint bits and to implement a different hint. This is all possible without bloating the ISA and without breaking binary compatibility.</p><p>Second, it allows one to encode only those hints that are most useful for a particular code section. E.g. it may be more beneficial to encode memory locality hints in memorydominated applications than it is to encode branch hints. Third, by making the encoded hints selectable, it is also possible for the processor to implement a portfolio of hints that is significantly larger than the small number of hints that can be encoded in a typical register name space. Furthermore, a processor can implement hints targeting different goals, e.g. performance, power consumption, etc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Backwards Compatibility</head><p>Processors that recognize implicit hints must still perform well when running code where no hints are encoded in register names. Also, there is a potential problem when linking (either static or dynamically) object files where some files have implicit hints and others do not.</p><p>To handle these scenarios, we rely on the hint configuration register to enable or disable hints during execution. For instance, it allows programs without hints to run while the hardware does not attempt to read implicit hints. Hereto, system software turns off implicit hints using the hint configuration register when the program is loaded into memory.</p><p>Linking object files with and without implicit hints is possible by inserting code snippets to set the hint configuration register at module boundaries. E.g. when calling a function from a different module, the call instruction jumps to a preamble of the function that sets the hint configuration register. When returning from a cross-module call, the hint configuration register is reset to the appropriate value. Within a compilation module, the compiler has absolute knowledge of the value of the hint configuration register. This is much the same mechanism as used on Alpha systems for keeping the global pointer ($gp) consistent. It guarantees that, whatever the control flow in the program, the hint configuration register (or the global pointer) contains the desired value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. EVALUATION</head><p>The goal of this evaluation is to confirm the feasibility of encoding hints in register names and to gauge the impact of ISA properties. Speed-up results are deferred to future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Evaluation Environment</head><p>We experimentally evaluate the accuracy of implicit hints on the RISC Alpha ISA and the CISC x86-64 ISA using branch bias and branch strength hints.</p><p>The relation between branch hints and register names is depicted in Table <ref type="table" target="#tab_2">II</ref>. Branch hints are encoded in the register argument of conditional branches in the Alpha. In the x86-64, the hints are encoded in a proxy instruction.</p><p>We implemented the hint encoding techniques in a nonresearch compiler: GCC 4.2.0. We modified the Alpha and x86-64 back-ends to incorporate the new register classes. For the x86-64, we broke up the GENERAL (integer registers), INDEX (pointer registers) and SSE (floating-point/SSE2) register classes to encode hints. For the Alpha, the integer and floating-point register classes were refined.</p><p>The accuracy of the encoded hints is computed using functional simulation. We use SimpleScalar for the Alpha <ref type="bibr" target="#b9">[11]</ref> and PTLsim for the x86-64 <ref type="bibr" target="#b10">[12]</ref>. Only the application part of the benchmarks is measured. Libraries are not modified and are not included in the reported statistics. All benchmarks are run to completion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Branch Hints</head><p>We evaluate the accuracy of encoding a branch bias hint by the overall static branch prediction accuracy, i.e. the number of times that the branch bias hint corresponds to the actual branch direction during execution. Figure <ref type="figure">4</ref>   <ref type="figure">4</ref>. Prediction accuracy for the branch bias hint in the Alpha and x86-64 broken down by cause of prediction error. The "static prediction" bar shows the oracle static prediction accuracy. The "compiler" bar shows the accuracy of the hints in the internal representation of the compiler. The "hint in reg-name" bar adds the impact of register pressure and ISA constraints to the accuracy. The "BT-FNT" bar compares to the accuracy of backward-taken forward-not taken static branch prediction.</p><p>the prediction accuracy of the hint bit during various steps in the compilation chain.</p><p>The perfect static branch bias predictor sets an upper bound on the achievable static branch prediction accuracy. Prediction errors occur as branches that go the same direction D% of the time are statically mispredicted in at least min(D%, 100%-D%) of the cases. This variability of branch direction introduces a minimum error of 12.5% in both ISAs.</p><p>The next source of error is the compiler. Compiler hints may be wrong as it can be inherently impossible to correctly compute branch biases when transforming a control flow graph <ref type="bibr" target="#b11">[13]</ref>. E.g. for code duplication, the compiler must guess the branch biases in each copy of the code. An obvious assumption is that all copies of the code behave the same as the original code, but this is not true in general. The compiler's branch bias is slightly distorted resulting in less than 1.3% average increase of prediction error.</p><p>Encoding the compiler's erroneous branch bias in register names further increases prediction error to 15.91% in the Alpha, which introduces an error of 3.72% compared to the perfect static branch predictor. For the x86-64, hint encoding is far less accurate due to various ISA properties, such as abundant use of implicitly named registers and 2-operand instruction formats allowing memory operands.</p><p>The difference between the hint in reg-name bar and the compiler's hint bar shows hint encoding errors. This includes errors due to register class restrictions and register pressure but also due to ISA properties and due to incompleteness of the implementation of the technique (rare cases are not always implemented).</p><p>The backward taken/forward not-taken (BTFNT) static branch predictor is a well-studied static predictor that assumes that backward branches are typically taken as they often correspond to loop branches, while forward branches are generally not-taken. The branch prediction error for BTFNT is 19.88% on average on the Alpha and 24.09% in the x86-64. Thus, on regular ISAs, encoding hints in register names is more accurate than simple static hardware predictors.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Encoding Hints in the PC</head><p>Jim?nez <ref type="bibr" target="#b12">[14]</ref> proposes to encode branch hints in the program counter. By carefully aligning the code, it is possible to make a particular bit in the program counter collide with the branch bias. The code is aligned by inserting no-ops, which are placed as much as possible on cold code paths. Overall, placement is not exact. We refer to <ref type="bibr" target="#b12">[14]</ref> for details of the algorithm.</p><p>Figure <ref type="figure" target="#fig_2">5</ref> demonstrates the error on the branch bias hint when it is encoded in the program counter or in register names. Results are shown for the x86-64 ISA because Jim?nez also applied his work to x86-64. The hint is on average 6% more accurate when it is encoded in the register name then when it is encoded in the program counter. Thus, register names are a more appropriate place to encode hints, even though the x86-64 ISA is strongly register-constrained. In the case of the hmmer benchmark, the structure of the code does not provide many degrees of freedom for aligning the code. Furthermore, strong deviations between training and reference inputs push the error above 50%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Multiple Hints</head><p>We have set up an experiment where 2 hints are encoded: a branch bias hint and a branch strength hint, indicating that a branch is strongly biased (when the bias is larger than 95% or less than 5%) or it is weakly biased. Prediction error of the bias hint is increased with 0.27% points.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. The Cost of Implicit Hints</head><p>The overhead of encoding hints in register names is practically zero: We measured the dynamic instruction count increase for encoding a branch bias hint and a branch strength hint, averaging at 0.15% and 0.27% in the Alpha and x86-64 ISAs respectively. The numbers vary across benchmarks between -0.38% and 0.75% for the Alpha and between -0.05% and 0.56% for the x86-64. This shows that the goal of minimizing spill code, that we set forth at the beginning, has been successfully reached.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F. Cache Hit/Miss Hints</head><p>Implicit hints are not restricted to branch hints but they are useful for a variety of different hints. Here, we discuss the cache hit/miss hint. We simulate accesses to a 64 KB, 4way set-associative data cache with 64-byte blocks. For each load instruction in the program, we determine what is most likely: a hit or a miss. This information is encoded in the register name.</p><p>The cache hit/miss hint is, on average, wrong 4.49% of the time (Figure <ref type="figure">6</ref>). We find that most of the errors in the static prediction are due to the compiler, as the hint that the compiler tries to encode has an error rate of 3.72%. These errors are due to the absence of profiling information for many load instructions.</p><p>The graph also shows the accuracy of a dynamic hit/miss predictor (e.g. a table of 4-bit bimodal counters), which has an error rate of 1.8%. It is clear that the dynamic predictor has a smaller error. The point is however that comparable results can be obtained using static information and that using static information has many advantages in terms of hardware cost, energy consumption, etc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. CONCLUSION AND FUTURE WORK</head><p>This paper proposes implicit hints, a technique to embed hints in programs without changing the ISA. This technique exploits the freedom present in the choice of register names to hold information. We have presented a compiler algorithm for encoding implicit hints and we have discussed the hardware support necessary for decoding those hints.</p><p>Evaluation on the Alpha and the x86-64 instruction sets has shown that hints can be encoded with high accuracy, although the accuracy depends strongly on the ISA. Branch bias hints are encoded with 3.72% error in the Alpha and with 14.22% error in the x86-64. We showed that encoding an additional hint in register names does not significantly degrade this accuracy and that encoding hints in register names does not affect the quality of register allocation.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>Fig.2. Register class hierarchy extended with register classes that encode hints (drawn with dotted lines). These classes encode taken (T) or not-taken (NT) branch bias and strong (S) or weak (W) branch bias.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Decoding a hint in a proxy instruction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Analysis of encoding the branch bias hint in the program counter on the x86-64 ISA.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Fig. 1. Taken rate per register name in an unmodified program (left) and in a program with the branch bias encoded in the register name (right). Registers 29 and 30 have a special use and do not appear in branch instructions. Register 31 is always zero.</figDesc><table><row><cell></cell><cell>100%</cell><cell></cell><cell>100%</cell></row><row><cell></cell><cell>90%</cell><cell></cell><cell>90%</cell></row><row><cell></cell><cell>80%</cell><cell></cell><cell>80%</cell></row><row><cell></cell><cell>70%</cell><cell></cell><cell>70%</cell></row><row><cell>Taken rate</cell><cell>40% 50% 60%</cell><cell>Taken rate</cell><cell>40% 50% 60%</cell></row><row><cell></cell><cell>30%</cell><cell></cell><cell>30%</cell></row><row><cell></cell><cell>20%</cell><cell></cell><cell>20%</cell></row><row><cell></cell><cell>10%</cell><cell></cell><cell>10%</cell></row><row><cell></cell><cell>0%</cell><cell></cell><cell>0%</cell></row><row><cell></cell><cell>0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30</cell><cell></cell><cell>0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30</cell></row><row><cell></cell><cell>Register name</cell><cell></cell><cell>Register name</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE I BRANCH</head><label>I</label><figDesc>CONDITION TOGGLES.    </figDesc><table><row><cell>Condition</cell><cell>Toggle</cell><cell>Condition</cell><cell>Toggle</cell></row><row><cell>equal</cell><cell>0</cell><cell>not-equal</cell><cell>1</cell></row><row><cell>greater-than</cell><cell>0</cell><cell>less-or-equal</cell><cell>1</cell></row><row><cell>greater-or-equal</cell><cell>0</cell><cell>less-than</cell><cell>1</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE II THE</head><label>II</label><figDesc>RELATION BETWEEN BRANCH HINTS AND REGISTER NAMES. IN X86-64, SUBREGISTERS (E.G. AL, AH, AX AND EAX) ENCODE THE SAME HINT AS THE 64-BIT REGISTER (E.G. RAX).</figDesc><table><row><cell cols="2">Hint value</cell><cell></cell><cell>ISA</cell></row><row><cell>Bias</cell><cell>Strength</cell><cell>x86-64</cell><cell>Alpha</cell></row><row><cell>not-taken</cell><cell>weak</cell><cell>rax, rdx, r8, r10,</cell><cell>Rn, Fn if n mod 4 = 0</cell></row><row><cell></cell><cell></cell><cell>xmm{0,2,8,10}</cell><cell></cell></row><row><cell>not-taken</cell><cell>strong</cell><cell>rsi, rbp, r12, r14,</cell><cell>Rn, Fn if n mod 4 = 2</cell></row><row><cell></cell><cell></cell><cell>xmm{4,6,12,14}</cell><cell></cell></row><row><cell>taken</cell><cell>weak</cell><cell>rbx, rcx, r9, r11,</cell><cell>Rn, Fn if n mod 4 = 1</cell></row><row><cell></cell><cell></cell><cell>xmm{1,3,9,11}</cell><cell></cell></row><row><cell>taken</cell><cell>strong</cell><cell>rdi, rsp, r13, r15,</cell><cell>Rn, Fn if n mod 4 = 3</cell></row><row><cell></cell><cell></cell><cell>xmm{5,7,13,15}</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>shows</figDesc><table><row><cell></cell><cell>50%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>50%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">static prediction</cell></row><row><cell></cell><cell>45%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">static prediction</cell><cell></cell><cell>45%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">compiler's hint</cell></row><row><cell>Static branch prediction error</cell><cell>5% 10% 15% 20% 25% 30% 35% 40%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">compiler's hint hint in reg-name BT-FNT</cell><cell>Static branch prediction error</cell><cell>5% 10% 15% 20% 25% 30% 35% 40%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">hint in reg-name BT-FNT</cell></row><row><cell></cell><cell>0%</cell><cell>astar</cell><cell>bzip206</cell><cell>gcc06</cell><cell>go06</cell><cell>h264ref</cell><cell>hmmer</cell><cell>mcf06</cell><cell>omnetpp</cell><cell>perl06</cell><cell>quantum</cell><cell>sjeng</cell><cell>average</cell><cell></cell><cell>0%</cell><cell>astar</cell><cell>bzip206</cell><cell>gcc06</cell><cell>go06</cell><cell>h264ref</cell><cell>hmmer</cell><cell>mcf06</cell><cell>omnetpp</cell><cell>perl06</cell><cell>quantum</cell><cell>sjeng</cell><cell>average</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">(a) Alpha</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">(b) x86-64</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Fig.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>As the same register name may need to encode a combination of hints, it is advisable to divide the set of registers in different ways for the hints, e.g. by using a different bit in the binary representation of the register names to represent the hint.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>All <rs type="programName">FP INT INT-T INT-WT INT-ST INT-NT INT-WNT INT-SNT ACKNOWLEDGMENTS Hans Vandierendonck</rs> is a Postdoctoral Fellow with the <rs type="grantName">Fund for Scientific Research-Flanders</rs>. This research was also sponsored by <rs type="funder">Ghent University</rs> and by the <rs type="funder">European Network of Excellence on High-Performance Embedded Architectures and Compilation</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_MAXM2QP">
					<orgName type="grant-name">Fund for Scientific Research-Flanders</orgName>
					<orgName type="program" subtype="full">FP INT INT-T INT-WT INT-ST INT-NT INT-WNT INT-SNT ACKNOWLEDGMENTS Hans Vandierendonck</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Intel Itanium architecture software developer&apos;s manual</title>
		<imprint>
			<date type="published" when="2006-01">Jan. 2006</date>
			<biblScope unit="page" from="245319" to="245324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m">Intel Pentium 4 Processor Optimization: Reference Manual, Intel Corporation</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="248966" to="248967" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Synergistic Processor Unit Instruction Set Architecture</title>
		<imprint>
			<date type="published" when="2002">Jan. 2007, version 1.2</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Itanium processor microarchitecture</title>
		<author>
			<persName><forename type="first">H</forename><surname>Sharangpanai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Arora</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="24" to="43" />
			<date type="published" when="2000">2000. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Static load classification for improving the value predictability of data-cache misses</title>
		<author>
			<persName><forename type="first">M</forename><surname>Burtscher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Diwan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hauswirth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN&apos;2002 Conference on Programming Language Design and Implementation</title>
		<meeting>the ACM SIGPLAN&apos;2002 Conference on Programming Language Design and Implementation<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="222" to="233" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Static classification of value predictability using compiler hints</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Lilja</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="929" to="944" />
			<date type="published" when="2004-08">Aug. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Compiler directed early register release</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F P</forename><surname>O'boyle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Abella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Ergin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PACT &apos;05: Proceedings of the 14th International Conference on Parallel Architectures and Compilation Techniques</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="110" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Accurate critical path prediction via random trace construction</title>
		<author>
			<persName><forename type="first">P</forename><surname>Salverda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Tucker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zilles</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CGO &apos;08: Proceedings of the sixth annual IEEE/ACM international symposium on Code generation and optimization</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="64" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A generalized algorithm for graph-coloring register allocation</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ramsey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Holloway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI &apos;04: Proceedings of the ACM SIGPLAN 2004 conference on Programming language design and implementation</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="277" to="288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">SimpleScalar: An infrastructure for computer system modeling</title>
		<author>
			<persName><forename type="first">T</forename><surname>Austin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Larson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Ernst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="59" to="67" />
			<date type="published" when="2003-02">Feb. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">PTLsim: A cycle accurate full system x86-64 microarchitectural simulator</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Yourst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Symposium on Performance Analysis of Systems and Software (ISPASS 2007)</title>
		<imprint>
			<date type="published" when="2007-04">Apr. 2007</date>
			<biblScope unit="page" from="23" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Accuracy of profile maintenance in optimizing compilers</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th Annual Workshop on Interaction between Compilers and Computer Architectures</title>
		<meeting>the 6th Annual Workshop on Interaction between Compilers and Computer Architectures</meeting>
		<imprint>
			<date type="published" when="2002-02">Feb. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Code placement for improving dynamic branch prediction accuracy</title>
		<author>
			<persName><forename type="first">D</forename><surname>Jim?nez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN&apos;2005 Conference on Programming Language Design and Implementation</title>
		<meeting>the ACM SIGPLAN&apos;2005 Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="107" to="116" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
