<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Cause Clue Clauses: Error Localization using Maximum Satisfiability *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Manu</forename><surname>Jose</surname></persName>
							<email>mjose@cs.ucla.edu</email>
						</author>
						<author>
							<persName><forename type="first">Rupak</forename><surname>Majumdar</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Los Angeles</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Los Angeles</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<address>
									<settlement>San Jose</settlement>
									<region>California</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Cause Clue Clauses: Error Localization using Maximum Satisfiability *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">221F85399AEBE29F9119BABB2361DF5A</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.2.5 [Software Engineering]: Testing and Debugging-Fault-localization; F.3.2 [Logics and Meaning of Programs]: Semantics of Programming Languages-Program Analysis General Terms Verification</term>
					<term>Reliability Debugging</term>
					<term>Fault localization</term>
					<term>Maximum Satisfiability</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Much effort is spent by programmers everyday in trying to reduce long, failing execution traces to the cause of the error. We present an algorithm for error cause localization based on a reduction to the maximal satisfiability problem (MAX-SAT), which asks what is the maximum number of clauses of a Boolean formula that can be simultaneously satisfied by an assignment. At an intuitive level, our algorithm takes as input a program and a failing test, and comprises the following three steps. First, using bounded model checking, and a bound obtained from the execution of the test, we encode the semantics of a bounded unrolling of the program as a Boolean trace formula. Second, for a failing program execution (e.g., one that violates an assertion or a post-condition), we construct an unsatisfiable formula by taking the formula and additionally asserting that the input is the failing test and that the assertion condition does hold at the end. Third, using MAX-SAT, we find a maximal set of clauses in this formula that can be satisfied together, and output the complement set as a potential cause of the error.</p><p>We have implemented our algorithm in a tool called BugAssist that performs error localization for C programs. We demonstrate the effectiveness of BugAssist on a set of benchmark examples with injected faults, and show that in most cases, BugAssist can quickly and precisely isolate a few lines of code whose change eliminates the error. We also demonstrate how our algorithm can be modified to automatically suggest fixes for common classes of errors such as off-by-one.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>A large part of the development cycle is spent in debugging, where the programmer looks at a long, failing, trace and tries to localize the problem to a few lines of source code that elucidate the cause of the problem. We describe an algorithm for fault localization for software that automates this process. The input to our algorithm is a program, a correctness specification (either a post-condition, an assertion, or a "golden output"), and a program input and corresponding execution (called the failing execution) that demonstrates the violation of the specification. The output is a minimal set of program statements such that there exists a way to replace these statements such that the failing execution is no longer valid.</p><p>Internally, our algorithm uses symbolic analysis of software based on Boolean satisfiability, and reduces the problem to maximum Boolean satisfiability. It takes as input a program and a failing test case and performs the following three steps. First, it constructs a symbolic trace formula for the input program. This is a Boolean formula in conjunctive normal form such that the formula is satisfiable iff the program execution is feasible (and every satisfiable assignment to the formula corresponds to the sequence of states in a program execution). The trace formula construction proceeds identically to symbolic execution or bounded model checking algorithms <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b14">15]</ref>.</p><p>Second, it extends the trace formula by conjoining it with constraints that ensure the initial state satisfies the values of the failing test and the final states satisfy the program post-condition that was failed by the test. The extended trace formula essentially states that starting from the test input and executing the program trace leads to a state satisfying the specification. Obviously, the extended trace formula for a failing execution must be unsatisfiable.</p><p>Third, it feeds the extended trace formula to a maximum satisfiability solver. Maximum satisfiability (MAX-SAT) is the problem of determining the maximum number of clauses of a given Boolean formula that can be satisfied by any given assignment. Our tool computes a maximal set of clauses of the extended trace formula that can be simultaneously satisfied, and takes the complement of this set as a candidate set of clauses that can be changed to make the entire formula satisfiable. Since each clause in the extended trace formula can be mapped back to a statement in the code, this process identifies a candidate localization of the error in terms of program statements. Note that there may be several minimal sets of clauses that can be found in this way, and we enumerate each minimal set as candidate localizations for the user. In our experiments, we have found that the number of minimal sets enumerated in this way remains small.</p><p>More precisely, our algorithm uses a solver for partial MAX-SAT. In partial MAX-SAT, the input clauses can be marked hard or soft, and the MAX-SAT instance finds the maximum number of soft clauses that can be satisfied by an assignment which satisfies every hard clause. In our algorithm, we mark the input constraints (that ensure that the input is a failing test) as well as constraints arising from the specification are hard. This is necessary: otherwise, the MAX-SAT algorithm can trivially return that changing an input or changing the specification can eliminate the failing execution. In addition, in our implementation, we group clauses arising out of the same program statement together, thus keeping the resulting MAX-SAT instance small.</p><p>We have implemented our algorithm in a tool called BugAssist for fault localization of C programs. <ref type="foot" target="#foot_0">1</ref> BugAssist takes as input a C program with an assertion, and a set of failing test cases, and returns a set of program instructions whose replacement can remove the failures. It builds on the CBMC bounded model checker for construction of the trace formula and an off-the-shelf MAX-SAT solver <ref type="bibr" target="#b19">[20]</ref> to compute the maximal set of satisfied clauses. We demonstrate the effectiveness of BugAssist on 5 programs from the Siemens set of benchmarks with injected faults <ref type="bibr" target="#b7">[8]</ref>. The TCAS program in the test suite is run with all the faulty versions in detail to illustrate the completeness of the tool. In each case, we show that BugAssist can efficiently and precisely determine the exact (to the human) lines of code that form the "bug". The other 4 programs are used to show the scalability of the tool when used in conjunction with orthogonal error trace reduction methods.</p><p>We can extend our algorithm to suggest fixes for bugs automatically, by noticing that the MAX-SAT instance can be used not only to localize problems, but also to suggest alternate inputs that will eliminate the current failure. In general, this is an instance of Boolean program synthesis, and the cost of the search can be prohibitive. However, we have experimentally validated that automatic suggestions for fixes is efficient when we additionally restrict the search to common classes of programmer errors, such as replacement of comparison operators (e.g., &lt; by ≤) or off-by-one arithmetic errors. For these classes of systems, BugAssist can automatically create suggestions for program changes that eliminate the current failure.</p><p>Error localization is an important step in debugging, and improved automation for error localization can speed-up manual debugging and improve the usability of automatic error-detection tools (such as model checkers and concolic testers). Based on our implementation and experimental results, we feel BugAssist is a simple yet precise technique for error localization. Related Work. Fault localization for counterexample traces has been an active area of research in recent years <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b22">23]</ref>. Most papers perform localization based on multiple program runs, both successful and failing, and defining a heuristic metric on program traces to identify locations which separate failing runs from successful ones.</p><p>Griesmayer et al. <ref type="bibr" target="#b11">[12]</ref> gives a fault localization algorithm for C programs that constructs a modified system that allows a given number of expressions to be changed arbitrarily and uses the counter example trace from a model checker. This requires instrumenting each expression ei in the program with (diag == i?nondet() : ei), where diag is a non deterministic variable and nondet() is a new variable with the size equal to that of ei. The number of diagnosis variables is equal to the number of components that are faulty in the program and need to be analyzed before creating the modified system. So each expression in the program requires a new variable in the modified system along with the diagnosis variables which could blow up the size of the instrumented program under consideration. In this work we avoid these draw-backs using selector variables and efficient MAX-SAT instance formulation using clause grouping technique.</p><p>Many existing algorithms for fault localization <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b32">33</ref>] use the difference between the faulty trace and a number of successful traces. For example, Ball, Naik, and Rajamani <ref type="bibr" target="#b0">[1]</ref> use multiple calls to a model checker and compare the counterexamples to a successful trace. The faults are those transitions that does not appear in a correct trace. Our approach does not require comparing the traces or a successful run of the program as benchmark. We report the exact locations where the bug could be corrected instead of a minimal code fragment or a fault neighbor location.</p><p>Alternate approaches to reducing the cognitive load of debugging are delta debugging <ref type="bibr" target="#b32">[33]</ref>, where multiple runs of the program are used to minimize the "relevant" portion of the input, and dynamic slicing <ref type="bibr" target="#b29">[30]</ref>, where data and control dependence information is used to remove statements irrelevant to the cause of failure. Our technique is orthogonal to delta-debugging and dynamic slicing, and can be composed profitably. In fact, we demonstrate in our experiments how a combination of dynamic slicing and delta debugging, followed by our technique, can allow us to localize faults in long executions.</p><p>While we describe our algorithm in pure symbolic execution terms, our algorithm fits in very well with concolic execution <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b24">25]</ref>, where symbolic constraints are generated while the concrete test case is run. Our motivation for using CBMC was the easy integration with MAX-SAT solvers, but in our implementation, we performed some optimizations (such as using concrete values for external library calls in the trace formula and constantfolding input-independent parts of the constraints) similar to concolic execution.</p><p>Unsatisfiability cores and MAX-SAT have been used successfully for design debugging of gate-level hardware circuits <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b23">24]</ref>. Unsatisfiability cores have also been used to localize overconstrains in declarative models <ref type="bibr" target="#b25">[26]</ref>. The program has a bug. If the input index is equal to 1, then the else-branch sets index to 3, and the subsequent array dereference on line 6 is out of bounds. Testing the program with this input will find the bug, and return a program trace that shows the array bounds violation at the end. But testing or model checking returns a full execution path, including details irrelevant to the specific bug, and do not give the reason for failure, or the cause of the bug. The localization algorithm in BugAssist helps to nail down the issue to a few potential bug locations in the program where the correction has to be made.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Motivating Example</head><p>BugAssist works as follows. Starting with the test input index = 1 and the program, it first constructs a symbolic trace formula TF encoding the program semantics:</p><formula xml:id="formula_0">TF ≡ guard 1 = (index1 = 1)∧ index2 = 2 ∧ index3 = index1 + 2∧ i = guard 1 ?index2 : index3</formula><p>Every satisfying assignment to the trace formula gives a possible execution of the program, and conversely. We assume that integers and integer operations are encoded in a bit-precise way, and without loss of generality, the trace formula is a Boolean formula in conjunctive normal form. In case there are loops in the program, we unroll loops up to a bound computed from the execution of the test input on the program (roughly, we take the bound as the maximum number of times any loop gets executed along the execution, taking nesting into account). We omit the details of the standard encoding from imperative programs to Boolean formulas (see, e.g., <ref type="bibr" target="#b5">[6]</ref>).</p><p>Clearly, at the end of the trace, the assertion i &lt; 3</p><p>does not hold for all inputs to the program. Consider now the formula</p><formula xml:id="formula_1">Φ ≡ index1 = 1 test input ∧ TF trace formula ∧ i &lt; 3</formula><p>assertion which is unsatisfiable. Intuitively, the formula captures the execution of the program starting with the error-inducing test input, and asserts that the assertion holds at the end (a contradiction, by choice of the input).</p><p>We convert Φ to conjunctive normal form (CNF) and feed it to a partial MAX-SAT solver <ref type="bibr" target="#b19">[20]</ref>. A partial MAX-SAT solver takes as input a Boolean formula in CNF where each clause is marked "hard" or "soft," and returns the maximum number of soft clauses (as well as a subset of clauses of maximum cardinality) that can be simultaneously satisfied by an assignment satisfying all the hard clauses. In case of Φ, we make the constraints coming from the test input (index1 = 1) and the assertion (i &lt; 3) as hard, and leave the clauses in the trace formula soft. Intuitively, we ask, given that the input and the assertion are fixed, which parts of the trace formula are consistent with the input and the assertion? The partial MAX-SAT solver then tries to find a set of soft clauses of maximum cardinality which can be simultaneously satisfied while satisfying all the hard clauses. The complement of a set of maximally satisfiable clauses (CoMSS) gives a set of soft clauses of minimum cardinality whose removal would make Φ satisfiable, i.e., consistent with the view that the test input does not break the assertion. By tracing the origins of the clauses in this set to the program, we get a set of program locations that are potential indicators of the error. Using clause grouping, described in Section 3, each line in the program is mapped to a bunch of its soft clauses which are enabled and disabled simultaneously.</p><p>In our example, the hard and soft clauses are:</p><formula xml:id="formula_2">Hard :index1 = 1 ∧ i &lt;<label>3</label></formula><p>Soft :TF MAX-SAT returns that a possible CoMSS maps to the line 4 in the program. This is the unsatisfiable core whose removal or correction can satisfy the formula Φ. We claim that is a potential error location for the program and a fix would be to change the constant to any integer less than 2 and greater than -2.</p><p>If the programmer decides this is not a correct localization, we can generate additional localization candidates as follows. We iterate by making another call to MAX-SAT, but this time make clauses arising out of line 4 hard, i.e., asking the MAX-SAT for possible CoMSS where line 4 is kept unchanged. This reveals another potential bug location in the code. We repeat this process until MAX-SAT finds the formula to be unsatisfiable and such that no clauses can be removed to make the instance satisfiable. The error locations reported by BugAssist are underlined in Program 1. On a closer look, these are all the places where the correction can be made. Either changing the constant value at line 4 or the conditional statement at line 1 can fix the program. Our method is limited by the existing code: we cannot "localize" errors that can only be fixed by adding additional code.</p><p>Notice that our technique is stronger than simply taking the backward slice of the program trace, and gives fine-grained information about potential error locations. The backward slice for this trace contains all the lines 1, 4, and 5. Our algorithm returns lines 1 and 4 separately as potential error locations. However, slicing is an orthogonal optimization which can be applied before applying our technique.</p><p>So far we have focused on error localization. The methodology can be modified to suggest program repairs as well. Intuitively, the fault localization returns a set of program commands that are likely to be wrong. One can then ask, what are potential replacements to these commands that fixes the error? In general, the space of potential replacements is large, and searching this space efficiently is a difficult problem of program synthesis <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b28">29]</ref>. Instead, we take a pragmatic approach and look for possible fixes for common programmer errors.</p><p>Specifically, we demonstrate our idea by fixing "off by one" errors. In this example, the error occurs due to accessing an out of bound array element by one. When BugAssist comes back with line 4 as a potential bug location, we try to "fix" the bug by changing the constant whose new value is one off its current value. So we change the value 2 in this line to 3 or 1 and check if either of these values satisfy the properties. This involves modifying the trace formula appropriately and checking if the failing program execution becomes infeasible with either change. So in this case we create two programs with new constants at line 4 as follows.</p><formula xml:id="formula_3">P rogram1 : index = index + 3 × P rogram2 : index = index + 1 √</formula><p>The new value 1 ensures that the error path is infeasible, and this can be used as a suggestion for repair for the program. The same procedure can be used to check for operator errors like use of plus instead of minus, division instead of multiplication, performing assignment instead of equality test, etc., which are common programmer error patterns.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Preliminaries</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Programs: Syntax and Semantics</head><p>We describe our algorithm on a simple imperative language based on control-flow graphs. For simplicity of description, we omit features such as function calls or pointers. These are handled by our implementation.</p><p>A program G = (X, L, 0, T ) consists of a set X of Booleanvalued variables, a set L of control locations, an initial location 0 ∈ L and a set T of transitions. Each transition τ ∈ T is a tuple ( , ρ, ) where and are control locations and ρ is a constraint over free variables from X ∪ X , where the variables from X denote the values of the variables from X in the next state. For a constraint ρ, we sometimes write ρ(X, X ) to denote that the free variables in ρ come from the set X ∪ X .</p><p>Our notation is sufficient to express common imperative programs (without function calls): the control flow structure of the program is captured by the graph of control locations, and operations such as assignments x := e and assumes assume(p) captured by constraints x = e ∧ {y = y | y ∈ X \ {x}} and p ∧ {x = x | x ∈ X} respectively. A program is loop-free if there is no syntactic loop in the graph of control locations.</p><p>A state of the program P is a mapping from variables in X to Booleans. We denote the set of all program states by v.X. A computation of the program is a sequence m0, s0 m1, s1 . . . ∈ (L × v.X) * , where m0 = 0 is the initial location, and for each i ∈ {0, . . . , k -1}, there is a transition (mi, ρi, mi+1) ∈ T such that (si, si+1) satisfies the constraint ρi.</p><p>An assertion p is a set of program states. A program violates an assertion p if there is some computation m0, s0 . . . m k , s k such that s k is not in p. Typically, assertions can be given as languagelevel correctness requirements (e.g., "no null pointer dereference"), as programmer-specified asserts in the code, or as post-conditions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Trace Formulas</head><p>Given a program and a bound k &gt; 0, we can unwind the graph of control locations to get a simplified program without loops whose computations all have length at most k and such that each computation of the simplified program is also a computation of the original program. From such a loop-free program, we can derive a (quantifier-free) Boolean formula, called the trace formula, such that the set of satisfying assignments to the formula correspond exactly to computations of the program. We briefly describe the construction; see <ref type="bibr" target="#b5">[6]</ref> for details.</p><p>The construction of the trace formula takes a loop-free program P, all of whose computations have length at most k, and recursively constructs a Boolean formula as follows. Let X0, . . . , X k be independent copies of the set of variables X. For each ∈ L and i ∈ {0, . . . , k -1}, let z i be a Boolean variable, and define a constraint φ( , i) as follows:</p><formula xml:id="formula_4">z i ↔ ( ,ρ, )∈T ρ(Xi, Xi+1) ∧ z i+1<label>(1)</label></formula><p>The trace formula is then defined to be the conjunction over ∈ L and i ∈ {0, . . . , k -1} of the constraints in Equation ( <ref type="formula" target="#formula_4">1</ref>), together with the conjunct z 0 0 :</p><formula xml:id="formula_5">z 0 0 ∧ ∈L,i∈{0,...,k-1} φ( , i)<label>(2)</label></formula><p>The construction is well-defined because P is loop-free. While we have described trace formulas for our simple programs, a C program with finite bit width data, e.g., 32-bit integers, can be converted into an equivalent Boolean program by separately tracking each bit of the state, and by interpreting fixed-width arithmetic and comparison operators as corresponding Boolean operations on each individual bit. In particular, our implementation handles all features of ANSI-C, including function calls and pointers. We omit the (standard) details, see e.g., <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b31">32]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Partial Maximum Satisfiability</head><p>Given a Boolean formula in conjunctive normal form, the maximum satisfiability (MAX-SAT) problem asks what is the maximum number of clauses that can be satisfied by any assignment <ref type="bibr" target="#b15">[16]</ref>. The MAX-SAT decision problem is NP-complete; note that a formula is satisfiable iff all its clauses can be satisfied by some assignment.</p><p>The partial maximum satisfiability (pMAX-SAT) problem takes as input a Boolean formula Φ in conjunctive normal form, and a marking of each clause of Φ as hard or soft, and asks what is the maximum number of soft clauses which can be satisfied by an assignment to the variables which satisfies all hard clauses. Intuitively, each hard clause must be satisfied, and we look for the maximum number of soft clauses which may be satisfied under this constraint.</p><p>Recent years have seen a tremendous improvement in engineering efficient solvers for MAX-SAT and pMAX-SAT. The widely used algorithm for MaxSAT is based on branch-and-bound search <ref type="bibr" target="#b16">[17]</ref>, supported by effective lower bounding and dedicated inference techniques. Recently, unsatisfiability based MaxSAT solvers by iterated identification of unsatisfiable sub-formulas was proposed in <ref type="bibr" target="#b9">[10]</ref>. This approach consist of identifying unsatisfiable sub-formulas and relaxing clauses in each unsatisfiable subformulas by associating a relaxation variable with each such clause. Cardinality constraints are used to constrain the number of relaxed clauses <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b19">20]</ref>.</p><p>In addition to solving the decision problem, MAX-SAT solvers also give a set of clauses of maximum cardinality that can be simultaneously satisfied. The complement of these maximum satisfiable subsets (MSS) are a set of clauses whose removal makes the instance satisfiable (CoMSS). Since the maximum satisfiability subset is maximal, the complement of this set is minimal <ref type="bibr" target="#b17">[18]</ref>.</p><p>In this work we make use of these CoMSS which refers to the clauses whose removal can make the system satisfiable. Since we represent a C program as a boolean satisfiability problem with constraints and properties, the CoMSS are oracles for potential bug locations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Efficient Compilation to MAX-SAT</head><p>A single transition can lead to multiple clauses in the conjunctive normal form of the trace formula. In this section we provide a method to simplify the MAX-SAT problem by grouping together clauses arising out of a single transition in the program.</p><p>For each transition τ = (m, ρ, m ) ∈ T , we introduce a new Boolean variable λτ . Let Λ = {λτ | τ ∈ T }. Let CNF(ρ) be a conjunctive normal form representation of ρ. We augment each clause in CNF(ρ) with λτ . For example, suppose (c 1 1 ∨ . . .) ∧ (c 2 1 ∨. . .) is a conjunctive normal form representation of ρ, then the augmented representation is (¬λτ ∨ c 1 1 ∨ . . .) ∧ (¬λτ ∨ c 2 1 ∨ . . .). The augmentation with λτ has the following effect. When λτ is assigned true, the original clauses in the CNF representation of ρ must be satisfied, while when λρ is assigned false, each augmented clause is already satisfied. This helps to enable and disable the clauses corresponding to each transition by setting and unsetting the λτ variable respectively. The λ-variables are called selector variables.</p><p>We now augment trace formulas with selector variables. Let φ ( , i, Λ) be the formula in which each clause arising out of τ = (•, ρ, •) is augmented with λτ . Instead of Equation ( <ref type="formula" target="#formula_5">2</ref>) for the trace formula, we use the form:</p><formula xml:id="formula_6">z 0 0 ∧ ∈L,i∈{0,...,k-1} φ ( , i, Λ) TF 1 ∧ τ ∈T λτ TF 2<label>(3)</label></formula><p>where we label the two parts of the formula TF1 and TF2 for later reference. Intuitively, clauses from TF1 will be marked as hard clauses to the MAX-SAT solver, and clauses from TF2 will be marked soft. Thus, the MAX-SAT solver will explore the space of possible program statements whose replacement will cause the error to go away. return "No counterexample to p found" 4: else Notice that we allocate a selector variable for each transition of the program, so the number of selector variables is bounded by the size of the program. However, in a trace, the same program transition may occur multiple times (e.g., on unrolling a loop), and there is a distinct clause for each of these occurrences all tagged with the same selector variable.</p><p>We use the abstraction technique on transitions, which correspond to line numbers of code in our implementation, but it is also possible to group the clauses from modules and recursively narrow down the problem to a module, and then to a line.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Algorithm</head><p>We now describe the algorithm for BugAssist. There are two phases of the algorithm: first, generate a failing execution (and a test demonstrating a failing execution), and second, find a minimal set of transitions that can render the failing execution infeasible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Generating Failing Tests</head><p>In our implementation, we use either failing test cases from a test suite as a starting point. If there are no available tests, we use bounded model checking <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b5">6]</ref> to systematically explore program executions and look for potential assertion violations. Once a failing execution is found, the bounded model checking procedure can generate a concrete initial state that leads to the assertion violation as well as the trace formula.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">The Localization Algorithm</head><p>Algorithm 1 shows the BugAssist localization algorithm. Line 1 calls the procedure to generate failing executions for the assertion. If no failing executions are found, the procedure returns. Otherwise, we get a concrete test case test as well as a trace σ demonstrating the failure of the assertion.</p><p>Using the test, the failing execution, and the assertion, we construct two formulas (lines 5,6). The formula ΦH consists of three parts. The first part, [[test]], is a formula asserting that the initial state coincides with the test case that caused the failure. Formally, for a program state s, the constraint</p><formula xml:id="formula_7">[[s]] is defined as {x = s(x) | x ∈ X}.</formula><p>The second part is the assertion p. The third part is the first part TF1(σ) of the trace formula from Equation (3). The formula ΦS is the second part TF2(σ) of the trace formula from Equation <ref type="bibr" target="#b2">(3)</ref>.</p><p>Notice that ΦH ∧ ΦS is unsatisfiable. (Intuitively, it says that if the program is run with the test input test, then at the end of the execution trace σ, the assertion p holds.)</p><p>In subsequent calls to pMAX-SAT, clauses in ΦH are treated as hard clauses, and clauses in ΦS are treated as soft clauses. Intuitively, treating ΦS as soft clauses enables us to explore the effect of changing each subset of transitions to see if the failing transition can be made infeasible.</p><p>The search for localizations is performed in the while loop of lines 7-14. During each iteration of the while loop, we call the pMAX-SAT solver and get a CoMSS for the current (ΦH , ΦS) pair. Each of these clauses returned by CoMSS gives potential bug locations in the code, and is output to the programmer.</p><p>Whenever we report a potential bug, we add a hard blocking clause for the corresponding CoMSS, so that in subsequent iterations, this CoMSS is not explored again as a potential cause of error. In many of our experiments, the CoMSS returns a single λρ clause as the indicator of error. In general, it returns more than one selector variable which indicates that the program cannot be fixed by changing any one line but must be changed at multiple locations. (This does happen in experiments.) Adding each of these λρ variables as a new hard clause blocks the occurrence of these clauses in a different clause combination. To avoid this problem, we compute a blocking clause β (lines 13) and make the blocking clause hard. For example, suppose the coMSS returned is, BugLoc = {λ1, λ2, . . . , λ k }. This means that the bug can be fixed by making simultaneous changes to these k locations. In the next iteration, we add a new hard clause (λ1 ∨ . . . ∨ λ k ) which ensures that this particular CoMSS is not encountered again, but other combinations of these locations are still allowed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Dealing with Multiple Locations</head><p>BugAssist may return multiple locations where a correction is possible. The experimental results in section 6.1 shows that the number of potential error locations returned is quite small and, in most cases, the exact bug location is reported using a single failing execution. However, for reliability and further refinement of bug locations, we use a ranking mechanism for bug locations by running the localization algorithm repeatedly with different failing program traces and ranking the bug locations based on their frequency of appearance in each of these runs. For test cases, this requires access to a set of tests that all fail the assertion. For counterexample generation using bounded model checking, we take the Boolean formula constructed by the bounded model checker and generate multiple satisfying assignments by changing the order of variables in the SAT algorithm <ref type="bibr" target="#b6">[7]</ref> or by doing a random restart of the solver. Running BugAssist with these new values gives a another set of potential bug locations. Repeating this process and ranking the bug locations can narrow down the search to a few lines in the program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Extensions</head><p>We now describe two extensions to the basic algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Extension 1: Automated Repair</head><p>BugAssist can be extended to suggest potential repairs automatically. In general, program repair reduces to program synthesis. We sacrifice generality for practicality by focusing on specific program repairs inspired by program mutation testing and checking if there is a possible repair from this class that can remove the current test failures. For example, if there is a constant used in a potential error location, we try to synthesize a new constant which can fix the code <ref type="bibr" target="#b11">[12]</ref>, or if there is an operator used in a potential error location, we try to generate a repair by mutating the operator to a different one. We demonstrate this capability by generating suggestions for fixing off-by-one errors <ref type="bibr" target="#b30">[31]</ref> in the program. These are a common class of logical errors in programs arising when programmers use an expression e in the program when they should be using e ± 1. For example, this can happen if programmers forget that a sequence starts at zero rather than one (e.g. array indices in many languages like C, C++). It is also caused during boundary check conditions by using a &lt; instead of ≤ or vice versa.</p><p>During the code parsing phase, we mark lines which have constants in them. After running BugAssist on the code, we look at potential error locations, and for each constant c in this set, we introduce an indicator variable ic that takes values in the set {-1, 0, 1}. We replace the constant c with the expression c + ic in the code. Now, we ask if there exist values to the indicator variables that ensures that the new trace is infeasible. This is a Σ2 query (does there exist values of ic such that for all inputs the trace formula is infeasible), and cannot be directly solved by a SAT solver (see <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b28">29]</ref> for extensions to SAT solvers to solve this problem). In our implementation, we restrict the number of non-zero indicator variables and iteratively call a SAT solver for each assignment of the indicator variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Extension 2: Debugging Loops</head><p>Bugs within loop bodies can be particularly hard to debug as they might be hidden in initial iterations and only visible afterwards. The usual bounded model checking methodology to verify properties is by unwinding loops by duplicating the loop body K times for a limit K on the number of unwindings. The programmer would be interested in knowing the iteration at which the assertion is violated to get a better idea about the cause of the error. We suggest a method to catch the potential iteration of the loop where the bug appeared first.</p><p>We can do this by grouping clauses and assigning weights to the soft clauses in the pMAX-SAT instance, and using a weighted version of the pMAX-SAT algorithm. Each time a loop body is duplicated (till the bound K), we create a new selector variable. For example, for a transition τ = (m, ρ, m ) ∈ T in the loop body, during the i th unwinding, we augment each clause arising out of ρ with λ i τ . We add these selector variables as soft clauses to the pMAX-SAT instance as before, but additionally assign a weight as follows:</p><formula xml:id="formula_8">Weight(λ i τ ) = α + K -i<label>(4)</label></formula><p>for each i = 1, . . . , K, where α is some default weight for soft clauses. This makes sure that the clauses corresponding to the initial iterations of the loop gets a higher weightage. The weights assigned to the soft clauses in the pMAX-SAT can be thought of as the penalty that has to be paid to falsify the clauses. The solver extracts the CoMSS in such a way that clauses from initial iterations are preferred over clauses from later iterations, since the former have higher weights. This helps to localize the first iteration of the loop which can reproduce the failure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Experimental Results</head><p>We now demonstrate the capability of the tool by showing the results from running programs from the Siemens test suite <ref type="bibr" target="#b7">[8]</ref>. The Siemens test suite is widely used in the literature for bug localization studies <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b22">23]</ref>. In Section 6.1, we analyze a simple TCAS program from the Siemens suite <ref type="bibr" target="#b13">[14]</ref> in depth and in Section 6.2 we illustrate the scalability of our method using more complex examples.</p><p>In our implementation, we used the bounded model checker CBMC <ref type="bibr" target="#b5">[6]</ref> to generate failing test inputs as well as to construct the trace formula for an unrolling of the program. For solving the pMAX-SAT instances, we used the Maximum Satisfiability with UNsatisfiable COREs (MSUnCORE) tool <ref type="bibr" target="#b19">[20]</ref>, which can handle large and complex weighted partial MAX-SAT problems. Fixes for off-by-one errors were synthesized using the MiniSAT2 [9] SAT  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">TCAS Experiments</head><p>The TCAS task of the Siemens test suite implements an aircraft collision avoidance system. It consists of 173 lines of code. The authors have created 41 versions of the program by injecting one or more faults. Their goal was to introduce faults that were as realistic as possible, based on their experience with real programs. We refer to the versions as "v1" to "v41". The Siemens test suite also contains 1600 test cases which are valid inputs for the program.</p><p>We created the golden outputs for these 1600 test cases by running the original version of the program. Then for each of the faulty versions, we ran those 1600 test vectors and matched with the golden outputs to segregate the failing test cases. Since the program does not contain a specification, we use the failing test cases as counterexamples and the correct value as its specification.</p><p>Table <ref type="table" target="#tab_3">1</ref> shows the result of running BugAssist on the TCAS test suite. BugAssist ran 1440 times over all versions and 1367 of these runs pin-pointed the exact bug location, i.e., in 95% of the total runs. The "T C#" in the for each version. We ran BugAssist with each of these failing test cases as failing program executions and the golden output as the assertion to be satisfied. The column "Error#" shows the number of errors injected in to each version. Most versions have only 1 error but some have 2 and 3 errors. "Detect#" is the number of runs of BugAssist which detected the correct (human-verified) bug location. "SizeReduc%" is the percentage reduction in the code size given by the tool to locate the bug, the ratio of bug locations returned by the tool to the total number of lines in the code. The "RunT ime" shows the run time for each run of BugAssist in seconds and they are negligible. The last column is the type of bug which is explained in Table <ref type="table" target="#tab_4">2</ref>. For example, the version v2 has one error injected and has 69 failing test cases. We collected the bug locations reported during these 69 runs of the tool which gave 8 potential bug locations, which is 4.6% of the total line number's in the program. The exact location of the fault is contained in the localizations obtained from all the 69 runs. Except for a few versions like v12, v28 and v35, BugAssist detected the correct bug location for all the runs. For the remaining ones, when we rank locations based on frequency of being reported as bugs, exact bug locations had a count more than half of the total number of runs. The runs in which exact location was not reported did give clues about the real bug. For example, some test cases had wrong constant value assignment to an array element, for which the tool reported the fault at places where that array is accessed rather than the line at which the bad assignment occurred. By analyzing the error locations it is quite evident that the error is due to a wrong value in that array location. On average the number of lines to check for potential bug is reduced to 8% of the total code. It should be noted that most of the single runs of the faulty version have captured the exact bug location.</p><p>Figure <ref type="figure" target="#fig_1">1</ref> gives an overview of a version of tcas (v2). The bug is in line 2 (and the original code is shown commented out in line 3). The bug is injected in function Inhibit Biased Climb at line 2 by changing the constant value. The declaration and initialization of variables, functions, and conditional statements that are not relevant to this bug are omitted in the figure. The program needs to satisfy the safety property alt sep test() should return DOWNWARD RA and is given as assertion at line 37. There were 69 failing test cases for this version. We ran all these test cases and the tool returned 8 potential bug locations which are shown underlined in Figure <ref type="figure" target="#fig_1">1</ref>.</p><p>There is no error reported in function Non Crossing Climb() because the call for that function at line 25 needs the function Own Below Threat() to be true, but that is false based on a comparison on the input parameters which are made hard clauses. Now lets take a closer look at the reported errors.</p><p>1. Line 34 is too weak for a fix because changing the return value can make the assertion always true and that does not serve as a suitable fix.</p><p>2. In line 26, setting the need downward RA variable to true can pick the right value for alt sep. This decision is made by an evaluation of the two functions in that statement. The function Own Above Treat() returns true based on the input and it is clear that the correction needs to be done to the function call Non Crossing Decend().</p><p>3. The function Non Crossing Decend() has a call for the actual faulty function at line 14. It also shows that the repair could be done by changing the return value of this function at line 19 (which we ignore as in case 1 above), or where the wrong evaluation happens (lines 15,16).</p><p>4. The actual bug at line 2 is reported as a potential bug location in all the runs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Larger Examples</head><p>To show the performance and applicability of our approach for larger programs and in the presence of complex pointers and loops, we chose a set of other test cases with function calls, recursion, dynamic memory allocation, loops, and complex programming constructs.</p><p>The TCAS test cases were small enough to allow the MAX-SAT solver to deal with the Boolean trace formula without additional optimizations. However, for larger programs, the trace formula obtained by unrolling a program, and the corresponding MAX-SAT instance, was beyond the capacity of the MAX-SAT solver. Therefore, we combine our technique with existing trace reduction techniques like program slicing (S) <ref type="bibr" target="#b29">[30]</ref>, concolic execution (C) <ref type="bibr" target="#b10">[11]</ref>, and isolating failure-inducing input using delta debugging (D) <ref type="bibr" target="#b33">[34]</ref>.</p><p>Table <ref type="table">3</ref> shows the result of running BugAssist on 4 other programs from the Siemens suite, each with one injected fault. "Program" shows the name of the program from the Siemens testsuite. "LOC#" is the total lines of code in the program and "Proc#", the number of procedure calls. The kind of reduction technique is specified in "Reduc" and "assign#" shows the size of the dynamic error trace as the number of assignment expressions before and after performing the reduction technique. The "var#" and "clause#" is the number of boolean variables and clauses in the MAX-SAT representation of the error trace both before and after the reduction step (the unit "m" denotes million). The number of potential fault locations returned by the tool is given under "Fault#". The column "Time" shows the runtime in seconds (s) or (in one case) hours (h).</p><p>We picked a faulty version of the program and one test input that reveals the bug. The golden output from the non-faulty program with the same input is given as a post condition on the return value of the faulty version. Trace reduction techniques are applied to the program execution with this input to generate a smaller trace formula and given as input to BugAssist. The tool reported the exact bug location in all programs except one (Program 2: print token). Trace reduction techniques significantly reduced the resulting trace and the size of the MAX-SAT instance, as shown in "Before" and "After" sizes in Table <ref type="table">3</ref>. The cardinality of the potential fault location set for each of these programs turns out to be small. In all cases, the run time of the tool was smaller than our human effort required to isolate the fault on the original trace. This shows the applicability of the approach.</p><p>• The error inducing input to Program totinfo was the rows and columns of a matrix. The bug was in the constant value of a conditional operator on checking the product of rows and columns after a few other operations. A simple program slicing removed the assignments irrelevant to the assertion being checked and reduced the number of assignments to 21 and the run time to less than a second. • Program print token contained a recursive function "next token" and the input to the program required the loops to be unrolled 8 times in the symbolic trace formula generation. This made the recursive function to have 64 instances in the symbolic trace and the number of assignments went up to 65K without concolic execution. Using concrete execution for the recursive function and variables, the number of assignment statements was bought down to 239. It should be noted that the limitation in using a concrete execution would be to assume that the bug is not present in the functions and loops which are concretized. However, this methodology fits well in programs using functions from a reliable library or for functions which are already verified to be bug free. This program did not show error at the exact location, which was a comparison on a variable which got the value from the execution. This was because the constant propagation used by the symbolic trace generator abstracted away the variable since value was a constant. Instead, the error was shown in the assignment of the variable to the constant. • The priority scheduler program 3 and 4, contained a large error inducing input which called a number of procedures before deviating from the golden output of the original program. The trace size was significantly reduced after isolating the error inducing input using delta debugging, but was still quite big (about 400 and 5400 assignment operations respectively).</p><p>In program 3, the off-by-one error on flushing the number of processes was detected by the presence of a single process creation (leading to a trace of about 400 assignments Table <ref type="table">3</ref>. Running BugAssist on larger benchmark programs from the Siemens Test Suite copying the n characters at line 17, the implementation writes to the (n + 1)st location of the string dest on line 18. This implies that the function MyFunCopy should be using SIZE -1 as the last argument to strncat.</p><p>We ran BugAssist on this function, checking whether array accesses are within bounds. We made the assumption that library functions cannot be modified, and the error lies in the client code. That is, in the pMAX-SAT problem formulation, we made constraints arising out of library functions (strncat in this case) hard clauses. BugAssist located line 6 as a potential bug location in the code. This location is marked during preprocessing as a statement with a constant; so BugAssist now tries to fix it by changing the value to SIZE -1 and SIZE + 1 as explained before. This creates two SAT instances with the new constant values, and we use a SAT solver to check if the error is still feasible. In this example, the change to SIZE -1 eliminated the bug. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Finding Faulty Loop Iterations</head><p>Program 3 contains a function to find the nearest integer square root of a value. The post condition is specified as an assertion, and states that the result res should be the closest square root for val. The bug locations reported by BugAssist are underlined. The correct code is given as a comment on line 13. Even though the actual bug is not in the loop body, it requires an analysis of the loop body to conclude that the right fix is at line 12. We gave the unwinding limit 50 to CBMC and BugAssist reports a potential repair at line 10 in the 8 th iteration of the loop. This gives clue to the programmer that the error occurs if the loop is iterated atleast 8 times.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Discussions</head><p>Program analysis based on Boolean satisfiability has been extremely successful in detecting subtle errors in large software programs <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b31">32]</ref>. We show that techniques based on Boolean MAX-SAT can be similarly effective in localizing program errors (as well as in identifying potential fixes).</p><p>Our fault localization algorithm depends on the underlying Boolean transform of the program to clauses, and is limited by the scalability of bounded model checking tools. In most cases, a single failing input was sufficient to locate the exact error location. Each of the potential error locations are the unsatisfied clauses in each iteration of the MAX-SAT solver. Our fault correction algorithm works by changing existing clauses. We cannot detect or correct code omission faults.</p><p>Our experimental results show that trace reduction techniques are crucial in making our implementation scale to reasonably large examples. Trace reduction techniques, such as delta-debugging or slicing, are orthogonal to our approach, and we can build on the extensive literature in these fields. Additionally, the performance can be improved by using an incremental SAT solver for iterative applications of MAX-SAT. While we have described error localization at the line-number (or program statement) level, our reduction to pMAX-SAT is general, and can be used at different levels of granularity. For example, to localize bugs at the function or module level, we can group clauses coming from the same function or module in the pMAX-SAT instance.</p><p>To improve the usability of our tool, we have built an Eclipse plugin to use BugAssist interactively during the development process. The plugin marks potential bugs in the code under development and assists in analyzing the right fix.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>5 :β</head><label>5</label><figDesc>ΦH = [[test]] ∧ p ∧ TF1(σ) = {λi | λi ∈ BugLoc} 14: ΦS = ΦS\β and ΦH = ΦH ∪ β</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Sample TCAS code. Potential bug locations identified by BugAssist are underlined. Original code on line 3; mutation on line 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Algorithm 1 Localization Algorithm Input: Program P and assertion p Output: Either p holds for all executions or potential bug locations 1: (test, σ) = GenerateCounterexample(P, p)</figDesc><table /><note><p>2: if σ is "None" then 3:</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1 .</head><label>1</label><figDesc>table is the number of failed test cases Results of running BugAssist on the TCAS task of the Siemens Test Suite</figDesc><table><row><cell cols="5">Version TC# Error# Detect# Size</cell><cell cols="6">Run Error -Version TC# Error# Detect# Size</cell><cell cols="2">Run Error</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="3">Reduc% Time Type</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">Reduc% Time Type</cell></row><row><cell>v1</cell><cell>132</cell><cell>1</cell><cell>132</cell><cell>8.6</cell><cell>0.016 op</cell><cell>v21</cell><cell>16</cell><cell>1</cell><cell>16</cell><cell>8.6</cell><cell>0.108</cell><cell>op</cell></row><row><cell>v2</cell><cell>69</cell><cell>1</cell><cell>69</cell><cell>4.6</cell><cell>0.068 const</cell><cell>v22</cell><cell>11</cell><cell>1</cell><cell>11</cell><cell>5.7</cell><cell cols="2">0.056 code</cell></row><row><cell>v3</cell><cell>23</cell><cell>1</cell><cell>13</cell><cell>9.8</cell><cell>0.096 op</cell><cell>v23</cell><cell>42</cell><cell>1</cell><cell>41</cell><cell>6.3</cell><cell cols="2">0.100 code</cell></row><row><cell>v4</cell><cell>26</cell><cell>1</cell><cell>26</cell><cell>9.2</cell><cell>0.104 op</cell><cell>v24</cell><cell>7</cell><cell>1</cell><cell>7</cell><cell>8.6</cell><cell>0.092</cell><cell>op</cell></row><row><cell>v5</cell><cell>10</cell><cell>1</cell><cell>10</cell><cell>8.6</cell><cell>0.120 assign</cell><cell>v25</cell><cell>3</cell><cell>1</cell><cell>3</cell><cell>6.9</cell><cell cols="2">0.068 code</cell></row><row><cell>v6</cell><cell>12</cell><cell>1</cell><cell>12</cell><cell>8.6</cell><cell>0.108 op</cell><cell>v26</cell><cell>11</cell><cell>1</cell><cell>11</cell><cell>9.2</cell><cell cols="2">0.108 addcode</cell></row><row><cell>v7</cell><cell>36</cell><cell>1</cell><cell>36</cell><cell>9.2</cell><cell>0.072 const</cell><cell>v27</cell><cell>10</cell><cell>1</cell><cell>10</cell><cell cols="3">10.9 0.108 addcode</cell></row><row><cell>v8</cell><cell>1</cell><cell>1</cell><cell>1</cell><cell>8.6</cell><cell>0.112 const</cell><cell>v28</cell><cell>76</cell><cell>1</cell><cell>58</cell><cell>5.7</cell><cell cols="2">0.080 Branch</cell></row><row><cell>v9</cell><cell>9</cell><cell>1</cell><cell>9</cell><cell>5.2</cell><cell>0.092 op</cell><cell>v29</cell><cell>18</cell><cell>1</cell><cell>14</cell><cell>5.7</cell><cell cols="2">0.092 code</cell></row><row><cell>v10</cell><cell>14</cell><cell>2</cell><cell>14</cell><cell>9.2</cell><cell>0.136 op</cell><cell>v30</cell><cell>58</cell><cell>1</cell><cell>58</cell><cell>5.7</cell><cell cols="2">0.064 code</cell></row><row><cell>v11</cell><cell>14</cell><cell>2</cell><cell>14</cell><cell>6.3</cell><cell>0.080 op</cell><cell>v31</cell><cell>14</cell><cell>2</cell><cell>14</cell><cell cols="3">10.9 0.008 addcode</cell></row><row><cell>v12</cell><cell>70</cell><cell>1</cell><cell>48</cell><cell>9.2</cell><cell>0.164 op</cell><cell>v32</cell><cell>2</cell><cell>2</cell><cell>2</cell><cell cols="3">10.9 0.004 addcode</cell></row><row><cell>v13</cell><cell>4</cell><cell>1</cell><cell>4</cell><cell>9.2</cell><cell>0.080 const</cell><cell>v34</cell><cell>77</cell><cell>1</cell><cell>77</cell><cell>8.6</cell><cell>0.100</cell><cell>op</cell></row><row><cell>v14</cell><cell>50</cell><cell>1</cell><cell>50</cell><cell>8.1</cell><cell>0.028 const</cell><cell>v35</cell><cell>76</cell><cell>1</cell><cell>58</cell><cell>5.7</cell><cell cols="2">0.060 code</cell></row><row><cell>v15</cell><cell>10</cell><cell>3</cell><cell>10</cell><cell>7.5</cell><cell>0.104 const</cell><cell cols="2">v36 126</cell><cell>1</cell><cell>126</cell><cell>2.9</cell><cell>0.024</cell><cell>op</cell></row><row><cell>v16</cell><cell>70</cell><cell>1</cell><cell>70</cell><cell>9.2</cell><cell>0.104 init</cell><cell>v37</cell><cell>93</cell><cell>1</cell><cell>93</cell><cell>8.6</cell><cell cols="2">0.040 index</cell></row><row><cell>v17</cell><cell>35</cell><cell>1</cell><cell>35</cell><cell>9.2</cell><cell>0.096 init</cell><cell>v39</cell><cell>3</cell><cell>1</cell><cell>3</cell><cell>6.9</cell><cell>0.088</cell><cell>op</cell></row><row><cell>v18</cell><cell>29</cell><cell>1</cell><cell>29</cell><cell>6.9</cell><cell>0.124 init</cell><cell cols="2">v40 126</cell><cell>2</cell><cell>126</cell><cell>6.3</cell><cell cols="2">0.088 assign</cell></row><row><cell>v19</cell><cell>19</cell><cell>1</cell><cell>19</cell><cell>9.2</cell><cell>0.112 init</cell><cell>v41</cell><cell>20</cell><cell>1</cell><cell>20</cell><cell>8.6</cell><cell cols="2">0.120 assign</cell></row><row><cell>v20</cell><cell>18</cell><cell>1</cell><cell>18</cell><cell>9.2</cell><cell>0.120 op</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell></cell></row><row><cell cols="4">Error Type Explanation for the error</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>op</cell><cell cols="3">Wrong operator usage</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="3">e.g.: &lt;= instead of &lt;</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">code Logical coding bug</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">assign Wrong assignment expression</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">addcode Error due to extra code fragments</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">const Wrong constant value supplied</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="3">e.g.: off-by-one error</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>init</cell><cell cols="5">Wrong value initialization of a variable</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">index Use of wrong array index</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="6">branch Error in branching due to negation of</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="3">branching condition</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 .</head><label>2</label><figDesc>Type of error</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>). However, program 4 required a much larger input and more procedures to expose the failure, resulting in a longer trace. It took BugAssist almost 11 hours to find the exact location (excluding the time taken for input minimization using delta debugging). Each execution of MAX-SAT took around 30 minutes to identify one potential fault location.We demonstrate the repair capability of BugAssist by synthesizing fixes for off-by-one errors in the use of standard C library routines. We focus on off-by-one errors arising out of the misuse of the C strncat string manipulation function<ref type="bibr" target="#b20">[21]</ref>. A common misconception with strncat is that the guaranteed null termination will not write beyond the maximum length. In reality, strncat can write a terminating null character one byte beyond the maximum length specified.The Program 2 shows an instance of the bug in the function MyFunCopy, which takes a string s and uses the strncat routine to copy the contents to a string buf of length SIZE. The lines 10-20 shows a standard C implementation of strncat. Note that after</figDesc><table><row><cell></cell><cell cols="4">Program LOC# Proc# Reduc</cell><cell cols="2">assign#</cell><cell>var#</cell><cell cols="2">clause#</cell><cell>Fault# time</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">Before After Before After</cell><cell>Before</cell><cell>After</cell></row><row><cell>1</cell><cell>totinfo</cell><cell>565</cell><cell>7</cell><cell>S</cell><cell>734</cell><cell cols="2">21 0.797m 400</cell><cell>1.822m</cell><cell>1225</cell><cell>2 0.19s</cell></row><row><cell cols="3">2 print tokens 726</cell><cell>18</cell><cell cols="6">C 65698 239 5.507m 7439 53.483m 22634</cell><cell>13</cell><cell>25s</cell></row><row><cell cols="2">3 schedule</cell><cell>564</cell><cell>21</cell><cell cols="7">DS 5914 391 5.173m 0.053m 15.379m 0.142m 13</cell><cell>28s</cell></row><row><cell cols="2">4 schedule</cell><cell>564</cell><cell>21</cell><cell cols="7">DS 41942 5412 78.982m 4.517m 239.385m 13.788m 25</cell><cell>11h</cell></row><row><cell>5</cell><cell>totinfo</cell><cell>565</cell><cell>7</cell><cell>CS</cell><cell cols="5">865 454 0.862m 0.734m 4.156m 3.728m</cell><cell>3</cell><cell>225s</cell></row><row><cell cols="3">6 schedule2 374</cell><cell>16</cell><cell>S</cell><cell cols="5">398 275 0.021m 0.015m 0.048m</cell><cell>9</cell><cell>20s</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="5">Program 2 The strncpy program with an off-by-one error</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>1</cell><cell cols="2">#define SIZE 15</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>2</cell><cell cols="4">void MyFunCopy (char *s)</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>3</cell><cell>{</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>4</cell><cell cols="3">char buf[SIZE];</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>5</cell><cell cols="4">memset(buf, 0, SIZE);</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>6</cell><cell cols="4">strncat(buf, s, SIZE);</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>7</cell><cell cols="4">/*Last argument should be: SIZE-1 */</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>8</cell><cell cols="2">return;</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>9</cell><cell>}</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="5">/*Standard C implementation of strncat*/</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>10</cell><cell cols="4">char *strncat(char *dest, const char *src,</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>size t n)</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>11</cell><cell>{</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>12</cell><cell></cell><cell cols="3">char *ret = dest;</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>13</cell><cell></cell><cell cols="2">while (*dest)</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>14</cell><cell></cell><cell cols="2">dest++;</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>15</cell><cell></cell><cell cols="2">while (n--)</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>16</cell><cell></cell><cell cols="3">if (!(*dest++ = *src++))</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>17</cell><cell></cell><cell></cell><cell cols="2">return ret;</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>18</cell><cell></cell><cell cols="3">*dest = 0; /*Problem cause*/</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>19</cell><cell></cell><cell cols="2">return ret;</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>20</cell><cell>}</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="4">6.3 Fixing Off-By-One Errors</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>Program 3The nearest integer square root function with a bug at</figDesc><table><row><cell cols="2">line 12</cell></row><row><cell>1</cell><cell>int squareroot()</cell></row><row><cell>2</cell><cell>{</cell></row><row><cell>3</cell><cell>int val = 50;</cell></row><row><cell>4</cell><cell>int i =1;</cell></row><row><cell>5</cell><cell>int v =0;</cell></row><row><cell>6</cell><cell>int res =0;</cell></row><row><cell>7</cell><cell>while(v &lt; val)</cell></row><row><cell>8</cell><cell>{</cell></row><row><cell>9</cell><cell>v = v + 2*i +1;</cell></row><row><cell>10</cell><cell>i = i+1;</cell></row><row><cell>11</cell><cell>}</cell></row><row><cell>12</cell><cell>res = i;</cell></row><row><cell>13</cell><cell>/* res = i -1; */</cell></row><row><cell>14</cell><cell>assert( (res*res &lt;= val) &amp;&amp;</cell></row><row><cell></cell><cell>((res+1)*(res+1) &gt; val);</cell></row><row><cell>15</cell><cell>return res;</cell></row><row><cell>}</cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The tool, Eclipse plugin, and test cases can be downloaded from our web page http://bugassist.mpi-sws.org.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* This research was sponsored in part by the NSF grant CCF-0546170 and the DARPA grant HR0011-09-1-0037.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">From symptom to cause: localizing errors in counterexample traces</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mayur</forename><surname>Naik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sriram</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL &apos;03: Principles of Programming Languages</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="97" to="105" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Symbolic model checking using sat procedures instead of bdds</title>
		<author>
			<persName><forename type="first">A</forename><surname>Biere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fujita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DAC &apos;09: Design Automation Conference</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="317" to="320" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Klee: unassisted and automatic generation of high-coverage tests for complex systems programs</title>
		<author>
			<persName><forename type="first">Cristian</forename><surname>Cadar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Dunbar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dawson</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI &apos;08: Operating Systems Design and Implementation</title>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="209" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Exe: automatically generating inputs of death</title>
		<author>
			<persName><forename type="first">Cristian</forename><surname>Cadar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vijay</forename><surname>Ganesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">M</forename><surname>Pawlowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dawson</forename><forename type="middle">R</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS &apos;06: Computer and Communications security</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="322" to="335" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Spatial and temporal design debug using partial maxsat</title>
		<author>
			<persName><forename type="first">Yibin</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sean</forename><surname>Safarpour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Veneris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joao</forename><surname>Marques-Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GLSVLSI &apos;09: Great Lakes Symposium on VLSI</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="345" to="350" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A tool for checking ANSI-C programs</title>
		<author>
			<persName><forename type="first">Edmund</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Kroening</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Flavio</forename><surname>Lerda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS &apos;04: Tools and Algorithms for the Construction and Analysis of Systems</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">2988</biblScope>
			<biblScope unit="page" from="168" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A computing procedure for quantification theory</title>
		<author>
			<persName><forename type="first">Martin</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hilary</forename><surname>Putnam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="201" to="215" />
			<date type="published" when="1960-07">July 1960</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Supporting controlled experimentation with testing techniques: An infrastructure and its potential impact</title>
		<author>
			<persName><forename type="first">Hyunsook</forename><surname>Do</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Elbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gregg</forename><surname>Rothermel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Empirical Softw. Engg</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="405" to="435" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Minisat v2.0 (beta)</title>
		<author>
			<persName><forename type="first">Niklas</forename><surname>Eén</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Niklas</forename><surname>Sörensson</surname></persName>
		</author>
		<ptr target="http://fmv.jku.at/sat-race-2006/" />
	</analytic>
	<monogr>
		<title level="m">SAT-Race</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">On solving the partial MAX-SAT problem</title>
		<author>
			<persName><forename type="first">Zhaohui</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sharad</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAT &apos;06: Theory and Applications of Satisfiability Testing</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4121</biblScope>
			<biblScope unit="page" from="252" to="265" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Dart: directed automated random testing</title>
		<author>
			<persName><forename type="first">Patrice</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nils</forename><surname>Klarlund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Koushik</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI &apos;05: Programming Language Design and Implementation</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="213" to="223" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Automated fault localization for C programs</title>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Griesmayer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Staber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roderick</forename><surname>Bloem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ENTCS</title>
		<imprint>
			<biblScope unit="volume">174</biblScope>
			<biblScope unit="page" from="95" to="111" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Error explanation with distance metrics</title>
		<author>
			<persName><forename type="first">Alex</forename><surname>Groce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sagar</forename><surname>Chaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Kroening</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ofer</forename><surname>Strichman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Softw. Tools Technol. Transf</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="229" to="247" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Experiments of the effectiveness of dataflow-and controlflow-based test adequacy criteria</title>
		<author>
			<persName><forename type="first">Monica</forename><surname>Hutchins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Herb</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tarak</forename><surname>Goradia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ostrand</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE &apos;94: International Conference on Software Engineering</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="191" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Symbolic execution and program testing</title>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">C</forename><surname>King</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="385" to="394" />
			<date type="published" when="1976-07">July 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">MaxSAT, hard and soft constraints</title>
		<author>
			<persName><forename type="first">Min</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Felip</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><surname>Manyà</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Satisfiability</title>
		<imprint>
			<publisher>IOS Press</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">185</biblScope>
			<biblScope unit="page" from="613" to="631" />
		</imprint>
	</monogr>
	<note>chapter 19</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">New inference rules for MAX-SAT</title>
		<author>
			<persName><forename type="first">Min</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Felip</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jordi</forename><surname>Manyà</surname></persName>
		</author>
		<author>
			<persName><surname>Planes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Artif. Int. Res</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="321" to="359" />
			<date type="published" when="2007-10">October 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">On finding all minimally unsatisfiable subformulas</title>
		<author>
			<persName><forename type="first">H</forename><surname>Mark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Karem</forename><forename type="middle">A</forename><surname>Liffiton</surname></persName>
		</author>
		<author>
			<persName><surname>Sakallah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAT &apos;05: Theory and Applications of Satisfiability Testing</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3569</biblScope>
			<biblScope unit="page" from="173" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">Joao</forename><surname>Marques-Silva</surname></persName>
		</author>
		<title level="m">Minimal unsatisfiability: Models, algorithms and applications</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="9" to="14" />
		</imprint>
	</monogr>
	<note>ISMVL &apos;10: International Symposium on Multiple-Valued Logic</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Algorithms for maximum satisfiability using unsatisfiable cores</title>
		<author>
			<persName><forename type="first">Joao</forename><surname>Marques</surname></persName>
		</author>
		<author>
			<persName><forename type="first">-</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jordi</forename><surname>Planes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DATE &apos;08: Design, Automation and Test in Europe</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="408" to="413" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">strlcpy and strlcat: consistent, safe, string copy and concatenation</title>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">C</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Theo</forename><surname>De</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raadt</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Annual Technical Conference</title>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="175" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Darwin: an approach for debugging evolving programs</title>
		<author>
			<persName><forename type="first">Dawei</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Abhik</forename><surname>Roychoudhury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhenkai</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kapil</forename><surname>Vaswani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESEC/FSE &apos;09: European Software Engineering Conference and Foundations of Software Engineering</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="33" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Fault localization with nearest neighbor queries</title>
		<author>
			<persName><forename type="first">Manos</forename><surname>Renieres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><forename type="middle">P</forename><surname>Reiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASE &apos;03: Automated Software Engineering</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="30" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Improved design debugging using maximum satisfiability</title>
		<author>
			<persName><forename type="first">Sean</forename><surname>Safarpour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hratch</forename><surname>Mangassarian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Veneris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><forename type="middle">H</forename><surname>Liffiton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Karem</forename><forename type="middle">A</forename><surname>Sakallah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FMCAD &apos;07: Formal Methods in Computer-Aided Design</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="13" to="19" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">CUTE: a concolic unit testing engine for C</title>
		<author>
			<persName><forename type="first">Koushik</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Darko</forename><surname>Marinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gul</forename><surname>Agha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESEC/FSE &apos;05: European Software Engineering Conference and Foundations of Software Engineering</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="263" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Debugging overconstrained declarative models using unsatisfiable cores</title>
		<author>
			<persName><forename type="first">Ilya</forename><surname>Shlyakhter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Seater</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Jackson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manu</forename><surname>Sridharan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mana</forename><surname>Taghdiri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASE &apos;03: Automated Software Engineering</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="94" to="105" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Rastislav Bodík, and Kemal Ebcioglu. Programming by sketching for bit-streaming programs. PLDI &apos;05: Programming Languages Design and Implementation</title>
		<author>
			<persName><forename type="first">Armando</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rodric</forename><surname>Rabbah</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>ACM</publisher>
			<biblScope unit="page" from="281" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Combinatorial sketching for finite programs</title>
		<author>
			<persName><forename type="first">Armando</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Liviu</forename><surname>Tancau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rastislav</forename><surname>Bodík</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sanjit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vijay</forename><forename type="middle">A</forename><surname>Seshia</surname></persName>
		</author>
		<author>
			<persName><surname>Saraswat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS &apos;06: Architectural Support for Programming Languages and Operating Systems</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="404" to="415" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">VS3: SMT solvers for program verification</title>
		<author>
			<persName><forename type="first">Saurabh</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sumit</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">S</forename><surname>Foster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV &apos;09: Computer-Aided Verification</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5643</biblScope>
			<biblScope unit="page" from="702" to="708" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A survey of program slicing techniques</title>
		<author>
			<persName><forename type="first">F</forename><surname>Tip</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Programming Languages</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="121" to="189" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Off-by-one error, the free encyclopedia</title>
		<imprint>
			<date type="published" when="2004-03">2004. March-2010</date>
			<publisher>Wikipedia</publisher>
			<biblScope unit="volume">28</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Scalable error detection using boolean satisfiability</title>
		<author>
			<persName><forename type="first">Yichen</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Aiken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL &apos;05: Principles of Programming Languages</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="351" to="363" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Isolating cause-effect chains from computer programs</title>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Zeller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE &apos;10: Foundations of Software Engineering</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Simplifying and isolating failure-inducing input</title>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Zeller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ralf</forename><surname>Hildebrandt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Softw. Eng</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="183" to="200" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
