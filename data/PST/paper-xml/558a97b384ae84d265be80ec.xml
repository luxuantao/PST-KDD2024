<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Service Combinators for Web Computing</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Luca</forename><surname>Cardelli</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Microsoft Research</orgName>
								<address>
									<postCode>CB2 3NH</postCode>
									<settlement>Cambridge</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Rowan</forename><surname>Davies</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Microsoft Research</orgName>
								<address>
									<postCode>CB2 3NH</postCode>
									<settlement>Cambridge</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="middle">L</forename><surname>Cardelli</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<postCode>15017</postCode>
									<settlement>Pittsburgh</settlement>
									<region>PA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Service Combinators for Web Computing</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">507B5AC4ECB980CBD84610CBB2CB7D07</idno>
					<note type="submission">received 23 June 1998; revised 17 Dec. 1998. Recommended for acceptance by D. Wile.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:10+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>1. Uniform Resource Locator [9]</term>
					<term>[12] 2. The HyperText Transfer Protocol is the Web&apos;s communication protocol [3]</term>
					<term>[9]</term>
					<term>[12]</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We would like to be able to write programs that reproduce human browsing behavior, including reactions to slow transmission-rates and failures on many simultaneous links. We thus introduce a concurrent model that directly incorporates the notions of failure and rate of communication, and then describe programming constructs based on this model. Index TermsÐProgramming languages, wide area computation, World Wide Web.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>T HE World Wide Web [1] is a uniform, highly inter- connected collection of computational resources, and as such it can be considered as forming a single global computer. But, what kind of computer is the Web, exactly? And what kind of languages are required for programming such a computer? Before approaching the second question, we must answer the first. In other words, what is the Web's model of computation?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Some Kind of Computer</head><p>We can quickly scan a checklist of possibilities. Is the Web a Von Neumann computer? Of course not: There is no stored program architecture and no single instruction counter. Is the Web a collection of Von Neumann computers? Down below yes, but each computer is protected against outside access: Its Von Neumann characteristics are not exploitable. Is the Web a file system? No, because there is no universally available ªwriteº instruction (for obvious good reasons). Is the Web a distributed database? In many ways yes: It certainly contains a huge amount of information. But, on the one hand the Web lacks all the essential properties of distributed databases, such as precise data schemas, uniform query languages, distributed coherence, consistent replication, crash recovery, etc. On the other hand, the Web is more than a database, because answers to queries can be computed by nontrivial algorithms.</p><p>Is the Web a distributed object system? Now we are getting closer. Unfortunately the Web lacks some of the fundamental properties of traditional (in-memory, or localarea) object systems. The first problem that comes to mind is the lack of referential integrity: a pointer (URL 1 ) on the Web does not always denote the same value as it did in a previous access. Even when a pointer denotes the same value, it does not always provide the same quality of access as it did in a previous access. Moreover, these pointers are subject to intermittent failures of various duration; while this is unpleasant, these failures are tolerated and do not negate the usefulness of the Web.</p><p>Most importantly, though, the Web does not work according to the Remote Procedure Call (RPC) semantics that is at the basis of distributed object systems. For example, if we could somehow replace HTTP 2 requests with RPC requests, we would drastically change the flavor of Web interactions. This is because the Web communication model relies on streaming data. A request results in a stream of data that is displayed interactively, as it is downloaded. It is not that case that a request blocks until it produces a complete result (as in RPC).</p><p>At a more abstract level, here are the main peculiarities of a Web computer, with respect to more familiar computational models. Three new classes of phenomena become observable:</p><p>. Wide-area distribution. Communication with distant locations involves a noticeable delay, and behavior may be location-dependent. This is much more dramatic than the distribution observable on a multiprocessor or a local-area network. It is not possible to build abstractions that hide this underlying reality, if only because the speed of light is a physical limit. . Lack of referential integrity. A URL is a kind of network pointer, but it does not always point to the same entity, and occasionally it does not point at all. This is quite different from a pointer in a programming language. . Quality of service. A URL is a ªpointer with a bandwidth.º The bandwidth of connections varies widely with time and route, and may influence algorithmic behavior. A Web programmer will need to take these new observables into account. This calls for new programming models, and eventually new languages.</p><p>Therefore, there are no good names for describing the computational aspects of the Web. We might as well name such a computer a ªBerners-Lee computer,º after the inventor of HTTP. The model of computation of the Web is implicit in the HTTP protocol and in the Web's hardware and software infrastructure, but the implications of the interaction of the protocol and the infrastructure are not easy to grasp. The protocol is actually quite simple, but the infrastructure is likely to slow down, speed up, crash, stop, hang, and revive unpredictably. When the Web is seen as a computer, e.g., for the purpose of programming it, it is a very unusual computer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Some Kind of Algorithmic Behavior</head><p>What kind of activities can one carry out on such a strange computer? Here is an example of a typical behavior a user might exhibit.</p><p>Hal carries out a preliminary search for some document, and discovers that the document (say, a big postscript file) is available at four servers: in Japan, Australia, North America, and Europe. Hal does not want to start a parallel four-way download at first: it would be antisocial and, in any case, it might saturate his total incoming bandwidth. Hal first tries the North American server, but the server is overloaded and slow in downloading the data. So, he opens another browser window and contacts the European server. This server is much faster, initially, but suddenly the transfer rate drops to almost zero. Will the North American server catch up with it in the end? While he waits to find out, Hal remembers that it is night in Japan and Australia, so the servers should be unloaded and the intercontinental link should not be too congested. So he starts two more downloads. Japan immediately fails, but Australia starts crawling along. Now Hal notices that the European download has been totally idle for a few minutes so he kills it, and waits to see who wins out between Australia and North America.</p><p>What is described above is an instance of an ªalgorithmicº behavior that is used frequently for retrieving data. The decisions that determine the flow of the algorithm are based on the observable semantic properties of the Web: load, bandwidth, and even local time. The question is: what language could one use to comfortably program such an algorithm? An important criterion is that the language should be computationally complete with respect to the observable properties of the Web:</p><p>Every algorithmic behavior should be scriptable.</p><p>That is, if a user sitting in front of (say) a browser carries out a set of observations, decisions, and actions that are algorithmically describable, then it should be possible to write a program that emulates the same observations, decisions, and actions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Some Kind of Run-Time System</head><p>The Web is one vast run-time system that, if we squint a bit, has many of the features of more conventional runtime systems.</p><p>There are atomic data structures (images, sounds, video), and compound data structures (HTML 3 documents, forms, tables, multipart data), as described by various Internet standards. There are pointers (URLs) into a universal address space.</p><p>There are tree and graph structures (XML 4 and MIME 5  multipart/related format) that can be used to transmit complex data. There are standardized type systems for data layout (XML DTD's and MIME media types). There are subroutine calls and parameter passing conventions (HTTP and CGI 6 ). There are plenty of available processors (Web servers) that can be seen as distributed objects that protect and dispense encapsulated data (e.g., local databases). Finally, there are some nice visual debuggers (Web browsers).</p><p>What programming language features could correspond to this run-time system? What could a ªWeb languageº look like? Let's try to imagine it.</p><p>A ªvalueº in a Web language would be a pair of a MIME media type and an appropriate content. (For example, the media type may be image/jpeg and the content would be a jpeg-encoded image.) These values could be stored in variables, passed to procedures, etc. Note that the contents of such values may be in the process of being fetched, so values are naturally concurrently evaluated. Other kinds of values would include gateways and scripts (see below).</p><p>The syntax of a programming language usually begins with the description of the ªliteralsº: the entities directly denoting a value, e.g., a numeral or a string. A ªmedia literalº would be a pair of a media type and a URL indicating the corresponding content. Such a literal would be evaluated to a value by fetching the URL content (and verifying that it corresponds to the claimed media type).</p><p>A ªgateway literalº would be a pair of a Gateway Type and a URL indicating a gateway (e.g., a CGI gateway). The gateway type indicates the parameter passing conventions expected by the gateway (e.g., GET, POST, or ISINDEX) and the media types for the requests and replies. A gateway literal evaluates to a gateway value, which just sits there waiting to be activated.</p><p>A gateway value can be activated by giving it its required parameters. The syntax for such an activation would look like a normal procedure call: g I Y F F F Y n where g is a literal, variable, or expression that produces a gateway value, and the arguments are (normally) media values. The effect of this call is to package the arguments according to the conventions of the gateway, ship them through the appropriate HTTP connection, get the result, and convert it back to a value. The final value may be rendered according to its type. As an example, g might be a constant URL that refers to the Altavista search engine, in which case the arguments would include a phrase for the search engine to look up. The result would most likely be of type text/html, which could be either displayed or processed further.</p><p>We now have primitive data structures (media literals) and primitive control structures (gateway calls). With this much we can already write ªscripts.º These scripts could be stored on the Web as Internet Media, so that a script can refer to another one through a URL. The syntax for script calls would be the same as above. Scripts would have to be closed (i.e., no free variables, except for URLs), for security and network transparency. This is arguably a Web language. The scripts are for the Web (not for a particular operating system or file system) and in the Web (not stored in a particular address space or file). Such a language uses the Web as its run-time system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Other Issues</head><p>Two major issues remain to be addressed.</p><p>The first issue is output parsing. Because of the prominence of browsers and browser-ready content on the Web, the result of a query is almost always returned as an entity of type text/html (a page), even when its only purpose is to present, say, a single datum of type image/ jpeg. The output has to be parsed to extract the information out of the HTML. Although the structure of HTML pages is relatively well defined, the parsing process is delicate, error-prone, and can be foiled by cosmetic changes in the pages. In order to make Web programming possible on a large scale, one needs some uniform way of describing the protocol of a gateway and, by extension, of a script. This problem is in the process of being solved by the XML standards for data description, and by sophisticated pattern-matching languages for web pages <ref type="bibr" target="#b13">[10]</ref>. We will not discuss this topic any further in this paper.</p><p>The second issue is the design of control structures able to survive the flaky connectivity of the Web. This is the topic of the rest of the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">SERVICE ALGEBRA</head><p>Suppose we want to write a program that accesses and manipulates data on the Web. An obvious starting point is an HTTP library, embedded in some programming language, that gives us the ability to issue HTTP calls. Each HTTP call can fail with fairly high probability; therefore, error-handling code must be written using the errorhandling primitives of the language. If we want to write code that reacts concurrently to network conditions and network failures in interesting ways, then the errorhandling code ends up dominating the informationprocessing code. The error-handling and concurrency primitives of common languages are not very convenient when the exceptional code exceeds the normal code.</p><p>An alternative is to try to use high-level primitives that incorporate error handling and concurrency, and that are optimized for Web programming. In this section we introduce such primitives. A service is an HTTP information provider wrapped in error-detection and handling code. A service combinator is an operator for composing services, both in terms of their information output and of their error output, and possibly involving concurrency. The error recovery policy and concurrency are thus modularly embedded inside each service.</p><p>The idea of handling failures with combinators comes, in a sequential context, from LCF tactics <ref type="bibr">[6]</ref>. Perhaps not surprisingly, our combinators have some similarities to those found in concurrent, real-time languages for programming ªreactive systems,º such as Esterel <ref type="bibr">[4]</ref>. One major difference is that our combinator language includes the concept of the ªrate of progress.º We have also tried to concentrate only on those features that allow the easy expression of common web browsing algorithms, so our language is very small and simple. Our language does not appear to allow every possible algorithmic behavior to be expressed: To achieve that goal, we suggest that it would probably be necessary to start with a language like Esterel, and explicitly include the concept of ªrate of progressº in programs. Our combinators could then be provided as a library to allow easy expression of many common web browsing algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Services</head><p>A Web server is an unreliable provider of data: any request for a service has a relatively high probability of failing or of being unacceptably slow. Different servers, though, may provide the same or similar services. Therefore it should be possible to combine unreliable services to obtain more reliable ªvirtual services.º A service, when invoked, may never initiate a response. If it initiates a response, it may never complete it. If it completes a response, it may respond ªservice denied,º or produce a real answer in the form of a stream of data.</p><p>In the period of time between a request and the end of a response, the main datum of interest is the ªtransmission rate,º counted as bytes per second averaged over an interval. It is interesting to notice that the basic communication protocol of the Internet does not provide direct data about the transmission rate: this must be estimated from the outside. We might also be interested in what percentage of the total service has been completed. Unfortunately, many web servers have historically not provided information on the length of the document they are sending, so we were forced to omit this aspect from our language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Service Combinators</head><p>We now describe the syntax and informal semantics of the service combinators in our language. The combinators were chosen to allow common manual Web-browsing techniques to be reproduced with simple programs.</p><p>The syntax for our language is given below in BNF-like notation. We use curly brackets f g for grouping, square brackets for zero or one occurrences, postfix Ã for zero or more occurrences, postfix for one or more occurrences, infix j for disjunction, and simple juxtaposition for concatenation. We use H j H to indicate an occurrence of | in the language itself. For lexical items, I À P indicates a character in the range I À P . </p><formula xml:id="formula_0">sd XX A À Z j a À z j 0 À 9Ã el XX $ higit X higit higit XX 0 À 9</formula><p>The basic model for the semantics of services is as follows: a service may be invoked at any time, and may be invoked multiple times. An invocation will either succeed and return a result after some time, or fail after some time, or continue forever. At each point in time it has a rate which is a real number indicating how fast it is progressing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Basic Service</head><p>urltring. The service urltring fetches the resource associated with the URL indicated by the string. The result returned is the content fetched. The service fails if the fetch fails, and the rate of the service while it is running is the rate at which the data for the resource is being received, measured in kilobytes per second.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">Gateways</head><p>indextringY tring I gateway gettringY sd I tring I F F F sd n tring n gateway posttringY sd I tring I F F F sd n tring n Each of these services is similar to the service urltring, except that the URL String should be associated with a CGI gateway having the corresponding type (index, get or post). The arguments are passed to the gateway according to the protocol for this gateway type.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.3">Sequential Execution</head><p>I c P . The ªcº combinator a secondary service to be consulted in the case that the primary service fails for some reason. Thus, the service I c P acts like the service I , except that if I fails then it acts like the service P .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.4">Concurrent Execution</head><p>I j P . The ª|º combinator allows two services to be executed concurrently. The service I j P starts both services I and P at the same time, and returns the result of whichever succeeds first. If both I and P fail, then the combined service also fails. The rate of the combined service is always the maximum of the rates of I and P .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.5">Time Limit</head><p>timeouttY . The timeout combinator allows a time limit to be placed on a service. The service timeouttY acts like except that it fails after t sec if has not completed within that time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.6">Rate Limit</head><p>limittY rY . This combinator provides a way to force a service to fail if the rate ever drops below a certain limit r. A start-up time of t sec is allowed, since generally it takes some time before a service begins receiving any data.</p><p>In our original design, this start-up time was applied to the whole service . We later realized that this design leads to an unfortunate interaction with some of the other combinators. This is demonstrated by the example: limittY rY I c P X The problem here is that if I fails after the first t sec, then P is initiated but is not allowed any start-up time, so quite likely the whole service fails.</p><p>This motivates the following semantics. The service limittY rY acts like the service , except that each physical connection is considered to have failed if the rate ever drops below r kbytes/sec after the first t sec of the connection. Physical connections are created by invocations of url, index, and gateway combinators.</p><p>In general, a rate limit can be described as a function f from time to rate, and a combinator limitfY could be used; the current combinator could then be defined via a step function. The more general combinator is supported by our semantics, but we decided to adopt the current, simpler, definition.</p><p>We have found this semantics for rate to be useful in many situations, but admittedly it may seem surprising to some users and appear to have some strange interactions with other combinators. In fact, these interactions are quite simple: the limit combinator distributes through all combinators other than physical connections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.7">Repetition</head><p>repeat. The repeat combinator provides a way to repeatedly invoke a service until it succeeds. The service repeat acts like , except that if fails, repeat starts again.</p><p>Unlike many traditional language constructs, the repeat combinator does not include a condition for terminating the loop. Instead, the loop can be terminated in other ways, e.g., timeout(t, repeat. This program repeatedly tries to fetch the URL, but waits 10 sec between attempts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.8">Nontermination</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.9">Failure</head><p>fail. The fail combinator fails immediately. It is hard to construct examples in our small language where this is useful, though we include it anyway for completeness, and because we expect it to be useful when the language is extended to include conditionals and other more traditional programming language constructs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Examples</head><p>We now show some simple examples to illustrate the expressiveness of the service combinators. It is our intention that our service combinators be included as a fragment of a larger language, so for these examples (and in our implementation) we include some extensions. We use ªletº to make top-level bindings, and we use ªfunx bodyº and ªfunction(argument)º for function abstraction and application. It is not completely clear how to define the semantics for these extensions in terms of the service model used above. If we are going to be very Web-oriented, then perhaps functions should be implemented as gateways, and bound variables should actually refer to dynamically allocated URLs. Regardless, for the simple examples which follow, the meaning should be clear, since function declarations could be expanded out. The actual implementation allows more flexible use of functions than this, but we will not elaborate here, since we are not yet sure of exactly what status functions should have in our language. We would also like to point out that by embedding our language in a host language, as we have done with Java (see Section 4), we need only make use of the abstraction mechanisms provided by the host language. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">FORMAL SEMANTICS</head><p>We now give a formal semantics for the service combinators.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The Meaning Function</head><p>The basic idea of the semantics is to define the status of a service at a particular time u, given the starting time t. Possible values for this status are hrate, ri, hdone, ci, and hfaili, where r is the rate of a service in progress, and is the content returned by a successful service. The particular value of r is not used in the semantics, but we have retained it here since the application which initiates a service might want to make use of this parameter, e.g., to display it to the user. It might also be of use when considering extending the language with new combinators.</p><p>The limit combinator does not immediately fit into this framework. We handle it by introducing an additional parameter in the semantics that is a function from a time interval to a rate. This function takes as argument the duration since a connection was started and indicates the minimum rate that satisfies all applicable rate limits.</p><p>Thus our semantics is based on a meaning function w, with four arguments: a service, a start time, a status time, and a rate limit function.</p><p>The meaning function implicitly depends on the state of the Web at any time. Instead of building a mathematical model of the whole Web, we assume that a url query returns an arbitrary but fixed result that, in reality, depends on the state of the Web at the time of the query.</p><p>A complication arises from the fact that Web queries started at the same time with the same parameters may not return the same value. For example, two identical url queries could reach a server at different times and fetch different versions of a page; moreover, two identical gateway queries may return pages that contain different hit counters. For simplicity, to make w, deterministic, we assume the existence of an ªinstantaneous caching proxyº that caches, for an instant, the result of any query initiated a t t h a t i n s t a n t . T h a t i s , w e a s s u m e t h a t urltring j urltring urltring, while we do not assume that timeouttY stll c urltring urltring for any t b H.</p><p>The meaning function is defined compositionally on the first argument as follows: The semantics for gateway is essentially the same as for url, except that the parameters are passed when opening the connection.</p><formula xml:id="formula_1">wstallY</formula><p>A basic property of this semantics, which can be proven by structural induction, is that if wY tY uY f , with hfili or hdoneY i for some , then for all u H ! u, wY tY u H Y f .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Algebraic Properties</head><p>Our semantics can be used to prove algebraic properties of the combinators. In turn, these properties could be used to transform and optimize Web queries, although we have not really investigated these possibilities.</p><p>We define:</p><formula xml:id="formula_2">H iff VtY u ! tY f X wY tY uY f w H Y tY uY f</formula><p>Simple properties can be easily derived, for example: fail c c fail fail j j fail stall c stall c stall j stall An interesting observation is that our semantics equates the services repeat(fail) and stall. However, it is still useful to include stall in the language, since the obvious implementation will be inefficient for the service repeat(fail). Conversely, we could consider eliminating fail in favor of timeout(0, stall).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>stall repeatfail fail timeout0Y</head><p>A range of other equations can be derived, each by an easy but tedious case analysis: Other ªintuitiveº properties can be checked against the semantics, and sometimes we may discover they are not satisfied. For example, j H T H j , because the operator asymmetrically picks one result if two results are obtained at exactly the same time.</p><formula xml:id="formula_3">j I j P j Q I j P j Q I c P c Q I c P c Q repeat c repeat repeat c repeat c F F F c repeat repeat c H timeouttY limituY</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">IMPLEMENTATION</head><p>We have implemented an interpreter for the language of service combinators, including top-level definitions and functions as used in the examples. This implementation is written in Java <ref type="bibr" target="#b10">[7]</ref>.</p><p>The implementation also provides an easy interface for programming with service combinators directly from Java. This essentially provides an embedding <ref type="bibr" target="#b11">[8]</ref> of our language in Java. Services are defined by the abstract class Service, declared as follows: public abstract class Service { public Content getContent(FuncTime tf); public float getRate(); public void stop(); }</p><p>To invoke a service, the getContent method is passed a function of time which determines the minimum rate for physical connections, exactly as in the formal semantics. At the top-level, the function ZeroThreshold is normally used, indicating no minimum rate. This method returns the content when the service completes, or returns null when the service fails. During the invocation of the service, the current rate of the service can be found using a concurrent call to the getRate method, which might be used to display a rate to the user. Also, the current invocation can be aborted by calling the stop method.</p><p>The various service combinators are provided as Java classes, whose constructors take subservices as arguments.</p><p>For example, the following Java code corresponds to Example 3: new Par( new Media (ªhttp://www.cs.umd.edu/~pugh/popl97/º), new Media (ªhttp://www.diku.dk/popl97/º))</p><p>In some sense the implementation is only an approximation to the formal semantics because the semantics ignores interpretation overhead. However, it is quite a close approximation, since interpretation overhead is very small for most programs compared to the time for data to be transmitted.</p><p>The rate of a basic service is defined to be the average over the previous 2 sec, as calculated by samples done 5 times/sec. This appears to give good results in practice, though admittedly it is somewhat ad hoc.</p><p>The implementation uses the Sun Java classes to fetch URLs. A small modification was made to them so that failures are correctly detected, since they normally catch failures and instead return an error page. Concurrency is implemented using Java threads, which required a surprisingly large amount of work. Functions are implemented essentially by manipulating the abstract syntax prior to the actual initiation of a service. A programmer could of course write their own subclasses of service, which could call arbitrary Java code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CONCLUSIONS AND FUTURE DIRECTIONS</head><p>We have shown that a simple language allows easy expression of common strategies for handling failure and slow communication when fetching content on the Web. We have defined such a language based on service combinators, implemented it, and given a formal semantics for it.</p><p>Our intention was that our language will be extended to a more powerful Web-scripting language. Such a language would include some common language features such as functions and conditionals. It should also include additional features for Web-programming beyond our service combinators, for example special constructs for manipulating HTML content, possibly linked to a browser. Another direction is to allow scripts themselves to be stored on the Web, and in our implementation we have experimented with this. It should also be possible to write scripts which provide content on the Web, and perhaps even export a function as a CGI gateway. A full Web-scripting language might even allow a thread of execution to migrate via the Web.</p><p>A language with all these features would certainly be very powerful and useful. Partially inspired by our work, Kistler and Marais have designed a language called ªWebLº <ref type="bibr" target="#b13">[10]</ref> which includes some of these features, in particular constructs for manipulating HTML, as well as our service combinators. This language has been released to the public, and is becoming relatively popular.</p><p>In this paper, we have concentrated only on one particular aspect which is unique to the Web, namely its unreliable nature. By first considering the fundamental properties of the Web we have built a small language whose computation model is tailored for Web programming. We hope that this language and model will serve as a firm foundation for larger Web scripting languages. Elements of our language design and formal semantics should also be useful to designers of other domain specific languages in domains which include real-time concerns or where failures are common.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>ervies</head><label></label><figDesc>XX url tring j I c P j I H j H P j timeout elY j limitel I Y el P Y j repeat j stall j fail j indextring I Y tring P j gateway G tringY fsd tringg Ã qtewy types q XX get j post vexil items tring XX HH tringghr Ã HH tringghr XX ny single legl hrter other thn H } n or one of the pirs of hrters n H n HH nn</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>stall. The stall combinator never completes or fails and always has a rate of zero. The following examples show how this can be useful. timeout(10, stall) ? This program waits 10 sec before starting . repeat(url (ºhttp://www.cs.cmu.edu/ e rowanº) ? timeout(10, stall))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>This program attempts to fetch the WWW7 conference page from Australia. If the fetch fails or the rate ever drops below 1 kbyte/sec, then it starts again. If the page is not successfully fetched within 20 sec, then a site known to be easily reachable is used to retrieve a failure message. This program defines two functions for looking up search strings on AltaVista and HotBot, and a single function which tries both concurrently, returning whichever succeeds first. It then uses this function to lookup the word ªjava,º to see which engine performs this task the fastest. There are a large number of other constant parameters required by the HotBot gateway, which we have omitted above.This program defines two functions for looking up stock quotes based on two different gateways. It then defines a very reliable function which makes repeated attempts in the case of failure, alternating between the gateways. It then uses this function to lookup the quote for Compaq Computer.</figDesc><table><row><cell></cell><cell>2.3.5 Example 5</cell></row><row><cell></cell><cell>let av = fun(x)</cell></row><row><cell></cell><cell>gateway get</cell></row><row><cell></cell><cell>(ªhttp://www.altavista.digital.com/</cell></row><row><cell></cell><cell>cgi-bin/queryº, pg=ªqº what=ªwebº q=x)</cell></row><row><cell></cell><cell>let hb = fun(x)</cell></row><row><cell></cell><cell>gateway get</cell></row><row><cell></cell><cell>(ºhttp://www.HotBot.com/search.htmlº,</cell></row><row><cell></cell><cell>... MT=x ... )</cell></row><row><cell></cell><cell>let avhb = fun(x) av(x) | hb(x)</cell></row><row><cell></cell><cell>avhb(ºjavaº)</cell></row><row><cell></cell><cell>2.3.6 Example 6</cell></row><row><cell></cell><cell>let dbc = fun(ticker)</cell></row><row><cell></cell><cell>gateway post</cell></row><row><cell></cell><cell>("http://www.dbc.com/cgi-bin/</cell></row><row><cell></cell><cell>htx.exe/squoteº,</cell></row><row><cell>2.3.2 Example 2</cell><cell>source=ªdbccº TICKER=ticker format=ªdecimalsº</cell></row><row><cell>gateway get</cell><cell>tables=ªtableº)</cell></row><row><cell>(ºhttp://www.altavista.digital.com/</cell><cell>let grayfire = fun(ticker)</cell></row><row><cell>cgi-bin/queryº,</cell><cell>index</cell></row><row><cell>pg=ºqº what=ºwebº q=ºjavaº)</cell><cell>(ªhttp://www.grayfire.com/cgi-bin/</cell></row><row><cell>This program looks up the word ªjavaº on the AltaVista search engine.</cell><cell>get-priceº, ticker) let getquote = fun(ticker) repeat(grayfire(ticker) ? dbc(ticker))</cell></row><row><cell>2.3.3 Example 3</cell><cell>getquote(ªCPQº)</cell></row><row><cell>url (ºhttp://www.cs.umd.edu/ e pugh/popl97/º) |</cell><cell></cell></row><row><cell>url</cell><cell></cell></row><row><cell>(ºhttp://www.diku.dk/popl97/º)</cell><cell></cell></row><row><cell>This program attempts to fetch the POPL'97 conference</cell><cell></cell></row><row><cell>page from one of two alternate sites. Both sites are</cell><cell></cell></row><row><cell>attempted concurrently, and the result is that from</cell><cell></cell></row><row><cell>whichever site successfully completes first.</cell><cell></cell></row><row><cell>2.3.4 Example 4</cell><cell></cell></row><row><cell>repeat (limit(1, 1,</cell><cell></cell></row><row><cell>url(ºhttp://www7.conf.au/º))) |</cell><cell></cell></row><row><cell>(timeout(20, stall) ?</cell><cell></cell></row></table><note><p>2.3.1 Example 1 url(ºhttp://www.cs.cmu.edu/º) This program simply attempts to fetch the named URL. url(ºhttp://www.cs.cmu.edu/ e rowan/ failed.txtº)</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>tY uY f hrteY Hi wfailY tY uY f hfili w I c P Y tY uY f w P Y v I Y uY f if w I Y tY uY f hfili w I Y tY uY f otherwise where v I inf fv j w I Y tY vY f hfilig iXeXY the time t whih I fils w I j P Y tY uY f hrteY mx r I Y r P i if s I hrteY r I i nd s P hrteY r P i hrteY r I i if s I hrteY r I i nd s P hfili hrteY r P i if s P hrteY r P i nd s I hfili hdoneY I i if s I hdoneY I i nd s P hrteY r P i or s P hfili or v I v P hdoneY P i if s P hdoneY P i nd s I hrteY r I i or s I hfili or v P `vI hfili if s I hfili nd s P hfili where s I w I Y tY uY f nd s P w P Y tY uY f nd v I inf fv j w I Y tY vY f hdoneY I ig nd v P inf fv j w P Y tY vY f hdoneY P ig H sXtX u H ! t nd u H u nd onnetion fething the v tring t time t fils t time u H or hs rte r H t time u H Y with r H `fu H À t hrteY ri otherwiseY if onnetion fething the v tring t time t hs rte r t time u</figDesc><table><row><cell cols="2">wtimeoutvY Y tY uY f</cell><cell></cell></row><row><cell cols="2">wY tY uY f</cell><cell>if u À t</cell><cell>`v</cell></row><row><cell>hdoneY i</cell><cell></cell><cell cols="2">if u À t ! v</cell></row><row><cell></cell><cell></cell><cell cols="2">nd wY tY t vY f</cell></row><row><cell></cell><cell></cell><cell cols="2">hdoneY i</cell></row><row><cell>hfili</cell><cell></cell><cell cols="2">otherwise</cell></row><row><cell cols="4">wlimitvY rY Y tY uY f wY tY uY g</cell></row><row><cell cols="3">where gv H mxfv H Y hv H</cell></row><row><cell cols="2">nd hv H H</cell><cell cols="2">i f v H `v</cell></row><row><cell>r</cell><cell></cell><cell cols="2">if v H ! v</cell></row><row><cell cols="2">wrepetY tY uY f</cell><cell></cell></row><row><cell cols="2">wY v n Y uY f</cell><cell cols="2">if v n u `vnI</cell></row><row><cell>hrteY Hi</cell><cell></cell><cell cols="2">if u ! v n for ll n ! H</cell></row><row><cell cols="2">where v H t</cell><cell></cell></row><row><cell cols="3">nd v mI inf fv j v ! v m</cell></row><row><cell></cell><cell cols="3">nd wY v m Y vY f hfilig</cell></row><row><cell cols="2">with inf f g I</cell><cell></cell></row><row><cell cols="2">wurltringY tY uY f</cell><cell></cell></row><row><cell cols="4">hdoneY i if onnetion fething the v tring</cell></row><row><cell></cell><cell cols="3">t time t sueds efore time u with</cell></row><row><cell></cell><cell>ontent X</cell><cell></cell></row><row><cell>hfili</cell><cell cols="2">if there exists u</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>rY timeouttY if t u limittY rY j H limittY rY j limittY rY H limittY rY c H limittY rY c limittY rY H</figDesc><table /><note><p>limittY rY timeoutuY timeoutuY limittY rY limittY rY repeat repeatlimittY rY limittY rY stall stall limittY rY fail fail</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>ACKNOWLEDGMENTS Luca Cardelli would like to thank David Jefferson and a group of people at Digital Palo Alto who met to discuss Web-related issues. Those discussions provided the initial stimulus for this work. Rowan Davies would like to thank Digital SRC, including all its staff, for providing the opportunity to work in an exceptionally stimulating and pleasant environment during the summer of 1996. Martõ Ân Abadi, Paul McJones, and Benjamin Pierce reviewed early drafts.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Luca Cardelli studied at the University of Pisa until 1979, and has a PhD degree in computer science from the University of Edinburgh <ref type="bibr">(1982)</ref>. He worked at Bell Labs, Murray Hill, New Jersey, 1982±1985, and in the Systems Research Center at Digital Equipment Corporation, Palo Alto, California from 1985±1997, before assuming his current position at Microsoft Research Ltd, at Cambridge UK. His main interests are in theory of programming languages, for applications to language design, semantics, and implementation. He implemented the first compiler for ML (the most popular typed functional language) and one of the earliest direct-manipulation user-interface editors. He was a member of the Modula-3 design committee, and has designed a few experimental languages, of which the latest is Obliq: a distributed higher-order language. His more protracted research activity has been in establishing the semantic and type-theoretic foundations of object-oriented languages, resulting in the recent book ªA Theory of Objectsº with Martõ Ân Abadi. Currently, he is interested in global and mobile computation.</p><p>Rowan Davies studied at the University of Western Australia (until 1992), while also working as a computer and mathematics consultant. Since 1993, he has been studying toward his PhD degree in the Computer Science Department at Carnegie Mellon University. During this time he has worked summers on the Cristal project at INRIA, Rocquencourt, France; at BRICS at the University of Aarhus, Denmark; and in the Systems Research Center at Digital Equipment Corporation, Palo Alto, California. His main interests are in program language design, semantics, and implementation, with an emphasis on using logical foundations to achieve practical goals. He helped design and implement a prototype of the object system used in the popular functional language Objective CAML. He helped develop a strong link between modal logic and languages with a form of ªstaging,º which has lead to the design of a realistic language for run-time code generation, PML (ªPummelº due to the presence of modal boxing). He is currently working on the implementation and theory of a refinement-type checker for an extension of Standard ML, which should allow accurate information about program invariants to be captured and checked at compile time.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m">HyperText Markup Language</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Extensible Markup Language</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m">Common Gateway Interface</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">T</forename><surname>Berners-Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cailliau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Luotonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">F</forename><surname>Nielsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Secret</surname></persName>
		</author>
		<author>
			<persName><forename type="first">World-Wide</forename><surname>Web</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm ACM</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="76" to="82" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Hypertext Markup LanguageÐ2.0, RFC 1866, MIT/W3C</title>
		<author>
			<persName><forename type="first">T</forename><surname>Berners-Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Connolly</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995-11">Nov. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><surname>Berners-Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fielding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Frystyk</surname></persName>
		</author>
		<title level="m">Hypertext Transfer ProtocolÐHTTP/1.0, RFC 1945, MIT/UC Irvine</title>
		<imprint>
			<date type="published" when="1996-05">May 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gonthier</surname></persName>
		</author>
		<title level="m">ªThe Esterel Synchronous Programming Language: Design, Semantics, Implementation,º Science of Computer Programming</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="87" to="152" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies, RFC 1521, Bellcore</title>
		<author>
			<persName><forename type="first">N</forename><surname>Borenstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Freed</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993-09">Sept. 1993</date>
			<publisher>Innosoft</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">M</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wadsworth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Edinburgh LCF Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">78</biblScope>
			<date type="published" when="1979">1979</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">The Java Language Specification</title>
		<author>
			<persName><forename type="first">J</forename><surname>Gosling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Joy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Steele</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Hudak</surname></persName>
		</author>
		<title level="m">ªModular Domain Specific Languages and Tools,º Proc. Fifth Int&apos;l Conf. Software Reuse</title>
		<meeting><address><addrLine>Victoria, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-06">June 1998</date>
			<biblScope unit="page" from="134" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Internet Engineering Task Force, Internet Standards</title>
		<ptr target="http://www.isoc.org" />
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>The Internet Soc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">ªWebLÐA Programming Language for the Web,º Computer Networks and ISDN Systems</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kistler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Marais</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. WWW7 Conf</title>
		<meeting>WWW7 Conf</meeting>
		<imprint>
			<date type="published" when="1998-04">Apr. 1998</date>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="259" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">World Wide Web Consortium, ªExtensible Markup Language (XML) 1.0,º W3C Recommendation</title>
		<ptr target="http://w3c.org/" />
		<imprint>
			<date type="published" when="1998-02">Feb. 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title/>
		<ptr target="http://www.w3.org/pub/WWW/Protocols/" />
	</analytic>
	<monogr>
		<title level="j">World Wide Web Consortium, ªHttpÐHypertext Transfer Protocol</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
