<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Coded Caching Schemes with Reduced Subpacketization from Linear Block Codes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Li</forename><surname>Tang</surname></persName>
							<email>litang@iastate.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution">Iowa State University Ames</orgName>
								<address>
									<postCode>50010</postCode>
									<region>IA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Aditya</forename><surname>Ramamoorthy</surname></persName>
							<email>adityar@iastate.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution">Iowa State University Ames</orgName>
								<address>
									<postCode>50010</postCode>
									<region>IA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Coded Caching Schemes with Reduced Subpacketization from Linear Block Codes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">EFB5F5315C1AFC7E07AC01B9A842D3CC</idno>
					<idno type="DOI">10.1109/TIT.2018.2800059</idno>
					<note type="submission">This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIT.2018.2800059, IEEE Transactions on Information Theory This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIT.2018.2800059, IEEE Transactions on Information Theory</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>coded caching</term>
					<term>resolvable designs</term>
					<term>cyclic codes</term>
					<term>subpacketization level</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Coded caching is a technique that generalizes conventional caching and promises significant reductions in traffic over caching networks. However, the basic coded caching scheme requires that each file hosted in the server be partitioned into a large number (i.e., the subpacketization level) of non-overlapping subfiles. From a practical perspective, this is problematic as it means that prior schemes are only applicable when the size of the files is extremely large. In this work, we propose coded caching schemes based on combinatorial structures called resolvable designs. These structures can be obtained in a natural manner from linear block codes whose generator matrices possess certain rank properties. We obtain several schemes with subpacketization levels substantially lower than the basic scheme at the cost of an increased rate. Depending on the system parameters, our approach allows us to operate at various points on the subpacketization level vs. rate tradeoff.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Caching is a popular technique for facilitating large scale content delivery over the Internet. Traditionally, caching operates by storing popular content closer to the end users. Typically, the cache serves an end user's file request partially (or sometimes entirely) with the remainder of the content coming from the main server. Prior work in this area <ref type="bibr" target="#b0">[1]</ref> demonstrates that allowing coding in the cache and coded transmission from the server (referred to as coded caching) to the end users can allow for significant reductions in the number of bits transmitted from the server to the end users. This is an exciting development given the central role of caching in supporting a significant fraction of Internet traffic. In particular, reference <ref type="bibr" target="#b0">[1]</ref> considers a scenario where a single server contains N files. The server connects to K users over a shared link and each user has a cache that allows it to store M/N fraction of all the files in the server. Coded caching consists of two distinct phases: a placement phase and a delivery phase. In the placement phase, the caches of the users are populated. This phase does not depend on the user demands which are assumed to be arbitrary. In the delivery This work was supported in part by the National Science Foundation by grants CCF-1718470, CCF-1320416 and CCF-1149860. This paper was presented in part at the 2016 IEEE Workshop on Network Coding and Applications (NetCod) and at the 2017 IEEE International Symposium on Information Theory (ISIT).</p><p>phase, the server sends a set of coded signals that are broadcast to each user such that each user's demand is satisfied.</p><p>The original work of <ref type="bibr" target="#b0">[1]</ref> considered the case of centralized coded caching, where the server decides the content that needs to be placed in the caches of the different users. Subsequent work considered the decentralized case where the users populate their caches by randomly choosing parts of each file while respecting the cache size constraint. Recently, there have been several papers that have examined various facets of coded caching. These include tightening known bounds on the coded caching rate <ref type="bibr" target="#b1">[2]</ref>, [3], considering issues with respect to decentralized caching <ref type="bibr" target="#b3">[4]</ref>, explicitly considering popularities of files <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b5">[6]</ref>, network topology issues <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref> and synchronization issues <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b9">[10]</ref>.</p><p>In this work, we examine another important aspect of the coded caching problem that is closely tied to its adoption in practice. It is important to note that the huge gains of coded caching require each file to be partitioned into F s ≈ K KM N non-overlapping subfiles of equal size; F s is referred to as the subpacketization level. It can be observed that for a fixed cache size M N , F s grows exponentially with K. This can be problematic in practical implementations. For instance, suppose that K = 64, with M N = 0.25 so that F s = 64 16 ≈ 4.8 × 10 14 with a rate R ≈ 2.82. In this case, it is evident that at the bare minimum, the size of each file has to be at least 480 terabits for leveraging the gains in <ref type="bibr" target="#b0">[1]</ref>. It is even worse in practice. The atomic unit of storage on present day hard drives is a sector of size 512 bytes and the trend in the disk drive industry is to move this to 4096 bytes <ref type="bibr" target="#b10">[11]</ref>. As a result, the minimum size of each file needs to be much higher than 480 terabits. Therefore, the scheme in <ref type="bibr" target="#b0">[1]</ref> is not practical even for moderate values of K. Furthermore, even for smaller values of K, schemes with low subpacketization levels are desirable. This is because any practical scheme will require each of the subfiles to have some header information that allows for decoding at the end users. When there are a large number of subfiles, the header overhead may be non-negligible. For these same parameters (K = 64, M/N = 0.25) our proposed approach in this work allows us obtain, e.g., the following operating points: (i) F s ≈ 1.07 × 10 9 and R = 3, (ii) F s ≈ 1.6 × 10 4 and R = 6, (iii) F s = 64 and R = 12. For the first point, it is evident that the subpacketization level drops by over five orders of magnitude with only a very small increase in the rate. Points (ii) and (iii) show that the proposed scheme allows us to operate at various points on the tradeoff between subpacketization level and rate.</p><p>The issue of subpacketization was first considered in the work of <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b12">[13]</ref> in the decentralized coded caching setting. In the centralized case it was considered in the work of <ref type="bibr" target="#b13">[14]</ref>. They proposed a low subpacketization scheme based on placement delivery arrays. Reference <ref type="bibr" target="#b14">[15]</ref> viewed the problem from a hypergraph perspective and presented several classes of coded caching schemes. The work of <ref type="bibr" target="#b15">[16]</ref> has recently shown that there exist coded caching schemes where the subpacketization level grows linearly with the number of users K; however, this result only applies when the number of users is very large. We elaborate on related work in Section II-A.</p><p>In this work, we propose low subpacketization level schemes for coded caching. Our proposed schemes leverage the properties of combinatorial structures known as resolvable designs and their natural relationship with linear block codes. Our schemes are applicable for a wide variety of parameter ranges and allow the system designer to tune the subpacketization level and the gain of the system with respect to an uncoded system. We note here that designs have also been used to obtain results in distributed data storage <ref type="bibr" target="#b16">[17]</ref> and network coding based function computation in recent work <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b18">[19]</ref>.</p><p>This paper is organized as follows. Section II discusses the background and related work and summarizes the main contributions of our work. Section III outlines our proposed scheme. It includes all the constructions and the essential proofs. A central object of study in our work are matrices that satisfy a property that we call the consecutive column property (CCP). Section IV overviews several constructions of matrices that satisfy this property. Several of the longer and more involved proofs of statements in Sections III and IV appear in the Appendix. In Section V we perform an indepth comparison of our work with existing constructions in the literature. We conclude the paper with a discussion of opportunities for future work in Section VI.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. BACKGROUND, RELATED WORK AND SUMMARY OF CONTRIBUTIONS</head><p>We consider a scenario where the server has N files each of which consist of F s subfiles. There are K users each equipped with a cache of size M F s subfiles. The coded caching scheme is specified by means of the placement scheme and an appropriate delivery scheme for each possible demand pattern. In this work, we use combinatorial designs <ref type="bibr" target="#b19">[20]</ref> to specify the placement scheme in the coded caching system. Definition 1. A design is a pair (X, A) such that 1) X is a set of elements called points, and 2) A is a collection of nonempty subsets of X called blocks, where each block contains the same number of points.</p><p>A design is in one-to-one correspondence with an incidence matrix N which is defined as follows.</p><p>Definition 2. The incidence matrix N of a design (X, A) is a binary matrix of dimension |X| × |A|, where the rows and columns correspond to the points and blocks respectively. Let i ∈ X and j ∈ A. Then,</p><formula xml:id="formula_0">N (i, j) = 1 if i ∈ j, 0 otherwise.</formula><p>It can be observed that the transpose of an incidence matrix also specifies a design. We will refer to this as the transposed design. In this work, we will utilize resolvable designs which are a special class of designs. Definition 3. A parallel class P in a design (X, A) is a subset of disjoint blocks from A whose union is X. A partition of A into several parallel classes is called a resolution, and (X, A) is said to be a resolvable design if A has at least one resolution.</p><p>For resolvable designs, it follows that each point also appears in the same number of blocks.</p><p>Example 1. Consider a block design specified as follows. X = {1, 2, 3, 4}, and A = {{1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4}, {3, 4}}.</p><p>Its incidence matrix is given below.</p><formula xml:id="formula_1">N =     1 1 1 0 0 0 1 0 0 1 1 0 0 1 0 1 0 1 0 0 1 0 1 1     .</formula><p>It can be observed that this design is resolvable with the following parallel classes. P 1 = {{1, 2}, {3, 4}}, P 2 = {{1, 3}, {2, 4}}, and P 3 = {{1, 4}, {2, 3}}.</p><p>In the sequel we let [n] denote the set {1, . . . , n}. We emphasize here that the original scheme of <ref type="bibr" target="#b0">[1]</ref> can be viewed as an instance of the trivial design. For example, consider the setting when t = KM/N is an integer. Let X = [K] and A = {B : B ⊂ [K], |B| = t}. In the scheme of <ref type="bibr" target="#b0">[1]</ref>, the users are associated with X and the subfiles with A.</p><formula xml:id="formula_2">User i ∈ [K] caches subfile W n,B , n ∈ [N ] for B ∈ A if i ∈ B.</formula><p>The main message of our work is that carefully constructed resolvable designs can be used to obtain coded caching schemes with low subpacketization levels, while retaining much of the rate gains of coded caching. The basic idea is to associate the users with the blocks and the subfiles with the points of the design. The roles of the users and subfiles can also be interchanged by simply working with the transposed design.</p><p>Example 2. Consider the resolvable design from Example 1. The blocks in A correspond to six users U 12 , U 34 , U 13 , U 24 , U 14 , U 23 . Each file is partitioned into F s = 4 subfiles W n,1 , W n,2 , W n,3 , W n,4 which correspond to the four points in X. The cache in user U B , denoted Z B is specified as</p><formula xml:id="formula_3">Z ij = (W n,i , W n,j ) N n=1 . For example, Z 12 = (W n,1 , W n,2 ) N n=1 .</formula><p>We note here that the caching scheme is symmetric with respect to the files in the server. Furthermore, each user caches half of each file so that M/N = 1/2. Suppose that in the delivery phase user U B requests file</p><formula xml:id="formula_4">W d B where d B ∈ [N ].</formula><p>As shown in Example 2, we can obtain a scheme by associating the users with the blocks and the subfiles with the points. In this work, we demonstrate that this basic idea can be significantly generalized and several schemes with low subpacketization levels that continue to leverage much of the rate benefits of coded caching can be obtained.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Discussion of Related Work</head><p>Coded caching has been the subject of much investigation in recent work as discussed briefly earlier on. We now overview existing literature on the topic of low subpacketization schemes for coded caching. In the original paper <ref type="bibr" target="#b0">[1]</ref>, for given problem parameters K (number of users) and M/N (cache fraction), the authors showed that when N ≥ K, the rate equals</p><formula xml:id="formula_5">R = K(1 -M/N ) 1 + KM/N</formula><p>when M is an integer multiple of N/K. Other points are obtained via memory sharing. Thus, in the regime when KM/N is large, the coded caching rate is approximately N/M -1, which is independent of K. Crucially, though this requires the subpacketization level F s ≈ K KM/N . It can be observed that for a fixed M/N , F s grows exponentially with K. This is one of main drawbacks of the original scheme and for reasons outlined in Section I, deploying this solution in practice may be difficult.</p><p>The subpacketization issue was first discussed in the work of <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b12">[13]</ref> in the context of decentralized caching. Specifically, <ref type="bibr" target="#b12">[13]</ref> showed that in the decentralized setting for any subpacketization level F s such that F s ≤ exp(KM/N ) the rate would scale linearly in K, i.e., R ≥ cK. Thus, much of the rate benefits of coded caching would be lost if F s did not scale exponentially in K. Following this work, the authors in <ref type="bibr" target="#b13">[14]</ref> introduced a technique for designing low subpacketization schemes in the centralized setting which they called placement delivery arrays. In <ref type="bibr" target="#b13">[14]</ref>, they considered the setting when M/N = 1/q or M/N = 1 -1/q and demonstrated a scheme where the subpacketization level was exponentially smaller than the original scheme, while the rate was marginally higher. This scheme can be viewed as a special case of our work. We discuss these aspects in more detail in Section V. In <ref type="bibr" target="#b14">[15]</ref>, the design of coded caching schemes was achieved through the design of hypergraphs with appropriate properties. In particular, for specific problem parameters, they were able to establish the existence of schemes where the subpacketization scaled as exp(c √ K). Reference <ref type="bibr" target="#b20">[21]</ref> presented results in this setting by considering strong edge coloring of bipartite graphs.</p><p>Very recently, <ref type="bibr" target="#b15">[16]</ref> showed the existence of coded caching schemes where the subpacketization grows linearly with the number of users, but the coded caching rate grows as O(K δ ) where 0 &lt; δ &lt; 1. Thus, while the rate is not a constant, it does not grow linearly with K either. Both <ref type="bibr" target="#b14">[15]</ref> and <ref type="bibr" target="#b15">[16]</ref> are interesting results that demonstrate the existence of regimes where the subpacketization scales in a manageable manner. Nevertheless, it is to be noted that these results come with several caveats. For example, the result of <ref type="bibr" target="#b15">[16]</ref> is only valid in the regime when K is very large and is unlikely to be of use for practical values of K. The result of <ref type="bibr" target="#b14">[15]</ref> has significant restrictions on the number of users, e.g., in their paper, K needs to be of the form n a and q t n a .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Summary of Contributions</head><p>In this work, the subpacketization levels we obtain are typically exponentially smaller than the original scheme. However, they still continue to scale exponentially in K, albeit with much smaller exponents. However, our construction has the advantage of being applicable for a large range of problem parameters. Our specific contributions include the following.</p><p>• We uncover a simple and natural relationship between a (n, k) linear block code and a coded caching scheme. We first show that any linear block code over GF (q) and in some cases Z mod q (where q is not a prime or a prime power) generates a resolvable design. This design in turn specifies a coded caching scheme with K = nq users where the cache fraction M/N = 1/q. A complementary cache fraction point where M/N = 1α/nq where α is some integer between 1 and k + 1 can also be obtained.</p><p>Intermediate points can be obtained by memory sharing between these points. • We consider a class of (n, k) linear block codes whose generator matrices satisfy a specific rank property. In particular, we require collections of consecutive columns to have certain rank properties. For such codes, we are able to identify an efficient delivery phase and determine the precise coded caching rate. We demonstrate that the subpacketization level is at most q k (k + 1) whereas the coded caching gain scales as k + 1 with respect to an uncoded caching scheme. Thus, different choices of k allow the system designer significant flexibility to choose the appropriate operating point. • We discuss several constructions of generator matrices that satisfy the required rank property. We characterize the range of alphabet sizes (q) over which these matrices can be constructed. If one has a given subpacketization budget in a specific setting, we are able to find a set of schemes that fit the budget while leveraging the rate gains of coded caching.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. PROPOSED LOW SUBPACKETIZATION LEVEL SCHEME</head><p>All our constructions of low subpacketization schemes will stem from resolvable designs (cf. Definition 3). Our overall approach is to first show that any (n, k) linear block code over GF (q) can be used to obtain a resolvable block design. The placement scheme obtained from this resolvable design is such that M/N = 1/q. Under certain (mild) conditions on the generator matrix we show that a delivery phase scheme can be designed that allows for a significant rate gain over the uncoded scheme while having a subpacketization level that is significantly lower than <ref type="bibr" target="#b0">[1]</ref>. Furthermore, our scheme can be transformed into another scheme that operates at the point M/N = 1 -k+1 nq . Thus, intermediate values of M/N can be obtained via memory sharing. We also discuss situations under which we can operate over modular arithmetic Z q = Z mod q where q is not necessarily a prime or a prime power; this allows us to obtain a larger range of parameters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Resolvable Design Construction</head><p>Consider a (n, k) linear block code over GF (q). To avoid trivialities we assume that its generator matrix does not have an all-zeros column. We collect its q k codewords and construct a matrix T of size n × q k as follows.</p><formula xml:id="formula_6">T = [c T 0 , c T 1 , • • • , c T q k -1 ],<label>(2)</label></formula><p>where the 1 × n vector c represents the -th codeword of the code. Let X = {0, 1, • • • , q k -1} be the point set and A be the collection of all subsets B i,l for 0 ≤ i ≤ n -1 and 0 ≤ l ≤ q -1, where</p><formula xml:id="formula_7">B i,l = {j : T i,j = l}.</formula><p>Using this construction, we can obtain the following result.</p><p>Lemma 1. The construction procedure above results in a design (X, A) where</p><formula xml:id="formula_8">X = {0, 1, • • • , q k -1} and |B i,l | = q k-1 for all 0 ≤ i ≤ n -1 and 0 ≤ l ≤ q -1.</formula><p>Furthermore, the design is resolvable with parallel classes given by</p><formula xml:id="formula_9">P i = {B i,l : 0 ≤ l ≤ q -1}, for 0 ≤ i ≤ n -1. Proof. Let G = [g ab ], for 0 ≤ a ≤ k -1, 0 ≤ b ≤ n -1, g ab ∈ GF (q). Note that for ∆ = [∆ 0 ∆ 1 . . . ∆ n-1 ] = uG, we have ∆ b = k-1 a=0 u a g ab , where u = [u 0 , • • • , u k-1 ]. Let a * be such that g a * b = 0. Consider the equation a =a * u a g ab = ∆ b -u a * g a * b ,</formula><p>where ∆ b is fixed. For arbitrary values of u a , a = a * , this equation has a unique solution for u a * , which implies that for any ∆ b , |B b,∆ b | = q k-1 and that P b forms a parallel class.</p><p>Remark 1. A k × n generator matrix over GF (q) where q is a prime power can also be considered as a matrix over an extension field GF (q m ) where m is an integer. Thus, one can obtain a resolvable design in this case as well; the corresponding parameters can be calculated in an easy manner.</p><p>Remark 2. We can also consider linear block codes over Z mod q where q is not necessarily a prime or a prime power.</p><p>In this case the conditions under which a resolvable design can be obtained by forming the matrix T are a little more involved. We discuss this in Lemma 4 in the Appendix.</p><p>Example 3. Consider a (4, 2) linear block code over GF (3) with generator matrix</p><formula xml:id="formula_10">G = 1 0 1 1 0 1 1 2 .</formula><p>Collecting the nine codewords, T is constructed as follows.</p><formula xml:id="formula_11">T =     0 0 0 1 1 1 2 2 2 0 1 2 0 1 2 0 1 2 0 1 2 1 2 0 2 0 1 0 2 1 1 0 2 2 1 0     .</formula><p>Using T, we generate the resolvable block design (X, A) where the point set is X = {0, 1, 2, 3, 4, 5, 6, 7, 8}. For instance, block B 0,0 is obtained by identifying the column indexes of zeros in the first row of T, i.e., B 0,0 = {0, 1, 2}.</p><p>Following this, we obtain </p><formula xml:id="formula_12">A ={{0,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. A special class of linear block codes</head><p>We now introduce a special class of linear block codes whose generator matrices satisfy specific rank properties. It turns out that resolvable designs obtained from these codes are especially suited for usage in coded caching.</p><p>Consider the generator matrix G of a (n, k) linear block code over GF (q). The i-th column of G is denoted by g i . Let z be the least positive integer such that k + 1 divides nz (denoted by k + 1 | nz). We let (t) n denote t mod n.</p><p>In our construction we will need to consider various collections of k + 1 consecutive columns of G (wraparounds over the boundaries are allowed). For this purpose, let T a = {a(k + 1), • • • , a(k + 1) + k} (a is a non-negative integer) and S a = {(t) n | t ∈ T a }. Let G Sa be the k × (k + 1) submatrix of G specified by the columns in S a , i.e., g is a column in G Sa if ∈ S a . Next, we define the (k, k + 1)-consecutive column property that is central to the rest of the discussion. Definition 4. (k, k+1)-consecutive column property. Consider the submatrices of G specified by G Sa for 0 ≤ a ≤ zn k+1 -1. We say that G satisfies the (k, k + 1)-consecutive column property if all k × k submatrices of each G Sa are full rank.</p><p>Henceforth, we abbreviate the (k, k+1)-consecutive column property as (k, k + 1)-CCP.</p><p>Example 4. In Example 3 we have k = 2, n = 4 and hence z = 3. Thus, S 0 = {0, 1, 2}, S 1 = {3, 0, 1}, S 2 = {2, 3, 0} and S 3 = {1, 2, 3}. The corresponding generator matrix G satisfies the (k, k + 1) CCP as any two columns of the each of submatrices G Si , i = 0, . . . , 3 are linearly independent over GF (3).</p><p>We note here that one can also define different levels of the consecutive column property. Let</p><formula xml:id="formula_13">T α a = {aα, • • • , aα+α-1}, S α a = {(t) n | t ∈ T α a }</formula><p>and z is the least positive integer such that α | nz. Definition 5. (k, α)-consecutive column property Consider the submatrices of G specified by G S α a for 0 ≤ a ≤ zn α -1. We say that G satisfies the (k, α)-consecutive column property, where α ≤ k if each G S α a has full rank. In other words, the α columns in each G S α a are linearly independent. As pointed out in the sequel, codes that satisfy the (k, α)-CCP, where α ≤ k will result in caching systems that have a multiplicative rate gain of α over an uncoded system. Likewise, codes that satisfy the (k, k + 1)-CCP will have a gain of k + 1 over an uncoded system. In the remainder of the paper, we will use the term CCP to refer to the (k, k +1)-CCP if the value of k is clear from the context.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Usage in a coded caching scenario</head><p>A resolvable design generated from a linear block code that satisfies the CCP can be used in a coded caching scheme as follows. We associate the users with the blocks. Each subfile is associated with a point and an additional index. The placement scheme follows the natural incidence between the blocks and the points; a formal description is given in <ref type="bibr">Algorithm</ref>  In general, (see Algorithm 1) we have</p><formula xml:id="formula_14">K = |A| = nq users. Each file W n , n ∈ [N ] is divided into q k z subfiles W n = {W s n,t | 0 ≤ t ≤ q k -1, 0 ≤ s ≤ z -1}. A subfile W s n,t</formula><p>is cached in user U B where B ∈ A if t ∈ B. Therefore, each user caches a total of N q k-1 z subfiles. As each file consists of q k z subfiles, we have that M/N = 1/q. It remains to show that we can design a delivery phase scheme that satisfies any possible demand pattern. Suppose that in the delivery phase user U B requests file W d B where d B ∈ [N ]. The server responds by transmitting several equations that satisfy each user. Each equation allows k + 1 users from different parallel classes to simultaneously obtain a missing subfile. Our delivery scheme is such that the set of transmitted equations can be classified into various recovery sets that correspond to appropriate collections of parallel classes. For example, in Fig. <ref type="figure" target="#fig_11">1</ref>, P S0 = {P 0 , P 1 , P 2 }, P S1 = {P 0 , P 1 , P 3 } and so on. It turns out that these recovery sets correspond precisely to the sets S a , 0 ≤ a ≤ zn k+1 -1 defined earlier. We illustrate this by means of the example below.  <ref type="figure" target="#fig_11">1</ref>, e.g., P S1 corresponds to S 1 = {0, 1, 3}. The outgoing edges from each parallel class are labeled arbitrarily with numbers 0, 1 and 2. Our delivery scheme is such that each user recovers missing subfiles with a specific superscript from each recovery set that its corresponding parallel class participates in. For instance, a user in parallel class P 1 recovers 0018-9448 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information. This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIT.2018.2800059, IEEE Transactions on Information Theory missing subfiles with superscript 0 from P S0 , superscript 1 from P S1 and superscript 2 from P S3 ; these superscripts are the labels of outgoing edges from P 1 in the bipartite graph. It can be verified, e.g., that user U 012 which lies in P 0 recovers all missing subfiles with superscript 1 from the equations below.</p><formula xml:id="formula_15">W 1 d012,3 ⊕ W 1 d036,2 ⊕ W 0 d237,0 , W 1 d012,6 ⊕ W 1 d036,1 ⊕ W 0 d156,0 , W 1 d012,4 ⊕ W 1 d147,0 ⊕ W 0 d048,1 , W 1 d012,7 ⊕ W 1 d147,2 ⊕ W 0 d237,1 , W 1 d012,8 ⊕ W 1 d258,0 ⊕ W 0 d048,2 , W 1 d012,5 ⊕ W 1 d258,1 ⊕ W 0 d156,2 .</formula><p>Each of the equations above benefits three users. They are generated simply by choosing U 012 from P 0 , any block from P 1 and the last block from P 3 so that the intersection of all these blocks is empty. The fact that these equations are useful for the problem at hand is a consequence of the CCP. The process of generating these equations can be applied to all possible recovery sets. It can be shown that this allows all users to be satisfied at the end of the procedure.</p><p>In what follows, we first show that for the recovery set P Sa it is possible to generate equations that benefit k + 1 users simultaneously.</p><p>Claim 1. Consider the resolvable design (X, A) constructed as described in Section III.A by a (n, k) linear block code that satisfies the CCP. Let</p><formula xml:id="formula_16">P Sa = {P i | i ∈ S a } for 0 ≤ a ≤ zn k+1 -1, i.e., it is the subset of parallel classes corresponding to S a . We emphasize that |P Sa | = k + 1. Consider blocks B i1,li 1 , . . . , B i k ,li k (where l ij ∈ {0, . . . , q -1}) that are picked from any k distinct parallel classes of P Sa . Then, | ∩ k j=1 B ij ,li j | = 1.</formula><p>Before proving Claim 1, we discuss its application in the delivery phase. Note that the claim asserts that k blocks chosen from k distinct parallel classes intersect in precisely one point. Now, suppose that one picks k + 1 users from k + 1 distinct parallel classes, such that their intersection is empty. These blocks (equivalently, users) can participate in an equation that benefits k + 1 users. In particular, each user will recover a missing subfile indexed by the intersection of the other k blocks. We emphasize here that Claim 1 is at the core of our delivery phase. Of course, we need to justify that enough equations can be found that allow all users to recover all their missing subfiles. This follows from a natural counting argument that is made more formally in the subsequent discussion. The superscripts s ∈ {0, . . . , z -1} are needed for the counting argument to go through.</p><p>Proof. Following the construction in Section III.A, we note that a block B i,l ∈ P i is specified by</p><formula xml:id="formula_17">B i,l = {j : T i,j = l}. Now consider B i1,li 1 , . . . , B i k ,li k (where i j ∈ S a , l ij ∈ {0, . . . , q -1}) that are picked from k distinct parallel classes of P Sa . W.l.o.g. we assume that i 1 &lt; i 2 &lt; • • • &lt; i k . Let I = {i 1 , .</formula><p>. . , i k } and T I denote the submatrix of T obtained by retaining the rows in I. We will show that the vector [l i1 l i2 . . . l i k ] T is a column in T I and only appears once.</p><p>Algorithm 2: Signal Generation Algorithm for P Sa Input : For P ∈ P Sa , E(P) = label(P -P Sa ).</p><p>Signal set Sig = ∅. 1 while any user U B ∈ P j , j ∈ S a does not recover all its missing subfiles with superscript E(P j ) do 2</p><p>Pick blocks B j,lj ∈ P j for all j ∈ S a and l j ∈ {0, . . . , q -1} such that ∩ j∈Sa B j,lj = ∅; To see this consider the system of equations in variables</p><formula xml:id="formula_18">u 0 , . . . , u k-1 . k-1 b=0 u b g bi1 = l i1 , . . . k-1 b=0 u b g bi k = l i k .</formula><p>By the CCP, the vectors g i1 , g i2 , . . . , g i k are linearly independent. Therefore this system of k equations in k variables has a unique solution over GF (q). The result follows.</p><p>We now provide an intuitive argument for the delivery phase. Recall that we form a recovery set bipartite graph (see Fig. <ref type="figure" target="#fig_11">1</ref> for an example) with parallel classes and recovery sets as the disjoint vertex subsets. The edges incident on each parallel class are labeled arbitrarily from 0, . . . , z -1. For a parallel class P ∈ P Sa we denote this label by label(P -P Sa ). For a given recovery set P Sa , the delivery phase proceeds by choosing blocks from distinct parallel classes in P Sa such that their intersection is empty; this provides an equation that benefits k + 1 users. It turns out that the equation allows a user in parallel class P ∈ P Sa to recover a missing subfile with the superscript label(P -P Sa ).</p><p>The formal argument is made in Algorithm 2. For ease of notation in Algorithm 2, we denote the demand of user U Bi,j for 0 ≤ i ≤ n -1, 0 ≤ j ≤ q -1 by W κi,j .</p><p>Claim 2. Consider a user U B belonging to parallel class P ∈ P Sa . The signals generated in Algorithm 2 can recover all the missing subfiles needed by U B with superscript E(P).</p><p>Proof. Let P α ∈ P Sa . In the arguments below, we argue that user U B α,lα that demands file W κ α,lα can recover all its missing subfiles with superscript E(P α ). Note that |B α,lα | = q k-1 . Thus, user U B α,lα needs to obtain q kq k-1 missing subfiles with superscript E(P α ). Consider an iteration of the while loop where block B α,lα is picked in step 2. The equation in Algorithm 2 allows it to recover W E(Pα) κ α,lα , lα where lα = ∩ j∈Sa\{α} B j,lj . This is because ∩ j∈Sa B j,lj = ∅ and because of Claim 1.</p><p>Next we count the number of equations that U B α,lα participates in. We can pick k -1 users from some k -1 distinct parallel classes in P Sa . This can be done in q k-1 ways. Claim 1 ensures that the blocks so chosen intersect in a single point. Next we pick a block from the only remaining parallel class in P Sa such that the intersection of all blocks is empty. This can be done in q -1 ways. Thus, there are a total of q k-1 (q -1) = q kq k-1 equations in which user U B α,lα participates in.</p><p>It remains to argue that each equation provides a distinct subfile. Towards this end, let {i 1 , . . . , i k } ⊂ S a be an index set such that α / ∈ {i 1 , . . . , i k }. Suppose that there exist sets of blocks</p><formula xml:id="formula_19">{B i1,li 1 , . . . , B i k ,li k } and {B i1,l i 1 , . . . , B i k ,l i k } such that {B i1,li 1 , . . . , B i k ,li k } = {B i1,l i 1 , . . . , B i k ,l i k }, but ∩ k j=1 B ij ,li j = ∩ k j=1 B ij ,l i j = β. This is a contradiction since this in turn implies that β ∈ ∩ k+1 j=2 B ij ,li j ∩ k+1 j=2 B ij ,l i j</formula><p>, which is impossible since two blocks from the same parallel class have an empty intersection.</p><p>As the algorithm is symmetric with respect to all blocks in parallel classes belonging to P Sa , we have the required result.</p><p>The overall delivery scheme repeatedly applies Algorithm 2 to each of the recovery sets.</p><p>Lemma 2. The proposed delivery scheme terminates and allows each user's demand to be satisfied. Furthermore the transmission rate of the server is (q-1)n k+1 and the subpacketization level is q k z.</p><p>Proof. See Appendix.</p><p>The main requirement for Lemma 2 to hold is that the recovery set bipartite graph be biregular, where multiple edges between the same pair of nodes is disallowed and the degree of each parallel class is z. It is not too hard to see that this follows from the definition of the recovery sets (see the proof in the Appendix for details).</p><p>In an analogous manner, if one starts with the generator matrix of a code that satisfies the (k, α)-CCP for α ≤ k, then we can obtain the following result which is stated below. The details are quite similar to the discussion for the (k, k+1)-CCP and can be found in the Appendix (Section B).</p><p>Corollary 1. Consider a coded caching scheme obtained by forming the resolvable design obtained from a (n, k) code that satisfies the (k, α)-CCP where α ≤ k. Let z be the least positive integer such that α | nz. Then, a delivery scheme can be constructed such that the transmission rate is (q-1)n α and the subpacketization level is q k z. D. Obtaining a scheme for M/N = 1 -k+1 nq . The construction above works for a system where M/N = 1/q. It turns out that this can be converted into a scheme for M N = 1 -k+1 nq . Thus, any convex combination of these two points can be obtained by memory-sharing.</p><p>Towards this end, we note that the class of coded caching schemes considered here can be specified by an equationsubfile matrix. This is inspired by the hypergraph formulation and the placement delivery array (PDA) based schemes for coded caching in <ref type="bibr" target="#b14">[15]</ref> and <ref type="bibr" target="#b13">[14]</ref>. Each equation is assumed to be of the all-but-one type, i.e., it is of the form </p><formula xml:id="formula_20">W dt 1 ,Aj 1 ⊕ W dt 2 ,Aj 2 ⊕ • • • ⊕ W dt m ,</formula><formula xml:id="formula_21">: s ∈ [m], s = }.</formula><p>The coded caching system corresponds to a ∆×F s equationsubfile matrix S as follows. We associate each row of S with an equation and each column with a subfile. We denote the i-th row of S by Eq i and j-th column of S by A j . The value S(i, j) = t if in the i-th equation, user U t recovers subfile W dt,Aj , otherwise, S(i, j) = 0. Suppose that these ∆ equations allow each user to satisfy their demands, i.e., S corresponds to a valid coded caching scheme. It is not too hard to see that the placement scheme can be obtained by examining S. Namely, user U t caches the subfile corresponding to the j-th column if integer t does not appear in the j-th column.</p><p>Example 7. Consider a coded caching system in <ref type="bibr" target="#b0">[1]</ref> with K = 4, ∆ = 4 and F s = 6. We denote the four users as U 1 , U 2 , U 3 , U 4 . Suppose that the equation-subfile matrix S for this scheme is as specified below.</p><formula xml:id="formula_22">      A 1 A 2 A 3 A 4 A 5 A 6 Eq 1 3 2 0 1 0 0 Eq 2 4 0 2 0 1 0 Eq 3 0 4 3 0 0 1 Eq 4 0 0 0 4 3 2       .</formula><p>Upon examining S it is evident for instance that user U 1 caches subfiles A 1 , . . . , A 3 as the number 1 does not appear in the corresponding columns. Similarly, the cache placement of the other users can be obtained. Interpreting this placement scheme in terms of the user-subfile assignment, it can be verified that the design so obtained corresponds to the transpose of the scheme considered in Example 1 (and also to the scheme of <ref type="bibr" target="#b0">[1]</ref> for</p><formula xml:id="formula_23">K = 4, M/N = 1/2).</formula><p>Lemma 3. Consider a ∆×F s equation-subfile matrix S whose entries belong to the set {0, 1, . . . , K}. It corresponds to a valid coded caching system if the following three conditions are satisfied.</p><p>• There is no non-zero integer appearing more than once in each column. • There is no non-zero integer appearing more than once in each row.</p><formula xml:id="formula_24">• If S(i 1 , j 1 ) = S(i 2 , j 2 ) = 0, then S(i 1 , j 2 ) = S(i 2 , j 1 ) = 0.</formula><p>Proof. in column A j . Therefore, matrix S corresponds to a placement scheme.</p><p>Next we discuss the delivery scheme. Note that Eq i corresponds to an equation as follows.</p><formula xml:id="formula_25">W dt 1 ,Aj 1 ⊕ W dt 2 ,Aj 2 ⊕ • • • ⊕ W dt m ,Aj m ,</formula><p>where S(i, j 1 ) = t 1 , • • • , S(i, j m ) = t m . The above equation can allow m users to recover subfiles simultaneously if (a) U t does not cache W n,Aj and (b) U t caches all W n,Aj s where {j s : s ∈ [m], s = }. It is evident that U t does not cache W n,Aj owing to the placement scheme. Next, to guarantee the condition (b), we need to show that integer t = S(i, j ) will not appear in column A js in S where {j s : s ∈ [m], s = }. Towards this end, t = S(i, j s ) because of Condition 2. Next, consider the non-zero entries that lie in the column A js but not in the row Eq i . Assume there exists an entry S(i , j s ) such that S(i , j s ) = S(i, j ) = t and i = i, then S(i, j s ) = t s = 0, which is a contradiction to Condition 3. Finally, Condition 1 guarantees that each missing subfile is recovered only once.</p><p>User U t caches a fraction Mt N = Lt Fs where L t is the number of columns of S that do not have the entry t. Similarly, the transmission rate is given by R = ∆ Fs . The crucial point is that the transpose of S, i.e., S T also corresponds to a coded caching scheme. This follows directly from the fact that S T also satisfies the conditions in Lemma 3. In particular, S T corresponds to a coded caching system with K users and ∆ subfiles. In the placement phase, the cache size of U t is</p><formula xml:id="formula_26">M t N = ∆-Fs+Lt ∆ .</formula><p>In the delivery phase, by transmitting F s equations corresponding to the rows of S T , all missing subfiles can be recovered. Then, the transmission rate is R = Fs ∆ . Applying the above discussion in our context, consider the equation-subfile matrix S corresponding to the coded caching system with K = nq, Mt N = 1 q for 1 ≤ t ≤ nq, F s = q k z and ∆ = q k (q -1) nz k+1 . Then S T corresponds to a system with K = nq, M N = 1 -k+1 nq , F s = (q -1)q k zn k+1 , and transmission rate R = Fs ∆ = k+1 (q-1)n . The following theorem is the main result of this paper.</p><p>Theorem 1. Consider a (n, k) linear block code over GF (q) that satisfies the (k, k + 1) CCP. This corresponds to a coded caching scheme with K = nq users, N files in the server where each user has a cache of size M ∈</p><formula xml:id="formula_27">1 q N, 1 - k+1 nq N . Let z be the least positive integer such that k + 1 | nz. When M N = 1 q , we have R = (q -1)n k + 1 ,<label>and</label></formula><formula xml:id="formula_28">F s = q k z.</formula><p>When M N = (1 -k+1 nq ), we have</p><formula xml:id="formula_29">R = k + 1 (q -1)n</formula><p>, and</p><formula xml:id="formula_30">F s = (q -1)q k zn k + 1 .</formula><p>By memory sharing any convex combination of these points is achievable.</p><p>In a similar manner for the (n, k) linear block code that satisfies the (k, α)-CCP over GF (q), the caching system where M/N = 1/q can be converted into a system where K = nq, M N = 1 -α nq , F s = (q -1)q k zn α and R = α (q-1)n using the equation-subfile technique. The arguments presented above apply with essentially no change.</p><p>IV. SOME CLASSES OF LINEAR CODES THAT SATISFY THE CCP At this point we have established that linear block codes that satisfy the CCP are attractive candidates for usage in coded caching. In this section, we demonstrate that there are a large class of generator matrices that satisfy the CCP. For most of the section we work with matrices over a finite field of order q. In the last subsection, we discuss some constructions for matrices over Z mod q when q is not a prime or prime power. We summarize the constructions presented in this section in Table <ref type="table">I</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Maximum-distance-separable (MDS) codes</head><p>(n, k)-MDS codes with minimum distance nk + 1 are clearly a class of codes that satisfy the CCP. In fact, for these codes any k columns of the generator matrix can be shown to be full rank. Note however, that MDS codes typically need large field size, e.g., q + 1 ≥ n (assuming that the MDS conjecture is true) <ref type="bibr" target="#b21">[22]</ref>. In our construction, the value of M/N = 1/q and the number of users is K = nq. Thus, for large n, we will only obtain systems with small values of M/N , or equivalently large values of M/N (by Theorem 1 above). This may be restrictive in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Cyclic Codes</head><p>A cyclic code is a linear block code, where the circular shift of each codeword is also a codeword <ref type="bibr" target="#b22">[23]</ref>. A (n, k) cyclic code over GF (q) is specified by a monic polynomial g(X) = n-k i=0 g i X i with coefficients from GF (q) where g n-k = 1 and g 0 = 0; g(X) needs to divide the polynomial X n -1. The generator matrix of the cyclic code is obtained as below.</p><formula xml:id="formula_31">G =      g 0 g 1 • • • g n-k 0 • • 0 0 g 0 g 1 • • • g n-k 0 • 0 . . . . . . 0 0 • 0 g 0 g 1 • • • g n-k      .</formula><p>The following claim shows that for verifying the CCP for a cyclic code it suffices to pick any set of k + 1 consecutive columns.</p><p>Claim 3. Consider a (n, k) cyclic code with generator matrix</p><formula xml:id="formula_32">G. Let G S denote a set of k + 1 consecutive columns of G. If each k × k submatrix of G S is full rank, then G satisfies the (k, k + 1)-CCP.</formula><p>Proof. Let the generator polynomial of the cyclic code be g(X), where we note that g(X) has degree nk. Let Cyclic codes over the ring Require that q = q 1 × q 2 × • • • × q d where q i 's are prime. Satisfy the (k, k)-CCP.</p><p>Kronecker product of z×α matrices satisfying the (z, z)-CCP with the identity matrix I t×t Satisfy the (k, k)-CCP property where k = tz.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CCP matrix extension</head><p>Extends a k × n CCP matrix to a k × (n + s(k + 1)) CCP matrix for integer s.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TABLE I A SUMMARY OF THE DIFFERENT CONSTRUCTIONS OF CCP MATRICES IN SECTION IV</head><formula xml:id="formula_33">G S = [g (a)n , g (a+1)n , • • • , g (a+k)n ]</formula><p>where we assume that G S satisfies the (k, k + 1)-CCP. Let G S\j =[g (a)n , . . . , g (a+j-1)n , g (a+j+1)n , . . . , g (a+k)n ], and G S \j =[g (a+i)n , . . . , g (a+j-1+i)n , g (a+j+1+i)n , . . . , g (a+k+i)n ].</p><p>We need to show that if G S\j has full rank, then G S \j has full rank, for any 0 ≤ j ≤ k.</p><p>As G S\j has full rank, there is no codeword c = 0 such that c((a</p><formula xml:id="formula_34">) n ) = • • • = c((a + j -1) n ) = c((a + j + 1) n ) = • • • = c((a + k) n ) = 0.</formula><p>By the definition of a cyclic code, any circular shift of a codeword results in another codeword that belongs to the code. Therefore, there is no codeword c such that c ((</p><formula xml:id="formula_35">a + i) n ) = • • • = c (a + j -1 + i) n ) = c ((a + j + 1 + i) n ) = • • • = c ((a + k + i) n ) = 0. Thus, G S \j has full rank.</formula><p>Claim 3 implies a low complexity search algorithm to determine if a cyclic code satisfies the CCP. Instead of checking all G Sa , 0 ≤ a ≤ zn k+1 -1, in Definition 4, we only need to check an arbitrary</p><formula xml:id="formula_36">G S = [g (i)n , g (i+1)n , • • • , g (i+k)n ],</formula><p>for 0 ≤ i &lt; n. To further simplify the search, we choose i = n -k 2 -1. For this choice of i, Claim 4 shows that G S is such that we only need to check the rank of a list of small-dimension matrices to determine if each k × k submatrix of G S is full rank (the proof appears in the Appendix). Claim 4. A cyclic code with generator matrix G satisfies the CCP if the following conditions hold.</p><p>• For 0 &lt; j ≤ k 2 , the submatrices</p><formula xml:id="formula_37">C j =        g n-k-1 g n-k 0 • • 0 g n-k-2 g n-k-1 g n-k 0 • 0 . . . . . . g n-k-j+1 • • • • g n-k g n-k-j • • • • g n-k-1       </formula><p>have full rank. In the above expression, g i = 0 if i &lt; 0. • For k 2 &lt; j &lt; k, the submatrices</p><formula xml:id="formula_38">C j =        g 1 g 2 • • • • g k-j g 0 g 1 • • • • g k-j-1 . . . . . . 0 • • 0 g 0 g 1 g 2 0 • •• 0 g 0 g 1        have full rank.</formula><p>Example 8. Consider the polynomial g(X) = X 4 + X 3 + X + 2 over GF (3). Since it divides X 8 -1, it is the generator polynomial of a (8, 4) cyclic code over GF (3). The generator matrix of this code is given below.</p><formula xml:id="formula_39">G =     2 1 0 1 1 0 0 0 0 2 1 0 1 1 0 0 0 0 2 1 0 1 1 0 0 0 0 2 1 0 1 1     .</formula><p>It can be verified that the 4 × 5 submatrix which consists of the two leftmost columns and three rightmost columns of G is such that all 4 × 4 submatrices of it are full rank. Thus, by Claim 3 the (4,5)-CCP is satisfied for G.</p><p>Remark 3. Cyclic codes form an important class of codes that satisfy the (k, k)-CCP (cf. Definition 5). This is because, it is well-known <ref type="bibr" target="#b22">[23]</ref> that any k consecutive columns of the generator matrix of a cyclic code are linearly independent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Constructions leveraging properties of smaller base matrices</head><p>It is well recognized that cyclic codes do not necessarily exist for any choice of parameters. This is because of the divisibility requirement on the generator polynomial. We now discuss a more general construction of generator matrices that satisfy the CCP. As we shall see, this construction provides a more or less satisfactory solution for a large range of system parameters.</p><p>Our first simple observation is that the Kronecker product (denoted by ⊗ below) of a z ×α generator matrix that satisfies the (z, z)-CCP with a t × t identity matrix, I t×t immediately yields a generator matrix that satisfies the (tz, tz)-CCP.</p><p>Claim 5. Consider a (n, k) linear block code over GF (q) whose generator matrix is specified as G = A ⊗ I t×t where A is a z × α matrix that satisfies the (z, z)-CCP. Then, G satisfies the (k, k)-CCP where k = tz and n = tα.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof. The recovery set for</head><formula xml:id="formula_40">A is specified as S z a = {(az) α , • • • , (az+z-1) α } and the recovery set for G is speci- fied as S k a = {(ak) n , • • • , (ak+k-1) n }. Since A satisfies the (z, z)-CCP, A S z a has full rank. Note that G S k a = A S z a ⊗ I t×t . Then det(G S k a ) = det(A S z a ⊗ I t×t ) = det(A S z a ) t = 0. Therefore, G satisfies the (k, k)-CCP.</formula><p>Remark 4. Let A be the generator matrix of a cyclic code over GF (q), then G = A ⊗ I t×t satisfies the (k, k)-CCP by Claim 5.</p><p>Our next construction addresses the (k, k + 1)-CCP. In what follows, we use the following notation.  <ref type="figure">(n,</ref><ref type="figure">k</ref>) linear code that satisfies the CCP over GF (q) where q &gt; α. Since α = n t , the required field size in Claim 6 is lower than the MDS code considered in Section IV-A. Claim 6. Consider a (n, k) linear block code over GF (q) whose generator matrix is specified as eq. (3), where</p><formula xml:id="formula_41">• 1 a : [1, • • • , 1 a ] T ; • C(c 1 , c 2</formula><formula xml:id="formula_42">     b 00 b 01 • • • b 0(α-1) b 10 b 11 • • • b 1(α-1) . . . . . . b (z-1)0 b (z-1)1 • • • b (z-1)(α-1)     </formula><p>is a Vandermonde matrix and q &gt; α. Then, G satisfies the (k, k + 1)-CCP.</p><p>Proof. The proof again leverages the idea that G can be expressed succinctly by using Kronecker products. The arguments can be found in the Appendix.</p><p>Consider the case when α = z + 1. We construct a (n, k) linear code satisfy the CCP over GF (q) where q ≥ z. It can be noted that the constraint of field size is looser than the corresponding constraint in Claim 6.</p><p>Claim 7. Consider nz = (z + 1) • (k + 1) . Consider a (n, k) linear block code whose generator matrix (over GF (q)) is specified as follows. Proof. See Appendix.</p><formula xml:id="formula_43">G =     It×t 0t×t ••• 0t×t 0 t×(t-1) 1t b1It×t 0t×t It×t ••• 0t×t 0 t×(t-1) 1t b2It×t . . . . . . 0t×t 0t×t ••• It×t 0 t×(t-1) 1t bz-1It×t 0 (t-1)×t 0 (t-1)×t ••• 0 (t-1)×t I (t-1)×(t-1) 1t-1 C(c1,c2) (t-1)×t ,     (4) where t = n -k -1. If q ≥ z, b 1 , b 2 , • • • , b z-</formula><p>Claim 8 can provide more parameter choices and more possible code constructions. For example, given n, k, q, where k +1+(n) k+1 ≤ q +1 &lt; n, there may not exist a (n, k)-MDS code over GF (q). However, there exists a (k +1+(n) k+1 , k)-MDS code over GF (q). By Claim 8, we can obtain a (n, k) linear block code over GF (q) that satisfies the CCP. Similarly, combining Claim 4, Claim 6, Claim 7 with Claim 8, we can obtain more linear block codes that satisfy the CCP.</p><p>A result very similar to Claim 8 can be obtained for the (k, α)-CCP. Specifically, consider a (n, k) linear block code with generator matrix G that satisfies the (k, α)-CCP and let D be the first α columns of G.</p><formula xml:id="formula_44">Then, G = [D| • • • |D s |G] of dimension k × (n + sα) also satisfies the (k, α)-CCP.</formula><p>D. Constructions where q is not a prime or a prime power We now discuss constructions where q is not a prime or a prime power. We attempt to construct matrices over the ring Z mod q in this case. The issue is somewhat complicated by the fact that a square matrix over Z mod q has linearly independent rows if and only if its determinant is a unit in the ring <ref type="bibr" target="#b23">[24]</ref>. In general, this fact makes it harder to 0018-9448 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information. This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIT.2018.2800059, IEEE Transactions on Information Theory</p><formula xml:id="formula_45">G =        b 00 I t×t b 01 I t×t • • • b 0(α-1) I t×t b 10 I t×t b 11 I t×t • • • b 1(α-1) I t×t . . . . . . b (z-2)0 I t×t b (z-2)1 I t×t • • • b (z-2)(α-1) I t×t C(b (z-1)0 , b (z-1)0 ) (t-1)×t C(b (z-1)1 , b (z-1)1 ) (t-1)×t • • • C(b (z-1)(α-1) , b (z-1)(α-1) ) (t-1)×t        (3)</formula><p>obtain constructions such as those in Claim 6 that exploit the Vandermonde structure of the matrices. Specifically, the difference of units in a ring is not guaranteed to be a unit. However, we can still provide some constructions. It can be observed that Claim 5 and Claim 8 hold for linear block codes over Z mod q. We will use them without proof in this subsection.</p><p>Claim 9. Let G = [I k×k |1 k ], i.e., it is the generator matrix of a (k + 1, k) single parity check (SPC) code, where the entries are from Z mod q. The G satisfies the (k, k + 1)-CCP and the (k, k)-CCP. It can be used as base matrix for Claim 5.</p><p>Proof. It is not too hard to see that when G = [I k×k |1 k ], any k × k submatrix of G has a determinant which is ±1, i.e., it is a unit over Z mod q. Thus, the result holds in this case.</p><p>Claim 10. The following matrix with entries from Z q satisfies the (k, k + 1)-CCP. Here k = 2t -1 and n = 3t.</p><formula xml:id="formula_46">G = I t×t 0 1 t I t×t 0 I (t-1)×(t-1) 1 t C(1, -1) (t-1)×t .</formula><p>Proof. This can be proved by following the arguments in the proof of Claim 7 while treating elements to be from Z mod q and setting z = 2. We need to consider three different k ×(k + 1) submatrices for which we need to check the property. These correspond to simpler instances of the submatrices considered in Types I -III in the proof of Claim 7. In particular, the corresponding determinants will always be ±1 which are units over Z mod q.</p><p>Remark 5. We note that the general construction in Claim 7 can potentially fail in the case when the matrices are over Z mod q. This is because in one of the cases under consideration (specifically, Type III, Case 1), the determinant depends on the difference of the b i values. The difference of units in Z mod q is not guaranteed to be a unit, thus there is no guarantee that the determinant is a unit.</p><p>Remark 6. We can use Claim 8 to obtain higher values of n based on the above two classes of linear block codes over Z mod q.</p><p>While most constructions of cyclic codes are over GF (q), there has been some work on constructing cyclic codes over Z mod q. Specifically, <ref type="bibr" target="#b24">[25]</ref> provides a construction where q = q 1 × q 2 • • • × q d and q i , i = 1, . . . , d are prime. We begin by outlining this construction. By the Chinese remainder theorem any element γ ∈ Z mod q has a unique representation in terms of its residues modulo q i , for i = 1, . . . , d. Let ψ : Z mod q → GF (q 1 ) × • • • × GF (q d ) denote this map.</p><p>• Suppose that (n, k i ) cyclic codes over GF (q i ) exist for all i = 1, . . . , d. Each individual code is denoted C i .</p><p>• Let C denote the code over Z mod q. Let c (i) ∈ C i for i = 1, . . . , d. The codeword c ∈ C is obtained as follows.</p><p>The j-th component of c, c j = ψ -1 (c</p><formula xml:id="formula_47">(1) j , . . . , c (d) j ) Therefore, there are q k1 1 q k2 2 • • • q k d d codewords in C.</formula><p>It is also evident that C is cyclic. As discussed in Section III-A, we form the matrix T for the codewords in C. It turns out that using T and the technique discussed in Section III-A, we can obtain a resolvable design. Furthermore, the gain of the system in the delivery phase can be shown to be</p><formula xml:id="formula_48">k min = min{k 1 , k 2 , • • • , k d }.</formula><p>We discuss these points in detail in the Appendix (Section C).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. DISCUSSION AND COMPARISON WITH EXISTING SCHEMES</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Discussion</head><p>When the number of users is K = nq and the cache fraction is M N = 1 q , we have shown in Theorem 1 that the gain g = k + 1 and F s = q k z. Therefore, both the gain and the subpacketization level increase with larger k. Thus, for our approach given a subpacketization budget F s , the highest coded gain that can be obtained is denoted by</p><formula xml:id="formula_49">g max = k max +1</formula><p>where k max is the largest integer such that q kmax z ≤ F s and there exists a (n, k max ) linear block code that satisfies the CCP.</p><p>For determining k max , we have to characterize the collection of values of k such that there exists a (n, k) linear code satisfies the CCP over GF (q) or Z mod q. We use our proposed constructions (MDS code, Claim 4, Claim 6, Claim 7, Claim 8, Claim 9, Claim 10) for this purpose. We call this collection C(n, q) and generate it in Algorithm 3. We note here that it is entirely possible that there are other linear block codes that fit the appropriate parameters and are outside the scope of our constructions. Thus, the list may not be exhaustive. In addition, we note that we only check for the (k, k + 1)-CCP. Working with the (k, α)-CCP where α ≤ k can provide more operating points.</p><p>Example 9. Consider a caching system with K = nq = 12 × 5 = 60 users and cache fraction M N = 1 5 . Suppose that the subpacketization budget is 1.5 × 10 6 . By checking all k &lt; n we can construct C(n, q) (see Table <ref type="table" target="#tab_6">II</ref>). As a result, C(n, q) = {1, 2, 3, 4, 5, 6, 7, 8, 9, 11}. Then k max = 8, F s ≈ 1.17 × 10 6 and the maximal coded gain we can achieve is g max = 9. By contrast, the scheme in <ref type="bibr" target="#b0">[1]</ref> can achieve coded gain g = KM N + 1 = 13 but requires subpacketization level</p><formula xml:id="formula_50">F s = K KM N ≈ 1.4 × 10 12 .</formula><p>We can achieve almost the same rate by performing memory-sharing by using the scheme of <ref type="bibr" target="#b0">[1]</ref>   ). Thus, the overall cache fraction is 0.9 × 2 15 + 0.1 × 13 15 ≈ 1 5 . The overall coded gain of this scheme is g ≈ 9. However, the subpacketization level is</p><formula xml:id="formula_51">F M N s = K KM1/N1 + K KM2/N2 ≈ 5 × 10 9 ,</formula><p>which is much greater than the subpacketization budget.</p><p>In Fig. <ref type="figure">2</ref>, we present another comparison for system parameters K = 64 and different values of M/N . The scheme of <ref type="bibr" target="#b0">[1]</ref> works for all M/N such that KM/N is an integer. In Fig. <ref type="figure">2</ref>, our plots have markers corresponding to M/N values that our scheme achieves. For ease of presentation, both the rate (left y-axis) and the logarithm of the subpacketization level (right y-axis) are shown on the same plot. We present results corresponding to two of our construction techniques: (i) the SPC code and (ii) a smaller SPC code coupled with Claim 8. It can be seen that our subpacketization levels are several orders of magnitude smaller with only a small increase in the rate.</p><p>An in-depth comparison for general parameters is discussed next. In the discussion below, we shall use the superscript * to refer to the rates and subpacketization levels of our proposed scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Comparison with memory-sharing within the scheme of [1]</head><p>Suppose that for given K, M and N , a given rate R can be achieved by the memory sharing of the scheme in <ref type="bibr" target="#b0">[1]</ref> between the corner points</p><formula xml:id="formula_52">(M 1 , R 1 ), (M 2 , R 2 ), • • • , (M d , R d )</formula><p>where</p><formula xml:id="formula_53">M i = tiN K for some integer t i . Then R i = K(1- M i N ) 1+ KM i N , R = d i=1 λ i R i , M/N = d i=1 λ i Mi N and d i=1 λ i = 1. The subpacketization level is F M S s = d i=1 K KM i N</formula><p>. In addition, we note that the function h(x) = K(1x)/(1 + Kx) is convex in the parameter 0 ≤ x ≤ 1. This can be verified by a simple second derivative calculation.</p><p>We first argue that F M S s is lower bounded by</p><formula xml:id="formula_54">K KM N</formula><p>, where M is obtained as follows. For a given M/N , we first Fig. <ref type="figure">2</ref>. A comparison of rate and subpacketization level vs. M/N for a system with K = 64 users. The left y-axis shows the rate and the right y-axis shows the logarithm of the subpacketization level. The green and the blue curves correspond to two of our proposed constructions. Note that our schemes allow for multiple orders of magnitude reduction in subpacketization level and the expense of a small increase in coded caching rate.</p><p>determine λ and M * N that satisfy the following equations.</p><formula xml:id="formula_55">R = λ K(1 -M * N ) 1 + KM * N + (1 -λ) K M * N 1 + K(1 -M * N )</formula><p>, and ( <ref type="formula">5</ref>)</p><formula xml:id="formula_56">M N = λ M * N + (1 -λ) 1 - M * N .<label>(6)</label></formula><p>Here, M * N ≤ 1 2 , and M = t N K , where t is the least integer such that M ≥ M * .</p><p>To see this, consider the following argument. Suppose that the above statement is not true. Then, there exists a scheme that operates via memory sharing between points</p><formula xml:id="formula_57">(M 1 , R 1 ), • • • , (M d , R d ) such that F s &lt; K KM N . Note that K KM 1 N &lt; K KM 2 N if M1 N &lt; M2 N ≤ 1 2 or M1 N &gt; M2 N ≥ 1 2</formula><p>. By the convexity of h(•), we can conclude that (M, R) is not in the convex hull of the corner points</p><formula xml:id="formula_58">(M 1 , R 1 ), • • • , (M d , R d ).</formula><p>This is a contradiction.     we compare this lower bound on M S s to the subpacketization level of our proposed scheme. In principle, we can solve the system of equations ( <ref type="formula">5</ref>) and ( <ref type="formula" target="#formula_56">6</ref>) for R = n(q-1) k+1 and M N = 1 q and obtain the appropriate λ and M * values 1 .</p><formula xml:id="formula_59">Algorithm 3: C(n, q) Construction Algorithm Input : n, q, C(n, q) = ∅ 1 if q is a prime power then 2 for k = 1 : (n -1) do 3 n ← (n) k+1 + k + 1; 4 z ← k+1 gcd(n ,</formula><p>1 Similar results can be obtained for M N = 1 -k+1 nq Unfortunately, doing this analytically becomes quite messy and does not yield much intuition. Instead, we illustrate the reduction in subpacketization level by numerical comparisons.</p><p>Example 10. Consider a (9, 5) linear block code over GF (2) with generator matrix specified below.</p><formula xml:id="formula_60">G =      </formula><p>1 0 0 0 0 1 1 0 0 0 1 0 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 0 1 0 1 1 1 0 0 0 0 0 1 1 0 1 1</p><formula xml:id="formula_61">      .</formula><p>It can be checked that G satisfies the (5, 6)-CCP. Thus, it corresponds to a coded caching system with K = 9 × 2 = 18 users. Our scheme achieves the point</p><formula xml:id="formula_62">M1 N = 1 2 , R 1 = 3 2 , F * s,1 = 64 and M2 N = 2 3 , R 2 = 2 3 , F * s,2 = 96. On the other hand for M1 N = 1 2 , R 1 = 3 2</formula><p>, by numerically solving ( <ref type="formula">5</ref>) and ( <ref type="formula" target="#formula_56">6</ref>) we obtain</p><formula xml:id="formula_63">M * 1 N ≈ 0.227 and therefore M 1 N = 5 18 . Then F M S s,1 ≥ 18 5</formula><p>= 8568, which is much higher than F * s,1 = 64. A similar calculation shows that</p><formula xml:id="formula_64">M * 2 N ≈ 1 4</formula><p>and therefore</p><formula xml:id="formula_65">M 2 N = 5</formula><p>18 . Thus F M S s,2 is also at least as large as which is still much higher than F * s,2 = 96. The next set of comparisons are with other proposed schemes in the literature. We note here that several of these are restrictive in the parameters that they allow. <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b14">[15]</ref> and <ref type="bibr" target="#b15">[16]</ref> For comparison with <ref type="bibr" target="#b0">[1]</ref>, denote R M N and F M N s be the rate and the subpacketization level of the scheme of <ref type="bibr" target="#b0">[1]</ref>, respectively. For the rate comparison, we note that</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Comparison with</head><formula xml:id="formula_66">R * R M N = 1 + n 1 + k , for M N = 1 q R * R M N = nq -k nq -n , for M N = 1 - 1 + k nq ,</formula><p>For the comparison of subpacketization level we have the following results. Claim 11. When K = nq, the following results hold.</p><formula xml:id="formula_67">• If M N = 1 q , we have lim n→∞ 1 K log 2 F M N s F * s = H 2 1 q - η q log 2 q. (<label>7</label></formula><formula xml:id="formula_68">) • If M N = 1 -k+1 nq , we have lim n→∞ 1 K log 2 F M N s F * s = H 2 η q - η q log 2 q. (<label>8</label></formula><formula xml:id="formula_69">)</formula><p>In the above expressions, 0 &lt; η = k/n ≤ 1 and H 2 (•) represents the binary entropy function.</p><p>Proof. Both results are simple consequences of approximating <ref type="bibr" target="#b25">[26]</ref>. The derivations can be found in the Appendix.</p><formula xml:id="formula_70">K Kp ≈ 2 KH2(p)</formula><p>It is not too hard to see that F * s is exponentially lower than F M N s . Thus, our rate is higher, but the subpacketization level is exponentially lower. Thus, the gain in the scaling exponent of with respect to the scheme of <ref type="bibr" target="#b0">[1]</ref> depends on the choice of R and the value of M/N . In Fig. <ref type="figure" target="#fig_8">3</ref> we plot this value of different values of R and q. The plot assumes that codes satisfying the CCP can be found for these rates and corresponds to the gain in eq. ( <ref type="formula" target="#formula_67">7</ref>).</p><p>In <ref type="bibr" target="#b13">[14]</ref> a scheme for the case when M/N = 1/q or M/N = 1-1/q with subpacketization level exponentially smaller with respect to <ref type="bibr" target="#b0">[1]</ref> was presented. This result can be recovered a special case of our work (Theorem 1) when the linear block code is chosen as a single parity check code over Z mod q. In this specific case, q does not need to be a prime power. Thus, our results subsume the results</p><p>In a more preprint, reference <ref type="bibr" target="#b20">[21]</ref>, proposed a caching system with</p><formula xml:id="formula_71">K = m a , F s = m b and M/N = 1 - a λ m-a b-β / m b . The corresponding rate is R = m a+b-2β m b min m (a b 2β) λ a + b -2β a -β ,</formula><p>where m, a, b, β are positive integers and 0 &lt; a &lt; m, 0 &lt; b &lt; m, 0 ≤ β ≤ min{a, b}. While a precise comparison is somewhat hard, we can compare the schemes for certain parameter choices, that were also considered in <ref type="bibr" target="#b20">[21]</ref>. Let a = 2, β = 1, m = 2b. This corresponds to a coded caching system with</p><formula xml:id="formula_72">K = b(2b -1) ≈ 2b 2 , M N = b-1 2b-1 ≈ 1 2 , F s = 2b b ≈ 2 2b , R = b.</formula><p>For comparison with our scheme we keep the transmission rates of both schemes roughly the same and let n = b 2 , q = 2, k = b -1. We assume that the corresponding linear block code exists. Then F * s ≈ 2 b , which is better than F s .</p><p>On the other hand if we let β = 0, a = 2, m = 2qb, we obtain a coded caching system with K = m(m-1) 2 . For keeping the rates the same, we let n = m(m-1)</p><formula xml:id="formula_73">2 , M N ≈ 1 q , F s = m m 2q ≈ (2q) m 2q , R Y AN = (2q -1)</formula><formula xml:id="formula_74">2q , k = m(m-1) 4q(2q-1) -1 so that F * s ≈ q m(m-1)</formula><p>4q(2q-1) ≈ q m 2 8q 2 . In this regime, the subpacketization level of <ref type="bibr" target="#b20">[21]</ref> will typically be lower.</p><p>The work of <ref type="bibr" target="#b14">[15]</ref> proposed caching schemes with parame-</p><formula xml:id="formula_75">ters (i) K = m a , M N = 1 - ( m-a b ) ( m b ) , F s = m b and R = ( m a+b ) ( m b )</formula><p>, where a, b, m are positive integers and a + b ≤ m and (ii) K = m t q t , M N = 1 -1 q t , F s = q m (q -1) t and R = 1 (q-1) t , where q, t, m are positive integers.</p><p>Their scheme (i), is the special case of scheme in <ref type="bibr" target="#b20">[21]</ref> when β = 0. For the second scheme, if we let t = 2, <ref type="bibr" target="#b14">[15]</ref> shows that</p><formula xml:id="formula_76">R ≈ R * , F s ≈ q K 2q ( √ q -1)</formula><p>2 and F * s ≈ (q -1)q K q -1 , which means F s is again better than F * s . We emphasize here that these results require somewhat restrictive parameter settings.</p><p>Finally, we consider the work of <ref type="bibr" target="#b15">[16]</ref>. In their work, they leveraged the results of <ref type="bibr" target="#b26">[27]</ref> to arrive at coded caching schemes where the subpacketization is linear in K. Specifically, they show that for any constant M/N , there exists a scheme with rate K δ , where δ &gt; 0 can be chosen arbitrarily small by choosing K large enough. From a theoretical perspective, this is a positive result that indicates that regimes where linear subpacketization scaling is possible. However, these results are only valid when the value of K is very large. In particular, K = C n and the result is asymptotic in the parameter For these parameter ranges, the result of <ref type="bibr" target="#b15">[16]</ref> will clearly be better as compared to our work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. CONCLUSIONS AND FUTURE WORK</head><p>In this work we have demonstrated a link between specific classes of linear block codes and the subpacketization problem in coded caching. Crucial to our approach is the consecutive column property which enforces that certain consecutive column sets of the corresponding generator matrices are fullrank. We present several constructions of such matrices that cover a large range of problem parameters. Leveraging this approach allows us to construct families of coded caching schemes where the subpacketization level is exponentially smaller compared to the approach of <ref type="bibr" target="#b0">[1]</ref>.</p><p>There are several opportunities for future work. Even though our subpacketization level is significantly lower than <ref type="bibr" target="#b0">[1]</ref>, it still scales exponentially with the number of users. Of course, the rate of growth with the number of users is much smaller. There have been some recent results on coded caching schemes that demonstrate the existence of schemes where the subpacketization scales sub-exponentially in the number of users. It would be interesting to investigate whether some of these ideas can be leveraged to obtain schemes that work for practical systems with tens or hundreds of users.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX</head><p>A. Resolvable design over Z mod q Lemma 4. A (n, k) linear block code over Z mod q with generator matrix G = [g ab ] can construct a resolvable block design by the procedure in Section III-A if gcd(q, g 0b , g 1b ,</p><formula xml:id="formula_77">• • • , g (k-1)b ) = 1 for 0 ≤ b &lt; n. Proof. Assume q = q 1 × q 2 × • • • × q d where q i , 1 ≤ i ≤ d is a prime or a prime power. If the gcd(q, g 0b , g 1b , • • • , g (k-1)b ) = 1, then it is evident that gcd(q i , g 0b , g 1b , • • • , g (k-1)b ) = 1 for 1 ≤ i ≤ d.</formula><p>As q i is either a prime or a prime power, it follows that there exists a g a * b which is relatively prime to q i , i.e., g a * b is a unit in the ring Z mod q i . Note that for ∆ = [∆ 0 ∆ 1 . . . ∆ n-1 ] = uG, we have</p><formula xml:id="formula_78">∆ b = k-1 a=0 u a g ab ,<label>(9)</label></formula><p>where</p><formula xml:id="formula_79">u = [u 0 , • • • , u k-1 ]</formula><p>. We consider eq. ( <ref type="formula" target="#formula_78">9</ref>) over the ring Z mod q i and rewrite eq. ( <ref type="formula" target="#formula_78">9</ref>) as</p><formula xml:id="formula_80">∆ b -u a * g a * b = a =a * u a g ab ,</formula><p>For arbitrary u a , a = a * , this equation has a unique solution for u a * since g a * b is a unit in Z mod q i . This implies that there are q k-1 i distinct solutions for (9) over Z mod q i . Using the Chinese remainder theorem, eq. ( <ref type="formula" target="#formula_78">9</ref>) has q k-1</p><formula xml:id="formula_81">1 × q k-1 2 × • • • q k-1 d = q k-</formula><p>1 solutions over Z mod q and the result follows.</p><p>Remark 7. From Lemma 4, it can be easily verified that a linear block code over Z mod q can construct a resolvable block design if one of the following conditions for each column g i of the generator matrix is satisfied.</p><p>• At least one non-zero entry of g i is a unit in Z mod q, or • all non-zero entries in g i are zero divisors but their greatest common divisor is 1. For the SPC code over Z mod q, all the non-zero entries in the generator matrix are 1, which is an unit. Therefore, the construction always results in a resolvable design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Lemma 2</head><p>First, we show that the proposed delivery scheme allows each user's demand to be satisfied. Note that Claim 2 shows that each user in a parallel class that belongs to the recovery set S a recovers all missing subfiles with a specified superscript from it. Thus, we only need to show that if signals are generated (according to Claim 2) for each recovery set, we are done. This is equivalent to showing that the bipartite recovery set graph is such that each parallel class has degree z and multiple edges between nodes are disallowed.</p><p>Towards this end, consider the parallel class and we claim that there exist exactly z solutions (a α , b α ) for integer values of α = 1, . . . , z to the equation</p><formula xml:id="formula_82">a α (k + 1) + b α = j + n(α -1)<label>(10)</label></formula><p>such that a α1 = a α2 for α 1 = α 2 and j &lt; n. The existence of the solution for each equation above follows from the division algorithm. Note that a α &lt; nz/(k + 1) as the RHS &lt; nz. Furthermore, note that for 1 ≤ α 1 ≤ z and 1 ≤ α 2 ≤ z, we cannot have solutions to eq. ( <ref type="formula" target="#formula_82">10</ref>) such that a α1 = a α2 as this would imply that |b α1b α2 | ≥ n which is a contradiction. This shows that each parallel class P j participates in at least z different recovery sets.</p><p>The following facts follow easily from the construction of the recovery sets. The degree of each recovery set in the bipartite graph is k + 1 and there are nz k+1 of them; multiple edges between a recovery set and a parallel class are disallowed. Therefore, the total number of edges in the bipartite graph is nz. As each parallel class participates in at least z recovery sets, by this argument, it participates in exactly z recovery sets. . Finally, we calculate the rate of the delivery phase. In total, the server transmits q k (q -1) zn k+1 equations, where the symbol transmitted has the size of a subfile. Thus, the rate is</p><formula xml:id="formula_83">R = q k (q -1) zn k + 1 1 q k z = (q -1)n k + 1 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Claim 4</head><p>The matrix G S is shown below.</p><formula xml:id="formula_84">               g 0 g 1 • • g k 2 -1 0 • • 0 0 0 g 0 g 1 • g k 2 -2 0 • • 0 0 . . . . . . 0 • 0 g 0 g 1 0 • • 0 0 0 • • 0 g 0 g n-k 0 • • 0 0 • • 0 0 g n-k-1 g n-k 0 • 0 . . . . . . 0 • • 0 0 g n-k-k 2 • • • g n-k               </formula><p>In the above expression and the subsequent discussion if i is such that i &lt; 0, we set g i = 0. By Claim 3, a cyclic code with generator matrix G satisfies the CCP if all submatrices</p><formula xml:id="formula_85">G S\(a+j)n =[g (a)n , g (a+1)n , • • • , g (a+j-1)n , g (a+j+1)n , • • • , g (a+k)n ],</formula><p>where</p><formula xml:id="formula_86">a = n -k 2 -1, 0 ≤ j ≤ k, have full rank.</formula><p>In what follows, we argue that this is true. Note that in the generator matrix of cyclic code, any k consecutive columns are linearly independent <ref type="bibr" target="#b22">[23]</ref>. Therefore for j = 0 and k, G S\(a+j)n has full rank, without needing the conditions of Claim 4. For 0 &lt; j ≤ k 2 , G S\(a+j)n is as eq. ( <ref type="formula" target="#formula_96">11</ref>). Rewriting G S\(a+j)n in block form, we get</p><formula xml:id="formula_87">G S\(a+j)n =   A j B j 0 C j 0 D j E j   ,</formula><p>where</p><formula xml:id="formula_88">A j =      g 0 g 1 • • g k 2 -1 0 g 0 g 1 • g k 2 -2 . . . . . . 0 • 0 g 0      , C j =        g n-k-1 g n-k 0 • • 0 g n-k-2 g n-k-1 g n-k 0 • 0 . . . . . . g n-k-j+1 • • • • g n-k g n-k-j • • • • g n-k-1       </formula><p>, and</p><formula xml:id="formula_89">E j =      g n-k 0 • • 0 g n-k-1 g n-k 0 • 0 . . . . . . g n-k-k 2 +j+1 • • • g n-k     </formula><p>.</p><p>Matrices A j and E j have full rank as they are respectively upper triangular and lower triangular, with non-zero entries on the diagonal (as g 0 and g n-k are non-zero in a cyclic code). Therefore, G S\(a+j)n has full rank if C j has full rank. For k 2 &lt; j &lt; k, G S\(a+j)n can be partitioned into a similar form and the result in Claim 4 follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Claim 6</head><p>We need to argue that all × k submatrices of G Sa where 0 ≤ a &lt; α are full rank. In what follows we argue that all k × k submatrices of G S0 are full rank. The proof for any G Sa is similar. Note that G S0 can be written compactly as follows by using Kronecker products. <ref type="bibr" target="#b0">(1,</ref><ref type="bibr" target="#b0">1)</ref> ,</p><formula xml:id="formula_90">G S0 = A ⊗ I t B ⊗ C (t-1)×t</formula><p>where</p><formula xml:id="formula_91">A =    b 00 • • • b 0(z-1) . . . . . . b (z-2)0 • • • b (z-2)(z-1)    and B = [b (z-1)0 , • • • , b (z-1)(z-1) ].</formula><p>Next, we check the determinant of submatrices G S0\i obtained by deleting i-th column of G S0 . W.l.o.g, we let i = (z -1)t + j where 0 ≤ j &lt; t. The block form of the resultant matrix G S0\i can be expressed as</p><formula xml:id="formula_92">G S0\i = A ⊗ I t A ⊗ ∆ 1 B ⊗ C (t-1)×t (1, 1) B ⊗ ∆ 2 ,</formula><p>where A and A are the first z -1 columns and last column of A respectively. Likewise, B and B are the first z -1 components and last component of B. The matrices ∆ 1 and ∆ 2 are obtained by deleting the j-th column of I t and C (t-1)×t (1, 1) respectively. Then, using the Schur determinant identity <ref type="bibr" target="#b27">[28]</ref>, we have</p><formula xml:id="formula_93">det(G S0\i ) = det(A ⊗ I t ) det(B ⊗ ∆ 2 - B ⊗ C (t-1)×t (1, 1) • (A ⊗ I t ) -1 • A ⊗ ∆ 1 )<label>(1)</label></formula><p>= det(A</p><formula xml:id="formula_94">⊗ I t ) det(B ⊗ ∆ 2 - B A -1 A ⊗ C (t-1)×t (1, 1)∆ 1 ) (2) = det(A ⊗ I t ) det((B -B A -1 A ) ⊗ ∆ 2 ),</formula><p>where (1) holds by the properties of the Kronecker product <ref type="bibr" target="#b27">[28]</ref> and (2) holds since C (t-1)×t (1, 1)∆ 1 = ∆ 2 . Next note that det(∆ 2 ) = 0. This is because ∆ 2 can be denoted as </p><formula xml:id="formula_95">∆ 2 = A 0 0 B , 0018-</formula><formula xml:id="formula_96">                        g 0 g 1 • g k 2 -1 0 • • • • 0 0 g 0 • g k 2 -2 0 • • • • 0 . . . . . . 0 • g 0 g 1 0 • • • • 0 0 • 0 g 0 g n-k 0 • • • 0 0 • • 0 g n-k-1 g n-k 0 • • 0 . . . . . . 0 • • 0 g n-k-j+1 • g n-k 0 • 0 0 • • 0 g n-k-j • g n-k-1 0 • 0 0 • • 0 g n-k-j-1 • g n-k-2 g n-k • 0 . . . . . . 0 • • 0 g n-k-k 2 • g n-k-k 2 +j-1 g n-k-k 2 +j+1 • g n-k                          . (<label>11</label></formula><formula xml:id="formula_97">)</formula><p>where A is a j × j upper-triangular matrix;</p><formula xml:id="formula_98">A =        1 1 0 • • • 0 0 0 1 1 • • • 0 0 . . . . . . 0 0 0 • • • 1 1 0 0 0 • • • 0 1       </formula><p>and B is a (t -1j) × (t -1j) lower-triangular matrix;</p><formula xml:id="formula_99">B =        1 0 • • • 0 0 0 1 1 • • • 0 0 0 . . . . . . 0 0 • • • 1 1 0 0 0 • • • 0 1 1       </formula><p>.</p><p>Next, we define the matrix</p><formula xml:id="formula_100">F =      b 00 b 01 • • • b 0(z-1) b 10 b 11 • • • b 1(z-1) . . . . . . b (z-1)0 b (z-1)1 • • • b (z-1)(z-1)      .</formula><p>Another application of the Schur determinant identity yields</p><formula xml:id="formula_101">det(B -B A -1 A ) = det(F) det(A ) = 0,</formula><p>since det(F) and det(A ) are both non-zero as their columns have the Vandermonde form. In F, the columns correspond to distinct and non-zero elements from GF (q); therefore, q &gt; z. Note however, that the above discussion focused only G S0 . As the argument needs to apply for all G Sa where 0 ≤ a &lt; α, we need q &gt; α.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Claim 7</head><p>Note that the matrix in eq. ( <ref type="formula">4</ref>) is the generator matrix of (n, k) linear block code over GF (q) where nz = (z + 1)(k + 1). Since z and z+1 are coprime, z is the least positive integer such that k + 1 | nz. To show G satisfies the CCP, we need to argue that all k × k submatrices of G Sa where 0 ≤ a ≤ z are full rank. It is easy to check that</p><formula xml:id="formula_102">S a = {0, • • • , n -1} \ {t(z -a), t(z -a) + 1, • • • , t(z -a) + t -1}.</formula><p>We verify three types of matrix G Sa as follows: I. a = 0 II. a = 1 III. a &gt; 1.</p><p>• Type I When a = 0, it is easy to verify that any k × k submatrix of G S0 has full rank since G S0 has the form</p><formula xml:id="formula_103">[I k×k |1 k ],</formula><p>which is the generator matrix of the SPC code. • Type II When a = 1, G S1 has the form in eq. ( <ref type="formula">12</ref>), Case 1: Suppose that we delete any of first (z -1)t columns in G S1 (this set of columns is depicted by the underbrace in eq. ( <ref type="formula">12</ref>)), say the i-th column of G S1 , where</p><formula xml:id="formula_104">z 1 t ≤ i &lt; (z 1 + 1)t and 0 ≤ z 1 ≤ z -2. Let i 1 = i -z 1 t, i 2 = (z 1 + 1)t -i -1.</formula><p>The resultant matrix G S1\i can be expressed as follows.</p><formula xml:id="formula_105">G S1\i = A C B D ,</formula><p>where</p><formula xml:id="formula_106">A = I i×i , B = 0 (k-i)×i , C =        0 t×(k-t-i) b 1 I t×t 0 t×(k-t-i) b 2 I t×t . . . . . . 0 t×(k-t-i) b z1 I t×t 0 i1×(k-t-i) b z1+1 I i1×i1 0 i1×(i2+1)       </formula><p>, and D has the form in eq. ( <ref type="formula" target="#formula_109">13</ref>). Note that if</p><formula xml:id="formula_107">z 1 = 0, C = [0 i1×(k-t-i) b 1 I i1×i1 0 i1×(i2+1) ] and if z 1 = z -2, D =   0 1×i2 0 1×i1 b z-1 0 1×i2 I i2×i2 0 i2×(i1+1) b z-1 I i2×i2 0 (t-1)×i2 C(c 1 , c 2 ) (t-1)×t   .</formula><p>To verify G S1\i has full rank, we just need to check that D has full rank (as A is full rank). Checking that D has full rank can be further simplified as follows. As b z1+1 = 0, we can move the corresponding column that has b z1+1 as its first entry so that it is the first column of D. Following this, consider C(c 1 , c 2 ) (t-1)×t \ c i1 which is obtained by deleting the i 1 -th column of </p><formula xml:id="formula_108">C(c 1 , c 2 ) (t-1)×t . C(c 1 , c 2 ) (t-1)×t \ c i1 = D 1 D 2 D 3 D</formula><formula xml:id="formula_109">G S 1 =           I t×t 0 t×t • • • 0 t×t 0 t×t I t×t • • • 0 t×t . . . 0 t×t 0 t×t • • • I t×t 0 (t-1)×t 0 (t-1)×t • • • 0 (t-1)×t Case 1 b 1 I t×t b 2 I t×t . . . b z-1 I t×t C(c 1 , c 2 ) (t-1)×t Case 2           (12) D =        0 1×i 2 0 1×t • • • 0 1×t 0 1×i 1 b z 1 +1 0 1×i 2 I i 2 ×i 2 0 i 2 ×t • • • 0 i 2 ×t 0 i 2 ×(i 1 +1) b z 1 +1 I i 2 ×i 2 . . . . . . 0 t×i 2 0 t×t • • • I t×t b z-1 I t×t 0 (t-1)×i 2 0 (t-1)×t • • • 0 (t-1)×t C(c 1 , c 2 ) (t-1)×t       <label>(13)</label></formula><p>where D 1 is a i 1 × i 1 matrix as follows</p><formula xml:id="formula_110">D 1 =        c 1 c 2 0 0 • • • 0 0 0 c 1 c 2 0 • • • 0 0 . . . . . . 0 0 0 • • • 0 c 1 c 2 0 0 0 • • • 0 0 c 1        , D 4 is a i 2 × i 2 matrix as follows D 4 =        c 2 0 0 • • • 0 0 0 c 1 c 2 0 • • • 0 0 0 . . . . . . 0 0 • • • 0 c 1 c 2 0 0 0 • • • 0 0 c 1 c 2       </formula><p>and D 2 and D 3 are i 1 × i 2 and i 2 × i 1 all zero matrices respectively. Then det(C(c 1 , c 2</p><formula xml:id="formula_111">) (t-1)×t \ c i1 ) = c i1 1 c i2 2</formula><p>and det(G S1\i ) = ±b z1+1 c i1 1 c i2 2 = 0. Case 2: By deleting any of last t columns in G S1 , say the i-th column of G S1 , where (z -1)t ≤ i &lt; zt, the block form of resultant matrix G S1\i can be expressed as follows.</p><formula xml:id="formula_112">G S1\i = A C B D ,</formula><p>where A = I (z-1)t×(z-1)t , B = 0 (t-1)×(z-1)t , C is obtained by deleting the (i</p><formula xml:id="formula_113">-(z -1)t)-th column of matrix [b 1 I t×t b 2 I t×t • • • b z-1 I t×t ] T and D is C(c 1 , c 2 ) (t-1)×t \ c i-(z-1)t . Since det(D) = c i-(z-1)t 1 c zt-i-1 2 = 0, det(G S1\i ) = ±c i-(z-1)t 1 c zt-i-1 2</formula><p>= 0 and therefore G S1\i has full rank.</p><p>• Type III when a &gt; 1, G Sa has the form in eq. ( <ref type="formula">14</ref>). As before we perform a case analysis. Each of the cases is specified by the corresponding underbrace in eq. ( <ref type="formula">14</ref>). Case 1: By deleting the i-th column of G Sa , where z 1 t ≤ i &lt; (z 1 + 1)t, z 1 ≤ za -1, i 1 = iz 1 t, and i 2 = (z 1 + 1)ti -1, the block form of the resultant matrix G Sa\i can be expressed as follows,</p><formula xml:id="formula_114">G Sa\i = A C B D ,</formula><p>where A = I i×i , B = 0 (k-i)×i , C and D has the form in eq. ( <ref type="formula">15</ref>) and eq. ( <ref type="formula" target="#formula_119">16</ref>), respectively. Note that if</p><formula xml:id="formula_115">z 1 = 0, C = [0 i1×i2 0 i1×t • • • 0 i1×(t-1) 1 i1 b 1 I i1×i1 0 i1×(i2+1) ]</formula><p>and if z 1 = za -1, D has the form in <ref type="bibr" target="#b16">(17)</ref>.</p><p>To verify that G Sa\i has full rank, we just need to check D has full rank. Owing to the construction of we have to check the determinant of the following (t+1)×(t+1) matrix. z-a+1 = 0, so that G Sa\i has full rank. Case 2: By deleting the i-th column of G Sa , where z 1 t ≤ i &lt; (z 1 + 1)t, za ≤ z 1 ≤ z -3, the proof that the resultant matrix has full rank is similar to the case that z 1 ≤ za -1 and we omit it here. Case 3: By deleting the i-th column of G Sa , where (z - </p><formula xml:id="formula_116">F =        1 0 0 • • • b z1+1 • • • 0 1 b z-a+1 0 • • • 0 • • • 0 1 0 b z-a+1 • • • 0 • • • 0 . . . . . . 1 0 0 • • • 0 • • • b z-a+1        ; det<label>(</label></formula><formula xml:id="formula_117">2)t ≤ i ≤ (z -1)t -2, i 1 = i -(z -2)t and i 2 = (z -1)t -2 -i, the resultant matrix is as follows, G Sa\i = A C B D ,<label>where</label></formula><formula xml:id="formula_118">A = I (z-a)t×(z-a)t B = 0 (k-(z-a)t)×(z-a)t C =    0 t×t • • • 0 t×(t-2) 1 t b 1 I t×t . . . . . . 0 t×t • • • 0 t×(t-2) 1 t b z-a I t×t    D =      0t×t • • • 0 t×(t-2) 1t bz-a+1It×t It×t • • • 0 t×(t-2) 1t bz-a+2It×t . . . . . . 0 (t-1)×t • • • Ii 1 ×i 1 0i 1 ×i 2 1t-1 C(c1, c2) (t-1)×t 01×i 1 01×i 2 0i 2 ×i 1 Ii 2 ×i 2     <label>0018</label></formula><formula xml:id="formula_119">G Sa =                   I t×t • • • 0 t×t . . . . . . 0 t×t • • • I t×t 0 t×t • • • 0 t×t 0 t×t • • • 0 t×t . . . . . . 0 t×t • • • 0 t×t 0 (t-1)×t • • • 0 (t-1)×t Case 1 0 t×t • • • 0 t×t . . . . . . 0 t×t • • • 0 t×t 0 t×t • • • 0 t×t I t×t • • • 0 t×t . . . . . . 0 t×t • • • I t×t 0 (t-1)×t • • • 0 (t-1)×(t-1) Case 2 0 t×(t-1) . . . 0 t×(t-1) 0 t×(t-1) 0 t×(t-1) . . . 0 t×(t-1) I (t-1)×(t-1) Case 3 1t . . . 1t 1t 1t . . . 1 t-1 Case 4 b 1 I t×t . . . b z-a I t×t b z-a+1 I t×t b z-a+2 I t×t . . . b z-1 I t×t C(c 1 , c 2 ) (t-1)×t Case 5                   (14) C =      0 t×i 2 0 t×t • • • 0 t×(t-1) 1t b 1 I t×t . . . . . . 0 t×i 2 0 t×t • • • 0 t×(t-1) 1t bz 1 I t×t 0 i 1 ×i 2 0 i 1 ×t • • • 0 i 1 ×(t-1) 1 i 1 b z 1 +1 I i 1 ×i 1 0 i 1 ×(i 2 +1)      (15) D =                0 1×i 2 0 1×t • • • • • • • • • 0 1×(t-1) 1 0 1×i 1 b z 1 +1 0 1×i 2 I i 2 ×i 2 0 i 2 ×t • • • • • • • • • 0 i 2 ×(t-1) 1 i 2 0 i 2 ×(i 1 +1) b z 1 +1 I i 2 ×i 2 0 t×i 2 I t×t • • • • • • • • • 0 t×(t-1) 1t b z 1 +2 I t×t . . . . . . 0 t×i 2 0 t×t • • • 0 t×t • • • 0 t×(t-1) 1t b z-a+1 I t×t 0 t×i 2 0 t×t • • • I t×t • • • 0 t×(t-1) 1t b z-a+2 I t×t . . . . . . 0 (t-1)×i 2 0 (t-1)×t • • • 0 (t-1)×t • • • I (t-1)×(t-1) 1 t-1 C(c 1 , c 2 ) (t-1)×t               <label>(16)</label></formula><formula xml:id="formula_120">D =          0 1×i 2 0 1×t • • • • • • • • • 0 1×(t-1) 1 0 1×i 1 b z-a 0 1×i 2 I i 2 ×i 2 0 i 2 ×t • • • • • • • • • 0 i 2 ×(t-1) 1 i 2 0 i 2 ×(i 1 +1) b z-a I i 2 ×i 2 0 t×i 2 0 t×t • • • 0 t×t • • • 0 t×(t-1) 1t b z-a+1 I t×t 0 t×i 2 0 t×t • • • I t×t • • • 0 t×(t-1) 1t b z-a+2 I t×t . . . . . . 0 (t-1)×i 2 0 (t-1)×t • • • 0 (t-1)×t • • • I (t-1)×(t-1) 1 t-1 C(c 1 , c 2 ) (t-1)×t          . (<label>17</label></formula><formula xml:id="formula_121">)</formula><p>To verify G Sa\i has full rank, we need to check the determinant of D. Owing to the construction of D, the following matrix is required to be full rank, z-a+1 (c 1 +c 2 )) = 0 and thus G Sa\i is full rank. Case 4: By deleting the i-th column of G Sa , where i = (z -1)t-1, the block form of the resultant matrix G Sa\i can be expressed as eq. ( <ref type="formula">18</ref>). Evidently, det(G Sa\i ) = ±b t z-a+1 , so that G Sa\i has full rank. </p><formula xml:id="formula_122">D = 1 t b z-a+1 I t×t 1 C(c 1 , c 2 ) (t-1)×t (i 1 ) =     1 bz-a+1 0 ••• 0 0 0 ••• 0 1 0 bz-a+1 ••• 0 0 0 ••• 0 . . . . . . 1 0 0 ••• 0 0 0 ••• bz-a+1 1 0 ••• 0 c1 c2 0 ••• 0     , where C(c 1 , c 2 ) (t-1)×t (i 1 ) denotes the i 1 -th row of C(c 1 , c 2 ) (t-1)×t , 0 ≤ i ≤ t -2. det D = det(b z-a+1 I t×t ) • det(1- C(c 1 , c 2 ) (t-1)×t (i 1 ) • (b -1 z-a+1 I t×t ) • 1 t ) =b t z-a+1 (1 -b -1 z-a+1 (c 1 + c 2 )) Since b z-a+1 = 0</formula><formula xml:id="formula_123">     1 b z-a+1 0 • • • 0 1 0 b z-a+1 • • • 0 . . . . . . 1 0 0 • • • b z-a+1     </formula><p>, by deleting any column of above matrix, it is obvious that det([1 t |b z-a+1 I t×t \c i1 ]) = ±b t-1 z-a+1 and det(G Sa\i ) = 0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Claim 8</head><p>Let z be the least integer such that k + 1 | nz. First, we argue that z is the least integer such that k+1 | (n+s(k+1))z. Assume that this is not true, then there exists z &lt; z such that 0018-9448 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information. This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIT.2018.2800059, IEEE Transactions on Information Theory</p><formula xml:id="formula_124">G Sa\i =              I t×t • • • 0 t×t 0 t×t • • • 0 t×(t-1) b 1 I t×t . . . . . . 0 t×t • • • I t×t 0 t×t • • • 0 t×(t-1) b z-a I t×t 0 t×t • • • 0 t×t 0 t×t • • • 0 t×(t-1) b z-a+1 I t×t 0 t×t • • • 0 t×t I t×t • • • 0 t×(t-1) b z-a+2 I t×t . . . . . . 0 (t-1)×t • • • 0 (t-1)×t 0 (t-1)×t • • • I (t-1)×(t-1) C(c 1 , c 2 ) (t-1)×t              (18) G Sa\i =             I t×t • • • 0 t×t 0 t×t • • • 0 t×(t-1) 1t b 1 I t×t \ c i 1 . . . . . . 0 t×t • • • I t×t 0 t×t • • • 0 t×(t-1) 1t b z-a I t×t \ c i 1 0 t×t • • • 0 t×t 0 t×t • • • 0 t×(t-1) 1t b z-a+1 I t×t \ c i 1 0 t×t • • • 0 t×t I t×t • • • 0 t×(t-1) 1t b z-a+2 I t×t \ c i 1 . . . . . . 0 (t-1)×t • • • 0 (t-1)×t 0 (t-1)×t • • • I (t-1)×(t-1) 1 t-1 C(c 1 , c 2 ) (t-1)×t \ c i 1              (19) k + 1 | (n + s(k + 1))z . As n ≥ k + 1 and k + 1 | s(k + 1)z this implies that k + 1 | nz which is a contradiction.</formula><p>Next we argue that G satisfies the CCP, i.e., all k × k submatrices of each G S a , where T a = {a(k + 1), • • • , a(k + 1)+k} and S a = {(t) n+s(k+1) |t ∈ T a } and 0 ≤ a ≤ nz k+1 +sz, are full rank. Let n = n+s(k +1). We argue it in three cases. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Claim 11</head><p>• M N = 1 q . We have</p><formula xml:id="formula_125">1 K log 2 F M N s F * s = 1 K log 2 K K/q - 1 K log 2 z - k K log 2 q.</formula><p>Using the fact that z ≤ k+1 and taking limits as n → ∞, we get that</p><formula xml:id="formula_126">lim n→∞ 1 K log 2 F M N s F * s = H 2 1 q - η q log 2 q.</formula><p>• M N = 1 -k+1 nq . We have</p><formula xml:id="formula_127">1 K log 2 F M N s F * s = 1 K log 2 K k + 1 - k + 1 K log 2 q - 1 K log 2 zn k + 1 .</formula><p>Using the fact that z ≤ k+1 and taking limits as n → ∞, we get that ] be the submatrix of G specified by the columns in S α a , i.e, g ij ∈ G S α a if i j ∈ S α a . We demonstrate that the resolvable design generated from a linear block code that satisfies the (k, α)-CCP can also be used in a coded caching scheme. First, we construct a (X, A) resolvable design as described in Section III.A., which can be partitioned into n parallel classes P i = {B i,j : 0 ≤ j &lt; q}, 0 ≤ i &lt; n. By the constructed resolvable design, we partition each subfile W n into q k z subfiles W n = {W s n,t | 0 ≤ t &lt; q k , 0 ≤ s &lt; z} and operate the placement scheme in Algorithm 1. In the delivery phase, for each recovery set, several equations are generated, each of which benefit α users simultaneously. Furthermore, the equations generated by all the recovery sets can recover all the missing subfiles. In this section, we only show that for the recovery set P S α a , it is possible to generate equations which benefit α users and allow the recovery of all of missing subfiles with given superscript. The subsequent discussion exactly mirrors the discussion in the (k, k + 1)-CCP case and is skipped.</p><p>Towards this end, we first show that picking α users from α distinct parallel classes can always form q k-α+1q k-α signals. More specifically, consider blocks B i1,li 1 , . . . , B iα,li α (where l ij ∈ {0, . . . , q -1}) that are picked from α distinct parallel classes of P S α a . Then, | ∩ α-1 j=1 B ij ,li j | = q k-α+1 and | ∩ α j=1 B ij ,li j | = q k-α . Claim 12. Consider the resolvable design (X, A) constructed by a (n, k) linear block code that satisfies the (k, α) CCP. Let P S α a = {P i | i ∈ S α a } for 0 ≤ a &lt; zn α , i.e., it is the set of parallel classes corresponding to S α a . We emphasize that |P S α a | = α ≤ k. Consider blocks B i1,li 1 , . . . , B i α ,li α (where l ij ∈ {0, . . . , q -1}) that are picked from any α distinct parallel classes of P S α a where α ≤ α. Then, | ∩ α j=1 B ij ,li j | = q k-α .</p><p>The above argument implies that any α -1 blocks from any α -1 distinct parallel classes of P S α a have q k-α+1 points in common and any α blocks B i1,li 1 , B iα,li α from any α distinct parallel classes of P S α a have q k-α points in common. These blocks (or users) can participate in q k-α+1q k-α equations, each of which benefits α users. In particular, each user will recover a missing subfile indexed by an element belonging to the intersection of the other α -1 blocks in each equation. A very similar argument to Lemma 2 can be made to justify that enough equations can be found that allow all users to recover all missing subfiles.</p><p>Proof. Recall that by the construction in Section III.A, block B i,l ∈ P i is specified as follows, B i,l = {j : T i,j = l}.</p><p>Let G = [g ab ], for 0 ≤ a &lt; k, 0 ≤ b &lt; n. Now consider B i1,li 1 , . . . , B i α ,li α (where i j ∈ S α a , l ij ∈ {0, . . . , q -1}) that are picked from α distinct parallel classes of P S α a . W.l.o.g. we assume that i 1 &lt; i 2 &lt; • • • &lt; i α . Let I = {i 1 , . . . , i α } and T I denote the submatrix of T obtained by retaining the rows in I. We will show that the vector [l i1 l i2 . . . l i α ] T is a column in T I and appears q k-α times in it.</p><p>We note here that by the (k, α)-CCP, the vectors g i1 , g i2 , . . . , g iα are linearly independent and thus the subset of these vectors, g i1 , • • • , g i α are linearly independent. W. l. o. g., we assume that the top α × α submatrix of the matrix [g i1 g i2 . . . g i α ] is full-rank. Next, consider the system of equations in variables u 0 , . . . , u α -1 . By the assumed condition, it is evident that this system of α equations in α variables has a unique solution for a given vector v = [u α , • • • , u k-1 ] over GF (q). Since there are q k-α possible v vectors, the result follows.</p><p>As in the case of the (k, k +1)-CCP, we form a recovery set bipartite graph with parallel classes and recovery sets as the disjoint vertex subsets, and the edges incident on each parallel class are labeled arbitrarily from 0 to z -1. For a parallel class P ∈ P S α a we denote this label by label(P -P S α a ). For a given recovery set P S α a , the delivery phase proceeds by choosing blocks from α distinct parallel classes in P S α a and it provides q k-α+1 -q k-α equations that benefit α users. Note that in the (k, α)-CCP case, randomly picking α blocks from α parallel classes in P S α a will always result in q k-α intersections, which is different from (k, k +1)-CCP. It turns out that each equation allows a user in P ∈ P S α a to recover a missing subfile with superscript label(P -P S α a ). Let the demand of user U Bi,j for i ∈ n-1, 0 ≤ j ≤ q-1 by W κi,j . We formalize the argument in Algorithm 4 and prove that equations generated in each recovery set P S α a can recover all missing subfile with superscript label(P -P S α a ).</p><p>Algorithm 4: Signal Generation Algorithm for P S α a Input : For P ∈ P S α a , E(P) = label(P -P S α a ). Signal set Sig = ∅. 1 while any user U B ∈ P j , j ∈ S α a does not recover all its missing subfiles with superscript E(P) do 2 Pick blocks B j,lj ∈ P j for all j ∈ S α a and l j ∈ {0, . . . , q -1}; / * Pick blocks from distinct parallel classes in P S α a . The cardinality of their intersection is always q k-α * / 3 Find set Ls = ∩ j∈S α a \{s} B j,lj \ ∩ j∈S α a B j,lj for s ∈ S α a ;</p><p>/ * Determine the missing subfile indices that the user from P α s will recover. Note that | Ls| = q k-α+1q k-α * / , 0 ≤ t &lt; q k-α+1q k-α , to Sig; For the sake of convenience we argue that user U B β,l β that demands W κ β,l β can recover all its missing subfiles with superscript E(P β ). Note that B β,l β = q k-1 . Thus user U B β,l β needs to obtain q kq k-1 missing subfiles with superscript E(P β ). The delivery phase scheme repeatedly picks α users from different parallel classes of P S α a . The equations in Algorithm 4 allow U B β,l β to recover all W E(P β ) κ β,l β , Lβ [t] where Lβ =</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Example 6 .</head><label>6</label><figDesc>Consider the placement scheme specified in Example 5. Let each user U B request file W d B . The recovery sets are specified by means of the recovery set bipartite graph shown in Fig.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>0018-9448 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information. This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIT.2018.2800059, IEEE Transactions on Information Theory Code type Code construction Notes Codes over field GF (q) (n, k) MDS codes Satisfy (k, k + 1)-CCP. Need q + 1 ≥ n. (n, k) Cyclic codes Existence depends on certain properties of the generator polynomials. All cyclic codes satisfy the (k, k)-CCP. Additional conditions are needed for the (k, k + 1)-CCP. Kronecker product of z×α matrices satisfying the (z, z)-CCP with the identity matrix I t×t Satisfy the (k, k)-CCP where k = tz. Kronecker product of Vandermonde and Vandermonde-like matrices with structured base matrices Satisfy the (k, k + 1)-CCP for certain parameters. CCP matrix extension Extends a k × n CCP matrix to a k × (n + s(k + 1)) CCP matrix for integer s. Codes over ring Z mod q Single parity-check (SPC) code Satisfies the (k, k + 1)-CCP with n = k + 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>) a×b : a × b matrix where each row is the cyclic shift (one place to the right) of the row above it and the first row is [c 1 c 2 0 • • • 0]; and • 0 a×b : a × b matrix with zero entries. Consider parameters n, k. Let the greatest common divisor of n and k + 1, gcd(n, k + 1) = t. It is easy to verify that z = k+1 t is the smallest integer such that k + 1 | nz. Let n = tα and k + 1 = tz. Claim 6 below constructs a</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Claim 8 .</head><label>8</label><figDesc>1 are non-zero and distinct, and c 1 + c 2 = 0, then G satisfies the CCP. Proof. See Appendix. Given a (n, k) code that satisfies the CCP, we can use it obtain higher values of n in a simple manner as discussed in the claim below. Consider a (n, k) linear block code over GF (q) with generator matrix G that satisfies the CCP. Let the first k + 1 columns of G be denoted by the submatrix D. Then the matrix G of dimension k × (n + s(k + 1)) where s ≥ 0 G = [D| • • • |D s |G] also satisfies the CCP.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>14 else 15 if α = z + 1 and q ≥ z then 16 C</head><label>141516</label><figDesc>(n, q) ← k. Corresponding codes are constructed by Claim 7 and Claim 8.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>17</head><label>17</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>end 18 if α &gt; z + 1 and q &gt; α then 19 C</head><label>1819</label><figDesc>(n, q) ← k. Corresponding codes are constructed by Claim 6 and Claim 8.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>if q is not a prime power then 27 for k = 1 : (n -1) do 28 if z ≤ 2 then 29 C(n, q) ← k. Corresponding codes are constructed by Claim 9 when z = 1 and Claim 8 or Claim 10 and Claim 8 when z = 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 3 .</head><label>3</label><figDesc>Fig.3. The plot shows the gain in the scaling exponent obtained using our techniques for different value of M/N = 1/q. Each curve corresponds to a choice of η = k/n.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>F) = (b z-a+1 -b z1+1 )b t-1 z-a+1 . Since z 1 = z -a and then b z1+1 = b z-a+1 , the above matrix has full rank and det(G Sa\i ) = ±(b z-a+1b z1+1 )b t-1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>and c 1 +c 2 = 0, det D = 0 and D has full rank. Then det(D) = b t z-a+1 (1-b -1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>• Case 1 .</head><label>1</label><figDesc>The first column of G S a lies in the first s(k + 1) columns of G . Suppose ln ≤ a(k + 1) &lt; ln + s(k + 1) where 0 ≤ l &lt; z -1. By the construction of G , G Sa = D. Since D = G S0 , all k × k submatrices of D have full rank and so does G Sa .• Case 2. The first and last column of G S a lie in the last n columns of G . Suppose ln + s(k + 1) ≤ a(k + 1) and a(k+ 1) + k &lt; (l + 1)n where 0 ≤ l &lt; z -1. As n &gt; s(k + 1), a(k + 1) -(l + 1)s(k + 1) &gt; 0 and k + 1 | a(k + 1) -(l + 1)s(k + 1). Let a = a -(l + 1)s, then G Sa = G S aand hence all k × k submatrices of G Sa have full rank. • Case 3. The first column of G S a lies in the last n columns of G but the last column lies in the first (k + 1) columns of G . Suppose ln + s(k + 1) ≤ a(k + 1) and a(k+ 1) + k &gt; (l + 1)n where 0 ≤ l &lt; z -2. Again, we can get k +1 | a(k +1)-(l +1)s(k +1) and let a = a-(l +1)s. Let S 1 = {(a(k + 1)) n , • • • , (ln + n -1) n } and S 1 = {(a (k+1)) n , • • • , (ln+n-1) n }. As (ln +n -1)-a(k+ 1) = (ln + n -1)a (k + 1), G S 1 = G S 1 . Let S 2 = {(ln + n ) n , • • • , (a(k + 1) + k) n } and S 2 = {(ln + n) n , • • • , (a (k + 1) + k) n }. By the construction of G , G S 2 = G S 2 . Then G Sa = [G S 1 G S 2 ] = [G S 1 G S 2 ] =G S a and hence all k × k submatrices of G Sa have full rank.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>on coded caching systems constructed by generator matrices satisfying the (k, α)-CCP where α ≤ k Consider the (k, α)-CCP (cf. Definition 5) where α ≤ k. Let z be the least integer such that α | nz, and letT α a = {aα, • • • , aα + α -1)} and S α a = {(t) n | t ∈ T α a }. Let G S α a = [g i0 , • • • , g iα-1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>α - 1 b=0uu</head><label>1</label><figDesc>b g bi1 = l i1b g bi2 = l i2 -k-1 b=α u b g bi2 , . . . α -1 b=0 u b g bi α = l i α -k-1 b=α u b g bi α .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>The blocks in A correspond to twelve users U 012 , U 345 , U 678 , U 036 , U 147 , U 258 , U 057 , U 138 , U 246 , U 048 , U 237 , U 156 . Each file is partitioned intoF s = 9 × z = 27 subfiles, each of which is denoted by W s n,t , t = 0, • • • , 8, s = 0, 1, 2.The cache in user U abc , denoted Z abc is specified as Z abc = {W s n,t | t ∈ {a, b, c}, s ∈ {0, 1, 2} and n ∈ [N ]}. This corresponds to a coded caching system where each user caches 1/3-rd of each file so that M/N = 1/3. Divide each file W n , for n ∈ [N ] into q k z subfiles.</figDesc><table><row><cell>1 and Example 5. Consider the resolvable design from Example illustrated further in Example 5. 3, where we recall that z = 3. Algorithm 1: Placement Scheme Input : Resolvable design (X, A) constructed from a (n, k) linear block code. Let z be the least positive integer such that k + 1 | nz. Thus, W n = {W s n,t : t ∈ {0, . . . , q k -1} and s ∈ {0, . . . , z -1}} ; 2 User U B for B ∈ A caches Z B = {W s n,t : n ∈ [N ], t ∈ B &amp; s ∈ {0, . . . , z -1}} ; Output: Cache content of user U B denoted Z B for B ∈ A. Parallel Classes Recovery Sets P 0 P 1 P 2 P 3 P S0 P S1 P S2 P S3 0 1 2 0 1 2 0 1 2 0 1 2 1 Fig. 1. Recovery set bipartite graph</cell></row></table><note><p><ref type="bibr" target="#b0">1</ref> </p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Aj m where for each ∈ [m], we have the property that user U t does not cache subfile W n,Aj but caches all subfiles W n,Aj s where {j s</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIT.2018.2800059, IEEE Transactions on Information Theory</figDesc><table /><note><p>The placement scheme is obtained as discussed earlier, i.e., user U t caches subfiles W n,Aj if integer t does not appear 0018-9448 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIT.2018.2800059, IEEE Transactions on Information Theory Generator polynomial is X 8 + X 7 + 4X 6 + 3X 5 + 2X 3 + X 2 + 4X + 4</figDesc><table><row><cell>k</cell><cell>n</cell><cell>z</cell><cell>α</cell><cell>Construction</cell><cell>Notes</cell></row><row><cell>11</cell><cell>12</cell><cell>1</cell><cell>1</cell><cell>(12, 11) SPC code</cell><cell>k + 1 = n</cell></row><row><cell>10</cell><cell>12</cell><cell>11</cell><cell>12</cell><cell>-</cell><cell>-</cell></row><row><cell>9</cell><cell>12</cell><cell>5</cell><cell>6</cell><cell>Claim 7</cell><cell>α = z + 1 and q ≥ z</cell></row><row><cell>8</cell><cell>12</cell><cell>3</cell><cell>4</cell><cell>Claim 7</cell><cell>α = z + 1 and q ≥ z</cell></row><row><cell>7 6</cell><cell>12 12</cell><cell>2 7</cell><cell>3 12</cell><cell>Claim 7 Claim 4</cell><cell>α = z + 1 and q ≥ z Generator polynomial is X 6 + X 5 + 3X 4 + 3X 3 + X 2 + 4X + 3</cell></row><row><cell>5</cell><cell>6</cell><cell>1</cell><cell>1</cell><cell>(6,5) SPC code and Claim 8</cell><cell>Extend (6,5) SPC code to (12,5) code</cell></row><row><cell>4</cell><cell>7</cell><cell>5</cell><cell>7</cell><cell>Claim 4</cell><cell></cell></row><row><cell>3</cell><cell>4</cell><cell>1</cell><cell>1</cell><cell>(4,3) SPC code and Claim 8</cell><cell>Extend (4,3) SPC code to (12,3) code</cell></row><row><cell>2</cell><cell>3</cell><cell>1</cell><cell>1</cell><cell>(3,2) SPC code and Claim 8</cell><cell>Extend (3,2) SPC code to (12,2) code</cell></row><row><cell>1</cell><cell>2</cell><cell>1</cell><cell>1</cell><cell>(2,1) SPC code and Claim 8</cell><cell>Extend (2,1) SPC code to (12,1) code</cell></row></table><note><p>in this example. In particular, we divide each file of size Ω into two smaller subfiles W 1 n and W 2 n , where the size of W 1 n , |W 1 n | = 9 10 Ω and the 0018-9448 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>TABLE II LIST</head><label>II</label><figDesc>OF k VALUES FOR EXAMPLE 9. THE VALUES OF n , α AND z ARE OBTAINED BY FOLLOWING ALGORITHM 3.</figDesc><table /><note><p><p>size of W 2 n , |W 2 n | =</p>1 10 Ω. The scheme of [1] is then applied separately on W 1 n and W 2 n with M1 N1 = 2 15 (corresponding to W 1 n ) and M2 N2 = 13 15 (corresponding to W 2 n</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>k+1) ;</figDesc><table><row><cell>5 6</cell><cell>n gcd(n ,k+1) ; if there exists a (n + i(k + 1), k) cyclic code α ←</cell></row><row><cell></cell><cell>which satisfies the condition in Claim 4 for</cell></row><row><cell>7</cell><cell>some i such that n + i(k + 1) ≤ n then C(n, q) ← k. Corresponding codes are constructed by using Claim 8.</cell></row><row><cell>8</cell><cell>else</cell></row><row><cell>9 10</cell><cell>if z ≤ 2 then C(n, q) ← k. Corresponding codes are constructed by SPC code and Claim 8</cell></row><row><cell></cell><cell>when z = 1 or Claim 7 and Claim 8</cell></row><row><cell></cell><cell>when z = 2.</cell></row></table><note><p><p>11 else 12 if q + 1 ≥ n then 13 C(n, q) ← k.</p>Corresponding codes are constructed by MDS code and Claim 8.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>9448 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information. This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIT.2018.2800059, IEEE Transactions on Information Theory</figDesc><table><row><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIT.2018.2800059, IEEE Transactions on Information Theory</figDesc><table /><note><p><p><ref type="bibr" target="#b3">4</ref> </p>, 0018-9448 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIT.2018.2800059, IEEE Transactions on Information Theory</figDesc><table /><note><p>-9448 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head></head><label></label><figDesc>Sa\i can be expressed as eq. (19). where b s I t×t \ c i1 denotes the submatrix obtained by deleting i 1 -th column of b s I t×t and C(c 1 , c 2 ) (t-1)×t \c i1 denotes the submatrix obtained by deleting i 1 -th column of C(c 1 , c 2 ) (t-1)×t \ c i1 . To verify G Sa\i has full rank, we just need to check [1 t |b z-a+1 I t×t \ c i1 ] has full rank. Since [1 t |b z-a+1 I t×t ] has the following form,</figDesc><table /><note><p>Case 5: By deleting i-th column of G Sa , where (z-1)t ≤ i &lt; zt and i 1 = i-(z-1)t, the block form of the resultant matrix G</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head>4</head><label></label><figDesc>Add signals ⊕ s∈S α a W</figDesc><table /><note><p>E(Ps) κ s,ls , Ls[t]</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head></head><label></label><figDesc>/ * User U B s,ls demands file Wκ s,ls . This equation allows it to recover the corresponding missing subfile index Ls[t], which is the t-th element of Ls[t].</figDesc><table><row><cell>The</cell></row><row><cell>superscript is determined by the recovery</cell></row><row><cell>set bipartite graph * /</cell></row><row><cell>5 end</cell></row><row><cell>Output: Signal set Sig.</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Aditya Ramamoorthy (M'05) received the B.Tech. degree in electrical engineering from the Indian Institute of Technology, Delhi, in 1999, and the M.S. and Ph.D. degrees from the University of California, Los Angeles (UCLA), in 2002 and 2005, respectively. He was a systems engineer with Biomorphic VLSI Inc. until 2001. From 2005 to 2006, he was with the Data Storage Signal Processing Group of Marvell Semiconductor Inc. Since fall 2006, he has been with the Electrical and Computer Engineering Department at Iowa State University, Ames, IA 50011, USA. His research interests are in the areas of network information theory, channel coding and signal processing for bioinformatics and nanotechnology. Dr. Ramamoorthy served as an editor for the IEEE Transactions on Communications from 2011 -2015. He is currently serving as an associate editor for the IEEE Transactions on Information Theory. He is the recipient of the 2012 Early Career Engineering Faculty Research Award from Iowa State University, the 2012 NSF CAREER award, and the Harpole-Pentair professorship in 2009 and 2010.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIT.2018.2800059, IEEE Transactions on Information Theory ∩ j∈S α a \{β} B j,lj \ ∩ j∈S α a B j,lj and t = 1, • • • , q k-α+1q k-α . This is because of Claim 12.</p><p>Next, we count the number of equations that U B β,l β participates in. We can pick α -1 users from α -1 parallel classes in P S α a . There are totally q α-1 ways to pick them, each of which generate q k-α+1q k-α equations. Thus there are a total of q kq k-1 equations in which user U B β,l β participates in.</p><p>It remains to argue that each equation provides a distinct file part of user U B β,l β . Towards this end,</p><p>Note that when we pick the same set of blocks [t1] and W [t2] are the same since the points in Lβ are distinct. Next, suppose that there exist sets of blocks</p><p>, which is impossible since two blocks from the same parallel class have an empty intersection.</p><p>Finally we calculate the transmission rate. In Algorithm 4, for each recovery set, we transmit q k+1q k equations and there are totally zn α sets. Since each equation has size equal to a subfile, the rate is given by</p><p>The (n, k) linear block codes that satisfy the (k, α)-CCP over GF (q) correspond to a coded caching system with K = nq, M N = 1 q , F s = zq k and have a rate R = n(q-1) α . Thus, the rate of this system is a little higher compared to the (k, k +1)-CCP system with almost the same subpacketization level.</p><p>However, by comparing Definitions 4 and 5 it is evident that the rank constraints of the (k, α)-CCP are weaker as compared to the (k, k + 1)-CCP. Therefore, in general we can find more instances of generator matrices that satisfy the (k, α)-CCP. For example, a large class of codes that satisfy the (k, k)-CCP are (n, k) cyclic codes since any k consecutive columns in their generator matrices are linearly independent <ref type="bibr" target="#b22">[23]</ref>. Thus, (n, k) cyclic codes always satisfy the (k, k)-CCP but satisfy (k, k + 1)-CCP if they satisfy the additional constraints discussed in Claim 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Cyclic codes over Z mod q [25]</head><p>First, we show that matrix T constructed by constructed by the approach outlined in Section IV-D still results in a resolvable design. Let ∆ = [∆ 0 ∆ 1 • • • ∆ n-1 ] be a codeword of the cyclic code over Z mod q, denoted C where q = q 1 q 2 • • • q d , and q i , i = 1, . . . , d are prime. By using the Chinese remaindering map ψ (discussed in Section IV-D), ∆ can be uniquely mapped into d codewords c (i) , i = 1, . . . , d where each c (i) is a codeword of C i (the cyclic code over GF (q i )). Thus, the b-th component ∆ b can be mapped to (c</p><p>ab ] represent the generator matrix of the code C i . Based on prior arguments, it is evident that there are q ki-1 i distinct solutions over GF (q i ) to the equation</p><p>In turn, this implies that ∆ b appears q k1-1</p><p>times in the b-th row of T and the result follows.</p><p>Next, we show that any α blocks from distinct parallel classes of P S k min a have q k1-α</p><p>Towards this end consider B i1,li 1 , . . . , B iα,li α (where i j ∈ S kmin a , l ij ∈ {0, . . . , q -1}) that are picked from α distinct parallel classes of P S k min a . W.l.o.g. we assume that i 1 &lt; i 2 &lt; • • • &lt; i α . Let I = {i 1 , . . . , i α } and T I denote the submatrix of T obtained by retaining the rows in I. We will show that the vector [l i1 l i2 . . . l iα ] T is a column in T I and appears q k1-α</p><p>Let ψ m (l ij ) for m = 1, . . . , d represent the m-th component of the map ψ. Consider the (n, k 1 ) cyclic code over GF (q 1 ) and the system of equations in variables u 0 , . . . , u α-1 that lie in GF (q 1 ).</p><p>biα .</p><p>By arguments identical to those made in Claim 12 it can be seen that this system of equations has q k1-α 1 solutions. Applying the same argument to the other cyclic codes we conclude that the vector </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Fundamental limits of caching</title>
		<author>
			<persName><forename type="first">M</forename><surname>Maddah-Ali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Niesen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Info. Th</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="2856" to="2867" />
			<date type="published" when="2014-05">May 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Improved lower bounds for coded caching</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ghasemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ramamoorthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Info. Th</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="4388" to="4413" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Improved approximation of storage-rate tradeoff for caching via new outer bounds</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sengupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tandon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">C</forename><surname>Clancy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Intl. Symposium on Info. Th</title>
		<imprint>
			<biblScope unit="page" from="1691" to="1695" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Decentralized coded caching attains order-optimal memory-rate tradeoff</title>
		<author>
			<persName><forename type="first">M</forename><surname>Maddah-Ali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Niesen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Netw</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1029" to="1040" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Coded caching with nonuniform demands</title>
		<author>
			<persName><forename type="first">U</forename><surname>Niesen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Maddah-Ali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Info. Th</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1146" to="1158" />
			<date type="published" when="2017-02">Feb 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Multi-level coded caching</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hachem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Karamchandani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Diggavi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Intl. Symposium on Info. Th</title>
		<imprint>
			<biblScope unit="page" from="56" to="60" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Coded caching for networks with the resolvability property</title>
		<author>
			<persName><forename type="first">L</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ramamoorthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Intl. Symposium on Info</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On the fundamental limits of caching in combination networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Tulino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Llorca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Caire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Effros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Langberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 16th International Workshop on Signal Processing Advances in Wireless Communications (SPAWC)</title>
		<imprint>
			<date type="published" when="2015-06">June 2015</date>
			<biblScope unit="page" from="695" to="699" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Asynchronous coded caching</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ghasemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ramamoorthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Intl. Symposium on Info</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="2438" to="2442" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Coded caching for delay-sensitive content</title>
		<author>
			<persName><forename type="first">U</forename><surname>Niesen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Maddah-Ali</surname></persName>
		</author>
		<editor>IEEE Intl. Conf. Comm</editor>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="5559" to="5564" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">4K Sector Disk Drives: Transitioning to the Future with Advanced Format Technologies</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Fitzpatrick</surname></persName>
		</author>
		<ptr target="http://cdaweb01.storage.toshiba.com/docs/services-support-documents/toshiba4kwhitepaper.pdf" />
	</analytic>
	<monogr>
		<title level="m">Toshiba 4K White Paper</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Finite length analysis of caching-aided coded multicasting</title>
		<author>
			<persName><forename type="first">K</forename><surname>Shanmugam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Tulino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Llorca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Dimakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">52nd Annual Allerton Conference on Communication, Control, and Computing</title>
		<imprint>
			<date type="published" when="2014-09">Sept 2014</date>
			<biblScope unit="page" from="914" to="920" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Finite-length analysis of caching-aided coded multicasting</title>
		<author>
			<persName><forename type="first">K</forename><surname>Shanmugam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Tulino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Llorca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Dimakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Info. Th</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="5524" to="5537" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">On the placement delivery array design for centralized coded caching scheme</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Info. Th</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="5821" to="5833" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Centralized coded caching schemes: A hypergraph theoretical approach</title>
		<author>
			<persName><forename type="first">C</forename><surname>Shangguan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ge</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/1608.03989" />
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note type="report_type">preprint</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Coded caching with linear subpacketization is possible using Ruzsa-Szeméredi graphs</title>
		<author>
			<persName><forename type="first">K</forename><surname>Shanmugam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Tulino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Dimakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Intl. Symposium on Info. Th</title>
		<imprint>
			<biblScope unit="page" from="1237" to="1241" />
			<date type="published" when="2017-06">June 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Fractional repetition codes with flexible repair from combinatorial designs</title>
		<author>
			<persName><forename type="first">O</forename><surname>Olmez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ramamoorthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Info. Th</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1565" to="1591" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Capacity of sum-networks for different message alphabets</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Tripathy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ramamoorthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Intl. Symposium on Info. Th</title>
		<imprint>
			<biblScope unit="page" from="606" to="610" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Sum-networks from incidence structures: construction and capacity analysis</title>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Info. Th</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Stinson</surname></persName>
		</author>
		<title level="m">Combinatorial Designs: Construction and Analysis</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Placement delivery array design through strong edge coloring of bipartite graphs</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Communications Letters</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Roth</surname></persName>
		</author>
		<title level="m">Introduction to Coding Theory</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Costello</surname></persName>
		</author>
		<title level="m">Error Control Coding</title>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Abstract algebra</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Dummit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Foote</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Wiley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Codes over certain rings</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">F</forename><surname>Blake</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Control</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="396" to="404" />
			<date type="published" when="1972">1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Graham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Knuth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Patashnik</surname></persName>
		</author>
		<title level="m">Concrete mathematics: a foundation for computer science</title>
		<imprint>
			<publisher>Addison-Wesley Professional</publisher>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
	<note>nd ed.</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Nearly complete graphs decomposable into large induced matchings and their applications</title>
		<author>
			<persName><forename type="first">N</forename><surname>Alon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moitra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Sudakov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 44-th Annual ACM symposium on Theory of computing (STOC)</title>
		<meeting>of the 44-th Annual ACM symposium on Theory of computing (STOC)</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1079" to="1090" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
		</author>
		<title level="m">Topics in matrix analysis</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
