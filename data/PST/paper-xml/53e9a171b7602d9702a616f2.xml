<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Practical Homomorphic MACs for Arithmetic Circuits</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Dario</forename><surname>Catalano</surname></persName>
							<email>catalano@dmi.unict.it</email>
							<affiliation key="aff0">
								<orgName type="department">Dipartimento di Matematica e Informatica</orgName>
								<orgName type="institution">Università di Catania</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Dario</forename><surname>Fiore</surname></persName>
							<email>fiore@mpi-sws.org</email>
							<affiliation key="aff1">
								<orgName type="department">Max Planck Institute for Software Systems</orgName>
								<orgName type="institution">MPI-SWS)</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Practical Homomorphic MACs for Arithmetic Circuits</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">824E00AD46D3A68A516D8B5EBC8142F6</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:05+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Homomorphic message authenticators allow the holder of a (public) evaluation key to perform computations over previously authenticated data, in such a way that the produced tag σ can be used to certify the authenticity of the computation. More precisely, a user knowing the secret key sk used to authenticate the original data, can verify that σ authenticates the correct output of the computation. This primitive has been recently formalized by Gennaro and Wichs, who also showed how to realize it from fully homomorphic encryption. In this paper, we show new constructions of this primitive that, while supporting a smaller set of functionalities (i.e., polynomially-bounded arithmetic circuits as opposite to boolean ones), are much more efficient and easy to implement. Moreover, our schemes can tolerate any number of (malicious) verification queries. Our first construction relies on the sole assumption that one way functions exist, allows for arbitrary composition (i.e., outputs of previously authenticated computations can be used as inputs for new ones) but has the drawback that the size of the produced tags grows with the degree of the circuit. Our second solution, relying on the D-Diffie-Hellman Inversion assumption, offers somewhat orthogonal features as it allows for very short tags (one single group element!) but poses some restrictions on the composition side.</p><p>Work done while Postdoctoral researcher at NYU.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Cloud Computing allows a user to outsource his data to remote service providers in such a way that he can later access the data from multiple platforms (e.g., his desktop at work, his laptop, his smartphone, etc.), and virtually from everywhere. Moreover, using this paradigm, even clients with very limited storage capacity (e.g., smart phones) can have access "on demand" to very large amounts of data. Having access to the outsourced data does not necessarily mean only to retrieve such data. Indeed, a user may wish to perform a computation on (a subset of) the outsourced data, and this too can be delegated to the service provider. These and other benefits are the key success of Cloud Computing. The paradigm, however, raises security concerns essentially because cloud providers cannot always be trusted. One problem is related to preserving the privacy of the outsourced data. This question has been successfully addressed by the recent work on fully homomorphic encryption <ref type="bibr" target="#b25">[24]</ref>. The second question deals with enforcing the authenticity of the computations performed on the outsourced data, and is the focus of this work. In a nutshell, this problem can be described as follows. Assume that a client outsources a collection of data m 1 , . . . , m n to a server, and later asks the server to run a program P over (m 1 , . . . , m n ). The server computes m←P(m 1 , . . . , m n ) and sends m to the client. The problem here is that the client wants to be sure that m is the value obtained by running P on its own data. A trivial solution would be to have the server send m 1 , . . . , m n to the client, who can then compute/check m = P(m 1 , . . . , m n ) by itself. This however vanishes the advantages of the outsourcing and is too costly in terms of bandwidth. Therefore, the main goal here is to find solutions in which the server can authenticate the output of the computation by sending some value whose size is much shorter than m 1 , . . . , m n . Such property is also motivated by the fact that, in spite of the continuous progress in increasing the computational power of small devices, bandwidth (especially in mobile data connections) seems to remain the most serious and expensive bottleneck.</p><p>The research community has recently put a notable effort in developing new cryptographic tools that can help in solving this and related problems. It is the case, for instance, for works on verifiable computation <ref type="bibr" target="#b29">[28,</ref><ref type="bibr" target="#b30">29,</ref><ref type="bibr" target="#b27">26,</ref><ref type="bibr" target="#b22">21,</ref><ref type="bibr" target="#b18">17,</ref><ref type="bibr" target="#b2">3]</ref> and memory delegation <ref type="bibr" target="#b19">[18]</ref>.</p><p>Another line of research has explored the idea of enabling computation on authenticated data <ref type="bibr" target="#b1">[2]</ref> by means of homomorphic authentication primitives.</p><p>In the public key setting Boneh and Freeman introduced the notion of (fully) homomorphic signatures <ref type="bibr" target="#b11">[11]</ref>. Roughly speaking, a homomorphic signature allows a user to generate signatures σ 1 , . . . , σ n on messages m 1 , . . . , m n so that later anyone (without knowledge of the signing key) can compute a signature σ that is valid for the value m = f (m 1 , . . . , m n ). Boneh and Freeman also showed a realization of homomorphic signatures for bounded (constant) degree polynomials, from ideal lattices.</p><p>Very recently, Gennaro and Wichs proposed, formally defined and constructed the secret-key analogue of homomorphic signatures, that is homomorphic message authenticators (homomorphic MACs, for short) <ref type="bibr" target="#b24">[23]</ref>. Their construction makes use of fully homomorphic encryption and allows to evaluate every circuit.</p><p>In this work, we continue the study of homomorphic MACs and propose new constructions which, while less general than that given in <ref type="bibr" target="#b24">[23]</ref>, are much more efficient.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Homomorphic Message Authenticators.</head><p>Informally, a homomorphic MAC scheme enables a user to use his secret key for generating a tag σ which authenticates a message m so that later, given a set of tags σ 1 , . . . , σ n authenticating messages m 1 , . . . , m n respectively, anyone can homomorphically execute a program P over (σ 1 , . . . , σ n ) to generate a short tag σ that authenticates m as the output of P(m 1 , . . . , m n ). Given such a primitive, it is not hard to imagine how it can be employed to solve the problem of verifying computations on outsourced data. However, the above description needs some refinements, in particular to explain what means to authenticate a message as the output of a program. To do this Gennaro and Wichs introduce the notion of labeled data and programs.</p><p>The label τ of a data m is some binary string τ chosen by the user to authenticate m, i.e., σ←Auth(sk, τ, m). One can think of labels as some indexing of the data. For example, assume that a company outsources a database with informations on its customers, in which each column contains a different attribute (e.g., age, expended amount, etc.). Then, to authenticate the "age" column of the database the user can define a label "(age, i)" for the age value in record i. On the other hand, a labeled program P is defined by a circuit f and a set of labels τ 1 , . . . , τ n , one for each input wire of f . This can be seen as a way to specify on which inputs the circuit should be evaluated upon, without knowing the input values themselves. So, given a labeled program P = (f, τ 1 , . . . , τ n ) and a set of tags σ 1 , . . . , σ n that authenticate messages m i under label τ i , anyone can run the homomorphic evaluation algorithm σ←Eval(P, σ 1 , . . . , σ n ) whose output σ will authenticate m = P(m 1 , . . . , m n ). Precisely, the secret-key verification algorithm takes as input a triple (m, P, σ) and verifies that m is the output of the program P run on some previously authenticated and labeled messages, without knowing such messages themselves.</p><p>Informally, homomorphic MACs are secure if any adversary who can adaptively query tags for messages of its choice cannot produce a valid tag σ that authenticates m as the output of P unless σ can be honestly computed by applying Eval on the queried tags.</p><p>Homomorphic MACs are also required to be succinct. Informally, succinctness requires that the output of P run over (previously) authenticated data can be certified with significantly less communication than that of sending the original inputs. Another property one might want from homomorphic MACs is composability, which allows to combine tags authenticating previous computations to create a tag that authenticates a composition of such computations. More precisely, given tags σ 1 , . . . , σ t that authenticate m 1 , . . . , m t as the outputs of P 1 , . . . , P t respectively, composability allows to further compute σ←Eval(P, σ 1 , . . . , σ t ) which authenticates m = P(m 1 , . . . , m t ) as the output of P * , the composed program obtained by running P on the outputs of P 1 , . . . , P t .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Our Contribution</head><p>In this paper we propose the first practically efficient constructions of homomorphic MACs. The most attractive feature of our schemes is that they are efficient, simple to implement and rely on well studied assumptions. Moreover, they are secure against PPT adversaries that can make an unbounded number of verification queries, as opposite to the construction in <ref type="bibr" target="#b24">[23]</ref> that supports only an a-priori bounded number of verification queries (see next section for more details about this). On the negative side our solution works only for functionalities that can be expressed as arithmetic circuits with certain additional restrictions that we describe below.</p><p>Our first construction is surprisingly simple and relies only on the existence of pseudorandom functions. While it offers arbitrary composition, it does not achieve full succinctness. More precisely, the size of the authentication tags grows with the degree d of the circuit<ref type="foot" target="#foot_0">1</ref> , and thus we are able to guarantee succinct authenticators only when d is smaller than the input size n.</p><p>Our second construction enjoys succinct, constant-size tags (just one group element!) but only supports a limited form of composition . More precisely, for a fixed bound D (polynomial in the security parameter) the scheme allows to evaluate any arithmetic circuit of degree d ≤ D. In general, the evaluation has to be done in a "single shot", that is the authentication tags obtained from the Eval algorithm cannot be used again to be composed with other tags. However, we interestingly show that the scheme achieves what we call local composition.</p><p>The idea is that one can keep locally a non-succinct version of the tag that allows for arbitrary composition. Next, when it comes to send an authentication tag to the verifier, one can securely compress such large tag in a very compact one of constant-size. We prove the security of our second construction under the D-Diffie Hellman Inversion assumption <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b31">30]</ref> (where D is the bound on the maximal circuit's degree supported by the scheme).</p><p>Succinct Tags and Composition. Even though our solutions do not achieve succinctness and composition at the same time, we argue that these limitations might not be too relevant in many real life scenarios. First, we notice that several interesting functions and statistics (e.g., the standard deviation function) can be represented by constant-degree polynomials. In such a case, our first construction perfectly fits the bill as it is efficient, simple to implement and produces constantsize tags (and, of course, it only requires the existence of a PRF to be proved secure). For the case of polynomials of large degree d (i.e., d polynomial in the security parameter), our scheme fits well in those applications where composition is not needed. Think for example of the application described at the beginning of this section. There, if the server just runs m←P(m 1 , . . . , m n ) on the client's data, using our second construction it can produce a succinct tag that authenticates m as P's output, and this tag is only one group element.</p><p>Finally, in applications where composition is needed but does not involve different parties, the notion of local composition achieved by our second scheme still allows to save in bandwidth and to (locally) compose tags of partial computations.</p><p>Overview of Our Techniques. The main idea behind our construction is a "re-interpretation" of some classical techniques for information-theoretic MACs. The authentication tag of a message m ∈ Z p with label τ is a degree-1 polynomial y(z) ∈ Z p [z] that evaluates to m on the point 0, and to r τ on a random point x (i.e., y(0) = m and y(x) = r τ ). Here r τ = F K (τ ) is a pseudorandom value, unique per each label, defined by the PRF, while x is the secret key. If we do not care about the homomorphic property and we assume that each r τ is truly random, then this is a secure information-theoretic MAC. Now, the basic observation that allows to show the homomorphic property is the following. Let f be an arithmetic circuit and assume to evaluate the circuit over the tags (i.e., over these polynomials y(z)) as follows: for every additive gate we compute the addition of the two input polynomials, and for every multiplicative gate we compute the multiplication of them (i.e., the convolution of their coefficients). Now, we observe that these operations are naturally homomorphic with respect to the evaluation of the polynomial in every point. In particular, if we have two tags y (1) and y (2) (i.e., we are given only the coefficients of these polynomials) such that y (1) (0) = m 1 and y (2) (0) = m 2 , then for y = y (1) + y (2) (resp. y = y (1)  * y (2) ) we clearly obtain y(0</p><formula xml:id="formula_0">) = m 1 + m 2 (resp. y(0) = m 1 • m 2 ).</formula><p>The same holds for its evaluation at the random point x, i.e., y(x) = r τ1 + r τ2 (resp. y(x) = r τ1 • r τ2 ). By extending this argument to the evaluation of the entire circuit f , this allows to verify a tag y for a labeled program P = (f, τ 1 , . . . , τ n ) and a message m, by simply checking that m = y(0) and f (r τ1 , . . . , r τn ) = y(x), where r τi = F K (τ i ).</p><p>A drawback of this construction is that the tag's size grows linearly with the degree of the evaluated circuit f . The reason is that the above homomorphic evaluation increases the degree of the "tag polynomial" y at every multiplication gate. This is why this MAC fails in achieving the succinctness property when the degree d becomes greater than the input size n of the circuit.</p><p>Our second construction overcomes this drawback as follows. First, the evaluation algorithm computes a tag y = (y 0 , . . . , y d ) as before, and then it "accumulates" these coefficients in a single group element <ref type="formula">0</ref>) , and thus one can easily see why correctness holds. The need to resort to the (D -1)-Diffie Hellman Inversion assumption<ref type="foot" target="#foot_1">2</ref> , comes from the fact that, in order to perform the evaluation procedure correctly, the values g x , g x 2 , . . . , g x D need to be published as part of the evaluation key ek. Once a tag of the Λ form is created, it can be composed with other tags of the same form only for additions but not for multiplications. To satisfy partial composition, the idea is that one can keep locally the large version of the tag consisting of the coefficients y 0 , . . . , y d , and always send to the verifier its compact version Λ = d i=1 (g x i ) yi . In the full version of this paper we also show an extension of this scheme that, by using bilinear pairings, allows to further compute an additional level of multiplications and unbounded additions on tags of the Λ form.</p><formula xml:id="formula_1">Λ = d i=1 (g x i ) yi . Verifi- cation will check that g f (rτ 1 ,...,rτ n ) = g m • Λ. If Λ is computed correctly, then Λ = g y(x)-y(</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Related Work</head><p>Homomorphic Message Authenticators and Signatures. Recently, many papers considered the problem of realizing homomorphic (mostly linear) authenticators either in the symmetric setting (MAC) or in the asymmetric one (signatures). This line of research has been initiated by the work of Johnson et al. <ref type="bibr" target="#b28">[27]</ref> and became very popular in recent years because of the important application to linear network coding. Efficient solutions for this latter application have been proposed both in the random oracle <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b23">22,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b14">14]</ref> and in the standard model <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b17">16,</ref><ref type="bibr" target="#b21">20,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6]</ref>. Linearly-homomorphic message authenticators have been considered also for proofs of retrievability for outsourced storage <ref type="bibr" target="#b33">[32]</ref>. Only two works, however, consider the problem of realizing solutions for more complex functionalities (i.e., beyond linear).</p><p>Boneh and Freeman defined the notion of (fully) homomorphic signatures and showed a realization for bounded (constant) degree polynomials, from ideal lattices <ref type="bibr" target="#b11">[11]</ref>. With respect to our work this solution has the obvious advantage of allowing for public verifiability. On the negative side it is not truly practical and the bound on the degree of the supported polynomials is more stringent than in our case (as they can support only polynomials of constant degree).</p><p>Closer to our setting is the recent work of Gennaro and Wichs <ref type="bibr" target="#b24">[23]</ref> where fully homomorphic MACs are introduced, formally defined and constructed. The solution given there supports a wider class of functionalities with respect to ours, and it allows to achieve succinct tags and composability at the same time. Their tags have size μ(λ) = poly(λ) where λ is the security parameter, and thus they are asymptotically succinct as long as the circuit's input size n is greater than μ(λ). Despite its nice properties, the proposed construction seems unfortunately far from being truly practical as it relies on fully homomorphic encryption. Moreover, it is proven secure only for a bounded and a-priori fixed number of verification queries 3 , meaning with this that the scheme becomes insecure if the verifier leaks information on whether it accepts/rejects tags. Succinct Non-interactive Arguments of Knowledge. The problem of realizing homomorphic signatures can be solved in theory using Succinct Noninteractive Arguments of Knowledge (SNARKs) <ref type="bibr" target="#b8">[8]</ref>. In a nutshell, given any NP statement a SNARK allows to construct a succinct argument that can be used to prove knowledge of the corresponding witness. The nice feature of SNARKs is that the size of the argument is independent of the size of both the statement and the witness. A drawback of SNARKs is that they are not very efficient (or at least not nearly as practical as we require) and require either the random oracle model <ref type="bibr" target="#b30">[29]</ref> or non-standard, non-falsifiable assumptions <ref type="bibr" target="#b26">[25]</ref>. Moreover, SNARKbased solutions seem to allow for only very limited composability <ref type="bibr" target="#b35">[34,</ref><ref type="bibr" target="#b9">9]</ref>.</p><p>Other Related Work. The notion of homomorphic authenticators is also (somewhat) related to the notion of verifiable computation <ref type="bibr" target="#b29">[28,</ref><ref type="bibr" target="#b30">29,</ref><ref type="bibr" target="#b27">26,</ref><ref type="bibr" target="#b22">21,</ref><ref type="bibr" target="#b18">17,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b32">31,</ref><ref type="bibr" target="#b20">19</ref>]. There, one wants to delegate a computationally heavy task to a remote server while keeping the ability to verify the result in a very efficient way. While the two primitives might seem quite different at first, one can reinterpret some of the results on verifiable computation in our setting. The resulting solutions however present several limitations that make them of limited practical interest compared to 3 More precisely, their basic construction cannot support verification queries at all. This can be extended to allow for some fixed a-priori number of queries q at the cost of increasing by O(q) the size of the tag.</p><p>homomorphic authenticators. We refer the reader to <ref type="bibr" target="#b24">[23]</ref> for a nice discussion about this. Homomorphic authenticators are also related to memory delegation <ref type="bibr" target="#b19">[18]</ref>. This primitive allows a client to outsource large amounts of data to a server so that he can later verify computations on the data. The advantage of this approach over ours is that it offers an efficient verification procedure, and it supports a dynamic memory in which the client can update the outsourced data. However, current (non-interactive) realizations of memory delegation, in the standard model, are rather inefficient and require the user to keep a state. Moreover, in known constructions, efficient verification comes at the price of an offline phase where the runtime of both the delegator and the server depends polynomially on the size of the memory.</p><p>Organization. The paper is organized as follows. In Section 2 we provide a background and relevant definitions of arithmetic circuits and homomorphic authenticators. Section 3 describes our first construction from PRFs while our second compact construction is given in Section 4. For lack of space, all proofs will appear in the full version of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background and Definitions</head><p>Arithmetic Circuits. Here we provide a very brief overview of arithmetic circuits. The interested reader is referred to <ref type="bibr" target="#b34">[33]</ref> for a more detailed treatment of the subject.</p><p>An arithmetic circuit over a field F and a set of variables X = {τ 1 . . . τ n }, is a directed acyclic graph with the following properties. Each node in the graph is called gate. Gates with in-degree 0 are called input gates (or input nodes) while gates with out-degree 0 are called output gates. Each input gate is labeled by either a variable or a constant. Variable input nodes are labeled with binary strings τ 1 , . . . , τ n , and can take arbitrary values in F. A constant input node instead is labeled with some constant c and it can take only some fixed value c ∈ F. Gates with in-degree and out-degree greater than 0 are called internal gates. Each internal gate is labeled with an arithmetic operation symbol. Gates labeled with × are called product gates, while gates labeled with + are called sum gates. In this paper, we consider circuits with a single output node and where the in-degree of each internal gate is 2. The size of the circuit is the number of its gates. The depth of the circuit is the length of the longest path from input to output.</p><p>Arithmetic circuits evaluate polynomials in the following way. Input gates compute the polynomial defined by their labels. Sum gates compute the polynomial obtained by the sum of the (two) polynomials on their incoming wires. Product gates compute the product of the two polynomials on their incoming wires. The output of the circuit is the value contained on the outgoing wire of the output gate. The degree of a gate is defined as the total degree of the polynomial computed by that gate. The degree of a circuit is defined as the maximal degree of the gates in the circuit.</p><p>We stress that arithmetic circuits should be seen as computing specific polynomials in F[X] rather than functions from F |X| to F. In other words, when studying arithmetic circuits one is interested in the formal computation of polynomials rather than the functions that these polynomials define <ref type="foot" target="#foot_2">4</ref> .</p><p>In this paper we restrict our interest to families of polynomials {f n } over F which have polynomially bounded degree, meaning with this that both the number of variables and the degree of f n are bounded by some polynomial p(n). The class VP (also known as AlgP /poly ) contains all such polynomials. More precisely it contains all polynomially bounded degree families of polynomials that are computable by arithmetic circuits of polynomial size and degree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Homomorphic Message Authenticators</head><p>Labeled Programs. First, we recall the notion of labeled programs introduced by Gennaro and Wichs in <ref type="bibr" target="#b24">[23]</ref>. A labeled program P consists of a tuple (f, τ 1 , . . . , τ n ) where f : F n → F is a circuit, and the binary strings τ 1 , . . . , τ n ∈ {0, 1} * are the labels of the input nodes of f . Given some labeled programs P 1 , . . . , P t and a function g : F t → F it is possible to define the composed program P * = g(P 1 , . . . , P t ) which consists in evaluating a circuit g on the outputs of P 1 , . . . , P t respectively. The labeled inputs of P * are all distinct labeled inputs of P 1 , . . . , P t , i.e., all inputs with the same label are put together in a single input of the new program. We denote with I τ = (g id , τ) the identity program with label τ where g id is the canonical identity function and τ ∈ {0, 1} * is some input label. Finally, we notice that any program P = (f, τ 1 , . . . , τ n ) can be expressed as the composition of n identity programs P = f (I τ1 , . . . , I τn ).</p><p>While Gennaro and Wichs <ref type="bibr" target="#b24">[23]</ref> defined labeled programs for Boolean circuits (i.e., f : {0, 1} n → {0, 1}), here we consider its extension to the case of arithmetic circuits f : F n → F where F is some finite field, e.g., Z p for a prime p.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Homomorphic Authenticator Scheme. A homomorphic message authenticator scheme HomMAC is a 4-tuple of algorithms working as follows:</head><p>KeyGen(1 λ ): on input the security parameter λ, the key generation algorithm outputs a secret key sk and a public evaluation key ek. Auth(sk, τ, m): given the secret key sk, an input-label τ and a message m ∈ M, it outputs a tag σ. Ver(sk, m, P, σ): given the secret key sk, a message m ∈ M, a program P = (f, τ 1 , . . . , τ n ) and a tag σ, the verification algorithm outputs 0 (reject) or 1 (accept). Eval(ek, f, σ): on input the evaluation key ek, a circuit f : M n → M and a vector of tags σ = (σ 1 , . . . , σ n ), the evaluation algorithm outputs a new tag σ. </p><formula xml:id="formula_2">, σ) = 1] = 1.</formula><p>Evaluation Correctness. Informally, this property states that if the evaluation algorithm is given a vector of tags σ = (σ 1 , . . . , σ n ) such that each σ i authenticates some message m i as the output of a labeled program P i , then the tag σ produced by Eval must authenticate f (m 1 , . . . , m n ) as the output of the composed program f (P 1 , . . . , P n ).</p><p>More formally, let us fix a pair of keys (sk, ek) $ ← KeyGen(1 λ ), a function g : M t → M and any set of message/program/tag triples {(m i , P i , σ i )} t i=1 such that Ver(sk, m i , P i , σ i ) = 1. If m * = g(m 1 , . . . , m t ), P * = g(P 1 , . . . , P t ), and σ * = Eval(ek, g, (σ 1 , . . . , σ t )), then it must hold: Ver(sk, m * , P * , σ * ) = 1.</p><p>Succinctness. The size of a tag is bounded by some fixed polynomial in the security parameter, that is independent of the number of inputs taken by the evaluated circuit.</p><p>Security. Let HomMAC be a homomorphic MAC scheme as defined above. Consider the following experiment HomUF-CMA A,HomMAC (λ) between a challenger and an adversary A against HomMAC:</p><p>Setup. The challenger generates (sk, ek) $ ← KeyGen(1 λ ) and gives ek to A. It also initializes a list T = ∅. Authentication queries. The adversary can adaptively ask for tags on labelmessage pairs of its choice. Given a query (τ, m), if there is some (τ, •) ∈ T (i.e., the label was already queried), then the challenger ignores the query. Otherwise, it computes σ $ ← Auth(sk, τ, m), returns σ to A and updates the list T = T ∪ (τ, m). If (τ, m) ∈ T (i.e., the query was previously made), then the challenger replies with the same tag generated before. Verification queries. The adversary is also given access to a verification oracle. Namely, A can submit a query (m, P, σ) and the challenger replies with the output of Ver(sk, m, P, σ). Forgery. At some point the adversary is supposed to output a forgery (m * , P * = (f * , τ * 1 , . . . , τ * n ), σ * ). Notice that such tuple can be returned by A also as a verification query (m * , P * , σ * ).</p><p>Before describing the outcome of this experiment, we define the notion of well defined program with respect to a list T . Informally, there are two ways for a program P * = (f * , τ * 1 , . . . , τ * n ) to be well defined. Either all the τ * i s are in T or, if there are labels τ * i not in T , then the inputs associated with such labels are somewhat "ignored" by f * when computing the output. In other words input corresponding to labels not in T do not affect the behavior of f * in any way.</p><p>More formally, we say that a labeled program P * = (f * , τ * 1 , . . . , τ * n ) is well defined on T if either one of the following two cases occurs:</p><p>1. there exists i ∈ {1, . . . , n} such that (τ * i , •) / ∈ T (i.e., A never asked an authentication query with label τ * i ), and f * ({m j } (τj,mj)∈T ∪ { mj } (τj,•) / ∈T ) outputs the same value for all possible choices of mj ∈ M; 2. T contains tuples (τ * 1 , m 1 ), . . . , (τ * n , m n ), for some messages m 1 , . . . , m n . The experiment HomUF-CMA outputs 1 if and only if Ver(sk, m * , P * , σ * ) = 1 and one of the following conditions holds:</p><p>-Type 1 Forgery: P * is not well-defined on T . -Type 2 Forgery: P * is well defined on T and m * = f * ({m j } (τj,mj)∈T ), i.e., m * is not the correct output of the labeled program P * when executed on previously authenticated messages (m 1 , . . . , m n ).</p><p>We say that a homomorphic MAC scheme HomMAC is secure if for every PPT adversary A we have that Pr[HomUF-CMA A,HomMAC (λ) = 1] is negligible.</p><p>Remark 1 (Comments on our definition). First, we observe that our definition explicitly disallow the possibility of re-using a label to authenticate more than one value. Essentially, this is a way to uniquely keep track of the authenticated inputs. We notice that such restriction is implicitly present in the Gennaro-Wichs construction as well as in all previous works on homomorphic signatures. Second, the notion of well defined programs aims at capturing, in a formal way, which tuples generated by the adversary should be considered as forgeries. The catch here is that, since we are dealing with a homomorphic primitive, we should be able to differentiate MACs produced by Eval from MACs generated in some other, possibly malicious, way. Notice, however, that even maliciously generated MACs should not necessarily be considered as forgeries. This is because, in our setting, the adversary can trivially modify a circuit C she is allowed to evaluate by adding dummy gates and inputs that are simply ignored in the evaluation of the modified circuit (i.e., the new circuit is semantically equivalent to C). This last case does not constitute an infringement of our security requirements. Our notion of well defined program P captures exactly this: either P is run on legal (i.e. in T ) inputs only, or, if this is not the case, those inputs not in T do not affect the computation in any way.</p><p>Finally, we observe that for arbitrary computations checking whether a program is well defined may not be efficiently computable. In particular, the difficult task is to check the first condition, i.e., whether a program always outputs the same value for all possible choices of the inputs that are not in T . However, for the case of arithmetic circuits in (exponentially) large fields and of polynomial degree this check can be efficiently performed as follows: by fixing all inputs in T one writes the computation as a new multivariate polynomial whose variables are only the inputs not in T . Then, one checks whether this polynomial is a constant function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Remark 2 (Relations with previous definitions).</head><p>Our definition is very similar to that proposed by Gennaro and Wichs in <ref type="bibr" target="#b24">[23]</ref> except for two modifications. First, we explicitly allow the adversary to query the verification oracle. Second, we adopt a definition of forgery slightly weaker than that in <ref type="bibr" target="#b24">[23]</ref>. More precisely, Gennaro and Wichs define Type 1 forgeries as ones where at least one new label is present. Type 2 forgeries, on the other hand, contain only labels that have been already queried, but m * is not the correct output of the program when executed on the previously queried inputs.</p><p>Notice that our notion becomes equivalent to that given in <ref type="bibr" target="#b24">[23]</ref> by simply changing the definition of "well defined program" so that</p><formula xml:id="formula_3">P * = (f * , τ * 1 , . . . , τ * n ) is said well defined on T if (τ i , m i ) ∈ T ∀i = 1, . . . n.</formula><p>The difference between the two definitions is that, as we explained above, we do not consider forgeries all those tuples where "fresh" labels (i.e. labels not in T ) do not contribute to the output of the program.</p><p>Even though our security definition is weaker than the one in <ref type="bibr" target="#b24">[23]</ref>, we stress that it is perfectly meaningful for the notion of homomorphic MAC. Indeed, we are still excluding from forgeries all those MACs that can be trivially computed by the adversary from what it queried during the game.</p><p>On a technical level, our definition of forgery is inspired by the security definition recently proposed by Freeman for homomorphic signatures <ref type="bibr" target="#b21">[20]</ref>, except that in our case we do not consider the notion of data set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Our Homomorphic MAC from OWFs</head><p>In this section we propose our first construction of homomorphic MACs whose security relies only on a pseudo-random function (and thus on one-way functions). The scheme is simple and efficient and allows to homomorphically evaluate arithmetic circuits f : Z n p → Z p for a prime p of roughly λ bits, where λ is the security parameter.</p><p>Our Scheme. In our construction we restrict to circuits whose additive gates do not get inputs labeled by constants. This can be done without loss of generality as, when needed, one can use an equivalent circuit in which there is a special variable/label for the value 1, and can publish the MAC of 1. The description of our scheme follows.</p><p>KeyGen(1 λ ). Let p be a prime of roughly λ bits. Choose a seed K of a pseudorandom function F K : {0, 1} * → Z p and a random value x $ ← Z p . Output sk = (K, x), ek = p and let the message space M be Z p . Auth(sk, τ, m). To authenticate a message m ∈ Z p with label τ ∈ {0, 1} λ , compute r τ = F K (τ ), set y 0 = m, y 1 = (r τm)/x mod p and output σ = (y 0 , y 1 ). Basically, y 0 , y 1 are the coefficients of a degree-1 polynomial y(z) with the special property that it evaluates to m on the point 0 (y(0) = m), and it evaluates to r τ on a hidden random point x (y(x) = r τ ).</p><p>In our construction we will interpret tags σ as polynomials y ∈ Z p [z] of degree d ≥ 1 in some (unknown) variable z, i.e., y(z) = i y i z i . Eval(ek, f, σ). The homomorphic evaluation algorithm takes as input the evaluation key ek = p, an arithmetic circuit f : Z n p → Z p , and a vector σ of tags (σ 1 , . . . , σ n ).</p><p>Intuitively, Eval consists in evaluating the circuit f on the tags σ 1 , . . . , σ n instead of evaluating it on messages. However, since the values σ i 's are not messages in Z p , but rather are polynomials y (i) ∈ Z p [z], we need to specify how this evaluation is carried through. Eval proceeds gate-by-gate as follows. At each gate g, given two tags σ 1 , σ 2 (or a tag σ 1 and a constant c ∈ Z p ), it runs the algorithm σ←GateEval(ek, g, σ 1 , σ 2 ) described below that returns a new tag σ, which is in turn passed on as input to the next gate in the circuit. When the computation reaches the last gate of the circuit f , Eval outputs the tag vector σ obtained by running GateEval on such last gate. To complete the description of Eval we describe the subroutine GateEval.</p><p>-GateEval(ek, g, σ 1 , σ 2 ). Let σ i = y (i) = (y</p><formula xml:id="formula_4">(i) 0 , . . . , y (i)</formula><p>di ) for i = 1, 2 and d i ≥ 1 (see below for the special case when one of the two inputs is a constant c ∈ Z p ). If g = +, then:</p><formula xml:id="formula_5">• let d = max(d 1 , d 2 ).</formula><p>Here we assume without loss of generality that d 1 ≥ d 2 (i.e., d = d 1 ). • Compute the coefficients (y 0 , . . . , y d ) of the polynomial y(z) = y (1) (z) + y (2) (z). This can be efficiently done by adding the two vectors of coefficients, y = y (1) + y (2) (y (2) is eventually padded with zeroes in positions d 1 ...d 2 ). If g = ×, then:</p><formula xml:id="formula_6">• let d = d 1 + d 2 .</formula><p>• Compute the coefficients (y 0 , . . . , y d ) of the polynomial y(z) = y (1) (z) * y (2) (z) using the convolution operator * , i.e., ∀k = 0, . . . , d, define y k = k i=0 y</p><p>(1)</p><formula xml:id="formula_7">i • y (2)</formula><p>k-i . If g = × and one of the two inputs, say σ 2 , is a constant c ∈ Z p , then:</p><p>• let d = d 1 .</p><p>• Compute the coefficients (y 0 , . . . , y d ) of the polynomial y(z) = c • y (1) (z). Return σ = (y 0 , . . . , y d ). As one can notice, the size of a tag grows only after the evaluation of a multiplication gate (where both inputs are not constants). It is not hard to see that after the homomorphic evaluation of a circuit f , it holds |σ| = d + 1, where d is the degree of f . Ver(sk, m, P, σ). Let P = (f, τ 1 , . . . , τ n ) be a labeled program, m ∈ Z p and σ = (y 0 , . . . , y d ) be a tag for some d ≥ 1. Verification proceeds as follows:</p><p>-If y 0 = m, then output 0 (reject). Otherwise continue as follows.</p><p>-For every input wire of f with label τ compute r τ = F K (τ ).</p><p>-Next, evaluate the circuit on r τ1 , . . . , r τn , i.e., compute ρ←f (r τ1 , . . . , r τn ), and use x to check whether the following equation holds:</p><formula xml:id="formula_8">ρ = d k=0 y k x k (1)</formula><p>If this is true, then output 1. Otherwise output 0.</p><p>Observe that the above applies also to identity programs I τ , in which case the algorithm just checks that r τ = y 0 + y 1 • x and y 0 = m.</p><p>Efficiency. Our scheme is extremely efficient in generating a tag using the Auth algorithm: just one PRF evaluation (e.g., one AES evaluation, in practice).</p><p>If we analyze the Eval algorithm, its complexity is dominated by the cost of evaluating the circuit f with an additional overhead due to the modified gate evaluation and to that the tag's size grows with the degree of the circuit. If the circuit has degree d, in the worst case, this overhead is going to be O(d) for addition gates, and O(d log d) for multiplication gates <ref type="foot" target="#foot_3">5</ref> .</p><p>The cost of verification is basically the cost of computing ρ = f (r τ1 , . . . , r τn ), that is O(|f |), plus the cost of computing d i=0 y i x i , that is O(d). Correctness. Very roughly, correctness follows from the special property of the polynomials y generated by Auth, i.e., that y(0) = m and y(x) = r τ . In particular, this property is preserved when evaluating the circuit f over tags y (1) , . . . , y (n) . We give a formal proof of correctness in the full version of this paper.</p><p>Security. The security of our scheme is established by the following theorem (again the proof is deferred to the full version of this paper). Theorem 1. If F is a PRF, then the homomorphic MAC scheme described in Section 3 is secure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">A Compact Homomorphic MAC for Circuits of Bounded Polynomial Degree</head><p>As we mentioned earlier, the homomorphic MAC of Section 3 has the drawback that the tags' size grows linearly with the degree of the evaluated circuit. While this may be acceptable in some cases, e.g., circuits evaluating constant-degree polynomials, it may become impractical in other situations, e.g., when the degree is greater than the input size of the circuit. In this section, we propose a second scheme that solves this issue and enjoys tags of constant size. The scheme keeps almost the same efficiency of the previous one, even though constant-size tags come at the price of a couple of restrictions. First, we have to fix an a-priori bound D on the degree of the circuits that can be evaluated. Second, the homomorphic evaluation has to be done in a "single shot", that is the authentication tags obtained from the Eval algorithm cannot be used again to be composed with other tags. Nevertheless, we show that the scheme achieves an interesting property that we call local composition. The idea is that one can keep locally a non-succinct version of the tag that allows for arbitrary composition. Later, when it comes to send an authentication tag to the verifier, one can securely compress such large tag in a very compact one of constant-size.</p><p>For security, in addition to a PRF we need to rely on a computational assumption that says that one cannot compute g given values g x , . . . , g x D . This problem is basically a re-writing of a problem already considered in the past: the -Diffie-Hellman Inversion. We recall its definition below. Definition 1 ( -DHI <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b31">30]</ref>). Let λ ∈ N be the security parameter, and G be a group of order p &gt; 2 λ . For a generator g ∈ G and a randomly chosen x $ ← Z p we define the advantage of an adversary A in solving the -DHI problem as Adv DHI A (λ) = Pr[A(g, g x , . . . , g x ) = g 1/x ] and we say that the -DHI assumption holds in G if for every PPT A and for = poly(λ), the advantage Adv DHI A (λ) is at most negligible in λ.</p><p>Our Construction. The description of our scheme follows.</p><p>KeyGen(1 λ , D). Let λ be the security parameter and D = poly(λ) be an upper bound so that the scheme can support the homomorphic evaluation of circuits of degree at most D. The key generation works as follows.</p><p>Generate a group G of order p where p is a prime of roughly λ bits, and choose a random generator g $ ← G. Choose a seed K of a pseudorandom function F K : {0, 1} * → Z p and a random value x $ ← Z p . For i = 1 to D compute h i = g x i . Output sk = (K, g, x), ek = (h 1 , . . . , h D ) and let the message space M be Z p . Auth(sk, τ, m). The tagging algorithm is the same as the one of the construction in Section 3. To authenticate a message m ∈ Z p with label τ ∈ {0, 1} λ , compute r τ = F K (τ ), set y 0 = m , y 1 = (r τm)/x mod p, and output σ = (y 0 , y 1 ). Eval(ek, f, σ). The homomorphic evaluation algorithm takes as input the evaluation key ek, an arithmetic circuit f : Z n p → Z p , and a vector σ of tags (σ 1 , . . . , σ n ) so that σ i ∈ Z 2 p (i.e., it is a tag for a degree-1 polynomial). First, proceed exactly as in the construction of Section 3 to compute the coefficients (y 0 , . . . , y d ). If d = 1 (i.e., the circuit f computes a degree-1 polynomial), then return σ = (y 0 , y 1 ). Otherwise, compute Λ = d i=1 h yi i and return σ = Λ. Ver(sk, m, P, σ). Let P = (f, τ 1 , . . . , τ n ) be a labeled program, m ∈ Z p and σ be a tag of either the form (y 0 , y 1 ) ∈ Z 2 p or Λ ∈ G. First, proceed as in the construction of Section 3 to compute ρ = f (r τ1 , . . . , r τn ). If the program P computes a polynomial of degree 1, then proceed exactly as in the construction of Section 3 and check that ρ = y 0 + y 1 • x and y 0 = m. Otherwise, use g to check whether the following equation holds:</p><formula xml:id="formula_9">g ρ = g m • Λ (2)</formula><p>If the checks are satisfied, then output 1. Otherwise output 0.</p><p>Correctness. The correctness easily follows from the correctness of the scheme described in Section 3 and by observing that equation ( <ref type="formula">2</ref>) is essentially equivalent to checking that ρ = d i=0 y i x i , which is the verification equation (1) in the scheme of Section 3.</p><p>Local Composition. The above scheme satisfies an interesting property that we call local composition. The idea is that one can keep locally the large version of the tag, i.e., the polynomial y with its d+1 coefficients y 0 , . . . , y d , but still send its compact version Λ = d i=1 (g x i ) yi to the verifier. Keeping y allows for arbitrary composition as in the scheme of Section 3. In applications where composition does not involve many parties, this property allows to achieve succinct tags and local composition of partial computations at the same time.</p><p>Extension. In the full version of this paper we show an extension of this scheme that, by using pairings, allows to further compute an additional level of multiplications and unbounded additions on tags of the Λ form.</p><p>Security. Security follows from the following theorem (whose proof is postponed to the full version of this paper). Theorem 2. If F is a PRF and the (D -1)-Diffie Hellman Inversion Assumption holds in G, then the homomorphic MAC scheme described in Section 4 is secure.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Authentication Correctness. Intuitively, a homomorphic MAC satisfies this property if any tag σ generated by the algorithm Auth(sk, τ, m) authenticates with respect to the identity program I τ . Formally, we require that for any message m ∈ M, all keys (sk, ek) Auth(sk, τ, m), it holds: Pr[Ver(sk, m, I τ</figDesc><table /><note><p><p>$</p>← KeyGen(1 λ ), any label τ ∈ {0, 1} * , and any tag σ $ ←</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Informally, the degree of an arithmetic circuit is related to the degree of the polynomial computed by the circuit (see next section for more details).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Very briefly, this assumption states that it is computationally infeasible to compute g 1/x , given g, g x , g x 2 , . . . , g x D-1</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>While, in general, every polynomial defines a unique function the converse is not true as a function may be expressed as a polynomial in several ways.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_3"><p>This bound follows from that one can use optimized algorithms based on FFT to compute the convolution.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. The authors would like to thank Valerio Pastro and Daniel Wichs for helpful discussions on this work.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">MACs: MAC-based integrity for network coding</title>
		<author>
			<persName><forename type="first">S</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACNS 2009</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Abdalla</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Pointcheval</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P.-A</forename><surname>Fouque</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Vergnaud</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5536</biblScope>
			<biblScope unit="page" from="292" to="305" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Computing on authenticated data</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Ahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Camenisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hohenberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shelat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2012</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7194</biblScope>
			<biblScope unit="page" from="1" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">From secrecy to soundness: Efficient verification via secure computation</title>
		<author>
			<persName><forename type="first">B</forename><surname>Applebaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP 2010, Part I</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Abramsky</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Gavoille</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Kirchner</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Meyer Auf Der Heide</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Spirakis</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6198</biblScope>
			<biblScope unit="page" from="152" to="163" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Homomorphic network coding signatures in the standard model</title>
		<author>
			<persName><forename type="first">N</forename><surname>Attrapadung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Libert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC 2011</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Catalano</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><surname>Fazio</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Nicolosi</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6571</biblScope>
			<biblScope unit="page" from="17" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Computing on authenticated data: New privacy definitions and constructions</title>
		<author>
			<persName><forename type="first">N</forename><surname>Attrapadung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Libert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Peters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2012</title>
		<editor>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Sako</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7658</biblScope>
			<biblScope unit="page" from="367" to="385" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Efficient completely context-hiding quotable and linearly homomorphic signatures</title>
		<author>
			<persName><forename type="first">N</forename><surname>Attrapadung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Libert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Peters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC 2013</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Kurosawa</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Hanaoka</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">7778</biblScope>
			<biblScope unit="page" from="386" to="404" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Verifiable delegation of computation over large datasets</title>
		<author>
			<persName><forename type="first">S</forename><surname>Benabbas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Vahlis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2011</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">6841</biblScope>
			<biblScope unit="page" from="111" to="131" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bitansky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ITCS 2012: Proceedings of the 3rd Symposium on Innovations in Theoretical Computer Science</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Recursive composition and bootstrapping for snarks and proof-carrying data</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bitansky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2012">2012/095 (2012</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Signing a linear subspace: Signature schemes for network coding</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Freeman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC 2009</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Jarecki</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Tsudik</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5443</biblScope>
			<biblScope unit="page" from="68" to="87" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Homomorphic signatures for polynomial functions</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Freeman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2011</title>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Paterson</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6632</biblScope>
			<biblScope unit="page" from="149" to="168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Linearly homomorphic signatures over binary fields and new tools for lattice-based signatures</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Freeman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC 2011</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Catalano</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><surname>Fazio</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Nicolosi</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6571</biblScope>
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The uber-assumption family: A unified complexity framework for bilinear groups</title>
		<author>
			<persName><forename type="first">X</forename><surname>Boyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Pairing 2008</title>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Galbraith</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Paterson</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5209</biblScope>
			<biblScope unit="page" from="39" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Algebraic (trapdoor) one way functions and their applications</title>
		<author>
			<persName><forename type="first">D</forename><surname>Catalano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fiore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Vamvourellis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2013</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">7785</biblScope>
			<biblScope unit="page" from="680" to="699" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Adaptive pseudo-free groups and applications</title>
		<author>
			<persName><forename type="first">D</forename><surname>Catalano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fiore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Warinschi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2011</title>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Paterson</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">6632</biblScope>
			<biblScope unit="page" from="207" to="223" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Efficient network coding signatures in the standard model</title>
		<author>
			<persName><forename type="first">D</forename><surname>Catalano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fiore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Warinschi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC 2012</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Fischlin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Buchmann</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Manulis</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7293</biblScope>
			<biblScope unit="page" from="680" to="696" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Improved delegation of computation using fully homomorphic encryption</title>
		<author>
			<persName><forename type="first">K.-M</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Kalai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vadhan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2010</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Rabin</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6223</biblScope>
			<biblScope unit="page" from="483" to="501" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Memory delegation</title>
		<author>
			<persName><forename type="first">K.-M</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">T</forename><surname>Kalai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F.-H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Raz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2011</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6841</biblScope>
			<biblScope unit="page" from="151" to="168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Publicly verifiable delegation of large polynomials and matrix computations, with applications</title>
		<author>
			<persName><forename type="first">D</forename><surname>Fiore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2012/281" />
	</analytic>
	<monogr>
		<title level="m">2012 ACM Conference on Computer and Communication Security</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2012-10">October 2012</date>
		</imprint>
	</monogr>
	<note>Full version avaiable at</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Improved security for linearly homomorphic signatures: A generic framework</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Freeman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC 2012</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Fischlin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Buchmann</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Manulis</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7293</biblScope>
			<biblScope unit="page" from="697" to="714" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Non-interactive verifiable computing: Outsourcing computation to untrusted workers</title>
		<author>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2010</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Rabin</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6223</biblScope>
			<biblScope unit="page" from="465" to="482" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Secure network coding over the integers</title>
		<author>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC 2010</title>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">Q</forename><surname>Nguyen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Pointcheval</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6056</biblScope>
			<biblScope unit="page" from="142" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Fully homomorphic message authenticators</title>
		<author>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wichs</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2012">2012/290 (2012</date>
		</imprint>
	</monogr>
	<note>Report</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Fully homomorphic encryption using ideal lattices</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">41st ACM STOC</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</editor>
		<meeting><address><addrLine>Bethesda, Maryland, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2009">May 31-June2. 2009</date>
			<biblScope unit="page" from="169" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Separating succinct non-interactive arguments from all falsifiable assumptions</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wichs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">43rd ACM STOC</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Fortnow</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Vadhan</surname></persName>
		</editor>
		<meeting><address><addrLine>San Jose, California, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2011-08">June 6-8. 2011</date>
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Delegating computation: interactive proofs for muggles</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">T</forename><surname>Kalai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">N</forename><surname>Rothblum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">40th ACM STOC</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Ladner</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Dwork</surname></persName>
		</editor>
		<meeting><address><addrLine>Victoria, British Columbia, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2008">May 17-20. 2008</date>
			<biblScope unit="page" from="113" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Homomorphic signature schemes</title>
		<author>
			<persName><forename type="first">R</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Molnar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CT-RSA 2002</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer, Heidelberg</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2271</biblScope>
			<biblScope unit="page" from="244" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A note on efficient zero-knowledge proofs and arguments</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">24th ACM STOC</title>
		<meeting><address><addrLine>Victoria, British Columbia, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1992-06">May 4-6. 1992</date>
			<biblScope unit="page" from="723" to="732" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Cs proofs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th FOCS</title>
		<meeting><address><addrLine>Santa Fe, New Mexico</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994">November 20-22. 1994</date>
			<biblScope unit="page">35</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A new traitor tracing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mitsunari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sakai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kasahara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEICE Transactions on Fundamentals E</title>
		<imprint>
			<biblScope unit="volume">85</biblScope>
			<biblScope unit="page" from="481" to="484" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">How to delegate and verify in public: Verifiable computation from attribute-based encryption</title>
		<author>
			<persName><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Raykova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2012</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7194</biblScope>
			<biblScope unit="page" from="422" to="439" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Compact proofs of retrievability</title>
		<author>
			<persName><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2008</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Pieprzyk</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5350</biblScope>
			<biblScope unit="page" from="90" to="107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Arithmetic circuits: A survey of recent results and open questions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Shpilka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yehudayoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Foundations and Trends in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="207" to="388" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Incrementally verifiable computation or proofs of knowledge imply time/Space efficiency</title>
		<author>
			<persName><forename type="first">P</forename><surname>Valiant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2008</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4948</biblScope>
			<biblScope unit="page" from="1" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
