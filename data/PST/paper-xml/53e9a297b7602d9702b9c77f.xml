<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Automated analysis of security-design models</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2008-05-15">15 May 2008</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">David</forename><surname>Basin</surname></persName>
							<email>basin@inf.ethz.ch</email>
							<affiliation key="aff0">
								<orgName type="laboratory">Information Security Group</orgName>
								<orgName type="institution">ETH Zurich</orgName>
								<address>
									<settlement>Zürich</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Manuel</forename><surname>Clavel</surname></persName>
							<email>clavel@sip.ucm.es</email>
							<affiliation key="aff1">
								<orgName type="institution">IMDEA Software Institute</orgName>
								<address>
									<settlement>Madrid</settlement>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">Universidad Complutense de Madrid</orgName>
								<address>
									<settlement>Madrid</settlement>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jürgen</forename><surname>Doser</surname></persName>
							<email>doserj@inf.ethz.ch</email>
							<affiliation key="aff0">
								<orgName type="laboratory">Information Security Group</orgName>
								<orgName type="institution">ETH Zurich</orgName>
								<address>
									<settlement>Zürich</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Marina</forename><surname>Egea</surname></persName>
							<email>marina_egea@fdi.ucm.es</email>
							<affiliation key="aff2">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">Universidad Complutense de Madrid</orgName>
								<address>
									<settlement>Madrid</settlement>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Automated analysis of security-design models</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2008-05-15">15 May 2008</date>
						</imprint>
					</monogr>
					<idno type="MD5">F9E21B2534D9CCD85252D04B33FF0C7F</idno>
					<idno type="DOI">10.1016/j.infsof.2008.05.011</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:41+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>UML OCL SecureUML Security policies Formal analysis Metamodels</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We have previously proposed SecureUML, an expressive UML-based language for constructing securitydesign models, which are models that combine design specifications for distributed systems with specifications of their security policies. Here, we show how to automate the analysis of such models in a semantically precise and meaningful way. In our approach, models are formalized together with scenarios that represent possible run-time instances. Queries about properties of the security policy modeled are expressed as formulas in UML's Object Constraint Language. The policy may include both declarative aspects, i.e., static access-control information such as the assignment of users and permissions to roles, and programmatic aspects, which depend on dynamic information, namely the satisfaction of authorization constraints in a given scenario. We show how such properties can be evaluated, completely automatically, in the context of the metamodel of the security-design language. We demonstrate, through examples, that this approach can be used to formalize and check non-trivial security properties. The approach has been implemented in the SecureMOVA tool and all of the examples presented have been checked using this tool.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Model driven development <ref type="bibr" target="#b10">[11]</ref> holds the promise of reducing system development time and improving the quality of the resulting products. Recent investigations <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b7">[8]</ref><ref type="bibr" target="#b8">[9]</ref><ref type="bibr" target="#b9">[10]</ref> have shown that security policies can be integrated into system design models and that the resulting security-design models can be used as a basis for generating systems along with their security infrastructures. Moreover, when the models have a formal semantics, they can be reasoned about: one can query properties of models and understand potentially subtle consequences of the policies they define.</p><p>In previous work <ref type="bibr" target="#b3">[4]</ref>, we presented a security modeling language, called SecureUML, closely related to Role Based Access Control (RBAC). We showed how to combine this language (both syntactically and semantically) with different design languages, thereby creating languages for formalizing security-design models that specify system designs together with their security requirements. Our focus in <ref type="bibr" target="#b3">[4]</ref> was on the language definitions and generating access-control infrastructure from security-design models. Although we gave SecureUML a formal semantics, we did not investigate methods for formalizing and mechanically analyzing the security properties of security-design models. This is our focus in the present paper.</p><p>Security-design models are formal objects with both a concrete syntax (or notation) and an abstract syntax. The modeling language for security-design models is described by a metamodel that formalizes the structure of well-formed models as well as scenarios, representing possible run-time instances, i.e., concrete system states. We show that, in this setting, security properties of security-design models can be expressed as formulas in OCL <ref type="bibr" target="#b11">[12]</ref>, the Object Constraint Language of UML, in the context of the metamodel combining SecureUML with a design language.</p><p>Our use of OCL results in an expressive language for formalizing queries, which utilizes the entire vocabulary present in this metamodel. We can formalize queries about the relationships between users, roles, permissions, actions, and even system states. An example of a typical query about a security policy is ''are there two roles such that one includes the set of actions of the others, but the roles are not related in the role hierarchy?" Another example, but this time involving system state, is ''which roles can be assigned to a user so as to allow her to perform an action on a concrete resource in the context of a given scenario?" As we will see, we answer such queries by evaluating the corresponding OCL expression on the instances of the metamodel that represent the security-design models (or scenarios) under consideration.</p><p>The idea of formulating OCL queries on access control policies is not new. Our work is inspired by <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b13">14]</ref>, who first explored the use of OCL for querying RBAC policies, and we make comparisons in 0950-5849/$ -see front matter Ó 2008 Elsevier B.V. All rights reserved. doi:10.1016/j.infsof.2008.05.011 Section 8. Moreover, OCL is the natural choice for querying UML models. It is part of the UML standard and expressions written in OCL can be used to constrain and query UML models. Given this previous work, we see our contributions as follows.</p><p>First, we clarify the metatheory required to make query evaluation formally well defined. This requires, in particular, precise definitions of both the metamodel of the modeling language and the mapping from models and scenarios to the corresponding instances of this metamodel. As we will see, being explicit about the metamodels and mappings used requires considerable attention to detail. But the payoff is substantial: models and scenarios can then be automatically analyzed in a semantically meaningful way. Second, we show the feasibility of this approach by applying it to a non-trivial example: a security-design modeling language from <ref type="bibr" target="#b3">[4]</ref>, which combines SecureUML with a component modeling language named ComponentUML. Third, we demonstrate that OCL expressions can be used to formalize and check non-trivial security properties of security-design models. We provide a number of examples that illustrate the expressiveness of this approach for reasoning about properties depending on both the modeled access control policy as well as a snapshot of the dynamic system state. Finally, we provide a tool, SecureMOVA, that implements our approach. All of the examples presented in this paper have been checked using this tool.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.">Outline</head><p>In Section 2, we describe the methodology underlying our approach. Afterwards, in Sections 3 and 4, we describe the different modeling languages employed and their semantics. In Section 5, we explain how scenarios are modeled and, in Section 6, we give examples that illustrate how one can formalize and analyze a wide spectrum of authorization queries using OCL. In Section 7, we present SecureMOVA, a security-design modeling tool whose implementation is directly based on our metamodel-based approach for analyzing security-design models. We conclude in Section 8 with a discussion of related and future work.</p><p>A preliminary version of this paper appeared in <ref type="bibr" target="#b1">[2]</ref>. The results reported on there were limited to security-design models without scenarios and based on a more rudimentary version of the SecureMOVA tool.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">General approach</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Background on (meta)models</head><p>A modeling language provides a vocabulary (concepts and relations) for building models, as well as a notation to graphically depict them as diagrams. Often, the modeling language also provides a vocabulary and notation for describing model instances, also called scenarios. In the case of UML, for example, object diagrams represent instances of class models.</p><p>Diagrams that depict models (or model instances) must conform to the metamodel of the modeling language. A metamodel is a diagram whose elements formalize the concepts and relations provided by the modeling language and whose invariants, usually written in OCL, specify additional well-formedness constraints on models and model instances.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Problem statement: rigorously analyzing security models</head><p>Some modeling languages explain the meaning of the diagrams using natural language. In this situation, analyzing the models (or the model instances) depicted by the diagrams can only be done informally and no rigorous tool support can be expected. Other modeling languages explain the meaning of the diagrams using a formal semantics: that is, they define an interpretation function ½Á that associates mathematical structures ½M to well-formed diagrams M.</p><p>In general, given a modeling language with a formal semantics, one can reason about models by reasoning about their semantics. In the case of a security modeling language M, a security model (or a security model instance) M has a property P (expressed as a formula in some logical language) if and only if ½M P. While this approach is standard, it either requires deductive machinery for reasoning about the semantics of models (i.e., a semantic embedding <ref type="bibr" target="#b4">[5]</ref> and deduction within the relevant semantic domains, which typically cannot be done automatically) or an appropriate programming logic for reasoning at the level of the models. These are strong requirements and a hurdle for many practical applications. Hence, the question we address is whether there are other ways of formally analyzing security policies modeled by M (or implemented in M, if M is a security model instance), but in a more familiar setting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Approach taken</head><p>Our approach for analyzing properties of security-design models and their instances reduces deduction to evaluation. In a nutshell, we express the desired properties as OCL queries and evaluate these queries on the models or model instances under consideration. <ref type="foot" target="#foot_0">2</ref> To give a more detailed description of our approach, we first recall the elements involved in using OCL for analyzing model properties. A brief review of OCL itself is provided in Appendix A.</p><p>Consider the UML four-layer metamodel hierarchy represented by the following diagram.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Class</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Property</head><p>Class Instance Specification Person name : String</p><formula xml:id="formula_0">Mike : Person name = 'Mike' Mike +ownedAttribute «snapshot» «instanceOf» «instanceOf» «instanceOf» «instanceOf» «instanceOf» «instanceOf» «instanceOf» M3 (MOF) M2 (UML)</formula><p>M1 (User-model)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M0 (Run-time instances)</head><p>As a query language, OCL can be used to analyze an instance of a model at level M0, using the types and vocabulary introduced by the model at level M1. The types correspond to the classes in the model and the vocabulary corresponds to the properties (attributes, roles, and operations) declared for these classes. For example, in OCL one can query the number of persons (Person.allInstances()-&gt;size()) or the name of a person such as Mike (Mike.name). Interestingly, since metamodels are themselves models, OCL can also be used to query the models at level M1, using the types and vocabulary introduced by the metamodel at level M2. For example, in OCL one can query the number of classes in the model (Class.allInstances()) or the number of attributes possessed by a particular class such as Person (Person.ownedAttribute -&gt;size()).</p><p>A crucial observation is that, although OCL expressions ''talk about" instances of (meta)models, they are in fact interpreted on representations of those instances for which the meaning of the new types and vocabulary introduced by the (meta)models is unambiguous. In our example, consider the meaning of the property ownedAttribute: should the attributes ''owned" by a class (which is the intended meaning of the property ownedAttribute) include those which are inherited by the class or only those explicitly declared in the class? <ref type="foot" target="#foot_1">3</ref> An adequate representation of UML models as instances of the UML metamodel should provide an unambiguous interpretation for ownedAttribute as well as the rest of the vocabulary introduced by the UML metamodel to ''talk about" models. In UML, the standard way of representing instances of (meta)models is through object diagrams (also called ''snapshots"). The object diagrams also provide the information needed to unambiguously interpret OCL expressions written in the context of (meta)models. In what follows, we will denote by graphical models the models M that the modeler sees and works with, and by abstract models M we mean the object diagrams that represent the models M as instances of the metamodel.</p><p>Now we can give a more precise description of our approach. Let a security-design modeling language M be given. In order to analyze properties of security-design models (and model instances) M, we first formalize the desired properties as OCL queries using the types and vocabulary provided by the metamodel of M, and we then evaluate these queries on the corresponding snapshots M of the metamodel of M. For this approach to be meaningful, we require that the mapping relating graphical models M to abstract models M, along with the evaluation of OCL expressions, correctly interacts with the interpretation function ½Á. The precise requirements are defined below. If this mapping is not explicitly given, or the requirements are not satisfied, the validity of the results returned may be open (for examples, see Section 8.1), or even wrong. Note that this is particularly prone to happen when one is using modeling languages loaded with syntactic sugar.</p><p>Overall, our metamodel-based approach has a number of advantages over more traditional deductive approaches. First, the metamodel of a modeling language is always well defined and should be known by the modelers. Thus, when analyzing their security-design models, the modelers need not create from scratch, or learn, new (non-standard) concepts and relations. Instead, they can use the same language that they are using for modeling their system and its security policy. Second, OCL is a formal language defined as a standard add-on to UML. As noted in <ref type="bibr" target="#b15">[16]</ref>, ''it should be easily read and written by all practitioners of object technology and by their customers, i.e., people who are not mathematicians or computer scientists." Thus, the analysis of the models can be carried out by those building them, rather than only by others (''verification engineers") with a strong logical and mathematical background. Last but not least, there are many tools that support working with UML and OCL. In particular, there are tools that can automatically evaluate OCL expressions. Thus, the analysis of the models need not be a time-consuming task, which may require even more effort and ingenuity than the modeling itself. Instead, the modelers can use push-button technologies that are already available in academia and industry. The limitations of our approach are also clear: there are properties that cannot be naturally expressed using OCL or that cannot be proven by simply evaluating the expressions on concrete security-design models and scenarios.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">Correctness</head><p>Here, we expand on the requirements of our approach, in particular how OCL query evaluation must be related to the semantics of the modeling language. Let f be a function on the semantic domain and let exp f be an expression intended to formalize f in OCL. We require that the following diagram commutes: abstract graphical semantic model model domain</p><formula xml:id="formula_1">M M ! ½M # # evðexp f ; MÞ ! f<label>ð½MÞ</label></formula><p>In this diagram, the downward arrow on the left side denotes the evaluation of the OCL expression exp f , the result of which is denoted by the function evðÁ; ÁÞ. The downward arrow on the right side corresponds to the evaluation of the function f in the semantic domain, and the mapping to the semantic domain is, as before, given by ½Á.</p><p>The requirement says that the OCL expression exp f can be used to analyze the behavior of f if and only if ½evðexp f ; MÞ ¼ f ð½MÞ. Roughly speaking, this means that an OCL expression can be correctly used to check a property P if and only if, for arbitrary models (or model instances) M, the result of evaluating this expression on M corresponds to the value of the property P in ½M.</p><p>Rigorously proving this correspondence requires detailed metareasoning that involves both the semantics of the underlying formal system, the semantics of OCL, and the translation scheme from terms in the semantic domain to OCL expressions. This is a large undertaking and outside the scope of this paper. In many practical cases however, one may settle for the next best thing: it may be sufficient to have a careful understanding of the metamodel of the modeling languages and of the underlying mapping from graphical models to abstract models. This is the approach we have taken in this paper and hence we provide in the following sections precise definitions of the metamodel of our modeling language and of the mappings from graphical models to abstract models. Note that, as explained above, this is already a necessary condition for stating meaningful OCL expressions on models and model instances in the first place. SecureUML <ref type="bibr" target="#b3">[4]</ref> is a modeling language for formalizing access control requirements that is based on RBAC <ref type="bibr" target="#b6">[7]</ref>. In RBAC, permissions specify which roles are allowed to perform given operations. These roles typically represent job functions within an organization. Users are granted permissions by being assigned to the appropriate roles, based on their competencies and responsibilities in the organization. RBAC additionally allows one to organize the roles in a hierarchy, where roles can inherit permissions along the hierarchy. In this way, the security policy can be described in terms of the hierarchical structure of an organization. However, it is not possible to specify policies that depend on dynamic properties of the system state, for example, to allow an operation only during weekdays. SecureUML extends RBAC with authorization constraints to overcome this limitation. It formalizes access control decisions that depend on two kinds of information:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">The SecureUML + ComponentUML Language</head><p>(i) Declarative access control decisions that depend on static information, namely the assignments of users and permissions to roles, which we designate as an RBAC configuration. (ii) Programmatic access control decisions that depend on dynamic information, namely the satisfaction of authorization constraints in the current system state.</p><p>SecureUML provides a language for specifying access control policies for actions on protected resources. However, it leaves open what the protected resources are and which actions they offer to clients. These are specified in a so-called dialect and depend on the primitives for constructing models in the system design modeling language. Fig. <ref type="figure" target="#fig_0">1</ref> shows the SecureUML metamodel. Essentially, it provides a language for modeling Roles, Permissions, Actions, Resources, and Authorization Constraints, along with their Assignments, i.e., which permissions are assigned to which roles, which actions are assigned to which permissions, which resources are assigned to which actions, and which constraints are assigned to which permissions. Notice that actions can be either Atomic or Composite. The atomic actions are intended to map directly onto actual operations of the modeled system. The composite actions are used to hierarchically group more lower-level ones and are used to specify permissions for sets of actions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2.">ComponentUML</head><p>The system design modeling language that we consider in this paper, ComponentUML, is a simple language for modeling component-based systems. Essentially, it provides a subset of UML class models: Entities can be related by Associations and may have Attributes and Methods. The ComponentUML metamodel is depicted in the (boxed) right-hand part of Fig. <ref type="figure">2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.3.">Dialect definition</head><p>The dialect metamodel provides the connection between Secur-eUML and the system design modeling language. The metamodel shown in Fig. <ref type="figure">2</ref>, together with the complete SecureUML metamodel, constitute the SecureUML + ComponentUML metamodel.</p><p>A dialect metamodel specifies:</p><p>(i) The model element types of the system design modeling language that represent protected resources. These element types are modeled as specializations of the class Resource.</p><p>Here, Entities, as well as their Attributes, Methods, and Associ-ationEnds  and that they contain both the read and the update actions upon the corresponding attributes.</p><formula xml:id="formula_2">(</formula><p>context AttributeFullAccess inv targetsAnAttribute: self.resource.oclIsTypeOf(Attribute) inv containsSubactions:</p><p>self.subordinatedactions = self.resource.action -&gt;select(a|a.ocllsTypeOf(AtomicUpdate)) -&gt;union(self.resource.action -&gt;select(a|a.ocllsTypeOf(AtomicRead)))</p><p>(iii) The default access control policy for those actions where no explicit permissions are defined (i.e., whether access is allowed or denied by default). This is accomplished by specifying whether the default role has the default permission, where the default role and the default permission are distinguished by having the default attribute set to true. OCL metamodel invariants (given in Appendix B) therefore include, for example, the following invariants, which guarantee that security models contain a default permission that can only be given to the default role and whose authorization constraint is always satisfied.</p><p>context Permission inv existsADefaultPermission: self.allInstances()-&gt;select(p|p.default)-&gt;size()=1 inv defaultPermissionAssignedToDefaultRole: self.default implies self.givesaccess-&gt;forAll(r|r.default) inv constraintByTrue: self.default implies self.isconstraintby.body=''true"</p><p>The default access policy is now specified by the following constraint, stating that the default role has the default permission, i.e., access is allowed by default.</p><p>context Role inv defaultAccess: self.default implies self.haspermission-&gt;exists(p|p.default)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">The SecureUML + ComponentUML models</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1.">Concrete syntax</head><p>We use Fig. <ref type="figure" target="#fig_2">3</ref> as a running example to illustrate the concrete syntax of SecureUML and ComponentUML. In this example, the system should maintain data on persons and records of meetings. A meeting has an owner, a list of participants, a time, and a place. Users may carry out standard operations on meetings, such as creating, reading, editing, and deleting them. A user may also cancel a meeting, which deletes the meeting and notifies all participants by email. The system should obey the following (here informally given) security policy:</p><p>-All users of the system are allowed to create new meetings and read all meeting entries. -Only the owner of a meeting is allowed to change meeting data and cancel or delete the meeting. -A supervisor is allowed to cancel any meeting.</p><p>-A system administrator is allowed to read meeting data, and administer the system's users. -A supervisor (but not a system administrator) is also a user of the system.</p><p>Fig. <ref type="figure" target="#fig_2">3</ref> formalizes this security policy using the UML profile for SecureUML and ComponentUML defined in <ref type="bibr" target="#b3">[4]</ref>.</p><p>A role is represented by a UML class with the stereotype hhRoleii and an inheritance relationship between two roles is defined using a UML generalization relationship. The role referenced by the arrowhead of the generalization relationship is considered to be the superrole of the role referenced by the tail.</p><p>A permission, along with its relations to roles and actions, is defined in a single UML model element, namely an association class with the stereotype hhPermissionii. The association class connects a role with a UML class representing a protected resource, which is designated as the root resource of the permission. The actions that such a permission refers to may be actions on the root resource or on subresources of the root resource. Each attribute of the association class represents the assignment of an action to the permission, where the action is identified by the name and the type of the attribute. Stereotypes for these permission attributes specify how the attribute is mapped to an action and are defined as part of the dialect. The stereotype hhentityactionii, for example, specifies that a permission attribute refers to an action on an entity. The name of the permission attribute specifies the name of the attribute, method, or association end targeted by the permission. The type of the permission attribute specifies the action (e.g., read, update, or full access) that is permitted by the permission. The authorization constraint expressions are attached to the permissions' association classes.</p><p>ComponentUML entities are represented by UML classes with the stereotype hhEntityii. Every method, attribute, or association end owned by such a class is automatically considered to be a method, attribute, or association end of the entity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">The mapping from models to snapshots of the metamodel</head><p>Recall that, in our approach, the specification of security properties using OCL depends on the mapping from models to snapshots of the metamodel. This is because the expressions formalizing the properties will not be evaluated on the graphical models, but rather on the corresponding abstract models. Of course, the mapping must satisfy the following property: if M is a well-formed graphical model, then M is an abstract model that satisfies all the invariants of the metamodel. The complete definition of the mapping from SecureUML + ComponentUML graphical models to abstract models is given in Appendix C. To a large extent, this mapping is straightforward: UML model elements with appropriate stereotypes are mapped to snapshots of the corresponding metamodel elements and associations between UML model elements are mapped to links between the snapshots of the corresponding metamodel elements.</p><p>In some cases, however, this mapping is less straightforward. In such cases, explicitly giving the mapping is essential to avoid ambiguous or incorrect interpretations and to guarantee that the resulting abstract models fulfill the metamodel invariants. This is particularly important when the notation provides the modeler with syntactic sugar. We list below some examples of such subtleties. Let M be a model, then the mapping constructs an M that contains (among others) the following elements.</p><p>-The mapping creates default objects of type Role, Authorization-Constraint, and Permission. Note that the default roles, authorization constraints, and permissions are not depicted in M. A default role, for example, is created by the mapping; it is assigned to every user depicted in M and it is declared a superrole of every role depicted in M. As a result, the following metamodel invariants (which formalize part of the default access control policy defined in SecureUML + ComponentUML) are guaranteed to be fulfilled in M: Similarly, a default object of type AuthorizationConstraint is created by the mapping, with the string 'true' as the value of its body attribute.</p><formula xml:id="formula_3">context</formula><p>-The mapping creates links between the default objects of type Role, AuthorizationConstraint, and Permission, and between the default object of type Permission and the objects of subtypes of Action. For example, the mapping creates a ConstraintAssignment-link between the default authorization constraint and the default permission, as well as a PermissionAssignment-link between the default permission and the default role. As a result, the metamodel invariants defaultPermissionAssignedToDefault-Role and constraintByTrue (which, as explained in the previous section, formalize part of the default access control policy defined in SecureUML + ComponentUML) are guaranteed to be (partially) fulfilled in M.</p><p>-The mapping creates objects of subtypes of Action that correspond to the actions offered by the resources, and links between these objects and the corresponding objects of subtypes of Resource. Note that objects for all possible actions are created, not only for those mentioned in the attributes of the permissions depicted in M. As an illustration, consider the model in Fig. <ref type="figure" target="#fig_2">3</ref>. The objects representing the actions of reading or updating the attribute name of the entity Person, as well as the composition of these two actions, are created by the mapping, although they are not explicitly referenced by any permission. In addition, the mapping creates ResourceAssignment-links between these objects and the object representing the attribute name. As a result, the following metamodel invariant, which formalizes the actions defined in SecureUML + ComponentUML on entity attributes, is guaranteed to be fulfilled in M for the attribute name:</p><p>context Attribute inv areAccessedBy: self.action-&gt;size()=3 and self.action-&gt;exists(a| a.ocllsTypeOf(AttributeFullAccess)) and self.action-&gt;exists(a|a.ocllsTypeOf(AtomicRead)) and self.action-&gt;exists(a|a.ocllsTypeOf(AtomicUpdate))</p><p>-The mapping creates links between the objects of type AtomicAction and the corresponding objects of type CompositeAction. For example, the mapping for the model in Fig. <ref type="figure" target="#fig_2">3</ref>  Notice that the abstract models contain objects (and links between these objects) that are created by our mapping and therefore do not appear (or have names) in the graphical model. To denote these objects, we use the following conventions.</p><p>-Objects representing users, roles, permissions, and entities are named by their name in the graphical model. For example, the object representing the role SystemUser as a snapshot of the class Role is named SystemUser in the abstract model. -Objects representing actions are named by the name of the resource they act upon, followed by their types. For example, the object representing an atomic update action that acts upon the attribute start of the entity Meeting is named MeetingstartAtomicUpdate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Analyzing SecureUML + ComponentUML models</head><p>In this section, we define OCL operators in the context of the metamodel of SecureUML + ComponentUML that formalize different aspects of the access control information contained in the models. We will use these operators as part of an OCL-based language for analyzing access control decisions that depend on static information, namely the assignment of users and permissions to roles. Programmatic access control decisions can also be analyzed using these operators as we will discuss in Section 5. The approach we take not only allows us to formalize desired properties of models, but also to automatically analyze models by evaluating the corresponding OCL expressions on the snapshots of the metamodel corresponding to the models.</p><p>To illustrate our approach, we include examples that show the result of evaluating our OCL operators on the security policy modeled in Fig. <ref type="figure" target="#fig_2">3</ref>. All the examples have been checked with the SecureMOVA tool. In what follows, let SCHEDULER be the snapshot of the metamodel of SecureUML + ComponentUML that corresponds to the model depicted in Fig. <ref type="figure" target="#fig_2">3</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Semantics</head><p>We recall the semantics of SecureUML + ComponentUML models <ref type="bibr" target="#b3">[4]</ref> Here, / User ðu; pÞ denotes that u has permission p and / Action ðp; aÞ denotes that p is a permission for action a.</p><p>The access control semantics is now given by the formula / RBAC ðu; aÞ, which expresses that a user u has a permission to perform the action a.</p><p>/ RBAC ðu; aÞ :¼ 9p 2 Permissions : / User ðu; pÞ ^/Action ðp; aÞ:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Analysis operations</head><p>In this section, we define different OCL query operations that are useful for analyzing security properties of models formalized using SecureUML + ComponentUML.</p><p>To analyze the relation P Roles in the R RBAC -structure I RBAC defined by a model M, we define the operation Role::superrole-Plus():Set(Role) that returns the collection of roles (directly or indirectly) above a given role in the role hierarchy. In our example, Supervisor.superrolePlus() evaluates to Set{default Role, SystemUser, Supervisor} on SCHEDULER.</p><p>Similarly, we define the operation Role::subrolePlus():Set(Role) returning the roles (directly or indirectly) below a given role in the role hierarchy. Also, we use these operations to define the operation Role::allPermissions():Set(Permission) that returns the collection of permissions (directly or indirectly) assigned to a role.</p><p>context Role::allPermissions():Set(Permission) body:</p><p>self.superrolePlus().haspermission-&gt;asSet()</p><p>In our example, Supervisor.allPermissions() evaluates to Set{default-Permission, OwnerMeeting, UserMeeting, SupervisorCancel} on SCHEDULER.</p><p>Conversely, we define the operation Permission::allRoles(): Set(Role), returning the collection of roles that are (directly or indirectly) assigned to the given permission.</p><p>To analyze the relation P Actions in the R RBAC -structure I RBAC defined by a model M, we define the operation Action::subaction-Plus():Set(AtomicAction) that returns the collection of atomic actions (directly or indirectly) subordinated to an action. Similarly, we define Action::compactionPlus():Set(Action) returning the collection of actions to which an action is (directly or indirectly) subordinated. In addition, we define the operation Permission::allActions():Set(AtomicAction) that returns the collection of atomic actions whose access is (directly or indirectly) granted by a permission.</p><p>context Permission::allActions():Set(AtomicAction) body:</p><p>self.accesses.subactionPlus()-&gt;asSet()</p><p>In our example, OwnerMeeting.allActions() evaluates to Set{Meet-ingAtomicDelete, MeetingstartAtomicUpdate, MeetingdurationAtomi-cUpdate, MeetingcancelAtomicExecute, MeetingnotifyAtomicExecute, MeetingownerAtomicUpdate, MeetingparticipantsAtomicUpdate} on SCHEDULER.</p><p>Conversely, we define Action::allAssignedPermissions(): Set(Permission), returning the collection of permissions that (directly or indirectly) grant access to an action.</p><p>Finally, we define the operation User::allAllowedActions(): Set(AtomicAction) that returns the collection of atomic actions that are permitted for the given user, subject to the satisfaction of the associated constraints in each concrete scenario.</p><p>context User::allAllowedActions():Set(AtomicAction) body:</p><p>self.hasrole.allPermissions().allActions()-&gt;asSet()</p><p>Remark. Let I RBAC be the R RBAC structure defined by a model M.</p><p>Then, for any u in Users, r, r 1 , and r 2 in Roles, p in Permissions, a 1 in Actions, and a and a 2 in AtomicActions, Table <ref type="table" target="#tab_5">1</ref> shows the correspondence between satisfaction in I RBAC and evaluation of OCL expressions in M.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Analyzing scenarios</head><p>To analyze the effect of authorization constraints on a Secure-UML policy, we must be able to formalize and reason about instances of the ComponentUML model. Hence, one must be able to specify system states, which we will call security scenarios in the following.</p><p>In a security scenario, one specifies both the instance of the ComponentUML part of the security-design model (in the manner of a UML object diagram), as well as role assignments for the users in the scenario. We assume here that SecureUML users are represented as ComponentUML entities. The example scenario in Fig. <ref type="figure" target="#fig_4">4</ref> contains two users, Bob and Alice, with roles SystemUser and Supervisor, respectively. It also contains one meeting, Kick-off, whose owner is Alice.</p><p>Recall that our general approach for analyzing models is based on evaluating OCL expressions on snapshots of the metamodel. This means, we first must define the metamodel that formalizes the concepts and relations which are modeled by the security scenarios of security-design models. Afterwards, we must define how to map the security-design model together with the security scenario to a snapshot of this new metamodel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Metamodel combination</head><p>Our goal is to reason about the static RBAC configuration given in the security-design model together with the effects of authorization constraints in the given security scenario. Hence, the metamodel in which our analysis questions can be formalized as OCL expressions must provide the vocabulary for both. The idea thus is to merge the SecureUML metamodel with the ComponentUML model that is part of the security-design model (i.e., the design model) so that queries involving the validity of authorization constraints can be formulated using OCL expressions on snapshots of this combined metamodel.</p><p>This merging is more than a simple union of both models (the SecureUML metamodel and the ComponentUML model). Connections between them must be made in order to formulate queries involving, for example, both role assignments and system state.  To illustrate this metamodel combination, Fig. <ref type="figure" target="#fig_6">5</ref> shows the result of the merging for the case of the security-design model in Fig. <ref type="figure" target="#fig_2">3</ref> and the scenario in Fig. <ref type="figure" target="#fig_4">4</ref>. In particular:</p><p>(i) The ComponentUML entities are added to the Secure-UML + ComponentUML metamodel and are given a common supertype EntityInstance, which is associated to Entity. This reflects that, in a scenario, a person Alice is an instance of the class Person but, as a concrete resource, she also has a type Person, which is an instance of Entity. This is similar to how the relationship between objects and classes is modeled in the UML metamodel. Only here, the metamodel is not fixed, but is extended by the entities depicted in the security design model (in our example, Person and Meeting).To ensure that entity instances are associated to their corresponding entities, for each pair of distinct entities A and B depicted in the security-design model (in our example, Person and Meeting) the following invariants are added to the Secure-UML + ComponentUML metamodel: (ii) An inheritance relationship from the ComponentUML entity representing users to the class User is added to the Secure-UML + ComponentUML metamodel. This reflects the fact that, in a scenario, a person Alice is an instance of the class Person but, as a user, she can also be a caller in an authorization constraint. In general, this user-entity will be implicitly defined by the actual role-assignments in the scenario: The entity whose instances are associated to roles obviously represents users (in our example, the entity Person). (iii) A class ActionInstance, with associations both to Action and EntityInstance, is added to the SecureUML + Componen-tUML metamodel. This reflects the fact that, in a scenario, the action of reading Alice's name has a type, namely, the type represented by the atomic action PersonnameAtomic-Read and it also refers to an instance of an entity, namely, the person Alice. To guarantee that action instances are created for each pair of compatible atomic action and entity instance, and that they are associated to their corresponding action and entity instances, the following invariants are added to the SecureUML + ComponentUML metamodel:</p><p>context is added to AuthorizationConstraint in the SecureUML + Component-UML metamodel, with the following semantics: it evaluates the constraint on the given scenario, using the arguments caller and self to instantiate the parameters caller and self in the constraint.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Scenario mapping</head><p>Given the combined metamodel, a security-design model together with a security scenario can be mapped to a snapshot of this metamodel. The complete definition is given in Appendix C. For the most part, this mapping is straightforward: the SecureUML policy in the security-design model is mapped as described in Section 3.3 and the object diagram in the security scenario (i.e., the instance of the ComponentUML part in the security-design model) is mapped as expected. There are, however, some subtleties that we list below. We use as an example the security-design model in Fig. <ref type="figure" target="#fig_2">3</ref> together with the scenario in Fig. <ref type="figure" target="#fig_4">4</ref>.</p><p>-Links are created to connect each instance of EntityInstance with the corresponding instance of Entity. In our example, the mapping creates a link between the object Alice of the class EntityInstance (that represents the person Alice depicted in the security scenario) and the object Person of the class Entity (that represents the entity Person). This link reflects the type of Alice as a resource, namely, a Person. -Objects of the type ActionInstance are created for each instance of AtomicAction and each instance of Entity such that the latter is the (root) resource for the former in the security-design model. Also, links are created to connect these instances of ActionInstance with the corresponding instances of AtomicAction and EntityInstance. In our example, an object Kick-OffstartAtomicRead of the class ActionInstance is created and is linked both to the object MeetingstartAtomicRead of the class AtomicRead (that represents the action of reading the value of the attribute start of the entity Meeting) and to the object Kick-Off of the class Meeting (that represents the meeting Kick-Off depicted in the security scenario). These links reflect, respectively, the type of Kick-Off-startAtomicRead as an action, namely, the action Meetingstart-AtomicRead, and the resource upon which it acts, namely, the meeting Kick-Off.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Scenario analysis operations</head><p>Let us first recall here the semantics of programmatic access control decisions in SecureUML + ComponentUML models, with respect to which we claim that our OCL-operations are correct. Let R ST be the order-sorted signature corresponding to the Componen-tUML model and let S ST be the R ST -structure defined by the security scenario. For the formal definition of R ST and S ST , we refer to <ref type="bibr" target="#b3">[4]</ref>. Basically, R ST contains a sort for each entity and a function symbol for each attribute or association end of an entity in the ComponentUML model. The definition of S ST from the security scenario is the straightforward one. Let R AC ¼ R RBAC [ R ST and</p><formula xml:id="formula_4">S AC ¼ hS ST ; I RBAC i.</formula><p>Given the above, a user u is allowed to perform the action a if and only if In what follows, let SCHEDULER+ be the snapshot of the metamodel that corresponds to the scenario depicted in Fig. <ref type="figure" target="#fig_4">4</ref>. We start by defining an operation User::allAuthConstUser(a:Action):Set(Autho-rizationConstraint) that returns the list of authorization constraints for a given user-action pair.</p><p>context User::allAuthConstUser(a:Action) :Set(AuthorizationConstraint) body: self.hasrole.superrolePlus().allAuthConstRole(a)</p><p>context Role::allAuthConstRole(a:Action) :Set(AuthorizationConstraint) body: self.permissionPlus(a).isconstraintby Given this, we can now define the most basic analysis operation: can a given user perform a given action instance in the current scenario? This is the operation User::isAllowed(a: ActionInstance):Boolean defined below.</p><p>context User::isAllowed(a:ActionInstance):Boolean body:</p><p>self.allAuthConstUser(a.action)-&gt;exists(au| au.evaluate(self,a.resourceInstance))</p><p>In our example, Alice.isAllowed(Kick-OffAtomicDelete) evaluates to true on SCHEDULER+. We can also calculate the allowed action instances for a given user and the set of users that are allowed to perform a given action instance.</p><p>context User::allAllowedActionInstances() :Set(ActionInstance) body: self.allAllowedActions().actionInstance -&gt;select(ai|(self.isAllowed(ai))</p><p>In our example, Bob.allAllowedActionInstances() evaluates to Set{-Kick-OffAtomicCreate, Kick-OffstartAtomicRead, Kick-OffdurationAtom-icRead, Kick-OffownerAtomicRead, KickOffparticipantsAtomicRead}on SCHEDULER+.</p><p>context ActionInstance::allUsers():Set(User) body:</p><p>self.action.allAssignedUsers-&gt;select(u|u.isAllowed(self))</p><p>context Action::allAssignedUsers():Set(User) body: self.allAssignedRoles.includes</p><p>In our example, Kick-OffAtomicDelete.allUsers() evaluates to Set{Alice} on SCHEDULER+.</p><p>Remark. Let S AC be the R ST -structure defined by a model M together with a security scenario. Then, for any u in Users and a in AtomicActions, and for any action instance ai of a, Table <ref type="table" target="#tab_8">2</ref> shows the correspondence between satisfaction in S AC and evaluation of OCL expressions in M. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Analysis examples</head><p>In this section, we give examples that illustrate how one can analyze SecureUML + ComponentUML models or scenarios M using the OCL operations defined in the previous sections. The properties to be analyzed are formalized as queries on objects in M, possibly with additional arguments referring to the objects in M. We also show the results of the queries on the security policy modeled in Fig. <ref type="figure" target="#fig_2">3</ref> and the scenario modeled in Fig. <ref type="figure" target="#fig_4">4</ref>. All the examples have been checked with the SecureMOVA tool.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Security policies</head><p>Example. Given a role, what are the atomic actions that a user in this role can perform? context Role::allAtomics():Set(AtomicAction) body:</p><p>self.allPermissions().allActions()-&gt;asSet() Example. Given an atomic action, which roles can perform this action?</p><formula xml:id="formula_5">In</formula><p>context AtomicAction::allAssignedRoles():Set(Roles) body:</p><p>self.compactionPlus().isassigned.allRoles()-&gt;asSet()</p><p>In our example, MeetingAtomicDelete.allAssignedRoles() evaluates to Set{Supervisor, SystemUser} on SCHEDULER.</p><p>Example. Given a role and an atomic action, under which circumstances can a user in this role perform this action?</p><p>context Role::allAuthConst(a:Action):Set(String) body: self.permissionPlus(a).isconstraintby.body-&gt;asSet() context Role::permissionPlus(a:Action):Set(Permission) body: self.allPermissions() -&gt;select(p|p.allActions()-&gt;includes(a))</p><p>In our example, Supervisor.allAuthConst(MeetingCancelAtomicExecute) evaluates to Set{''self.name.owner=caller.name", ''true"} on SCHEDULER.</p><p>Example. Are there two roles with the same set of atomic actions? context Role::duplicateRoles():Boolean body:</p><p>Role.allInstances() -&gt;exists(r1, r2| r1.allAtomics()=r2.allAtomics())</p><p>In our example, duplicateRoles() evaluates to true on SCHEDULER.</p><p>Example. Given an atomic action, which roles allow the least set of actions, including the atomic action? This requires a suitable definition of ''least" and we use here the smallest number of atomic actions.</p><p>context AtomicAction::minimumRole():Set(Role) body:</p><p>self.allAssignedRoles()-&gt;select(r1|self.allAssignedRoles() -&gt;forAll(r2| r1.allAtomics()-&gt;size() &lt;= r2.allAtomics()-&gt;size()))</p><p>In our example, PersoneventsAtomicRead.minimumRole() evaluates to Set{SystemAdministrator} on SCHEDULER.</p><p>Example. Do two permissions overlap? context Permission::overlapsWith(p:Permission):Boolean body: self.allActions() -&gt;intersection(p.allActions())-&gt;notEmpty()</p><p>In our example, OwnerMeeting.overlapsWith(SupervisorCancel) evaluates to true on SCHEDULER.</p><p>Example. Are there overlapping permissions for different roles?</p><p>context Permission::existOverlapping():Boolean body:</p><p>Permission.allInstances()-&gt;exists(p1,p2| p1 &lt;&gt; p2 and p1.overlapsWith(p2) and not(p1.allRoles()-&gt;includesAll(p2.allRoles())))</p><p>In our example, existOverlapping() evaluates to true on SCHEDULER.</p><p>Example. Are there atomic actions that every role, except the default role, may perform? context AtomicAction::accessAll():Boolean body:</p><p>AtomicAction.allInstances()-&gt;exists(a| Role.allInstances()-&gt;forAll(r| not(r.default) implies r.allAtomics()-&gt;includes(a)))</p><p>In our example, accessAll() evaluates to true on SCHEDULER.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Security scenarios</head><p>Many of the analysis examples above can be expressed in terms of action instances instead of actions. In the following, we provide several examples of this.</p><p>Example. Given an action on a concrete resource, which roles are to be assigned to a given user so as to allow her to perform the action in the given scenario? context User::allRolesToPerform(ai:ActionInstance) :Set(Role) body: Role.allInstances()-&gt;select(r| r.allAuthConstRole(ai.action)-&gt;exists(au| au.evaluate(self, ai.resourceInstance)))</p><p>In our example, Bob.allRolesToPerform(Kick-OffstartAtomicUpdate) and Bob.allRolesToPerform(Kick-OffcancelAtomicExecute) evaluate, respectively, to Set{} and Set{Supervisor} on SCHEDULER+.</p><p>Example. Are there actions on concrete resources that every user can perform in the given scenario? context ActionInstance::accessAllUsers():Boolean body:</p><p>ActionInstance.allInstances()-&gt;exists(ai| User.allInstances()-&gt;forAll(u|u.isAllowed(ai)))</p><p>In our example, accessAllUsers() evaluates to true on SCHEDULER+.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">The SecureMOVA tool</head><p>As <ref type="bibr" target="#b13">[14]</ref> observed, although there are different proposals for specifying role-based authorization constraints, there is a lack of appropriate tool support for the validation, enforcement, and testing of role-based access control policies. In particular, tools are needed that can be easily applied by policy designers without much additional training. In response to this need, <ref type="bibr" target="#b13">[14]</ref> shows how to employ the USE system to validate and test access control policies formulated in UML and OCL. We comment on this work in Section 8. As part of our work, we have implemented SecureMOVA, a modeling and analysis tool for SecureUML + ComponentUML that is directly based on the results presented in this paper.</p><p>The SecureMOVA tool is an extension of the MOVA tool. MOVA itself is a modeling and validation tool for UML and OCL. MOVA provides facilities for drawing UML class and object diagrams, entering and evaluating OCL constraints and queries, defining new OCL operations, and evaluating OCL metrics. The OCL editor includes a model-based syntax-guided facility where, to write an expression, the user selects patterns from lists, generated at runtime. The patterns presented to the user depend on the type of the expression and the types and vocabulary introduced in the model under consideration.</p><p>SecureMOVA extends MOVA to support the automated analysis of security-design models. In particular, it allow users to draw Secur-eUML + ComponentUML models and scenarios, to write OCL authorization constraints and assign them to permissions, and to enter and evaluate OCL queries on security-design models and scenarios. It shares with MOVA its model-based, syntax-guided, OCL editor.</p><p>Figs. <ref type="figure">6</ref> and<ref type="figure" target="#fig_7">7</ref> show three screenshots of the SecureMOVA tool. First, Fig. <ref type="figure">6</ref> shows how the security policy in Fig. <ref type="figure" target="#fig_2">3</ref> can be modeled in SecureMOVA. Second, Fig. <ref type="figure" target="#fig_7">7</ref> (left) illustrates the use of the OCL editor for querying the example scenario in Fig. <ref type="figure" target="#fig_4">4</ref> with one of the queries introduced in Section 6, namely, Bob.AllRolesToPerform(Kick-OffCancelAtomicExecute). Finally, Fig. <ref type="figure" target="#fig_7">7</ref> (right) shows the answer to this query after evaluating it on the given scenario. The tool is publicly available at http://maude.sip.ucm.es/mova, along with a tutorial and the security-design model and scenario presented in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusion</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1.">Related work</head><p>As mentioned in the introduction, our work was inspired by <ref type="bibr" target="#b0">[1]</ref>, who first explored the use of OCL for querying RBAC policies (see also <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b14">15]</ref>). We discuss two of the main differences here. First, a distinct characteristic of our work is that we spell out and follow a precise methodology that guarantees that query evaluation is formally meaningful. This methodology requires, in particular, precise definitions of both the metamodel of the modeling language and the mapping from models and scenarios to the corresponding snapshots of this metamodel. These definitions make it possible to rigorously reason about the meaning of the OCL expressions used in specifying and analyzing security policies.</p><p>To underscore the importance of such a methodology, consider a simple example: specifying two mutually exclusive roles such as ''accounts payable manager" and ''purchasing manager". Mutual exclusion means that no individual can be assigned to both roles. In <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15]</ref> this constraint is specified using OCL as follows:</p><p>context User inv: let M: Set={{accounts payable manager, purchasing manager}, . . .} in M-&gt;select(m | self.role-&gt;intersection(m)-&gt;size &gt; 1) -&gt;isEmpty() This constraint correctly specifies mutual exclusion only if the association-end role returns all the roles assigned to a user. This should include all role assignments explicitly depicted as well as those implicitly assigned to users via the role hierarchy. The actual meaning of the association-end role depends, of course, on the mapping between models and the corresponding snapshots of the metamodel. Since the precise definition of this mapping is not given in <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15]</ref>, readers (and tool users) must speculate on Fig. <ref type="figure">6</ref>. A SecureMOVA security-design model.</p><p>the meaning of such expressions. (Note that if the mapping used in <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15]</ref> is the ''straightforward" one, then the association-end role will only return the roles explicitly assigned to a user.)</p><p>In our setting, mutual exclusion can be specified using OCL as follows:</p><p>context User inv: let M: Set={{accounts payable manager, purchasing manager}, . . .} in M-&gt;select(m | self.hasrole.superrolePlus() -&gt;intersection(m)-&gt;size &gt; 1) -&gt;isEmpty() From our definition of superrolePlus() in Section 4.2, it is clear that this expression denotes all the roles assigned to a user, including those implicitly assigned under the specified role hierarchy.</p><p>A second difference concerns the fact that the SecureUML modeling language includes the possibility of constraining permissions with authorization constraints, given by OCL formulas. These constraints restrict the permissions to those system states satisfying the constraints. In our approach, these states can be formalized within models as (security) scenarios and we can automatically determine the satisfaction of authorization constraints with respect to given scenarios. As explained in Section 5, this allows us to go beyond querying properties about a system's static RBAC configuration by allowing queries to refer to, and answers to depend on, the system state, i.e., the current instance of the design model (the ComponentUML part of the security-design model). We have given examples of this in Section 6, where queries combine aspects of both declarative and programmatic access control. For example, ''are there actions on concrete resources that every user can perform in a given scenario?"</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2.">Generality of approach</head><p>We comment now on the generality of our approach and the effort needed to use it in other settings, for example, when employing other (domain-specific) design modeling languages. Consider, for example, the metamodel constraints shown in Appendix B. Some of these constraints only depend on the fact that the underlying access control model is a variant of RBAC, for example, constraints describing the general structure of role hierarchies. The majority, however, explicitly concern the structure of the design modeling language, for example, the action hierarchy. Transferring our approach to another design modeling language requires that we also define the corresponding metamodel constraints for the new language. Analogous considerations hold for the mapping from graphical to abstract models, described in Appendix C. This is not, however, a peculiarity of our approach. The definition of the dialect for the design-modeling language must include this information anyway so that the meaning of the language can be understood. Note that the metamodel constraints in Section 5.1 not only depend on the design modeling language, but also on the design model. However, these constraints are automatically generated from the design model. This generation scheme again only depends on the design modeling language. Interestingly, the analysis examples given in Section 6 do not depend on the design modeling language or on the design model. One could therefore imagine a library of such constraints that could, for example, be used to automatically suggest possible flaws in the modeled security policy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3.">Future work</head><p>The use of scenarios provides support for handling queries involving system state, where we can evaluate queries with respect to a given scenario. Nevertheless, it would be attractive to support queries about the existence of states satisfying constraints or queries where the states themselves are existentially quantified. An example of the latter for a design metamodel that includes access to the system date is ''which operations are possible on week days that are impossible on weekends?" Alternatively, in a banking model, we might ask ''which actions are possible on overdrawn bank accounts?" Such queries cannot currently be evaluated as they require reasoning about the consequences of OCL formulas and this involves theorem proving as opposed to determining the satisfiability of formulas in a concrete model.</p><p>Another interesting direction would be to use our approach to analyze the consistency of different system views. We showed in [4] how one can combine SecureUML with different modeling languages (i.e., ComponentUML and ControllerUML <ref type="bibr" target="#b2">[3]</ref>) to formalize different views of multi-tier architectures. In this setting, access control might be implemented at both the middle tier (implementing a controller for, say, a web-based application) and a back-end persistence tier. If the policies for both of these tiers are formally modeled, we can potentially answer question like ''will the controller ever enter a state in which the persistence tier throws a security exception?" This is a query about the existence (reachability) of states and answering it would again require support for theorem proving or other forms of deduction such as constraint solving or state search.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A. Background on OCL</head><p>OCL has played a central role in our work for formalizing both constraints and queries on models. In this section, we briefly summarize relevant aspects of OCL.</p><p>The Object Constraint Language (OCL) <ref type="bibr" target="#b11">[12]</ref> is a typed language, with an object-oriented, textual notation for writing constraints within, or queries on, UML models. The language includes predefined types like Boolean, Integer, and String, with standard operators like not and or over Boolean, +, and * over Integer, and substr and concat over String. For example, 2 + 5 and not(2 + 5 = 6) are OCL expressions of type Integer and Boolean, respectively. The language also provides operators for generating collection types from more basic types, along with standard operations on collections like union, includes, or size. For example, Set(Integer) is the type of sets of integers and Set{1, 4, 6}-&gt;union(Set{3}) is an expression of type Set(Integer) that denotes the union of the sets f1; 4; 6g and f3g. Iterator operators like forAll, select, or collect, operate on collection types. Each takes an OCL expression as an argument and specifies an operation computed over the elements of a collection. For example, Set{1, 4, 6}-&gt;forAll(i|i &gt; 7) is an expression of type Boolean that evaluates to true if and only if each element of the set f1; 4; 6g is greater than 7. As another example, collect applies an OCL expression to each element in the collection and returns the union of these results: Set{1, 4, 6}-&gt;collect(i|i + 1) is an expression of type Set(Integer) that denotes the set of integers that result from adding 1 to each of the elements of the set f1; 4; 6g.</p><p>The OCL language is open in the sense that it is parametric. Expressions are written in the context of a UML model, using the types and vocabulary provided by the model. The new types correspond to the classes in the model and the new vocabulary correspond to the properties (attributes, roles, and operations) declared for these classes. For example, consider a class diagram M containing a class A. Suppose too that this class has an attribute x of type String. Now, x can appear in OCL expressions, using dot notation: for an object o of the class A, the expression o. x denotes the value of its attribute x.</p><p>OCL provides a convenient shorthand notation for navigating over multiple association ends: Whenever a property call (attribute, operation, or association end call) is applied to a collection, it will be interpreted as a collect over the members of the collection with the specified property. In the context of Meeting for example, self.participants.name is shorthand for self.participants -&gt; collect(p|p.name) and refers to the collection of the names of the participants of the meeting.</p><p>OCL also provides access to the value of certain properties of the classes themselves using the dot notation. For example, the expression A.allInstances() denotes the set of all objects of the class A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix B. The SecureUML + ComponentUML metamodel constraints</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.1. Default role</head><p>The following invariants guarantee that models contain a default role with the desired semantics; in particular, any user is assigned, at least, the default role. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.2. Role hierarchy</head><p>The following invariant guarantees that the role hierarchy is acyclic.</p><p>context Role inv noCyclesinRoleHierarchy: self.superrole-&gt;forAll(r|r.superrolePlus()-&gt;excludes(self))</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.3. Default permission</head><p>The following invariants guarantee that models contain a default permission with the desired semantics. In particular, the default permission may only be given to the default role and may contain only atomic actions. Also, atomic actions are assigned at least one permission and, if they are assigned more than one, then none of them can be the default permission. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.4. Resource action association</head><p>The following invariants guarantee that actions refer to the correct resource.</p><p>(vi) ActionHierarchy-links between euðeÞ (subordinatedAction) and efaðeÞ, erðeÞ (subordinatedAction) and efaðeÞ, acðeÞ (subordinatedAction) and efaðeÞ, and adðeÞ (subordinatedAction) and efaðeÞ; and (vii) ActionAssignment-links between acðeÞ and adðeÞ and the object ''default" of the class Permission.</p><p>-For each attribute a of an entity e, insert (i) an object a of the class Attribute; (iv) ActionHierarchy-links between auðdÞ (subordinatedAction) and dfaðdÞ, arðaÞ (subordinatedAction) and dfaðdÞ, auðdÞ (subordi-natedAction) and euðeÞ, and arðdÞ (subordinatedAction) and erðeÞ;</p><p>(v) an EntityAssociationEnd-link between e and d; and (vi) Action-Assignment-links between auðdÞ and arðdÞ and the object ''default" of the class Permission. -Insert an object ''default" of the class AuthorizationConstraint, with values ''OCL" and ''true", respectively, for its language and body attributes. -For each authorization constraint ath, insert an object ath, with values ''OCL" and ''ath" for its language and body attributes, respectively. -Insert an object ''default" of the class Permission, with the value true for its default-attribute. -Insert a ConstraintAssignment-link between the ''default" object of the class Permission and the ''default" object of the class AuthorizationConstraint. -Insert a PermissionAssignment-link between the ''default" object of the class Permission and the ''default" object of the class Role. -For each permission p, insert an object p of the class Permission, with the value false for its default-attribute. -For each assignment of a permission p to a role r, insert a Permis-sionAssignment-link between r and p. -For each assignment of a constraint ath to a permission p, insert a ConstraintAssignment-link between p and ath. -For each entity e and each permission p that grants ''entity full access" to e, insert an ActionAssignment-link between efaðeÞ and p. Delete any ActionAssignment-link between the ''default" object of the class Permission and acðeÞ or adðeÞ. For each attribute a, method m, and association-end d of e, delete any ActionAssignment-link between the ''default" object of the class Permission and auðaÞ, arðaÞ, auðdÞ, arðdÞ, or aeðmÞ. -For each entity e and each permission p that grants ''entity read access" to e, insert an ActionAssignment-link between erðeÞ and p.</p><p>For each attribute a, query method m, and association-end d of e, delete any ActionAssignment-link between the ''default" object of the class Permission and arðaÞ, arðdÞ, or aeðmÞ. -For each entity e and each permission p that grants ''entity update access" to e, insert an ActionAssignment-link between euðeÞ and p. For each attribute a, non-query method m, and association-end d of e, delete any ActionAssignment-link between the ''default" object of the class Permission and auðaÞ, auðdÞ, or aeðmÞ. -For each entity e and each permission p that grants ''atomic create access" to e, insert an ActionAssignment-link between acðeÞ and p. Delete any ActionAssignment-link between the ''default" object of the class Permission and acðeÞ. -For each entity e and each permission p that grants ''atomic delete access" to e, insert an ActionAssignment-link between adðeÞ and p. Delete any ActionAssignment-link between the ''default" object of the class Permission and adðeÞ. -For each attribute a and each permission p that grants ''attribute full access" to a, insert an ActionAssignment-link between afaðaÞ and p. Delete any Action Assignment-link between the ''default" object of the class Permission and auðaÞ or arðaÞ. -For each attribute a and each permission p that grants ''atomic update access" to a, insert an ActionAssignment-link between auðaÞ and p. Delete any ActionAssignment-link between the ''default" object of the class Permission and auðaÞ. -For each attribute a and each permission p that grants ''atomic read access" to a, insert an ActionAssignment-link between arðaÞ and p. Delete any ActionAssignment-link between the ''default" object of the class Permission and arðaÞ. -For each association-end d and each permission p that grants ''association-end full access" to d, insert an ActionAssignmentlink between dfaðdÞ and p. Delete any ActionAssignment-link between the ''default" object of the class Permission and auðdÞ or arðdÞ. -For each association-end d and each permission p that grants ''atomic update access" to d, insert an ActionAssignment-link between auðdÞ and p. Delete any ActionAssignment-link between the ''default" object of the class Permission and auðdÞ. -For each association-end d and each permission p that grants ''atomic read access" to d, insert and ActionAssignment-link between arðdÞ and p. Delete any ActionAssignment-link between the ''default" object of the class Permission and arðdÞ. -For each method m and each permission p that grants ''atomic execute access" to m, insert an ActionAssignment-link between aeðmÞ and p. Delete any ActionAssignment-link between the ''default" object of the class Permission and aeðmÞ. -For each method m of an entity e and each object ei of this entity, insert (i) an object aeiðmÞ of the class ActionInstance; (ii) an Action-ActionInstance link between aeðmÞ and aeiðmÞ; and (iii) an ActionInstance-EntityInstance link between aeiðmÞ and ei. -For each association-end d of an entity e, and for each object ei of this entity, insert (i) an object ariðdÞ of the class ActionInstance;</p><p>(ii) an object auiðdÞ of the class ActionInstance; (iii) Action-Actio-nInstance links between arðdÞ and ariðdÞ, and auðdÞ and auiðdÞ; and (iv) ActionInstance-EntityInstance links between ariðdÞ and ei, and auiðdÞ and ei.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>3. 1 .</head><label>1</label><figDesc>The SecureUML + ComponentUML Metamodel 3.1.1. SecureUML</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .Fig. 2 .</head><label>12</label><figDesc>Fig. 1. SecureUML metamodel.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig.3. Example security policy.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>context</head><label></label><figDesc>Role::superrolePlus():Set(Role) body: self.superrolePlusOnSet(self.superrole) context Role::superrolePlusOnSet(rs:Set(Role)):Set(Role) body: if rs.superrole-&gt;exists(r|rs-&gt;excludes(r)) then self.superrolePlusOnSet(rs -&gt;union(rs.superrole)-&gt;asSet()) else rs-&gt;including(self) endif</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Example scenario</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>context A inv:A.allInstances()-&gt;forAll(x,y| x.entity=y.entity) context A inv: B.allInstances()-&gt;forAll(b| b.entity &lt;&gt; self.entity)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Combined metamodel</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. A SecureMOVA OCL pattern-selection (left) and OCL evaluation (right).</figDesc><graphic coords="13,53.86,67.92,496.46,225.98" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>(ii) an object afaðaÞ of the class AttributeFullAccess; (iii) an object auðaÞ of the class AtomicUpdate; (iii) an object arðaÞ of the class AtomicRead; (vi) ResourceAssignment-links between a and afaðaÞ, a and auðaÞ, and a and arðaÞ; (iv) ActionHierarchy-links between auðaÞ ( subordinatedAction) and afaðeÞ, arðaÞ (subordinatedAction) and afaðeÞ, auðaÞ (subordinatedAction) and euðeÞ, and arðaÞ ( subordinatedAction) and erðeÞ; (v) an EntityAttibute-link between e and a; and (vi) ActionAssignment-links between auðaÞ and arðaÞ and the object ''default" of the class Permission. -For each query method m of an entity e, insert (i) an object m of the class Method, with valuetrue for its is Query-attribute; (ii) an object aeðmÞ of the class AtomicExecute; (iii) a ResourceAssignment-link between m and aeðmÞ; (iv) an ActionHierarchy-link between aeðmÞ (subordinatedAction) and erðeÞ; (v) an Entity-Method-link between e and m; and (vi) an ActionAssignment-link between aeðmÞ and the object ''default" of the class Permission. -For each non-query method m of an entity e, insert (i) an object m of the class Method, with value false for its isQuery-attribute; (ii) an object aeðmÞ of the class AtomicExecute; (iii) a ResourceAssignment-link between m and aeðmÞ; (iv) an ActionHierarchy-link between aeðmÞ (subordinatedAction) and euðeÞ; (v) an EntityMethod-link between e and m; and (vi) an ActionAssignment-link between aeðmÞ and the object ''default" of the class Permission. -For each association-end d of an entity e, insert (i) an object d of the class AssociationEnd; (ii) an object dfaðdÞ of the class Associa-tionEndFullAccess; (iii) an object auðdÞ of the class AtomicUpdate; (iii) an object arðdÞ of the class AtomicRead; (v) ResourceAssignment-links between d and dfaðdÞ, d and auðdÞ, and d and arðdÞ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>From</head><label></label><figDesc>security-policy scenarios to abstract models. -For each object ei of an entity e, insert (i) an object ei of the class e; (ii) an Entity-EntityInstance link between e and ei; (iii) an object aciðeiÞ of the class AtomicActionInstance; (iv) an object adiðeiÞ of the class AtomicActionInstance; (v) EntityInstance-ActionInstance links between ei and aciðeiÞ, and ei and adiðeiÞ; and (vi) Action-ActionInstance links between acðeÞ and aciðeiÞ, and adðeÞ and adiðeiÞ. -For each attribute a of an entity e, and each object ei of this entity, insert (i) an object ariðaÞ of the class ActionInstance; (ii) an object auiðaÞ of the class ActionInstance; (iii) Action-ActionInstance links between arðaÞ and ariðaÞ, and auðaÞ and auiðaÞ; and (iv) ActionInstance-EntityInstance links between ariðaÞ and ei, and auiðaÞ and ei.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="12,44.05,513.13,496.59,225.52" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>creates an Action-Hierarchy-link between the object of type CompositeAction representing the action of reading the entity Person and the object of type AtomicAction representing the action of reading its attribute name. As a result, the following metamodel invariant (which formalizes part of the hierarchy of actions defined in Secure-UML + ComponentUML) is guaranteed to be (partially) fulfilled in M for the entity Person:</figDesc><table><row><cell>context EntityRead inv containsSubactions:</cell></row><row><cell>self.subordinatedactions=</cell></row><row><cell>self.resource.oclAsType(Entity).hasattribute.action</cell></row></table><note><p><p><p>-&gt;select(a|a.ocllsTypeOf(AtomicRead)) -&gt;union(self.resource.oclAsType</p>(Entity)   </p>.hasassociationend.action -&gt;select(a|a.oclIsTypeOf(AtomicRead))) -&gt;union(self.resource.oclAsType(Entity).hasmethod -&gt;select(me|me.isQuery).action -&gt;select(a|a.ocllsTypeOf(AtomicExecute)))</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>RBAC is a set of sorts, P RBAC is a partial order on S RBAC , F RBAC is a sorted set of function symbols, and P RBAC is a sorted set of predicate symbols. In detail, UserAsssignment, PermissionAssignment, and ActionAssignment. Additionally, we define the partial orders P Roles and P Actions on the sets of roles and actions, respectively. P Roles is given by the reflexive-transitive closure of the metamodel aggregation RoleHierarchy on Role, and we write subroles (roles with additional privileges) on the left (larger) side of the P-symbol. P Actions is given by the reflexive-transitive closure of the composition hierarchy on actions, defined by the metamodel aggregation ActionHierarchy. We write a 1 P Actions a 2 , if a 2 is a subordinated action of a 1 . These relations are partial orders since aggregations in UML are antisymmetric by definition.Remark. Let I RBAC be the R RBAC structure defined by a model M.Then, for any u in Users, r in Roles, p in Permissions, and a in Actions, the following table shows the correspondence between satisfaction in I RBAC and evaluation of OCL expressions in M.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Is satisfied in I RBAC</cell><cell>Evaluates to true over M</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>UAðu; rÞ</cell><cell>u.hasrole-&gt;includes(r)</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>PAðr; pÞ</cell><cell>r.haspermission-&gt;includes(p)</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>AAðp; aÞ</cell><cell>p.accesses-&gt;includes(a)</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Next, we introduce the formulas</cell></row><row><cell cols="6">, with respect to which we claim that our OCL-operations</cell></row><row><cell>correctly</cell><cell>capture</cell><cell>access</cell><cell>control</cell><cell>information.</cell><cell>Let</cell></row><row><cell>S RBAC ¼</cell><cell cols="2">Users; Roles; Permissions; AtomicActions; Actions</cell><cell>;</cell><cell></cell><cell></cell></row><row><cell cols="5">where ActionsP RBAC AtomicActions. Also, F RBAC ¼ ; and P RBAC ¼ P Roles : Roles Â Roles; P Actions : Actions Â Actions; UA : Users Â Roles; PA : Roles Â Permissions; AA : Permissions Â Actions 8 &gt; &gt; &gt; &gt; &gt; &gt; &lt; &gt; &gt; &gt; &gt; &gt; &gt; : 9 &gt; &gt; &gt; &gt; &gt; &gt; = &gt; &gt; &gt; &gt; &gt; &gt; ; :</cell><cell></cell></row></table><note><p>R RBAC ¼ ðS RBAC ; P RBAC ; F RBAC ; P RBAC Þ be the order-sorted signature that defines the type of structures specifying role-based access control configurations. Here, S Given a SecureUML + ComponentUML model M, one defines a R RBAC -structure I RBAC in the obvious way: the sets Users, Roles, Permissions, AtomicActions, and Actions each contain entries for every model element of the corresponding metamodel types User, Role, Permission, AtomicAction, and Action. Also, the relations UA, PA, and AA contain tuples for each instance of the corresponding meta-model associations / User ðu; pÞ :¼ 9r; r 0 2 Roles : UAðu; rÞ ^rP Roles r 0 ^PAðr 0 ; pÞ; and / Action ðp; aÞ :¼ 9a 0 2 Actions : AAðp; a 0 Þ ^a0 P Actions a:</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 1</head><label>1</label><figDesc>Correspondence between semantics and OCL evaluationIs satisfied in I RBACEvaluates to true in M r 1 P Roles r 2 r 1 .superrolePlus()-includes(r 2 ) r 2 .subrolePlus()-includes(r 1 ) 9r 2 2 Roles: r 1 P Roles r 2 ^PAðr 2 ; pÞ r</figDesc><table><row><cell>1 .allPermissions()-includes(p)</cell></row><row><cell>p.allRoles()-includes(r 1 )</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 2</head><label>2</label><figDesc>Correspondence between semantics and OCL evaluationIs satisfied in S</figDesc><table /><note><p>AC Evaluates to true in M 9p 2 Permissions: p 2 UAPðu; aÞ u.allAuthConstUser(a)-&gt;includes(/ p ST ) 9p 2 Permissions: u.isAllowed(ai) p 2 UAPðu; aÞ ^/p ST u.allAllowedActionInstances()-&gt;includes(ai) ai.allUsers()-&gt;includes(u)</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>A similar approach has been proposed for UML model metrication<ref type="bibr" target="#b5">[6]</ref>: metrics are formalized as OCL queries on the UML metamodel and are evaluated on the models under consideration. This approach appears very general: it can be applied to analyze any model property, independently of the modeling language, as long as the property is expressible in OCL with the types and vocabulary provided by the metamodel.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>In principle, both are possible definitions of the property ownedAttribute. In fact,<ref type="bibr" target="#b12">[13]</ref> must clarify that the reference of the property ownedAttribute ''does not include the inherited attributes." D. Basin et al. / Information and Software Technology 51 (2009) 815-831</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>D. Basin et al. / Information and Software Technology 51 (2009) 815-831</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_3"><p>D. Basin et al. / Information and Software Technology 51 (2009) 815-831</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>1 Research partially supported by Spanish MEC Projects TIN2005-09207-C03-03 and TIN2006-15660-C02-01, and by Comunidad de Madrid Program S-0505/TIC/0407. Information and Software Technology 51 (2009) 815-831</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Appendix C. The mapping from graphical to abstract models</p><p>In the following, we give a complete, albeit informal, definition of the mapping from SecureUML + ComponentUML graphical models and scenarios to the corresponding abstract models.</p><p>From security-policy models to abstract models.</p><p>-Insert an object ''default" of the class Role, with the value true for its default-attribute. -For each role r, insert (i) an object r of the class Role, with the value false for its default-attribute, and (ii) a RoleHierarchy-link between r (subrole) and ''default". -For each inheritance relationship between two roles r 1 (subrole) and r 2 , insert a RoleHierarchy-link between r 1 (subrole) and r </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Role-based authorization constraints specification using object constraint language, in: WETICE&apos;01: Proceedings of the 10th IEEE International Workshops on Enabling Technologies</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Ahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Shin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>IEEE Computer Society</publisher>
			<pubPlace>Washington, DC, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A metamodel-based approach for analyzing security-design models</title>
		<author>
			<persName><forename type="first">D</forename><surname>Basin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Clavel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Doser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Egea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th International Conference on Model Driven Engineering Languages and Systems (MODELS 2007)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 10th International Conference on Model Driven Engineering Languages and Systems (MODELS 2007)</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4735</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Model driven security for process-oriented systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Basin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Doser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lodderstedt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighth ACM Symposium on Access Control Models and Technologies (SACMAT 2003)</title>
		<meeting>the Eighth ACM Symposium on Access Control Models and Technologies (SACMAT 2003)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Model driven security: from UML models to access control infrastructures</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Basin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Doser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lodderstedt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Software Engineering and Methodology</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="39" to="91" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Experience with embedding hardware description languages in HOL</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Boulton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J C</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Herbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">V</forename><surname>Tassel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IFIP TC10/WG 10.2 International Conference on Theorem Provers in Circuit Design</title>
		<meeting>the IFIP TC10/WG 10.2 International Conference on Theorem Provers in Circuit Design<address><addrLine>North-Holland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Using OCL to Formalize Object Oriented Metrics Definitions</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">B</forename><surname>Abreu</surname></persName>
		</author>
		<idno>ES007/2001</idno>
		<ptr target="&lt;http://ctp.di.fct.unl.pt/QUASAR/Resources/Papers/others/MOOD_OCL.pdf/&gt;" />
	</analytic>
	<monogr>
		<title level="m">FCT/UNL and INESC, Portugal</title>
		<imprint>
			<date type="published" when="2001-06">June, 2001</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Proposed NIST standard for role-based access control</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F</forename><surname>Ferraiolo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Sandhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gavrila</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Kuhn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Chandramouli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Information and System Security</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="224" to="274" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Using aspects to design a secure system</title>
		<author>
			<persName><forename type="first">G</forename><surname>Georg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Ray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>France</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICECCS&apos;02: Proceedings of the Eighth International Conference on Engineering of Complex Computer Systems</title>
		<meeting><address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Towards development of secure systems using UMLsec</title>
		<author>
			<persName><forename type="first">J</forename><surname>Jürjens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fundamental Approaches to Software Engineering, (FASE/ ETAPS</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Hussmann</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001">2001. 2001</date>
			<biblScope unit="volume">2029</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">UMLsec: extending UML for secure systems development</title>
		<author>
			<persName><forename type="first">J</forename><surname>Jürjens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">UML 2002 -The Unified Modeling Language</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J.-M</forename><surname>Jézéquel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Hussmann</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Cook</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2460</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Kleppe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Bast</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Warmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Watson</surname></persName>
		</author>
		<author>
			<persName><surname>Explained</surname></persName>
		</author>
		<title level="m">The Model Driven Architecture -Practice and Promise</title>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">OCL Specification, OMG document</title>
		<idno>UML 2.0</idno>
		<ptr target="&lt;http://www.omg.org/cgi-bin/doc?ptc/" />
		<imprint>
			<date type="published" when="2003-10-14">2003-10-14/&gt;, 2003</date>
		</imprint>
		<respStmt>
			<orgName>Object Management Group</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Unified Modeling Language: Infrastracture, Version 2.1.1, OMG document</title>
		<ptr target="&lt;http://www.omg.org/cgi-bin/doc?formal/07-02-04/&gt;" />
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
		<respStmt>
			<orgName>Object Management Group</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Specification and validation of authorisation constraints using UML and OCL</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sohr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Ahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gogolla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Migge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th European Symposium on Research in Computer Security (ESORICS 2005)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 10th European Symposium on Research in Computer Security (ESORICS 2005)</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3679</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Specifying role-based access constraints with object constraint language</title>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Sixth Asia-Pacific Web Conference</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the Sixth Asia-Pacific Web Conference</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004">APWeb 2004. 2004</date>
			<biblScope unit="volume">3007</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">The Object Constraint Language: Getting Your Models Ready for MDA</title>
		<author>
			<persName><forename type="first">J</forename><surname>Warmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kleppe</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
	<note>second ed.</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
