<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Adding Symmetry Reduction to Uppaal</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Martijn</forename><surname>Hendriks</surname></persName>
							<email>martijnh@cs.kun.nl</email>
							<affiliation key="aff0">
								<orgName type="department">Nijmeegs Instituut voor Informatica en Informatiekunde</orgName>
								<orgName type="institution">University of Nijmegen</orgName>
								<address>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Gerd</forename><surname>Behrmann</surname></persName>
							<email>behrmann@cs.auc.dk</email>
							<affiliation key="aff1">
								<orgName type="department">Department of Computing Science</orgName>
								<orgName type="institution">Aalborg University</orgName>
								<address>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kim</forename><surname>Larsen</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computing Science</orgName>
								<orgName type="institution">Aalborg University</orgName>
								<address>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Peter</forename><surname>Niebert</surname></persName>
							<email>peter.niebert@lif.univ-mrs.fr</email>
							<affiliation key="aff2">
								<orgName type="laboratory" key="lab1">Laboratoire d&apos;Informatique Fondementale</orgName>
								<orgName type="laboratory" key="lab2">CMI</orgName>
								<orgName type="institution">Université de Provence</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Frits</forename><surname>Vaandrager</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Nijmeegs Instituut voor Informatica en Informatiekunde</orgName>
								<orgName type="institution">University of Nijmegen</orgName>
								<address>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Adding Symmetry Reduction to Uppaal</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">094D25FD5AD27EA16604F551E61F5A0D</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:23+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We describe a prototype extension of the real-time model checking tool Uppaal with symmetry reduction. The symmetric data type scalarset, which is also used in the Murϕ model checker, was added to Uppaal's system description language to support the easy static detection of symmetries. Our prototype tool uses state swaps, described and proven sound earlier by Hendriks, to reduce the space and memory consumption of Uppaal. Moreover, the reduction strategy is canonical, which means that the symmetries are optimally used. For all examples that we experimented with (both academic toy examples and industrial cases), we obtained a drastic reduction of both computation time and memory usage, exponential in the size of the scalar sets used.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Model checking is a semi-automated technique for the validation and verification of all kinds of systems <ref type="bibr" target="#b7">[8]</ref>. The approach requires the construction of a model of the system and the definition of a specification for the system. A model checking tool then computes whether the model satisfies its specification. Nowadays, model checkers are available for many application areas, e.g., hardware systems <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b21">22]</ref>, finite-state distributed systems <ref type="bibr" target="#b16">[17]</ref>, and timed and hybrid systems <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b15">16]</ref>.</p><p>Despite the fact that model checkers are relatively easy to use compared to manual verification techniques or theorem provers, they are not being applied on a large scale. An important reason for this is that they must cope with the state space explosion problem, which is the problem of the exponential growth of the state space as models become larger. This growth often renders the mechanical verification of realistic systems practically impossible: there just is not enough time or memory available. As a consequence, much research has been directed at finding techniques to fight the state space explosion. One such a technique is the exploitation of behavioral symmetries <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b6">7]</ref>. The exploitation of full symmetries can be particularly profitable, since its gain can approach a factorial magnitude.</p><p>There are many timed systems which clearly exhibit full symmetry, e.g., Fischer's mutual exclusion protocol <ref type="bibr" target="#b0">[1]</ref>, the CSMA/CD protocol <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b26">27]</ref>, industrial audio/video protocols <ref type="bibr" target="#b12">[13]</ref>, and distributed algorithms, for instance <ref type="bibr" target="#b3">[4]</ref>.</p><p>Motivated by these examples, the work presented in <ref type="bibr" target="#b13">[14]</ref> describes how Uppaal, a model checker for networks of timed automata <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b1">2]</ref>, can be enhanced with symmetry reduction. The present paper puts this work to practice: a prototype of Uppaal with symmetry reduction has been implemented. The symmetric data type scalarset, which was introduced in the Murϕ model checker <ref type="bibr" target="#b9">[10]</ref>, was added to Uppaal's system description language to support the easy static detection of symmetries. Furthermore, the state swaps described and proven sound in <ref type="bibr" target="#b13">[14]</ref> are optimally used to reduce the space and time consumption of the model checking algorithm. Run-time data is reported for the examples mentioned above, showing that symmetry reduction in a timed setting can be very effective.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related work.</head><p>Symmetry reduction is a well-known technique to reduce the resource requirements for model checking algorithms, and it has been successfully implemented in model checkers such as Murϕ <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b18">19]</ref>, SMV <ref type="bibr" target="#b21">[22]</ref>, and Spin <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b5">6]</ref>. As far as we know, the only model checker for timed systems that exploits symmetry is Red <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b25">26]</ref>. The symmetry reduction technique used in Red, however, gives an over approximation of the reachable state space (this is called the anomaly of image false reachability by the authors). Therefore, Red can only be used to ensure that a state is not reachable when it is run with symmetry reduction, whereas symmetry enhanced Uppaal can be used to ensure that a state is reachable, or that it is not reachable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contribution.</head><p>We have added symmetry reduction as used within Murϕ, a well-established technique to combat the state space explosion problem, to the real-time model checking tool Uppaal. For researchers familiar with model checking it will come as no surprise that this combination can be made and indeed leads to a significant gain in performance. Still, the effort required to actually add symmetry reduction to Uppaal turned out to be substantial.</p><p>The soundness of the symmetry reduction technique that we developed for Uppaal does not follow trivially from the work of Ip and Dill <ref type="bibr" target="#b18">[19]</ref> since the description languages of Uppaal and Murϕ, from which symmetries are extracted automatically, are quite different. In fact, the proof that symmetry reduction for Uppaal is sound takes up more than 20 pages in <ref type="bibr" target="#b13">[14]</ref>.</p><p>The main theoretical contribution of our work is an efficient algorithm for the computation of a canonical representative. This is not trivial due to Uppaal's symbolic representation of sets of clock valuations.</p><p>Many timed systems exhibit symmetries that can be exploited by our methods. For all examples that we experimented with, we obtained a drastic reduction of both computation time and memory usage, exponential in the size of the scalar sets used.</p><p>Outline. Section 2 presents a very brief summary of model checking and symmetry reduction in general, while Sections 3 and 4 introduce symmetry reduction for the Uppaal model checker in particular. In Section 5, we present run-time data of Uppaal's performance with and without symmetry reduction, and Section 6 summarizes and draws conclusions.</p><p>A full version of the present paper including proofs of lemma 1 and of theorem 2 is available as <ref type="bibr" target="#b14">[15]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Model Checking and Symmetry Reduction</head><p>This section briefly summarizes the theory of symmetry presented in <ref type="bibr" target="#b18">[19]</ref>, which is reused in a timed setting since (i) it has proven to be quite successful, and (ii) it is designed for reachability analysis, which is the main purpose of the Uppaal model checker. We simplify (and in fact generalize) the presentation of <ref type="bibr" target="#b18">[19]</ref> using the concept of bisimulations.</p><p>In general, a transition system is a tuple (Q, Q 0 , ∆), where Q is a set of states, Q 0 ⊆ Q is a set of initial states, and ∆ ∈ Q × Q is a transition relation between states. Figure <ref type="figure" target="#fig_0">1</ref> depicts a general forward reachability algorithm which, under the assumption that Q is finite, computes whether there exists a reachable state q that satisfies some given property φ (denoted by q |= φ).</p><p>(1) passed := ∅ (2) waiting := Q0 (3) while waiting = ∅ do (4) get q from waiting (5) if q |= φ then return YES <ref type="bibr" target="#b5">(6)</ref> else if q / ∈ passed then <ref type="bibr" target="#b6">(7)</ref> add q to passed (8)</p><p>waiting Due to the state space explosion problem, the number of states of a transition system frequently gets too big for the above algorithm to be practical. We would like to exploit structural properties of transition systems (in particular symmetries) to improve its performance. Here the well-known notion of bisimulation comes in naturally: Definition 1 (Bisimulation). A bisimulation on some transition system, say</p><formula xml:id="formula_0">:= waiting ∪ { q ∈ Q | (q, q ) ∈ ∆ } (9) fi (10) od (11) return NO</formula><formula xml:id="formula_1">(Q, Q 0 , ∆), is a relation R ⊆ Q × Q such that</formula><p>, for all (q, q ) ∈ R, 1. q ∈ Q 0 if and only if q ∈ Q 0 , 2. if (q, r) ∈ ∆ then there exists an r such that (q , r ) ∈ ∆ and (r, r ) ∈ R, 3. if (q , r ) ∈ ∆ then there exists an r such that (q, r) ∈ ∆ and (r, r ) ∈ R.</p><p>Suppose that, before starting the reachability analysis of a transition system, we know that a certain equivalence relation ≈ is a bisimulation and respects the predicate φ in the sense that either all states in an equivalence class satisfy φ or none of them does. Then, when doing reachability analysis, it suffices to store and explore only a single element of each equivalence class. To implement the state space exploration, a representative function θ may be used that converts a state to a representative of the equivalence class of that state:</p><formula xml:id="formula_2">∀ q∈Q (q ≈ θ(q))<label>(1)</label></formula><p>Using θ, we may improve the algorithm in Figure <ref type="figure" target="#fig_0">1</ref> by replacing lines 2 and 8, respectively, by:</p><p>(2)</p><formula xml:id="formula_3">waiting := { θ(q) | q ∈ Q 0 } (8) waiting := waiting ∪ { θ(q ) | (q, q ) ∈ ∆ }</formula><p>It can easily be shown that the adjusted algorithm remains correct: for all (finite) transition systems the outcomes of the original and the adjusted algorithm are equal. If the representative function is "good", which means that many equivalent states are projected onto the same representative, then the number of states to explore, and consequently the size of the passed set, may decrease dramatically. However, in order to apply the approach, the following two problems need to be solved:</p><p>-A suitable bisimulation equivalence that respects φ needs to be statically derived from the system description. -An appropriate representative function θ needs to be constructed that satisfies formula (1). Ideally, θ satisfies q ≈ q ⇒ θ(q) = θ(q ), in which case it is called canonical.</p><p>In this paper, we use symmetries to solve these problems. As in <ref type="bibr" target="#b18">[19]</ref>, the notion of automorphism is used to characterize symmetry within a transition system. This is a bijection on the set of states that (viewed as a relation) is a bisimulation. Phrased alternatively:</p><formula xml:id="formula_4">Definition 2 (Automorphism). An automorphism on a transition system (Q, Q 0 , ∆) is a bijection h : Q → Q such that 1. q ∈ Q 0 if and only if h(q) ∈ Q 0 for all q ∈ Q</formula><p>, and 2. (q, q ) ∈ ∆ if and only if (h(q), h(q )) ∈ ∆ for all q, q ∈ Q.</p><p>Let H be a set of automorphisms, let id be the identity function on states, and let G(H) be the closure of H ∪{id} under inverse and composition. It can be shown that G(H) is a group, and it induces a bisimulation equivalence relation ≈ on the set of states as follows:</p><formula xml:id="formula_5">q ≈ q ⇐⇒ ∃ h∈G(H) (h(q) = q ) (2)</formula><p>We introduce a symmetric data type to let the user explicitly point out the symmetries in the model. Simple static checks can ensure that the symmetry that is pointed out is not broken. Our approach to the second problem of coming up with good representative functions consists of "sorting the state" w.r.t. some ordering relation on states using the automorphisms. For instance, given a state q and a set of automorphisms, find the smallest state q that can be obtained by repeatedly applying automorphisms and their inverses to q. It is clear that such a θ satisfies the correctness formula (1), since it is constructed from the automorphisms only.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Adding Scalarsets to Uppaal</head><p>The tool Uppaal is a model checker for networks of timed automata extended with discrete variables (bounded integers, arrays) and blocking, binary synchronization as well as non-blocking broadcast communication (see for instance <ref type="bibr" target="#b20">[21]</ref>). In the remainder of this section we illustrate by an example Uppaal's description language extended with a scalarset type constructor allowing symmetric data types to be syntactically indicated. Our extension is based on the notion of scalarset first introduced by Ip and Dill in the finite-state model checking tool Murϕ <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b18">19]</ref>. Also our extension is based on the C-like syntax to be introduced in the forthcoming version 4.0 of Uppaal.</p><p>To illustrate our symmetry extension of Uppaal we consider Fischer's mutual exclusion protocol. This protocol consists of n process identical up to their unique process identifiers. The purpose of the protocol is to insure mutual exclusion on the critical sections of the processes. This is accomplished by letting each process write its identifier (pid) in a global variable (id) before entering its critical section. If after some given lower time bound (say 2) id still contains the pid of the process, then it may enter its critical section.</p><p>A scalarset of size n may be considered as the subrange {0, 1, . . . , n -1} of the natural numbers. Thus, the n process identifiers in the protocol can be modeled using a scalarset with size n. In addition to the global variable id, we use the array active to keep track of all active locations of the processes <ref type="foot" target="#foot_0">4</ref> . Global declarations are the following:</p><p>typedef scalarset <ref type="bibr" target="#b2">[3]</ref>  The first line defines proc id to be a scalarset type of size 3, and the second line declares id to be a variable over this type. Thus scalarset is in our extension viewed as a type constructor. In the last line we show a declaration of an array indexed by elements of the scalarset proc id.</p><p>At this point the only thing missing is the declaration of the actual processes in the system. In the description language of Uppaal, processes are obtained as instances of parameterized process templates. In general, templates may contain several different parameters (e.g. bounded integers, clocks, and channels). In our extension we allow in addition the use of scalarsets as parameters. In the case of Fischer's protocol the processes of the system are given as instances of the template depicted in Figure <ref type="figure" target="#fig_1">2</ref>. The template has one local clock, x, and no local process Fischer (const proc id pid) variables. Note that the header of the template defines a (constant) scalarset parameter pid of type proc id. Access to the critical section cs is governed by suitable updates and tests of the global scalarset variable id together with upper and lower bound time constraints on when to proceed from requesting access (req) respectively proceed from waiting for access (wait). Note that all transitions update the array active to reflect the current active location of the process. The instantiation of this template and declaration of all three process in the system can be done as follows:</p><p>FischerProcs = forall i in proc_id : Fischer(i); system FischerProcs;</p><p>The forall construct iterates over all elements of a declared scalarset type. In this case the iteration is over proc id and a set of instances of the template Fischer is constructed and bound to FischerProcs. In the second line the final system is defined to be precisely this set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Using Scalarsets for Symmetry Reduction</head><p>As a preliminary to this section we briefly mention the state representation of Uppaal. A state is a tuple (l, v, Z), where l is the location vector, v is the integer variable valuation, and Z is a zone, which is a convex set of clock valuations that can efficiently be represented by a difference bounded matrix (DBM) <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b8">9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Extraction of Automorphisms</head><p>This subsection is a very brief summary of <ref type="bibr" target="#b13">[14]</ref>, to which we refer for further details. The new syntax described in the previous section enables us to derive the following information from a system description:</p><p>-A set Ω of scalarset types.</p><p>-For each α ∈ Ω: (i) a set V α of variables of type α, and (ii) a set D α of pairs (a, n) where a is an array and n is a dimension of a that must be indexed by variables of type α to ensure soundness. We assume that arrays that are indexed by scalarsets do not contain elements of scalarsets. The reason is that this would make computation of a canonical representative as hard as testing for graph isomorphism. -A partial mapping γ : P × Ω → N that gives for each process p and scalarset α the element of α with which p is instantiated. This mapping is defined by quantification over scalarsets in the process definition section.</p><p>This information enables us to derive so-called state swaps. Let Q be the set of states of some Uppaal model, and let α be a scalarset type in the model with size n. A state swap swap α i,j : Q → Q can be defined for all 0 ≤ i &lt; j &lt; n, and consists of two parts:</p><p>-The multiple process swap swaps the contributions to the state of all pairs of processes p and p if they originate from the same template and γ(p, α) = i, γ(p , α) = j and γ(p, β) = γ(p , β) for all β = α ∈ Ω. Swapping such a pair of symmetric processes consists of interchanging the active locations and the values of the local variables and clocks (note that this is not a problem since the processes originate from the same template). -The data swap swaps array entries i and j of all dimensions that are indexed by scalarset α (these are given by the set D α ). Moreover, it swaps the value i with the value j for all variables in V α .</p><p>Consider the instance of Fischer's mutual exclusion protocol (as described in the previous section) with three processes. There are three swap functions:</p><formula xml:id="formula_6">swap proc id 0,1 , swap proc id 0,2</formula><p>and swap proc id 1,2 . Now consider the following state of the model (the active location of the i-th process is given by l i and the local clock of this process is given by x i ):</p><formula xml:id="formula_7">l : l 0 = idle, l 1 = wait, l 2 = cs v : id = 2, set = 1 Z : x 0 = 4, x 1 = 3, x 2 = 2.5 active ; active[0] = 0, active[1] = 2, active[2] = 3</formula><p>When we apply swap proc id 0,2 to this state, the result is the following state:</p><formula xml:id="formula_8">l : l 0 = cs, l 1 = wait, l 2 = idle v : id = 0, set = 1 Z : x 0 = 2.5, x 1 = 3, x 2 = 4 active ; active[0] = 3, active[1] = 2, active[2] = 0</formula><p>The process swap swaps l 0 with l 2 , and x 0 with x 2 . The data swap first changes the value of the variable id from 2 to 0, since id ∈ V proc id , and then swaps the values of active[0] and active <ref type="bibr" target="#b1">[2]</ref>. Applying swap proc id 1,2 to this state gives the following state:</p><formula xml:id="formula_9">l : l 0 = cs, l 1 = idle, l 2 = wait v : id = 0, set = 1 Z : x 0 = 2.5, x 1 = 4, x 2 = 3 active ; active[0] = 3, active[1] = 0, active[2] = 2</formula><p>Note that this swap does not change the value of id, since the scalarset elements 1 and 2 are interchanged and id contains scalarset element 0.</p><p>A number of syntactic checks have been identified that ensure that the symmetry suggested by the scalarsets is not broken. These checks are very similar to those originally identified for the Murϕ verification system <ref type="bibr" target="#b18">[19]</ref>. For instance, it is not allowed to use variables of a scalarset type for arithmetical operations such as addition. The next soundness theorem has been proven in <ref type="bibr" target="#b13">[14]</ref>: Theorem 1 (Soundness). Every state swap is an automorphism.</p><p>As a result, the representative function θ can be implemented by minimization of the state using the state swaps. Note that every state swap resembles a transposition of the state. Hence, the equivalence classes induced by the state swaps originating from a scalarset with size n consist of at most n! states. The maximal theoretical gain that can be achieved using this set of automorphisms is therefore in the order of a factor n!.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Computation of Representatives</head><p>The representative of a state is defined as the minimal element of the symmetry class of that state w.r.t. a total order ≺ on the symmetry class. In general, the DBM representation of zones renders an efficient canonical minimization algorithm impossible, since minimization of a general DBM for any given total order using state swaps is at least as difficult as testing for graph isomorphism for strongly regular graphs <ref type="bibr" target="#b13">[14]</ref>. If we assume, however, that the timed automaton that is analyzed resets its clocks to zero only, then the zones (DBMs) that are generated by the forward state space exploration satisfy the nice diagonal property. This property informally means that the individual clocks can always be ordered using the order in which they were reset. To formalize this, three binary relations on the set of clocks parameterized by a zone Z are defined:</p><formula xml:id="formula_10">x Z y ⇐⇒ ∀ ν∈Z ν(x) ≤ ν(y) (3) x ≈ Z y ⇐⇒ ∀ ν∈Z ν(x) = ν(y) (4) x ≺ Z y ⇐⇒ (x Z y ∧ ¬(x ≈ Z y))<label>(5)</label></formula><p>The diagonal property is then defined as follows.</p><p>Lemma 1 (Diagonal Property). Consider the state space exploration algorithm described in figure <ref type="figure">6</ref> of <ref type="bibr" target="#b20">[21]</ref>. Assume that the clocks are reset to the value 0 only. For all states (l, v, Z) stored in the waiting and passed list and for all clocks x and y holds that either x ≺ Z y, or x ≈ Z y or y ≺ Z x.</p><p>Using the reset order on clocks and the diagonal property, we can define a total order, say ≺, on all states within a symmetry class whose minimal element can be computed efficiently. To this end we first assume a fixed indexing of the set of clocks X: a bijection ρ : X → {1, 2, . . . , |X|}. Now note that ≈ Z is an equivalence relation that partitions X in P = {X 1 , X 2 , . . . , X n }. We define a relation on the cells of P as follows:</p><formula xml:id="formula_11">X i ≤ X j ⇐⇒ ∀ x∈Xi,y∈Xj x Z y<label>(6)</label></formula><p>Clearly this is a total order on P . Let X i be a cell of P . The code of X i , denoted by C * (X i ), then is the lexicographically sorted sequence of the indices of the clocks in X i (the set {ρ(x) | x ∈ X i }). The zone code of the zone which induced P is then defined as follows.</p><p>Definition 3 (Zone code). Let Z be a zone and let P = {X 1 , X 2 , . . . , X n } be the partitioning of the set of clocks X under ≈ Z such that i ≤ j ⇒ X i ≤ X j (we can assume this since ≤ is a total order on P ). The zone code of Z, denoted by C(Z), is the sequence (C * (X 1 ), C * (X 2 ), . . . , C * (X n )).</p><p>Note that every zone has exactly one zone code since the indices of equivalent clocks are sorted. Moreover, zone codes can lexicographically be ordered, since they are sequences of number sequences. This order is then used in the following way to define a total order on the states in a symmetry class (the orders on the location vectors and variable valuations are just the lexicographical order on sequences of numbers):</p><formula xml:id="formula_12">(l, v, Z) ≺ (l , v , Z ) ⇐⇒ (l &lt; l ) ∨ (l = l ∧ v &lt; v ) ∨ (l = l ∧ v = v ∧ C(Z) &lt; C(Z )) (7)</formula><p>We minimize the state w.r.t. the order of equation ( <ref type="formula">7</ref>) using the state swaps by applying the bubble-sort algorithm to it, see Figure <ref type="figure">3</ref>. It is clear that this representative computation satisfies the soundness equation ( <ref type="formula" target="#formula_2">1</ref>), since states are transformed using the state swaps only, which are automorphisms by Theorem 1. We note that swap α j-1,j (q) is not computed explicitly for the comparison in the fourth line of the algorithm; using the statically derived γ, D α and V α (see section 4.1) we are able to tell whether swapping results in a smaller state.</p><p>(1) for all α ∈ Ω do <ref type="bibr" target="#b1">(2)</ref> for i = 1 to |α| do (3)</p><p>for j = 1 to |α| -i do (4)</p><p>if swap α j-1,j (q) ≺ q then (5) q := swap α j-1,j (q) (6) od ( <ref type="formula">7</ref>) od (8) od Fig. <ref type="figure">3</ref>. Minimization of state q using the bubble-sort algorithm. The size of scalarset type α is denoted by |α|.</p><p>The following theorem states the main technical contribution of our work. Informally, it means that the detected symmetries are optimally used.</p><p>Theorem 2 (Canonical Representative). The algorithm in Figure <ref type="figure">3</ref> computes a canonical representative.</p><p>Note that we assumed that arrays that are indexed by scalarsets do not contain elements of scalarsets. Otherwise, computation of a canonical representative is as hard as graph isomorphism, but this is entirely due to the discrete part of the model, and not to the clock part.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experimental Results</head><p>This section presents and discusses experimental data that was obtained by the Uppaal prototype on a dual Athlon 2000+ machine with 3 GB of RAM. The measurements were done using the tool memtime, for which a link can be found at the Uppaal website http://www.uppaal.com/.</p><p>In order to demonstrate the effectiveness of symmetry reduction, the resource requirements for checking the correctness of Fischer's mutual exclusion protocol were measured as a function of the number of processes for both regular Uppaal and the prototype, see that the verification of the protocol for 20 processes without symmetry reduction would take 115 days and 1000 GB of memory, whereas this verification can be done within approximately one second using less than 10 MB of memory with symmetry reduction.</p><p>Similar results have been obtained for the CSMA/CD protocol ( <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b26">27]</ref>) and for the timeout task of a distributed agreement algorithm<ref type="foot" target="#foot_1">5</ref>  <ref type="bibr" target="#b3">[4]</ref>. To be more precise, regular Uppaal's limit for the CSMA/CD protocol is approximately 10 processes, while the prototype can easily handle 50 processes. Similarly, the prototype can easily handle 30 processes for the model of the timeout task, whereas regular Uppaal can only handle 6.</p><p>Besides the three models discussed above, we also investigated the gain of symmetry reduction for two more complex models. First, we experimented with the previously mentioned agreement algorithm, of which we are unable to verify an interesting instance even with symmetry reduction due to the size of the state space. Nevertheless, symmetry reduction showed a very significant improvement. Second, we experimented with a model of Bang &amp; Olufsen's audio/video protocol <ref type="bibr" target="#b12">[13]</ref>. The mentioned paper describes how Uppaal is used to find a bug in the protocol, and it describes the verification of the corrected protocol for two (symmetric) senders. Naturally, we added another sender -verification of the model for three senders was impossible at the time of the first verification attemptand we found another bug, whose source and implications we are investigating at the time of this writing. Table <ref type="table">1</ref> shows run-time data for these models. Table <ref type="table">1</ref>. Comparing the time and memory consumption of the relations for the agreement algorithm and for Bang &amp; Olufsen's audio/video protocol with two and three senders. The exact parameters of the agreement model are the following: n = 2, f = 1, ones = 0, c1 = 1, c2 = 2 and d varied (the value is written between the brackets). Furthermore, the measurements were done for the verification of the agreement invariant only. Three verification runs were measured for each model and the best one w.r.t. time is shown.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Model Time [s] Memory [MB]</head><p>Agreement (0) Agreement ( <ref type="formula" target="#formula_2">1</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions</head><p>The results we obtained with our prototype are clearly quite promising: with relatively limited changes/extensions of the Uppaal code we obtain a rather drastic improvement of performance for systems with symmetry that can be expressed using scalarsets.</p><p>An obvious next step is to do experiments concerning profiling where computation time is spent, and in particular how much time is spent on computing representatives. In the tool Design/CPN <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b10">11]</ref> (where symmetry reduction is a main reduction mechanism) there have been interesting prototype experiments with an implementation in which the (expensive) computations of representatives were launched as tasks to be solved in parallel with the main exploration algorithm.</p><p>The scalarset approach that we follow in this paper only allows one to express total symmetries. An obvious direction for future research will be to study how other types of symmetry (for instance as we see it in a token ring) can be exploited.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. A general forward reachability analysis algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. The template for Fischer's protocol.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 .Fig. 4 .</head><label>44</label><figDesc>Fig.4. Run-time data for Fischer's mutual exclusion protocol showing the enormous gain of symmetry reduction. The step in the graph of the memory usage is probably due to the the fact that Uppaal allocates memory in chunks of a few megabyte at a time.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_0"><p>This array is actually redundant and not present in the standard formulations of the protocol. However, it is useful for showing important aspects of our extension.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_1"><p>Models of the agreement algorithm and its timeout task are available through the URL http://www.cs.kun.nl/∼martijnh/</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Supported by the European Community Project IST-2001-35304 (AMETIST), http://ametist.cs.utwente.nl.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">An old-fashioned recipe for real time</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1543" to="1571" />
			<date type="published" when="1994-09">September 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Model checking in dense real time</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Courcoubetis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">104</biblScope>
			<biblScope unit="page" from="2" to="34" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Automata for modeling real-time systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">17th International Colloquium on Automata, Languages, and Programming</title>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="322" to="335" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Bounds on the time to reach agreement in the presence of timing uncertainty</title>
		<author>
			<persName><forename type="first">H</forename><surname>Attiya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Dwork</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Lynch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Stockmeyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="122" to="152" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Dynamic Programming</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bellman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1957">1957</date>
			<publisher>Princeton University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A heuristic for symmetry reductions with scalarsets</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bosnacki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Holenderski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FME 2001, number 2021 in LNCS</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">N</forename><surname>Oliveira</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Zave</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="518" to="533" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Exploiting symmetry in temporal logic model checking</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Enders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Filkorn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Methods in System Design</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">1/2</biblScope>
			<biblScope unit="page" from="77" to="104" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Peled</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Model Checking. The MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Timing assumptions and verification of finite-state concurrent systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Automatic Verification Methods for Finite State Systems, number 407 in LNCS</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Sifakis</surname></persName>
		</editor>
		<meeting>of Automatic Verification Methods for Finite State Systems, number 407 in LNCS</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="197" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Protocol verification as a hardware design aid</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Drexler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">Han</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Computer Design: VLSI in Computers and Processors</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="522" to="525" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">The Symmetry Method for Coloured Petri Nets -Theory, Tools, and Practical Use</title>
		<author>
			<persName><forename type="first">L</forename><surname>Elgaard</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002-07">July 2002</date>
			<pubPlace>Denmark</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computing Science, University of Aarhus</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Symmetry and model checking</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Sistla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV&apos;93, number 697 in LNCS</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Formal modelling and analysis of an audio/video protocol: An industrial case study using uppaal</title>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Skou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Lund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">18th IEEE Real-Time Systems Symposium</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="2" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Enhancing uppaal by exploiting symmetry</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hendriks</surname></persName>
		</author>
		<idno>NIII- R0208</idno>
		<imprint>
			<date type="published" when="2002-10">October 2002</date>
		</imprint>
		<respStmt>
			<orgName>NIII, University of Nijmegen</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Adding symmetry reduction to uppaal</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hendriks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Behrmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Niebert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">W</forename><surname>Vaandrager</surname></persName>
		</author>
		<idno>NIII-R03xx</idno>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>University of Nijmegen</publisher>
			<biblScope unit="volume">NIII</biblScope>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wong-Toi</surname></persName>
		</author>
		<title level="m">HyTech: A model checker for hybrid systems. Software Tools for Technology Transfer</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="110" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The spin model checker</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Holzmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="279" to="295" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Reachability trees for high-level petri nets</title>
		<author>
			<persName><forename type="first">P</forename><surname>Huber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">O</forename><surname>Jepsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Jensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="261" to="292" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Better verification through symmetry</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">N</forename><surname>Ip</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Hardware Description Languages and their Applications</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Agnew</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Claesen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Camposano</surname></persName>
		</editor>
		<meeting><address><addrLine>Ottawa, Canada; Amsterdam, The Netherlands</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier Science Publishers B.V</publisher>
			<date type="published" when="1993">1993. 1996</date>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="41" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Condensed state spaces for symmetrical Coloured Petri Nets</title>
		<author>
			<persName><forename type="first">K</forename><surname>Jensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Methods in System Design</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">1/2</biblScope>
			<biblScope unit="page" from="7" to="40" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Uppaal in a nutshell</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pettersson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Yi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal on Software Tools for Technology Transfer</title>
		<imprint>
			<biblScope unit="page" from="134" to="152" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
		<title level="m">Symbolic Model Checking</title>
		<meeting><address><addrLine>Pittsburgh</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992-05">May 1992</date>
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Reachability analysis of petri nets using symmetries</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">H</forename><surname>Starke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Syst. Anal. Model. Simul</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="293" to="303" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Computer Networks</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Tanenbaum</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Efficient data structure for fully symbolic verification of real-time software systems</title>
		<author>
			<persName><forename type="first">F</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS&apos;00, number 1785 in LNCS</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Graf</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Schwartzbach</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="157" to="171" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Symmetric symbolic safety-analysis of concurrent software with pointer data structures</title>
		<author>
			<persName><forename type="first">F</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Schmidt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FORTE&apos;02, number 2529 in LNCS</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Peled</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="50" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Kronos: a verification tool for real-time systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Yovine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal on Software Tools for Technology Transfer</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
