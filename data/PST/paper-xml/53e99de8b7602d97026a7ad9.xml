<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient Gradient-Domain Compositing Using Quadtrees</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Aseem</forename><surname>Agarwala</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Adobe Systems</orgName>
								<address>
									<region>Inc</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Efficient Gradient-Domain Compositing Using Quadtrees</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T13:07+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We describe a hierarchical approach to improving the efficiency of gradient-domain compositing, a technique that constructs seamless composites by combining the gradients of images into a vector field that is then integrated to form a composite. While gradient-domain compositing is powerful and widely used, it suffers from poor scalability. Computing an n pixel composite requires solving a linear system with n variables; solving such a large system quickly overwhelms the main memory of a standard computer when performed for multi-megapixel composites, which are common in practice. In this paper we show how to perform gradient-domain compositing approximately by solving an O(p) linear system, where p is the total length of the seams between image regions in the composite; for typical cases, p is O( √ n). We achieve this reduction by transforming the problem into a space where much of the solution is smooth, and then utilize the pattern of this smoothness to adaptively subdivide the problem domain using quadtrees. We demonstrate the merits of our approach by performing panoramic stitching and image region copy-and-paste in significantly reduced time and memory while achieving visually identical results.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Many recent algorithms for combining regions of multiple photographs or videos into a seamless composite operate in the gradient domain. Rather than copying absolute colors from the source images into a composite, these algorithms instead copy color gradients between source pixels and their immediate neighbors to form a composite vector field. A composite image (or video) whose gradients best match this composite vector field in a least squares sense is then reconstructed by solving a linear system (equivalent to the discretized Poisson equation) whose variables are the colors of each pixel <ref type="bibr">[Pérez et al. 2003</ref>].</p><p>This technique is one of the most widely used algorithms in computational photography and video; unfortunately, however, it does not scale well to the multi-megapixel digital imagery common today. Solving a linear system on the order of the number of pixels quickly becomes prohibitive both in terms of time and space. Thus, despite the broad applicability of gradient-domain techniques, this poor scalability has limited their adoption in digital photography software. <ref type="foot" target="#foot_0">1</ref>In this paper, we describe a simple and novel approach to gradientdomain compositing that greatly reduces the scale of the problem. We show how to approximately compute an n pixel gradient-Figure <ref type="figure">1</ref> A 17-megapixel panorama shot with a hand-held camera. (First row) Panorama created by simply copying colors from the source images. Notice the subtle vertical seams caused by variations in exposure. (Second row) The gradient-domain composite. (Third row) A visualization of the difference between the first two images. The key observation of our work is that this difference exhibits intricate detail near the seams between image regions, but becomes progressively smoother away from these seams. (Fourth row) To take advantage of this smoothness, we subdivide the domain using a quadtree such that maximum subdivision occurs along the seams. (Fifth row) The result computed in this reduced space, which can be computed much more efficiently, is visually identical to the full gradient-domain solution. The numerical error is shown in Table <ref type="table">1</ref>. Images courtesy of Tobias Oberlies.</p><p>domain composite by solving a linear system whose number of variables is O(p) rather than n, where p is the total length of the seams between the image regions in the composite. This length will be much smaller than n, and can be shown to be O( √ n) for typical cases. Solving this reduced system greatly reduces time and memory requirements yet achieves results that are visually identical. We achieve this efficiency increase by observing that the difference between a simple color composite and its associated gradientdomain composite is largely smooth (Figure <ref type="figure">1</ref>), and the pattern of this smoothness can be predicted a priori. We thus solve for this difference, and adaptively subdivide the domain using a quadtree (a hierarchical spatial data structure <ref type="bibr" target="#b21">[Samet 1990</ref>]) so that smoother areas of the solution are interpolated using fewer variables.</p><p>Efficient algorithms for solving the Poisson equation such as multigrid methods <ref type="bibr" target="#b20">[Saad 2003</ref>] are well-studied and can be adapted to the GPU <ref type="bibr" target="#b5">[Bolz et al. 2003]</ref>. <ref type="bibr" target="#b27">Szeliski [2006]</ref> recently introduced a preconditioner that greatly accelerates the convergence of an iterative conjugate gradient solver. These techniques, however, do nothing to address the fundamental scale of the problem; they still require solving linear systems on the order of the number of pixels. Thus, even though the number of iterations required to solve the linear system may be greatly reduced, the O(n) memory required by a sparse solver can still quickly overwhelm the capabilities of a typical computer. Worse, iterative solvers do not exhibit the data reuse patterns that would make them well-suited to an efficient out-ofcore implementation <ref type="bibr" target="#b28">[Toledo 1999</ref>], since iterations computed only within a local area of the domain may not make significant progress towards the correct, global solution. In contrast, by solving an O(p) variable linear system we can compute very large gradient-domain composites in surprisingly little memory (Table <ref type="table" target="#tab_2">2</ref>). The main memory used by our approach is O(p) (since the input and output images are streamed through the algorithm tile-by-tile), but asymptotically the execution time is still O(n) since each input and output pixel must be visited. However, those stages of our algorithm that are O(n) are not time-consuming, and the solution of the O(p) linear system remains the bottleneck.</p><p>We are not the first to adaptively vary resolution when solving linear systems or discretized partial differential equations. <ref type="bibr" target="#b16">Losasso et al. [2004]</ref> performed large-scale fluid simulations by solving the Poisson equation on octree grids, and <ref type="bibr" target="#b25">Szeliski and Shum [1996]</ref> used quadtrees for hierarchical motion estimation in video. To the best of our knowledge, however, we are the first to show how quadtrees can be applied to efficient gradient-domain compositing, and the transformations of the problem necessary to make this approach effective. We are also the first to demonstrate very large gradient-domain composites computed in reasonable time and, more importantly, space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Gradient-domain compositing</head><p>Gradient-domain compositing hides seams between composited image regions by converting high-frequency artifacts that may appear at the boundaries between composited regions into lowfrequency variations that spread across the image. This approach is effective because the human visual system is much more sensitive to local contrast than to slow changes in luminance and chrominance <ref type="bibr" target="#b18">[Palmer 1999</ref>]. Gradient-domain compositing takes advantage of lightness constancy -our ability to discount the effects of scene illumination in order to perceive the true reflectivity of a scene. Retinex theory <ref type="bibr" target="#b14">[Land 1977</ref>] suggests that humans achieve lightness constancy by perceiving scene lightness only through local luminance ratios at edges; low-frequency variations in luminance are discounted as the effects of illumination.</p><p>The usefulness of combining image regions in the gradient-domain was first described by <ref type="bibr">Perez et al. [2003]</ref>; they demonstrated the ability to seamlessly copy a region from one image into another, as well as a variety of other image editing operations. <ref type="bibr" target="#b9">Georgiev [2004]</ref> revealed that the Adobe Photoshop Healing Brush uses a similar technique, and <ref type="bibr" target="#b12">Jia et al. [2006]</ref> improved on this basic approach by first optimizing the boundary of the copied region. <ref type="bibr" target="#b0">Agarwala et al. [2004]</ref> extended gradient-domain compositing to the case of compositing an entire image from regions of many sources, within the context of a general, interactive framework for combining sets of images into a photomontage. This system used both graph cuts <ref type="bibr" target="#b13">[Kwatra et al. 2003</ref>] for optimal seam selection and gradient-domain compositing for removing any artifacts remaining at the seams. This approach has been used to fill holes in images <ref type="bibr" target="#b11">[Hays and Efros 2007]</ref> and to compute multi-viewpoint <ref type="bibr" target="#b2">[Agarwala et al. 2006</ref>] and video panoramas <ref type="bibr" target="#b1">[Agarwala et al. 2005]</ref>. Others have confirmed <ref type="bibr" target="#b15">[Levin et al. 2004;</ref><ref type="bibr" target="#b31">Zomet et al. 2006;</ref><ref type="bibr" target="#b10">Goldman and Chen 2005</ref>] that gradient-domain compositing is a crucial component in state-of-the-art techniques for seamless panoramic stitching after the images have been aligned. Finally, <ref type="bibr" target="#b29">Wang et al. [2004]</ref> were the first to adapt gradient-domain compositing to video.</p><p>The technique described in this paper should be applicable in all of the compositing systems just described. Gradient-domain techniques are not only used for compositing image regions, however. Various operations can be performed by creating an image that best matches a specified gradient-field; recent examples include high dynamic range (HDR) compression <ref type="bibr" target="#b7">[Fattal et al. 2002]</ref>, intrinsic image recovery <ref type="bibr" target="#b30">[Weiss 2001</ref>], shadow removal <ref type="bibr" target="#b8">[Finlayson and Drew 2002]</ref>, flash artifact correction <ref type="bibr" target="#b3">[Agrawal et al. 2005]</ref>, reproducing photographic look <ref type="bibr" target="#b4">[Bae et al. 2006]</ref>, and alpha matting <ref type="bibr" target="#b24">[Sun et al. 2004]</ref>. One drawback of our approach is that increases in efficiency will only occur if the problem can be transformed into a space where the solution is mostly smooth, and the pattern of smoothness can be predicted a priori. This transformation may not be possible for all problems, however, and the degree of smoothness will affect the gains in efficiency. We discuss the possibility of more widely applying our approach in Section 5. Finally, computing a large linear system is not the only way to solve Poisson equations; Fourier transforms can be used to directly calculate a solution <ref type="bibr" target="#b23">[Simchony et al. 1990</ref>]. However, this approach requires O(n lg n) time, and more importantly, O(n) memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Mathematical formulation</head><p>Gradient-domain compositing is performed for a single color channel of an image by re-ordering the image pixels into a vector x and solving for the x that best matches the desired horizontal and vertical gradients ∇I x , ∇I y . There are various possibilities for choosing these gradients. When compositing a region from image I A into image I B <ref type="bibr">[Pérez et al. 2003;</ref><ref type="bibr" target="#b12">Jia et al. 2006</ref>], the gradients inside this region are ∇I A and the colors at the boundaries are fixed from image I B . When simultaneously compositing multiple regions from multiple images, the simplest approach <ref type="bibr" target="#b0">[Agarwala et al. 2004</ref>] is to use the gradient of the source image between any two pixels inside of one region, and the average of the gradients of the two source images between any two pixels that straddle a boundary between two regions.</p><p>Each horizontal and vertical gradient specifies a single linear constraint on two variables, all of which can be expressed in matrix form as</p><formula xml:id="formula_0">Ax = b (1)</formula><p>where x is of length n (one element for each pixel), and A has at most two non-zero elements per row. This system of equations is overconstrained, and thus the solution x that minimizes Ax − b in a least squares sense is the solution to the normal equations</p><formula xml:id="formula_1">A T Ax = A T b (2)</formula><p>where the sparse, banded square matrix A T A has at most five nonzero elements per row. Since this linear system is large it is typically solved using an iterative solver such as conjugate gradient <ref type="bibr" target="#b22">[Shewchuk 1994</ref>] whose inner loop performs the sparse matrixvector multiplication A T Ax. This multiplication is equivalent to applying the Laplacian<ref type="foot" target="#foot_2">2</ref> to x, and thus can be applied procedurally without storing A T A. The initial condition x 0 of the iterative solver is typically set to the image that would result from simply copying colors (rather than gradients) from the source images (e.g., first row of Figure <ref type="figure">1</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Scalability issues</head><p>Consider using this approach to composite a panorama. A top-end digital SLR can produce 16 megapixel images, so a panorama from several such photographs can easily contain 50 megapixels (and often more). At a bare minimum, solving the n-element linear system in equation ( <ref type="formula">2</ref>) for one color channel requires storing five floating point vectors of length n -one vector for x, one for A T b, and three temporary vectors of storage during conjugate gradient iterations. Assuming four bytes per float, computing one channel of a 50 megapixel panorama would require one gigabyte of memory for these five vectors alone. The running time of this basic conjugate gradient solver would also be painfully long. Pyramidal approaches such as multigrid accelerate convergence but require even more memory; <ref type="bibr" target="#b27">Szeliski [2006]</ref>, for example, reports memory footprints that are roughly doubled.</p><p>As we show in the next section, this memory consumption is simply unnecessary; we can achieve visually equivalent results by solving a dramatically smaller linear system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Our approach</head><p>The key to our approach is to solve the problem in a reduced space by assuming certain regions of the solution are smooth. The solution vector x itself is a natural image that will not typically be very smooth. Observe, however, that the initial residual b − Ax 0 will be zero for any pixel not adjacent to a seam, since the colors of that pixel and its neighbors were copied from one image and thus already satisfy the gradient constraints. If we substitute for x the sum x = x 0 + x δ , where x δ is the difference between the initial condition and final solution, the normal equations become</p><formula xml:id="formula_2">A T Ax δ = A T (b − Ax 0 ).<label>(3)</label></formula><p>Note that the right hand side of this equation will be zero for any pixel not adjacent to a seam. Regions of an image with a zero Laplacian will be very smooth. Thus, we can see that the offset x δ to the initial condition x 0 will be very smooth away from the seams between image regions, even if the final image x is not smooth anywhere. An example of this pattern of smoothness for x δ is shown in the third row of Figure <ref type="figure">1</ref>.</p><p>Once this pattern of smoothness is realized, it becomes obvious that representing each pixel in a smooth area with one variable is wasteful; these areas can accurately be interpolated with fewer variables with larger regions of support. We can imagine varying the resolution of a solution vector adaptively; high resolution could be used near seams, and progressively lower resolutions in areas farther away from seams.</p><p>To accomplish this vision, we transform the full resolution problem in equation ( <ref type="formula">1</ref>) into a reduced space</p><formula xml:id="formula_3">ASy = b (4)</formula><p>by substituting x = Sy, where y is a vector of dimension m such that m n, and S is an m × n matrix that transforms from the reduced to the full space. Since the solution will not be smooth near seams, we wish any pixel adjacent to a seam to be represented with a single variable, just as in the full-resolution problem. Pixels in smoother areas may be interpolated as a weighted sum of several elements of y. The regions of support for interpolating x from elements of y should be larger further away from the seams. Given the interpolation x = Sy, the normal equations for the offset y δ are</p><formula xml:id="formula_4">S T A T ASy δ = S T A T (b − ASy 0 ).<label>(5)</label></formula><p>Once the matrix S T A T AS on the left and vector S T A T (b − ASy 0 ) on the right are pre-computed, the inner loop of an iterative solver for this linear system becomes an m × m rather than n × n sparse matrix-vector multiplication.</p><p>To define the matrix S we adaptively subdivide the problem domain using a quadtree <ref type="bibr" target="#b21">[Samet 1990</ref>] that is maximally subdivided</p><p>Figure <ref type="figure">2</ref> An inset of a grid of pixels in a larger gradient-domain composite. The green pixels are assigned to one source image, and the pink pixels to another; thus, a seam exists between them. The red lines are the boundaries of quadtree leaf nodes. The corners of quadtree nodes lie at pixel centers, and the quadtree is maximally subdivided along the seam.</p><p>In the full linear system, each pixel is represented by one variable in the solution vector x. In the reduced linear system, variables in the solution vector y exist at the corners of the quadtree nodes (the blue dots), except along T-junctions where quadtree nodes of different sizes abut. We can interpolate the full solution x from a reduced solution y by computing x = Sy. This interpolation (which can be computed procedurally without ever building matrix S) is defined by the structure of the quadtree. Pixels that enclose a blue dot do not need to be interpolated; these values in x are just copied from the appropriate variable in y (which corresponds to a row in matrix S that is all 0 except for a single 1). Other pixels are interpolated; for example, the pixel enclosing the orange dot can be bi-linearly interpolated from the four corners of the enclosing quadtree node (which corresponds to a row of S with four non-zero values that sum to 1). One complication is that the lower-left corner of this node is not a variable in y, since it lies on a T-junction; the value here must first be linearly interpolated from the values of y at the blue dots above and below (not pictured).</p><p>to pixel-sized nodes along the seams (a visualization of such a quadtree can be seen in Figure <ref type="figure">1</ref>). We represent the quadtree with a pointer-based tree where each non-leaf node has four children that subdivide space into four quadrants. The root node corresponds to the smallest square that can entirely contain the image domain and whose width is a power of two. Variables in the reduced space (elements of y δ ) are placed at the corners between leaf nodes, as shown in Figure <ref type="figure">2</ref>. Each leaf node stores the indices of the variables at its four corners. To ensure a gradual reduction in resolution away from the seams, we force the quadtree to be restricted; no two nodes that share an edge may differ in tree depth by more than one.</p><p>Given this quadtree and the values of a vector y δ , the interpolation x δ = Sy δ can be computed with a single traversal of the quadtree, as shown in Figure <ref type="figure">2</ref>. Note that the matrix S does not need to be explicitly built since it simply encodes a bi-linear interpolation from quadtree nodes to pixels. That is, each pixel of x δ is set as the bilinear interpolation of the values of y δ at the four corners of the enclosing quadtree node. One exception is that we do not place variables at corners that lie at T-junctions between neighboring nodes of different depth; instead, T-junctions are interpolated from the two corners of the larger node along the horizontal stem of the "T".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Implementation details</head><p>Our overall algorithm can be be broken into three stages. In the input stage, the quadtree is constructed. Note that the colors of input image pixels appear only in the right-hand side of equation ( <ref type="formula" target="#formula_4">5</ref>), and are non-zero only for pixels adjacent to a seam. Thus, in this input stage the colors of the relevant input images are stored only at leaf nodes bordering a seam. Each input image (or tile of an input image) can be immediately discarded after traversing the quadtree to store these colors.</p><p>The second stage is the computation of the linear system in equation ( <ref type="formula" target="#formula_4">5</ref>). The right-hand side vector, which is computed only once per color channel, is non-zero only for variables that border seams. Table <ref type="table">1</ref> Performance of three algorithms for several gradient-domain compositing problems. For each dataset, we show the number of megapixels, the number of variables per color channel in the reduced linear system as a percentage of the total number of pixels, and the error between the solutions computed using the reduced and full linear systems (error is measured using the 8-bit red channel, with both an average per-pixel RMS error and the maximum error across all pixels). We show the time and memory performance of three algorithms: quadtree-based (QT), hierarchical basis preconditioning (HB), and locally adapted hierarchical basis preconditioning (LHB). Each panorama was stitched from five source images.</p><p>Since these variables always correspond to single pixels (Figure <ref type="figure">2</ref>), the S and S T matrices on the right-hand side do nothing but change the index of the variable. The right-hand side is therefore easy to compute procedurally in a single quadtree traversal. The matrix S T A T AS on the left-hand side can also be computed procedurally in a single quadtree traversal by summing the contribution of the gradient constraint between each pair of neighboring pixels along the edges of quadtree nodes (the Laplacian of pixels internal to a quadtree node will be zero and thus can be ignored). We compute this matrix once and store it in a sparse, symmetric form. The fourneighbor quadtree traversal algorithm of Fuhrmann <ref type="bibr">[1988]</ref> is useful during the setup of the linear system, which is then solved using preconditioned conjugate gradients. We precondition using a standard incomplete Cholesky factorization <ref type="bibr" target="#b20">[Saad 2003</ref>], though even diagonal preconditioning is sufficient given the reduced size of the system. Note that there is never a need to allocate any O(n) storage during this stage; the memory allocated is O(m).</p><p>In the third and final output stage, the interpolated solution x δ is added to the initial composite x 0 . To avoid allocating the entire x δ , the interpolation x δ = Sy δ can be performed independently for subregions (tiles) of the output image.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Scale of the reduced space</head><p>Since the input and output stages can be performed by streaming over arbitrarily small tiles of the source images, the memory and time requirements of our algorithm are bounded by the solution of an m-variable linear system. How small is m compared to n? The quadtree used here is equivalent to a region quadtree that represents a 2D array whose elements can be values in a small, discrete range. <ref type="bibr" target="#b6">Dyer [1982]</ref> showed that the number of quadtree nodes in a region quadtree is O(p), where p is the perimeter of the regions in the array, i.e., the total length of the seams. Our quadtree is restricted, but <ref type="bibr" target="#b17">Moore [1995]</ref> showed that restriction only increases the number of nodes by a constant factor. Since m is linearly proportional to the number of leaf nodes in the quadtree, m is O(p). The growth of p will depend on how the seams are chosen; for typical cases, we observe that p is O( √ n). For example, if a single rectangular region is chosen from each one of a constant number of input images, p will be O( √ n) since the perimeter of each region is upper-bounded by the perimeter of the composite (which is O( √ n) assuming the width and height of the composite are related by a constant factor). The same upper-bound is true for a polygonal region with a constant number of sides. Seams chosen using graph cuts <ref type="bibr" target="#b13">[Kwatra et al. 2003</ref>] will typically also be short since lengths are minimized by their cost functions, though one can imagine pathological inputs that would cause p to exceed O( √ n).  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Experimental results</head><p>We compare the performance of our technique against our implementation of two other algorithms for several datasets of different sizes (Table <ref type="table">1</ref>), and show several results that were too large to compute in available memory using other algorithms (Table <ref type="table" target="#tab_2">2</ref>). Most of our results are panoramas whose seams were computed using hierarchical graph cuts <ref type="bibr" target="#b1">[Agarwala et al. 2005]</ref>, though the first result in Table <ref type="table">1</ref> demonstrates image region copy-and paste with manually chosen seams. In the interest of space, most of our results can only be seen on the project web site, although the Rainier dataset is shown in Figure <ref type="figure">1</ref>.</p><p>We compare against two approaches for solving the full linear system. The first is locally adapted hierarchical basis preconditioning (LHB) <ref type="bibr" target="#b27">[Szeliski 2006</ref>], one of the fastest current approaches to solving gradient-domain problems. We also compare against the older hierarchical basis (HB) approach <ref type="bibr" target="#b26">[Szeliski 1990</ref>], because unlike LHB, it requires no additional memory to perform preconditioning and thus can be considered a lower bound on the memory required to solve the full linear system. Along with performance comparisons, we also measure the error introduced by our reduction of the linear system by comparing its interpolated result (i.e., Sy) against the solution of the full linear system computed by LHB.</p><p>The reduced linear system is typically over 99% smaller. While it only approximates the full solution, the results are visually identical; when the images computed using both systems are rapidly flipped back and forth, no differences can be seen. Even when we scale the computed offsets by ten to generate the visualization in the third row of Figure <ref type="figure">1</ref>, no differences are visible. The error values in Table <ref type="table">1</ref> explain why. For color values that range from 0 to 255, the per-pixel RMS error is in the hundredths. The maximum error tells us that, once rounded to the nearest integer, color values differ by at most two for these examples. Differences this rare and small are simply not visible to the naked eye.</p><p>While the quality of the result remains the same, the reductions in both time and memory are dramatic. For all algorithms, the iterative solver was terminated when the sum of squared residuals (i.e., ||Ax − b|| 2 for the linear system Ax = b) was less than 10 −11 times the number of pixels; this error tolerance is aggressively low, but gives us a high confidence that each result has converged. The LHB approach terminated in very few iterations (typically around 20 for our error tolerance irregardless of the number of pixels in the dataset), but the sheer size of the full system and the time required to setup the locally adapted pyramids causes its performance to be slower. Note that the performance numbers do not include resources consumed when reading and writing data from disk.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Future work</head><p>Our approach is very efficient at compositing image regions in the gradient-domain; an obvious extension is to perform gradientdomain compositing for video <ref type="bibr" target="#b29">[Wang et al. 2004;</ref><ref type="bibr" target="#b1">Agarwala et al. 2005]</ref>, where scalability concerns are even greater. This extension should be straightforward using octrees rather than quadtrees.</p><p>Our technique is effective because we can create an initial solution to the linear system whose residual is sparse. The same can be said about several other gradient-domain problems, such as shadow removal <ref type="bibr" target="#b8">[Finlayson and Drew 2002]</ref>, removal of reflections in flash images <ref type="bibr" target="#b3">[Agrawal et al. 2005]</ref>, and reproduction of photographic look <ref type="bibr" target="#b4">[Bae et al. 2006</ref>], since in these cases the desired gradient field largely matches the original image except for certain gradients that are damped or set to zero. This observation suggests that our approach could be used to improve their efficiency. However, it cannot be directly applied to other gradient-domain problems for which no such initial solution exists.</p><p>We also plan to explore an extension that may allow more efficient out-of-core reconstruction from general gradient fields. A solution could be computed for each tile of an image independently, thus creating an initial solution with non-zero residuals only along tile boundaries. Then, a quadtree could be subdivided along these tile boundaries and used to compute an offset to the initial solution that corrects the errors introduced by tile-by-tile computation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>While gradient-domain compositing is a remarkably effective technique for compositing image and video regions, it simply was not previously practical to use it for imagery of the large resolutions common even in consumer-level digital imaging. We have shown an approximate approach to gradient-domain compositing that yields visually identical results, yet can be computed in surprisingly little time and memory, even for very large composites. This efficiency improvement allowed us to use gradient-domain compositing in the new "Auto-Blend Layers" feature in Adobe R Photoshop R CS3.</p><p>We hope that our technique will be one of many to address the scalability of algorithms for computational photography and video.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2</head><label>2</label><figDesc>Performance of quadtree-based gradient-domain compositing for several very large panoramas.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">An exception is Adobe Photoshop's Healing Brush[Georgiev  </note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2004" xml:id="foot_1">], which is efficient because it operates on only small regions of an image at any one time.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2">At the boundaries of the image the Laplacian kernel will depend on the choice of boundary conditions; the most common are Neumann and Dirichlet<ref type="bibr" target="#b20">[Saad 2003</ref>], both of which are supported by our approach.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements: Thanks to Dan Goldman for fruitful discussions, Rick Szeliski for advice in implementing his preconditioner, and Dan Goldman, Michael Cohen, and David Salesin for help with the manuscript. Thanks to Jeff Chien for helping me transfer this research into Photoshop, and to Tobias Oberlies and Brian Curless for images.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">A</forename><surname>Agarwala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dontcheva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Agrawala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Drucker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Colburn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Curless</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Salesin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Cohen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Interactive digital photomontage. ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="294" to="302" />
			<date type="published" when="2004-08">2004. Aug</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Panoramic video textures</title>
		<author>
			<persName><forename type="first">A</forename><surname>Agarwala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">C</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Agrawala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Curless</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Salesin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Szeliski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="821" to="827" />
			<date type="published" when="2005-08">2005. Aug.</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Photographing long scenes with multi-viewpoint panoramas</title>
		<author>
			<persName><forename type="first">A</forename><surname>Agarwala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Agrawala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Salesin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Szeliski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="853" to="861" />
			<date type="published" when="2006-07">2006. July</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Removing photography artifacts using gradient projection and flash-exposure sampling</title>
		<author>
			<persName><forename type="first">A</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Raskar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Nayar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="828" to="835" />
			<date type="published" when="2005-08">2005. Aug.</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Two-scale tone management for photographic look</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bae</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Paris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Durand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="637" to="645" />
			<date type="published" when="2006-07">2006. July</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Sparse matrix solvers on the GPU: Conjugate gradients and multigrid</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bolz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Farmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Grinspun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Schr Öder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="917" to="924" />
			<date type="published" when="2003-07">2003. July</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The space efficiency of quadtrees</title>
		<author>
			<persName><forename type="first">C</forename><surname>Dyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics and Image Processing</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="335" to="348" />
			<date type="published" when="1982-08">1982. Aug.</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Gradient domain high dynamic range compression</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fattal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lischinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Werman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="249" to="256" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Quadtree traversal algorithms for pointer-based and depth-first representations</title>
		<author>
			<persName><forename type="first">G</forename><surname>Finlayson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">H M</forename><surname>Drew</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Computer Vision (ECCV 02)</title>
				<editor>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Fuhrmann</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1988">2002. 1988</date>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="955" to="960" />
		</imprint>
	</monogr>
	<note>Removing shadows from images</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Photoshop healing brush: a tool for seamless cloning</title>
		<author>
			<persName><forename type="first">T</forename><surname>Georgiev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Applications of Computer Vision</title>
				<imprint>
			<date type="published" when="2004">2004. 2004</date>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Vignette and exposure calibration and compensation</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Goldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-H</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer Vision (ICCV 05)</title>
				<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="899" to="906" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Scene completion using millions of photographs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hays</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Efros</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Drag-and-drop pasting</title>
		<author>
			<persName><forename type="first">J</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-K</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-Y</forename><surname>Shum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="631" to="637" />
			<date type="published" when="2006-07">2006. July</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Graphcut textures: Image and video synthesis using graph cuts</title>
		<author>
			<persName><forename type="first">V</forename><surname>Kwatra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sch Ödl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Essa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Turk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bobick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="277" to="286" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The retinex theory of color vision</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">H</forename><surname>Land</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Scientific American</title>
		<imprint>
			<biblScope unit="volume">237</biblScope>
			<biblScope unit="page" from="108" to="128" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Seamless image stitching in the gradient domain</title>
		<author>
			<persName><forename type="first">A</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zomet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Peleg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Weiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Computer Vision (ECCV 04</title>
				<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="377" to="389" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Simulating water and smoke with an octree data structure</title>
		<author>
			<persName><forename type="first">F</forename><surname>Losasso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Gibou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fedkiw</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="457" to="462" />
			<date type="published" when="2004-08">2004. Aug.</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The cost of balancing generalized quadtrees</title>
		<author>
			<persName><forename type="first">D</forename><surname>Moore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third ACM Symposium on Solid Modeling and Applications</title>
				<meeting>the Third ACM Symposium on Solid Modeling and Applications</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="305" to="312" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Vision Science: Photons to Phenomenology</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">E</forename><surname>Palmer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>The MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Poisson image editing</title>
		<author>
			<persName><forename type="first">P</forename><surname>Érez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gangnet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Blake</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="313" to="318" />
			<date type="published" when="2003-07">2003. July</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Iterative methods for sparse linear systems</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Saad</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Society for Industrial and Applied Mathematics</publisher>
		</imprint>
	</monogr>
	<note>2nd ed</note>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Applications for spatial data structures: computer graphics, image processing, and GIS</title>
		<author>
			<persName><forename type="first">H</forename><surname>Samet</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">An introduction to the conjugate gradient method without the agonizing pain</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Shewchuk</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep. CS-94-125</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Direct analytical methods for solving Poisson equations in computer vision problems</title>
		<author>
			<persName><forename type="first">T</forename><surname>Simchony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Chellappa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="435" to="446" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-K</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-Y</forename><surname>Shum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Poisson matting. ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="315" to="321" />
			<date type="published" when="2004-08">2004. Aug.</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Motion estimation with quadtree splines</title>
		<author>
			<persName><forename type="first">R</forename><surname>Szeliski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-Y</forename><surname>Shum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Pattern Analysis and Machine Intelligence 18</title>
				<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="1199" to="1210" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Fast surface interpolation using hierarchical basis functions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Szeliski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="513" to="528" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Locally adapted hierarchical basis preconditioning</title>
		<author>
			<persName><forename type="first">R</forename><surname>Szeliski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1135" to="1143" />
			<date type="published" when="2006-07">2006. July</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A survey of out-of-core algorithms in numerical linear algebra</title>
		<author>
			<persName><forename type="first">S</forename><surname>Toledo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">External Memory Algorithms</title>
		<title level="s">DIMACS Series in Discrete Mathematics and Theoretical Computer Science</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="161" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Seamless video editing</title>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Raskar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ahuja</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Pattern Recognition (ICPR)</title>
				<meeting>the International Conference on Pattern Recognition (ICPR)</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="858" to="861" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Deriving intrinsic images from image sequences</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Weiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference On Computer Vision (ICCV 01)</title>
				<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="68" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Seamless image stitching by minimizing false edges</title>
		<author>
			<persName><forename type="first">A</forename><surname>Zomet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Peleg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Weiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Image Processing</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="969" to="977" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
