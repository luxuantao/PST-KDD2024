<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">On Optimal Shaping of Multidimensional Constellations</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><roleName>Member, ZEEE</roleName><forename type="first">Rajiv</forename><surname>Laroia</surname></persName>
						</author>
						<author>
							<persName><roleName>Member, ZEEE</roleName><forename type="first">Nariman</forename><surname>Farvardin</surname></persName>
						</author>
						<author>
							<persName><roleName>SeniorMember, ZEEE</roleName><forename type="first">Steven</forename><forename type="middle">A</forename><surname>Tretter</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering</orgName>
								<orgName type="institution">University of Maryland</orgName>
								<address>
									<settlement>College</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">AT&amp;T Bell Laboratories</orgName>
								<address>
									<postCode>07974</postCode>
									<settlement>Murray Hill</settlement>
									<region>NJ</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Department of Electrical Engineering</orgName>
								<orgName type="institution">University of Maryland</orgName>
								<address>
									<postCode>20742</postCode>
									<settlement>College Park</settlement>
									<region>MD</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department">Department of Electrical Engineering</orgName>
								<orgName type="institution">Uni-versity of Maryland</orgName>
								<address>
									<postCode>20742</postCode>
									<settlement>College Park</settlement>
									<region>MD</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">On Optimal Shaping of Multidimensional Constellations</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">4FF5CAC0D6AB669B382A78B54392AF19</idno>
					<note type="submission">received December 30,1991; revised February 6,1992 and April 15,1993.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T10:36+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I d e r Term-Multidimensional constellations</term>
					<term>SVQ shaping</term>
					<term>shell mapping</term>
					<term>optimal shaping</term>
					<term>Voronoi constellations</term>
					<term>trellis shaping</term>
					<term>constellation expansion</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Astmct-A scheme for the optimal shaping of multidimensional constellations is proposed. This scheme is motivated by a type of structured vector quantizer for memoryless sources, and results in N-sphere shaping of N-dimensional cubic lattice-based constellations. Becanse N-sphere shaping is optimal in N dimensions, shapimg gains higher than these of N-dimensional Voronoi constellations can be realized. While optimal shaping for a large N an realize most of the 1.53 dB total shaping gain, it has the undesirable effect of increasing the size and the peak-to-average power ratio of the Constituent 2D constellation. This limits its usefahess for many real world channels which have nonlinearities. The proposed scheme alleviates this problem by achieving optimal constellation shapes for a given limit on the constellation expansion ratio or the pealc-&amp;average power ratio of the constituent 2D constellation. Results of Calderbank and olarow on nonequiprobable s i g n a h g are used to reduce the complexity of this scheme and make it independent of the data rate with essentially no &amp;ect on the shaping gain. Comparisons with Fomey's trellis shaping scheme are also provided.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION HE problem of data transmission is the dual of the</head><p>T quantization problem, and this duality is formally described in [ 13. Advances in transmission theory have therefore resulted in useful insight and new quantization techniques (and vice versa). One such example is the use of the idea behind trellis-coded modulation [2], <ref type="bibr">[3]</ref> for the quantization of data <ref type="bibr">[41, [51.</ref> Another example is the quantization of memoryless sources using lattice-and trellis-bounded codebooks [ll, [61, a topic extensively studied in the context of modulation. This paper applies some of the ideas from a structured vector quantizer for memoryless sources <ref type="bibr">[7]</ref> to the optimal shaping of multidimensional constellations.</p><p>Shaping of multidimensional constellations has been studied in detail in [8]- <ref type="bibr">[14]</ref>. Reference I81 contains an excellent introduction to the problem and discusses cross and generalized cross constellations. Lattice-bounded constellations are considered in <ref type="bibr">[9]</ref>, and the generalization to trellis-bounded constellations (trellis shaping) is <ref type="bibr">described in [lo]</ref>. Shaping codes based on nonequiprobable signaling are the topic of <ref type="bibr" target="#b0">[11]</ref>- <ref type="bibr">[14]</ref>. Most of the terminology in this paper is adopted from IS]. Some of the relevant terms defined there are now briefly described.</p><p>A constellation C generally consists of a set of points on an N-dimensional lattice (translate) A that are enclosed within a finite region 9. The simplest N-dimensional constellation consists of all the points on a cubic lattice enclosed within an N-cube. This is the baseline constellation, and the performance of all the more complex constellations is measured in terms of gains over this constellation. There are two kinds of gains that can be achieved over the baseline system. The first is obtained by using a more densely packed N-dimensional lattice than the N-dimensional cubic lattice and is called the coding gain x. The second is the shapinggain 'ys that results from using a more spherical bounding region 9 than an Ncube. When the region 9 is big and encloses a large number of lattice points, the distribution of points in 9 can be approximated by a continuous uniform distribution over 9. This is the continuous approximation and, unless mentioned otherwise, in this paper we assume that it holds. Under the continuous approximation, the coding gain is decoupled from the shaping gain, and both can be realized independently. The topic of coding gain is addressed in <ref type="bibr">[15]</ref>, and here we focus only on the shaping gain. Shaping gain is defined as the ratio of the average energy of a baseline constellation with the same number of points and based on the same lattice as the given constellation to the average energy of the given constellation. Under the continuous approximation, the shaping gain is the inverse ratio of the average energy of the constellation region 9 to the average energy of the region bounded by an N-cube of the same volume as 9; this is also referred to as the shaping gain of the region 9. The region that has the smallest average energy for a given volume is an N-sphere. For a given N, therefore, the shaping gain is bounded by the shaping gain of an N-sphere. The maximum possible shaping gain is me/6 = 1.423 (1.53 dB), which is the limit of the N-sphere shaping gain as N becomes large. The shaping gains of the generalized cross constellations described in <ref type="bibr">[8]</ref> are limited to about 0.4 dB. Voronoi constellations of known lattices <ref type="bibr">[9]</ref> can achieve gains up to 1.1 dB. Simulations in <ref type="bibr">[4]</ref> show that trellis shaping can achieve larger gains-1.36 dB with a 256-state trellis. Shaping codes based on nonequiprobable signaling 1131, [141 can realize up to 1.2 dB shaping gain.</p><p>A constiaent 2D constellation of a given N-dimensional (assuming an even N ) constellation C is the set of all values that a given two-dimensional symbol takes as the N-dimensional signal points range through C. The constellation C is called a 2D-ymmetric constellation if it has the same constituent 2D constellation for all possible pairs of dimensions. In this case, we say that the constituent 2D constellation of C is C,. For constellations that are not 2D-symmetric, C, is taken as the union of all the different constituent 2D constellations. Some attributes of the constituent 2D constellations are important from the viewpoint of implementation with QAM (quadrature amplitude modulation) modems and are described next.</p><p>The shaping constellation expanswn mtio CER, of the constituent 2D constellation C, of C is defined as the ratio of the size IC,I of C, to the size of the constituent 2D constellation of a baseline N-cube bounded constellation containing the same number of points as in C. Therefore, CER, = IC21/1CIZ/N and is lower bounded by unity. The peak-to-average power mtio (PAR,) of C, is defined as the ratio of the squared distance of the farthest point(s) in C, from the origin to the average energy of points in C normalized to two dimensions (assuming all points in C are equally probable). The PAR, of the baseline N-cube bounded constellation is 3. For implementation with QAM modems, it is desirable to have both a small PAR, and a small CER, [81. Although optimal, N-sphere shaping is undesirable because it results in large CER, and PAR,.</p><p>The Voronoi region g v ( A ) c R N of an N-dimensional lattice A is defined as the set of points in R N that are at least as close (in the Euclidean distance sense) to the origin as to any other point in the lattice. The conventional approach of bounding the constellation by the Voronoi region of a lattice is based on the fact that the Voronoi regions of some N-dimensional lattices can approximate an N-sphere (especially for large N). In <ref type="bibr">[16]</ref>, it is shown that algorithmic indexing or labeling of the points in such constellations can be performed (look-up tables are generally impractical for a large N ) , leading to modest complexity encoding/decoding algorithms. Forney's trellis shaping scheme [lo] uses the "Voronoi region" of a trellis code to shape the constellation. A trellis code is the generalization of a finite-dimensional lattice to an infinite-dimensional sequence space. For a given complexity, trellis shaping achieves higher shaping gains than lattice-bounded constellations. Although the lattice-and trellis-bounded constellations can achieve a significant portion of the maximum possible shaping gain of 1.53 dB, this usually comes at the cost of an equally significant increase in <ref type="bibr">CER,</ref><ref type="bibr">and PAR,</ref><ref type="bibr">. Bounds obtained in [81 (see Figs. 2 and 3 of this paper)</ref> show that it is, at least in principle, possible to realize the same shaping gain as some of the best known lattices and trellises with a significantly smaller CER, and PAR,.</p><p>For lattice-and trellis-bounded constellations, peak constraints [lo], [17] can be introduced to significantly reduce the CER, and PAR, with only a minimal loss in shaping gain. Although the peak constraints make these schemes useful for practical implementation, they do not result in the best tradeoff between CER, (or PAR,) and shaping gain.</p><p>In this paper, we describe the optimal constellation boundary for a given constraint on the constellation expansion ratio or the peak-to-average power ratio. Two algorithms for indexing the points of such optimally shaped constellations are also given. These algorithms are motivated by the indexing algorithms of a structured vector quantizer called the scalar-vector ' quantizer (SVQ) 171, <ref type="bibr">[18]</ref>, and therefore the shaping scheme described in this paper is called SVQ shaping. The first indexing algorithm (Algorithm 1) requires no multiplications ,(only additions and subtractions), but has a higher storage complexity than the second algorithm (Algorithm 2) which requires multiplications. The storage and computational complexities of these algorithms are polynomial in constellation dimension, but exponential in rate. We use the results of Calderbank and Ozarow (C&amp;O) on nonequiprobable signaling <ref type="bibr">[ll]</ref> to reduce the complexities of these algorithms and make them independent of the constellation data rate. Compatability of SVQ shaping with trellis coding is also demonstrated.</p><p>Even though our indexing algorithms were motivated by scalar-vector quantizers, it was pointed out by the reviewers that the second algorithm (Algorithm 2) presented here is similar to the indexing scheme of Lang and  Longstaff [19] called shell mapping. In <ref type="bibr">[19]</ref>, Lang and Longstaff use shell mapping to enumerate the Leech lattice points enclosed in a 24-dimensional sphere. However, they do not consider constellation boundaries that maximize shaping gain for a given constraint on the CER, (or PAR,).</p><p>ReviewerS also brought to our attention the work of Khandani and Kabal (K&amp;K) <ref type="bibr">[20]</ref>, <ref type="bibr">[21]</ref> and the work of Kschischang and Pasupathy (K&amp;P) <ref type="bibr">[22]</ref> which were also under review at that time. Although performed independently, both of these are in some ways similar to the present work. Both K&amp;K and K&amp;P also describe the optimal constellation boundary for a given CER, and PAR,. For addressing the constellation points, K&amp;K use a table look-up algorithm which decomposes the problem into a hierarchy of simpler lower dimensional addressing problems. To reduce the look-up table size, they too use the C&amp;O results 1111. However the memory requirement of their algorithm is relatively large for applications such as voiceband modems. The indexing scheme used by K&amp;P is a generalization of the shell mapping algorithm of Lang and Longstaff, hut they do not capitalize on the C&amp;O results to make the complexity of their scheme indepenr dent of the data rate (at high rates).</p><p>This paper is organized as follows. In the next section, we define a class of constellations called SVQ constellations, and give two algorithms for indexing the points of these constellations. We show that the optimal N-sphere shaped constellation is a special case of SVQ constellation, and so the indexing algorithms of the SVQ constellation can be used for N-sphere shaping. Generalized cross constellations 181 and binary shaping codes Ill] are also shown to be special cases of the SVQ constellation. In Section 111, we describe constellations that result in the best tradeoff between shaping gain and CER, or PAR,, and show that these can also be represented as SVQ constellations. Shaping at high rates is considered in Section IV, followed by an example of a high-rate constellation in Section V. In Section VI, it is shown that SVQ shaping can be combined with coding. This is important because coding gain is more significant than shaping gain. Comparisons with trellis shaping are provided in Section VI1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">SVQ SHAPING OF CONSTELLATIONS</head><p>In this section, we first define a class of constellations which are called SVQ constellations. These constellations are so named because they are defined similar to the codebook of the scalar-vector quantizer (SVQ) introduced in [71, 1181. Two algorithms to index the points of SVQ constellations are also described. These algorithms are motivated by the indexing algorithms of the scalar-vector quantizer. The reason for starting with the general class of SVQ constellations is that many useful constellations are special cases of the SVQ constellations. These include N-sphere shaped constellations and the optimal constellations of Section 111. A shaping scheme that uses an SVQ constellation and its indexing algorithms will be referred to as SVQ shaping.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. SVQ Constellations</head><p>In QAM transmission, the channel alphabet d consists of a finite set of points (channel symbols) from a 2D (cubic) lattice. An N-dimensional constellation is usually a subset of dN/', the N/2-fold Cartesian product of d with itself. The constituent 2D constellation of the Ndimensional constellation is then a subset of d. In the general case, consider a d-dimensional channel. For QAM transmission, d = 2. Let B = { q l , q2,*-, q,,) be the set of n, d-dimensional channel symbols. These symbols are usually taken to be the n smallest energy points on some ddimensional lattice Ad. To every channel symbol 4,; i E J,, E {1,2,---, n} in 8, assign a positive integer cost li. The cost could, for example, be the normalized energy of the channel symbol. Define 9= {11, 12;--,ln} to be the set of (positive integer) costs. An N-dimensional ( N = md) SVQ-constellation Z consists of those points in Bm which have a total cost no greater than a threshold L, where the total cost of a point in Z is defined as the sum of the costs of its m d-dimensional components. The threshold L is chosen such that Z contains (at least) 2"' points, where r is the rate of the constellation in bits/d-dimension. This is formally described by the following definition.</p><p>Definition: An N-dimensional SVQ constellation 2 derived from an alphabet d and the corresponding set of costs 9 is given as</p><formula xml:id="formula_0">(1)</formula><p>where the index function f: 0 + J, is defined as f ( q J = i, i EJ,,.</p><p>(</p><p>For a rate r bits/d-dimension constellation, the threshold L is selected as the smallest integer such that the cardinality of 2 is no less than 2"' . Since this paper deals mainly with shaping and not coding, the lattice A d will be assumed to be cubic, i.e., the alphabet 8 is assumed to consist of points on a d-dimensional cubic lattice. Compatibility with trellis coding will be discussed in Section VI. Also, except where mentioned otherwise, we shall be dealing with QAh4 systems and assume d = 2.</p><p>It is easy to show that the generalized cross constellation [8] is a special case of the SVQ constellation. This can be done by dividing a 2D cross constellation 8 into inner and outer points and assigning a cost of, say, 1 to the inner points and 2 to th,e outer points. If the threshold L is chosen as m + 1, no N-dimensional constellation point contains more than one outer point of 8. The binary shaping codes [ll] can similarly be represented as SVQ constellations. Also, by taking d to be an appropriate subset of the integers Z and the Cost I, = q:, an N-sphere shaped cubic-lattice constellation can be described as an SVQ constellation.</p><p>The above definition is very similar to the definition of the scalar-vector quantizer <ref type="bibr">[71, [18]</ref>, and the constellation here corresponds to the codebook of the quantizer. This is because shaping of the codebook boundary is also important in the quantization of memoryless sources [l], 171. In general, the best codebook boundary depends on the probability distribution of the source to be quantized. For Gaussian sources, the optimal codebook boundary (in N dimensions) is an N-sphere. The scalar-vector quantizer implements optimal codebook boundaries for an important class of memoryless sources and algorithmically indexes the codevectors. Defining SVQ constellations as above enables us to use the indexing algorithms of the scalar-vector quantizer to index the constellation points. In this sense, the SVQ constellation is a transmission dual of the scalar-vector quantizer.</p><p>Before we discuss the indexing of constellation points, we present an algorithm to determine the threshold L given the rate r of the SVQ constellation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Determinution of the Threshold L</head><p>For a given set of costs 9 and a desired constellation rate r in bits/d-dimension, the threshold L can be obtained by counting the constellation points-starting with the ones that have the smallest total cost-until there are 2"' points, and then taking the largest total cost in this collection.</p><p>Let Mi represent the number of distinct i-vectors (U', u2,**-, ui) E cTi such that their total cost + +lf(,, = j . Then M/ satisfies the following recursive equation V I E J,:</p><formula xml:id="formula_2">+</formula><p>where M/ = 0 for j &lt; 0 and M{ = 1. The Mi can hence be determined by evaluating these formulas in increasing order of i. Define Ci as the number of i-vectors in 8' that have a total cost no greater than j. Clearly, CL = C{=,M;: The threshold L is the smallest value of j for which CL is at least 2"' , i.e., L = min{j: CL 2 2"' ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Indening the Constelkation Points</head><p>Indexing consists of encoding and decoding the constellation points. There are 2"' points in a constellation (there may be more that satisfy the threshold, but only 2"' are used); hence, each constellation point can be uniquely specified by an 'mr-bit binary number called the address or the index of the point. In the transmitter, the encoder maps a string of mr bits of data into a unique constellation point. The constellation point is transmitted and received by the receiver where the decoder maps the received point into mr bits of data. The decoder map is the inverse of the of the encoder, and hence any one of these maps specifies the other. It is obvious that when the dimension N is large, the encoder/decoder maps should be such that they can be implemented algorithmically rather than, by table look-up. We give here two different algorithms to encode/decode the constellation points. These algorithms are motivated by the indexing algorithm of the scalar-vector quantizer. The first algorithm (Algorithm l) requires no multiplication, but uses more storage than Algorithm 2 which requires multiplication.</p><p>Algorithm 1: We begin by specifying the decoder map and the algorithm that implements it. Following this, the encoding algorithm is presented.</p><formula xml:id="formula_3">Decoder Map: To each constellation point z = (zl, z2,*--,z,) â‚¬3, assign an m-digit base n number M ( z ) = (f(zl) -1, f(z2) -I,..., f(z,) -1) = f ( z J -1). Clearly, &amp;(z,&gt; = d ( z 2 ) -z1 = z2.</formula><p>All the constellation points are now ordered according to the following two rules: 1) a point z1 is "smaller than" z2 (i.e., z1 &lt;z2) if T ( z l ) &lt; T(z2), where T ( z ) denotes the total cost of z; and 2) if T ( z , ) = T(z2), then z1 &lt; z2 if A z , )</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>&lt;&amp;(z,).</head><p>The decoder mapping E: Z + (0) U Jzmr-, is defined as the number of points in Z that are smaller than the given point, i.e.,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E ( z )</head><formula xml:id="formula_4">= cp-1 + ZZIW = c y -' + a(z) (4) W e 2</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>T(w)= T ( 2 )</head><p>where = 0 if A ( w ) ~&amp; ( z ) ; 1 otherwise, and C: = 0. The function 8 ( z ) in the above equation gives the total number of cost T ( z ) constellation points that are smaller than z. We can further write 8(z) = Ckm,l&amp;;;i(z), where Zk(z) is the number of cost T ( z ) points w such that the base n representations of A ( z &gt; and A w ) are identical in the k -1 most significant digits, while the kth digit of A ( w ) is smaller than that of d z ) . It is simple to see that 2Fk(z) = Z{?f)-lMmT(_zi-Lt-l-t~; k E J,, where Lo = 0 and L, = Xi=llf(z,); i E J,. The decoder function can hence be written as</p><formula xml:id="formula_5">m .f(zk)-l E ( z ) = c;(")-1 + E llrf,T'_Zz-,-Lt-1-5. (5) k=l 1 = 1</formula><p>Given that Mi' and CL; Vi E J m -l ; V j E JL are computed once [using (3)] and stored in the memory, this equation shows that the total number of additions required (per d-dimension) for the decoding operation is upper bounded by n. It should be noted, though, that each of CL and M i can be up to mr bits long. The number of bit additions is hence bounded by nmr per d-dimension and the memory requirement is bounded by Lm'r bits.</p><p>The decoder map is a slightly modified version of its quantization counterpart described in [7], and ensures that (rule 1) above) the constellation points with the largest total cost are assigned the largest indexes. Hence, of the total number of constellation points (which may be a little more than 2"), only those 2" with the smallest cost are transmitted.</p><p>Encoder Map: The encoder function E-' : (0) U JZmr-, + Z is the inverse of the decoder and assigns constellation point to every mr-bit binary address. The encoding can be performed as follows. Given an index c, first compare it with CL; j E JL and determine the cost T ( z ) of the constellation point z corresponding to c. Then let c' = c -C:(z)-' . The encoding is now done one component at a time starting with zl. The algorithm is straightforward. Compare c' with the number M:'_Z)l-'f(qi) of constellation points beginning with q1 that have cost equal to</p><formula xml:id="formula_6">T(z). If c' &lt; M,T!!{-h), then z1 = ql; else, compare c' - M;!!)l-'f(n) with the number of codevectors M;!!)l-'f@2)</formula><p>beginning with q2, and so on, until z1 is determined. Now, the problem reduces to an equivalent (m -1)-component problem which can similarly be handled. This algorithm, when implemented efficiently, requires at most n additions (subtractions) of mr-bit numbers per d-dimension. Its complexity is hence the same as that of the decoder.</p><p>The above indexing method requires that a table of m X L numbers, each up to mr bits long, be stored in the memory. This can be somewhat expensive for practical implementations in voiceband modems. We now present a divide-and-conquer version of the above algorithm that has a smaller memory requirement.</p><p>Algorithm 2: The encoding maps described here assume that m is a power of 2, i.e., m = 2K. They are essentially based on the following idea. A constellation point (which is an m-vector in a") is split into two m/2-vectors.</p><p>Assuming that the m/2-vectors have been indexed, a two-component version of Algorithm 1 is used to index each vector. The alphabet for each of the two components is the set of m/2-vectors. This splitting into two and indexing is repeated until the original constellation point is reduced to the concatenation of pairs of 1-vectors which can be easily indexed using Algorithm 1. As pointed out earlier, this is very similar to the mapping algorithm of Lang and Longstaff [19].</p><p>Let mi = m/2('-'), i E J ~+ ~ = {1,2;.., K + I}. Then MAL is the number of mi-vectors or mi-tuples U = ( U ! , u2;**, umi) E @'" that have total cost j. Clearly, MA(K+l = Mi is the number of elements hi the alphabet B of the SVQ constellation that have a cost equal to j.</p><p>.Also, CAi is the number of mi-vectors U E B"i with a total cost no greater than j . The encoding and decoding algorithms described below assume that the MAi V i E</p><p>(2,3,-.., K + l}, V j E JL and CA, V j E JL are computed once using (3) and stored in the memory. This takes up considerably less storage, especially for a large m, than storing the Ml for all k E JmP1, as in Algorithm 1. It is further assumed that the alphabet ql, q2,*--, q, is indexed such that the corresponding costs Z,, Z2,---, I, form a nondecreasing sequence, i.e., smaller costs are assigned smaller indexes. Decoder Map: The. mapping given decodes a constellation point (m-vector, m =,2K) by recursively splitting it into two equal parts. Let 'U 7 ( U , , u2,---, umi) denote an mi-vector in CY". Also, let 'ul = ( U ' , u2,--*, um(,+,) and i ~2 ( u ( m i + , ) + l ) 7 ~( m ( i + l , + ~) , * * * , u m , ) be .the first and the second haives of 'U, respectively. If z = (q, z, ; . . ,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2,) E</head><p>am is the constellation point to be decoded, then let } the decoding function that maps in m,-vector iu E Bmi into a nonnegative integer. Define EK+':</p><formula xml:id="formula_7">d + {0,1,2,.-.} as E K + l ( u ) = f ( u ) -1, V u E 8, where f(-) is the index function in (2).</formula><p>Assume that all 'U, and 'u2 in Bm(i+l) have been indexed using Ei+', i.e., E'+'Cu,) and E'+'Cu2) are the indexes of Iul' and Iu2, respectively. Order all mi-vectors in according to the following three rules: 1) a vector</p><formula xml:id="formula_8">'U E CY'" is "smaller than" ' w E &amp;" I (i.e., 'U &lt; ' w ) if T'('u) &lt; Ti(%)</formula><p>, where the function Ti(.) gives the total *st of an mi-vector E &amp;"I;</p><p>2) if Ti('u) = Ti('w), then .</p><p>'U = z .</p><p>Represent by E': 8"' + IO, 1,2,</p><formula xml:id="formula_9">I u &lt; i w if Ei+l (.U') I &lt; E'+'('w,); and 3) if Ti(%) = Ti(%) and E'+' ( i ul) = E'+'('w,), then 'U &lt; ' w if E'+'('u,) &lt; E'+ 1(iw2).</formula><p>The decoding function Ei('u) is now given as the number of mi-vectors in B"i that are smaller than 'U. This can be expressed as (IU') + 271+1(1u2). ( <ref type="formula">7</ref>)</p><formula xml:id="formula_10">+ g 1 + 1 I 1 l u ) -T ( ' + ' ) ( Ul)M:(:+' )</formula><p>The first term on the right-hand side of ( <ref type="formula">7</ref>) is the number of mI-vectors with the same cost as 'U, and whose first halves have cost less than the first half, Iul of 'U. The second term is the number of m,-vectors with the same cost as 'U, whose first halves have the same cost as 'U', but have index less than that of 'U,. These first two terms account for the vectors satisfying ordering rule 2). The third term is the number of m,-vectors with the same cost as 'U, with the identical first half, and with a smaller second half. It accounts for vectors satisfying ordering rule 3).</p><p>The decoding operation is hence performed by partitioning the input m-tuples into m / 2 pairs and decoding the pairs using aK(-). The pairs are then grouped into 4-tuples and decoded using gK-'(*), and so on. When i = 1 is reached, E'(-) given by ( <ref type="formula">6</ref>) is used for the final decoding step. Note that the CA,., V j E JL are required only when i = 1 in the final decodmg step.</p><p>The storage requirement of this algorithm is bounded by Lm(1og m)r bits instead of Lm2r bits for Algorithm 1. Note that (7) requires multiplications of mr-bit numbers by mr-bit numbers. Taking each such multiplication to consist of m2r2 bit multiplications, a simple bound on the computational requirement of the above algorithm is Lm2r2 bit operations per d-dimension.</p><p>Encoder Map: The encoder mapping is implemented as the inverse of the decoder mapping described above. The aim is to determine the constellation point (m-vector) z ='U E d m that corresponds to a given mr-bit binary number E'('u). This is accomplished by determining E2('ul) and E2('u,) from E'('u). The problem now reduces to two problems, each half of the original dimension. These can be similarly handled.</p><p>To determine E2('ul) and E2('u2) from E'('u), first determine 8 ' ( ' u ) and the cost T'('u) of 'U using the stored values of CA, j E JL. The values T2('ul), g2('u,), T2('u2), and g2('u,) are next determined from 8'('u) by repeated subtraction and a division as explained in the next paragraph.</p><p>The first encoding step is to find the cost T'('u) of 'U. This can be computed as </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Thus, according to the Euclidean division dgorithm, i ? ' ' + ' ( ' v</head><p>) is the remainder when S'('v) is divided by MP(:;-%+l)</p><formula xml:id="formula_11">( V I ) ' = MT"+"('V,) % + I )</formula><p>and gi+'('vl) is the quotient.</p><p>The halving procedure described above is repeated until m 1-vectors are reached. The complexity of this encoding algorithm is approximately the same as that of the decoding algorithm. The structure of these algorithms makes them amenable to DSP-based implementation.</p><p>The indexing scheme described above can easily be adapted to values of m that are not a power of 2. For example, when m = 12, a 12-vector can be split into two 6-vectors, and further into four 3-vectors. Each 3-vector can be indexed using Algorithm 1 with m = 3.</p><p>Table <ref type="table" target="#tab_1">I</ref> gives the bounds on computational and storage requirements of both of these algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="111.">OPTIMAL SHAPING A. N-Sphere Bounded Constellatwns</head><p>As mentioned before, an N-sphere constellation boundary maximizes the shaping gain in N dimensions. An N-sphere bounded cubic lattice-based constellation can be described as an SVQ constellation with scalar</p><formula xml:id="formula_12">( d = 1, m = N ) alphabet B -{ -( n -1)/2;..,</formula><p>-1, 0, 1,---, ( n -1)/2} for some large enough odd n, costs li = q:, and an appropriate L that is determined by the rate r (bits/dimension) of the constellation. Assuming that the continuous approximation holds, L is the squared radius of an N-sphere enclosing 2" lattice points and, assuming even N, is given as L = 22r(N/2)!2/N/7r. Using Sterling's approximation for (N/2)!, we get L =  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I II I</head><p>22rN/(2e.rr). Also, for an N-sphere boundary, the size n of the alphabet d corresponds to the diameter of the N-sphere and is approximately 2 a . With this value of L, the computational complexity of Algorithm 1 goes as N3l2 and the memory requirement is cubic in N, while for Algorithm 2, the computational complexity is cubic in N and the memory requirement goes as N log N. Hence, for large N, the choice between Algorithms 1 and 2 is dictated by the relative costs of processing and storage.</p><p>Because of the polynomial dependence of complexity on N, these algorithms can, in principle, be implemented for large N, making it possible to realize a large fraction of the 1.53 dB maximum shaping gain. It should be pointed out, though, that when N is large, any errors caused by channel noise could corrupt the entire data in the block. Table I also gives the bounds on computational and storage requirements of Algorithms 1 and 2 for N-sphere bounded constellations. Transmission of data using an N-sphere SVQ-shaped cubic lattice-based constellation is shown in Fig. <ref type="figure" target="#fig_2">1</ref> and can be described as follows. The transmitter takes a block of Nr bits from the input data stream and encodes these bits to a constellation point (N-vector) which is transmitted. The encoding can be performed using the encoder map of either Algorithm 1 or 2. At the receiver, the channel output is first quantized, using a bank of N scalar quantizers, to the nearest point on the cubic lattice. This will give back the transmitted constellation point (assuming channel noise does into cause an error) which is converted to an Nr-bit block using the corresponding decoder map.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Shaping and Constellation Expansion Ratio</head><p>While N-sphere shaping achieves the best shaping gains, it also results in large CER, and PAR,. Table <ref type="table" target="#tab_1">I1</ref> gives the shaping gain ys, CER,, and PAR, of N-spheres for various N (also see [SI). For large N, the probability of Occurrence of the points in the constituent 2D constellation is not uniform, but is close to a two-dimensional Gaussian distribution even when the N-dimensional constellation points themselves are equally probable. Channel capacity arguments for the additive Gaussian noise chan-. nel also show that the optimal distribution of points in the constituent 2D constellation is the two-dimensional Gaussian distribution. Because of this, the points of the  constituent 2D constellation that, occur most frequently are the ones that are closet to the origin; hence, the average energy per two dimensions of this constellation is small, and this is the reason for its large shaping gain. On the other hand, the points on the periphery of the constituent 2D constellation are very improbable, suggesting that even if these points are removed, resulting in a smaller CER,, good shaping gains should still be possible.</p><p>Bounds on the shaping gain for a given CER, and PAR, derived in [8] (see Figs. 2 and 3 of this paper) show that it is indeed possible to get large shaping gains at considerably smaller values of CER, and PAR, than those required for N-spheres. Soon it will be shown that these bounds can indeed be achieved asymptotically in N by SVQ shaping.</p><p>A subtle point worth observing is the following. The definition of the constituent 2D constellation given in [8] (and in Section I) is a little too restrictive. For a QAM modem-based implementation, all that is really required is that the N dimensions be partitioned into a set of N/2 pairs of dimensions, and the constituent constellation along any pair in this set, if they are all the same (if not, take the largest of such constituent constellations), can be taken as the constituent 2D constellation. This is less restrictive than requiring that the constituent 2D constellation be the same for all possible pairs of dimensions. Although it is not mentioned, the bounds on shaping gain derived in [8] are asymptotically achievable only for a constraint on the expansion ratio CER, of this less restrictive definition of the constituent 2D constellation. For the rest of this paper, we use these new definitions of the </p><formula xml:id="formula_13">h m P c M v . 3 F . 3 a r: I/) 0 1 1 2 1 4 1 6 1 8 2 2 2 CER-2</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>constituent 2D constellation C , and the constellation expansion ratio CER,.</head><p>To demonstrate that optimal SVQ shaping is possible for a given constraint on CER,, we first consider the simpler problem of optimal SVQ shaping for a given CER,, which is the constellation expansion ratio of the constituent 1D constellation C,. The constituent 1D constellation is defined as the largest of the constituent constellations along each dimension. This will be generalized to the 2D case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Optimal Shaping for a Given CER,</head><p>The problem is to determine the shaping region of a rate r (bits per dimension) N-dimensional cubic latticebased constellation that maximizes the shaping gain for 1 s CER, I p. For this rate, the baseline constellation is bounded by an N-cube of side (2' -1) and has 2' points in its constituent 1D constellation. The desired constellation has at most n = p2' points in its constituent 1D constellation, and is a subset of points inside on outer N-cube of side p(2' -1). It is obvious that the best way to choose a given small number of points inside the outer N-cube while minimizing the average energy is to choose them inside an N-sphere of appropriate radius centered at the origin. As the number of points to be chosen increases, the radius of the N-sphere that contains them also increases until the sphere begins to intersect with the outer N-cube. When that happens, only the points that lie in the intersection of the N-sphere interior and the N-cube interior must be included in the collection. The size of the N-sphere can be increased if necessary to accommodate a total of 2" points in the required constellation. This procedure of choosing the constellation points ensures that the points closest to the origin (minimum energy) that satisfy the outer N-cube constraint are chosen first. Hence, the resulting constellation has the smallest possible average power for the required number of points. The shaping region of this constellation will be the intersection of an N-sphere interior and an N-cube interior. It might happen that for a small N (and large PI, the N-sphere is entirely contained inside the N-cube. The resulting constellation then is bounded by the N-sphere and actually CER, s 8; equality holds only if the diameter of the N-sphere is equal to the side of the N-cube, As in [8], it can be reasoned that the above constellations also give the best tradeoff between the shaping gain ' y,</p><p>and the PAR,.</p><p>The optimal constellation described above can be specified as an N-dimensional SVQ constellation ( d = 1 and m = N ) with d = { -(n -1)/2,.--, -1, 0, l,..., ( n -1)/2} (assuming odd n), li = q?, and L chosen such that the constellation has (at least) 2" points. The indexing algorithms described in the previous section can therefore be used to encode/decode the constellation points. The transmitter/receiver block diagram in this case is also described by Fig. <ref type="figure" target="#fig_2">1</ref>.  <ref type="table" target="#tab_1">I11</ref> gives the shaping gain ' y, for various values of CER, (and the corresponding PAR,) for two different N . For a given CER, = / 3 of the constituent 1D constellation, CER, is upper bounded by p 2 and PAR, is upper bounded by PAR, (for large N, these quantities become equal to their bound). Table <ref type="table" target="#tab_1">I11</ref> also gives these (upperbounds) values for the corresponding constituent 2D constellation. For these values of CER, and PAR,, however, higher shaping gains are possible, as shown next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Optimal Shaping for a Given CER,</head><p>The optimal shaping solution in this case is the generalization of the 1D solution described above. It is shown in [81 (also see <ref type="bibr">[NI,</ref><ref type="bibr">[22l)</ref> that the required optimally shaped N-dimensional constellation-under the CER, I constraint-should have a circular constituent 2D constellation 8 with n = 82' smallest energy points on the 2D cubic lattice, where r is the rate in bits/d-dimensions and d = 2. The required constellation is hence constrained to be a subset of points enclosed by 8" (where m = N / 2 ) , which is the m-fold Cartesian product of 0 with itself. Proceeding as in the 1D case, we choose the points in the intersection of the interiors of C" and an N-sphere of appropriate radius so that the constellation has 2" points. This ensures that we choose the 2" minimum energy points that satisfy the CER, constraint (i.e., lie inside 8"). Hence, the average power of this constellation is the minimum for the given size. This constellation can also be described as an SVQ constellation. The alphabet d = {ql,q2,.--,qn} consists of the n = 82' points of the constituent 2D constellation B. The cost Zi associated with q1 is its squared distance from the origin, i.e., I, is the energy of 4,. The threshold L is once again chosen such that the constellation consists of (at least) 2" points. As shown in <ref type="bibr">[8]</ref>, this optimally shaped constellation under the CER, constraint also represents the best tradeoff between shaping gain and PAR,. A generalization of the above method to optimal shaping for a given CER,, j &gt; 2 is straightforward.</p><p>Table <ref type="table" target="#tab_5">IV</ref> gives the optimal ys for various values of CER, and the corresponding PAR,. These results are also plotted in Figs. <ref type="figure" target="#fig_3">2</ref> and<ref type="figure">3</ref>, along with the asymptotic bounds for large N, and demonstrate that large shaping gains are indeed possible with a small CER,.</p><p>So far, we have described the optimal constellations for a given CER and PAR and presented two algorithms to index the constellation points. Although the complexity of these algorithms is polynomial in the constellation dimension N, it is exponential in its rate r. This makes it difficult to realize a large shaping gain at high rates. In the next section, we show that at high rates, it is possible to implement an approximation of the optimal constellation such that the indexing complexity becomes independent of the data rate with negligible effect on the shaping gain. This is accomplished by using results on nonequiprobable signaling [U].</p><p>IV. SHAPING AT HIGH RATES <ref type="bibr">Calderbank and Ozarow in [ll]</ref> have shown that it is, in principle, possible to achieve most of the maximum shaping gain of 1.53 dE3 by partitioning a circular 2D constellation (with a large number of points) into a small number t of equal area regions (circular shells) and using all the constellation points in a region with the same probability. Virtually all of the shaping gain can be achieved with just t = 16 regions and a CER, less than about 2. For t = 8, a shaping gain of over 1.4 dB can be realized. The shaping gam versus PAR, plot for t = 32 given in [ll, Fig. <ref type="figure">4(e)</ref>] (the notation in 1111 is different from that used here) is claimed to be indistinguishable from the optimal shaping gain versus PAR, plot in <ref type="bibr">[8]</ref>.</p><p>These results suggest that at high rates, there is almost no loss in shaping gain if the optimal constellation described in Section 111-D is approximated by the following constellation. Partition the given circular constituent 2D constellation into a maximum of t = 16 regions (circular shells), each containing the same number of points. To all the points within a given region, assign a cost equal to the average energy of that region. This ensures that all points in the same region of the constituent 2D constellation occur with the same frequency in the multidimensional constellation. Since SVQ shaping can minimize the average constellation energy (cost) subject to the above constraint, for a given t it can asymptotically (in dimension) achieve the performance described in 1111. The shaping gain for a given t is independent of the number of points in the constituent 2D constellation assuming a large number of points. Therefore, the complexity of this SVQ shaping scheme for nearly optimal shaping does not continue to increase with the constellation rate r. An example is presented in the next section. Numerical results show that for r greater than about 6 bits/2D, the complexity can be made independent of the rate with little or no effect on the shaping gain.</p><p>The above reduction in complexity makes it possible to achieve a large shaping gain, even for high-rate constellations. In the next section, we consider an example that demonstrates this.</p><p>V. EXAMPLE OF AN SVQ-SHAPED CONSTELLATION Assume that it is desired to transmit binary data using a 64-dimensional SVQ-shaped uncoded ZM-based constellation at the rate of 8 bits/2D. (Trellis-coded constellations are considered later.) The constituent 2D constellation in this case must consist of at least 256 points. A circular 256-point 2D constellation, however, results in only 0.2 dB shaping gain (that of a circle over a square). To achieve higher shaping gains, the constituent 2D constellatin must be expanded to have more than 256 points. In this example, we assume that a shaping CER, of 1.5 (corresponding to a 384-point 2D constellation) is acceptable. The 2D constellation A, hence consists of 384 points on the translated lattice 2, + (1/2,1/2) that are enclosed inside a circle of appropriate radius. The circular constellation A, is partitioned into t = 12 regions R,, R,,..., R,,, each containing 32 points. The region R, consists of the 32 lowest energy (smallest squared distance from the origin) points in A,, R, consists of the 32 next higher energy points in A,, and so on. There are many different ways to choose the regions R,, R,,..., R12: however, one that preserves the 1r/2 rotational symmetry of A, is preferable [8].</p><p>As described in the previous section, close to optimal shaping gain can be achieved by using all 32 points in any given region Ri, i E J,, = {1,2,.-., 12) with the same probability. In the context of SVQ shaping, this can be accomplished by taking the 2D alphabet ( d = 2) of the SVQ constellation as the 384 points in A, and assigning the same cost to all points in the same region. The threshold L can be determined such that the constellation has 232x8 = P6 points. Alternatively, for a more efficient implementation, we define a region constellation where the alphabet is taken as the 12 ( n = t = 12) regions, i.e., B =LZ = {RI, R2,.-., R,,}, and every region Ri, i E J12 is assigned a cost li = i . The justification for this cost assignment is that for a large number of points in each region; the average cost of the region is approximately proportional to the region number. Since each region vector represents (2')" = 2160 constellation points and there are 2256 constellation points, the region constellation must consist of P6/Po = 2% region vectors in L Z ~~. The threshold L is selected so that the region constellation contains this many points.</p><p>The transmitter in a QAM-based system accepts binary data in blocks of 32 X 8 = 256 bits and transmits each block using 32 2D-points (equivalent to one point on the 64-dimensional constellation). Out of the 256 bits in each block, the encoder maps 96 bits into a region vector in 9". These 96 bits are called the shuped bits. The additional 5 bits/2D (a total of 160 bits) are used to determine which point (E A,) of each 32-point region is transmitted. These 160 bits are called the mhuped bits. In the receiver, the unshaped bits (5 bits/2D) are recovered by determining which point within each region was received, and the 96 shaped bits are recovered by using the decoder map on the received region vector. Fig. <ref type="figure">4</ref> shows a block diagram of the transmission system described above.</p><p>Numerical evaluation shows that the above SVQ-shaped constellation achieves a shaping gain of 1.20 dB and has a PAR, = 3.76. If Algorithm 2 is used to index the m t e llation points, the encoding and decoding operations each require a peak computational load of about 60 multiply-adds/2D (assuming a 16 bit processor) and 3 kbytes of memory.</p><p>The complexity of the shaping scheme using Algorithm 2 in the example above can be further reduced with little or no effect on the shaping gain. This is done by repeatedly applying the ideas of Section IV to constituent constellations in 4,8, 16, and 32 dimensions. For instance, the number Mi is the total number of cost T 3 ( 3 v ) = j points (K = 5 and 3v represents an 8-tuple in E?*) in the constituent 16-dimensional constellation. The constituent 16dimensional constellation can be divided into regions of, say, 1024 points each. The 1024 points with the smallest costs belong to the first region, the 1024 points with the next higher costs belong to the next region, and so on. All points in the same region are now assigned the same cost (this may be different from the original cost of the points).</p><p>This corresponds to modifying the numbers Mi, j = 1,2,3, ... to a new set A d , where A d is the new number of points in the constituent 16dimensional constellation with the modified cost s3(3v) = j. Also, let ' 2?d be the (new) number of points in the 16-dimensional constellation with (modified) cost s3(3v) I j.</p><p>The index E3(3v) of 3v can now be used to determine s3(3v) and e3(3v)--which z k the number of (modiJed) cost s3(3v) points in the constituent 16dimenswnal constellation that are smaller than 3v.</p><p>For this approach, the encoding function of Algorithm 2 is modified as follows:</p><p>E'('v) = g l ( l v ) + C ; ; ( ' w <ref type="bibr" target="#b0">(11)</ref> where (</p><formula xml:id="formula_14">Y</formula><formula xml:id="formula_15">)<label>15</label></formula><p>With this modification, a variety of tradeoffs among shaping gain, computational complexity, and storage requirement are possible. In the above example, a shaping gain of about 1.15 dB can be realized at a PAR, of 3.75 with a worst case computational complexity of about 45 multiply-adds/2D (assuming a 16 bit processor) and a storage requirement of around 1.5 kbytes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. COMPATIBILITY WITH'TRELLIS CODING</head><p>We have so far discussed the optimal shaping of cubic lattice-based N-dimensional constellations. These constellations have a large shaping gain, but offer no coding gain. Since maximum achievable coding gains (up to about 6 dB) are significantly larger than the maximum shaping gain of 1.53 dB, the present approach will be useful only if it allows constellations based on trellis codes that coding gains over the cubic lattice. We now describe how SVQ shaping can be implemented on trellis-coded constellations. In fact, the SVQ-shaped trellis-coded constellation is the transmission dual of the trellis-based scalar-vector quantizer described in [51.</p><p>--r It was shown in <ref type="bibr">[2]</ref> that trellis codes can be constructed from a redundant cubic lattice (that has a higher density of points than required) to achieve significant coding gains. Most of the useful trellis codes belong to the class of coset codes [31. A d,-dimensional binary trellis code is constructed by partitioning a d,-dimensional binary lattice A into v = 2k+' cosets of a sublattice A', which we call the coset lattice. A rate k / ( k + 1) convolutional code G, is used to specify the coset. Since many good codes can be constructed from redundant cubic lattices, we shall assume here that both A and A' are cubic lattices. The k input bits to the convolutional encoder produce k + 1 output bits, called the coded bits, which select one of the v cosets of A!. The remaining input bits, called the uncoded bits, select a point within the coset lattice A'.</p><p>Shaping of trellis-coded constellations can be easily accomplished by requiring that each wset of A' (in A) have the same cost (energy) profile, i.e., by requiring that all points of a given cost in A must be distributed equally between the v costs. If this requirement is satisfied, we can form vtuples of equal cost points such that each vtuple contains exactly one point from each of the v cosets. Shaping is now performed only on the uncoded bits or, equivalently, only on the coset lattice A'. The output of the shaping encoder is a block of m points in A'.</p><p>Each point in A' specifies a unique vtuple. The k + 1 coded bits (per d, dimensions) at the output of the conventional encoder G, are only used to select one of the points in this u-tuple.</p><p>In QAM transtnission, the lattice (translate) A is usually Z2 + (1/2,1/2). This could, for example, be partitioned into four cosets of 22' + (1/2,1/2) which are selected using a rate 1/2 convolutional coder. In this case, it is easy to check that the four cosets have identical energy profiles. This is because 0", !No, </p><formula xml:id="formula_16">= Z2 + (1/2,1/2) into four cosets of h' = 22' + (1/2,1/2).</formula><p>As mentioned above, the encoder shapes only the cubic coset lattice (translate) A' using the m(r -1) uncoded bits. This can be done by using the encoder described in Fig. <ref type="figure" target="#fig_2">1</ref>. The output of the shaping operation is a block of m points in A' . Each point in A! specifies a unique 4-tuple (v = 4) containing exactly one point from each coset of A'. The m X 1 input bits to the convolutional encoder produce m X 2 coded bits which are used to convert the block of m points in A' to a trellis code sequence. In the receiver, a Viterbi decoder is used to map the received sequence to the nearest trellis code sequence. The received sequence is partitioned into blocks of m points, each in A. Assuming that no channel errors occurred, the coset information is used to recover m x 1 bits using Gc-', and the block of received points in A is converted to points in A'. Now, the decoder of Fig. <ref type="figure" target="#fig_2">1</ref> is used to recover the remaining m(r -1) information bits.</p><p>As another example, we will now describe how SVQ shaping on regions as explained in Section V can be used with trellis channel coding. Suppose shaping is performed on frames consisting of m 2D-symbols. Each frame, the 'For low rate constellations, this could lead to some loss in shaping gain. In this case, the indexing algorithm similar to that of the trellisbased scalar-vector quantizer [5] can be used. This algorithm avoids the above requirement, and hence does not result in any loss in shaping gain, even for low rate constellations. shaping encoder accepts n, shaping bits and maps them into one of 2"s region vectors. The channel trellis encoder accepts k, bits per 2D symbol and generates a sequence of 2D subsets. The 2D regions must be selected so that each region Contains the same number of points, and there are an equal number, 2 " ~, of points from each coding subset in each region. The transmitter accepts nu uncoded bits per 2D symbol, which are used to select a unique 2D point from the ring specified by the corresponding component of the region vector and subset specified by the channel trellis encoder. The resulting sequences are paths in the trellis of the channel trellis encoder.</p><p>If the Viterbi decoder makes an error due to channel noise, the recovered data bits will be corrupted. In general, it is not possible for the decoder to conclude if an error has occurred. However, in the above scheme, there is one type of error that is easily detectable. It corresponds to the case when the received block of m points at the output of the Viterbi decoder has a total cost greater than the threshold L. This is called a constellation overload error. Clearly, this can only be the result of a channel error. This kind of error is most likely to result from the outermost points in the shaping region. A simple way to deal with it is to let it cause bit errors. Often, the knowledge that an error has occurred is useful even if the error cannot be corrected. A better but computationally more expensive way to deal with overload errors is to use a search algorithm that maps the received channel output sequence to the closest "allowed" (within the shaping region) trellis sequence rather than the closest trellis sequence. For this purpose, an algorithm similar to the codebook search algorithm of the trellis-based scalar-vec-tor qantizer [5] can be used in place of the simpler Viterbi trellis decoder. While this does not guarantee error-free decoding, it reduces the probability of such errors. This gain is the result of the fact that the outermost constellation points in the shaping region have fewer neighbors than the inside points. For Voronoi constellations, such errors are not easy to detect, and hence no such error correction possibility exists.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. COMPARISONS WITH TRELLIS SHAPING</head><p>Trellis shaping was introduced by Fomey in [lo] and uses the "Voronoi region" of a trellis code to shape the constellation. It can realize large shaping gains-1.36 dB with a 256-state trellis. By incorporating peak constraints, peak signal power can be significantly reduced to make trellis shaping useful in practice. Since trellis shaping has been implemented in commercial modems and is a practical alternative to SVQ shaping, we will now compare them.</p><p>Trellis shaping based on Ungerboeck's four-state 2D code is simple to implement and results in about 1 dB shaping gain. With peak constraints, the corresponding PAR, is 3.75 and the CER, is about 1.5. The same shaping gain can also be obtained using 16-dimensional SVQ shaping, which is also simple to implement and results in similar PAR, and CER, but smaller encoding delay (only 8 QAM symbols rather than about 20 for trellis shaping). On the other hand, 1 dB shaping gain can be obtained using 32-dimensional SVQ shaping with a PAR, of only 3.2, and also using 64-dimensional shaping with a PAR, of only 2.9. This is even smaller than the PAR, = 3 of the baseline unshaped constellation. Such small values of PAR, are useful for transmission over most real-world channels because they introduce harmonic distortion at high signal levels. For trellis shaping (with 1 dB shaping gain), the PAR, cannot be reduced below 3.75. Also, trellis shaping requires constellation switching to support a noninteger bit rate per symbol, whereas SVQ shaping can naturally support noninteger rates.</p><p>It seems that shaping gains higher than 1 dB are more easily attainable with SVQ shaping than trellis shaping. In general, for a given PAR, or C E R , , no other shaping scheme results in a higher shaping gain and smaller delay than the one described in this paper.</p><p>In this paper, we have implicitly assumed that the channel over which the constellation points are transmitted is a memoryless channel corrupted by white Gaussian noise. In practice, there are important channels which are not memoryless, but suffer from intersymbol interference. Until recently, trellis shaping had an edge over other shaping methods because it was the only scheme that could be combined with an equalization technique called precoding-resulting in trellis precoding-to realize shap ing gains over intersymbol interference (ISI) channels [171. But a newly disclosed precoder [23]-[251 decouples shaping and equalization and enables the use of SVQ shaping (or any other method of shaping) for transmission over IS1 channels. The ITU-TSS committee formulating the V.fast modem standard was considering including trellis precoding, but has now agreed to use shell mapping (SVQ shaping) and a precoder similar to <ref type="bibr">[23]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. CONCLUSIONS</head><p>We have described a new shaping scheme called SVQ shaping. SVQ shaping is motivated by a type of structured vector quantizer called the scalar-vector quantizer. Optimal (N-sphere) SVQ shaping can realize a large fraction of the maximum shaping gain of 1.53 dB. Its implementation complexity is polynomial in the constellation dimension N and (at high rates) is independent of the constellation rate. Although their shaping gain approaches 1.53 dB as N + a, N-sphere bounded constellations result in a large CER, and PAR,, and are therefore not suitable for transmission over QAM channels. It is shown that SVQ shaping can achieve the maximum shaping gain for a given CER, (or PAR,) and constellation dimension. This is useful because even a small constellation expansion can result in relatively large shaping gains.</p><p>SVQ shaping offers a better PARJshaping gain/delay tradeoff than trellis shaping (even with peak constraints), is simple to implement, and can support noninteger data rates without constellation switching. This makes it a superior alternative to trellis shaping.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>=</head><label></label><figDesc>gi(iu) + c;:(W-l where 8'Cu) is the number of cost Ti('u) vectors in B m ~ that are smaller than 'U and can be computed in terms of pairs of m(i+l,-vectors as T'+'('v,)-1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>cost of the first half ' u l of 'U can be determined from (7) and, consequently, the cost of the second half. The second and third terms on the right-hand side of (7of the m-vectors that have the same total cost as 'U and the same first half costs. Therefore, Knowing the first half weight, we can compute the residual term Finally, the two 8's in B can be found by observing that and T(i+ 1) i 0 I. 8'+1('Ul) I Mm(i+IJvl).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Transmitter/receiver structure for an SVQ-shaped cubic lattice-based constellation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Shaping gain ys as a function of CER, for SVQ shaping.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Fig. 4. Transmitter/receiver structure for the example in Section V.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Transmitter/receiver structure for an SVQ-shaped trellisooded constellation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE I COMPUTATIONAL AND STORAGE CQMPLEXITIES OF THE *o INDEXING ALGORITHMS</head><label>I</label><figDesc></figDesc><table /><note><p><p><p>I</p>. , .</p>. .</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>IEEE TRANSACr'IONS ON INFORMATION THEORY, VOL. 40, NO. 4, JULY 1994</head><label></label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>N r bits</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>Decoder</cell></row><row><cell>N T bits</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">A Encoder I map k---point constellation noise</cell><cell>quantizer</cell></row><row><cell>Transmitter</cell><cell cols="2">Channel</cell><cell></cell><cell>Receiver</cell></row><row><cell>2</cell><cell>0.2</cell><cell>1.0</cell><cell>2.0</cell></row><row><cell>4</cell><cell>0.46</cell><cell>1.41</cell><cell>3.0</cell></row><row><cell>8</cell><cell>0.73</cell><cell>2.21</cell><cell>5.0</cell></row><row><cell>16</cell><cell>0.98</cell><cell>3.76</cell><cell>9.0</cell></row><row><cell>32</cell><cell>1.17</cell><cell>6.80</cell><cell>17.0</cell></row><row><cell>64</cell><cell>1.31</cell><cell>12.79</cell><cell>33.0</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE III THE SHAPING GAIN r FOR A GIVEN CER . THE CORRFSPONbING &amp;UES OF Pa,, C A , ,</head><label>III</label><figDesc>CERl I PAR1 1 CER2 ] PAR2</figDesc><table><row><cell></cell><cell cols="2">N = 32</cell></row><row><cell></cell><cell cols="2">N = 64 -</cell></row><row><cell>0.00</cell><cell>1.00</cell><cell>3.00</cell></row><row><cell>1.04</cell><cell>1.12</cell><cell>4.83</cell></row><row><cell>1.09</cell><cell>1.15</cell><cell>5.09</cell></row><row><cell>1.17</cell><cell>1.20</cell><cell>5.67</cell></row><row><cell>1.24</cell><cell>1.29</cell><cell>6.67</cell></row><row><cell>1.27</cell><cell>1.39</cell><cell>7.76</cell></row><row><cell>1.29</cell><cell>1.50</cell><cell>9.12</cell></row><row><cell>1.30</cell><cell>1.65</cell><cell>11.08</cell></row><row><cell>1.30</cell><cell>1.74</cell><cell>12.24</cell></row><row><cell>1.30</cell><cell>2.01</cell><cell>16.35</cell></row><row><cell>1.30</cell><cell>2.47 -</cell><cell>24.70</cell></row></table><note><p>AND PAR, AREALSO GIVEN I . (dB) I</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table</head><label></label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>TABLE IV THE SHAPING GAIN r, FOR A GIVEN CER *. THE IS ALSO GIVEN ys (dB) I CER2 I PAR2 N = 32 CORRESPONDING VALUE OF PAR, 0.00</head><label>IV</label><figDesc></figDesc><table><row><cell></cell><cell>1.00</cell><cell>2.00</cell></row><row><cell>0.54</cell><cell>1.05</cell><cell>2.27</cell></row><row><cell>0.80</cell><cell>1.14</cell><cell>2.62</cell></row><row><cell>0.94</cell><cell>1.24</cell><cell>2.95</cell></row><row><cell>1.02</cell><cell>1.36</cell><cell>3.28</cell></row><row><cell>1.09</cell><cell>1.54</cell><cell>3.79</cell></row><row><cell>1.13</cell><cell>1.75</cell><cell>4.34</cell></row><row><cell>1.15</cell><cell>1.99</cell><cell>4.96</cell></row><row><cell>1.17</cell><cell>2.47</cell><cell>6.17</cell></row><row><cell>1.17</cell><cell>3.06 -</cell><cell>7.67 -</cell></row><row><cell></cell><cell>= 64</cell><cell></cell></row><row><cell>0.00</cell><cell>1.00</cell><cell>2.00</cell></row><row><cell>0.64</cell><cell>1.05</cell><cell>2.33</cell></row><row><cell>0.81</cell><cell>1.10</cell><cell>2.53</cell></row><row><cell>0.92</cell><cell>1.14</cell><cell>2.71</cell></row><row><cell>1.06</cell><cell>1.24</cell><cell>3.04</cell></row><row><cell>1.22</cell><cell>1.51</cell><cell>3.82</cell></row><row><cell>1.29</cell><cell>2.01</cell><cell>5.16</cell></row><row><cell>1.30</cell><cell>2.53</cell><cell>6.52</cell></row><row><cell>1.30</cell><cell>2.99 -</cell><cell>7.72</cell></row></table></figure>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The work of R. Laroia and N. Farvardin was supported in part by the National Science Foundation under Grants NSFD MIP-91-09109 and NSFD CDR-85-00108. This paper was</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SVQ-Constellation Computation Storage (bit-operations per d-dimensions)</head><p>(bits)</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Lattice and trellis quantization with lattice-and trellis-bounded codebooks-High-rate theory for memoryless sources</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">V</forename><surname>Eyuboglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Fomey</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="55" to="67" />
			<date type="published" when="1982-01">Jan. 1982</date>
			<publisher>G. Ungerboeck</publisher>
		</imprint>
	</monogr>
	<note>ZEEE Trans. Inform. Theory</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Coset codes-Part I Introduction and geometrical classilication</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Fomey</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="1123" to="1151" />
			<date type="published" when="1988-09">Sept. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Trellis coded quantization of memoryless and Gauss-Markov sources</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Marcellin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">R</forename><surname>Fischer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Commun., R. Laroia and N. Fawardin</title>
		<imprint>
			<biblScope unit="page" from="860" to="870" />
			<date type="published" when="1994-05">May 1994</date>
		</imprint>
	</monogr>
	<note>IEEE Trans. Inform. Theory</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Lattice and trellis quantization with lattice-and trellis-bounded codebooks-Construction and implementation for memoryless sources</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">V</forename><surname>Eyuboglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Balamesh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">submitted to ZEEE Trans. Inform. Theory</title>
		<imprint>
			<date type="published" when="1991-10">Oct. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A structured fixed-rate vector quantizer derived from a variable-length scalar quantizer-Part I: Memoryless sources</title>
		<author>
			<persName><forename type="first">R</forename><surname>Laroia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Favardin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint>
			<date type="published" when="1993-05">May 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Multidimensional constellations -Part I: Introduction, figures of merit, and generalized cross constellations</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Fomey</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">F</forename><surname>Wei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J. Select. Areas Commun</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="877" to="892" />
			<date type="published" when="1989-08">Aug. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Multidimensional constellations-Part II: Voronoi constellations</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Fomey</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J. Select. Areas Commun</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
		</imprint>
	</monogr>
	<note>IEEE Trans. Inform. Theory</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Nonequiprobable signaling on the Gaussian channel</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Calderbank</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">H</forename><surname>Ozarow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Binary covering codes and high speed data transmission</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Calderbank</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Symp. Coding Theory and Appl</title>
		<meeting><address><addrLine>Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990-11">Nov. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Balanced codes and nonequiprobable signaling</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Calderbank</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Klimesh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="1119" to="1122" />
			<date type="published" when="1992-05">May 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Shaping using variable-size regions</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">N</forename><surname>Livingston</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theoiy</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="1347" to="1353" />
			<date type="published" when="1992-07">July 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Efficient modulation for band limited channels</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Fomey</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J. Select. Areas Commun</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="632" to="647" />
			<date type="published" when="1984-09">Sept. 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A fast encoding method for lattice codes and quantizers</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Conway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">J A</forename><surname>Sloane</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Trellis precoding</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">V</forename><surname>Eyuboglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Fomey</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ZEEE Trans. Inform. Theory</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="301" to="314" />
			<date type="published" when="1992-03">Mar. 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Design and analysis of a structured fixed-rate vector quantizer derived from variable-length scalar quantizers</title>
		<author>
			<persName><forename type="first">R</forename><surname>Laroia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Dep. Elec. Eng. and Syst. Res. Cen</title>
		<imprint>
			<date type="published" when="1992-05">May 1992</date>
			<pubPlace>UNv. Maryland, College Park</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Ph.D. dissertation</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A Leech lattice modem</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Lang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">M</forename><surname>Hnstaff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ZEEE J. Select. Areas Commun</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="968" to="973" />
			<date>Aug. i989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Shaping multidimensional signal spaces-Part I: Optimum shaping, shell mapping</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Khandani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Theory</title>
		<imprint>
			<biblScope unit="page" from="1794" to="1808" />
			<date type="published" when="1993-11">Nov. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Shaping multidimensional signal spaces-Part I 1 Shelladdressed constellations</title>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint>
			<biblScope unit="page" from="1809" to="1819" />
			<date type="published" when="1993">NOV. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Optimal shaping properties of the truncated polydisc</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">R</forename><surname>Kschischang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pasupathy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A simple and effective precoding scheme for noise whitening on intersymbol interference channels</title>
		<author>
			<persName><forename type="first">R</forename><surname>Laroia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tretter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Farvardin</surname></persName>
		</author>
		<idno>TR 30.1, TR 30.1/92-01-003</idno>
	</analytic>
	<monogr>
		<title level="j">TR Motorola Inform. Syst</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="726" to="740" />
			<date type="published" when="1989-08">Oct. 1993. Jan. 1992. Jan. 1993. Jan. 1990. Aug. 1989. 281-300, Mar. 1992. July 1990</date>
			<publisher>General Data Comm, Inc</publisher>
		</imprint>
	</monogr>
	<note>A flexible form of precoding for V.fast,&quot; contribution to TIA Subcommittee</note>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title/>
		<author>
			<persName><surname>It-29</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="106" to="109" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
