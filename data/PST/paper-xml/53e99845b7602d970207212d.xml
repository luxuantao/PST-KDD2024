<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Many-Sorted Unification</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Christoph</forename><surname>Walther</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Universitcit Karlsruhe</orgName>
								<address>
									<settlement>Karlsruhe</settlement>
									<country key="DE">Federal Republic of Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Universitit Karlsruhe</orgName>
								<orgName type="institution" key="instit2">lnstitut ftir lnformatik I</orgName>
								<address>
									<postCode>6980, D 7500</postCode>
									<settlement>Postfach, Karlsruhe 1</settlement>
									<country key="DE">Federal Republic of Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Many-Sorted Unification</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">FA3034277B467CCD09138538BE9FB41E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T10:14+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>F.2.2 [Analysis of Algorithms and Problem Complexity]: Nonnumerical Algorithms and Problems-pattern matching</term>
					<term>F.4.1 [Mathematical Logic and Formal Languages]: Mathematical L.&amp;c-mechanical theorem proving</term>
					<term>1.1.3 [Algebraic Manipulation]: Languages and Systems-substitution mechanisms</term>
					<term>1.2.3 [Artificial Intelligence]: Deduction and Theorem Proving-resolution Algorithms, Theory, Verification Equality reasoning, many-sorted logic, restricted quantification, taxonomic reasoning, unification</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Many-sorted unification is considered; that is, unification in the many-sorted free algebras of terms, where variables, as well as the domains and ranges of functions, are restricted to certain subsets of the universe, given as a potentially infinite hierarchy of sorts. It is shown that complete and minimal sets of unifiers may not always exist for many-sorted unification. Conditions for sort hierarchies that are equivalent for the existence of these sets with one, finitely many, or infinitely many elements are presented. It is also proved that being a forest-structured sort hierarchy is a necessary and sufficient criterion for the Robinson Unification Theorem to hold for many-sorted unification. An algorithm for many-sorted unification is given.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>There is a wide variety of areas, particularly in computer science, where unification problems arise; for instance, in databases, information retrieval, computer vision, natural language processing, expert systems, computer algebra, programming languages, automated theorem proving, and logic programming.</p><p>A special point of interest in unification theory is whether a set of most general unifiers for a unification problem exists under a certain theory, that is, a set of unifiers U such that each unifier is an instance of one of the unifiers in U (completeness) and no unifier in U is an instance of another member of U (minimality). Such a set may not always exist <ref type="bibr" target="#b5">[6]</ref>, but, when it does, the cardinality of this set can be used to induce a classification of the theories under which unification is performed: A theory is of type unitary iff each such set (in that theory) is a singleton; it is of type finitary iff such a set has always finitely many elements; otherwise it is of type infinitary <ref type="bibr" target="#b19">[20]</ref>.</p><p>This paper is concerned with unification in many-sorted empty equational theories. It was inspired by the fact that in many practical applications variables, as well as the domains and ranges of functions, are restricted to certain subsets of the universe, which are given as a hierarchy of sorts, that is, a partially ordered and potentially infinite set of sorts. Many-sorted unification (Z-unification for short) is the same as solving an equation in the corresponding heterogeneous many-sorted algebra <ref type="bibr" target="#b8">[9]</ref> rather than in a homogeneous algebra.</p><p>We prove in this paper that Z-unification can be classified completely by conditions imposed on the structure of the sort hierarchy. We show that complete and minimal sets of &amp;unifiers may not always exist, and we present a condition for sort hierarchies that is equivalent for the existence of these sets.</p><p>We also present conditions for sort hierarchies that are equivalent whether I;unification is of type unitary, of type finitary, or of type infirmary. We prove that being a forest structure is a sufficient and necessary criterion for the Robinson Unification Theorem to hold for many-sorted unification; that is, a criterion for the existence of a most general unifier without "auxiliary variables." Finally we present an algorithm for many-sorted unification. This paper thereby generalizes and extends the results presented in <ref type="bibr" target="#b24">[25]</ref>. It is a shortened version of the technical report <ref type="bibr" target="#b26">[27]</ref>, to which the reader is referred for any omitted proofs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Formal Preliminaries</head><p>Given pairwise disjoint alphabets, the infinite set of variable symbols Z;: and the set offunction symbols Z together with an arity function for them, we let Y denote the set of all well-formed terms over T and X For a term t, V(t) denotes the set of all variable symbols in t. For a set D of terms, Y(D) is defined as UtED V(t).</p><p>A mapping u from 7 to 9 with ax = x almost everywhere is called a substitution. Substitutions are extended as endomorphisms to mappings from 9 to 91 t is the empty or identity substitution; that is, LX = x for all x E Z For subsets D of 9 we define uD = (ut I t E D 1. The domain of u, denoted DOM(u), is given by lx E 7 ] ax # x), and the codomain (or range) COD(u) of u is defined as uDOM(u). Substitutions will be sometimes denoted by a finite set of variable-term pairs(x,tt*,...,</p><p>x,, t t,,). SUB is the set of all substitutions. Given u, p E SUB, u 0 p denotes the function composition, that is, (a 0 p)x = a(px) for all x E YT A separation of u is a sequence of ul, . . . , u,, of substitutions with pairwise disjoint domains and codomains satisfying (1) u = uI 0 . . . Q a,, A sort hierarchy is a pair (9 &lt;P) such that 9 is a nonempty set partially ordered by c9. The members of 9 are called sort symbols, and c9 is the subsort order of 9 If sl + s2 or sI = s2, we write s1 59 s2 and say sI is a subsort of s2. If 9 is known from the context, we omit the indices; for example, we write &lt; for c9.</p><p>A sort hierarchy (Z &lt;) is a forest structure iff sI 2 s I s2 implies sI r s2 or s1 5 s2 for all sI, ~2, s E 3 Following the standard terminology of lattice theory, for example <ref type="bibr">[ 11,</ref> we define for each so E 9 and each S C 9: so is the least element of S iff so E S and so I s for all s E S. so is a maximal element of S iff so E S and SO # s for all s E S. SO is a lower bound of S iff so 5 s for all s E S. so is the greatest lower bound or infimum of S, denoted nS, if additionally s' 5 so for each lower bound s' of S.</p><p>The set of all maximal elements in S is denoted max(S), and lbs(S) is the set of all lower bounds of S in 9; that is, max(S) = (so E Sl so K s Vs E SJ and lbs(S) = (SO E 9 ] SO I s Vs E SJ. S is a chain in 9 iff S is totally ordered by c, that is, sI 5 s2 or s1 L sz for all sl, s2 E S. (Z ~9) is called a meet-semilattice iff each pair of sort symbols s1 and sz has an infimum.</p><p>For a sort hierarchy (x C) let 9'* denote the set of all finite strings from 3 including the empty string e. For each s E 9 and each w E P* let % be an infinite set of variable symbols and let &amp;,,, be a set of function symbols such that all these sets are pairwise disjoint. An P-sorted signature Z is a family Z,,, of sets such that Z,, = Z U 9&amp;. Setting 7 = USE, K and 9-= UwE9*,sE~%,s we define terms as in the unsorted case, where the arity of eachfE 9&amp; is given by the length of the string w.</p><p>For a function symbol f E Zu, s(~),s, the ith domainsort off; denoted [f]i, iss(i),provided 1 =irk.Thesort For an Y-sorted signature Z, the set 7, of all well-sorted terms (or Z-terms for short) is the smallest subset of 7 satisfying (1) Z U 9&amp; C .% for each s E 9 and (2) f(q, . . . qk) E Sz, if qi E Sz and [ qi] 5 [ f]i for each i with 1 5 i I k. These notions are consistent with the standard terminology: For cY = 0, that is, sI z+ s2, iff sI = s2, Z is the free X-algebra generated by 7 denoted F(Z U z") in [ 121 or 55(F) in [lo]. 7, is the Z-word algebra on K denoted W,(Y) in <ref type="bibr" target="#b1">[2]</ref> if 9 is a singleton. The difference is that, for a sequence qI, . . . , qk of Z-terms and somefE ~~l~...s~k~,s, f(ql . . . qk) E FX implies [qi] I s(i), whereas in the unordered (and standard) case [qi] = s(i) is required.</p><p>A substitution d satisfying uYZ C S, is called well-sorted or a Z-substitution. A more useful characterization is [ux] I [x] and ax E S, for all x E K and it can be proved that both definitions are equivalent (cf. <ref type="bibr" target="#b26">[27]</ref>). SUB, is the set of all Zsubstitutions. Again these notions are in accordance with the many-sorted unordered case, where a substitution is defined as a sort-preserving Z-endomorphism from SX to S, [ 121, thus guaranteeing [cx] = [x] and ax E 7, for each x E K</p><p>The quasi-ordering s2: of Z-subsumption in SZ is defined by q sz r iff Bq = r for some 13 E SUBL:. Hence x $ y iff [x] ZZ~ [ y] for all x, y E % The corresponding quasi-ordering z$ (I VI) of Z-subsumption in SUB2 over some V C z/ is given as u sZ eI[ V] iff X 0 u = 01 VI for some X E SUBZ, and the corresponding equivalence relation 1x 1 VI is defined by u~zP([V~iffa=zPt[V~andp~zu(['V~.</p><p>The following observation leads us to introduce sZ and Z$ I[ VI): For the unsorted case we can prove that for all 41, q2 E 7 %!({ql, q2}) # 0, provided q1 I t and q2 3 t for some t E 7 and ql, q2 have no variables in common. But this result cannot be generalized to the many-sorted case; that is, replacing Y by SZ and Z! by VZ renders the above proposition false because having a common well-sorted instance is not sufficient for having a well-sorted unifier for a variable disjoint pair of well-sorted terms. For instance, the variables b of sort bool and i of sort integer are not &amp;unifiable, although both have fi (of sort real) as common well-sorted instance. However, if, additionally, 5 is replaced by sZ, the above proposition now also holds true in the many-sorted case.</p><p>Given a finite subset D of S, and a substitution 6, 8 is a Z-unifier of D and D is 2-uni$uble by (9 iff B is well-sorted and unities D. 22"(D) = g(D) n SUB, is the set of all Z-unifiers of D. c is a well-sorted most general unifier or a Z-mgu of D iff u E SUBz is an mgu of D, which obviously is equivalent to (I sZ B for all e E 2&amp;(D).</p><p>But, unfortunately, the notion of a most general unifier is too strong to provide us with all the necessary concepts when unification is generalized to the manysorted case (with &lt;Y # 0). The situation is similar (but not identical) to that of unification under equational theories, where the notion of an mgu is replaced by the concept of complete and minimal sets of unifiers <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr">201</ref></p><formula xml:id="formula_1">: U C ?&amp;(D) is a complete set of Z-unifiers of some D C YZ iff for each 0 E %-(0) there is some u E U such that u $ O([Y(D)]. U C F&amp;(D) is minimal iff (r sz: &amp;T(D)] implies c = p</formula><p>for all U, p E U. Each complete and minimal set of Z-unifiers is unique up to variable renaming!+ that is, for any complete and minimal pair UI, UZ C f&amp;(D) we have: For each u E U, there exists exactly one p E UZ such that u sZ &amp;T(D)] (the proof is the same as in the unsorted case, cf. <ref type="bibr" target="#b5">[6]</ref>).</p><p>Although these notions are similar to the notions used for unification under equational theories, there are essential differences: Equality = is generalized to equality =E modulo some equational theory E, but the notion of substitutions is not affected when equational reasoning is introduced to unification theory. In many-sorted unification, substitutions are restricted to well-sorted ones, but equality remains unchanged. Hence F&amp;(D) C Y/(D) C VE(D) for each D C 55 and an equational theory E.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Some Z-Unljication Problems</head><p>The following examples should serve to demonstrate the problems associated with Z-unification and to illustrate the results presented in the subsequent sections. We show how the existence and cardinality of complete and minimal sets of Z-unifiers depend on the structure of a sort hierarchy. Later we prove that each Z-unifiable Zterrnset has a Z-mgu, provided (Z -+) is a forest. The reason is that in a forest-structured sort hierarchy each Z-unifiable pair of variables, as x, y above, can be arranged in an mgu, that is, x t y or y c x, so that the resulting substitution is well-sorted.</p><p>In addition, we prove that being a forest structure is also a necessary condition for the Robinson Unification Theorem [ 171 to hold true for many-sorted uniftcation. As a consequence, we have to use auxiliary variables in order to obtain complete and minimal sets of Z-unifiers if non-forest-structured sort hierarchies are used. Unfortunately, however, the existence of complete and minimal sets of Z-unifiers is not guaranteed at all; that is, there are cases in which a Z-unifiable Z-termset has no complete and minimal set of Z-unifiers. Further on we formulate a condition for sort hierarchies, called the maximalsorts condition, and we prove that this condition is an equivalent characterization for the existence of complete and minimal sets of Z-unifiers; cf. Theorem 7.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Most General Weakening Sets</head><p>Throughout the following three sections we let D be any finite and Z-unifiable subset of Sz for which we are seeking a complete and minimal set of Z-unifiers. As we have seen in Example 3.2, auxiliary variables can become indispensable in order to obtain such a set. These new variables are formally introduced by certain Z-substitutions, called weakening substitutions, which replace certain variables in the set D. The application of a weakening substitution can be thought of as a kind of coercion process that is necessary in programming languages with types (e.g., Pascal or Ada), whenever the types of a variable and an expression do not agree in an assignment.</p><p>Since there are several distinct variable replacements, we also have several distinct weakening substitutions, which are collected in a so-called most general weakening set W(D) of D.</p><p>Let us look closer at the introduction of new variables before we go into formal details: Suppose that, during the computation of a complete and minimal set of Zunifiers of D, as a subproblem some variables (x1, . . . , x,,) = V C Y(D) have to be I;-unified "as generally as possible.</p><formula xml:id="formula_2">" If n[ V] E [VI, then n[ V] = [x]</formula><p>for some xE VandX,= (x,+x,..., x, t x) is obviously a Z-mgu of I/, that is, we do not need auxiliary variables in this case. But for n[V] 4 [VI, X, cannot be a Z-substitution for any x E I/. We need a new variable, say y, and X, = (x, t y, . . . ) x, c y) unifies V.</p><p>But which sort do we stipulate for y? We have to guarantee [ y] E lbs[ V], because otherwise the result cannot be well-sorted (which is a matter of correctness). As we shall see in subsequent sections, [y] E max(lbs[ I']) is a necessary condition to obtain a minimal set of Z-unifiers. But max(lbs[V]) may have more than one element, and as a matter of completeness we need a new variable y(s) for each s E max(lbs[ V]).</p><p>Hence U =( X,,(S) E SUBz ] s E max(lbs[ I'])) is a minimal subset of&amp;(V), but U is only complete if in addition for each s E lbs[ I'] some s, E max(lbs[ V]) exists such that s 5 s,.</p><p>To define the weakening substitutions for a given D C Sz, we have to identify the subsets I/ of Y'(D) (as the set V above) that necessitate a variable replacement. The following technical lemma shows that these sets are given as the equivalence classes of-D of which the sortal image has no least element. (3) W = {pf E SUB 1 r; = (Xi + vari(S)j for some s E max(lbs[ vi])), where Xi E Vi is arbitrary but fixed.</p><p>A most general weakening set or mgw-set W of D is a subset of SUB satisfying By this lemma there is no more need of "coercions" after an application of a weakening substitution; that is, all weakening substitutions ~1 E W(D) share the interesting property that each pD has a Z-mgu. This result will provide the key for the main theorems about X-unification in the subsequent sections. Since we obtain bi from ri by a variable renaming, we know u 0 7, = 7, and it is easily proved that [nix] 5 [x] and oix E "t for all x E Z Hence</p><p>(5) u 0 T. is an mgu of PD, and ( <ref type="formula">6</ref>) u E SUBr,.</p><p>We prove that u 0 7,, E SUBL:; that is, we have to show for each x E Y by <ref type="bibr" target="#b1">(2)</ref> and 0 E SUB,. Hence (7) holds in either case. For x 4 DOM(r,J we obtain ~?~x = ax E Z;: and ( <ref type="formula">8</ref>) holds for this case. Now let x E DOM(r,,) and t = T,,x. We assume by way of contradition that at B 9,. Then t has a subterm r =f(r, . . . Q) such that <ref type="bibr" target="#b8">(9)</ref> [urj] $ [ f]j for some j with 1 c j 5 k.  <ref type="formula">7</ref>) and ( <ref type="formula">8</ref>) we obtain u Q T,, E SUBz; hence by (5) u 0 7" is a Z-mgu OfPD. 0</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Z-Unification with Forest-Structured Sort Hierarchies</head><p>We consider here the special case in which (Z +) is a forest structure, that is, a (finite or infinite) collection of (finite or infinite) trees. This special case deserves our interest because we can prove that being a forest structure is a necessary and suflcient condition for a sort hierarchy such that the Robinson Unification Theorem [ 171 holds for many-sorted unification. To prove the completeness of an mgu-set, we use the fact that each Z-unifier is Z-subsumed by some weakening substitution, provided the maximal-sorts condition is satisfied. PROOF. Let U = V(W) be an mgu-set relative to some mgw-set Wof D. By the hypothesis, D satisfies the maximal-sorts condition; hence with Lemma 6.1 X 0 p= e[P(o)] for some ~1 E Wand some X E SUBz. llo has a Z-mgu by Theorem 4.3; hence by Definition 6.1 u 0 Jo E U for some Z-mgu u of PLD. With 0 E &amp;(D) we have X E Z&amp;D); hence X = X 0 6. But then X 0 60 p = X 0 P = el[Y(o)]; that is, u 0 p sz epqq. 0</p><p>Note that the completeness of an mgu-set is guaranteed only if the Z-unifiable Z-term&amp; under consideration satisfies the maximal-sorts condition. To prove the minimality, no such proviso is required. Again we need a technical lemma before proving the main theorem. PROOF. Let us assume by way of contradiction that X 0 p1 = p2[Y(D)jJ for some X E SUBZ, but p I # ~2. By Definition 6.1 there is an mgw-set W of D, some pl, p2 E W, and some (rl, u2 E SUB, such that for j = 1, 2</p><p>(1) pi= CjOpjand (2) uj is a Z-mgu of PjD.</p><p>For ~1 = ~2, U\(pjJ (for any j E (1, 2)) would also be an mgu-set of D by Definition 6.1. But this is impossible because U is a minimal subset of SUB satisfying conditions (1) and ( <ref type="formula" target="#formula_0">2</ref> From ( <ref type="formula">4</ref>) and ( <ref type="formula">5</ref>) we obtain [pixi] = [PzXi], which contradicts (3). Cl</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">A Classification of Sort Hierarchies</head><p>In Section 4 we defined the maximal-sorts condition for Z-unifiable Z-term&amp;s.</p><p>Here we extend this notion to sort hierarchies, and we prove that satisfying this condition is a necessary and sufficient criterion for a-sort hierarchy such that a complete and minimal set of Z-unifiers exists for each Z-unifiable Z-termset D.</p><p>We also define properties of sort hierarchies that are equivalent in having one, finitely many, or infinitely many members for a complete and minimal set of Z-unifiers of D. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">An Algorithm for Many-Sorted Unification</head><p>At the very heart of each (Robinson) unification algorithm variable symbols x have to be unified with terms t. The resulting substitution, represented by (x t t ), is composed of other substitutions of this kind, finally yielding an mgu for the set of terms initially given to the unification algorithm (provided the set is unifiable). Hence each unification algorithm contains a sequence of statements like that shown in Figure <ref type="figure">2</ref>.</p><p>On many-sorted unification a complete and minimal set of Z-unifiers is obtained by introduction of new variable symbols using most general weakening substitutions; cf. Definition 4.1.</p><p>We modify the unification algorithm to obtain an algorithm for Z-unification by replacing statement (3) in Figure <ref type="figure">2</ref> by the sequence of statements in Figure <ref type="figure">3</ref>.</p><p>Since the Z-unification algorithm returns a set of substitutions (instead of a single one, as in the unsorted case), the recursion case has to be modified accordingly: Most general solutions of a Z-unification problem are computed by stepwise combination (using functional composition) of most general well-sorted solutions of subproblems; cf. <ref type="bibr" target="#b27">[28]</ref>.</p><p>It can be verified using Theorems 7. For a forest-structured sort hierarchy (X C) with finite 9 we can also employ the standard unification algorithm for Z-unification by using a technique familiar in logic programming <ref type="bibr" target="#b3">[4]</ref>: With sort symbols used as unary function symbols, each well-sorted term t is represented by a term t* = s&amp;,(. . . s&amp;t') . . .), where the sequence of sort symbols in t* corresponds to the' sequence SO, . . . , s, of all sorts from a maximal element SO of 9 to the sort s,,, of t (i.e., for all i E (0, . . . , m -1) : si+r &lt; si and for no s E 9 Si+r C s &lt; St), and t ' is obtained from t by embedding the subterms of t in analogous sequences. Given t* and an analogous representation x* = &amp;@I(. -. s;(x) . . .) for a variable x as input, the unification algorithm returns (x t sn+r(. . . s&amp;t') . . .)) as a most general unifier ifn~mandsi=s~foralliE(O,...,n)andretums(tts~+~(...s~(x)...))</p><p>if t E q m 5 n, and si = S: for all i E (0, . . . , m).</p><p>These results correspond to the well-sorted mgu's (x c t) and (t c x), because [t] I [x] in the first case and [x] I [t] in the second one. Note that with 9 being finite, for each s,,, E 9 some so E max(9) exist such that s, 5 so (cf. proof of Corollary 7.3); hence t* exists for each term t. Moreover, t* is unique because (x &lt;) is a forest structure.</p><p>However, this method is extremely inefficient since terms become more nested by embedding them in sequences of sort symbols. Consequently, more recursive calls are performed during unification as compared with the modified algorithm, where the test for subsort relationships is static and does not necessitate any recursions. Also, with this technique, the sorts of function symbols are compared before performing the clash test. This is a useless effort, of course, because identical function symbols have the same sort, and terms beginning with different function symbols are not unifiable, no matter what sort these function symbols have. 9. Applications, Related Work, and Concluding Remarks As for ordinary unification, a Z-unification problem can be expressed in terms of first-order logic as the problem of deciding the validity of a certain first-order formula. For ordinary unification we have ( q, r ) is unifiable iff t= 3x1, . . . , x,, q = r, where q, I are any terms with Y( ( q, r]) = (xl, . . . , x,1 and = is the sign for syntactic equality. For Z-unification we obtain (q, rJ is Z-unifiable iff kz 3x, : sI , . . . , x,, : s,, q = r,</p><p>where Xi E xi and &amp; denotes the validity of a many-sorted first-order formula.</p><p>Using the sort-theorem for many-sorted logic (cf. <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b27">28]</ref>), we obtain (q,rj isZ-unifiableiff A"~=~x,,...,x, s*(x,) A -* * A s,(x,) A q = r, where A" is the set of sort axioms, which expresses (or encodes) the subsort order and the signature in terms of (unsorted) first-order formulas (cf. [24, 281) (using sort symbols as unary predicate symbols).</p><p>Starting with the Robinson Unification Problem [ 171, that is, unification in the empty equational theory or the free algebra of terms, respectively, several aspects of unification, for example, unification under special equational theories or universal unification, have been investigated, and unification theory has become an important subfield of artificial intelligence and computer science; cf. <ref type="bibr" target="#b19">[20]</ref>.</p><p>In particular, unification is a central notion in resolution-and paramodulationbased theorem proving (i.e., <ref type="bibr" target="#b16">[17,</ref><ref type="bibr">291)</ref>. In <ref type="bibr" target="#b23">[24]</ref> and <ref type="bibr" target="#b27">[28]</ref> a many-sorted version of a resolution calculus with paramodulation is proposed in which Z-unification can lead to a drastic reduction of the search space (cf. [23, 261 for a case study), and it is argued in <ref type="bibr" target="#b21">[22]</ref> that many-sorted unification implements a special procedure for taxonomic reasoning, which can be viewed (at least in particular cases) as an instance of the theory resolution principle.</p><p>Schmidt-Schauss extends this calculus with polymorphic function symbols (where the sort of a term f(t, . . . t,) can vary depending on the sorts of its arguments t1, * . . , t,), and the existence of complete and minimal sets of Z-unifiers with finite</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>COD(ai) = 1 yi) C 7 for each i with 1 I i c n, and (3) COD(u,J O Y = 0. A subset V of z/ induces an equivalence relation =I V] on SUB by u = p([ VI) iff ax = px for all x E V. The quasi-ordering 5 of subsumption is defined in Y by q I r iff Bq = r for some 8 E SUB. The corresponding quasi-ordering 51 V] of subsumption in SUB over some V C 7 is given as u I 61 V] iff X 0 u = rY([ VI for some X E SUB. =o[ VI) induces an equivalence relation =I V] on SUB by u = p[ VI iff u I p[ VI) and p I u1[ VI. 1 VD is omitted in the above definitions if V = SK Given a finite subset D = (t,, . . . , tn) of q a substitution 8 unifies D iff ] BD ] = l,thatis,Btl = . . . = et,,. In this case we say D is unifiable and B is a unifier of D. S(D) is the set of all unifiers of D. A unifier u of D is called a most general unifier (or mgu for short) iff u 5 0 for each B E Z(D). For any mgu u of D we have (1) DOM(U) u T(COD(U)) c 7(D), (2) u 0 u = U, (3) e = 00 u for each e E z(D), and (4) u = 7 iff 7 is also an mgu of D; cf. [5,6, 1 I]. Each unifiable subset D of Sr induces an equivalence relation -D on 9 x Y by q -D r iff uq = ar for some mgu u of D. By the most generality of u, this definition is independent of a particular mgu U. Y'/-D denotes the quotient set of .Y modulo -0. Obviously 44/(D) C g(M), and therefore ] A4 1 &lt; do for each equivalence class M E Y/-D (because infinite termsets are not unifiable).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>[t]ofatermtissifft~Kort=f(...)and f E 9&amp; for some w E 9 *. For D C S; [II] is the sortal image of D defined as ([t] E 9 ] t E DJ. Since the sort of a term is determined only by the outermost symbol oft, we have [at] = [t] and [aD] = [D] for each c E SUB, t E S\Z and DCS\%</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Example 3 . 1 .</head><label>31</label><figDesc>Let (z +) = (N, CN) and D = (x, y) with x E Y$ and y E '%, where N denotes the set of natural numbers ordered by &lt;N. Then uI = lx t y) and u2 = 1 y c x) are the only mgu's of D. For n ZN m, u1 E SUB2:, and for m ZN n, u2 E SUB,. Hence D possesses a Z-mgu in either case. Cl</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>FIG. 1 .</head><label>1</label><figDesc>FIG. 1. The sort hierarchies of Examples 3.2 and 3.3. Example3.2. Let9'=SUS~,withS=(a,b]andS~=(nEl!l~n&lt;~k),where k E IV+ U (m), and let &lt;Y = Sk x S. Figure la is a diagram of the sort hierarchy under consideration, which is obviously not a forest structure. Furthermore, let D = (x, y), with x E Z% and y E '5%;; let 6, = (x c y), u2 = ( y t x); and let 01, = (X t zh, y c zh), where zh E vh for any h E Sk. Since neither a C&amp;V b nor b $9 a, neither u1 nor a2 are Z-substitutions; that is, D has no Z-mgu. Now consider Uk = (&amp;, E SUB 1 h E Sk). Obviously Uk C Y&amp;(D), and later we prove that Uk is complete and minimal; cf. Appendix A. Cl We also present necessary and sufficient conditions for (X C-T) (cf. Theorem 7.2) such that each complete and minimal set of Z-unifiers of some Z-termset (1) is a singleton (as Uk for k = 1 in Example 3.2 above), (2) is finite (as Uk for k E N+ in Example 3.2 above), and (3) is infinite (as Uk for k = w in Example 3.2 above).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Example 3 . 3 .</head><label>33</label><figDesc>Let all notions be given as in Example 3.2, except that we define &lt;Y = (Sk x S) U cN. Figure 1 b is a diagram of this sort of hierarchy. We can prove that (&amp;) is a complete and minimal set of Z-unifiers of D if k E IV. But D has no complete and minimal set of Z-unifiers for k = 00; cf. Appendix B. Cl</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>LEMMA 4 . 1 .</head><label>41</label><figDesc>For each M E T/-B, A4 C T(D) or n[M] E [Ml.PROOF. For A4 C V(D) the lemma holds trivially, so let us assume q Q Y(D) for some q E M.If q E Z;: then q 4 DOM(a) U Y(COD(a)) for each mgu u of D, because DOM(a) U V(COD(u)) C z/(D). Hence uq = ur iff q = r for each r E Y; that is, M = (q) and obviously n[M] E [Ml. Now assume that q B Z For B E Y&amp;(D), B unifies M; that is, Bq = Or and, in particular, [Oq] = [er] for each r E M. With 0 E SUB, we obtain [er] 5 [r]; hence [Oq] 5 [r] and therefore [Oq] E lbs[M]. But [Oq] = [q] because q 4 '7; hence [41= Wfl E tM1. 0 Note that by this lemma, JY = (M E Y/-D ] n[M] B [Ml) is a finite set of finite subsets of Y'(D). This fact guarantees that the following definition, which renders precise our idea of how new variables have to be introduced, is meaningful. Definition 4.1. Let &amp; = (M E .Y/-D ] n[M] 4 [Ml). If J # 0, then by Lemma 4.1 J% = 1 V,, . . . , I/n) for some V,, . . . , I', C V(O) and we define for each i, with 1 5 i I n: (1) Zi C V\V(O) such that max(lbs[ Vi]) C [Zi] and Zi O &amp; = 0 for any h with 15h(nandh#i; (2) vari is a mapping from max(lbs[ Vi]) to Zi such that [var&amp;)] = s for all s E max(lbs[ Vi]);</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>( 4 )</head><label>4</label><figDesc>W(D) = {p E SUB ] /J = ~10 . . . 0 cc,, where pi E Wij where each element of W(D) is called a weakening substitution. Finally, the sortal degree AD of D is defined as (5) AD = ] max(lbs[ VI]) x . . -x max(lbs[ V,]) ] and D satisfies the maximal-sorts condition iff (6) Vs E lbs[ vi] s,,, E max(lbs[ vi]) s I s,,, holds true for each i. For J = 0 we define W(D) = (cl, AD = 1, and D satisfies the maximal-sorts condition. Cl Mgw-sets do exist for each Z-unifiable 2-termset D. They consist of Zsubstitutions, and their cardinality is given by the sortal degree AD of D. For instance, n = 1, VI = D, Z1 = {z,, ] h E Sk), and W, = W(D) = ({xc zh] I h E Sk) is an mgw-set of D as given in Example 3.2, where AD = k. As we have seen at the beginning of this section, n[ V] E [V] is a sufficient condition such that VC Y(D) has a Z-mgu. The introduction of auxiliary variables by a weakening substitution ~1 guarantees that this condition is satisfied for all equivalence classes of -fi LEMMA 4.2. Let p be a member of an mgw-set of D. Then n[N] E [N] for each NE Y//-,,D. PROOF. Since p replaces different variables in D by new different variables, pD is unifiable and for each N E Y/-d exactly one M E Y/-D exists such that N = N. Let all notions be given as in Definition 4.1: Assume that n[M] E [Ml, but [PM] # [Ml. Since [pq] = [q] for each q E .F\Y some x E M fl DOM(p) exists. Hence x E Vi for some vi E 9/-D satisfying n[Vi] 4 [Vi]. But x is a member of exactly one equivalence class of -D, and therefore M = Vi contradicting n[M] E [Ml. Hence [PM] = [Ml, and thus n[pM] E [pM]. Now let us assume n[M] 4 [Ml. Then with Definition 4.1 for some i and some Si E max(lbs[ vi]), M = K and [PM] C [Vi] U (St). But then Si E lbs([ Vi] U (Si]) C lb&amp;&amp;]. For s E lbs[gM] we obtain s 5 Si because si E [PM]; hence Si = n[pM] E [ww. So in either case n[pM] E [PM], and setting N = ti the lemma has been proved. 0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>THEOREM 4 . 3 .</head><label>43</label><figDesc>Let p be a member of an mgw-set of D. Then I.LD has a Z-mgu. PROOF. For each 19 E F&amp;(D) some T, X E SUB exists such that (1) risanmguofrD,and (2) X 0 T = t9[T(D) n V(/.tD)) 7, be a separation of 7, let ( yi) = COD(?i), and let Vi = DOM(?i) U ( yi) for each i with 1 I i C yt. Then Vi E Y/M~o, and by Lemma 4.2 each [Vi] has a least element; that is, [Xi] = n[ Vi] for some Xi E I'i. Leta,,..., u,-~, CT E SUB be defined by (3) ai=(YiCxiJO?i,foreachiwithlIi&lt;n,and (4) u = 61 0 **-oun-*.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>( 7 )</head><label>7</label><figDesc>[a?,,~] 5 [xl, and (8) UT,X E 55. To prove (7), suppose ?,,x E 7 for some x E K With COD (T,J n 7 = 0 we obtain TAX = x; that is, [u~"x] = [ux] I [x] by (6). If 7,x 4 7 for some x E K then XE V(D) n ?$D),and we obtain [UT~X] = [7,x] = [?x] = [X?x] = [Ox] 5 [x]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>From x E DOM(7,) we obtain x E V(D) rl Y(@); hence by (2) At = Bx and with 0 E SUBz, At E 7,. Therefore, hr E 72, and, in particular, [ Xrj] 5 [ f]j. NOW if rj 4 x then [urj] = [q] = [ Xrj] I [f]j, contradicting (9); hence (10) rjE?T Since r is a subterm of some member t of COD(r) and r is an mgu of @, a subterm 4 =f(41 * * * qk) of some term in PD exists such that (11) 4Ezi, and ?q = r. Hence 7qj = rj and therefore (12) [Urj] = [U?qj]e By ( 10) we obtain ?qj E F; hence qj E Y" and qj 4 DOM(7,) because COD(r,) n 7 = 0. If qj 4 Vi for each i, then arqj = aqj = qj and if qj E Vi for some i, then U?qj = U?iqj = Uyi = Xi. With [Xi] = n[ Vi] we have [UTqj] = [Xi] I [ qj]; hence in either case (13) [UT&amp;l = [&amp;I-;;rn (11) we infer [ qj] 5 [f]j; hence by (12) and (13) [urj] 5 [f]j, contradicting With (</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>THEOREM 5 . 1 .</head><label>51</label><figDesc>(z &lt;) is a forest-structured sort hierarchy iffeach Z-unifiable D C 55 has a Z-mgu. PRooF "+" Let 8 E '2&amp;(D) and let M E S/ -o. Then B unifies M; that is, Bq = r for some r E 9 and hence q E M. With 6' E SUBz we obtain [r] = [eq] % [q] for each q E M; hence lbs([M]) # 0. But then [M] is a chain in 9 because (x C) is a forest. Since M is unifiable, M is finite; hence [M] is finite, and since [M] is a chain in 3 [M] has a least element, that is, n[M] E [Ml. Hence W = (c) is the only mgw-set of D, and by Theorem 4.3 CD = D has a 2-mgu. "t" Let s(l), s(2), s E 9 such that (*) s(l) I s 5 s(2) and let xl E Q,, x2 E ctt2), and y E X. Then O = (xi c y, x2 t y) unifies D = {xl, x2) and with (*) B E SUB,. By the hypothesis D has a Z-mgu; that is, g1 = (xi c x2) or ~2 = (x2 c xl) is in SUB,. Hence s( 1) L s(2) or s( 1) zs s(2); that is, (3 C) is a forest structure. Cl6. Z-Unification with General Sort HierarchiesIn this section we prove the existence of complete and minimal sets of Z-unifiers for Z-unifiable Z-termsets that satisfy the maximal-sorts condition: We define socalled most general unifier sets and prove that each such set consists of Z-unifiers, is complete, and is also minimal. Definition 6.1. Let W be some mgw-set of D. Then U(W) is a most general unifier set or mgu-set of D (relative to W) iff U(W) is a minimal subset of SUB satisfying: VP E W 3a E SUB such that (1) COP E U(W) and (2) u is a 2-mgu of@D. 0 The existence of an mgu-set is guaranteed for each Z-unifiable Z-termset D by Theorem 4.3. It consists of Z-unifiers, and its cardinality is given by the sortal degree AD of D. For instance, (1 y c z,J 0 (x t zhJ 1 h E Sk) = (8, I h E Sk) is an mgu-set of D as given in Example 3.2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>LEMMA 6 . 1 .</head><label>61</label><figDesc>Let 6' E &amp;(D) and let W be an mgw-set of D. Zf D satisfies the maximal-sorts condition, then P I~ O[Y'(D)jj for some p E W. PROOF. Let all notions be given as in Definition 4.1. For A = 0, we obtain W = {c), and the lemma holds trivially. So let us assume A% # 0. With 8 E 2&amp;(D) we obtain, for any i, B E Z(Vi); hence [Ox] E lbs[l/i] for each x E Vi because B E SUBz. But then [Ox] 5 Si for some Si E max(lbs[ V,]) since D satisfies the maximal-sorts condition by the hypothesis. With Si E max(lbs[ Vi]) we obtain Si 5 [PiX] for each x E Vi and some pi E Wi with COD(pi) = (var&amp;i)). Hence (I) [OX] I [pix] for some pi E Wi and each x E V;:. Consequently, some P = pr 0 . . . 0 cc,, E W exists such that pi E II'i and each pi satisfies (1). Let /Li = (Xi t Zij, that is, P = (xl c ~1, . . . , x, c z,), where I&amp;,.*-, ~,ln%C(D)=0andsupposee,~(~)=(y,tB~,,...,y,cBy,).Wedefine X E SUB by h = (z, c 8x,, . . . , Z, t exn, yr t ey, , . . . , y, c ey,). From (1) we obtain [exi] I [Zi] and, with e E SUBz, obviously h E SUBz. NOW let x E V(O). If x E DOM(r), then x = Xi and XpXi = XZi = exi. For x 4 DOM(p) we obtain &amp;LX = Xx = Bx because x B COD(p). Hence, in either case X 0~ = f3([ct'(o)] and, with X E SUBz, ~1 Z$ e/&amp;Y(o)]. 0 THEOREM 6.2 (COMPLETENESS THEOREM). Let Ubean mgu-set ofD. Thenfir each B E Y&amp;(D) some p E U exists such that p 5x e([z;-(D)], provided D satisfies the maximal-sorts condition.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>LEMMA 6 . 3 .</head><label>63</label><figDesc>Let P be a member of an mgw-set of D and let u be a t;-mgu of PD. Then [uw] = [w] for each x E DOM(p). PROOF. Let all notions be given as in Definition 4.1. From x E DOM(p) we infer x E Vi for some i. Let us assume by way of contradiction that [uw] # [w]. Hence (1) [wd &lt; [WI because u E SUBz. Since u is an mgu of rD and p replaces different variables in D by different new variables, u is an mgu of pVi; that is, ul.~v = PVi for some vi E Vi and each v E I'i. But then U/AX = PVi for some vi E Vi. Using (I), we obtain [pvi] &lt; [w]; hence Vi # x and with Definition 4.1 (3) vi 4 DOM(r). But then pvi = vi, and thus (2) [Vi1 &lt; [CLXI-But by Definition 4.1 (2), (3) [w] I [v] for each v E Vi; that is, [@I % [Vi], and by (2) [w] &lt; [w]. Hence [UC] = [w] for each x E DOM(p) and the lemma has been proved. Cl THEOREM 6.4 (MINIMALITY THEOREM). Let U be an mgu-set of D and let pI, ~2 E U. Then PI = ~2, U-PI sz ,47(D)].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>1 (</head><label>1</label><figDesc>) in Definition 6.1; hence pI # p2. Let all notions be given as in Definition 4.1. From ~1 # ~2 we obtain pi-xi # PzXi for some Xi E DOM(pi) = DOM&amp;); hence by Definition 4.([PlXiI, [p2XiII C mWbs[Kl), and (5) [PZXI 5 [PIXI because [PzXi] = [a2p2Xi] by Lemma 6.3 using (2), [g2p2Xi] = [pzxi] by (l), [p2Xi] = [XplXi] by assumption, [XplXi] I [PlXi] since X E SUBz, [pixi] = [aiplxi] by (I), and finally [UipiXi] = [pixi] by Lemma 6.3 using (2).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>Definition 7.1. A sort hierarchy (Z &lt;) satisfies the maximal-sorts condition iff for each nonempty and finite S C 9 Vs E lbs(S) 3s, E max(lbs(S)) s5 sm. (z C) has degree 1 iff 1 max(lbs(S)) 1 s 1 and degree w iff 1 max(lbs(S)) 1 c 03 for each nonempty and finite S C 9 (3 C) has degree 00 iff (Z &lt;) does not have degree w. Cl THEOREM 7.1. A sort hierarchy (z &lt;) satisjies the maximal-sorts condition iff each Z-unifiable D c Sz has a complete and minimal set of Z-unifiers U(D) with 1 U(D) 1 = AD. PROOF "+" Obvious with Theorems 6.2 and 6.4, because D satisfies the maximalsorts condition if (Z C) does. &amp;&amp;t" We prove for any finite and nonempty subset S of 9: (1) Vs E lbs(S) 3s, E max(lbs(S)) s 5 s,. Let S = (s,, . . . , skJ and D = (xl, . . . , xk} C 7 with [Xi] = Si. For lbs(S) = 0 ( 1) holds trivially, so let us assume that Ibs(S) # 0. Then we can define 8, = (Xl + A, * . . , xk t x,), where x, E Z for each s E lbs(S). Obviously each B, E Y&amp;(D), and by the hypothesis U(D) exists. Let u= (u E U(D)1 u zzz e,([Y(D)] for some s E lbs(S)). Since 6, E F%(D) and U(D) is complete, we know that U # 0. Now for each u E U there is some y, E v such that aD = { yo) and [ ~~1 I Si for each i because u sz &amp;([Y(D)]. Let SU = ([ JJ~] E 9 ] u E U). With [ yo] = Si for each i we have [ y,] E lbs(S); that is (2) Su c Ibs(S). By the completeness of U(D), for each s E lbs(S) there is some u E U such that u sI: &amp;I[V(D)]; hence s 5 [ y,] E SU, that is, (3) Vs E lbs(S) 3s,,, E S, s I s,. Now suppose that, for some u E U, [ JJ~] is not maximal in lbs(S), that is, [ y-1 &lt; s' for some s' E Ibs(S). Then, by (3), s' 5 [ y,] for some p E U. Hence [yo] &lt; [v,], that is, p sz u([Y(D)j and, with the minimality of U(D), p = u, contradicting [ y,] &lt; [v,]. Hence with (2) Sv C max(lbs(S)) and with (3), (1) is proved. ClHaving proved the existence of complete and minimal sets of Z-unifiers, the cardinality of these sets can be characterized completely as a function of the structure of a particular sort hierarchy. THEOREM 7.2. Let (Z &lt;) be a sort hierarchy satisfying the maximal-sorts condition. Then ( 1) (3 C) has degree 1 iff 1 U(D) I = 1 for each 2-unifiable D C S,, (2) (x C) has degree w $1 U(D) I &lt; mfir each Z-unifiable D C S,, (3) (x C) has degree 00 iff I U(D) I = 00 fir some Z-unifiable D C SE, where U(D) denotes a complete and minimal subset of%(D). PROOF. Obvious consequence of Theorem 7.1. 0 Theorems 7.1 and 7.2 are the central results for the characterization of sort hierarchies with respect to the existence and the cardinality of complete and minimal sets of Z-unifiers. The following two lemmas deal with cases that are of interest in practical applications, namely, Zunilication for sort hierarchies with finite 9 and for those where (Z C) forms a meet-semilattice. COROLLARY 7.3. Let (Z &lt;) be a sort hierarchy with finite 9 Then each Zunifiable D c 9, possesses a finite, complete, and minimal set of Z-unifiers. PROOF. If 9 is finite, then each nonempty subset S* of 9 has a maximal element; that is, (S*, &gt;) satisfies the minimum condition (cf. [2]), and we can prove by Noetherian induction (*) Vs E S* 5, E max(S*) s 5 s,. With 9 finite, lbs(S) is finite for any S C 9 and by (*) (3 &lt;) satisfies the maximalsorts condition. By Theorem 7.1, each Z-unifiable subset of 55 has a complete and minimal set of Z-unifiers. This set is finite by Theorem 7.2(2) because (x &lt;) has degree o if 9 is finite. •I COROLLARY 7.4. Let (3 &lt;) be a meet-semilattice. Then each X-unifiable D C S, has a complete and minimal set of Z-unifiers that is a singleton. PROOF. If (3 &lt;) is a meet-semilattice, nS exists for each nonempty and finite S C 9; that is, max(lbs(S)) = (flS). Hence (z &lt;) satisfies the maximal-sorts condition and has degree 1, and by Theorems 7.1 and 7.2(l) this corollary has been proved. Cl</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>1 and 7.2 that, for each finite D C S, given as input, the Z-unification algorithm terminates with a failure indication if D is not Z-unifiable. Otherwise it terminates with a finite, complete, and minimal set U(D) of Z-unifiers of D, provided (8 &lt;) satisfies the maximal-sorts condition and also has degree o. If (z &lt;) is a forest structure, then U(D) = (a), where u is a Z-mgu of D, because in this case at least one of the conditions in statements (3.1)-(3.3) in Figure 3 is always satisfied. Consequently, statements (3.4)-(3.6) are never executed, and auxiliary variables are not generated. Hence, for the foreststructured case, a modification of the standard unification algorithm is easily obtained by replacing statement (3) in Figure 2 by statements (3.1)-(3.3) in Figure 3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>(</head><label></label><figDesc>FIG. 3. Z-unification of variables and terms.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS.</head><p>I am indebted to A. Herold, J.-P. Jouannaud, and J. Siekmann for their helpful comments and suggestions on an earlier draft of this paper.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>cardinality is proved under the proviso that there are finitely many sorts [ 181: Note that nonpolymorphism is an essential prerequisite in order for the results presented in the preceding sections to hold true. A further extension is obtained by combining many-sorted unification with unification under equational theories <ref type="bibr">[ 191.</ref> Unification is also one of the basic mechanisms in the Knuth-Bendix completion algorithm <ref type="bibr">[ 12, 141.</ref> In this approach conditional equations are difficult to treat, and therefore the use of sorts (and subsorts) can be advantageous because conditions can sometimes be expressed by sortal constraints.</p><p>A further advantage in this context is pointed out by Cunningham and Dick <ref type="bibr" target="#b2">[3]</ref>: Sorts can be used to deal economically with partial functions without leaving the scope of equational reasoning or introducing excessive formal clutter by error elements. A unification algorithm is presented, and it is shown that complete and minimal sets of Z-unifiers can have more than one member, if (Z ~9) is a lattice and polymorphic functions are admitted. An algorithm for Z-matching that returns at most one substitution is given.</p><p>Goguen et al. present rewrite-rule-based operational semantics for many-sorted algebra with subsorts and polymorphism, and they discuss pattern matching, as well as term rewriting, in this context <ref type="bibr" target="#b8">[9]</ref>.</p><p>Frisch gives a short survey of advantages that sortal inferences by Z-unification may yield in logic programming, in parsing with Horn-clause grammars and in knowledge retrieval <ref type="bibr">[7, 81.</ref> In all these cases of application only those sort hierarchies that avoid complete and minimal sets of Z-unifiers with infinite cardinality are of interest. </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Lattice Theory</title>
		<author>
			<persName><forename type="first">G</forename><surname>Birkhoff</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1967">1967</date>
			<publisher>American Mathematical Society Colloquium Publications</publisher>
			<biblScope unit="volume">25</biblScope>
			<pubPlace>Providence, RI</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Universal Algebra</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Cohn</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981">198 1</date>
			<pubPlace>Reidel, Dordrecht</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Rewrite systems on a lattice of types</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Cunningham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Dick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Actu Znf</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="149" to="169" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Translating Spanish into logic through logic</title>
		<author>
			<persName><forename type="first">V</forename><surname>Dahl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Am. J. Comput. Linguist</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="149" to="164" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Properties of substitutions and unifications</title>
		<author>
			<persName><forename type="first">E</forename><surname>Eder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symbolic Comput. I</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="31" to="46" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Complete sets of unifiers and matchers in equational theories</title>
		<author>
			<persName><forename type="first">F</forename><surname>Faces</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th Colloquium on Trees in Algebra and Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 8th Colloquium on Trees in Algebra and Programming<address><addrLine>L&apos;Aquila; Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1983">1983</date>
			<biblScope unit="volume">159</biblScope>
			<biblScope unit="page" from="205" to="220" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">An investigation into inference with restricted quantification and a taxonomic representation</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Frisch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SZGART Newsletter (ACM)</title>
		<imprint>
			<biblScope unit="volume">91</biblScope>
			<biblScope unit="page" from="28" to="31" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Parsing with restricted quantification</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Frisch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Society for the Study ofArtificial Intelligence and Simulation of Behavior Conference</title>
		<meeting>the Society for the Study ofArtificial Intelligence and Simulation of Behavior Conference</meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Operational semantics for order-sorted algebra</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Goguen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Jouannaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Colloquium on Automation Languages and Programming (Nafplion)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 12th International Colloquium on Automation Languages and Programming (Nafplion)<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1985">1985</date>
			<biblScope unit="volume">194</biblScope>
			<biblScope unit="page" from="221" to="231" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">An initial algebra approach to the specification, correctness and implementation of abstract data types</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Gixuen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Thatcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">G</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Current Trends in Progrumming Methodology</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">T</forename><surname>Yeh</surname></persName>
		</editor>
		<meeting><address><addrLine>Englewood Cliffs, N.J.</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1978">1978</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="80" to="321" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Some basic notions of first-order unification theory</title>
		<author>
			<persName><forename type="first">A</forename><surname>Herold</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983">1983</date>
		</imprint>
		<respStmt>
			<orgName>Universit?it Karlsruhe, Institut fti Informatik I</orgName>
		</respStmt>
	</monogr>
	<note>Intemer Bericht 15/83</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Equations and rewrite rules: A survey</title>
		<author>
			<persName><forename type="first">G</forename><surname>Huet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Oppen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Languages Theory: Perspectives and Open Problems</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Book</surname></persName>
		</editor>
		<meeting><address><addrLine>Menlo Park, Calif; Orlando, Fla</addrLine></address></meeting>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1980">1980. 1980</date>
			<biblScope unit="page" from="349" to="405" />
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep. CSGl 11, SRI International</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A many-sorted resolution based on an extension of a first-order language</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">B</forename><surname>Irani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Shin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th International Joint Conference on Artificial Intelligence</title>
		<meeting>the 9th International Joint Conference on Artificial Intelligence<address><addrLine>Los Angeles, Calif; Los Altos, Calif</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="1175" to="1177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Simple word problems in universal algebras</title>
		<author>
			<persName><forename type="first">D</forename><surname>Knuth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bendix</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computational Problems in Abstract Algebras</title>
		<meeting><address><addrLine>Pergamon, Oxford, England</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Partially ordered sets</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Macneille</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trans. Am. Math. Soc</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="416" to="460" />
			<date type="published" when="1937">1937</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Building-in equational theories</title>
		<author>
			<persName><forename type="first">G</forename><surname>Plotkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mach. Zntell</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="73" to="90" />
			<date type="published" when="1972">1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A machine-oriented logic based on the resolution principle</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Robinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="23" to="41" />
			<date type="published" when="1965-01">Jan. 1965</date>
		</imprint>
	</monogr>
	<note>also in [21</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A many-sorted calculus with polymorphic functions based on resolution and paramodulation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Schmidt-Schau~~</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th International Joint Conference on Artificial Zntelligence</title>
		<meeting>the 9th International Joint Conference on Artificial Zntelligence<address><addrLine>Los Angeles, Calif; Los Altos, Calif</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="1162" to="1168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Unification in many-sorted equational theories</title>
		<author>
			<persName><forename type="first">M</forename><surname>Schmidt-Schauss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Conference on Automated Deduction</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 8th International Conference on Automated Deduction<address><addrLine>Oxford, England; Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">230</biblScope>
			<biblScope unit="page" from="538" to="552" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Universal unification</title>
		<author>
			<persName><forename type="first">J</forename><surname>Siekmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th International Conference on Automated Deduction</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 7th International Conference on Automated Deduction<address><addrLine>Napa, Calif; Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1984">1984</date>
			<biblScope unit="volume">170</biblScope>
			<biblScope unit="page">42</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Automation of Reasoning-Classical Papers on Computational Logic</title>
		<author>
			<persName><forename type="first">J</forename><surname>Siekmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Wrightson</surname></persName>
		</author>
		<author>
			<persName><surname>Eds</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983">1983</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Automated deduction by theory resolution</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Stickel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th International Joint Conference on Arttjicial Intelligence</title>
		<meeting>the 9th International Joint Conference on Arttjicial Intelligence<address><addrLine>Los Angeles, Calif; Los Altos, Calif</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1985">1985. 1985</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="333" to="355" />
		</imprint>
	</monogr>
	<note>revised version in</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Schubert&apos;s steamroller problem: Formulations and solutions</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Stickel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Autom. Reasoning</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="89" to="101" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A many-sorted calculus based on resolution and paramodulation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Walther</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Joint Conference on Arttjicial Intelligence (Karlsruhe)</title>
		<meeting>the 8th International Joint Conference on Arttjicial Intelligence (Karlsruhe)<address><addrLine>Los Altos, Calif</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Unification in many-sorted theories</title>
		<author>
			<persName><forename type="first">C</forename><surname>Walther</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th European Conference on Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">O'</forename><surname>Shea</surname></persName>
		</editor>
		<meeting>the 6th European Conference on Artificial Intelligence<address><addrLine>Pisa, Italy; North-Holland, Amsterdam; Ed. North-Holland, Amsterdam</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985">1985. 1985</date>
			<biblScope unit="page" from="383" to="392" />
		</imprint>
	</monogr>
	<note>also in Advances in Artificial Zntelligence</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A mechanical solution of Schubert&apos;s steamroller by many-sorted resolution</title>
		<author>
			<persName><forename type="first">C</forename><surname>Walther</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Atizx IntelI</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="17" to="224" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">A classification of unification problems in many-sorted theories</title>
		<author>
			<persName><forename type="first">C</forename><surname>Walther</surname></persName>
		</author>
		<idno>Intemer Bericht 10/85</idno>
		<imprint>
			<date type="published" when="1985">1985</date>
		</imprint>
		<respStmt>
			<orgName>Universitat Karlsruhe, Instittit fir Informatik, I</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A many-sorted calculus based on resolution and paramodulation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Walther</surname></persName>
		</author>
		<author>
			<persName><forename type="first">London</forename><surname>Pitman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Morgan</forename><surname>Kaufmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Research Notes in Artificial IntelIigence</title>
		<meeting><address><addrLine>Los Altos, Calif</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Maximal models and refutation completeness: Semidecision procedures in automatic theorem proving</title>
		<author>
			<persName><forename type="first">L</forename><surname>Wos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Robinson</surname></persName>
		</author>
		<editor>Wordproblems, W. W. Boone, F. B. Cannonito, and R. C. Lyndon</editor>
		<imprint>
			<date type="published" when="1973">1973</date>
			<pubPlace>North-Holland, Amsterdam</pubPlace>
		</imprint>
	</monogr>
	<note>also in [2 I</note>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">January</forename><surname>Received</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986. 1987</date>
		</imprint>
	</monogr>
	<note>REVISED AUGUST 1987; ACCEPTED AUGUST</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
