<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Comlter Science</orgName>
								<orgName type="institution">Cornell University</orgName>
								<address>
									<settlement>Ithaca</settlement>
									<region>New York</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer, Information, and Control Sciences</orgName>
								<orgName type="institution">University of Minnesota</orgName>
								<address>
									<postCode>55455</postCode>
									<settlement>Minneapolis</settlement>
									<region>Minnesota</region>
								</address>
							</affiliation>
						</author>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">150999344E416AFC5F92B9942643455D</idno>
					<note type="submission">Received by the editors July 18, 1973, and in revised form April 6, 1974. The research reported here is part of the author&apos;s Ph.D. dissertation, Cornell University. An earlier version of these results was presented at the 1972 IEEE Annual Conference on Switching and Automata Theory. This research was supported in part by the National Science Foundation under Grant GJ-33169.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:22+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We look at several problems from areas such as network flows, game theory, artificial intelligence, graph theory, integer programming and nonlinear programming and show that they are related in that any one of these problems is solvable in polynomial time iff all the others are, tbo. At present, no polynomial time algorithm for these problems is known. These problems extend the equivalence class of problems known as P-Complete. The problem of deciding whether the class of languages accepted by polynomial time nondeterministic Turing machines is the same as that accepted by polynomial time deterministic Turing machines is related to P-Complete problems in that these two classes of languages are the same iff each P-Complete problem has a polynomial deterministic solution. In view of this, it appears very likely that this equivalence class defines a class of problems that cannot be solved in deterministic polynomial time.</p><p>Key words, complexity, polynomial reducibility, deterministic and nondeterministic algorithms, network flows, game theory, optimization, AND/OR graphs 1. Introduction. Cook [3 showed that determining whether the class of languages accepted by nondeterministic Turing machines operating in polynomial time was the same as that accepted by deterministic polynomial time bounded Turing machines was as hard as deciding if there was a deterministic polynomial algorithm for the satisfiability problem of propositional calculas (actually, Cook showed that there was a polynomial algorithm for satisfiability iff the determin- istic and nondeterministic polynomial time languages were the same). This problem about equivalence of the two classes of languages is a long-standing open problem from complexity theory. Intuitively, it seems that the two classes are not the same. Consequently there may be no polynomial algorithm for the satisfiability problem. Further empirical evidence that the two classes may not be the same was provided by Karp in [5, where he showed that many other problems like the traveling sales- man problem, finding the maximum clique of a graph, minimal colorings of graphs, minimal set covers, etc., had polynomial algorithms iff the two classes of languages were the same. In view of this relationship amongst all these problems, we can say that there is strong evidence to believe that there is no polynomial algorithm for any of the problems given in Karp [5. However, no formal proof of this (if this is true) is available at this time.</p><p>The equivalence class of problems having the property that each member of the class has a polynomial algorithm iff nondeterministic and deterministic polynomial languages are the same is known as P-Complete. In [5, Karp presents 21 members of this class. The purpose of this paper is to extend the class of known P-Complete problems. Specifically, we show that several important problems from</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>areas such as artificial intelligence, game theory, graph theory, network flows and integer optimization are P-Complete. We also introduce the concept of P-Hard.</p><p>The rest of this section will be devoted to definitions and establishing our notation. In 2 the new members of the classes P-Complete and P-Hard are presented. 1.1. Definitions. As our computational model we shall use Turing machines.</p><p>(See Hopcroft and Ullman I4 for a standard treatment of this model.) The reader unfamiliar with deterministic and nondeterministic polynomial time computa- tions should see Karp I5]. DEFINITION 1. P (NP) is the class of languages recognizable by deterministic (nondeterministic) polynomial time bounded one-tape Turing machines.</p><p>Open problem. "Is P NP?" We may rephrase this as, "Is there a determin- istic polynomial algorithm for all languages in NP?" Call this Problem P1. DEFINITION 2.1 A problem is a total function f: * 2r*, which takes each finite string to a nonempty subset of strings. (Informally, the finite string represents an encoding of the input or data and f maps this onto a solution set. Thus, for language recognition problems, f:Y* (0, 1), where f 0 iff the input string is not in the language.)</p><p>We consider algorithms which, given x6 Z*, produce some y6f(x). The computing time of the algorithm will be measured as a function of the length of x (Ixl). (All algorithms will be deterministic unless otherwise stated.) DEFINITION 3. A problem L will be said to be P-Reducible to a problem M (written L M) iff a polynomial algorithm for M implies a polynomial algorithm for L. That is, from a deterministic polynomial algorithm for M we can construct a deterministic polynomial algorithm for L. DEFINITION 4. A problem L is P-Hard iff a polynomial algorithm for L implies P NP. DEFINITION 5. Two problems L and M are P-Equivalent iff L a M and MeaL.</p><p>Clearly, P-Reducible is a transitive relation and P-Equivalent is an equiva- lence relation. DEFINITION 6. P-Complete (PC) is the equivalence class of P-Equivalent problems having a polynomial algorithm iff P NP.</p><p>Our definition of P-Complete differs from that used by Karp <ref type="bibr" target="#b5">[5]</ref>. However, it can easily be shown that any problem which is polynomial-Complete under his definition is P-Complete. The reverse, however, may not be true. (No proof of the equivalence or nonequivalence of the two definitions is known.) Note that all P-Complete problems are also P-Hard. In some cases, we may only be able to show the relation P-Hard rather than the stronger P-Complete relation. We shall often write L P1 when we mean "if P NP, then L is polynomial solvable" and P1 L when we mean "if L is polynomial solvable, then P NP". No ambiguity should arise from this double use of the symbol .</p><p>The author is grateful to an anonymous referee for suggesting this definition of a problem which encompasses both language recognition and optimization problems. Z is the tape alphabet of the Turing machine and Y* is the set of all finite length strings or words from the alphabet Z. Downloaded 12/20/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php There are several ways to show that a problem L is P-Complete. For instance, one could show L to be P-Equivalent to M, where M is a problem already known to be P-Complete, or show that L has a polynomial algorithm iff P NP, etc.</p><p>Most of the proofs in the next section will adopt the following approach: (i) show that "if P NP, then L" is polynomial solvable, i.e., L 0t (P NP), and (ii) show M 0t L, where M is a problem known to be P-Complete. M will usually be the satisfiability problem of propositional calculus (see Karp <ref type="bibr" target="#b5">[5]</ref> for a formal definition of this problem).</p><p>2. P-Complete and P-Hard problems. In this section we shall show that several frequently encountered problems in various areas such as network flows, game theory, graph theory, nonlinear and linear optimization are either P-Complete or at least P-Hard. The reductions are easily seen to be effective. The polynomial factors involved in the reduction are small (usually a constant or a polynomial of degree 1).</p><p>2.1. Some known P-Complete problems. To prove some of the reductions, we shall make use of some known members of PC. A brief description of these members is given below. (A more exhaustive list may be found in Karp <ref type="bibr" target="#b5">[5]</ref>.</p><formula xml:id="formula_0">) (i) Propositional calculus.</formula><p>(a) Satisfiability. Given a formula from the propositional calculus, in conjunctive normal form (CNF), is there an assignment of truth values for which it is "true"? (b) Satisfiability with exactly 3 literals per clause. This is the same as (a), except that each clause of the formula now has exactly 3 literals. (c) Tautology. Given a formula, from the propositional calculus, in dis- junctive normal form (DNF), does it have the value "true" for all pos- sible assignments of truth values.</p><p>(ii) Sum of subsets of integers. Given a multiset S (s l, ..., st) of positive integers and a positive integer M, does there exist a submultiset of S that sums to M? (This problem is called the Knapsack problem in <ref type="bibr" target="#b5">[5]</ref>. However, here we shall denote by "Knapsack problem" a similar integer optimization problem.) Note that a multiset is a collection of elements that may not necessarily be distinct.</p><p>(iii) Maximum independent set. Let G be a graph with vertices v 1, v2, ..., v,.</p><p>A set of vertices is independent if no two members of the set are adjacent in G. A maximum independent set is an independent set that has a maximum number of vertices.</p><p>(iv) Directed Hamiltonian cycle. Given a directed graph G, does it have a cycle that includes each vertex exactly once? THEOREM 2.1. The following problems are in PC (i) Satisfiability, satisfiability with exactly three literals per clause, tautology;</p><p>(ii) Sum of subsets of integers; (iii) Maximum independent set of a graph;</p><p>(iv) Directed Hamiltonian cycle.</p><p>Proof (i)is proved in Cook [3]. The rest are proved in Karp</p><p>Cook 3] actually shows that satisfiability with at most three literals per clause is P-Complete. From this result one may trivially show that satisfiability with exactly three literals per clause is P-Complete. We show how to convert a Downloaded 12/20/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php two-literal clause into an equivalent pair of three-literal clauses. Let (Xl + X 2) be the clause and y a variable not occurring in the formula. Then (xl + x2 + y) /x (xl + x2 + .) is satisfiable iff the two-literal clause is. All two-literal clauses may be replaced by pairs of three-literal clauses as above. This at most doubles the number of clauses. Clauses with only one literal can be deleted, the literal determin- ing the truth assignment to that variable. 2.2. Integer network flows. We define the following network problems.</p><p>Problem N(i). Network flows with multipliers. Let G be a directed graph with vertices 1, 2, U1, Vn and edges (arcs) el, e2, %. Let w-(v) be the set of arcs directed into vertex v and w +(v) those arcs directed away from v.</p><p>G will be said to denote a network with multipliers if:</p><p>(a) the source 31 of the network has no incoming arcs, i.e., w-(l) (b) the sink 2 has no outgoing arcs, i.e., w +(2) ;</p><p>(c) to every vertex v (excluding the source and sink) there corresponds an integer h &gt; 0, called its multiplier.</p><p>(d) to each edge ei there corresponds an interval [ai, bi] Conditions (a)-(d) are said to define a transportation network.</p><p>We are required to find a flow vector, with integer entries, (I)-(bl, b2, .., qS,,) such that the following conditions hold. Condition 1. a &lt;= dpi &lt; bi;</p><formula xml:id="formula_1">Condition 2. h(v) iw-v) dp iw+v) diDi for all v V(G), v =/: v =/= Condition 3. iw-s2) 49i is maximized.</formula><p>In what follows, we assume a O.</p><p>Problem N(ii). Multicommodity network flows. The transportation network is as above, but now h(v) for all v in V(G). We have, however, several different commodities c l, c2, ".', c,, and some arcs may be labeled, i.e., they can carry only certain commodities. Each arc is assigned a capacity, and we wish to know whether a flow R (rl, r2, rn), where r is the quantity of the ith commodity, is feasible in the network.</p><p>Problem N(iii). Integer flows with homologous arcs. The transportation network remains the same. Also, h(v)= and there is only one commodity.</p><p>Certain arcs are paired, and we require that if arcs i, j are paired, then</p><p>We wish to know if a flow of at least F is feasible in the network.</p><p>Problem N(iv). Integer flows with bundles. The arcs in the network are divided into sets I1, ..., I (the sets may overlap). Each set is called a bundle, and with each bundle is associated a capacity C i. We wish to know if a flow _&gt;_ F is feasible in the network"</p><formula xml:id="formula_2">Z )i C j, &lt;= j &lt;= k i6lj and h(v) V v e V(G). THEOREM 2.2. Problems N(i)-N(iv) are in PC.</formula><p>Proof (a) N(i), N(ii), N(iii), N(iv) P 1. The nondeterministic turing machine (NDTM) just guesses the flows in each arc and then verifies Conditions and 2.</p><p>In addition, it does the following:</p><p>(i) for N(ii) it verifies that the resultant flow is &gt;= R;</p><p>(ii) for N(iii) the "homologous conditions" are checked and iw-{_,/bi &gt; F verified;</p><p>(iii) for N(iv) the bundle restrictions are checked and iw-2)qSi &gt; F verified.</p><p>If in N(i) we replace the max iw-2)4i requirement to"</p><p>(2.2.1) T"</p><p>,&gt;__F, iew-(</p><p>then from the above it .follows that T a P l. 2 To see N(i)a T, we note that if the length of the input on a Turing machine's tape is n, then the largest number it can represent is c", for some constant c which depends only on the Turing machine.</p><p>Hence the maximum capacity of an arc is bounded by c" and so max iw-{2) qSi _&lt; k", for some constant k. Now, assume there is a polynomial [p(n)] algorithm for T. Then, using the method of bisection, we can determine max i,w-2)qSi in at most log 2 k n= n log 2 k applications of T. This, therefore, gives a polynomial algorithm for N(i). Therefore N(i) a T a P1, and from the transitivity of a we conclude N(i)ot P1. Clearly, this proof technique can be used to show N(iii) and N(iv) to be complete when they are changed to maximization problems. (b) We now show the reduction for N(i)-N(iv), in the other direction.</p><p>(i) Sum of subsets of integers a N(i). We construct a network flow problem of type N(i) such that max iw-2)4i M iff there is a submultiset of S {sl, "", st} that sums to M. iff some submultiset of S sums to M.</p><p>(ii) Tautology N(ii). Suppose that the formula P in DNF has n variables al, a2, "-', a,. We shall construct a multicommodity network with n commodities Recall that P1 was defined in 1.2 to be the decision problem" is NP P? Downloaded 12/20/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php C1, C2, C such that the flow R(1, ..-, 1) is feasible iff P is not a tautology. The network of Fig. <ref type="figure" target="#fig_1">2</ref>.2.2 realizes this.</p><p>Discussion.</p><p>[A] This section of the" network ensures that there is a flow through only one of the nodes a or i. In terms of the formula A, a flow through a means a truth assignment of to ai while a flow through fii means an assignment of 0 to ai.</p><p>[B] For each clause (Ki) in P we have a section of the form a 2 a 3 If there arej literals in the clause, then arc (,/3) is assigned a capacity ofj 1. This requires that the truth assignments be such that clause k is false (as at least one term in it is false). Node/ is where the "multicommodity" property of the network is used. Here the flow through is correctly separated into its components, i.e., we are able to get back the truth values of the variables. The components for each flow are connected in series as in Fig. 2.2.2.   We now want to know if a flow R (1, 1, ..., 1) is feasible. It is easy to see that such a flow is possible iff there is a truth assignment to a l, "", a, for which each clause is false, i.e., iff P is not a tautology.</p><p>(iii) Tautology a N(iii). The construction is very similar to that for multi- commodity network flows. The network is as in Fig. <ref type="figure" target="#fig_1">2</ref>.2.3. Homologous arcs are marked with the same subscripted Greek letter.</p><p>The arcs (,/1) have a capacity that is one less than the number of terms in the clause, thereby ensuring that truth assignments that would make the preceding clause "true" cannot occur. The "homologous conditions" permit the separation of the flow at/ into the original "truth assignments".</p><p>The maximum capacity of the sink is n. Hence there is a flow &gt;= n iff there is a consistent assignment of truth values to al, "', a, such that no clause is "true", and hence P is not a tautology.</p><p>(iv) Maximum independent set a N(iv). 3 Let G(V, E) be an undirected graph for which we want to determine the maximum independent set.</p><p>The author is grateful to S. Even for pointing out an error in the original proof and for suggesting the correction. Let 1, /)1, "'", /)n, 2 be the nodes of the network n ]V[. From the source node, draw an arc of capacity to each of the nodes vi, &lt; &lt; n. From each node vi, draw an arc ai to the sink node g2. For each edge in G, define a bundle (ag, .az) if this edge joins vertices v and vj in G. These are the only bundles in the network.</p><p>Each bundle is assigned a capacity 1. This ensures that if vertex v is chosen in the maximum independent set (i.e., if there is a nonzero flow through it), then there is no flow through vertices adjacent to v (i.e., adjacent vertices are not chosen).</p><p>Now there is a flow &gt;__F iff there is an independent set of cardinality &gt;__F.</p><p>We solve the flow problem for F n, n 1, ..., 1, and the first F for which we get a feasible flow defines a maximum independent set. The largest k for which there is a feasible flow is k 2, through vertices V and V 2. Thus the maximum independent set of G is of size 2, and one such set is {V1, V2}. The bundles are: (a, a4), (a2, a3), (a2, a4) and (a3, a4).</p><p>It is interesting to note that all these problems are related to a similar, poly- nomial time, flow problem (see <ref type="bibr" target="#b0">[1]</ref>).</p><p>2.3. Graph theory. Problem G1. Minimal equivalent graph of a digraph. Given a directed graph G(V, E), we wish to remove as many edges from G as possible, getting a graph G1 such that" (2.3. la) InG, thereisapathfromvitovjiffthereisapathinG fromvitovj;</p><formula xml:id="formula_4">(2.3.1b) E(G1) _ _ _ E(G) (E(G)</formula><p>is the set of edges of G), i.e., we want the smallest subset of E(G) such that the transitive closure of G transitive closure of G. THEOREM 2.3.1. G1 is in PC.</p><formula xml:id="formula_5">Proof (a) G1 P1, Let n number of vertices in G IV(G)[ then [E(G)[ =&lt; n(n 1) &lt; n2.</formula><p>We can easily construct an NDTM, T, which given G and an integer k, determines if there is a subset of k edges satisfying (2.3.1a,b). T can be constructed so as to work in O(n3) time. If NP P, then there is a deterministic algorithm that does this in p(n) time. We find the smallest k =&lt; rt 2 for which such a subset exists. After determining k, the k edges can be determined as below.</p><p>Define a sequence E of maximum length IE(G)I. Set i if edge is among the k edges and ; 0 otherwise. Suppose it is already known that E (il, .., ij) is a correct 'partial" choice; then we ask if E(ij+ 1) is.</p><p>If yes, then set E (il, i2,"', i.i, 1).</p><p>If no, then set E (i, i2,''', ij, 0). Do this forj 0, 1, 2,..-, ]E] 1. (b) Directed Hamilton cycle 0 G1. Note. (i) If the directed graph G has a Hamilton cycle, then its transitive closure is the "complete directed graph" on V(G)[ points. The smallest graph with this transitive closure is the cycle on IV(G)[ points. Thus if there is a Hamilton cycle, then this cycle forms the minimal equivalent graph of G. (ii) Conversely, if the minimal equivalent graph is a cycle on IV(G)] points, then G has a Hamilton cycle. Therefore G has a Hamiltonian cycle iff the minimal equivalent graph of G is a Hamiltonian cycle. Problem G2. Optimal solution to AND/OR graphs. This is a problem frequently encountered in artificial intelligence;see [2, <ref type="bibr" target="#b9">[9]</ref> and <ref type="bibr" target="#b10">[10]</ref>. We are given a directed graph G(V, E). Each node of G represents a subproblem. In order to solve this subproblem, one might have to solve either all of its successors or only one of them. In the former case the node will be denoted an AND node, while in the latter case it is an OR node. The arcs are weighted, and the weights represent the cost asso- ciated with solving the parent node given that the successor (or son) node has been solved. There is one special node, S, which has no incoming arcs. This node repre- sents the total problem being solved. The problem then is to find a minimum solution to S.</p><p>As an example, consider the directed graph of Fig. <ref type="figure" target="#fig_1">2</ref>.3.1. The problem to be solved is P1. To do this, one may solve either nodes 12, 1 3 or P7, as P1 is an OR node. The cost incurred is then either 2, 2 or 8 (i.e., cost in addition to that of solving one of P2, P3 or Pv). To solve P2, both P4 and P5 have to be solved, as 19 2 is an AND node. The total cost to do this is 2. To solve P3, we may solve either P5 or P6-The minimum cost to do this is 1. P7 is free. In this example, then, the optimal AND node FIG. Proof (a) G2 a (P NP). The proof for this part is very similar to the part (a) of the proofs of each of Theorems 2.3.1 and 2.5.1 (see 2.5).</p><p>(b) Satisfiability a G2. We show how to transform a formula P in CNF into an AND/OR graph such that the AND/OR graph so obtained has a certain minimum cost solution iff P is satisfiable.</p><formula xml:id="formula_6">Let P= A C, C= V lj, i=1 j=l</formula><p>where the lj's are literals and the variables of P, V(P) are Xl, X2, ")n" The AND/OR graph will then have nodes as follows:</p><p>1. There is a special node, S, with no incoming arcs. This node represents the problem to be solved.</p><p>2. S is an AND node with descendent nodes P, x 1, x 2, -.., x,.</p><p>3. Each node xi represents the corresponding variable xi in the formula P.</p><p>Each x is an OR node with two descendents denoted Tx and Fx, respectively. If Tx is solved, then this will correspond to assigning a truth value of "true" to the variable x. Solving node Fxi will then correspond to assigning a truth value of "false" to x.</p><p>4. The node P represents the formula P, and is an AND node. It has k de- scendents C1, C2, "", Ck. Node C corresponds to the clause Ci in the formula P.</p><p>The nodes C are OR nodes. 5. Each node of type Tx or Fx has exactly one descendent node which is terminal (i.e., has no edges leaving it). These terminal nodes shall be denoted l)</p><formula xml:id="formula_7">1) 2 l) 2</formula><p>To complete the construction of the AND/OR, graph the following edges and costs are added:</p><p>1. From each node C an edge (C, Txj) is added if xj occurs in clause C. An edge (C, Fxj) is added if ffj occurs in the clause C. This is done for all variables xj appearing in the clause C. Ci is designated an OR node.</p><p>2. Edges from nodes of type Tx or Fx to their respective terminal nodes are assigned a weight or cost 1.</p><p>3. All other edges have a cost 0.</p><p>In order to solve S, each of the nodes P, x 1, x2,..-x, must be solved. Solving nodes x 1, x2,'", x, costs n. To solve P, we must solve all the nodes C, C 2, ..., Ck. The cost of a node C is at most 1. However, if one of its descendent nodes was solved while solving the nodes x, x 2, .--, x,, then the additional cost to solve C is 0, as the edges to its descendent nodes have cost 0 and one of its descendents has already been solved. That is, a node C can be solved at no cost if one of the literals occurring in the clause C has been assigned a value "true."</p><p>From this it follows that the entire graph (i.e., node S) can be solved at a cost n if there is some assignment of truth values to the x's such that at least one literal in each clause is true under that assignment, i.e, if the formula P is satisfiable. If P is not satisfiable, then the cost is &gt; n. Downloaded 12/20/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php</p><p>We have now shown how to construct an AND/OR graph from a formula P such that the AND/OR graph so constructed has a solution of cost n iff P is satisfiable. Otherwise the cost is &gt;n. Hence from the minimum solution to the AND/OR graph, one can determine if P is satisfiable. The construction clearly takes only polynomial time. This completes the proof.</p><p>Example 2.3.1. Consider P (x1 'it-x2 + x3)(l -2 -+-3)(1 + x2), V(P)--X1,X2,X3, rl 3. The nodes Tx 1, Tx 2, Tx 3 can be solved at a total cost of 3. The node P then costs nothing extra. The node S can then be solved by solving all its descendent nodes and the nodes Txl, TX 2 and Tx3. The total cost for this solution is 3 (which is n). Assigning the truth value "true" to the variables of P results in P being "true." An n-person noncooperative game in normal form consists of a set N of n players denoted l, 2,..., n, a finite set N 0, 1, n of r/i d-pure strategies for each player N, and a payoff function F from N N to Rn.</p><p>A strategy n-tuple (S*, ..., S,*) is said to be an equilibrium n-tuple iff for all i, N and S Ni,</p><p>(2.4.1) Fi(S, S'n) &gt;= Fi(S', S_ , Si, S 1,'", Sn), where F is the ith component of F. That is, there is no advantage for a player to unilaterally deviate from an equilibrium point.</p><p>Problem GT1. Given a game G (F, n, N), does it have an equilibrium point? THEOREM 2.4.1. GT1 e PC.</p><p>Proof (a)GT1 z P1. The nondeterministic Turing machine just guesses an equilibrium point and verifies that the equilibrium condition (2.4.1) is satisfied.</p><p>(b) Satisfiability (3 literals/clause)z GT1. Let P be the formula in CNF in n variables. Define an n-person game as below"</p><p>Each player has two strategies 0 and 1. Strategy 0 corresponds to assigning a truth value "false" to the corresponding variable and strategy to a "true" assign-</p><formula xml:id="formula_8">ment, Let P---C /k C 2 /k A, Ck, C Ci, v Ci2 v Ci3</formula><p>where the variables are x l, x2, "", x,. Replace each variable in the clause Ci by x if x C and by (1 xi) if 2i Ci</p><p>Replace "v" by "+", getting C.</p><p>Example. C i=x v x 2 v.3Ci=Xl +x2 +(1-x3)=x'l +x 2 +x 3.</p><p>In order that C has a (0, 1) value, replace x' + x + x by f/(x') X'l -4-x2(1 + x'x)+ x(1 X'l)(1 xz).</p><p>Clearly, f/(x') iff Ci(x is "true". Define h (x') 2 l-I f/(x') and F (x') i=1 hl(X )J</p><p>From the above definition of F(x'), it follows that max Fl(X')  Fl(x).</p><p>Then F(x) defines an n-person game in which each player has 2 strategies. For any choice of strategy vector x, we have either (i) or (ii) below.</p><p>(i) El(X --0, F(x)--2Fz(x __&lt; By changing the strategies for either x or x2, we can increase the payoff to x or x 2 respectively, as Fz(x defines a game with no equilibrium point. If such a change results in 2</p><p>El(X) i then everyone's payoff increases. In any case, such an x cannot be an equilibrium point.</p><p>(ii) L23 F(x) F (x) 2 and 2 is the maximum payoff any player can get. So no change from this point, unilateral or otherwise, would be advantageous to any player. Therefore the n-person game defined above has an equilibrium point iff P(x) is satisfiable.</p><p>As an example for G2(x 1, x2), consider: Strategy</p><formula xml:id="formula_9">Payoff (o, o) [o, (1, O) [1, O] (1, 1) [0, 1] (0, 1) [1, O gl(x) (2 x x2)(x --x2) g2(x) --(1 x x2) 2</formula><p>Clearly, no x is a stable (equilibrium) point Proof (a) K ot P1. Clearly, the problem is reducible to P if (i) is replaced by (i') y', xip &gt;__ Z. Now if the length of the input is n then each pi &lt; k" for some k. So using the method of bisection, we can find the optimal Z in log 2 k" n log 2 k query steps of (i') for some k, k =&lt; [Y[ (here [El number of letters in the alphabet for the NDTM above).</p><p>(b) Sum of subsets of integers 0t K1. Let S (sl,..., s,) be the multiset of integers. We want to find a subset (if one exists) that sums to M. This may be stated in the form of a K1 problem as below: maximize subject to , XiSi, E XiSi M, Xi 0,1. Proof (a) LB a (P NP). This part of the proof is similar to Theorem 2.5.1.</p><p>(b) The following known member of PC shall be used (Karp <ref type="bibr" target="#b5">[5]</ref>). Given a set of positive integers s l, s2, ..., sn, is there a partition I such that E Si Si/2" il We show how this problem may be formulated as a line balancing problem. Let s and T Si/2 i=1 then the jobs 1, 2, ..., n can be processed on 2 machines iff there is a partition I of the jobs such that E ti T si/2. iI This is the minimum number of machines on which the jobs can be processed as E7=1 ti 2T. Problem PI. Quadratic programming. Here, the constraints are linear while the optimization function is quadratic. THEOREM 2.5.4. PI is P-Hard.</p><p>Proof Sum of subsets of integers t PI.</p><p>maximize Z xi(xi 1) + Z xisi f (x), (i) subject to XiSi 5 M, For 0 &lt; X &lt; 1, Xi(X 1) &lt; 0. This, together with (i), implies f(x) &lt; M if for some i, 0 &lt; x &lt; 1. Thus max f(x) M iff S has a subset that sums to M.</p><p>The following variation of this problem may also be shown to be P-Hard: linear programming with one nonlinear constraint. Call this problem PI(b). To show that sum of subsets = PI(b), just consider the formulation: maximize xis, subject to xis &lt;= M, E Xi(Xi-1)&gt; 0, 2.6. Minimal equivalent Boolean form. Problem B1. Given a formula B from the propositional calculus, we wish to find the shortest formula equivalent to it. Downloaded 12/20/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php THEOREM 2.6.1. B1 e PC.</p><p>Proof (a) B1 a P1. Define Blk to be the problem" is there a Boolean form of length k equivalent to B? We first show that a polynomial algorithm for P1 implies a polynomial algorithm for Blk. For this, we construct a nondeterministic Turing machine that guesses the Boolean form of length k and then uses the "tautology algorithm" to check that it is equivalent to B. If P1 works in p(n) time, thenthe "tautology algorithm" works in p2(n) time (as tautology a P1), and so the Turing machine constructed above works in p2(n) time. Hence Blk a P1. The proof for B1 a Blk is similar to part (a) of the proof of Theorem 2.3.1. We note that this proof relies heavily on our informal notion of P-Reducibility. The proof does not show that B is polynomially related to the other problems in PC. If the time complexity of the tautology problem is fl(n) and that of P1 if f2(n), then this reduction gives a f2(fl(n)) algorithm for B 1. If fl (and consequently f2) is exponential, thenf2(fl(n)) is of the form 22". All our other reductions have been of the form p(n). f2(n) or f2(p(n)) for some polynomial p.' (b) tautology a B 1. A formula P is a tautology iff its minimal form is "1". 3. Conclusions. We have extended the class of known P-Complete problems to include some important applications from network flows, game theory, artificial intelligence and integer optimization. We have also introduced the notion of P-Hard. The results indicate that many of the problems for which no polynomial time bounded algorithm is known are related in terms of time com- plexity. Indeed, all the evidence to date suggests that there is no polynomial al- gorithm for any of these problems.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>FIG. 2.2.4. Example for maximum independent set otN(iv)   </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2.3.2 shows the AND/OR graph obtained by applying the transformation of Theorem 2.3.2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>x defines an n-person game with no equilibrium point. Set F(x) Fl(x + Fz(x 2 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Downloaded 12/20/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php Construct a network as below"</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>2.3.1. AND/OR graph Downloaded 12/20/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpway to solve P1 is first solve P6, then P3 and finally P1. The total cost for this solution is 3.</figDesc><table><row><cell>TrEORFM 2.3.2. G2 PC.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>AND nodes markedAll other nodes are OR FIG. 2.3.2. AND/OR graph./br Example 2.3.1 Downloaded 12/20/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php 2.4. n-person game theory. Following Lucas [7], we have:</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Downloaded 12/20/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php Let G2(x1, X2) be a 2-person game with 2 strategies per player and with no</figDesc><table><row><cell>2</cell></row><row><cell>2</cell></row><row><cell>if P(x) is satisfiable,</cell></row><row><cell>0</cell></row><row><cell>otherwise.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>Downloaded 12/20/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php Such a point is an equilibrium point, as now 2 2</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>Downloaded 12/20/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php THEOREM 2.5.3. LB e PC.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Downloaded 12/20/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>' Note,that here we are not saying that the best way to solve this problem takes 2 2n time on a deterministic machine. In fact one can easily solve it in time bounded by 2 c". We are just making the point that this particular reduction does not show that the two problems are polynomially related. Downloaded 12/20/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. I am grateful to Professor Ellis Horowitz for many stimulating discussions on this subject. This work was motivated by the work of Cook  [3] and Karp [53.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>From this we trivially conclude that the general 0-1 integer programming problem with nonnegative coefficients is complete. The 0-1 constraint may be replaced by the inequalities xi =&lt; 1, =&lt; &lt; n.</p><p>The remarks of the last paragraph naturally lead us to the question of the status of the general integer programming problem (i.e., with both negative and positive coefficients). Here again, we are interested in only nonnegative solutions. Problem I1. Determining if Cx b has a nonnegative solution is P-Hard.</p><p>(Note the entries of C are integer. If C has all entries of the same sign, then the problem is P-Complete.)</p><p>To see this, consider the following formulation of the sum of subsets problem" WiX M, i=1 wi+Yi=l, &lt;i&lt;n.</p><p>Problem 12. Determining if Cx &gt;= 0 has any integer solution (i.e., the xi's are not constrained to be nonnegative) is P-Hard.</p><p>Application of Knuths' algorithm 6, vol. 2, p. 303] for obtaining integer solutions to Cx b yields a set of inequalities of the form Dy &gt;= w. Setting w 0 restricts the x to be &gt;=0, Hence Dy 0 has an integer solution iff Cx b has a nonnegative integer solution. Knuths' algorithm takes only polynomial time, so this problem is P-Hard. If the sign restriction on x is removed, then Knuths' algorithm solves Cx b in polynomial time. (This result was obtained, together with H. B. Hunt III.)</p><p>Problem PF. Permutation functions. We are given a function F(i) which is defined over all permutations of the elements of the vector i= (1, 2,..-, n). We wish to determine that permutation which minimizes F over all permutations. F is assumed to be polynomially computable. TI-IEOREM 2.5.2. PF PC.</p><p>Proof (a) PF a (P NP). This part of the proof is very similar to that used in Theorem 2.5.1.</p><p>(b) Sum of subsets a PF. Define where xi is the ith element of i.</p><p>We compute min F over all permutations of for k 1, 2, ..., n. If there is a subset that sums to M, then it hasj elements in it, and min F is M. If, on the other hand, for some k l, min F is M, then I=1 w(xi) M. This defines an algorithm to solve the sum of subsets problem in polynomial time if we have a polynomial algorithm for PF.</p><p>Problem LB. Assembly line balancing. In this problem we are given n jobs 1, 2, ..., n. Each job requires a certain amount of processing time t. We have available machines, each having an available process time T. We want to determine the minimum number of machines needed to process all the jobs (the processing of a job cannot be split up among several machines). </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Programming, Games and Transportation Networks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Berge</surname></persName>
		</author>
		<author>
			<persName><surname>Ghouila-Howri</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1964">1964</date>
			<publisher>John Wiley</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">An admissable and optimal algorithm for searching AND/OR graphs</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Slagle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="117" to="128" />
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The complexity of theorem proving procedures</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference Record of Third ACM Symposium on Theory of Computing</title>
		<imprint>
			<date type="published" when="1971">1971</date>
			<biblScope unit="page" from="151" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName><surname>E4</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Formal Languages and their Relation to Automata</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Hopcoft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullmnn</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1969">1969</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Reducibility among combinatorial problems, Complexity of Computer Computations</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Kap</surname></persName>
		</author>
		<editor>R. E. Miller and J. W. Thatcher</editor>
		<imprint>
			<date type="published" when="1972">1972</date>
			<publisher>Plenum Press</publisher>
			<biblScope unit="page" from="85" to="104" />
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Art of Computer Programming</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Knuth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1969">1969</date>
			<publisher>Addison-Wesley</publisher>
			<biblScope unit="volume">2</biblScope>
			<pubPlace>Reading, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Some recent development in n-person game theory</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">F</forename><surname>Lucas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Rev</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="491" to="523" />
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An algorithm for finding a minimum equivalent graph of a digraph</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Moyles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">L</forename><surname>Thomson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Assoc. Comput. Mach</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="455" to="460" />
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Problem Soh, ing Methods in Artificial Intelligence</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">J</forename><surname>Nilsson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1971">1971</date>
			<publisher>McGraw-Hill</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">On the optimal solution of AND/OR series-parallel graphs</title>
		<author>
			<persName><forename type="first">R</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C T</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Assoc. Comput. Mach</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="354" to="372" />
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
