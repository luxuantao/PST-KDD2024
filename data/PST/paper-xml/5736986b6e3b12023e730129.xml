<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Shaoqing</forename><surname>Ren</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Kaiming</forename><surname>He</surname></persName>
							<email>kahe@microsoft.com</email>
						</author>
						<author>
							<persName><forename type="first">Ross</forename><surname>Girshick</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jian</forename><surname>Sun</surname></persName>
							<email>jiansun@microsoft.com</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Microsoft Research</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University of Science and Technology of China</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Microsoft Research</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T13:33+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>State-of-the-art object detection networks depend on region proposal algorithms to hypothesize object locations. Advances like SPPnet <ref type="bibr" target="#b6">[7]</ref> and Fast R-CNN <ref type="bibr" target="#b4">[5]</ref> have reduced the running time of these detection networks, exposing region proposal computation as a bottleneck. In this work, we introduce a Region Proposal Network (RPN) that shares full-image convolutional features with the detection network, thus enabling nearly cost-free region proposals. An RPN is a fully-convolutional network that simultaneously predicts object bounds and objectness scores at each position. RPNs are trained end-to-end to generate highquality region proposals, which are used by Fast R-CNN for detection. With a simple alternating optimization, RPN and Fast R-CNN can be trained to share convolutional features. For the very deep VGG-16 model [19], our detection system has a frame rate of 5fps (including all steps) on a GPU, while achieving state-of-the-art object detection accuracy on PASCAL VOC 2007 (73.2% mAP) and 2012 (70.4% mAP) using 300 proposals per image. Code is available at https://github.com/ShaoqingRen/faster_rcnn.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Recent advances in object detection are driven by the success of region proposal methods (e.g., <ref type="bibr" target="#b21">[22]</ref>) and region-based convolutional neural networks (R-CNNs) <ref type="bibr" target="#b5">[6]</ref>. Although region-based CNNs were computationally expensive as originally developed in <ref type="bibr" target="#b5">[6]</ref>, their cost has been drastically reduced thanks to sharing convolutions across proposals <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b4">5]</ref>. The latest incarnation, Fast R-CNN <ref type="bibr" target="#b4">[5]</ref>, achieves near real-time rates using very deep networks <ref type="bibr" target="#b18">[19]</ref>, when ignoring the time spent on region proposals. Now, proposals are the computational bottleneck in state-of-the-art detection systems.</p><p>Region proposal methods typically rely on inexpensive features and economical inference schemes. Selective Search (SS) <ref type="bibr" target="#b21">[22]</ref>, one of the most popular methods, greedily merges superpixels based on engineered low-level features. Yet when compared to efficient detection networks <ref type="bibr" target="#b4">[5]</ref>, Selective Search is an order of magnitude slower, at 2s per image in a CPU implementation. EdgeBoxes <ref type="bibr" target="#b23">[24]</ref> currently provides the best tradeoff between proposal quality and speed, at 0.2s per image. Nevertheless, the region proposal step still consumes as much running time as the detection network.</p><p>One may note that fast region-based CNNs take advantage of GPUs, while the region proposal methods used in research are implemented on the CPU, making such runtime comparisons inequitable. An obvious way to accelerate proposal computation is to re-implement it for the GPU. This may be an effective engineering solution, but re-implementation ignores the down-stream detection network and therefore misses important opportunities for sharing computation.</p><p>In this paper, we show that an algorithmic change-computing proposals with a deep net-leads to an elegant and effective solution, where proposal computation is nearly cost-free given the de-tection network's computation. To this end, we introduce novel Region Proposal Networks (RPNs) that share convolutional layers with state-of-the-art object detection networks <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b4">5]</ref>. By sharing convolutions at test-time, the marginal cost for computing proposals is small (e.g., 10ms per image).</p><p>Our observation is that the convolutional (conv) feature maps used by region-based detectors, like Fast R-CNN, can also be used for generating region proposals. On top of these conv features, we construct RPNs by adding two additional conv layers: one that encodes each conv map position into a short (e.g., 256-d) feature vector and a second that, at each conv map position, outputs an objectness score and regressed bounds for k region proposals relative to various scales and aspect ratios at that location (k = 9 is a typical value).</p><p>Our RPNs are thus a kind of fully-convolutional network (FCN) <ref type="bibr" target="#b13">[14]</ref> and they can be trained end-toend specifically for the task for generating detection proposals. To unify RPNs with Fast R-CNN <ref type="bibr" target="#b4">[5]</ref> object detection networks, we propose a simple training scheme that alternates between fine-tuning for the region proposal task and then fine-tuning for object detection, while keeping the proposals fixed. This scheme converges quickly and produces a unified network with conv features that are shared between both tasks.</p><p>We evaluate our method on the PASCAL VOC detection benchmarks <ref type="bibr" target="#b3">[4]</ref>, where RPNs with Fast R-CNNs produce detection accuracy better than the strong baseline of Selective Search with Fast R-CNNs. Meanwhile, our method waives nearly all computational burdens of SS at test-time-the effective running time for proposals is just 10 milliseconds. Using the expensive very deep models of <ref type="bibr" target="#b18">[19]</ref>, our detection method still has a frame rate of 5fps (including all steps) on a GPU, and thus is a practical object detection system in terms of both speed and accuracy (73.2% mAP on PASCAL VOC 2007 and 70.4% mAP on 2012). Code is available at https://github.com/ ShaoqingRen/faster_rcnn.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>Several recent papers have proposed ways of using deep networks for locating class-specific or classagnostic bounding boxes <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b19">20]</ref>. In the OverFeat method <ref type="bibr" target="#b17">[18]</ref>, a fully-connected (fc) layer is trained to predict the box coordinates for the localization task that assumes a single object. The fc layer is then turned into a conv layer for detecting multiple class-specific objects. The Multi-Box methods <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b19">20]</ref> generate region proposals from a network whose last fc layer simultaneously predicts multiple (e.g., 800) boxes, which are used for R-CNN <ref type="bibr" target="#b5">[6]</ref> object detection. Their proposal network is applied on a single image or multiple large image crops (e.g., 224×224) <ref type="bibr" target="#b19">[20]</ref>. We discuss OverFeat and MultiBox in more depth later in context with our method. Shared computation of convolutions <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b4">5]</ref> has been attracting increasing attention for efficient, yet accurate, visual recognition. The OverFeat paper <ref type="bibr" target="#b17">[18]</ref> computes conv features from an image pyramid for classification, localization, and detection. Adaptively-sized pooling (SPP) <ref type="bibr" target="#b6">[7]</ref> on shared conv feature maps is proposed for efficient region-based object detection <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b15">16]</ref> and semantic segmentation <ref type="bibr" target="#b1">[2]</ref>. Fast R-CNN <ref type="bibr" target="#b4">[5]</ref> enables end-to-end detector training on shared conv features and shows compelling accuracy and speed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Region Proposal Networks</head><p>A Region Proposal Network (RPN) takes an image (of any size) as input and outputs a set of rectangular object proposals, each with an objectness score. <ref type="foot" target="#foot_0">1</ref> We model this process with a fullyconvolutional network <ref type="bibr" target="#b13">[14]</ref>, which we describe in this section. Because our ultimate goal is to share computation with a Fast R-CNN object detection network <ref type="bibr" target="#b4">[5]</ref>, we assume that both nets share a common set of conv layers. In our experiments, we investigate the Zeiler and Fergus model <ref type="bibr" target="#b22">[23]</ref> (ZF), which has 5 shareable conv layers and the Simonyan and Zisserman model <ref type="bibr" target="#b18">[19]</ref> (VGG), which has 13 shareable conv layers.</p><p>To generate region proposals, we slide a small network over the conv feature map output by the last shared conv layer. This network is fully connected to an n × n spatial window of the input conv feature map. Each sliding window is mapped to a lower-dimensional vector (256-d for ZF and 512-d for VGG). This vector is fed into two sibling fully-connected layers-a box-regression layer (reg) and a box-classification layer (cls). We use n = 3 in this paper, noting that the effective receptive field on the input image is large (171 and 228 pixels for ZF and VGG, respectively). This mininetwork is illustrated at a single position in Fig. <ref type="figure" target="#fig_0">1</ref> (left). Note that because the mini-network operates in a sliding-window fashion, the fully-connected layers are shared across all spatial locations. This architecture is naturally implemented with an n × n conv layer followed by two sibling 1 × 1 conv layers (for reg and cls, respectively). ReLUs <ref type="bibr" target="#b14">[15]</ref> are applied to the output of the n × n conv layer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Translation-Invariant Anchors</head><p>At each sliding-window location, we simultaneously predict k region proposals, so the reg layer has 4k outputs encoding the coordinates of k boxes. The cls layer outputs 2k scores that estimate probability of object / not-object for each proposal. <ref type="foot" target="#foot_2">2</ref> The k proposals are parameterized relative to k reference boxes, called anchors. Each anchor is centered at the sliding window in question, and is associated with a scale and aspect ratio. We use 3 scales and 3 aspect ratios, yielding k = 9 anchors at each sliding position. For a conv feature map of a size W ×H (typically ∼2,400), there are W Hk anchors in total. An important property of our approach is that it is translation invariant, both in terms of the anchors and the functions that compute proposals relative to the anchors.</p><p>As a comparison, the MultiBox method <ref type="bibr" target="#b19">[20]</ref> uses k-means to generate 800 anchors, which are not translation invariant. If one translates an object in an image, the proposal should translate and the same function should be able to predict the proposal in either location. Moreover, because the MultiBox anchors are not translation invariant, it requires a (4+1)×800-dimensional output layer, whereas our method requires a (4+2)×9-dimensional output layer. Our proposal layers have an order of magnitude fewer parameters (27 million for MultiBox using GoogLeNet <ref type="bibr" target="#b19">[20]</ref> vs. 2.4 million for RPN using VGG-16), and thus have less risk of overfitting on small datasets, like PASCAL VOC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Loss Function for Learning Region Proposals</head><p>For training RPNs, we assign a binary class label (of being an object or not) to each anchor. We assign a positive label to two kinds of anchors: (i) the anchor/anchors with the highest Intersectionover-Union (IoU) overlap with a ground-truth box, or (ii) an anchor that has an IoU overlap higher than 0.7 with any ground-truth box. Note that a single ground-truth box may assign positive labels to multiple anchors. We assign a negative label to a non-positive anchor if its IoU ratio is lower than 0.3 for all ground-truth boxes. Anchors that are neither positive nor negative do not contribute to the training objective.</p><p>With these definitions, we minimize an objective function following the multi-task loss in Fast R-CNN <ref type="bibr" target="#b4">[5]</ref>. Our loss function for an image is defined as:</p><formula xml:id="formula_0">L({p i }, {t i }) = 1 N cls i L cls (p i , p * i ) + λ 1 N reg i p * i L reg (t i , t * i ).<label>(1)</label></formula><p>Here, i is the index of an anchor in a mini-batch and p i is the predicted probability of anchor i being an object. The ground-truth label p * i is 1 if the anchor is positive, and is 0 if the anchor is negative. t i is a vector representing the 4 parameterized coordinates of the predicted bounding box, and t * i is that of the ground-truth box associated with a positive anchor. The classification loss L cls is log loss over two classes (object vs. not object). For the regression loss, we use</p><formula xml:id="formula_1">L reg (t i , t * i ) = R(t i − t * i )</formula><p>where R is the robust loss function (smooth L 1 ) defined in <ref type="bibr" target="#b4">[5]</ref>. The term p * i L reg means the regression loss is activated only for positive anchors (p * i = 1) and is disabled otherwise (p * i = 0). The outputs of the cls and reg layers consist of {p i } and {t i } respectively. The two terms are normalized with N cls and N reg , and a balancing weight λ. <ref type="foot" target="#foot_3">3</ref>For regression, we adopt the parameterizations of the 4 coordinates following <ref type="bibr" target="#b5">[6]</ref>:</p><formula xml:id="formula_2">t x = (x − x a )/w a , t y = (y − y a )/h a , t w = log(w/w a ), t h = log(h/h a ), t * x = (x * − x a )/w a , t * y = (y * − y a )/h a , t * w = log(w * /w a ), t * h = log(h * /h a )</formula><p>, where x, y, w, and h denote the two coordinates of the box center, width, and height. Variables x, x a , and x * are for the predicted box, anchor box, and ground-truth box respectively (likewise for y, w, h). This can be thought of as bounding-box regression from an anchor box to a nearby ground-truth box.</p><p>Nevertheless, our method achieves bounding-box regression by a different manner from previous feature-map-based methods <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b4">5]</ref>. In <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b4">5]</ref>, bounding-box regression is performed on features pooled from arbitrarily sized regions, and the regression weights are shared by all region sizes. In our formulation, the features used for regression are of the same spatial size (n × n) on the feature maps. To account for varying sizes, a set of k bounding-box regressors are learned. Each regressor is responsible for one scale and one aspect ratio, and the k regressors do not share weights. As such, it is still possible to predict boxes of various sizes even though the features are of a fixed size/scale.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Optimization</head><p>The RPN, which is naturally implemented as a fully-convolutional network <ref type="bibr" target="#b13">[14]</ref>, can be trained end-to-end by back-propagation and stochastic gradient descent (SGD) <ref type="bibr" target="#b11">[12]</ref>. We follow the "imagecentric" sampling strategy from <ref type="bibr" target="#b4">[5]</ref> to train this network. Each mini-batch arises from a single image that contains many positive and negative anchors. It is possible to optimize for the loss functions of all anchors, but this will bias towards negative samples as they are dominate. Instead, we randomly sample 256 anchors in an image to compute the loss function of a mini-batch, where the sampled positive and negative anchors have a ratio of up to 1:1. If there are fewer than 128 positive samples in an image, we pad the mini-batch with negative ones.</p><p>We randomly initialize all new layers by drawing weights from a zero-mean Gaussian distribution with standard deviation 0.01. All other layers (i.e., the shared conv layers) are initialized by pretraining a model for ImageNet classification <ref type="bibr" target="#b16">[17]</ref>, as is standard practice <ref type="bibr" target="#b5">[6]</ref>. We tune all layers of the ZF net, and conv3 1 and up for the VGG net to conserve memory <ref type="bibr" target="#b4">[5]</ref>. We use a learning rate of 0.001 for 60k mini-batches, and 0.0001 for the next 20k mini-batches on the PASCAL dataset. We also use a momentum of 0.9 and a weight decay of 0.0005 <ref type="bibr" target="#b10">[11]</ref>. Our implementation uses Caffe <ref type="bibr" target="#b9">[10]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Sharing Convolutional Features for Region Proposal and Object Detection</head><p>Thus far we have described how to train a network for region proposal generation, without considering the region-based object detection CNN that will utilize these proposals. For the detection network, we adopt Fast R-CNN <ref type="bibr" target="#b4">[5]</ref> 4 and now describe an algorithm that learns conv layers that are shared between the RPN and Fast R-CNN.</p><p>Both RPN and Fast R-CNN, trained independently, will modify their conv layers in different ways. We therefore need to develop a technique that allows for sharing conv layers between the two networks, rather than learning two separate networks. Note that this is not as easy as simply defining a single network that includes both RPN and Fast R-CNN, and then optimizing it jointly with backpropagation. The reason is that Fast R-CNN training depends on fixed object proposals and it is not clear a priori if learning Fast R-CNN while simultaneously changing the proposal mechanism will converge. While this joint optimizing is an interesting question for future work, we develop a pragmatic 4-step training algorithm to learn shared features via alternating optimization.</p><p>In the first step, we train the RPN as described above. This network is initialized with an ImageNetpre-trained model and fine-tuned end-to-end for the region proposal task. In the second step, we train a separate detection network by Fast R-CNN using the proposals generated by the step-1 RPN. This detection network is also initialized by the ImageNet-pre-trained model. At this point the two networks do not share conv layers. In the third step, we use the detector network to initialize RPN training, but we fix the shared conv layers and only fine-tune the layers unique to RPN. Now the two networks share conv layers. Finally, keeping the shared conv layers fixed, we fine-tune the fc layers of the Fast R-CNN. As such, both networks share the same conv layers and form a unified network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Implementation Details</head><p>We train and test both region proposal and object detection networks on single-scale images <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b4">5]</ref>. We re-scale the images such that their shorter side is s = 600 pixels <ref type="bibr" target="#b4">[5]</ref>. Multi-scale feature extraction may improve accuracy but does not exhibit a good speed-accuracy trade-off <ref type="bibr" target="#b4">[5]</ref>. We also note that for ZF and VGG nets, the total stride on the last conv layer is 16 pixels on the re-scaled image, and thus is ∼10 pixels on a typical PASCAL image (∼500×375). Even such a large stride provides good results, though accuracy may be further improved with a smaller stride.</p><p>For anchors, we use 3 scales with box areas of 128 2 , 256 2 , and 512 2 pixels, and 3 aspect ratios of 1:1, 1:2, and 2:1. We note that our algorithm allows the use of anchor boxes that are larger than the underlying receptive field when predicting large proposals. Such predictions are not impossibleone may still roughly infer the extent of an object if only the middle of the object is visible. With this design, our solution does not need multi-scale features or multi-scale sliding windows to predict large regions, saving considerable running time. Fig. <ref type="figure" target="#fig_0">1</ref> (right) shows the capability of our method for a wide range of scales and aspect ratios. The table below shows the learned average proposal size for each anchor using the ZF net (numbers for s = 600).</p><p>anchor 128 2 , 2:1 128 2 , 1:1 128 2 , 1:2 256 2 , 2:1 256 2 , 1:1 256 2 , 1:2 512 2 , 2:1 512 2 , 1:1 512 2 , 1:2 proposal 188×111 113×114 70×92 416×229 261×284 174×332 768×437 499×501 355×715</p><p>The anchor boxes that cross image boundaries need to be handled with care. During training, we ignore all cross-boundary anchors so they do not contribute to the loss. For a typical 1000 × 600 image, there will be roughly 20k (≈ 60 × 40 × 9) anchors in total. With the cross-boundary anchors ignored, there are about 6k anchors per image for training. If the boundary-crossing outliers are not ignored in training, they introduce large, difficult to correct error terms in the objective, and training does not converge. During testing, however, we still apply the fully-convolutional RPN to the entire image. This may generate cross-boundary proposal boxes, which we clip to the image boundary. Some RPN proposals highly overlap with each other. To reduce redundancy, we adopt nonmaximum suppression (NMS) on the proposal regions based on their cls scores. We fix the IoU threshold for NMS at 0.7, which leaves us about 2k proposal regions per image. As we will show, NMS does not harm the ultimate detection accuracy, but substantially reduces the number of proposals. After NMS, we use the top-N ranked proposal regions for detection. In the following, we train Fast R-CNN using 2k RPN proposals, but evaluate different numbers of proposals at test-time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Experiments</head><p>We comprehensively evaluate our method on the PASCAL VOC 2007 detection benchmark <ref type="bibr" target="#b3">[4]</ref>. This dataset consists of about 5k trainval images and 5k test images over 20 object categories. We also provide results in the PASCAL VOC 2012 benchmark for a few models. For the ImageNet pre-trained network, we use the "fast" version of ZF net <ref type="bibr" target="#b22">[23]</ref> that has 5 conv layers and 3 fc layers, and the public VGG-16 model<ref type="foot" target="#foot_5">5</ref>  <ref type="bibr" target="#b18">[19]</ref> that has 13 conv layers and 3 fc layers. We primarily evaluate detection mean Average Precision (mAP), because this is the actual metric for object detection (rather than focusing on object proposal proxy metrics).</p><p>Table <ref type="bibr">1 (top)</ref> shows Fast R-CNN results when trained and tested using various region proposal methods. These results use the ZF net. For Selective Search (SS) <ref type="bibr" target="#b21">[22]</ref>, we generate about 2k SS proposals by the "fast" mode. For EdgeBoxes (EB) <ref type="bibr" target="#b23">[24]</ref>, we generate the proposals by the default EB setting tuned for 0.7 IoU. SS has an mAP of 58.7% and EB has an mAP of 58.6%. RPN with Fast R-CNN achieves competitive results, with an mAP of 59.9% while using up to 300 proposals <ref type="foot" target="#foot_6">6</ref> .</p><p>Using RPN yields a much faster detection system than using either SS or EB because of shared conv computations; the fewer proposals also reduce the region-wise fc cost. Next, we consider several ablations of RPN and then show that proposal quality improves when using the very deep network.</p><p>Ablation Experiments. To investigate the behavior of RPNs as a proposal method, we conducted several ablation studies. First, we show the effect of sharing conv layers between the RPN and Fast R-CNN detection network. To do this, we stop after the second step in the 4-step training process. Using separate networks reduces the result slightly to 58.7% (RPN+ZF, unshared, Table <ref type="table" target="#tab_0">1</ref>). We observe that this is because in the third step when the detector-tuned features are used to fine-tune the RPN, the proposal quality is improved.</p><p>Next, we disentangle the RPN's influence on training the Fast R-CNN detection network. For this purpose, we train a Fast R-CNN model by using the 2k SS proposals and ZF net. We fix this detector and evaluate the detection mAP by changing the proposal regions used at test-time. In these ablation experiments, the RPN does not share features with the detector.</p><p>Replacing SS with 300 RPN proposals at test-time leads to an mAP of 56.8%. The loss in mAP is because of the inconsistency between the training/testing proposals. This result serves as the baseline for the following comparisons.</p><p>Somewhat surprisingly, the RPN still leads to a competitive result (55.1%) when using the topranked 100 proposals at test-time, indicating that the top-ranked RPN proposals are accurate. On the other extreme, using the top-ranked 6k RPN proposals (without NMS) has a comparable mAP (55.2%), suggesting NMS does not harm the detection mAP and may reduce false alarms.</p><p>Next, we separately investigate the roles of RPN's cls and reg outputs by turning off either of them at test-time. When the cls layer is removed at test-time (thus no NMS/ranking is used), we randomly sample N proposals from the unscored regions. The mAP is nearly unchanged with N = 1k (55.8%), but degrades considerably to 44.6% when N = 100. This shows that the cls scores account for the accuracy of the highest ranked proposals.</p><p>On the other hand, when the reg layer is removed at test-time (so the proposals become anchor boxes), the mAP drops to 52.1%. This suggests that the high-quality proposals are mainly due to regressed positions. The anchor boxes alone are not sufficient for accurate detection.  We also evaluate the effects of more powerful networks on the proposal quality of RPN alone. We use VGG-16 to train the RPN, and still use the above detector of SS+ZF. The mAP improves from 56.8% (using RPN+ZF) to 59.2% (using RPN+VGG). This is a promising result, because it suggests that the proposal quality of RPN+VGG is better than that of RPN+ZF. Because proposals of RPN+ZF are competitive with SS (both are 58.7% when consistently used for training and testing), we may expect RPN+VGG to be better than SS. The following experiments justify this hypothesis.</p><p>Detection Accuracy and Running Time of VGG-16. Table <ref type="table" target="#tab_1">2</ref> shows the results of VGG-16 for both proposal and detection. Using RPN+VGG, the Fast R-CNN result is 68.5% for unshared features, slightly higher than the SS baseline. As shown above, this is because the proposals generated by RPN+VGG are more accurate than SS. Unlike SS that is pre-defined, the RPN is actively trained and benefits from better networks. For the feature-shared variant, the result is 69.9%-better than the strong SS baseline, yet with nearly cost-free proposals. We further train the RPN and detection network on the union set of PASCAL VOC 2007 trainval and 2012 trainval, following <ref type="bibr" target="#b4">[5]</ref>. The mAP is 73.2%. On the PASCAL VOC 2012 test set (Table <ref type="table" target="#tab_2">3</ref>), our method has an mAP of 70.4% trained on the union set of VOC 2007 trainval+test and VOC 2012 trainval, following <ref type="bibr" target="#b4">[5]</ref>.</p><p>In Table <ref type="table" target="#tab_3">4</ref> we summarize the running time of the entire object detection system. SS takes 1-2 seconds depending on content (on average 1.51s), and Fast R-CNN with VGG-16 takes 320ms on 2k SS proposals (or 223ms if using SVD on fc layers <ref type="bibr" target="#b4">[5]</ref>). Our system with VGG-16 takes in total 198ms for both proposal and detection. With the conv features shared, the RPN alone only takes 10ms computing the additional layers. Our region-wise computation is also low, thanks to fewer proposals (300). Our system has a frame-rate of 17 fps with the ZF net.   In Fig. <ref type="figure" target="#fig_1">2</ref>, we show the results of using 300, 1k, and 2k proposals. We compare with SS and EB, and the N proposals are the top-N ranked ones based on the confidence generated by these methods. The plots show that the RPN method behaves gracefully when the number of proposals drops from 2k to 300. This explains why the RPN has a good ultimate detection mAP when using as few as 300 proposals. As we analyzed before, this property is mainly attributed to the cls term of the RPN. The recall of SS and EB drops more quickly than RPN when the proposals are fewer.</p><p>One-Stage Detection vs. Two-Stage Proposal + Detection. The OverFeat paper <ref type="bibr" target="#b17">[18]</ref> proposes a detection method that uses regressors and classifiers on sliding windows over conv feature maps.</p><p>OverFeat is a one-stage, class-specific detection pipeline, and ours is a two-stage cascade consisting of class-agnostic proposals and class-specific detections. In OverFeat, the region-wise features come from a sliding window of one aspect ratio over a scale pyramid. These features are used to simultaneously determine the location and category of objects. In RPN, the features are from square (3×3) sliding windows and predict proposals relative to anchors with different scales and aspect ratios. Though both methods use sliding windows, the region proposal task is only the first stage of RPN + Fast R-CNN-the detector attends to the proposals to refine them. In the second stage of our cascade, the region-wise features are adaptively pooled <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b4">5]</ref> from proposal boxes that more faithfully cover the features of the regions. We believe these features lead to more accurate detections.</p><p>To compare the one-stage and two-stage systems, we emulate the OverFeat system (and thus also circumvent other differences of implementation details) by one-stage Fast R-CNN. In this system, the "proposals" are dense sliding windows of 3 scales (128, 256, 512) and 3 aspect ratios (1:1, 1:2, 2:1). Fast R-CNN is trained to predict class-specific scores and regress box locations from these sliding windows. Because the OverFeat system uses an image pyramid, we also evaluate using conv features extracted from 5 scales. We use those 5 scales as in <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b4">5]</ref>.</p><p>Table <ref type="table" target="#tab_5">5</ref> compares the two-stage system and two variants of the one-stage system. Using the ZF model, the one-stage system has an mAP of 53.9%. This is lower than the two-stage system (58.7%) by 4.8%. This experiment justifies the effectiveness of cascaded region proposals and object detection. Similar observations are reported in <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b12">13]</ref>, where replacing SS region proposals with sliding windows leads to ∼6% degradation in both papers. We also note that the one-stage system is slower as it has considerably more proposals to process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>We have presented Region Proposal Networks (RPNs) for efficient and accurate region proposal generation. By sharing convolutional features with the down-stream detection network, the region proposal step is nearly cost-free. Our method enables a unified, deep-learning-based object detection system to run at 5-17 fps. The learned RPN also improves region proposal quality and thus the overall object detection accuracy.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Left: Region Proposal Network (RPN). Right: Example detections using RPN proposals on PASCAL VOC 2007 test. Our method detects objects in a wide range of scales and aspect ratios.</figDesc><graphic url="image-2.png" coords="3,336.72,139.33,71.72,53.82" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Recall vs. IoU overlap ratio on the PASCAL VOC 2007 test set.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Detection results on PASCAL VOC 2007 test set (trained on VOC 2007 trainval). The detectors are Fast R-CNN with ZF, but using various proposal methods for training and testing.</figDesc><table><row><cell cols="2">train-time region proposals</cell><cell cols="2">test-time region proposals</cell><cell></cell></row><row><cell>method</cell><cell># boxes</cell><cell>method</cell><cell># proposals</cell><cell>mAP (%)</cell></row><row><cell>SS</cell><cell>2k</cell><cell>SS</cell><cell>2k</cell><cell>58.7</cell></row><row><cell>EB</cell><cell>2k</cell><cell>EB</cell><cell>2k</cell><cell>58.6</cell></row><row><cell>RPN+ZF, shared</cell><cell>2k</cell><cell>RPN+ZF, shared</cell><cell>300</cell><cell>59.9</cell></row><row><cell cols="2">ablation experiments follow below</cell><cell></cell><cell></cell><cell></cell></row><row><cell>RPN+ZF, unshared</cell><cell>2k</cell><cell>RPN+ZF, unshared</cell><cell>300</cell><cell>58.7</cell></row><row><cell>SS</cell><cell>2k</cell><cell>RPN+ZF</cell><cell>100</cell><cell>55.1</cell></row><row><cell>SS</cell><cell>2k</cell><cell>RPN+ZF</cell><cell>300</cell><cell>56.8</cell></row><row><cell>SS</cell><cell>2k</cell><cell>RPN+ZF</cell><cell>1k</cell><cell>56.3</cell></row><row><cell>SS</cell><cell>2k</cell><cell>RPN+ZF (no NMS)</cell><cell>6k</cell><cell>55.2</cell></row><row><cell>SS</cell><cell>2k</cell><cell>RPN+ZF (no cls)</cell><cell>100</cell><cell>44.6</cell></row><row><cell>SS</cell><cell>2k</cell><cell>RPN+ZF (no cls)</cell><cell>300</cell><cell>51.4</cell></row><row><cell>SS</cell><cell>2k</cell><cell>RPN+ZF (no cls)</cell><cell>1k</cell><cell>55.8</cell></row><row><cell>SS</cell><cell>2k</cell><cell>RPN+ZF (no reg)</cell><cell>300</cell><cell>52.1</cell></row><row><cell>SS</cell><cell>2k</cell><cell>RPN+ZF (no reg)</cell><cell>1k</cell><cell>51.3</cell></row><row><cell>SS</cell><cell>2k</cell><cell>RPN+VGG</cell><cell>300</cell><cell>59.2</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Detection results on PASCAL VOC 2007 test set. The detector is Fast R-CNN and VGG-16. Training data: "07": VOC 2007 trainval, "07+12": union set of VOC 2007 trainval and VOC 2012 trainval. For RPN, the train-time proposals for Fast R-CNN are 2k. † : this was reported in<ref type="bibr" target="#b4">[5]</ref>; using the repository provided by this paper, this number is higher (68.0±0.3 in six runs).</figDesc><table><row><cell>method</cell><cell># proposals</cell><cell>data</cell><cell>mAP (%)</cell><cell>time (ms)</cell></row><row><cell>SS</cell><cell>2k</cell><cell>07</cell><cell>66.9  †</cell><cell>1830</cell></row><row><cell>SS</cell><cell>2k</cell><cell>07+12</cell><cell>70.0</cell><cell>1830</cell></row><row><cell>RPN+VGG, unshared</cell><cell>300</cell><cell>07</cell><cell>68.5</cell><cell>342</cell></row><row><cell>RPN+VGG, shared</cell><cell>300</cell><cell>07</cell><cell>69.9</cell><cell>198</cell></row><row><cell>RPN+VGG, shared</cell><cell>300</cell><cell>07+12</cell><cell>73.2</cell><cell>198</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 :</head><label>3</label><figDesc>Detection results on PASCAL VOC 2012 test set. The detector is Fast R-CNN and VGG-16. Training data: "07": VOC 2007 trainval, "07++12": union set of VOC 2007 trainval+test and VOC 2012 trainval. For RPN, the train-time proposals for Fast R-CNN are 2k. † : http:// host.robots.ox.ac.uk:8080/anonymous/HZJTQA.html. ‡ : http://host.robots.ox.ac.uk:8080/ anonymous/YNPLXB.html</figDesc><table><row><cell>method</cell><cell># proposals</cell><cell>data</cell><cell>mAP (%)</cell></row><row><cell>SS</cell><cell>2k</cell><cell>12</cell><cell>65.7</cell></row><row><cell>SS</cell><cell>2k</cell><cell>07++12</cell><cell>68.4</cell></row><row><cell>RPN+VGG, shared  †</cell><cell>300</cell><cell>12</cell><cell>67.0</cell></row><row><cell>RPN+VGG, shared  ‡</cell><cell>300</cell><cell>07++12</cell><cell>70.4</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 4 :</head><label>4</label><figDesc>Timing (ms) on a K40 GPU, except SS proposal is evaluated in a CPU. "Region-wise" includes NMS, pooling, fc, and softmax. See our released code for the profiling of running time.</figDesc><table><row><cell>model</cell><cell>system</cell><cell>conv</cell><cell>proposal</cell><cell>region-wise</cell><cell>total</cell><cell>rate</cell></row><row><cell>VGG</cell><cell>SS + Fast R-CNN</cell><cell>146</cell><cell>1510</cell><cell>174</cell><cell>1830</cell><cell>0.5 fps</cell></row><row><cell>VGG</cell><cell>RPN + Fast R-CNN</cell><cell>141</cell><cell>10</cell><cell>47</cell><cell>198</cell><cell>5 fps</cell></row><row><cell>ZF</cell><cell>RPN + Fast R-CNN</cell><cell>31</cell><cell>3</cell><cell>25</cell><cell>59</cell><cell>17 fps</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 5 :</head><label>5</label><figDesc>One-Stage Detection vs. Two-Stage Proposal + Detection. Detection results are on the PASCAL VOC 2007 test set using the ZF model and Fast R-CNN. RPN uses unshared features.</figDesc><table><row><cell></cell><cell>regions</cell><cell></cell><cell>detector</cell><cell>mAP (%)</cell></row><row><cell>Two-Stage</cell><cell>RPN + ZF, unshared</cell><cell>300</cell><cell>Fast R-CNN + ZF, 1 scale</cell><cell>58.7</cell></row><row><cell cols="3">One-Stage dense, 3 scales, 3 asp. ratios 20k</cell><cell>Fast R-CNN + ZF, 1 scale</cell><cell>53.8</cell></row><row><cell cols="4">One-Stage dense, 3 scales, 3 asp. ratios 20k Fast R-CNN + ZF, 5 scales</cell><cell>53.9</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">"Region" is a generic term and in this paper we only consider rectangular regions, as is common for many methods (e.g.,[20,  </note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="22" xml:id="foot_1">, 24]). "Objectness" measures membership to a set of object classes vs. background.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2">For simplicity we implement the cls layer as a two-class softmax layer. Alternatively, one may use logistic regression to produce k scores.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3">In our early implementation (as also in the released code), λ was set as 10, and the cls term in Eqn.(1) was normalized by the mini-batch size (i.e., N cls = 256) and the reg term was normalized by the number of anchor locations (i.e., Nreg ∼ 2,</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="400" xml:id="foot_4">). Both cls and reg terms are roughly equally weighted in this way.<ref type="bibr" target="#b3">4</ref> https://github.com/rbgirshick/fast-rcnn</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_5">www.robots.ox.ac.uk/ ˜vgg/research/very_deep/</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_6">For RPN, the number of proposals (e.g., 300) is the maximum number for an image. RPN may produce fewer proposals after NMS, and thus the average number of proposals is smaller.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Object-Proposal Evaluation Protocol is &apos;Gameable</title>
		<author>
			<persName><forename type="first">N</forename><surname>Chavali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mahendru</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Batra</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1505.05836</idno>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Convolutional feature masking for joint object and stuff segmentation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
				<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Scalable object detection using deep neural networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Erhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Szegedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Toshev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Anguelov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">The PASCAL Visual Object Classes Challenge 2007 (VOC2007) Results</title>
		<author>
			<persName><forename type="first">M</forename><surname>Everingham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Van Gool</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">K I</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Winn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zisserman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Girshick</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1504.08083</idno>
		<title level="m">Fast R-CNN</title>
				<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Rich feature hierarchies for accurate object detection and semantic segmentation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Girshick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Donahue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Darrell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Spatial pyramid pooling in deep convolutional networks for visual recognition</title>
		<author>
			<persName><forename type="first">K</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECCV</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">What makes for effective detection proposals?</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hosang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Benenson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Dollár</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schiele</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1502.05082</idno>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">How good are detection proposals, really</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hosang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Benenson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schiele</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">BMVC</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">Y</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shelhamer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Donahue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Karayev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Girshick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Guadarrama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Darrell</surname></persName>
		</author>
		<author>
			<persName><surname>Caffe</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1408.5093</idno>
		<title level="m">Convolutional architecture for fast feature embedding</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Imagenet classification with deep convolutional neural networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hinton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
				<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Backpropagation applied to handwritten zip code recognition</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Boser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Denker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Henderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Howard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hubbard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">D</forename><surname>Jackel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural computation</title>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">K</forename><surname>Lenc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vedaldi</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1506.06981</idno>
		<title level="m">R-CNN minus R</title>
				<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Fully convolutional networks for semantic segmentation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shelhamer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Darrell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
				<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Rectified linear units improve restricted boltzmann machines</title>
		<author>
			<persName><forename type="first">V</forename><surname>Nair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
				<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Girshick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1504.06066</idno>
		<title level="m">Object detection networks on convolutional feature maps</title>
				<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><forename type="first">O</forename><surname>Russakovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Krause</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Satheesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Karpathy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Khosla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Fei-Fei</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1409.0575</idno>
		<title level="m">ImageNet Large Scale Visual Recognition Challenge</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Overfeat: Integrated recognition, localization and detection using convolutional networks</title>
		<author>
			<persName><forename type="first">P</forename><surname>Sermanet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Eigen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mathieu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fergus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
		<editor>ICLR</editor>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Very deep convolutional networks for large-scale image recognition</title>
		<author>
			<persName><forename type="first">K</forename><surname>Simonyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zisserman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICLR</title>
				<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Scalable, high-quality object detection</title>
		<author>
			<persName><forename type="first">C</forename><surname>Szegedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Erhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Anguelov</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1412.1441v2</idno>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Deep neural networks for object detection</title>
		<author>
			<persName><forename type="first">C</forename><surname>Szegedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Toshev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Erhan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
				<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Selective search for object recognition</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Uijlings</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">E</forename><surname>Van De Sande</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Gevers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Smeulders</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>IJCV</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Visualizing and understanding convolutional neural networks</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Zeiler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fergus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECCV</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Edge boxes: Locating object proposals from edges</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Zitnick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Dollár</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECCV</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
