<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Verifying Industrial Hybrid Systems with MathSAT 1</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Gilles</forename><surname>Audemard</surname></persName>
							<email>audemard@iut-lens.univ-artois.fr</email>
							<affiliation key="aff0">
								<orgName type="department">Centre de Recherche en Informatique de Lens IUT de Lens</orgName>
								<address>
									<addrLine>Rue de l&apos;université</addrLine>
									<postCode>SP16, F 62307</postCode>
									<settlement>Lens Cedex</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Marco</forename><surname>Bozzano</surname></persName>
							<email>bozzano@itc.it</email>
							<affiliation key="aff1">
								<orgName type="department">ITC-IRST</orgName>
								<address>
									<addrLine>Via Sommarive 18</addrLine>
									<postCode>38050</postCode>
									<settlement>Povo, Trento</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alessandro</forename><surname>Cimatti</surname></persName>
							<email>cimatti@itc.it</email>
							<affiliation key="aff1">
								<orgName type="department">ITC-IRST</orgName>
								<address>
									<addrLine>Via Sommarive 18</addrLine>
									<postCode>38050</postCode>
									<settlement>Povo, Trento</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Roberto</forename><surname>Sebastiani</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">DIT</orgName>
								<orgName type="institution">Università di Trento</orgName>
								<address>
									<addrLine>Via Sommarive 14</addrLine>
									<postCode>38050</postCode>
									<settlement>Povo, Trento</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Verifying Industrial Hybrid Systems with MathSAT 1</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">5468DB13080672FA730E904FE6383CA8</idno>
					<idno type="DOI">10.1016/j.entcs.2004.12.022</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:29+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Formal Verification</term>
					<term>Hybrid Systems</term>
					<term>SAT</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Industrial systems of practical relevance can be often characterized in terms of discrete control variables and real-valued physical variables, and can therefore be modeled as hybrid automata. Unfortunately, continuity of the physical behaviour over time, or triangular constraints, must often be assumed, which yield an undecidable class of hybrid automata. In this paper, we propose a technique for bounded reachability of linear hybrid automata, based on the reduction of a bounded reachability problem to a MathSAT problem, i.e. satisfiability of a boolean combination of propositional variables and mathematical constraints. The MathSAT solver can be used to check the existence (or absence) of paths of bounded length. The approach is very similar in spirit to SAT-based bounded model checking; furthermore, the ability to reason directly about real variables gives computational leverage over discretizationbased methods. Despite the undecidability of the general problem, the proposed method is able to provide valuable information on large designs of practical relevance.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Many systems and plants of industrial relevance (e.g., engines, turbines) are defined in terms of discrete control variables and physical real-valued variables (e.g., speed, pressure), and can be naturally modeled as hybrid automata: depending on a discrete state (e.g., "nominal", "increasing"), different equations describe the behaviour of the physical variable (e.g., speed). Frequently, the dynamics of physical variables is continuous: i.e., transitions from a discrete state to another should not necessarily yield a discontinuity in the physical dimension. For instance, in the transition from "increasing" to "decreasing", the velocity should not change its value (but only its derivative). Furthermore, the evolution can depend on the comparison between the values of physical variables. Unfortunately, either imposing continuity or allowing for comparisons between variables (also known as triangular constraints) result in a class of hybrid automata where even reachability is undecidable <ref type="bibr" target="#b11">[12]</ref>. Yet, it is very important to be able to develop tools that allow to formally validate such designs, that often implement critical functionalities (e.g., control systems for avionics).</p><p>In this paper, we address the problem of verifying hybrid automata with continuous variables and triangular constraints. We propose a formal verification method for bounded reachability. The approach is based on the encoding of a bounded reachability problem into a MathSAT problem, i.e. the problem of checking the satisfiability of a boolean combination of propositional variables and mathematical constraints over real variables. The approach is made practical by the use of the efficient MathSAT solver <ref type="bibr" target="#b0">[1]</ref>, that extends and integrates state-of-the-art techniques for propositional satisfiability (SAT) with a set of mathematical reasoners. The approach presented in this paper is largely similar to bounded model checking <ref type="bibr" target="#b3">[4]</ref>, and enhances the method presented in <ref type="bibr" target="#b2">[3]</ref>, limited to timed systems, to dealing with real variables with arbitrary linear dynamics.</p><p>The proposed technique is clearly incomplete, and currently limited to the case of linear dynamics. Despite these facts, however, it allows us to represent and to analyze interesting systems from real-world applications <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b4">5]</ref>, providing useful information, especially oriented to debugging and goal-directed simulation. An experimental analysis shows that our techniques is competitive with state of the art verification tools such as HyTech, and with methods based on the discretization of real variables. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Outline of the paper</head><p>The rest of the paper is structured as follows. In Section 2 we illustrate a motivating example for our approach; in Section 3 we give a short and informal introduction to our model of hybrid systems; in Section 4 we give a brief overview of SAT-based bounded model checking and we discuss in more detail our encoding of hybrid systems into MathSAT; in Section 5 we discuss some experiments, and finally in Section 6 and 7 we discuss related work and draw some conclusions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">A Motivating Example: The Secondary Power System</head><p>Throughout the paper, we use a running example to motivate and illustrate the main concepts we present. Specifically, we discuss the modeling and analysis of a real-world safety-critical system, namely the Secondary Power System (SPS).</p><p>It is an industrial case study which has been and is being investigated within ESACS (Enhanced Safety Analysis for Complex Systems), a European-Unionsponsored project in the avionics sector, whose goal is to define a methodology to improve the safety analysis practice for complex systems development <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b4">5]</ref>.</p><p>The SPS drives the hydraulic and electrical utilities of an aircraft. It is an example of safety-critical system with embedded hardware and software components. The hardware subsystems comprise (electro)-mechanical components (e.g., control valves, relays, shafts, gearboxes, freewheels) and electronic transducers (e.g., speed and pressure sensors), whereas the software component is given by embedded controllers (SPS computers). The SPS drives the utilities of both the left and right hand side of the aircraft. To ensure the basic safety requirement, i.e. no single failures shall cause the total loss of the SPS utilities, the architecture of the system includes two basic redundancies: there are two independent and perfectly symmetric lines, whose purpose is to drive the left and the right hand side utilities, respectively; for each side, the mechanical drive of the relevant utilities (normal mode) is redounded by a pneumatic drive (cross-bleed mode) in case of failure of one of the components in the mechanical line.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> shows a simplified schematic view of the SPS. The SPS normal operation consists in transmitting the mechanical power from the engines to the relevant hydraulic and electrical generators. Specifically, the mechanical power of the main engine (ME) is transmitted via the Power Take Off Shaft (PTO) to a gearbox (GBX) which feeds the utilities. A component may fail due to abnormal operational conditions or ruptures. As an example, flameout and grippage are two possible failure modes of the main engine. To ensure safety of in-flight operation, in case of an engine failure the SPS computers automatically initiate a cross-bleed procedure consisting in driving the hydraulic and electrical generators by means of an air turbine motor (ATSM), using bled air from a valve (VALVE), which is in turn fed by the mechanical power coming from the opposite engine. Correct functioning of the cross-bleed procedure is an example of one safety requirement of the SPS. Some experimental results about this will be presented in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Modeling Hybrid Automata</head><p>In this section we briefly present and exemplify our model of hybrid systems. The model is inspired by the linear and rectangular hybrid automata models presented in <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>. Informally, a hybrid system can be seen as the parallel composition of a collection of hybrid automata, which can communicate either by explicit synchronization on some channel, or implicitly by means of shared variables. Each automaton models both discrete events (e.g., failure of a component) and continuous activities of analog variables (e.g., time, component speed). At any given instant of time, the state of a hybrid automaton is defined by a control location (discrete state) and the values of all the analog variables (continuous state). The state can change either because of an instantaneous discrete transition, which changes the control location and may also affect the values of the analog variables (e.g., re-initialization is possible) or because of a time elapse (continuous) transition, which changes only the values of the analog variables according to some specified law. Hybrid systems can be seen as an extension of the timed systems model of <ref type="bibr" target="#b2">[3]</ref>, in which the only analog variables are clocks. In the following, by elementary linear expression we mean an equality and/or (non-strict) inequality over linear terms (i.e., linear combinations of real-valued variables with rational coefficients). Analog Variables A finite vector of real-valued data variables (w 1 , . . . , w n ).</p><p>The sp me variable in Figure <ref type="figure" target="#fig_3">2</ref> encodes the speed of the ME. Clock variables of <ref type="bibr" target="#b2">[3]</ref> may be seen as a particular case of real-valued variables. Primed variables (e.g., sp me ) are used to denote the value of real-valued variables after execution of a transition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Initial and Invariant Conditions</head><p>Every location of a hybrid automaton may be declared as initial (meaning that it is a legal initial state of the system). Every location may be equipped with invariants on the real-valued variables, expressed by means of a set of elementary linear expressions {ψ 1 , ..., ψ h } over the variables w 1 , . . . , w n . Location no f ail is the initial location of the ME automaton (Figure <ref type="figure" target="#fig_3">2</ref>), and is equipped with an invariant enforcing the sp me variable to stay between the constant values sm 1 and sm 2 . The invariant in location speed sm3 forces sp me to assume con- stantly the value sm 3 .</p><p>Channels A finite set of channels is used for discrete communication between automata. A channel c may be used as an input (notation c?) or an output (notation c!) channel for synchronizing different automata. For instance, the pressure valve automaton of Figure <ref type="figure">3</ref> uses two different input channels called open? and close?. The intended semantics is that the pressure valve automaton awaits for incoming commands (requesting either opening of closing of the valve) coming from the relevant SPS computer controller.</p><p>Transitions A finite set of discrete transitions encodes the discrete evolution of the automaton. Each transition (also called switch) has a source and target location, and may be equipped with a set {γ 1 , ..., γ k } of guards (pre-conditions) and a set {θ 1 , ..., θ m } of jump conditions (post-conditions) on the real-valued variables. A guard is an elementary linear expression over w 1 , . . . , w n ; a jump condition is an elementary linear expression over w 1 , . . . , w n , w 1 , . . . , w n . In Figure <ref type="figure" target="#fig_3">2</ref>, the transition from flameout to speed sm3 has a guard sp me = sm 3 and no jump condition. By convention, the absence of jump conditions on a transition forces real-valued variables to preserve their value (e.g., in the previous example sp me = sp me implic- itly holds). Transitions may be equipped with one or more optional labels denoting the channels on which the automaton must synchronize. For instance, two transitions in Figure <ref type="figure">3</ref>  The hybrid automata presented here do not fall into the rectangular automata class described in <ref type="bibr" target="#b9">[10]</ref>, since re-initialization of variables is not enforced, and triangular constraints are possible. As a consequence, even the problem of reachability for this class of automata is undecidable <ref type="bibr" target="#b11">[12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Bounded Model Checking for Hybrid Systems</head><p>In this section we give a very short overview of SAT based model checking, and we discuss the encoding of our model of hybrid systems, informally described in Section 3, into MathSAT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">SAT Based Bounded Model Checking</head><p>Bounded Model Checking (BMC) is a recent approach to symbolic model checking <ref type="bibr" target="#b3">[4]</ref>. Given a Kripke structure M , and an LTL formula f , the idea is to check whether f is true in M by looking for a counterexample (i.e., a witness to the violation of f ) that can be presented within a bound of k steps. Given k, the problem is reduced to the satisfiability of a propositional formula [[M, ¬f ]] k . For instance, for a property of the form f := Gp(s), where p(s) is a boolean formula in the boolean variables s, then</p><formula xml:id="formula_0">[[M, ¬f ]] k = I(s (0) ) ∧ k i=0 C(s (i) ) ∧ k-1 i=0 R(s (i) , s (i+1) ) ∧ k i=0 ¬p(s (i) ),</formula><p>where I(s (0) ) is a representation of the initial conditions, C(s (i) ) is a representa- tion of the invariant conditions at step i, and R(s (i) , s (i+1) ) is a representation of the transition relation from step i BMC is being increasingly accepted as practical technique, effective in particular in the process of falsification, i.e. bug finding. The technique relies on the use of efficient SAT solvers (e.g., based on DPLL procedures <ref type="bibr" target="#b7">[8]</ref>) for checking the propositional satisfiability of [[M, ¬f ]] k . As shown in <ref type="bibr" target="#b6">[7]</ref>, BMC avoids the blow-up in memory that can occur with model checking based on Binary Decision Diagrams, and is therefore able to tackle much larger circuits.</p><formula xml:id="formula_1">to step i + 1. If [[M, ¬f ]] k is satisfiable, the propositional model provides a counterexaple of k steps to f . If [[M, ¬f ]] k is unsatisfiable,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">The encoding</head><p>Our approach to the verification of hybrid automata is a generalization of BMC for timed systems, as proposed in <ref type="bibr" target="#b2">[3]</ref>. The approach reduces a BMC problem for timed systems to the problem of deciding the satisfiability of math-formulas, i.e. boolean combinations of boolean variables and linear (in)equalities over real variables, representing absolute time and clocks. The resulting math-formulas are tackled with MathSAT [2,1], a solver combining an efficient DPLL procedure with mathematical constraint solvers of increasing deductive power.</p><p>In the encoding for timed automata, boolean variables are used to encode the discrete part of the system, while linear constraints on real variables encode the timed part. In particular, each location l is represented by a bitwise encoding l, so that l i holds if and only if the system is in the location l i ; each synchronization event (channel, shared variable) is represented by a corresponding boolean variables; each switch is represented by a single boolean variable (say, T ) which holds if and only if the system executes the corresponding switch; a boolean variable T δ , representing a continuous transition, holds if and only if time elapses by some δ &gt; 0; finally, for each process P i , we introduce a boolean variable T i null , that holds if and only if process P i does nothing. In order to deal with time, we introduce a real valued variable t representing absolute time, and, for each clock x, a real valued variable ox representing the difference with respect to absolute time. All mathematical constraints required in the encoding are in the form v 1v 2 c, ∈ {≤, ≥, =, &gt;, &lt;} v 1 and v 2 being real variables representing either absolute time or clock values. The reader can refer to <ref type="bibr" target="#b2">[3]</ref> for details.</p><p>We tackle the case of hybrid automata by considering that it is an extension of the case of timed automata. The encoding for the timed case is extended by introducing a set of real variables ω i 's, representing physical entities. To simplify the notation, in the following we write: "∆t" for the difference tt between absolute time in the next and in the current state; "∆ω" for "ωω", so that, e.g., we write "c • ∆t..." for "c • tc • t..."; "∆ω = 0" for "ω = ω", "∆ω ≤ ..." for "ω ≤ ω + ...". We also write "(w ∈ [t 1 , t 2 ])" for "(w ≥ t 1 ) ∧ (w ≤ t 2 )", where t 1 and t 2 are linear terms. If ψ is a formula, ψ denotes the formula obtained by substituting in ψ each propositional variable p j with p j , and each real variable v i with v i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Initial conditions I(s (0)</head><p>). At step 0, in an initial location l, ω can either:</p><p>• be set to a given initial value c 0 . If so, we represent this fact by the axiom:</p><formula xml:id="formula_2">l (0) → (ω (0) = c 0 );<label>(1)</label></formula><p>• be set nondeterministically to an initial value within a closed interval [a 0 , b 0 ], <ref type="foot" target="#foot_1">3</ref> If so, we represent this fact by the axiom:</p><formula xml:id="formula_3">a 0 , b 0 ∈ [-∞, ∞].</formula><formula xml:id="formula_4">l (0) → (ω (0) ∈ [a 0 , b 0 ]). (2)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Invariant conditions C(s).</head><p>For each location l equipped with the set {ψ 1 , ..., ψ h } of invariants on real valued variables, we include the axiom l → j ψ j .</p><p>(3)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Transition relation R(s, s ).</head><p>For each switch T equipped with a set {γ 1 , ..., γ k } of guards and with a set {θ 1 , ..., θ m } of jump conditions on the real valued variables ω i 's and t, we include the axioms</p><formula xml:id="formula_5">T → j γ j ,<label>(4)</label></formula><p>T → j θ j <ref type="bibr" target="#b4">(5)</ref> respectively. For each physical variable ω that is not interested by a jump condition of switch T , and must therefore keep its value, we add the axiom:</p><formula xml:id="formula_6">T → (∆ω = 0).<label>(6)</label></formula><p>When process i does nothing, in correspondence of T i null , each physical variable ω maintains its value:</p><formula xml:id="formula_7">T i null → (∆ω = 0). (<label>7</label></formula><formula xml:id="formula_8">)</formula><p>When time elapses in a location l, physical variables ω i evolve according to the set of variable dynamics {Ψ 1 , . . . , Ψ k } associated with l. For each location, we add the axiom</p><formula xml:id="formula_9">(l ∧ T δ ) → i Ψ i (8)</formula><p>Different forms of variable dynamics are possible:</p><p>• ω maintains its value under a dynamic of the form:</p><formula xml:id="formula_10">(l ∧ T δ ) → (∆ω = 0);<label>(9)</label></formula><p>• ω may evolve deterministically according to a linear function:</p><formula xml:id="formula_11">(l ∧ T δ ) → (∆ω = c • ∆t) ( 1 0 )</formula><p>c being a constant.</p><p>• ω may evolve nondeterministically within two linear functions: • in the general case, the evolution of the variables can be nondeterministic within the space described by the linear inequalities {Ψ 1 , . . . , Ψ k }, as in equation 8.</p><formula xml:id="formula_12">ω ∈ [b 1 ω + c 1 • ∆t -a 1 , b 2 ω + c 2 • ∆t + a 2 ], (11) a 1 , a 2 ≥ 0, b 1 , b 2 ∈ {0, 1}, c 1 , c 2 ∈ (-∞, ∞). (<label>12</label></formula><p>The encoding of properties basically follows the encoding in <ref type="bibr" target="#b2">[3]</ref>. Our approach is bounded complete, in the following sense: if there exists a trace of length k, then the encoding of length k is satisfiable, and can be found by running MathSAT on it. The undecidability of the class of hybrid automata we are dealing with tells us that it is in general impossible to decide if a counterexample might be found with bigger k, or if the problem is unsolvable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experimental Evaluation</head><p>We evaluated the potential of the approach by tackling an example of hybrid systems of industrial relevance, i.e. the model of the SPS. The bounded reachability method described in Section 4 can be used both for model debugging (i.e., bug hunting) and for simulation of hybrid systems. In the following we provide some hints about the use of our methodology by showing some experimental results. For illustration purposes, we will discuss a simplified one-sided model of the SPS case study, including one instance of the ME, GBX, VALVE, ATSM, PTO and SPS computer components of Figure <ref type="figure" target="#fig_0">1</ref>. Under this abstraction, the analogous components of the opposite side of the system are assumed to be correctly working. An example of property to be checked is given by (the negation of) the following formula:</p><formula xml:id="formula_13">(! GBX.loc broken &amp; ! GBX.loc grippage &amp; ! VALVE.loc stuck closed &amp; ! ATSM.loc broken &amp; ! PTO.loc fused) U GBX.sp gbx &lt;= sg1 (P1)</formula><p>This is a typical safety property expressed via the LTL until operator. The intended semantics is whether there exists a path such that no failures of the GBX, VALVE, ATSM and PTO components happen along the path, and finally the speed of the gearbox (GBX component) drops below the constant value sg 1 . The negation of the above property can be seen as a safety property to be verified by the system (i.e., in presence of failures due only to the main engine, the gearbox speed cannot drop below sg 1 ). The rationale behind this property is that the cross-bleed procedure initiated by the SPS computer (see Section 2) is able to recover from an engine failure by using power coming from the opposite engine (which is assumed to be working in this one-sided model).</p><p>The property may or may not hold depending on the value chosen for the constant sg 1 . In particular, if the value chosen for sg 1 exceeds a given threshold, the property is falsified by MathSAT (this means that the cross-bleed procedure is not able to prevent the gearbox speed to drop below that particular value). In this case, MathSAT generates an output trace showing an execution of the system which leads to the violation. The trace includes information on the discrete transitions and the time elapse transitions taken by the automata, the exact time delays and time points at which the transitions take place, and the synchronization channels between different automata. If the value of the constant sg 1 is chosen below a suitable threshold, property (P1) holds, and therefore MathSAT correctly does not find any counterexample. Regarding the choice of the constant sg 1 , see the discussion in Section 7.</p><p>The trace generated by MathSAT is schematically shown in Figure <ref type="figure" target="#fig_5">4</ref>. For each time instant, the trace shows the current locations of the ME, GBX, ATSM, and VALVE automata, the current values of the sp me, sp gbx, sp atsm analog variables, the discrete transitions which take place at that time instant, and the synchronizations channels. For a better understanding of the trace, in Figure <ref type="figure" target="#fig_6">5</ref> we show a simplified version of the SPS computer automaton (only the part relevant to the simulation is shown). Notice that this automaton shows as example of triangular constraint, i.e. sp gbx</p><formula xml:id="formula_14">-sp atsm ≤ c 1 [≥ c 1 ],</formula><p>and of communication with shared variables (variables sp gbx and sp atsm model, respectively, the speed of the GBX and ATSM components).</p><p>The simulation begins at time T0, when an engine grippage takes place. Both the engine and the gearbox speeds begin to decrease. At time T1, the SPS computer detects a gearbox low speed condition, and therefore issues the opening of the valve (the VALVE and SPS computer automata synchronize on the open channel); as a result, the ATSM begins to increase its speed (SPS and ATSM synchronize on the inc a channel). At time T2, the SPS computer issues a change in the ATSM dynamics (SPS and ATSM synchronize on inc b). The simulation stops at time T3, when the gearbox speed reaches the value sg 1 .</p><p>The same approach can be used for guided simulation. To give an example, we consider the following formula:</p><formula xml:id="formula_15">(! ME.loc eng flameout &amp; ! GBX.loc broken &amp; ! GBX.loc grippage &amp; ! VALVE.loc stuck closed &amp; ! ATSM.loc broken &amp; ! PTO.loc fused) U GBX.sp atsm &gt;= sa1 (P2)</formula><p>It is a variation of the previous reachability property, here we require that at the end of the path the speed of the ATSM component is greater than the constant value sa 1 . Furthermore, by explicitly ruling out an engine flameout, we limit the possible failure modes of the main engine to grippage. As explained in Section 2, in presence of an engine failure, the ATSM component is responsible of carrying out the cross-bleed procedure, which consists in driving the gearbox with the pneumatic power coming from the valve. Correct functioning of the cross-bleed procedure requires the ATSM (which is initially idle) to start and bring up the gearbox speed. Using MathSAT, we are able to reconstruct a trace corresponding to the above property, which illustrates how the cross-bleed procedure is carried out. It is possible to tune the above simulation and perform further ones by adding further constraints on the trace to look for. The performance of our method on the examples described above are reported in Table <ref type="table" target="#tab_2">1</ref>. For each problem length, we show computation time, total computation time up to that problem instance, and memory usage. Computation times include both parse and search time. The results have been obtained on a Pentium III machine 1.0 GHz, with 256 Mb memory, running Linux Redhat 7.1. The minimal length trace generated by MathSat for P1 has length 7, whereas the one generated for P2 has length 11.</p><p>We also attempted a comparison with HyTech <ref type="bibr" target="#b10">[11]</ref>, a state-of-the-art tool for the analysis of hybrid systems. Differently from our approach, HyTech is based on the calculation of the reachable state space, and is therefore not limited to the bounded case. In principle, HyTech may not terminate when tackling an undecidable class of automata (as in the case of the SPS).</p><p>We encoded the models of the SPS, as closely as possible, into HyTech. Overflow errors in the underlying polyhedral libraries made it impossible for HyTech to compute the space of reachable configurations beyond the 5th iteration. We also attempted to use the -o1 and -o2 options, that are sometimes able to limit such problems, but in our case obtained no effect. From the point of view of performance, the time required by HyTech to reach the 5th iteration was 32 seconds, when run without options; the use of -o1 and -o2 required 50 and 86 seconds, respectively. The analysis is very preliminary, but seems to suggest that there is a clear potential in our techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>The work presented in this paper builds upon our previous work on timed systems <ref type="bibr" target="#b2">[3]</ref>. In <ref type="bibr" target="#b2">[3]</ref>, we showed how to reduce the problem of bounded model checking for timed systems to the satisfiability of a math-formula, which can then be checked by a SAT-solver. We also presented the MathSat solver <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b0">1]</ref>, an efficient SAT-solver which is based on the integration of SAT techniques <ref type="bibr" target="#b3">[4]</ref> with some specialized decision procedures for linear mathematical constraints. A work related to ours, but still limited to timed systems, is <ref type="bibr" target="#b16">[17]</ref>. In the present work, as explained in Section 4.2, we have extended the encoding in order to deal with hybrid systems.</p><p>Our model for hybrid systems is closely related with the linear and rectangular hybrid automata models presented in <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b12">13]</ref>, the main difference being in the definition of the dynamics of the real-valued variables. In <ref type="bibr" target="#b9">[10]</ref>, the dynamics (called flow conditions) of the real-valued variables are defined by means of linear constraints over the first derivatives of such variables, whereas in our model dynamics can be characterized by means of linear functions of the time delay, which directly constrain the behaviour of the variables. This approach is analogous to restricting the flows of the real-valued variables to stay inside a rectangular region, as in the rectangular automata model of <ref type="bibr" target="#b9">[10]</ref>. In fact, as noted in <ref type="bibr" target="#b11">[12]</ref>, under the hypothesis of working with convex linear constraints, requiring the flow to be inside a rectangular region amounts to requiring the existence of a smooth function inside the corresponding piecewise-linear envelope.</p><p>The model of hybrid I/O automata presented in <ref type="bibr" target="#b13">[14]</ref> is general enough to accommodate our model of hybrid automata. Discrete and continuous communication are achieved by means of, respectively, shared actions and shared variables. However, discrete events are not allowed to change the value of shared variables, as in our case.</p><p>As an alternative approach to the verification of hybrid systems, we cite <ref type="bibr" target="#b14">[15]</ref>, where the CheckMate tool is presented. CheckMate performs verification of hybrid systems using finite-state approximations called quotient transition systems. Although this approach is not restricted to linear hybrid automata, the verification analysis may be inconclusive, in which case a refinement of the current approximation may be attempted. An analysis of the current trends in model checking of hybrid systems can be found in <ref type="bibr" target="#b15">[16]</ref>.</p><p>This line of research has been carried on inside the ESACS <ref type="bibr" target="#b5">[6]</ref> project (see http://www.esacs.org), an European-Union-sponsored project whose main goals are to define a methodology and a shared environment to improve the safety analysis practice for complex systems development. The Secondary Power System <ref type="bibr" target="#b4">[5]</ref> is one of the case-studies investigated in ESACS. One of the main motivations for our research is the realization that the use of traditional finite-state model checking, based on the discretization of real variables, has a very hard time in dealing with the complexity of hybrid systems <ref type="bibr" target="#b4">[5]</ref>. In fact, the results may depend on the step of discretization, and the state explosion problem makes such an approach infeasible in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions and Future Work</head><p>In this paper, we have addressed the problem of verification of industrial systems that are naturally modeled as linear hybrid automata. The approach is an enhancement of the bounded model checking approach for timed systems proposed in <ref type="bibr" target="#b2">[3]</ref> to the case of linear hybrid automata. Efficiency is gained by the use of the MathSAT solver. The main limitations are given by the undecidability of the analyzed class, and the constraints on the linearity of real variables dynamics. Despite this, however, the approach allows us to model and analyze systems of practical relevance, that HyTech is currently unable to deal with.</p><p>In the future, we will provide a more thorough experimental evaluation, by enlarging both the set of tools we compare with (some of them are cited in Section 6), and the set of case studies to analyze. Regarding the SPS example, we plan to experiment with more complex models, at different levels of granularity and abstraction (e.g., a two-sided model of the system). We will investigate how to optimize the MathSAT solver on these specific problems (e.g., by constraining the splitting variables in the style of <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b17">18]</ref>), and will experiment with different encodings. As a first step towards bridging the gap between bounded model checking and unbounded verification, inductive reasoning techniques to prove invariant properties will be investigated. An important point we plan to address in the near future is concerned with parametric analysis, which is currently supported in HyTech. To exemplify, parametric analysis would allow us to replace the constant value sg 1 in property (P1) (see Section 5) with a parameter α in order to find out constraints on the parameter for which the property does or does not hold. Finally, in the future we plan to extend the framework to properties expressed in full LTL.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. SPS schematic view</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>2 sp me= sm 3 sp me≤ sm 2 sp me≥ sm 4 sp me= sm 4 sp me= sm 4 Fig. 2 .</head><label>23442</label><figDesc>Fig. 2. SPS: main engine automaton (ME)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>p 1 p valve≤ p 2 p valve≥ p 1 p valve≤ p 2 Fig. 3 .</head><label>223</label><figDesc>Fig. 3. SPS: valve automaton (VALVE)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2</head><label>2</label><figDesc>and 3 depict two examples of hybrid automata, modeling the main engine (ME) and the valve (VALVE) components of the SPS. A hybrid automaton consists of the following components: Locations A finite set of locations, encoding the discrete states of the hybrid automaton. The automaton in Figure 2 has five locations, drawn as circles, which model the discrete state of the ME of the SPS. Location no f ail mod- els the default behaviour of the engine; locations grippage and flameout model two different faulty states; locations speed sm4 and speed sm3 model states in which the speed of the engine has the constant value sm 4 and sm 3 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>) If a 1 = a 2 = 0, then (11) encodes a triangular constraint. If b 1 = b 2 = 0 and c 1 = c 2 = 0, then (11) encodes a rectangular constraint.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. An example of MathSAT trace</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. SPS computer automaton (fragment)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Variable Dynamics Variable dynamics describe how the real-valued variables change in presence of a time elapse transition, and are expressed, for each location, as a set {Ψ 1 , . . . , Ψ k } of elementary linear expressions over w 1 , . . . , w n , w 1 , . . . , w n , As an example, in Figure2the sp me variable in lo- cation grippage varies according to the law sp me = sp me-k</figDesc><table /><note><p>are labeled with the input channels open? and close? 1 (∆t) (where k 1 is a constant), that is, the speed decreases linearly (proportionally to the time delay) with first derivative equal to k 1 . The expression ∆t, encoding the time delay, will be explained in Section 4.2.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>then nothing can be said about the existence of counterexamples to M |= f with higher bound. The typical technique is to generate and solve [[M, ¬f ]] k for increasing values of k, until either a counter-example is found, or a given time-out is reached.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1</head><label>1</label><figDesc>Experimental results (Time in seconds, Memory in MB)</figDesc><table><row><cell></cell><cell cols="2">Property P1</cell><cell></cell><cell></cell><cell cols="2">Property P2</cell></row><row><cell cols="8">k Time Σ Time Mem. Result Time Σ Time Mem. Result</cell></row><row><cell>2 0.06</cell><cell>0.06</cell><cell cols="3">5.6 UNSAT 0.10</cell><cell>0.10</cell><cell cols="2">5.5 UNSAT</cell></row><row><cell>3 0.20</cell><cell>0.26</cell><cell cols="3">6.2 UNSAT 0.16</cell><cell>0.26</cell><cell cols="2">6.0 UNSAT</cell></row><row><cell>4 0.53</cell><cell>0.79</cell><cell cols="3">7.1 UNSAT 0.30</cell><cell>0.56</cell><cell cols="2">6.8 UNSAT</cell></row><row><cell>5 1.81</cell><cell>2.60</cell><cell cols="3">7.7 UNSAT 0.49</cell><cell>1.05</cell><cell cols="2">7.5 UNSAT</cell></row><row><cell>6 6.49</cell><cell>9.09</cell><cell cols="3">8.4 UNSAT 0.84</cell><cell>1.89</cell><cell cols="2">8.2 UNSAT</cell></row><row><cell>7 4.53</cell><cell>13.62</cell><cell>8.9</cell><cell>SAT</cell><cell>1.53</cell><cell>3.42</cell><cell cols="2">8.8 UNSAT</cell></row><row><cell>8</cell><cell></cell><cell></cell><cell></cell><cell>2.88</cell><cell>6.30</cell><cell cols="2">9.4 UNSAT</cell></row><row><cell>9</cell><cell></cell><cell></cell><cell></cell><cell>4.94</cell><cell cols="3">11.24 10.0 UNSAT</cell></row><row><cell>10</cell><cell></cell><cell></cell><cell></cell><cell>8.69</cell><cell cols="3">19.93 10.7 UNSAT</cell></row><row><cell>11</cell><cell></cell><cell></cell><cell></cell><cell>8.88</cell><cell cols="2">28.81 11.3</cell><cell>SAT</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>G.Audemard  et al. / Electronic Notes in Theoretical Computer Science 119 (2005) 17-32</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>"a 0 = -∞" and "b 0 = -∞" mean that there is no lower bound and no upper bound for ω respectively.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"> <ref type="bibr" target="#b0">1</ref> <p>This work has been sponsored by the CALCULEMUS! IHP-RTN EC project, contract code HPRN-CT-2000-00102, and has thus benefited of the financial contribution of the Commission through the IHP programme. It has also been partly supported by ESACS, an European sponsored project, contract no. G4RD-CT-2000-00361, and by a grant from Intel Corporation. <ref type="bibr" target="#b1">2</ref> Sponsored by a MIUR COFIN02 project, code 2002097822 003.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A SAT Based Approach for Solving Formulas over Boolean and Linear Mathematical Propositions</title>
		<author>
			<persName><forename type="first">Gilles</forename><surname>Audemard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Piergiorgio</forename><surname>Bertoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alessandro</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Artur</forename><surname>Korni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roberto</forename><surname>Sebastiani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNAI</title>
		<editor>
			<persName><forename type="first">Andrei</forename><surname>Voronkov</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="195" to="210" />
			<date type="published" when="2002">2002</date>
			<publisher>Springer</publisher>
			<pubPlace>Copenhagen, Denmark</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Integrating Boolean and Mathematical Solving: Foundations, Basic Algorithms and Requirements</title>
		<author>
			<persName><forename type="first">Gilles</forename><surname>Audemard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Piergiorgio</forename><surname>Bertoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alessandro</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Artur</forename><surname>Korni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roberto</forename><surname>Sebastiani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CALCULEMUS-2002: Symposium on the Integration of Symbolic Computation and Mechanized Reasoning, volume 2385 of LNAI</title>
		<editor>
			<persName><forename type="first">Jacques</forename><surname>Calmet</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Bernard</forename><surname>Benhamou</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Olga</forename><surname>Caprotti</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Laurent</forename><surname>Henocque</surname></persName>
		</editor>
		<editor>
			<persName><surname>Volker Sorge</surname></persName>
		</editor>
		<meeting><address><addrLine>Marseille, France</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="231" to="245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Bounded Model Checking for Timed Systems</title>
		<author>
			<persName><forename type="first">Gilles</forename><surname>Audemard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alessandro</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Artur</forename><surname>Korni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roberto</forename><surname>Sebastiani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FORTE 2002: Conference on Formal Techniques for Networked and Distributed Systems</title>
		<editor>
			<persName><forename type="first">Doron</forename><forename type="middle">A</forename><surname>Peled</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</editor>
		<meeting><address><addrLine>Houston, Texas</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002-11">November 2002</date>
			<biblScope unit="volume">2529</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Symbolic Model Checking without BDDs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Biere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th International Conference on Tools and Algorithms for Construction and Analysis of Systems (TACAS&apos;99)</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Cleaveland</surname></persName>
		</editor>
		<meeting>5th International Conference on Tools and Algorithms for Construction and Analysis of Systems (TACAS&apos;99)</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1579</biblScope>
			<biblScope unit="page" from="193" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Improving Safety Assessment of Complex Systems: An industrial case study</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bozzano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cavallo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Cifaldi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Valacca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Villafiorita</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Formal Methods Europe (FME 2003), volume 2805 of LNCS</title>
		<meeting>Formal Methods Europe (FME 2003), volume 2805 of LNCS</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="208" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">ESACS: An Integrated Methodology for Design and Safety Analysis of Complex Systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bozzano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Villafiorita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Åkerlund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bieber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bougnol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Böde</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bretschneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cavallo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Castel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Cifaldi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Griffault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Lawrence</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lüdtke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Metge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Papadopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Passarello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Peikenkamp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Persson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Seguin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Trotta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Valacca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Zacco</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Safety and Reliability Conference (ESREL&apos;03)</title>
		<imprint>
			<publisher>Balkema Publisher</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="237" to="245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Benefits of Bounded Model Checking at an Industrial Setting</title>
		<author>
			<persName><forename type="first">F</forename><surname>Copty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Fix</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Giunchiglia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kamhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tacchella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CAV&apos;2001</title>
		<meeting>CAV&apos;2001</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A machine program for theorem proving</title>
		<author>
			<persName><forename type="first">M</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Longemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Loveland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">7</biblScope>
			<date type="published" when="1962">1962</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Act, and the Rest Will Follow: Exploiting Determinism in Planning as Satisfiability</title>
		<author>
			<persName><forename type="first">E</forename><surname>Giunchiglia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Massarotto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sebastiani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. AAAI&apos;98</title>
		<meeting>AAAI&apos;98</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="948" to="953" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The Theory of Hybrid Automata</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 11th Annual International Symposium on Logic in Computer Science (LICS&apos;96)</title>
		<meeting>11th Annual International Symposium on Logic in Computer Science (LICS&apos;96)<address><addrLine>New Brunswick, New Jersey</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="278" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-H</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wong-Toi</surname></persName>
		</author>
		<title level="m">HyTech: A Model Checker for Hybrid Systems. Software Tools for Technology Transfer</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="110" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">What&apos;s Decidable About Hybrid Automata?</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">W</forename><surname>Kopke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Puri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Varaiya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="page" from="94" to="124" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Symbolic Model Checking for Rectangular Hybrid Systems</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 6th International Conference on Tools and Algorithms for Construction and Analysis of Systems (TACAS&apos;00), volume 1785 of LNCS</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Graf</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Schwartzbach</surname></persName>
		</editor>
		<meeting>6th International Conference on Tools and Algorithms for Construction and Analysis of Systems (TACAS&apos;00), volume 1785 of LNCS<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="142" to="156" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">N</forename><surname>Lynch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Segala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Vaandrager</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Automata. Information and Computation</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Modeling and verification of hybrid dynamical system using CheckMate</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">I</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Richeson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">H</forename><surname>Krogh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chutinan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ADPM 2000, Automation of mixed processes</title>
		<meeting>ADPM 2000, Automation of mixed processes</meeting>
		<imprint>
			<publisher>Hybrid Dynamic Systems. Shaker Verlag</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">An assessment of the Current Status of Algorithmic Approaches to the Verification of Hybrid Systems</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">I</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Stursberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">H</forename><surname>Krogh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Engell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 40th Conference on Decision and Control</title>
		<meeting>40th Conference on Decision and Control</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Bounded Model Checking for Timed Automata</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sorea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 3rd Workshop on Models for Time-Critical Systems (MTCS&apos;02)</title>
		<meeting>3rd Workshop on Models for Time-Critical Systems (MTCS&apos;02)<address><addrLine>Brno, Czech Republic</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Tuning SAT checkers for bounded model checking</title>
		<author>
			<persName><forename type="first">Ofer</forename><surname>Strichman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CAV00</title>
		<meeting>CAV00<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1855</biblScope>
			<biblScope unit="page" from="480" to="494" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
