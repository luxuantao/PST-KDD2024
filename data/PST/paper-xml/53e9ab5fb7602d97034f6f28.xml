<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Variability-Aware Module System</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Christian</forename><surname>Kästner</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Philipps University Marburg</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Klaus</forename><surname>Ostermann</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Philipps University Marburg</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sebastian</forename><surname>Erdweg</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Philipps University Marburg</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Variability-Aware Module System</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C3CB7CE0F730E9A003C0164224EFC718</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T04:19+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.3.3 [Programming Languages]: Language Constructs and Features-Modules, packages</term>
					<term>D.2.2 [Software Engineering]: Reusable Software</term>
					<term>D.2.2 [Software Engineering]: Design Tools and Techniques-Modules and interfaces</term>
					<term>D.3.4 [Programming Languages]: Processors-Compilers, Preprocessors General Terms Design, Languages variability, module system, composition, linker, C, preprocessor, #ifdef, conditional compilation, Busybox, software product lines</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Module systems enable a divide and conquer strategy to software development. To implement compile-time variability in software product lines, modules can be composed in different combinations. However, this way, variability dictates a dominant decomposition. As an alternative, we introduce a variability-aware module system that supports compile-time variability inside a module and its interface. So, each module can be considered a product line that can be type checked in isolation. Variability can crosscut multiple modules. The module system breaks with the antimodular tradition of a global variability model in product-line development and provides a path toward software ecosystems and product lines of product lines developed in an open fashion. We discuss the design and implementation of such a module system on a core calculus and provide an implementation for C as part of the TypeChef project. Our implementation supports variability inside modules from #ifdef preprocessor directives and variable linking at the composition level. With our implementation, we type check all configurations of all modules of the open source product line Busybox with 811 compile-time options, perform linker check of all configurations, and report found type and linker errors -without resorting to a brute-force strategy.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>A module system allows developers to decompose a large system into manageable subsystems, which can be developed and checked in isolation <ref type="bibr" target="#b14">[15]</ref>. A module hides information about internal implementations and exports only a welldefined and often machine-enforced interface. This enables an open-world development style, in which software can be composed from modular self-contained parts.</p><p>The need for compile-time variability, for example in software product lines <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b18">19]</ref>, challenges existing module systems. To tailor a software system, stakeholders may want to select from compile-time configuration options (or features) and derive a specific configuration (or variant, or product) of the system. At compile-time, a user selects which configuration options code should be compiled into the system. In a modular scenario, we can derive different configurations by composing different subsets of modules. However, to encode variability only at the composition level, variability must align with the modular structure, and each compile-time configuration option must be expressed as a separate module. When variability crosscuts the dominant decomposition, a modular implementation becomes tricky: A configuration option, such as transaction support in a database, may affect multiple modules and may even change their interfaces <ref type="bibr" target="#b34">[35]</ref>.</p><p>In fact, state-of-the-art product-line implementations often use antimodular concepts: Conditional compilation, typically with #ifdef directives of the C preprocessor, is common and crosscuts entire implementations <ref type="bibr" target="#b38">[39]</ref>. Intended variability of the product line is commonly described in a single global variability model in a closed-world fashion. As long as productlines are developed entirely by a small team inside a single company, this closed-world view may suffice. But, for larger product lines developed by multiple teams, for product lines that should be reused in other contexts, and for product lines that span organizational units, a modular solution is needed.</p><p>An additional challenge comes from the combinatorial explosion of configuration options. There are O(2 n ) compiletime configurations of a product line with n Boolean configuration options. Checking all configurations, one by one, in a brute-force fashion is infeasible in practice due to the sheer number of configurations. Likewise, checking only specific configurations at module-composition-time defies the purpose of modularity, since conflicts are detected only late.</p><p>To enable modular product-line development, we introduce a variability-aware module system that supports both inner variability inside a module and crosscutting variability that affects multiple modules. In the module system, each module can be considered as a product line in itself. Module composition becomes the composition of entire product lines including their variability.</p><p>We formalize our variability-aware module system as a calculus. The distinguishing feature of this module calculus is that interfaces and implementations are variable depending on the selection of configuration options. Furthermore, each module defines its own local variability model -the constraints on its environment. The formalization is based on Cardelli's seminal formalization of separate type checking and linking <ref type="bibr" target="#b14">[15]</ref> and a more recent generalization of this work towards propositions in interfaces <ref type="bibr" target="#b35">[36]</ref>. We show that the calculus is sound in two ways: <ref type="bibr" target="#b0">(1)</ref> well-typedness of a module implies well-typedness of all configurations of the module, and (2) module composition preserves well-typedness.</p><p>We implement a variant of our variability-aware module system for the C programming language with #ifdef variability and build-system variability. Taking every translation unit (.c file) as a module with inner variability (from #ifdef directives), we efficiently and modularly check all configurations of a module and infer an interface with variability. Subsequently, we perform composition checks for all configurations, equivalent to linker checks in C. We encode expensive compatibility checks and type checks as Boolean satisfiability problems, building on prior work on variability-aware analysis <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b54">55,</ref><ref type="bibr" target="#b55">56]</ref>. We provide a full open-source implementation as part of our TypeChef project and type check the entire Busybox product line with 811 compile-time configuration options (and, thus, more potential configurations than the estimated number of atoms in the universe <ref type="bibr" target="#b36">[37]</ref>) to demonstrate practicality. Modularity allows us to type check each of Busybox's 522 files in parallel. We show that Type-Chef is able to find actual type errors in Busybox.</p><p>In summary, our central contributions are the following: <ref type="bibr" target="#b0">(1)</ref> We motivate the need for inner and crosscutting variability. <ref type="bibr" target="#b1">(2)</ref> We design a novel module system for product lines and discuss design decisions. <ref type="bibr" target="#b2">(3)</ref> We formalize the module system as a formal calculus and prove its soundness. <ref type="bibr" target="#b3">(4)</ref> To demonstrate practicality, we present a practical implementation strategy, we implement the module system for C and the C preprocessor, and we find type errors with this implementation in a medium-size real-world product line. To the best of our knowledge, this is the first implementation of modular type-checking for practical product-line implementions in C with #ifdef variability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Modules and variability</head><p>Modularity as enforced by most module systems serves a simple means: It allows splitting a system into smaller subsystems (modules), each of which are divided into an internal implementation and an external interface. The module's interface describes a contract with the rest of the system in terms of imports and exports. Ideally, a developer (or compiler) can understand (or type-check and compile) a module separately, by looking only at its internal implementation and interface, but not at implementations of other modules. Internals of the module can be changed without affecting (and even knowing) any other module. This separation into modules with interfaces enables modular reasoning and reuse of modules in unplanned contexts. For uniformity, we adopt Cardelli's notion that modules have explicit imports and are closed under composition <ref type="bibr" target="#b14">[15]</ref>. That is, two modules can be composed (or linked) to form a larger module, in which imports that are exported by the other module are removed. When composing two compatible modules, module composition should preserve well-typedness.</p><p>In practical software development, frequently a demand for variation arises. Different configurations of a system should be compiled for different platforms, customers, and use cases. Especially in software product lines, such variation is planned and used as strategic advantage. Instead of developing a software system only for a single customer, product lines cover related systems in a whole domain. Such a product-line approach promises lower costs, better quality, shorter time to market, and flexibility to react to market changes, due to strategic reuse <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b18">19]</ref>. For illustration and demonstration, we use two examples of product lines. First, we introduce a tailorable embedded database management system that can be configured with two different storage mechanisms -persistent and in-memory, -an optional XML layer, and other options. Second, we analyze Busybox, a real-world resourceefficient product line of UNIX utilities. In both scenarios, resource constraints of embedded systems demand compiletime reduction and specialization to the necessary core; hence, for different scenarios, different tailor-made solutions should be provided.</p><p>In the following, we outline how to implement variability with conventional module systems, we discuss their limitations, we outline our concept of a variability-aware module system, and we survey how variability is implemented in the real-world product line Busybox.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Variable module composition</head><p>To implement product lines modularly, developers usually develop a module for each configuration option and express variability by composing different sets of modules (which we also call intermodule variability). This style of programming, in which modules align with configuration options, is also known as feature-oriented programming <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b46">47]</ref> and popular in the form of plug-in systems <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b6">7]</ref>.</p><p>In our database example, we could decompose a system into four modules as illustrated in Figure <ref type="figure">1</ref>: a core database module core, an in-memory-storage module inmem, a persistent-storage module persist, and an XML module xml. Now, we derive different systems by composing (•) Composing two modules merges their definitions. Imports of one module are matched by exports of the other module as far as possible; nonexported (private) functions are renamed or inlined if necessary. Two modules exporting the same function, such as inmem and persist in our example, are incompatible and cannot be composed.</p><p>If desired, we can automate the generation of tailored systems for a given selection of configuration options with a build system. Build systems range from simple shell scripts to sophisticated compilation managers <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b47">48]</ref>. Build systems typically introduce explicit configuration options (and possibly dependencies between them in a variability model). The configuration options are then mapped to modules <ref type="bibr" target="#b18">[19]</ref>. For a given selection of configuration options, the build system compiles and composes the corresponding modules. In such a setting, variability is expressed globally for a fixed set of modules at composition level: The modules themselves have no notion of variability, especially no variability in interfaces.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">A case against variability-induced decomposition</head><p>When variability is expressed only at the composition level, modules align with configuration options. On one hand, this alignment enforces separation of concerns regarding configuration options; but, on the other hand, then, variability dictates a dominant decomposition <ref type="bibr" target="#b52">[53]</ref> of the system, which might not be the desired one. There are at least three problems of a variability-induced decomposition:</p><p>• Variability is known as a crosscutting concern <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b38">39,</ref><ref type="bibr" target="#b40">41,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b53">54</ref>]. In our database example, configuration options such as READONLY affect many modules and concerns.</p><p>Even with advanced and controversial module constructs, such as aspects, it is not clear whether the implementation of crosscutting configuration options can be specified modularly in a single module <ref type="bibr" target="#b34">[35]</ref>.</p><p>• Configuration options are not independent. In our example, configuration option READONLY would affect both inmemory and persistent storage. A typical solution of the module-per-configuration-option approach is creating more modules (e.g., inmem-common, inmem-write, and inmem-readonly) <ref type="bibr" target="#b40">[41]</ref>, leading to an explosion of micromodules <ref type="bibr" target="#b31">[32]</ref>.</p><p>• Configuration options (and interactions between configuration options) that affect only few lines of code must be extracted into their own function and module, even if they are just a minor concern in a larger context. Such small additional modules reduce the benefit of an open-world module system, because they are typically hard to reuse and tightly coupled to the rest of the system <ref type="bibr" target="#b31">[32]</ref>.</p><p>We argue that variability should not necessarily dictate the dominant decomposition. Although tool support could potentially address the problem of many small modules, we explore a language-based solution. In the remainder of the paper, we introduce a variability-aware module system that enforces modular checks in the presence of inner and crosscutting variability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Variability inside modules</head><p>Instead of encoding variability using module composition, we propose to encode variability inside modules (which we also call intramodule variability), such that configuration options and modules do not need to align. Each module can be interpreted as a product line that can be configured. For example, we implement a module storage for the storage subsystem that can be configured to use in-memory or persistent storage and to provide read-only or read-and-write access. However, with variability in interfaces, the composition process and the role of the variability model (previously part of the build system) changes.</p><p>We introduce variability with presence conditions. A presence condition on a code element is a formula over configuration options that specifies in which configurations the element should be included. For example, we say module storage defines function fopen only if configuration option  PERSIST is selected (fopen if PERSIST). In the simplest case, presence conditions can be implemented by conditional compilation with #ifdef directives; we discuss alternatives in Section 4.3.</p><p>To reason about configuration options inside a module, we declare them explicitly or import them like functions. Hence, for every configuration option there is a unique module that declares the configuration option (and possibly related configuration information, such as description, defaults, costs, and interested stakeholders). Hence, there is a well-defined distinction between configuration option definition and configuration option usage, which yields a well-defined scoping concept for configuration options and enables standard techniques such as α-renaming of configuration options. Declared configuration options are always part of the interface (they cannot be hidden, because users must be able to configure the module). Finally, each module can have a local variability model that constraints possible combinations of configuration options; for this purpose, we specify a formula, but other notations, including graphical feature diagrams, are possible <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b56">57]</ref>.</p><p>Composing two modules in our variability-aware module system is similar to composing two modules in a traditional module system. Composing two modules with variability (i.e., two product lines) yields another module that combines the variability of both (i.e., another product line). Imports are matched by exports as far as possible, and configuration options and functions are merged. Local variability models are combined, requiring now the constraints of both models.</p><p>We will explore additional constraints on the variability model in case of function conflicts later.</p><p>In Figure <ref type="figure" target="#fig_0">2</ref>, we illustrate module-system concepts with an extended database example. The system is divided into three modules storage, query, and xml, not aligned with variability. Each of these modules has inner variability. Furthermore, we exemplify the result of the composition storage • xml.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Crosscutting and inner-module variability in Busybox</head><p>Before we get to a formal description, we want to emphasize once more the need for a proper variability-aware module system with a look into practice. We report data from the opensource product line Busybox. Like in many product-lines, the Busybox developers did not pursue a strictly modular approach and used the C preprocessor to encode variability inside and across modules. We selected Busybox (release 0.18.5, available at http: //busybox.net/) as a paradigmatic case, representing many other product-line implementations based on conditional compilation <ref type="bibr" target="#b38">[39]</ref>. Busybox has 522 .c files and 260 000 lines of unpreprocessed C code. BusyBox combines custom implementations of many common UNIX utilities into a single small executable for small or embedded devices. Targeted at resource-constraint environments, BusyBox is highly customizable with 811 explicitly declared Boolean compile-time configuration options, allowing users to select which utilities to include and with which facilities.</p><p>As • Crosscutting variability. In addition to 391 (48 %) configuration options local to a single translation unit (usually configuration options of individual tools, such as MOD-PROBE_BLACKLIST), there are 109 (13 %) configuration options that crosscut multiple translation units. Crosscutting is mostly moderate with 46 configuration options affecting between two and ten translation units, and 15 between 11 and 50 translation units. However, 47 configuration options affect over 500 (essentially all) translation units. Configuration options crosscut when several translation units together implement the same concepts, such as UNICODE_SUPPORT and SHADOWPASSWDS. Heavy crosscutting comes mostly from variability in header files that are included in most translation units, independent of whether the functionality is used. Our analysis confirms that crosscutting configuration options are common, and we argue that they should be supported natively by the implementation approach.</p><p>• Variability in module interfaces. Source-level intramodule variability does not only affect module implementations, but also their interfaces. We regard imported and exported functions of a translation unit in C as its interface (for details, see Section 5.2). So, conditional compilation that controls only statements, expressions, or unused declarations does not cause variability in module interfaces. Overall, 11 % of all exports and 7 % of all imports are variable. Of all 811 configuration options, 303 (37 %) affect imports or exports in at least one translation unit. While again variability is mostly local to the interface of a single translation unit, 45 configuration options affect interfaces in up to ten translation units (e.g., HUMAN_READABLE, SHADOWPASSWDS), and 11 configuration options affect more than ten interfaces, with the maximum of 41 interfaces affected by IOCTL_HEX2STR_ERROR (a configuration option adjusting how errors are reported). Our analysis indicates that a large amount of source-level variability is hidden inside modules and does not influence interfaces, but also that handling variability in interfaces is crucial nonetheless.</p><p>In summary, Busybox illustrates that both intermodule variability at composition level and intramodule variability at source-code level are used. There is potential for local definitions of configuration options and for hiding variability implementations inside a module. Many translation units can be considered as small product lines. At the same time, crosscutting is also common. Based on our experience with other open-source systems with compile-time variability implemented in C <ref type="bibr" target="#b38">[39]</ref>, we judge Busybox as a paradigmatic case.</p><p>Traditional module systems cannot handle implementations with intramodule variability at source-code level. Enforcing decomposition by variability would require many additional modules and rewrites, which we regard as impractical for Busybox. On the other hand, in the current form with inner-module variability, a C compiler only determines imported and exported symbols after running the preprocessor to remove all variability from the code. Modules are composed only after selecting configuration options. There is no means to check module compatibility for all configurations, other than applying a brute-force strategy. We conclude that our motivation for variability-aware modules is also supported by current software practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Formalization</head><p>In our module system, a module has a well-defined interface that describes the names and types of imported and exported functions. A type system checks each module in isolation against its interface and a composition engine ensures that composed modules have type-compatible interfaces without name clashes. The formalization can be seen as the specification of the desired behavior, quite distinct from our implementation. We use the formalization to prove that our module system is sound. Although the formal definitions are simple, the soundness properties are not obvious; in fact, it took several iterations of proving and fixing to get the definitions right.</p><formula xml:id="formula_0">Notation: x ∈ X function names e ∈ E expressions t ∈ T types Γ ∈ X → T contexts / function imports ∆ ∈ X → E × T function definitions m = (Γ , ∆) ∈ M module Auxiliary functions: sig : (X → E × T ) → (X → T ) sig(∆)(x) = t where ∆(x) = (e, t) ∀x ∈ dom(Γ 1 ) ∩ dom(Γ 2 ). Γ 1 (x) = Γ 2 (x) typecompatible(Γ 1 , Γ 2 )</formula><p>Module typing:</p><formula xml:id="formula_1">dom(Γ ) ∩ dom(∆) = ∅ Γ ∆ (Γ , ∆) OK ∀x ∈ dom(∆). Γ ∪ sig(∆) e : t where ∆(x) = (e, t) Γ ∆</formula><p>Module compatibility and composition: </p><formula xml:id="formula_2">dom(∆ 1 ) ∩ dom(∆ 2 ) = ∅ typecompatible(Γ 1 , Γ 2 ) typecompatible(Γ 1 , sig(∆ 2 )) typecompatible(sig(∆ 1 ), Γ 2 ) (Γ 1 , ∆ 1 ) ÷(Γ 2 , ∆ 2 ) Γ = Γ 1 ∪ Γ 2 \ (sig(∆ 1 ) ∪ sig(∆ 2 )) ∆ = ∆ 1 ∪ ∆ 2 (Γ 1 , ∆ 1 ) • (Γ 2 , ∆ 2 ) = (Γ , ∆ )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">A base module system M without variability</head><p>To illustrate the basic concepts, let us start with a small calculus of a module system without intramodule variability in Figure <ref type="figure" target="#fig_1">3</ref>. The calculus follows the spirit of Cardelli's module system formalization <ref type="bibr" target="#b14">[15]</ref>.</p><p>A module consists of a set of imported function declarations with their associated type, and a list of typed function definitions with a body. Imports are modeled as partial finite maps (we overload the function arrow → to denote partial maps) from names to types, definitions are maps from names to types and expressions. The interface of a module consists of all imported declarations and the signatures of all locally defined functions. We could easily model a distinction between private definitions and exported definitions, but except for the need of renaming during composition, this adds little to our discussion; we instead assume that private functions have been inlined. Translating the example from Figure <ref type="figure">1</ref> into this calculus is straightforward. We leave the exact form of expressions and types open; we just assume that there is a type system for the expression language that can perform a type-check of the form Γ e : t. The only requirement on the typing relation is that it must be monotonic (if Γ is an extension of Γ and Γ e : t, then Γ e : t), otherwise module composition would not preserve well-typedness. Almost all type systems used in practical programming languages have this property. <ref type="foot" target="#foot_0">1</ref>We type check each module in isolation. A module is well-typed (m OK) if all function bodies are well-typed in the context of imported and defined functions and if a function is not both imported and defined.</p><p>Two modules are compatible (m 1 ÷ m 2 ) unless they contain a function conflict. There are three kinds of possible function conflicts: (1) both modules export a function with the same name, (2) both modules import a function with the same name but with different types, and (3) one module imports a function defined in the other with a different type. Composing two modules essentially merges imports and exports, and imports provided by the other module are removed. To compose two modules with a function conflict, first the conflict must be resolved; for example, developers can rename the function in one module to make both modules compatible (see also the rename operator of the composition language in Section 3.4).</p><p>Module system M has the following desirable properties:</p><p>(P1) The module system is closed under composition, that is, composing two modules yields a new module (• :</p><formula xml:id="formula_3">M × M → M).</formula><p>(P2) We can type check each module in isolation (against its own interface), independent of other modules (m OK).</p><p>(P3) To determine whether two modules are compatible (m 1 ÷ m 2 ), we only need to investigate their interfaces, not their internal implementations.</p><p>(P4) When composing two well-typed compatible modules, and the typing relation is monotonic, then the composed module is well-typed as well (m</p><formula xml:id="formula_4">1 OK ∧ m 2 OK ∧ m 1 ÷ m 2 ⇒ m 1 • m 2 OK).</formula><p>(P5) Composition is associative and commutative.</p><p>Additional notation:</p><formula xml:id="formula_5">f ∈ F configuration options c ∈ C = 2 F configurations v ∈ V = 2 C variability models Γ ∈ C → X → T variable contexts ∆ ∈ C → X → E × T variable definitions m = (v, Γ , ∆) ∈ M v module Auxiliary functions: Sig : (C → X → E × T ) → (C → X → T ) Sig(∆)(c)(x) = t where ∆(c)(x) = (e, t) Module typing: v ⊆ dom(Γ ) v ⊆ dom(∆) ∀c ∈ v. (Γ (c), ∆(c)) OK v = ∅ (v, Γ , ∆) OK conflictpresence(Γ 1 , Γ 2 ) = c ∈ dom(Γ 1 ) ∩ dom(Γ 2 ) | dom(Γ 1 (c)) ∩ dom(Γ 2 (c)) = ∅ conflicttype(Γ 1 , Γ 2 ) = c ∈ dom(Γ 1 ) ∩ dom(Γ 2 ) | ∃x ∈ dom(Γ 1 (c)) ∩ dom(Γ 2 (c)). Γ 1 (c)(x) = Γ 2 (c)(x) conflict(Γ 1 , ∆ 1 , Γ 2 , ∆ 2 ) = conflictpresence(Sig(∆ 1 ), Sig(∆ 2 )), conflicttype(Γ 1 , Γ 2 ), conflicttype(Γ 1 , Sig(∆ 2 )), conflicttype(Sig(∆ 1 ), Γ 2 )</formula><p>Module compatibility and composition:</p><formula xml:id="formula_6">v = x =y conflict(Γ x , ∆ x , Γ y , ∆ y ) v = v 1 ∩ . . . ∩ v n v\v = ∅ ÷ (v 1 , Γ 1 , ∆ 1 ), . . . , (v n , Γ n , ∆ n ) v = v 1 ∩ v 2 \ conflict(Γ 1 , ∆ 1 , Γ 2 , ∆ 2 ) Γ (c) = Γ 1 (c) ∪ Γ 2 (c) \ (sig(∆ 1 (c)) ∪ sig(∆ 2 (c))) ∆ (c) = ∆ 1 (c) ∪ ∆ 2 (c) (v 1 , Γ 1 , ∆ 1 ) • (v 2 , Γ 2 , ∆ 2 ) = (v , Γ , ∆ ) Figure 4. Module system M v with inner-module variability. (P6) Module compatibility is closed under module com- position (m 1 ÷ m 2 ∧ m 1 ÷ m 3 ∧ m 2 ÷ m 3 ⇒ m 1 ÷ (m 2 • m 3 )</formula><p>), as proved in the appendix.</p><p>We want to preserve these properties when we move to a variability-aware module system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">A variability-aware module system M v</head><p>Now, let us introduce variability into the module system M. For clarity, we proceed in two steps: First, we add variability with a global name space for configuration options in M v , as specified in Figure <ref type="figure">4</ref>. Subsequently, in the next subsection, we add a scoping concept for configuration options in M vl . The calculus models semantics and is hence rather abstract: We leave open how sets of configuration options are represented (usually with propositional formulas) and just represent them semantically as sets of (or mappings from) configurations. It also leaves open the question of an efficient implementation, since the formal definitions quantify over (possibly infinite) sets of configurations. We will outline an efficient implementation strategy later in Section 5.1.</p><p>From the (countably infinite) set of names of configuration options F, we can derive all possible configurations (c ∈ 2 F ). Of those, a variability model describes the subset of intended valid configurations (v ⊆ 2 F ). A module is a 3-tuple (v, Γ , ∆) that consists of a variability model v, imported function signatures Γ , and defined functions ∆. When considering variability, a function may be imported only in a subset of all configurations or may even be imported with different types in different configurations. Hence, we model imports as a partial map from configurations and function names to types (Γ ∈ C → X → T ). This model ensures the invariant that, in each configuration, each name is mapped to at most one type. Similarly, we model function definitions as map from configurations and function names to expressions with corresponding type declarations.</p><p>Despite variability, type checking (m OK) is still modular. Reusing the formalism of the module system M without variability, we check that function definitions are well-typed and do not overlap with imports in all valid configurations described by the variability model v. Furthermore, we assert that for each valid configuration the partial map of imports and definitions is well-defined (v ⊆ dom(Γ )). Finally, we expect that the variability model describes at least a single valid configuration (v = ∅, a property called model consistency in <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b41">42]</ref>) -otherwise module compatibility would be trivial. <ref type="foot" target="#foot_1">2</ref>Based on well-typed modules, we define module compatibility and module composition. There are actually different designs of compatibility and composition possible. Here, we first introduce a notion with some resemblance to type inference: We infer a variability model that describes valid configurations and only report an error when no valid configuration remains. In Section 4.1, we discuss alternative designs and their benefits and drawbacks.</p><p>Modules are incompatible if their variability models do not share a single configuration (v 1 ∩ . . . ∩ v n = ∅). In addition, modules are incompatible if all shared configurations contain a function conflict (as in M, two modules define the same function, two modules import the same function but with different types, or one module defines a function imported by</p><formula xml:id="formula_7">Additional notation: i ⊆ F configuration-option imports j ⊆ F configuration-option definition m = (v, i, j, Γ , ∆) ∈ M vl module Module typing: v ⊆ dom(Γ ) v ⊆ dom(∆) ∀c ∈ v. (Γ (c), ∆(c)) OK v = ∅ i ∩ j = ∅ varmodel(v) ⊆ i ∪ j varmap(v, Γ ) ∪ varmap(v, ∆) ⊆ i ∪ j (v, i, j, Γ , ∆) OK varmodel(v) = f ∈ F | ∃c ∈ v. (c \ {f}) / ∈ v ∨ (c ∪ {f}) / ∈ v varmap(v, ∆) = f ∈ F | f / ∈ varmodel(v) ∧ ∃c ∈ v. ∆(c \ {f}) = ∆(c ∪ {f})</formula><p>Module compatibility and composition: another module but with different types). Auxiliary function conflict returns the set of configurations containing a function conflict. In this design, we allow conflicts in some configurations, as long as not all configurations are affected. Furthermore, pairwise checking of compatibility is not sufficient to guarantee preservation of compatibility under composition (P6), because incompatibilities, say, due to a mutual exclusion property asserted by one module, only show up when considering the compatibility of all modules to be composed (see discussion in Section 4.1). Hence, we model compatibility as a predicate on a set of modules (÷ m 1 , . . . , m n ).</p><formula xml:id="formula_8">m x = (v x , i x , j x , Γ x , ∆ x ) v = x =y conflict(Γ x , ∆ x , Γ y , ∆ y ) v = v 1 ∩ . . . ∩ v n v\v = ∅ ∀x = y. j x ∩ j y = ∅ ÷ m 1 , . . . , m n m = (v , i , j , Γ , ∆ ) v = v 1 ∩ v 2 \ conflict(Γ 1 , ∆ 1 , Γ 2 , ∆ 2 ) Γ (c) = Γ 1 (c) ∪ Γ 2 (c) \ (sig(∆ 1 (c)) ∪ sig(∆ 2 (c))) ∆ (c) = ∆ 1 (c) ∪ ∆ 2 (c) i = i 1 ∪ i 2 \ (j 1 ∪ j 2 ) j = j 1 ∪ j 2 (v 1 , i 1 , j 1 , Γ 1 , ∆ 1 ) • (v 2 , i 2 , j 2 , Γ 2 , ∆ 2 ) = m</formula><p>Composing two compatible modules yields a new module. The new module contains the common configurations of both modules, excluding configurations that contain function conflicts</p><formula xml:id="formula_9">(v = v 1 ∩ v 2 \ conflict(Γ 1 , ∆ 1 , Γ 2 , ∆<label>2</label></formula><p>); we essentially add additional constraints to the variability model for function conflicts). Imports are merged but reduced by the corresponding function definitions for each valid configuration separately. The exclusion of conflicting configurations from the new variability model v ensures that the partial mappings of imports and function definitions are well-defined on the full variability model v .</p><p>Our module system M v with variability preserves properties (P1)-(P5) of the module system M. Since pairwise compatibility is not sufficient to preserve compatibility, as argued above, we relax (P6) to (P6'):</p><formula xml:id="formula_10">(P6') Module compatibility is closed under module composi- tion (÷ m 1 , m 2 , . . . , m n ⇒ ÷ m 1 • m 2 , . . . , m n ).</formula><p>Note that (P6') is compatible with an open-world assumption because a composed module can still be composed with arbitrary other modules (provided that they are compatible with the composed module).</p><p>In addition, M v satisfies a new property configuration preserves typing:</p><p>(P7) All module configurations derivable from a welltyped module are well-typed, that is,</p><formula xml:id="formula_11">∀(v, Γ , ∆) ∈ M v . (v, Γ , ∆) OK ⇒ ∀c ∈ v. (Γ (c), ∆(c)) OK.</formula><p>Properties (P1)-(P3) and (P7) follow directly from the definition of M v . Proofs of the remaining properties can be found in the appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Locality of configuration options in M vl</head><p>So far, our module system has global configuration options. In a final step, we introduce a scoping concept that allows declaring and explicitly importing configuration options, as illustrated in our motivating example in Figure <ref type="figure" target="#fig_0">2</ref>.</p><p>We model configuration options in direct analogy to functions: A configuration option is defined in a module. Equivalent to a function body, a configuration option can provide additional specifications, such as descriptions and defaults. Other modules can import a configuration option to use it, and referencing a configuration option as part of a presence condition is the equivalent of a function call. In line with functions, we check, in each module separately, that only defined or imported configuration options are referenced. Similar to name clashes between functions, name clashes between configuration options can be resolved with α-renaming (see Section 3.4). As function names in our basic module system, configuration options share a global namespace; however, declarations and imports provide a means to enforce scoping of names, so modules that declare the same name are incompatible. As with functions, it does not technically matter which of two modules defines and which imports a configura-tion option; selecting where to place the definition is a design choice. For example, similar to bundling function definitions in separate modules as libraries, designers may decide to bundle multiple configuration options in one separate module.</p><p>We extend our module system to M vl as specified in Figure <ref type="figure" target="#fig_2">5</ref>. A module now additionally contains imports of names of configuration options (i ⊆ F) and definitions of configuration options (j ⊆ F). Since additional description or defaults of configuration options are relevant only for external concerns, we omit them from our formalization. Locally, we check that a configuration option is not both imported and declared (i ∩ j = ∅). Furthermore, variability in the variability model, in function imports, and in function declarations must be expressed only in terms of declared or imported configuration options. Auxiliary function varmodel yields all configuration options that affect the variability model and varmap yields configuration options that make a difference in the definition of a variable mapping (a configuration option f makes a difference if and only if two otherwise equal configurations with and without f are distinguished by a model or mapping). This way, we enforce well-defined scoping of configuration options. In a practical implementation, in which sets of configuration options are represented by propositional formulas, these checks can be conservatively approximated by considering the set of configuration options that occur syntactically in presence conditions in the module.</p><p>Compatibility and composition require only minimal, straightforward extensions: Two modules are incompatible if they declare the same configuration option. During composition, declarations and imports of configuration options are matched and merged like functions. M vl also preserves properties (P1)-(P5), (P6'), and (P7), as proved in the appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Composition language</head><p>So far, we have discussed the module-composition operator (• : M × M → M) and module compatibility. There are additional useful operators at the level of the composition language, such as renaming, hiding, partial configuration, and variability checking. Here, we outline useful operators to give a more complete picture of typical and flexible module composition. We have the following syntax of module expressions in the module-composition language on top of M vl :</p><formula xml:id="formula_12">Z ::= M vl atomic modules | Z • Z composed modules | closed Z completeness check | rename X → X in Z function renaming | renameC F → F in Z configuration-option renaming | hide X in Z function hiding | configure F → { , ⊥} in Z partial configuration | assert V in Z variability check</formula><p>Since the operators and their formalization are straightforward, we provide only an intuition of how they work.</p><p>A module is closed if it has no remaining imports of functions or configuration options in any configuration. The operation closed returns a closed module unmodified and gets stuck on modules that are not closed. A module check is easy to specify and implement on a module's interface by inspecting Γ and i.</p><p>Operation rename takes a module and produces a new module in which all occurrences of a function name (in function imports, function definitions, and function calls in all configurations) are replaced by a different name. As precondition, we expect a well-typed module in which the new function name is not already imported or defined. For example to compose inmem and persist in Figure <ref type="figure">1</ref>, we could rename functions write to writemem and read to readmem: persist • (rename read→readmem in (rename write→writemem in inmem)).</p><p>Similarly, operation renameC renames all occurrences of a configuration option. The operation assumes a well-typed module and a target name that is not yet imported or defined as configuration option inside the module. Technically, we simply exchange the names in configurations during lookups; in a more syntactic implementation, we would rewrite variables in presence conditions. For example, in the source code in Figure <ref type="figure" target="#fig_0">2</ref>, we could simply replace all syntactic occurrences of READONLY by DB_READONLY_ACCESS to avoid possible name clashes with other modules that also have a configuration option READONLY.</p><p>Operation hide hides a function inside a module so that it is no longer exported. The notion of hiding is especially useful in hierarchical module systems <ref type="bibr" target="#b12">[13]</ref>. We can either explicitly model private functions, or we implement hiding by inlining the function. For example, after composing the modules core and inmem in Figure <ref type="figure">1</ref>, we could hide functions read and write to clean the namespace before further compositions.</p><p>Operation configure removes a configuration option from a well-typed module, by selecting or deselecting it. As discussed previously, there are no private configuration options, but every configuration option must be exported to enable a choice. Therefore, we cannot hide a configuration option without deciding whether the corresponding code should be included or not. Syntactically, this operation replaces all occurrences of the configuration option in presence conditions by true or false and removes the corresponding declaration. For example, we could decide to select feature READ-ONLY of module storage in Figure <ref type="figure" target="#fig_0">2</ref> (note that on subsequent composition of that module with query, the imported feature READONLY would no longer be matched by a corresponding definition, that is, the resulting module is not closed).</p><p>Finally, we provide a variability check for a module that asserts that the given module provides expected variability (roughly similar to a type cast). The operation simply returns the module if the expected variability (provided as a variability model) is a subset of the module's variability model, or gets stuck otherwise. So, we can compare a composed module with a separately defined specification, as we discuss in Section 4.2.</p><p>Based on this composition language and the formalization of M vl , we could define a type system that statically checks that a composition does not get stuck. However, such a type system adds little new to our discussion of variability, so it is outside the scope of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Formalization summary</head><p>We have shown that it is possible to make modules variabilityaware while preserving the basic properties of traditional module systems. To do so, we replaced the globals of traditional feature-oriented programming -variability model and scope of configuration options -by modular counterparts and enriched the interface language with variability, such that separate checking becomes possible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Design decisions</head><p>The variability-aware module system that we defined in the previous section makes several design decisions that deserve discussion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Constraint inference</head><p>The most controversial design decision of our calculus is to infer constraints during composition when function conflicts are detected. In our calculus, two modules are compatible even if they contain function conflicts, as long as at least one configuration is without conflict.</p><p>As alternative design, we could regard two modules as incompatible, if they have function conflicts in any configuration. We would define compatibility as follows:</p><formula xml:id="formula_13">v 1 ∩ v 2 ∩ conflict(Γ 1 , ∆ 1 , Γ 2 , ∆ 2 ) = ∅ j 1 ∩ j 2 = ∅ (v 1 , i 1 , j 1 , Γ 1 , ∆ 1 ) ÷(v 2 , i 2 , j 2 , Γ 2 , ∆ 2 )</formula><p>x =y m x ÷ m y ÷ m 1 , . . . , m n A main difference between both designs is associativity of module composition (P5). Consider the following modules: In the inference-based design, the composition operator infers additional constraints that are added to the feature model. If needed, we can use the assert operator of the composition language to ensure that we do not accidentally restrict the module's variability model too much (see Section 3.4). In contrast, in the alternative design, a developer is forced to compose one module with a glue-code module before composing it with another module with partial function conflicts. Along those lines, the variability model to be used as glue code can be integrated into the composition operator, such as</p><formula xml:id="formula_14">m 1 • v m 2 as shorthand for (m 1 • (v, ∅, ∅, ∅, ∅)) • m 2 .</formula><p>There are trade-offs between both designs:</p><p>• Associativity vs. pairwise compatibility: On the one hand, the inference-based design enables associativity of module composition (P5). On the other hand, in the alternative design, already pairwise module compatibility is closed under module composition; thus it satisfies the stronger property (P6) in addition to (P6').</p><p>• Local errors vs. specification effort: In the alternative design, function conflicts are always reported locally when composing two modules. When these function conflicts do not matter due to additional constraints, the developer must provide additional specifications at composition time.</p><p>Conceptually, the alternative design roughly relates to explicit type annotations for type checking, where precise local error messages are possible at the expense of additional specification effort. In contrast, the inference-based design roughly aligns with type inference, because we infer which compositions are correct but only report an error when we actually use one of the excluded configurations.</p><p>As in languages based on type inference, error reporting is less immediate and less local, but less specifications are required.</p><p>Both designs have their merits. For us, flexible, associative composition (P5, P6') was the more important goal, so we decided to present and implement the inference-based design as main mechanisms. Furthermore, our experimental evaluation suggests that compatibility in the inference-based design is not trivial and can find type errors in real-world code. Nevertheless, the alternative design is straightforward to formalize (actually, the different compatibility rule above is the only necessary change) and to implement. Finally, there is a third alternative that would allow both associativity (P5) and pairwise compatibility checks (P6): We could restrict variability models such that only positive constraints can be expressed, for example, by restricting constraints to Horn clauses. Unfortunately, that design choice reduces expressiveness beyond what is acceptable in productline practice: We could not even express mutual exclusion as in module vm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Local variability models and configuration-option imports</head><p>One of our design goals was to eliminate the inherently antimodular global variability model, which is common in product line engineering <ref type="bibr" target="#b18">[19]</ref>. A global variability model does not align with the open-world design of our module system. Instead, we allow specifying the relevant constraints distribut-edly in different modules. Thereby, our variability-aware module system allows decomposing large global variability models into small local variability models. We believe that modules with local variability models can be more easily reused, because local variability models make weaker assumptions on the context. If desired, a global variability model can still be encoded as just another module. This module would declare all configuration options and their constraints. The pattern of having a separate variability model may be useful for the common case that a domain expert models constraints not reflected or detected by the type system, such as "a read-only database does not require transactions". Such an additional variability model can simply be linked into any other module to restrict valid configurations. Optionally, we could extend our module system such that a module can specify expected variability in the form of a minimal configuration space that should not be restricted by other modules; this can also be encoded with the assumes operator of the composition language (cf. Section 3.4).</p><p>One could criticize that we still have a global namespace for configuration options. While this is true, the same holds for the namespace of function names. In both cases, we enforce scoping with explicit imports and compatibility checks detect accidental redefinitions. Furthermore, renaming operations of the composition language can be used to resolve naming conflicts.</p><p>A arguable aspect of our design is that we need to locally redeclare constraints between crosscutting configuration options in every module that needs those constraints for modular type checking. This could easily be addressed by adding named imports in which lists of constraints (and function signatures) or entire modules can be imported with a single import statement. In principle, we could also infer a local variability model that describes exactly all well-typed configurations (similar to how we infer constraints during linking), but in this case we prefer immediate modular reporting of local errors. We could even argue that repeating constraints for modular type checking provides even useful documentation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Abstraction from variability implementation</head><p>Our calculus abstracts from a concrete language and type system at expression level. We intentionally focus on module interfaces to allow different inner implementation approaches and different strategies to type check all configurations of a module's implementation.</p><p>There are many examples of how variability inside a module can be implemented and type-checked.</p><p>• Conditional compilation as introduced in Section 2, even though usually frowned upon from the research community <ref type="bibr" target="#b51">[52]</ref>, is a perfect match for our calculus: Developers can encode presence conditions on code fragments with #ifdef directives. Even variability at expression level is not uncommon in practice <ref type="bibr" target="#b38">[39]</ref>. Variability-aware type checking <ref type="bibr" target="#b32">[33]</ref> can be used to type check all configurations efficiently as we will show. Our implementation for C, discussed in Section 5.2, is entirely based conditional compilation in C code. Although we do not want to encourage using lexical preprocessors, we acknowledge their widespread use and the huge amount of legacy code and provide corresponding tool support.</p><p>• We can use an approach with intermodule variability, in which we provide one module per configuration option (without variability inside modules; cf. Section 2.1), to encode variability inside a composite module <ref type="bibr" target="#b57">[58]</ref>. Several mechanisms, called safe composition, can be used to efficiently check whether all compositions of a fixed set of inner modules allowed by a local variability model are well-typed <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b54">55]</ref>. In our module system, we can nest even variable modules and guarantee a common interface.</p><p>• Finally, we can use any other implementation strategy, including runtime variability <ref type="bibr" target="#b48">[49]</ref>, sophisticated metaprogramming systems <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b35">36]</ref>, and configuration management systems <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b36">37]</ref>. For most of these implementation mechanisms, no efficient means to type check all configurations is available yet. However, if variability in each module is sufficiently restricted, a brute-force approach of checking each distinct implementation of the module's configurations may sufficiently scale. Using a variability-aware module system, we can apply bruteforce type checking to each module in isolation, whereas, once we determined that a module is well-typed, there is no need to recheck it for composition (P3).</p><p>To summarize, the variability-aware module system can provide uniform interfaces to many different forms of variability implementation and type checking inside modules. As such, it also helps us to reason about the composition of variable modules implemented with different approaches and bridges intermodule and intramodule variability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Product lines of product lines</head><p>Developing product lines of product lines (also known as nested product lines <ref type="bibr" target="#b36">[37]</ref>, multi product lines <ref type="bibr" target="#b49">[50]</ref>, or product populations <ref type="bibr" target="#b57">[58]</ref>) has received increasing attention as the size of industrial product lines has grown and the need for a divide-and-conquer strategy arose again. Since each module can be considered as a product line of its own, composing multiple product lines and reusing product lines in different (even unplanned) contexts is a natural use case of our module system. For example, we could reuse the storage-subsystem product line from Figure <ref type="figure" target="#fig_0">2</ref> in a product line of consumer electronics. Our module system offers a clean solution to decompose a product line into smaller subproduct lines, including a suitable decomposition of the variability model, enforcing information hiding with variable interfaces.</p><p>In this context, it is useful to adopt the notion of hierarchical modularity <ref type="bibr" target="#b12">[13]</ref> and provide a rich composition language as outlined in Section 3.4. Supporting composition in hierarchical form allows resolving possible composition conflicts locally, at lower levels of the hierarchy. At each level, developers control what functions and variability the composed module exposes. To that end, renaming, hiding exported functions after composition, and partially configuring a module by selecting or deselecting configuration options become essential operations to prepare modules for composition with independently developed product lines. We believe that most concepts of the SML/NJ compilation manager <ref type="bibr" target="#b12">[13]</ref> can be adopted for product lines in our module system as well; but an in-depth analysis is outside the scope of this work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Implementation and practical scenario</head><p>We demonstrate a practical application of our variabilityaware module system as follows. First, we outline an implementation strategy that is sufficiently efficient for real-world product-line implementations. Second, we actually implemented a variant of the module system for C code with #ifdef variability as part of our TypeChef project. Third, we apply our implementation to the medium-size product line Busybox, which we already introduced in Section 2.4, and report detected type and linker errors. We do not intend to perform rigorous benchmarks; instead, we demonstrate that it is possible to implement such a module system that is sufficiently efficient, and we illustrate practical potential of the module system in a realistic setting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Implementation strategy</head><p>The calculus leaves open how to represent variability and describes checks by quantifying over large configuration spaces (e.g., ∀c ∈ v. . . .). In our implementation, we encode sets of configurations as propositional formulas (p ∈ P), in which variables are names of configuration options, as exemplified already in Section 2.3. Each model of the formula corresponds to a configuration. This allows us to encode module well-formedness and compatibility as Boolean satisfiability problem. We describe an encoding in line with a long tradition of prior work on variability-aware analysis <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b53">[54]</ref><ref type="bibr" target="#b54">[55]</ref><ref type="bibr" target="#b55">[56]</ref>.</p><p>Despite exponential worst-case time, reasoning about all configurations induced by a formula is sufficiently efficient in practice with modern Boolean satisfiability solvers <ref type="bibr" target="#b41">[42]</ref>. An empty configuration set corresponds to an unsatisfiable formula ( false = ∅), the intersection of two configuration sets is equivalent to the conjunction of the corresponding formula ( p 1 ∧ p 2 = v 1 ∩ v 2 ), and so forth.</p><p>We encode the map from configurations and names to types (Γ ∈ C → X → T ) as a map from names and formulas to types (Υ ∈ X → P → T ). This has two benefits: We can iterate over a typically small set of formulas describing only distinct types, and, due to the reversed mapping order, we do not need to copy the entire environment when changing a single function. In this encoding we need to enforce the invariant that all formulas for a name are mutually exclusive with a SAT solver. As optimization, two entries with the same name pointing to the same type can be joined by disjuncting their formulas.</p><p>Module compatibility. To determine compatibility between module interfaces, we check whether there is at least one satisfiable configuration that satisfies both variability models and is not a function conflict: SAT (p 1 ∧ p 2 ∧ ¬conflict(. . .)). To determine function conflicts, we derive a formula that describes all conflicting configurations. Let us illustrate this encoding with conflictpresence: For a name x, we determine the condition when x is exported with any type ( dom(Υ i (x))); subsequently, we require exports from both modules must be mutually exclusive (¬ dom(Υ 1 (x)) ∧ dom(Υ 2 (x)) ); finally, we return the disjunction of these mutually-exclusive constraints for all x defined in both modules. That is, to determine conflictpresence, we iterate over a small set of names and with a small set of formulas per name to create a single formula describing all configurations with conflicts. We encode conflicttype similarly, but additionally compare (a usually small number of) types. All checks are performed solely on interfaces (P3).</p><p>Module composition. During module composition, we create a new variability model as conjunction of the original ones without conflicts (p 1 ∧ p 2 ∧ ¬conflict(. . .)). When both modules import the same function with the same type, we import it only once using the disjunction of the respective presence conditions. To remove a function import with formula a by an export with formula b, the resulting module imports the function with formula a ∧ ¬b. Finally, all entries with formulas a that are unsatisfiable in the resulting variability model p (i.e., ¬SAT (p ∧ a i )) can be removed.</p><p>Type checking all configurations of a module. As discussed in Section 4.3, many different implementation mechanisms can be used inside a module; even a brute-force approach to type check all configurations may be feasible in some cases. Still, more sophisticated checks have been developed for certain variability-implementation approaches <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b54">55,</ref><ref type="bibr" target="#b55">56]</ref>. Here, we briefly outline how to type check code with conditional compilation.</p><p>With variability, each expression can have alternative types, just as each name in the current context can have alternative types. All expressions are type checked in a variability context p ctx (a formula describing the subset of configurations that are checked, for example, the presence condition of the function that contains the expression). When looking up a function call, we find all declared types t i with the corresponding formulas p i . We can discard types with formulas never satisfiable in the current context (¬SAT (p ctx ∧ p i )). We raise an error if, in any configuration in the context, there is no type (SAT (p ctx ∧ ¬p 1 ∧ . . . ∧ ¬p n )) and hence no function; a violation of a property that we call reachability <ref type="bibr" target="#b32">[33]</ref>. Again, the key idea is using propositional formulas to reason about (typically few) alternative types instead of iterating over all configurations.</p><p>For operations that involve comparing two types, such as function application (e.g., e 1 (e 2 )), we look up alternative types for both subexpressions. We check all combinations of both alternative types, if the conjunction of their formulas is satisfiable in the current context. Worst-case effort is exponential and the number of types can explode, but, in practice, expressions rarely have a large number of alternative types <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b16">17]</ref>. For more details on variability-aware type checking see the rich body of prior work <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b54">55]</ref>.</p><p>We determine relevant configuration options (varmodel, varmap in M vl ) syntactically with a sound and conservative approximation (all properties still hold): We collect all variable names in formulas, including the variability model.</p><p>Due to SAT solving, determining compatibility and welltypedness of modules is NP-complete. However, with modern SAT solvers, the complexity of SAT solving is not of practical concern even for large product lines <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b41">42,</ref><ref type="bibr" target="#b54">55]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Implementation for C</head><p>We provide the first approach to type check all configurations of realistic C code, beyond actually preprocessing and checking all configurations in isolation in a brute-force fashion (prior work focused on Java dialects <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b54">55]</ref>, the lambda calculus <ref type="bibr" target="#b16">[17]</ref>, and UML <ref type="bibr" target="#b19">[20]</ref>, or only sketched a possible strategy <ref type="bibr" target="#b5">[6]</ref>). Our implementation of variabilityaware module system supports both modular checking of all configurations of a translation unit and variability-aware compatibility checks. The implementation is part of the Type-Chef project, which pursues variability-aware analysis of real-world C code. TypeChef is open source and available at http://ckaestne.github.com/TypeChef/. For experimentation, a simple interactive online version is available at that site as well.</p><p>Based on the outlined implementation strategy, we implemented the variability-aware module system M vl for C. Instead of modifying a C compiler and linker, we wrote the module system as a separate analysis tool in Scala. It separately detects errors that the normal compiler and linker would find when compiling and composing files in a specific configuration. The implementation consists of four main parts: parsing, modular variability-aware type checking of translation units, interface inference, and composition checks between interfaces.</p><p>Variability-aware parsing. A challenge in analyzing #ifdef variability in C code, which hampered prior approaches, is preserving variability during parsing. Conventional C parsers only parse a single configuration after the preprocessor has inlined includes, expanded macros, and evaluated conditionalcompilation directives. Instead, we parse C code without evaluating #ifdef directives and produce an abstract syntax tree that contains variability information (including information from header files). In case of #ifdef directives, we parse both branches and encode variability in the abstract syntax tree. Typically only explicitly declared configuration options are considered for variability, whereas other macros, such as included guards, are processed as in a traditional preprocessor. The actual process is precise but much more complex, due to lexical use of #ifdef directives on arbitrary tokens and because of interactions between macros, includes, and conditional compilation. The parser has been discussed in detail in prior work <ref type="bibr" target="#b33">[34]</ref>; here, we use it as black-box component.</p><p>Modular variability-aware type checking. For each translation unit, we perform modular variability-aware type checking (m OK of M vl ) on the abstract syntax tree with variability, as outlined above in Section 5.1. The type system determines (alternative) types for all expressions. In C, this means it checks reachability (as described in Section 5.1) of function calls and variables access, reachability of field access of structures, and compatibility of types. In principle, a sound and complete variability-aware type system is possible <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b32">33]</ref>. However, due to the size and the informal description of the C standard, our prototype covers only a large subset of the standard but is incomplete and unsound regarding, for example, goto labels, unreachable-code removal, and several GNU C extensions. The type system incorporates a local variability model (defined in a separate file for each translation unit) and reports errors only within valid configurations. It checks each translation unit in isolation (P2).</p><p>Interface inference. Based on the type system's result, we infer an interface for each translation unit. C fits particularly well to our module-system design, because it distinguishes between function declarations without bodies (prototypes; typically defined in header files) and function definitions with bodies. Function definitions are exported unless marked static, whereas called functions that are declared but not defined are imported. From the presence conditions of function definitions and function calls, we derive presence conditions for the interface; for imports, we derive a presence condition as disjunction of all presence conditions of calls of this function within the translation unit. <ref type="foot" target="#foot_3">3</ref> Types of imports and exports are directly recognized from function declarations and function definitions, respectively (i.e., no type inference and no investigation of other modules is necessary). Furthermore, the interface contains imports for all configuration options used within presence conditions in the translation unit. We do not automatically infer declarations of configuration options or local variability models, but users can define them manually if desired.</p><p>We decided to infer interfaces instead of writing them explicitly, because, except for declarations of configuration options and variability model, all information is already available in the C code. Developers can decide when to import a function by adding an #ifdef around the prototype declaration and can explicitly decide when to export a function with the static specifier, which can also be guarded by an #ifdef. Maintaining a separate manual interface specification and checking it against the implementation is possible, but does not provide additional benefits: An interface cannot be more restrictive than the implementation, unless we change the C compiler as well to enforce our interfaces.</p><p>Compatibility checks. Compatibility checks between inferred interfaces (÷ m 1 , . . . , m n ) implement M vl as outlined in Section 5.1. Our implementation works on inferred interfaces in separate files, not directly on C code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Type checking Busybox</head><p>Finally, we used our variability-aware module system to parse all translation units in Busybox, type check each translation unit in isolation, infer interfaces, and check all compositions.</p><p>Errors. In the analyzed release 0.18.5, all 522 translation units are syntactically correct and well-typed in all valid configurations. The development process of Busybox, which includes some random-configuration testing before releases, seems to catch most type errors already. However, in recent development revisions, we found and reported three compiletime errors specific to certain configurations. <ref type="foot" target="#foot_4">4</ref> In addition, occasionally compile-time errors in development revisions are reported on the mailing list; we reproduced some known (and now fixed) compiler errors throughout the revision history. Here, we exemplify a type error and a linker error.</p><p>In September 2011, a user reported a compile-time error reporting two undeclared variables now and info in file procps/ps.c. 5 After some investigation, the user eventually traced down the problem to a configuration without feature FEATURE_PS_LONG and posted a configuration that would reproduce the error. The patch that fixed the problem adds an additional #ifdef directive around the problematic code fragment. Running TypeChef on the revision at the time of the bug report (git commit b64bd16459) yields two type errors in file procps/ps.c. Without manual investigation, TypeChef pinpoints the problem precisely to a set of configurations with the following constraint:</p><formula xml:id="formula_15">¬DESKTOP ∧ PS ∧ ¬FEATURE_PS_LONG ∧ (SELINUX ∨ FEATURE_SHOW_THREADS ∨ FEATURE_PS_WIDE).</formula><p>In the same month, another user provided a patch for a linker error. <ref type="foot" target="#foot_5">6</ref> An incorrectly placed #ifdef directive (introduced in git commit 128543721) caused that library function match_fstype was no longer exported (instead of being exported when feature PLATFORM_LINUX is selected). At</p><p>Local and crosscutting variability. Our module system supports local and crosscutting variability. In Section 2.4, we already presented several metrics from Busybox that we gathered ex post from our infrastructure. When relying on intermodule variability by providing one module per configuration option, we would have been forced to decompose translation units with inner variability into smaller modules, just for technical reasons. Furthermore, we would have been forced to create many additional modules for configuration options that crosscut the entire implementation. Such encoding appears cumbersome and unpractical, whereas our module system allows modular checks without restructuring the code.</p><p>Our module system explicitly supports encapsulating local inner variability, enables variability to crosscut multiple modules, and supports variability in interfaces. Whereas previously every configuration had to be checked in isolation in a brute-force fashion, we can type check all configurations of each module in isolation and we can check compatibility of all modules with their variability.</p><p>Performance. The advantage of modular checks shows most prominently regarding performance. In total, we need 57 minutes to type check all modules. <ref type="foot" target="#foot_6">7</ref> On average we need 5 seconds to parse a single translation unit with all its headers and with its variability, 0.7 seconds to type check all configurations in a variability-aware fashion, and 0.03 seconds to infer its interface. Compared to a brute-force approach of checking all configurations in isolation, our analysis is extremely fast. The slow down compared to conventional compilers is a tribute to the inherent complexity (we parse and type check all, potentially billions of possible configurations) and the necessity to solve many Boolean satisfiability problems. With our module system, we easily paral-lelize type checking with multiple machines. Furthermore, after a change, we only need to recheck affected files and corresponding compatibility checks instead of reperforming whole-program analysis.</p><p>Checking compatibility and composing all interfaces incrementally (in alphabetical order) requires 29 seconds. Composing them in a divide and conquer fashion (pairwise composition, then pairwise composition of the results, and so on) reduces effort to 4 seconds, with additional potential for parallelization. Overall, the opportunity for quick compatibility checks, for parallelization, and for incremental checking allows us to scale variability-aware analysis to real-world C code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Related work</head><p>Variable module composition. Product-line implementations that target some notion of modularity (e.g., components, plug-ins, feature modules, functors, or aspects) typically follow an approach in which compile-time variability is expressed as intermodule variability during composition, not inside modules <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b47">48,</ref><ref type="bibr" target="#b50">51]</ref>. Several of these approaches offer notions of function refinement, orthogonal to our discussion, for which composition is not commutative <ref type="bibr" target="#b4">[5]</ref>. When constructing product lines from modules without inner variability, type checking each module in isolation is usually straightforward; for languages without explicit module interfaces, such as AHEAD, AspectJ, and DeltaJ, corresponding interfaces can be inferred <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b37">38,</ref><ref type="bibr" target="#b50">51]</ref>. However, since variability is encoded as variable composition, there is still an exponential number of possible configurations. Checking them all is usually infeasible; modular type checking reduces the costs for each composition check but does not reduce their number.</p><p>Inheritance and subtype polymorphism is the traditional way to model variability in object-oriented languages. In classical object-oriented languages, these mechanisms are restricted to single classes and hence not suitable for features that affect multiple classes; more advanced approaches such as class boxes <ref type="bibr" target="#b9">[10]</ref> or virtual classes <ref type="bibr" target="#b23">[24]</ref> generalize these notions (with different restrictions) to sets of collaborating classes. In contrast to our approach inheritance with subtyping supports dynamic variability, it is more restricted with regard to the structural changes that a feature entails. Due to the highly dynamic nature of subtyping, subsumption requires that subtypes can only add methods or refine types of existing methods subject to co-and contravariance restrictions. For instance, it would not be possible to have a function return an integer value in one configuration and a Boolean value in a different configuration and be totally absent in a third configuration.</p><p>The idea to use configuration knowledge for type checking occurred in different contexts, for example, to make configuration options explicit during type checking <ref type="bibr" target="#b3">[4]</ref> or to check all configurations of an entire product lines <ref type="bibr" target="#b54">[55,</ref><ref type="bibr" target="#b55">56]</ref>. For a fixed set of modules (i.e., in a closed world), safe composition explores all configurations against a global variability model using an encoding as Boolean satisfiability problem <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b54">55]</ref>. The same technique was explored also as variability-aware type checking for closed-world nonmodular implementations <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b32">33]</ref> and for other analysis approaches <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b17">18]</ref>. Although following a different technical route, the implementation of our type-checking mechanism inside modules with alternative types was particularly inspired by the structures of the choice calculus <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b25">26]</ref> and the concept of variational programming <ref type="bibr" target="#b26">[27]</ref>. Overall, in our module system, we use similar algorithms and encodings for type checking a module and for implementing linker checks, but a closed-world assumption is never required; an existing (composed) module can always be composed with more modules while retaining the soundness guarantees.</p><p>Variability inside modules. Variability inside modules has been explored in different contexts. Our work was initially inspired by prior work on modular logic metaprogramming <ref type="bibr" target="#b35">[36]</ref>. In logic metaprogramming, programs are derived from a deductive database; by using a logic to describe the effect of metaprograms in interfaces, sound modular type checking can be achieved. We adopted the underlying idea of logic formulas in interfaces, but restricted and specialized it to a level that is practical for large-scale product line development and efficient to check with automated provers. From the perspective of logic metaprograming, we reduce metaprogramming to propositional presence conditions over configuration options and local variability models.</p><p>Several programming languages support some form of type-conditional methods, a form of parametric polymorphism in which the applicability of a method call can depend on the type parameter of the enclosing class <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b44">45]</ref>. Invoking a conditional method is only well-typed when the condition is satisfied in the context of the invocation. For example, in a collection class, such as List, clients should only be allowed to invoke a method print if the class is parameterized with a type that can be printed. The purpose of type-conditional methods is to improve static type-safety; the operational semantics of the language does not change. For instance, it is not possible to define several alternative variants of a method (with different implementations or types) or to define dependencies between configuration options. This means that the applicability of these approaches to variability management in software product lines is rather limited.</p><p>Approaches to increase the flexibility of method dispatch, such as multi-methods <ref type="bibr" target="#b43">[44]</ref>, predicate dispatch <ref type="bibr" target="#b24">[25]</ref>, or dependent classes <ref type="bibr" target="#b27">[28]</ref> could be used for modules with inner variability, but since the dispatch only depends on method arguments, it is not obvious how to encode variability that can not be deduced from the dynamic arguments of a method call. Furthermore, a set of methods with the same name typically needs a default implementation, which is called if none of the other methods is applicable, which is less safe than the checks in our approach, which do not need default implementations but can detect statically when no applicable function exists. Also, modular type checking of these approaches is quite hard <ref type="bibr" target="#b42">[43,</ref><ref type="bibr" target="#b43">44]</ref>. On the other hand, these approaches are much more powerful with regard to expressing dynamic variability, which is not in the scope of this work.</p><p>Compile-time metaprogramming, such as C++ templates or the C preprocessor, is often used to express inner compiletime variability <ref type="bibr" target="#b18">[19]</ref>, but these approaches suffer from the problem that type checking can only take place after specialization to a specific instance of the product line.</p><p>Also the product-line community has explored components with inner variability. Most prominently, the Koala component system has mechanisms for run-time and compiletime variability inside a module, exposed through a diversity interface in Koala <ref type="bibr" target="#b57">[58]</ref>. A Koala module can express variable module composition of inner modules; the condition for the composition can be exposed in the diversity interface. If a configuration parameter is known at compile-time, only the corresponding inner module is included (a specialized form of partial evaluation), otherwise all modules are included and function calls are dispatched at run-time. In contrast to our module system, Koala does not support variability in the functional interface: Diversity interfaces may change the behavior (and which inner component is used to provide the behavior) but not the interface. Dependencies between configuration options and crosscutting variability are not explicitly supported, but can be encoded. Since compile-time variability is expressed with variable module composition (possibly nested inside another module), Koala enforces a variability-induced dominant decomposition.</p><p>Along similar lines, de Jonge <ref type="bibr" target="#b20">[21]</ref> introduced configuration interfaces into a package mechanism: Each package can declare configuration options and bind them in imported packages. Similarly, plastic partial components <ref type="bibr" target="#b45">[46]</ref> introduce variability interfaces for architectural components and realize variability internally with aspect-oriented programming. Van der Storm <ref type="bibr" target="#b56">[57]</ref> subsequently extended this approach with local variability models and configuration checks by encoding variability information as Boolean satisfiability problem. However, all these approaches do not enforce modularity of the host language modules with code-level interfaces; at most they check consistency between packages.</p><p>Composing variability models. Finally, there are many mechanisms to specify and compose variability models and to reason about them. In practice, some flavor of graphical feature diagrams are typically used <ref type="bibr" target="#b18">[19]</ref>, which represent configuration options in a hierarchical form and have a straightforward translation to propositional logic <ref type="bibr" target="#b56">[57]</ref>. Busybox uses the textual feature-modeling language KConfig with a similar concept and translation <ref type="bibr" target="#b10">[11]</ref>. Advanced composition mechanisms attempt to retain the hierarchical form of variability models <ref type="bibr" target="#b0">[1]</ref>; they are orthogonal to our discussion. If variability model and reasoning should include non-Boolean con-figuration options, other logics and solvers can be used <ref type="bibr" target="#b8">[9]</ref>. For our calculus and our implementation, composing propositional formulas was sufficient.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion</head><p>We introduced a variability-aware module system for software product lines that overcomes the variability-induced dominant decomposition of traditional module systems, by allowing variability inside modules and in module interfaces. Each module can be type checked in isolation, covering all configurations allowed by the module's local variability model. Composing two compatible well-typed modules with variability yields another well-typed module with the combined variability. The module system breaks with the productline tradition of closed-world implementations with a global variability model and takes it into an open environment, toward software ecosystems and product lines of product lines. We defined the module system formally in a calculus, outlined a general implementation strategy, and presented an implementation for C, which we applied to the open source product line Busybox. Our next step is to type check the entire Linux kernel with 10 000 configuration options, a task for which the module system is an important foundation, but for which various engineering problems still have to be solved.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Extended database example with inner variability.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Module system M without variability.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Module system M vl extends M v with scoped configuration options.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>)</head><label></label><figDesc>Modules a and b export the same function in overlapping configuration sets, but module vm excludes all overlapping configurations. In an open-world scenario, modules a and b do not know about each other or their configuration options. Nevertheless, the inference-based design decision allows us to compose modules a and b without knowing about a dependency between configuration options A and B; the composition operator infers that A and B must be mutually exclusive. In the alternative design, in which we do not allow any function conflicts, we can compose a with b only after composing one of it with vm. That is, a • (b • vm) is a valid composition, whereas (a • b) • vm is undefined.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Figure 1. Simple database example without inner variability. modules in different combinations: core • inmem yields an in-memory database, core • persist a persistent database, core • inmem • xml an in-memory XML database, and so forth.</figDesc><table><row><cell>inmem = (</cell><cell>persist = (</cell></row><row><cell>export fun write(k: Key, t: Table): Bool = ...;</cell><cell>fun fopen(f: Int): Handle = ...;</cell></row><row><cell>export fun read(k: Key): Table = ...;</cell><cell>export fun write(k: Key, t: Table): Bool = ...;</cell></row><row><cell>)</cell><cell>export fun read(k: Key): Table = ...;</cell></row><row><cell></cell><cell>)</cell></row></table><note><p>core = ( import write: Key→Table→Bool; import read: Key→Table; fun log(msg: String): Unit = ...; export fun select(q: String): Table = ... read(...) ...; export fun update(q: String): Bool = ... write(...) ...; export fun main(p: String): Int = ...; ) xml = ( import update: String→Bool; fun parse(s: String): XML = ...; fun unparse(x: XML): String = ...; export fun storeXML(x: XML): Bool = ... update(...) ...; )</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Often called weakening; substructural type systems<ref type="bibr" target="#b58">[59]</ref> that violate this property (such as linear types) are uncommon in practice.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Requiring a single valid configuration is merely a consistency check. Asserting that a module provides specific configurations can be checked at composition-language level, see Section</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>3.4.   </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3"><p>In fact, the GNU C compiler creates symbols only for functions called after the optimizer removed unreachable code. We do not yet perform such optimizations; so, functions called only from unreachable code are part of the inferred interface. Adopting variability-aware constant folding and variability-aware static analysis in C to detect unreachable code in all configurations is an interesting avenue for future work.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_4"><p>Bug reports https://bugs.busybox.net/show _ bug.cgi?id=4994 and</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>http://lists.busybox.net/pipermail/busybox/ 2011-September/076576.html the same time, the function was still imported in modules mount and umount when the corresponding features MOUNT or UMOUNT were selected. In that revision, TypeChef reports that the composed module still conditionally imports function match_fstype; that is, the module is not closed in configurations with MOUNT ∨ UMOUNT.For other kinds of linker errors, such as conflicting types of imports, multiple function exports with the same name, and type mismatch between imports and exports, we have not found actual instances in Busybox. For testing purposes, we deliberately introduced and detected several of them. Overall, our experiments confirm that TypeChef finds type errors and linker errors in real-world product lines, which is especially helpful as rapid feedback during the development process, for instance as part of an automated build in a continuousintegration process.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>We measured performance on a normal lab computer (Intel quad-core 3.4 GHz with</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_7"><p>GB RAM; Linux; Java 1.6, OpenJDK). We did not perform low-level optimizations and still compute debug information and statistics. Measured times provide only rough indicators about what performance to expect and that variability-aware analysis is feasible; they are not meant as rigorous benchmarks.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. The work was inspired by Karl Klose's work on modular metaprogramming. We thank Tillmann Rendel, Sven Apel, Yannis Smarakdakis, Don Batory, Chungchieh Shan, Martin Erwig, and Paolo G. Giarrusso for their valuable discussions on early presentations of this work. This work is supported by ERC grant #203099.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Proofs</head><p>A.1 Properties of M Lemma 1. Let be a monotonic relation, (Γ 1 , ∆ 1 ) ∈ M, (Γ 2 , ∆ 2 ) ∈ M, (Γ 1 , ∆ 1 ) OK, (Γ 2 , ∆ 2 ) OK, and dom(∆</p><p>∆ 1 ∪ ∆ 2 if and only if ∀x ∈ dom(∆ 1 ∪ ∆ 2 ). Γ 1 ∪ Γ 2 ∪ sig(∆ 1 ) ∪ sig(∆ 2 ) e : t where (∆ 1 ∪ ∆ 2 )(x) = (e, t). Since dom(∆ 1 ) ∩ dom(∆ 2 ) = ∅, assume x ∈ dom(∆ 1 ) with ∆ 1 (x) = (e, t). Then, from (Γ 1 , ∆ 1 ) OK it follows that Γ 1 ∪ sig(∆ 1 ) e : t. Thus, by monotonicity, Γ 1 ∪ Γ 2 ∪ sig(∆ 1 ) ∪ sig(∆ 2 ) e : t. Analogous for x ∈ dom(∆ 2 ).</p><p>Theorem 1 (P4: Composition preserves typing in M). Given a monotonic relation , module composition of well-typed, compatible modules preserves typing, that is,</p><p>The first conjunct then follows from the equation dom(sig(∆)) = dom(∆) for all ∆. The second conjunct follows by Lemma 1.</p><p>Proof. By m 1 OK and m 2 OK, we deduce</p><p>and v 2 ⊆ ∆ 2 . v ⊆ dom(Γ ) and v ⊆ dom(∆ ) then follow from the definition of Γ and ∆ .</p><p>Theorem 2 (P4: Composition preserves typing in M v ). Given a monotonic relation , module composition of well-typed, compatible modules preserves typing, that is,</p><p>The first constraint follows from m 1 ÷ m 2 . The second and third constraint follow from Lemma 2. For the final constraint, note that (Γ (c),</p><p>. Thus, the final constraint follows from the type-preservation Theorem 1 of module system M. Lemma 3. For the computation of conflicts the following properties hold.</p><p>(i) conflictpresence and conflicttype are commutative</p><p>Proof. (i)-(vi) follow directly from the definition of conflictpresence, conflicttype, and conflict. (vii) follows from the definition of conflict and properties (i)-(vi).</p><p>Theorem 3 (P6': Composition preserves compatibility). The partial composition of compatible modules only yields compatible modules, that is,</p><p>x =y conflict(Γ x , ∆ x , Γ y , ∆ y ) , which is non-empty due to the assumption ÷ m 1 , m 2 , . . . , m n .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 4 (P5: Commutativity and associativity of module composition). Module composition is commutative</head><p>Proof. Commutativity is obvious from the definition of module composition. Associativity follows from Lemma 3 (ii), Lemma 3 (vii), and Theorem 3 by inlining the definition of module composition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3 Properties of M vl</head><p>Lemma 4. For varmodel and varmap, the following properties hold.</p><p>where</p><p>where</p><p>Proof. (i)-(iv) follow directly from the definition of varmodel and varmap. For (v), there are four cases in which</p><p>Similarly for the proof of (vi).</p><p>Theorem 5 (Composition preserves locality). Module composition of well-typed, compatible modules preserves the locality of configuration options, that is,</p><p>Proof. By Lemma 4, varmodel(v ) ⊆ varmodel(v 1 ) ∪ varmodel(v 2 ), varmap(v , Γ ) ⊆ varmap(v 1 , Γ 1 ) ∪ varmap(v 2 , Γ 2 ), and varmap(v , ∆ ) ⊆ varmap(v 1 , ∆ 1 ) ∪ varmap(v 2 , ∆ 2 ), which respectively are subsets of i ∪ j = (i 1 ∪ j 1 ) ∪ (i 2 ∪ j 2 ) by m 1 OK and m 2 OK.</p><p>Theorem 6 (P4: Composition preserves typing in M vl ). Given a monotonic relation , module composition of well-typed, compatible modules preserves typing, that is,</p><p>Proof. Follows directly from Theorem 2 and Theorem 5.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Comparing approaches to implement feature model composition</title>
		<author>
			<persName><forename type="first">M</forename><surname>Acher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Collet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lahire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>France</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. European Conf. Modelling Foundations and Applications (ECMFA)</title>
		<meeting>European Conf. Modelling Foundations and Applications (ECMFA)</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6138</biblScope>
			<biblScope unit="page" from="3" to="19" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Implementing product line variabilities</title>
		<author>
			<persName><forename type="first">M</forename><surname>Anastasopoules</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gacek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Symposium on Software Reusability (SSR)</title>
		<meeting>Symposium on Software Reusability (SSR)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="109" to="117" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Type safety for feature-oriented product lines</title>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kästner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Größlinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lengauer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Automated Software Engineering</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="251" to="300" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Research challenges in the tension between features and services</title>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kästner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lengauer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICSE Workshop on Systems Development in SOA Environments (SDSOA)</title>
		<meeting>ICSE Workshop on Systems Development in SOA Environments (SDSOA)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="53" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">An algebraic foundation for automatic feature-based program synthesis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lengauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Möller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kästner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming (SCP)</title>
		<imprint>
			<biblScope unit="volume">75</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1022" to="1047" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Handling preprocessor-conditioned declarations</title>
		<author>
			<persName><forename type="first">L</forename><surname>Aversano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Penta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">D</forename><surname>Baxter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Workshop Source Code Analysis and Manipulation (SCAM)</title>
		<meeting>Int&apos;l Workshop Source Code Analysis and Manipulation (SCAM)</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="83" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Software Architecture in Practice</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Clements</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kazman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Boston, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Scaling stepwise refinement</title>
		<author>
			<persName><forename type="first">D</forename><surname>Batory</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">N</forename><surname>Sarvela</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rauschmayer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Softw. Eng. (TSE)</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="355" to="371" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Automated analysis of feature models 20 years later: A literature review</title>
		<author>
			<persName><forename type="first">D</forename><surname>Benavides</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Seguraa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ruiz-Cortés</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Systems</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="615" to="636" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Classbox/J: Controlling the scope of change in Java</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bergel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ducasse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Nierstrasz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Object-Oriented Programming, Systems, Languages and Applications (OOPSLA)</title>
		<meeting>Int&apos;l Conf. Object-Oriented Programming, Systems, Languages and Applications (OOPSLA)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="177" to="189" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Variability modeling in the real: A perspective from the operating systems domain</title>
		<author>
			<persName><forename type="first">T</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>She</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lotufo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Czarnecki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Automated Software Engineering (ASE)</title>
		<meeting>Int&apos;l Conf. Automated Software Engineering (ASE)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="73" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Variability management with feature models</title>
		<author>
			<persName><forename type="first">D</forename><surname>Beuche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Papajewski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Schröder-Preikschat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sci. Comput. Program</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="333" to="352" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">M</forename><surname>Blume</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Appel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Hierarchical modularity. ACM Trans. Program. Lang. Syst. (TOPLAS)</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="813" to="847" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Intraprocedural dataflow analysis for software product lines</title>
		<author>
			<persName><forename type="first">C</forename><surname>Brabrand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ribeiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Tolêdo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Borba</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Aspect-Oriented Software Development (AOSD)</title>
		<meeting>Int&apos;l Conf. Aspect-Oriented Software Development (AOSD)</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Program fragments, linking, and modularization</title>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Symp. Principles of Programming Languages (POPL)</title>
		<meeting>Symp. Principles of Programming Languages (POPL)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="266" to="277" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Building a family of compilers</title>
		<author>
			<persName><forename type="first">W</forename><surname>Chae</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Blume</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Software Product Line Conference (SPLC)</title>
		<meeting>Int&apos;l Software Product Line Conference (SPLC)</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="307" to="316" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Extending type inference to variational programs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Erwig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Walkingshaw</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
		<respStmt>
			<orgName>School of EECS, Oregon State University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Symbolic model checking of software product lines</title>
		<author>
			<persName><forename type="first">A</forename><surname>Classen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Heymans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-Y</forename><surname>Schobbens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Legay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Software Engineering (ICSE)</title>
		<meeting>Int&apos;l Conf. Software Engineering (ICSE)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="321" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">K</forename><surname>Czarnecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Eisenecker</surname></persName>
		</author>
		<title level="m">Generative Programming: Methods, Tools, and Applications</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press/Addison-Wesley</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Verifying feature-based model templates against well-formedness OCL constraints</title>
		<author>
			<persName><forename type="first">K</forename><surname>Czarnecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pietroszek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Generative Programming and Component Engineering (GPCE)</title>
		<meeting>Int&apos;l Conf. Generative Programming and Component Engineering (GPCE)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="211" to="220" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Source tree composition</title>
		<author>
			<persName><forename type="first">M</forename><surname>De Jonge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Software Reuse (ICSR), volume 2319 of LNCS</title>
		<meeting>Int&apos;l Conf. Software Reuse (ICSR), volume 2319 of LNCS</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="261" to="282" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Fitting the pieces together: A machine-checked model of safe composition</title>
		<author>
			<persName><forename type="first">B</forename><surname>Delaware</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">R</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Batory</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Foundations of Software Engineering (ESEC/FSE)</title>
		<meeting>Foundations of Software Engineering (ESEC/FSE)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="243" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Variance and generalized constraints for C # generics</title>
		<author>
			<persName><forename type="first">B</forename><surname>Emir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kennedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Russo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Europ. Conf. Object-Oriented Programming</title>
		<meeting>Europ. Conf. Object-Oriented Programming</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4067</biblScope>
			<biblScope unit="page" from="279" to="303" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A virtual class calculus</title>
		<author>
			<persName><forename type="first">E</forename><surname>Ernst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ostermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Symp. Principles of Programming Languages (POPL)</title>
		<meeting>Symp. Principles of Programming Languages (POPL)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="270" to="282" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Predicate dispatching: A unified theory of dispatch</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ernst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kaplan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Chambers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Europ. Conf. Object-Oriented Programming (ECOOP)</title>
		<meeting>Europ. Conf. Object-Oriented Programming (ECOOP)</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="186" to="211" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The choice calculus: A representation for software variation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Erwig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Walkingshaw</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Softw. Eng. Methodol. (TOSEM)</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="6" to="7" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Variation programming with the choice calculus</title>
		<author>
			<persName><forename type="first">M</forename><surname>Erwig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Walkingshaw</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Generative and Transformational Techniques in Software Engineering</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Dependent classes</title>
		<author>
			<persName><forename type="first">V</forename><surname>Gasiunas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mezini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ostermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Object-Oriented Programming, Systems, Languages and Applications (OOPSLA)</title>
		<meeting>Int&apos;l Conf. Object-Oriented Programming, Systems, Languages and Applications (OOPSLA)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="133" to="152" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Implementing product-line features by composing aspects</title>
		<author>
			<persName><forename type="first">M</forename><surname>Griss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Software Product Line Conference (SPLC)</title>
		<meeting>Int&apos;l Software Product Line Conference (SPLC)</meeting>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="271" to="288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Expressive and safe static reflection with MorphJ</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Smaragdakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conf. Programming Language Design and Implementation (PLDI)</title>
		<meeting>Conf. Programming Language Design and Implementation (PLDI)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="79" to="89" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">cJ: Enhancing Java with safe type conditions</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Smaragdakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Aspect-Oriented Software Development (AOSD)</title>
		<meeting>Int&apos;l Conf. Aspect-Oriented Software Development (AOSD)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="185" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">The road to feature modularity?</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kästner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ostermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SPLC Workshop on Feature-Oriented Software Development (FOSD)</title>
		<meeting>SPLC Workshop on Feature-Oriented Software Development (FOSD)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Type checking annotation-based product lines</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kästner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Thüm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Saake</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Softw. Eng. Methodol. (TOSEM)</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="14" to="15" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Variability-aware parsing in the presence of lexical macros and conditional compilation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kästner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Giarrusso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rendel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Erdweg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ostermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Berger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Object-Oriented Programming, Systems, Languages and Applications (OOPSLA)</title>
		<meeting>Int&apos;l Conf. Object-Oriented Programming, Systems, Languages and Applications (OOPSLA)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="805" to="824" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">AOP: Does it make sense? The case of concurrency and failures</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kienzle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Guerraoui</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Europ. Conf. Object-Oriented Programming</title>
		<meeting>Europ. Conf. Object-Oriented Programming</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2374</biblScope>
			<biblScope unit="page" from="37" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Modular logic metaprogramming</title>
		<author>
			<persName><forename type="first">K</forename><surname>Klose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ostermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Object-Oriented Programming, Systems, Languages and Applications (OOPSLA)</title>
		<meeting>Int&apos;l Conf. Object-Oriented Programming, Systems, Languages and Applications (OOPSLA)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="484" to="503" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">New methods in software product line development</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Krueger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Software Product Line Conference (SPLC)</title>
		<meeting>Int&apos;l Software Product Line Conference (SPLC)</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="95" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Interfaces for modular feature verification</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">C</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Krishnamurthi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Fisler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Automated Software Engineering (ASE)</title>
		<meeting>Int&apos;l Conf. Automated Software Engineering (ASE)</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="195" to="204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">An analysis of the variability in forty preprocessor-based software product lines</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liebig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lengauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kästner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schulze</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Software Engineering (ICSE)</title>
		<meeting>Int&apos;l Conf. Software Engineering (ICSE)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="105" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Atkinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bloom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Moss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Schaffert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Scheifler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Snyder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">114</biblScope>
			<date type="published" when="1981">1981</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Berlin/Heidelberg</pubPlace>
		</imprint>
		<respStmt>
			<orgName>CLU Reference Manual</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Feature oriented refactoring of legacy applications</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Batory</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lengauer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Software Engineering (ICSE)</title>
		<meeting>Int&apos;l Conf. Software Engineering (ICSE)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="112" to="121" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">SAT-based analysis of feature models is easy</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mendonça</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Czarnecki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Software Product Line Conference (SPLC)</title>
		<meeting>Int&apos;l Software Product Line Conference (SPLC)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="231" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Expressive and modular predicate dispatch for Java</title>
		<author>
			<persName><forename type="first">T</forename><surname>Millstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Frost</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ryder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Warth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst. (TOPLAS)</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="7" to="8" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Relaxed MultiJava: Balancing extensibility and modular typechecking</title>
		<author>
			<persName><forename type="first">T</forename><surname>Millstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Reay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Chambers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Object-Oriented Programming, Systems, Languages and Applications (OOPSLA)</title>
		<meeting>Int&apos;l Conf. Object-Oriented Programming, Systems, Languages and Applications (OOPSLA)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="224" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Parameterized types for Java</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bank</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Symp. Principles of Programming Languages (POPL)</title>
		<meeting>Symp. Principles of Programming Languages (POPL)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="132" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Plastic partial components: A solution to support variability in architectural components</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pérez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Díaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Costa-Soria</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Garbajosa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. European Conf. Software Architecture (ECSA)</title>
		<meeting>European Conf. Software Architecture (ECSA)</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="221" to="230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Feature-oriented programming: A fresh look at objects</title>
		<author>
			<persName><forename type="first">C</forename><surname>Prehofer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Europ. Conf. Object-Oriented Programming</title>
		<meeting>Europ. Conf. Object-Oriented Programming</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="419" to="443" />
		</imprint>
	</monogr>
	<note>volume 1241 of LNCS</note>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Module interconnection languages</title>
		<author>
			<persName><forename type="first">R</forename><surname>Prieto-Diaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Neighbors</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Systems and Software</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="307" to="334" />
			<date type="published" when="1986-11">November 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Using symbolic evaluation to understand behavior in configurable software systems</title>
		<author>
			<persName><forename type="first">E</forename><surname>Reisner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-K</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Porter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Software Engineering (ICSE)</title>
		<meeting>Int&apos;l Conf. Software Engineering (ICSE)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="445" to="454" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Automating the configuration of multi software product lines</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rosenmüller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Siegmund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Workshop on Variability Modelling of Software-intensive Systems (VaMoS)</title>
		<meeting>Int&apos;l Workshop on Variability Modelling of Software-intensive Systems (VaMoS)</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="123" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Compositional typechecking for delta-oriented programming</title>
		<author>
			<persName><forename type="first">I</forename><surname>Schaefer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bettini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Damiani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Aspect-Oriented Software Development (AOSD)</title>
		<meeting>Int&apos;l Conf. Aspect-Oriented Software Development (AOSD)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="43" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">#ifdef considered harmful or portability experience with C news</title>
		<author>
			<persName><forename type="first">H</forename><surname>Spencer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Collyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Conf</title>
		<meeting>USENIX Conf</meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="185" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">N degrees of separation: Multi-dimensional separation of concerns</title>
		<author>
			<persName><forename type="first">P</forename><surname>Tarr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ossher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Sutton</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Software Engineering (ICSE)</title>
		<meeting>Int&apos;l Conf. Software Engineering (ICSE)</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="107" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Feature consistency in compile-time-configurable system software: Facing the Linux 10,000 feature problem</title>
		<author>
			<persName><forename type="first">R</forename><surname>Tartler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lohmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sincero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Schröder-Preikschat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. European Conference on Computer Systems (EuroSys)</title>
		<meeting>European Conference on Computer Systems (EuroSys)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="47" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Safe composition of product lines</title>
		<author>
			<persName><forename type="first">S</forename><surname>Thaker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Batory</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kitchin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Generative Programming and Component Engineering (GPCE)</title>
		<meeting>Int&apos;l Conf. Generative Programming and Component Engineering (GPCE)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="95" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<title level="m" type="main">Analysis strategies for software product lines</title>
		<author>
			<persName><forename type="first">T</forename><surname>Thüm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kästner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kuhlemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Schaefer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Saake</surname></persName>
		</author>
		<idno>FIN-004-2012</idno>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
		<respStmt>
			<orgName>School of Computer Science, University of Magdeburg</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Variability and component composition</title>
		<author>
			<persName><forename type="first">T</forename><surname>Van Der Storm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Software Reuse (ICSR)</title>
		<meeting>Int&apos;l Conf. Software Reuse (ICSR)</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3107</biblScope>
			<biblScope unit="page" from="157" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Building product populations with software components</title>
		<author>
			<persName><forename type="first">R</forename><surname>Van Ommering</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Software Engineering (ICSE)</title>
		<meeting>Int&apos;l Conf. Software Engineering (ICSE)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="255" to="265" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<monogr>
		<title level="m" type="main">Advanced Topics in Types and Programming Languages</title>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
		<editor>B. C. Pierce</editor>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>MIT Press</publisher>
			<biblScope unit="page" from="3" to="43" />
		</imprint>
	</monogr>
	<note>Substructural type systems</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
