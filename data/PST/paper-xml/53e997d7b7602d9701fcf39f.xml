<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">E1DA4334DF867180E53312612B8B3CBC</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Reusing Software: Issues and Research Directions Hafedh Mili, Fatma <ref type="bibr">Mili, and</ref>  <ref type="bibr">Ali Mili</ref> Abstruct-Software productivity has been steadily increasing over the past 30 years, but not enough to close the gap between the demands placed on the software industry and what the state of the practice can deliver <ref type="bibr" target="#b15">[22]</ref>, <ref type="bibr" target="#b32">[39]</ref>; nothing short of an order of magnitude increase in productivity will extricate the software industry from its perennial crisis <ref type="bibr" target="#b32">[39]</ref>, <ref type="bibr" target="#b61">[67]</ref>. Several decades of intensive research in software engineering and artificial intelligence left few alternatives but software reuse as the (only) realistic approach to bring about the gains of productivity and quality that the software industry needs. In this paper, we discuss the impli- cations of reuse on the production, with an emphasis on the technical challenges. Software reuse involves building software that is reusable by design and building with reusable software. Software reuse includes reusing both the products of previous software projects and the processes deployed to produce them, leading to a wide spectrum of reuse approaches, from the building blocks (reusing products) approach, on one hand, to the generative or reusable processor (reusing processes), on the other [as]. We discuss the implication of such approaches on the organization, control, and method of software development and discuss proposed models for their economic analysis.</p><p>Software reuse benefits from methodologies and tools to:</p><p>1) build more readily reusable software and 2) locate, evaluate, and tailor reusable software, the last being critical for the building blocks approach. Both sets of issues are discussed in this paper, with a focus on application generators and 00 development for the first and a thorough discussion of retrieval techniques for software components, component composition (or bottom-up design), and transformational systems for the second. We conclude by highlighting areas that, in our opinion, are worthy of further investigation. Index Term-Software reuse, managerial aspects of software reuse, software reuse measurements, building reusable components, 00 software development, software component retrieval, adapting reusable components.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>ESPITE several decades of intensive research, the routine D production of software under acceptable conditions of quality and productivity remains an unfulfilled promise. While a great deal of progress has been achieved in understanding the mechanics of constructing a program fiom a specification, little progress has been achieved in improving the practice of software development accordingly. This predicament stems, in our opinion, fiom two premises: 0 First, a problem of scale: most of our current knowledge in program construction deals with minute details about semantics of programming languages and correctness formulas; while this knowledge is enlightening and instructive, it is rather inadequate to deal with the current pressures on the software industry (in terms of productivity and quality). 0 Second, a problem of emphasis: the problem of scale could in principle be tackled with automated tools if it were not for the fact that the most crucial decisions that must be taken in a program construction process, such as the choice of algorithms, control structures, and data structures, are also the most difficult to formali-hence to automate.</p><p>As a result, a wide gap exists nowadays between the demands placed on the software industry (by a society that is increasingly dependent on software and increasingly intolerant of software failure) and what the state of the practice in the industry can deliver; also the brief history of the field abounds with instances of failure [ 191, <ref type="bibr" target="#b31">[38]</ref>, <ref type="bibr" target="#b61">[67]</ref>.</p><p>Software reuse offers a great deal of potential in terms of software productivity and software quality, because it tackles the above issues adequately: By dealing with software products at the component level and by focusing on arbitrarily abstract descriptions of software components, it addresses the question of scale; on the other hand, by dealing with software design at the architectural level, rather than the coding level, it addresses the question of emphasis. However, several factors hinder reuse, including the infancy of software development as a scientific <ref type="bibr" target="#b37">[44]</ref> or engineering discipline [ 1441, inadequate training in software development in general and software reuse in particular [ 1591, inadequate management structures and practices <ref type="bibr" target="#b53">[59]</ref>, and the lack of methodologies and tools to support software reuse or software development in general <ref type="bibr" target="#b40">[47]</ref>.</p><p>In this paper, we discuss the most important of these issues and focus on the methodological and technical aspects.</p><p>It is customary to categorize software reuse work based on what is being reused (the object ofreuse) or on the method of reuse (see, e.g., <ref type="bibr" target="#b78">[83]</ref> and <ref type="bibr" target="#b62">[68]</ref>), the two being closely related. It is customary to distinguish between two general categories of reuse approaches, the building blocks approach, which is based on reusing software development products, and the generative or reusable processor approach, which is based on reusing the process of previous software development efforts, often embodied in computer tools (processor) that automate part of the development life cycle <ref type="bibr" target="#b62">[68]</ref>; these are but two extreme approaches on a continuum involving different mixes of product and process reuse [148]. We refer to both products and processes as reusable assets. Reuse approaches raise a number of issues that may be divided into issues related to developing reusable assets and issues related to developing with reusable assets. Under the former set of issues, we focus on 0098-5589/95504.00 Q 1995 IEEE 00 software development, as an enabling technology for developing reusable building blocks, and application generators as an example of a commercially successful application of the generative approach. Developing with reusable assets raises issues related to providing methodological and computer support for:</p><p>1) locating reusable assets, 2) assessing their relevance to the current needs and 3) adapting them to those needs. Such issues are anywhere from secondary to irrelevant to the reusable processor end of the spectrum, but are central to the building blocks end of the spectrum. Under adaptation, we discuss a number of techniques for automating the integration and maintenance of reusable components, with an emphasis on techniques other than those offered by object orientation, which are discussed separately, along with other 00 principles.</p><p>In the next section, we attempt to motivate and define so% ware reuse, and provide a typology of software reuse research, to be used throughout the paper. In Section 111, we discuss the overall impact of software reuse on the production of software, starting with the organizational and methodological impact of reuse on the development of software, and then discuss costhenefit models of software reuse. Sections IV and V focus on the technical challenges and research solutions involved in building reusable software assets and building with reusable software assets, respectively. We conclude in Section VI by outlining areas and issues that, in our view, deserve further attention in the research community.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. A FRAIvEWORK FOR SOFTWARE REUSE</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Motivations</head><p>Software productivity has been steadily rising for the past 30 years <ref type="bibr" target="#b129">[160]</ref>. However, even with the steady rise in the number of computer professionals <ref type="bibr" target="#b15">[22]</ref>, it has not kept up with the rising demand for developing new ever more complex software systems and for maintaining existing software <ref type="bibr" target="#b15">[22]</ref>, [ 1031. While current software production management practices leave room for improvement [ 151, nothing short of an order of magnitude increase in programmer productivity will extricate the software industry from the current crisis <ref type="bibr" target="#b61">[67]</ref>. According to Boehm, the only factor that can yield that kind of productivity leverage is the number of software source instructions that have to be developed to deliver a given functionality <ref type="bibr" target="#b15">[22]</ref>: Instead of searching for ways of writing code faster, we have to look for ways of writing less of it. Automatic programming, whereby a computer system is capable of producing executable code based on informal, incomplete, and incoherent user requirements, is decades away, if ever possible [ 1361. That leaves us with software reuse as the only realistic, technically feasible solution: We could reuse the processes and products of previous development efforts in order to develop new applications.</p><p>Intuitively, savings occur with software product reuse because reused components do not have to be built from scratch.</p><p>Further, overall product quality improves if quality components are reused. With software process reuse, productivity increases to the extent that the reused processes are automated, and quality improves to the extent that quality-enhancing processes are systematized. Further, there is plenty of duplication in the applications being developed and maintained nowadays, and hence plenty of room for reuse. In 1984, for example, the U.S. software market offered some 500 accounting programs, 300 payroll programs, 150 communication programs, 125 word-processing packages, etc. <ref type="bibr" target="#b72">[77]</ref>; the figures are probably higher today, In the early eighties, Lanergan and Grass0 estimated that 60% of business applications can be standardized and reused [MI. Generally, potential (estimated) and actual reuse rates range from 15% to 85% (see, e.g., <ref type="bibr" target="#b53">[59]</ref>, <ref type="bibr" target="#b98">[103]</ref>). Existing experience reports suggest that indeed goodsometimes impressive-reuse rates, productivity and quality increases can .be achieved (see, e.g., <ref type="bibr">[12]</ref>, [13], <ref type="bibr" target="#b67">[73]</ref>, <ref type="bibr">[loo]</ref>). However, successes have not been systematic (see, e.g., <ref type="bibr">[59, [133]</ref>), and a lot of work remains to be done both in terms of "institutionalizing" reuse practice in organizations and in terms of addressing the myriad of technical challenges that make reuse difficult <ref type="bibr" target="#b78">[83]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. The Object of Reuse</head><p>The idea of formal software reuse, as first introduced by</p><p>McIlroy in his 1968 seminal paper <ref type="bibr" target="#b99">[104]</ref>, entailed the development of an industry of reusable source-code software components and the industrialization of the production of application software from off-the-shelf components. Software reuse is now understood to encompass all the resources used and produced during the development of software (see, e.g., <ref type="bibr" target="#b36">[43]</ref>, <ref type="bibr" target="#b43">[50]</ref>, <ref type="bibr">[ 1331)</ref>. Different researchers proposed different categorizations of reusable knowledge, but by and large, most classifications rely on one of three factors or a combination thereof: 1)stage of development at which the knowledge is pro-2) level of abstraction (e.g., abstract versus con-3) nature of knowledge (e.g., artifacts versus skills).</p><p>Jones identified four types of reusable artifacts <ref type="bibr" target="#b72">[77]</ref>: 1) data reuse, involving a standardization of data formats, 2) architectures reuse, which consists of standardizing a set of design and programming conventions dealing with the logical organization of software, 3) (detailed) design reuse, for some common business applications and 4) program reuse, which deals with reusing executable code. In addition to productlartifact reuse, Horowitz considered various kinds of reuse based on the utilization of very high-level program-producing systems <ref type="bibr" target="#b62">[68]</ref>.</p><p>Three general classes of systems that have been commonly recognized by researchers are:</p><p>1) reusable program pattems [ 191, <ref type="bibr" target="#b62">[68]</ref>, whereby code or design pattems are used to instantiate specific code frag- Technology transfer Utilization knowlknowledge: consists of edge: describes the knowledge about such business context in things as the organiza-which the software tional impact of softwareproduct will be used. technology, personnel training, computer literacy, and so forth.</p><formula xml:id="formula_0">ments</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>External</head><p>It is the environmental level of software development knowledge that is explicitly lacking from similar life cyclebased categorizations of reusable information. In his 1987 paper, Freeman identified the reuse of environmental knowledge as one of the long-term research goals in software reuse <ref type="bibr" target="#b43">[50]</ref>. We know of no research effort that has attempted or is attempting to formalize the reuse of such knowledge since. One area that has been getting considerable attention recently, however, is the reuse of application domain knowledge under the form of domain models (see, e.g., <ref type="bibr">[5]</ref>, <ref type="bibr">[501, [911, 11321, 11481)</ref>. Domain models serve three major purposes: 1) helping developers understand an application domain, 2) serving as the starting point for systems analysis (e.g., by specializing the domain model) and 3) providing an application-dependent categorization/ classification of existing reusable components (of later development stages) so that opportunities for reuse can be identified as early in the development process as possible [5], <ref type="bibr">[130]</ref>, <ref type="bibr">[132]</ref>.</p><p>Domain models should identify: common to the application domain, the entities and operations on those entities that are 0 relationships and constraints between the entities and "retrieval cues," i.e., properties of objects that are likely to be used by developers in the process of searching for reusable components [5], [ 1321.</p><p>We know of few research efforts that include declarative domain models that support all three functions described above (see, e.g., <ref type="bibr">[5]</ref>, <ref type="bibr" target="#b86">[91]</ref>). Neighbors's DRACO system <ref type="bibr" target="#b116">[121]</ref> and Simos's work on ASLs <ref type="bibr">[148]</ref> achieve much of the same goals by developing domain-dependent specification languages that embody an application domain's common objects and operations In the next section, we propose our own ontological categorization of reusable knowledge. Our categorization is geared toward highlighting the paradigmatic differences between the various reuse methods and abstracting what we consider to be inessential differences between various reusable assets (e.g.. code reuse versus design reuse).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. The Method of Reuse</head><p>We adopt the transformational systems' view of software development as a sequence of transformations and/or translations of the description of the desired system from one language (level i description) to another (level i + 1 description) as shown in Fig. <ref type="figure">1</ref>. Three levels of knowledge are used in this translation:</p><p>1) knowledge about the source domain (level 9,</p><p>2) knowledge about the target domain (level i + l), and 3) knowledge about how objects (entities, relations, structures) from the source domain map to objects in the tar- get domain.</p><p>For a given level, the knowledge can be seen in linguistic terms, as consisting of a domain language, and a set of expressions known to be valid. The domain language consists of bevelopment knowl-Application-area edge: deals with the planning and management of software projects such as cost and schedule estimation, test plans, benchmarking, and others.</p><p>kn owledge: deals with the underlying models for the application domain.</p><p>domain entities (or classes) and domain structures. The description of the various entities and structures can be based on an enumeration of legal entities and structures, or based on a set of properties that must be satisfied by either (e.g., consistency checks, composition rules), or a mix of the two. We refer to the description methods as enumerated and compositional, respectively. The descriptions of past problem instances constitute the expressions that are known to be valid.</p><p>The mapping knowledge consists of a set of transformation rules, from level i to level i + 1, and a set of known mappings between problem instances of level i and problem instances of level i + 1. The transformation rules' embody what is usually referred to as process reuse or skill reuse (see, e.g., <ref type="bibr">[133]</ref>). We shall refer to them as the transformation grammar. Note that this formalism does not distinguish between declarative knowledge and procedural knowledge as we feel the distinction to be mainly a representation issue. Typically, development consists of, first, describing (specifying) the problem at hand in the language of level i to obtain a description PDi and, second, transforming that description into one at level i + l (PD,+,), supposed to be the target description language (e.g., executable code). With reuse, one would want to avoid having to manually: 1) specify completely the problem at hand andor 2)transform the entire specification of level i into Thus, reusable assets include all the kinds of knowledge involved in the development transformation (DT,,i+l), which can be thought of as the result of applying a generic levelindependent problem-solving method on the relevant knowledge sources. The various reuse approaches can be categorized based on: 1) the extent to which the language of level i covers the problem domain of level i and 2) the extent to which the mapping knowledge (Ti,i+l) covers all the entities and structures (i.e., all the valid expressions) of the domain of level i.</p><p>level i + 1.</p><p>1. These rules do not only ensure syntactic correctness of the result description of level i + l, but also the preservation of some properties and the satisfaction of some "development constraints."</p><p>Finer characterizations may be based on the kind of language description used, along the enumerated versus compositional dimension. Table <ref type="table">I1</ref> shows the characteristics of some of the approaches commonly referred to in the literature. As we go down the rows of Table <ref type="table">11</ref>, we move from what is generally referred to as the building blocks approach to increasingly automated generative approaches. Automation requires the complete "cover" of the source domain language (level i) and the completeness of the mapping knowledge i + i + 1. In other words, automation is possible if we can express all new problems in terms of problems, or combinations of problems, that have already been solved. We comment below on the various approaches separately. With source code components, a new problem is solved by composing solutions to subproblems. A complete cover of level i domain would mean that all the components that one may need have been developed, or, more astutely-but equally unrealistic-a set of components has been developed such that every problem can be reduced to subproblems that these components can solve. Notwithstanding the issue of finding such a decompositionheduction, which can be as challenging as solving the original problem analytically from scratch (see SectionV.B), the number of required components is most probably prohibitive <ref type="bibr" target="#b78">[83]</ref>. That number depends on:</p><p>1) the breadth of the application domain and 2) the composition technique used.</p><p>With source code components, composition often takes place "too late" in the software life cycle: limiting the range of behaviors that can be obtained from a set of components to variations on functional composition, as supported by traditional module interconnection languages (see, e.g., [ 1291) or programming languages. Source code components approaches that support composition of components at a higher level of abstraction yield a greater range of behaviors (see, e.g., <ref type="bibr" target="#b73">[78]</ref>, <ref type="bibr">[149]</ref>). Software schemas are similar to source code components, except that the reusable artifacts are defined at a higher level of abstraction, allowing for a greater range of instantiations (through partial generation) and compositions. Further, the added parameterization makes it possible to build complex, yet generally useh1 structures (see, e.g., <ref type="bibr">[16]</ref>). However, the artifacts are still not meant to cover all the needs of the application domain, and finding and expressing the right compositions are still challenging design problems.</p><p>With the remaining three approaches, the source domain language covers the application domain. Transformational systems fall short of automation because the mapping knowledge is incomplete or non-deterministic: A transformational system needs developer assistance in selecting among applic a b l e a n d perhaps objectively equivalent-transformations [ 1231. The transformational approach can be used in conjunction with source code components to assist in the modification and integration of such components in new applications <ref type="bibr" target="#b108">[113]</ref>. Full   <ref type="bibr" target="#b20">[27]</ref>, REBOOT <ref type="bibr" target="#b111">[116]</ref>, and a number of other "nameless" tools and approaches (e.g. <ref type="bibr" target="#b80">[85]</ref>,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>responding to all the possible combinations of choices of</head><p>[131], <ref type="bibr" target="#b130">[161]</ref>). Object-orientation, seen as a development methodology for reusable components, is discussed in 8IV.C. Problems related to the use of such components are discussed in various subsections §V. The programmer's apprentice [137], the PARIS system [SO], and Basset'sJiame-based sofware engineering, in which an application could be completely specified and generated using 6ames [16]. Software schemas are briefly discussed in the context of 00 technology 9IV.C).</p><p>wide spectrum widespectrum</p><formula xml:id="formula_1">_ _ _ _ _ _ _ _ ~ ~</formula><p>A somewhat outdated survey of transformational systems is given in <ref type="bibr" target="#b118">[123]</ref>; their potential for quality-preserving maintenance and reuse has been recognized by a number of researchers, including Feather <ref type="bibr" target="#b38">[45]</ref> ing software "Solutions") parameterized directly with usw re-</p><p>The next section deals with the non-technical effects of software 1) its effects on the organizational structure of software produc-2)measuring reuse effectiveness, both in technical and eco-3) some reported case studies.</p><p>reuse on the production of s o h , including, ing organizations and on the software life cycle, nomic terms and Section IV deals with issues related to building reusable knowledge, with a focus on source code components and application generators. Section V deals with issues related to building new applications with reusable knowledge. Such issues are, for the most part, trivial or irrelevant to the application generators and very high-level languages approaches. The discussion will thus be geared toward the building blocks end of the spechum, and we address issues related to component retrieval, composition, and adaptation. Transformational systems will be discussed to the extent that they help adapt reusable components in a time-saving, qualitypreserving way.</p><p>3. No application generator available today can build a corporate information system. However, big chunks of such systems (e.g., report generators) can be generated using application generators <ref type="bibr" target="#b27">[34]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="111.">SOFTWARE REUSE AND THE</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PRODUCTION OF SOFTWARE</head><p>Software reuse provides some feasible remedies to the current software crisis, but many questioned the suitability of existing management practices, organizational structures, and technologies to support software reuse. There is a general agreement that a rethinking of software manufacturing is needed. There is also agreement that the required changes are managerial, cultural, and technical in nature, as was the case for other engineering disciplines [l5], <ref type="bibr" target="#b32">[39]</ref>, [144]. There is no consensus, however, as to the nature and scope of changes, both because the changes involve some yet to be proven management techniques and structures and because the proposed technological answers are different. In this section, we first discuss the effect of software reuse on the organization of software development processes (Section IILA); these changes depend on the reuse paradigm used, along the building blocks versus generative spectrum. Next (Section III.B), we discuss ways to measure software reuse and its impact on productivity and quality. We conclude in Section 1II.C by discussing the relation between the qualitative effects and measurable effects of software reuse and the challenges that stand in the way of comparing the effectiveness of the various reuse approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Software Reuse and Software Engineering</head><p>It is fair to say that technological innovations in software development contributed to enhancing software reusability, starting with high-level programming languages, up to structured and modular programming, up to design and analysis notations and methodologies. The same cannot be said about the organization and management of software organizations, which are at best reuse-neutral when they do not hinder reuse practice. We organize our discussion of the changes required and implied by reuse practice into, 1) new organizational structures (e.g., staffing structure), 2) new process models (life cycles) and 3) punctual methodological changes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. 1. New Organizational Structures</head><p>Software reuse relies on the availability of a base of reusable software in all forms (Section IV). Wegner argues that software companies should treat software as capital goods and their organization, including team structures and cost imputations, should reflect that [ 1551. This is true whether we are dealing with the building blocks approach or with the generative approach: in both cases we have to divert resources, both human and financial, into building a common base of reusable software assets to be amortized over several uses, be they application generators or source code components. It is widely accepted that, in addition to the typical project team structure of software organizations, a team responsible for building and maintaining a base of reuse capital is needed. Different authors proposed different divisions of labor between project teams and "reuse capital" teams. Within the building blocks approach, the component library team would, minimally, be responsible for packaging (e.g., documenting) and controlling 1) a pure producer-consumer relationship between the library team and project teams, where the library team is solely responsible for producing reusable components, and 2) a shared arrangement where project teams contribute to and consume what is in the library.</p><p>Caldieri and Basili <ref type="bibr" target="#b21">[28]</ref> proposed a more software factory-like approach [40]. In their model, project teams do no programming (see Fig. <ref type="figure">2</ref>). They are responsible for requirements and design specifications-which they submit to the experience factory-and for integration and integration testing <ref type="bibr" target="#b21">[28]</ref>. The experience factory's activities can be divided into: 1) Synchronous activities, which are activities initiated following requests from project teams, and can range from a simple look-up to building the required components from scratch. Such activities are subjected to project teams' schedules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2) Asynchronous activities, consisting of creating compo-</head><p>nents that are likely to be requested (anticipating future demands), or reengineering components generated by the synchronous activities to enhance their reusability.</p><p>In [12], Basili et al. report on experiences at the Software Engineering Laboratory (SEL), funded and operated by the University of Maryland, NASA, and the Computer Sciences Corp., in which the above structure has evolved over the years.</p><p>The experience factory was responsible mainly for process (vs. product) development and reuse [12], [13]. Over a period of five years, reuse rates increased from 26% to 96%, the cost per delivered statement decreased by 58%, a 138% increase in productivityQ -a n d the number of errors decreased by a factor of four [12]. It is not clear how a pure producer-consumer relationship between the experience factory and the project teams would have worked. With the building blocks approach, there are a number of motivational and managerial challenges to putting into place such a structure, including putting the 4. The experiments reported in [12] used a project implemented in Fortran as a baseline for errors and cost. Subsequent projects were implemented in Ada The numbers mentioned here used the first year data with Ada projects as a baseline, instead of the Fortran project. When the Fortran project is used as a baseline, we obtain smaller decrease of cost of delivered statement (35% instead of 58%), but a greater decrease in error rates (a factor of eight, instead of a factor of four), which is to be expected. most qualified developersS in the least satisfying tasks (experience factory) [28] and redistributing responsibility and control of individual projects in a way that may diffuse accountability. Such a division of labor is less problematic with the application generators approach where the skills required from application developers are markedly different from those required of application generator developers: The former have to be versed in the application domain, possibly end users, while the latter have to be both domain experts and software development experts <ref type="bibr" target="#b84">[89]</ref>. Less revolutionary divisions of labor exist in more traditional organizations where the job of system administrators and support staff often evolves into building and supporting custom-tailored development toolsembodying reusable processes-or at Japanese software factories, based essentially on a tighter management and measurement of software activities and products (see, e.g., [99], [ 1001).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2. New Process Models</head><p>A software life cycle is a model for organizing, planning, and controlling the activities associated with software development and maintenance [124]. For the most part, a life cycle identifies development tasks and identifies and standardizes intermediary work products (deliverables) and review and evaluation criteria. The known life cycles may be classified based on the kind of development tasks and work products involved, and the organization of such tasks. For example, the waterfall life cycle, the spiral model <ref type="bibr" target="#b14">[21]</ref>, and to some extent prototyping, all involve some measure of analysis, design, coding, and testing. However, while the waterfall life cycle implies that an entire system is analyzed before any part of it is designed or implemented, both the spiral model and prototyping prescribe the analysis ++ testing cycle on system increments [ 13. Newer development paradigms usually shorten the analysis t+ testing cycle by automating one or more steps along the cycle [2]. When we talk about software reuse, there are two life cycles to consider 1) the life cycle for developing reusable assets and 2) the life cycle for developing with reusable assets.</p><p>Issues to consider include whether the two life cycles are different and whether the availability of a base of reusable assets modifies the underlying life cycle. This depends on both the reuse approach used-along the building blocks ++ generative dimension-and on the development methodology used.</p><p>With the building blocks approach, both the reusable assets and the products developed with them are software components. Reusable components may be developed either concurrently or separately from specific product development, corresponding closely to the synchronous and asynchronous activities, respectively, of the experience factory in Caldieri and Basili's model (see above). When they are developed concurrently, they follow the same life cycle as non reusable components, except that greater care may go into building and pack-5. In the SEL at the Univ. of Maryland, the experience factory was mainly staffed by researchers [12]. However, they spent their time mainly collecting and analyzing data and proposing process enhancements, rather than developing variants of sort algorithms or stack structures! aging them. When a separate activity is set aside for developing them, we talk about domain analysis and domain engineering. One of the major inputs of domain analysis is a set of al- ready developed systems within the domain, whose common features are identified, abstracted, implemented, and then packaged [ 1321. The identification and abstraction of common features can take place at the earliest development stage for which there is adequate documentation. For example, if good quality analysis documents for the existing systems are available, the common features can be recognized at the analysis level. If not, one needs to look at existing designs or even code fiagments, perform some measure of reverse-engineering to recover requirements of individual systemskomponents, identify common features, abstract them, and forward-engineer them Building new applications with reusable components need not follow a radically different life cycle fiom building new applications without reusable components (see, e.g., [6], <ref type="bibr" target="#b20">[27]</ref>, <ref type="bibr" target="#b70">[76]</ref>, [131]). One of the criticisms leveled at the waterfall life cycle is that each life cycle stage is mainly influenced by the previous stages (top-down), while the existence of reusable components requires some sort of a look-ahead procedure to identify opportunities for reuse and take advantage of them [66], [148]. We believe this to be mainly a documentation issue: Reuse has traditionally meant reuse of small code fragments that have little or no life cycle documentation; if analysis information were stored in components libraries, for example, analysts could identify opportunities for reuse at the analysis level without looking at the actual code of reusable components. The point has been made, though, that 00 software development, the reuse methodology par excellence, requires a mix of top-down and bottom-up approaches6 [66]. This is explained by the premise that an 00 development life cycle needs to combine application and domain engineering in order to attain reuse objectives <ref type="bibr" target="#b60">[66]</ref>. The application engineering part of the life cycle proceeds in a top-down fashion from requirements gathering to high-level system design. Domain engineering consists of building "clusters" (libraries or layers [107]) of classes, starting with the lowest level (building blocks) which would most likely be needed no matter what the final system design is like, and moving up to applicationspecific classes, looping back on system design or even analysis The situation is markedly different with the generative approach. Application generators, which experienced some commercial success, have been studied in the literature (see, e.g., [89], <ref type="bibr" target="#b93">[98]</ref>). However, by and large, the process of build-6. The terms top-down and bottom-up are used in software. engineering to mean two things. They may refer to the direction used to go through the stages of a life cycle. For the waterfall life cycle, top-down means going ftom requirements to testinghtegration. The terms are also used to refer to construction paradigms, the analytical (top-down) versus synthetic (bottom-up). Things get confused because synthesizing systems from components suggests that detailed design is done before system design, e.g., and the two meanings overlap.</p><p>ing "reusable processors" has not earned a lot of attention, perhaps because most of the executable specification languages are research prototypes. A notable exception is Simos's work on application-specific specification languages (ASL), and what he calls domain life cycle <ref type="bibr">[148]</ref>. He sees ASLs as the culmination of the maturation of an application domain, or of an organization's expertise in that domain. The maturation starts with small reusable code components and moves toward more abstract representations and more complex constructs until an entire application domain is "covered" (Section 1I.C) [ 1481. The effect of using the generative approach for software development is much easier to assess: The generative approach shortens traditional life cycles through automation (see, e.g., <ref type="bibr" target="#b93">[98]</ref>). Application generators, for example, obviate the need for specifying the software requirements, designing, coding, and testing, of big chunks of applications <ref type="bibr" target="#b84">[89]</ref>. Executable specification languages and transformational systems obviate the need for designing, coding, and testing, but developers still need to produce precise formal specifications of the desired system [ 11.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3. Eflects on Development Method</head><p>Software development can be considered as a problemsolving activity, the problem being that of finding a software implementation that satisfies a set of user requirements. Cognitive scientists and AI theorists alike consider recall as an essential part of human problem-solving (see, e.g., [88], [141]). Broadly speaking, when faced with a problem, we first perform a "rote recall" to see if we haven't solved the problem before [MI. When that fails, we start looking for analogical (similar) problems that we might have already solved and adapt their solution to the problem at hand <ref type="bibr" target="#b22">[29]</ref>. When that fails, we fall back on general analytic problem-solving knowledge and skills [ 881. Traditional development methodologies (e.g., SNSD [124]) are analytical in nature and fall back immediately on general problem-solving knowledge and heuristics such as divide and conquer and successive refinements. Researchers recognize that "informal reuse" (i.e., in developer's head) has always been taking place, whereby the base of reusable knowledge is "acquired" individually by developers through experience (see, e.g., [ll]). To some extent, "formal" software reuse in general and the building blocks approach in particular recognize the earlier recall-based phases of problem-solving and aim at formalizing them and providing computer support for them.</p><p>Challenges to supporting reuse within development methodologies include:</p><p>1) identifying reuse tasks and the skills required to perform 2) providing methodological and tool support for these tasks</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3) integrating reuse activities into the normal workflow of</head><p>The reuse tasks depend heavily on the reuse approach used along the building blocks vs. generative axis. With the generative approach, the reuse tasks consist of specifying the desired application in a high-level language (executable specification those tasks (see, e.g., language, 4GL, etc.), and the required cognitive skills need not be different fiom those required of traditional development methods. With the building blocks approach, developers try to build a system that satisfies a set of requirements by using as many existing components (or developing as little code) as possible. For any part of the target system, developers must 1) formulate the requirements of the part in a way that sup- ports retrieval of potentially useful reusable components, 2) understand the retrieved components and 3) if the retrieved components are sufficiently %10Se" to the needs at hand and are of sufficient quality, then adapt them.</p><p>If no component is found that matches perfectly or closely the given requirements, developers may fall back on generalpurpose analytical heuristics to decompose the system (or part thereof) into smaller parts for which steps 1 to 3 may be reiterated [ 1 3 51.</p><p>The search and retrieval problem benefits fiom a large body of work in the area of document retrieval and will be discussed in more detail in Section V.A. For the time being, we note that in the context of reuse, we need more than an algorithm that tries to match a requirement to a single component; we need a retrieval system that is capable of synthesizing a set of building blocks into a single component that satisfies the developer's requirement. This is what is commonly referred to as bottom-up development. This is perhaps the most challenging problem in the building blocks approach, and where computer assistance is much needed. Yet, there have been few concrete proposals (see, e.g., [62], <ref type="bibr" target="#b74">[79]</ref>). Component synthesis and aggregation is discussed in more detail in Section V.B. Component/program understanding represents an important part of both the mental effort and the cost factor, in reuse [47], <ref type="bibr" target="#b90">[95]</ref> and m a i n t e n ~c e ~ <ref type="bibr" target="#b98">[103]</ref>. Component understanding can mean three things:</p><p>1) understanding what it does, 2) understanding how it does it and 3) understanding how to modify it in such a way that it does In a r e u s e a n d maintenancwontext, some abstract (implementation independent) component documentation should accommodate step 1, obviating the need for reusers to browse through actual codei.e., obviating the need for step 2. For components whose evolution/adaptation and extension has been properly planned, the amount of knowledge needed for step 3 can be very small, compared to what it would take to explain how the component works, i.e., step 2; the knowledge required for step 3 corresponds to documenting what Krueger called the variable part of component abstractions <ref type="bibr" target="#b78">[83]</ref>. It is reasonable to assume that if a component is to be modified in an unanticipated (or not properly parameterized) fashion, one might need to delve into the minute details of the component, and the knowledge required for step 3 may be comparable to that required for step 2. However, studies have shown that reusers are able to edit and adapt components 7. A 1979 study done at IBM revealed that "maintainen" spend at least something a little different.</p><p>30% of their time trying to understand the code to be modified <ref type="bibr" target="#b98">[103]</ref>. Component understanding is the first step toward component adaptation. Unplanned component adaptation constitutes a textbook case in analogical problem-solving <ref type="bibr" target="#b22">[29]</ref>. Analogical problem-solving is used when the mapping from problem to solution cannot be characterized intensionally, but such that some &lt;problem,solution&gt; pairs are known for which elements in the solution space (software artifacts) can be traced to elements in the problem space (requirements). A new problem Np is solved by first matching it to a known problem-solution pair &lt;KP, KS&gt;, and then using the difference between NP and KP to infer the difference between KS and the actual solution of NP (NS). Analogical problem-solving is unsound in the sense that a problem solution NS is not guaranteed to solve the problem NP; if we modify a component using this kind of reasoning, we lose any assurances that the modified version does what it says (verification), and what we want it to do (validation). It is inherently unsound because it relies on an incomplete knowledge (partial extension) of the problem + solution mapping. This kind of technique is only used in the constrained context of transformational systems (see, e.g., [ 171 and Section V.C) or for informal software artifacts for which there is not much else that can be done (see, e.g., <ref type="bibr" target="#b89">[94]</ref>).</p><p>In terms of tool support and integration, there is a fairly wide consensus that tools for reuse tasks should integrate seamlessly into CASE environments (see, e.g., 1471, <ref type="bibr" target="#b89">[94]</ref>, <ref type="bibr" target="#b108">[113]</ref>, [ 1 161). Typical reuse hctionalities such as search, copy, and edit should be available to developers in a modeless fashion, and should not distract them from their normal workflow (see, e.g., <ref type="bibr" target="#b108">[113]</ref>). Broadly speaking, reuse-oriented CASE environments should be viewed as problem-solving aids, to be used as extensions of developer's mental workspace, rather than a rigid formalism requiring constant translation back and forth to that mental workspace. This entails, among other things, enabling developers to custom-tailor their development environments and providing them with proactive development aids/tools [47]. The former is made possible by offering finegrained development functionalities which developers may combine and sequence at will [ 1 161. The latter remains a research goal, although some knowledge-based systems made some headway in that direction (see, e.g., [ 1471). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Measuring Software Reuse</head><p>Economic considerations are at the center of any discussion of software reuse. Indeed, the most vaunted advantages of software reuse are:</p><p>1) an increase of the productivity of software development, which translates directly into monetary terms and 2)an improvement of the quality of the products, which may mean less corrective maintenance, easier perfective maintenance, greater user satisfaction, and so forth, all of which translate into monetary gains.</p><p>There are also different costs associated with software reuse, both capital setup (up-front) costs and proportional costs (costper-use). Further, different technical approaches to reuse have different investment and return on investment profiles (see, e.g., [42], [148]). Economic models and software metrics are needed that quantify the costs and benefits of reuse. Only recently have researchers started to tackle this problem (see, e.g., <ref type="figure">[7],</ref><ref type="figure">[lo],</ref><ref type="figure"></ref> [ 1 13). Such studies will not only help convince management of the advantages of software reuse-in case there are any-but will also guide the choice of the technical approaches, and improve the management of the introduction of reuse work methods within organizations [ 121, [lS].</p><p>Traditional software metrics that estimate (predict) or measure (after the fact) effort, size, and the relation between them (productivity) need to be amended to account for software reuse. For example, reusable components that accommodate several uses tend to be bigger in size than a version that accommodates a single use, and more complex (see, e.g., [7], <ref type="bibr" target="#b92">[97]</ref>). Further, reuse practice presents managers and develop- ers with choices whose implications have to be measured at the organization, project, and task levels. We recognize three such decisions:</p><p>1) the decision to launch an organization-wide software reuse program (a long-term, capital investment-like decision [ 1 13, [52], [ 128]), 2) the decision to develop a reusable asset (a domain engineering decision <ref type="bibr" target="#b45">[52]</ref>) and 3 ) the decision to (re)use a reusable asset in an application currently under development (an application engineering decision <ref type="bibr" target="#b45">[52]</ref>).</p><p>In the next three sections, we discuss the work relevant to these decisions. Because of the dependencies between some of the metrics and models, we proceed in reverse order. We conclude in Section 1II.D by discussing the weaknesses of the existing methods and suggesting areas for research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. 1. Reuse Instance Costs</head><p>A reuse instance means different things whether we are talking about the building blocks approach or the generative approach. In the context of the building blocks approach, a reuse instance is a point in the development where a developer has the option of building a component from scratch, but chooses instead to try to reuse a component from the library. With the generative approach, a reuse instance corresponds to an entire project life cycle, or a significant part thereof, as the decision to reuse-in this case, generate-modifies the life cycle in significant ways (see Section 1LI.A). Models appropriate for the generative technology are needed that estimate (or measure) the cost of generative development (see, e.g., <ref type="bibr" target="#b93">[98]</ref>, <ref type="bibr">[154]</ref>) and thatcompare it to the cost of more traditional development (see, e.g., <ref type="bibr" target="#b109">[114]</ref>). In this section, we focus on studies that dealt with the building blocks approach.</p><p>Barnes and Bollinger recognized the existence of two kinds of building blocks reuse, namely, black box reuse, whereby the component is integrated in its host environment without modifications, and white box reuse, whereby the component is adapted and integrated into its host environment <ref type="bibr">[ll]</ref>. The average cost of attempting reuse can be formulated as follows:</p><formula xml:id="formula_2">[Search + (l-p) x Development]</formula><p>where Search is the cost of performing a search operation on the database, Development is the cost of developing the component from scratch, and p is the probability that the component is found in the database. The reuse option is attractive only if:</p><formula xml:id="formula_3">[Search + (l-p) x Development] e Development,</formula><p>or Search e p x Development.</p><p>To favor reuse, we must have an adequate coverage of the library (large p ) and make sure that developers can, quickly, either find the component they need or be fairly confident that it does not exist. Obviously, the more complex the reusable component, the more worthwhile it is for a developer to keep searching.</p><p>In the context of white box reuse, the developer must weigh the cost of producing a component h m scratch against the cost of attempting to reuse one, possibly after modifying it. The average cost of developing with intent to reuse can be formulated as follows:</p><formula xml:id="formula_4">[Search + (l-p) x (ApproxSearch + q x Adaptation + ( 1 3 ) x Development)]</formula><p>where p is the probability that the component is found in the database, q is the probability that a satisfactory approximation of the component can be found, ApproxSearch is the cost of performing the approximate search, Search is the cost of performing an exact search operation on the database, Development is the cost of developing the component from scratch, and Adaptation is the cost of adapting the component to its host environment [ 11 1. The reuse option is attractive if</p><formula xml:id="formula_5">Search + (l-p) ApproxSearch + (l-p) q Adaptation I</formula><p>(1) If we consider that the fact that a satisfactory approximation of the component is found means that Adaptation I Development,1° then a sufficient (but not necessary) condition for reuse to be attractive is given by: (p + (l-p) q) Development 10. A study by Woodfield and Embley suggested that developers would not consider reusing if they estimate the cost of adaptation to be 70% or higher than the cost of developing from scratch <ref type="bibr" target="#b128">[159]</ref>. They also found that develop ers systematically underestimate adaptation effort by about 15%. which means that what they perceive to be 70% may actually be 85%. Thus, all in all, developers are reasonably trustworthy as far as ensuring that they don't adapt reusable components in cases where they should develop from scratch.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Search + (l-p) ApproxSearch 5 p Development</head><p>(2) which means the overall cost of search, whether a satisfactory component is found or not, is less than the savings that actually result from those (100 x p) % cases where a satisfactory component is found.</p><p>This inequality has to be understood in the context of experimental evidence to the effect that the cost of adapting a component for the purpose of software reuse jumps very fast as the portion of code to be modified goes up <ref type="bibr" target="#b16">[23]</ref>; e.g., the cost of modifying 20% of the code of a component is estimated at near 90% the cost of developing the component from scratch <ref type="bibr" target="#b16">[23]</ref>. <ref type="bibr">Margono</ref> and Rhoads argued that adaptation costs depended on whether a component was reused within or across application domains and on whether a component was developed in-house or acquired externally <ref type="bibr" target="#b92">[97]</ref>. It is fair to say that, in general, white box reuse is cost-effective if it is restricted to those cases where modifications are very minor or already planned andor parameterized. That being said, inequality (2) can be used as a baseline for developing component libraries and retrieval systems, where we should replace p above by p x recall," which represents the probability that a component exists that satisfies the needs and that is found by the retrieval system. Putting more components in the library increases its coverage @), but may increase search time (Search and ApproxSearch) by returning more irrelevant components that need to be studied by developers. Putting in bigger components (higher development costs) increases also the cost effectiveness of the library. We discuss the marginal costs of adding a component to a library in the next section.</p><p>We conclude our discussion by pointing out that a developer who is fairly familiar with the contents of a component library can locate what shehe needs more quickly and knows ,when not to bother even looking. This has the effect of reducing the cost of individual searches (Search and ApproxSearch) and their relative frequency, which in case of perfect knowledge about the contents of the library, go down from 1 to p for exact search and from l-p to q for approximate search.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.2. Building a Reusable Asset</head><p>Building a reusable asset represents a more or less major investment, depending on the reuse approach used. With the building blocks approach, building components is a regular, recurring activity, whose implications, positive or negative, are minor. By contrast, building a generator is an extraordinary and costly decision, on which the success or failure of a reuse program may depend. For the case of application generators, the biggest challenge is to recognize opportunity: When is a generator appropriate <ref type="bibr" target="#b93">[98]</ref>. This depends on both the stability of the application domain and the number of systems that need to be developed and maintained within that domain (see, e.g., [34], [89]). The second question has to do with the extent of application development that should be automated. Levy argued that deciding the coverage of the generator should be 11. Simply put, the recall of a search on a retrieval system is the probability that a relevant item to the search is retrieved by the system The recall of a retrieval system is the statistical average over a sample of representative searchedqueries.</p><p>based on rational economic decisions, namely, on the marginal costs of automating an extra E % of applications, relative to the marginal benefits expected from automating that extra E % [89]. In particular, he noted that the 20/80 rule holds, namely, incrementally automating the development of applications gets much harder as we come close to full automation <ref type="bibr" target="#b84">[89]</ref>. The cost increments have to be measured against (amortized over) the number of systems to be developed and maintained during the "life expectancy" of the generator, which depends on the stability of the application domain.</p><p>With the building blocks approach, the decision to build a reusable component should take into account several cost factors:</p><p>1) the initial cost of development, 2) the direct and indirect costs of including the component 3) the cost of integrating and/or adapting the component and 4) the expected usage frequency of the component.</p><p>Barnes argued that organizations should consider acquiring reusable components from other vendors, and the decision should be purely economical. As a rule of thumb, build reusable components in-house for local expertise, and purchase reusable partslZ in external expertise. But how to estimate the cost of developing a reusable component? There is a wide consensus that reusable components cost more to develop than nonreusable components with comparable functionality, but estimates range from 50% more <ref type="bibr">[128]</ref> to twice the cost or more <ref type="bibr" target="#b92">[97]</ref>. The extra cost could be due to a more demanding requirements identification stage (domain analysis), lengthier or more complex codeI3 (see, e.g., [7]), or more demanding testing and packaging. Balda and Gustafson explored a CO-COMO-like empirical cost model for software projects that accounts for both reusing reusable components and developing reusable components [7]. They argued that reusable components tend to be longer and more complex than their nonreusable counterparts, and that the differences depend on the application domain, but offered no detailed breakdown of the extra costs [7]. Rhoads and Margano tracked software projects in which reuse-mainly within project-was a priority and found that 60% of overhead costs for building reusable components were incurred during the detailed design of the components <ref type="bibr" target="#b92">[97]</ref>. In their study, reusable components were built as a byproduct of application development, and not in the context of a stand-alone domain engineering activity, for which different cost profiles may hold.</p><p>Once a reusable component is built, it needs to be included in a repositoryllibrary of reusable components. In addition to the obvious (and negligible) costs associated with storage and degraded time performance, there are a number of insidious retrieval costs that are more significant and harder to measure. For a thorough assessment of the result of adding a reusable component to an existing library, we have to see the effects on the reuse instance cost equation: into a library of reusable components, 12. This explains in part why mathematical and statistical packages have gained wide acceptance in the software market: Few companies have an inhouse mathematician or statistician.</p><p>13. E.g., using conditional compilation (extra code) or more parameterization (more complex) to offer several variants of the same functionality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>[Search + (1-p) x (ApproxSeurch</head><formula xml:id="formula_6">+ q x Adaptation + (1-q) x Development)]</formula><p>In principle, adding a component increases the coverage of the component library and thus increases both probabilities p and q and modifies the averages Adaptation and Development (depending on the new component size relative to the average component size in the library and the average component size "outside the library"). It will also probably increase the costs Search and ApproxSearch. For instance, with document retrieval systems, there is a three-way trade-off between recall, precision,14 and simplicity of the encoding and search strate- gies <ref type="bibr">[142]</ref>. Increasing the size of the document collection degrades the performance of the retrieval system both in absolute terms (e.g., for the same precision level, the user has more irrelevant items to examine) and in relative terms (e.g., "higher resolution" encoding is required to describe components, and thus more complex queries are required to retrieve them with equal precisionI5 </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.3. Setting Up a Reuse Program</head><p>The question is not so much whether to set up a reuse program or not, but how. There are a number of intertwined organizational and technological choices to be considered, with different cost/benefit characteristics, and managers must have the tools to evaluate and compare them. In this section, we discuss the most salient choices, and any reuse-specific measurables (or measures) proposed in the literature that are relevant to these choices. As shown in SectionIII.A, reuse practice benefits from new organizational structures and managerial practices. Accounting for such changes in the costhenefit analysis would be no different from that in any business process re-engineering effort, and won't be discussed below. We organize our discussion around the steps of a reuse adoption process proposed by Davis <ref type="bibr" target="#b35">[42]</ref>:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="14.">Precision is the average ratio of retrieved and relevant items out of the retrieved items.</head><p>15. The readers can convince themselves of the above using intuitive information-theoretic arguments: to encode and distinguish between @recision) n items, we need codes of length hg(n). The more items we have, the longer the codes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Initiate reuse program development:</head><p>This step includes identifying organizational objectives (e.g., productivity and quality objectives) and reuse opportunities <ref type="bibr" target="#b35">[42]</ref>. An organization may be active in different application domains, and the reuse potential in each of these domains must be estimated. It is widely recognized that MIS applications are fairly stable and high reuse rates are possible, while systems software and programming environments, e.g., offer few opportunities for reuse (see, e.g., [85], [loo]). However, there is no easy way of finding out how much reuse is possible within an application domain without actually doing it over a period of years or performing some extent of domain analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Define reuse program: This step includes:</head><p>1) defining the scopdcoverage of the reuse program, 2) establishing "reasonable" reuse targets and 3) identifying alternative reuse adoption strategies.</p><p>Scoping the reuse program consists of choosing an application domain, or a subdomain thereof, that offers the most reuse potential, the lowest risks, the fastest returns on investment, etc. Once the scope is identified, organizations must establish reuse objectives that they can attain with reasonable effort, depending on a self-assessment of their managerial and technical processes [42]. Davis proposed a reuse capability model which defines reuse objectives in terms of three measures: 1) reuse proficiency, which is the ratio of the value of the actual reuse opportunities exploited to the value of potential reuse opportunities, 2) reuse eficiency, which measures how much of the reuse opportunities targeted by the organization have actually been exploited and 3) reuse egectiveness, which is the ratio of reuse benefits to reuse costs <ref type="bibr" target="#b35">[42]</ref>.</p><p>Note that all three measures assume that a reuse program is already in place. Davis pointed out that these measures are not metrics that organizations must be able to calculate at the outset, but are objectives to be attained once a program has started [42].</p><p>As mentioned above, it is difficult to precisely quantify the reuse potential of an application domain, and thus, reuse proficiency is only an indicative measure. There has been some interest in the literature for measures of reuse eficiency, although mostly as target reuse rates, i.e., as a target percentage of reused code in new projects (see, e.g.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>, [12], [99], [IOO]).</head><p>However, there are a number of problems in measuring reuse rates by comparing code sizes, as reflected by the sometimes surprisingly low productivity increases that resulted from impressive reuse rates (see, e.g., <ref type="bibr" target="#b53">[59]</ref>). First, there are difficulties in applying such measures for the generative approaches to reuse, where the generated code does not necessarily correspond to what a developer might write, either in style or in size <ref type="bibr" target="#b27">[34]</ref>. Second, as shown earlier, reusable components tend to be larger than their nonreusable counterparts, inflating the percentage of reused code within projects. This is exacerbated in the case of the black-box reuse of modules that offer several functionalities: One cannot separate the needed features from those that are not needed (e.g., with 00 components) and count them separately. Third, there are also difficulties with defining what constitutes an instance of reuse (see, e.g., [ 1281): A reusable component that is imported (used) in several client modules should be counted only once. To alleviate these problems, functional (versus size) metrics, such as function points, could be used instead. For each project developed un- der the reuse program, let firor and JpNw be the function points of the entire project, and of the new code developedfor the project, respectively; the functionali~ reuse rate may be defined as: *"' -* W W . The trouble with such a measure is that a function points count cannot be entirely automated. Further, while function points are additive for coarse-grained modules,I6 they may lose significance when we are dealing with low-level components.</p><p>FinalG, reuse efectiveness can be measured directly-and globally-from observables. A naive approach would consist of measuring productivity levels before and after the introduction of reuse. Productivity can be measured as the time average of the ratio of delivered functionality per expended resources. Because reuse involves both proportional recurring costs and one-time fixed costs, productivity studies must necessarily account for different amortizing schedules and account, implicitly or explicitly, for various product line life expectancies. Most of the work on metrics and economic models for software reuse takes into account the time-varying aspects of productivity and explores different return on investment scenarios</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Analyze reuse adoption strategies:</head><p>The identification of reuse objectives (in the previous step) suggests a number of candidate reuse adoption strategies, whose costs and benefits are analyzed at this step. An adoption strategy may be seen as a combination of a technical approach and a deployment strategy (e.g., starting at the project level vs. department level, pace of introduction of the technology, etc.). For example, the building-blocks approach may be suited to a low-investment and low-risk, incremental reuse adoption strategy. It also has some inherent limitations in terms of attainable reuse efficiency and effectiveness. A generative approach, on the other hand, supports a high-risk, high-payoff strategy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Plan reuse adoption strategy:</head><p>Based on the comparative analysis of the various adoption strategies, one or a combination of strategies may be chosen. At this stage, a detailed deployment plan is produced. Decisions such as how much of the reusable domain to cover the first year, the pace of acquiring the reusable assets, etc. are made here. Detailed cost models such as those discussed in Section III.B.l and Section III.B.2 are needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Implement and monitor reuse program:</head><p>Monitoring involves collecting data to support the various metrics.</p><p>In summary, setting up a reuse program is a major capital investment decision and has been recognized as such by a number of researchers. The economic models proposed in the literature address fairly adequately the economics of reuse at the organization level and at the project level, by integrating a set of elementary cost variables in an encompassing model (see, e.g., [ll], <ref type="bibr" target="#b45">[52]</ref>, [128]). However, it is often those elementary cost variables, or the observables used to derive them, that are hard to measure or interpret, undermining the forecasting or explanatory abilities of these models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.4. Discussion</head><p>A lot of progress has been achieved on the analysis of the software reuse processes and the derivation of cost estimation models for these processes, and a great deal more is needed. We feel that future efforts should be concentrated on addressing the following aspects:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>In relation to reuse instance costs:</head><p>We need more precise effort and cost models for adapting reusable software. Existing empirical evidence suggests that small changes-which defeat the quality advantage-require substantial efforts [23]defeating the productivity advantage. We need a better breakdown of those efforts (e.g., trying to understand the code versus implementing the actual change) to focus technical research on those aspects that are most costly. We also need a better characterization of which adaptation efforts are costly and which are not. For example, changing the type of a parameter of a procedure is probably less costly than changing the outcome of a control sequence. Such knowledge may help us develop better techniques for modularizing and parameterizing reusable components and computer tools to support the adaptation process (see, e.g., <ref type="bibr" target="#b89">[94]</ref>). We also need a finer characterization and a better integration of retrieval costs in the cost equation (Sections III.B.1 and III.B.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>In relation to the cost of building reusable assets:</head><p>It is widely recognized that reusable components are costlier to develop than their nonreusable counterparts. However, there is no agreement over how much more, and there are very few studies about the distribution of "reusability overhead" (see, e.g., [7]); more are needed. There is already recognition in the literature that the extra cost depends on the domain (see, e.g., [7], <ref type="bibr" target="#b92">[97]</ref>). Other factors could include the parameterization range, the implementation technique, and associated adaptationfinstantiation techniques, etc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>In relation to project-level and organization-level measures:</head><p>This is perhaps the area where most work is needed. First, we need more accurate and practical measures of reuse rates. As shown above, code reuse rates are difficult to measure accurately and do not reflect either effort or savings. Further, they apply only to code reuse and cannot be used to measure design reuse, e.g. We showed that functional metrics are useful, but impractical. We could ignore reuse rates (a means) altogether and look directly at productivity gains (an end). But then, how much of the productivity gains are due to reuse, how much are due to process improvement? How much are due to enhanced communication between developers because teams get smaller? For example, the greatest productivity gains with 4GL tools occur for those projects that become small enough to handle for a single developer <ref type="bibr" target="#b93">[98]</ref>. These are not moot questions because we need precise indicators to help us improve those aspects of the reuse plan that can (or should) be improved.</p><p>Until (most of) these concerns are properly addressed, there can be no objective basis for comparing different reuse approaches, especially those that fall on different segments of the building blocks t+ generative axis. The various approaches discussed in the remainder of this paper will only be compared for the extent to which they address specific issues. Where appropriate, we will guesstimate their likely relative effectiveness, but we will not, and cannot, go any further.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. ACQUIRING REUSABLE ASSETS</head><p>We saw in Section II.B that all the artifacts, both used and produced, and the processes of past software development activities are reusable. We choose the word "acquire" to encompass purchasing, building, and various degrees of reengineering or otherwise transforming existing assets. We discussed the economics of acquiring reusable assets in Section III.B.2. In this chapter, we deal with the technical aspects of acquiring reusable assets. We first discuss general issues related to the acquisition and packaging of reusable assets, with a focus on building blocks. In Section IV.B, we discuss application generators as an example of a commercially successful application of the generative approach. In Sec-tionIV.C, we discuss 00 software development, as an enabling technology for developing reusable blocks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Overview</head><p>What makes a software component reusable? We see reusability as a combination of two attributes, (re)usefulness, which means that the component addresses a common need, or provides an often requested service, and usability, which means that the component is of good enough quality and easy enough to understand and use for new software developments. The two are often at odds because the generality of a component (its usefulness) entails abstracting the details specific to its individual uses, which often means that these details have to be somehow put back in to use the component, making it less usable. New abstraction techniques in programming and design enable us to reach new optimums but do not change the basics of the trade-off (see, e.g., [72], <ref type="bibr" target="#b78">[83]</ref>). This is part of what makes the development of reusable assets more challenging than that of custom-made components.</p><p>Acquiring reusable components involves various mixes of new developments and use of existing assetdraw resources, depending on their usability, reusefulness, and desired level of computer support for unit reuse tasks (search, understanding, and adaptatiodintegration). Approaches that rely on existing resources include: providing access to existing "assets," which could be as simple as grouping existing computer files in publicly accessible directories, or providing indexing and search tools, browsers, etc. (see, e.g., <ref type="bibr" target="#b108">[113]</ref>), re-engineering and preemptive maintenance (enhancing the maintainability and the reuse worth of components), reverse engineering (recovering "implicit" development or, more generally, transforming available software knowledge that is otherwise too specific (usable but not reuseful) or too diffuse (reuseful but not usable) into a level of abstraction that makes it (re)useful and usable.</p><p>Domain analysis and engineering may involve any or a combination of the above approaches to identify the basic entities, relations, and operations of the application domain (see, e.g., [132]). Domain analysis is a relatively new activity, and there is some disagreement as to what it involves, both in terms of procesdactivities and in terms of outputdwork products. However, most researchers agree that a critical (and notoriously difficult) step in domain analysis is the identification of the boundaries of the domain [5], [loll, <ref type="bibr">[130]</ref>. Lest we oversimplify, domain analysis follows a process similar to that in developing specific software systems. Namely, it involves requirements, analysis, and the production of domain-wide reusable components [5], [loll, <ref type="bibr">[130]</ref>. The outputs, however, differ from traditional system development in that reusable components typically include standards and guidelines (i.e., semantic knowledge), as well as generic, but concrete components such as domain models (i.e., generic functional architectures), generic design architectures and templates, and even generic code fragments [130]. For the case of DRACO <ref type="bibr" target="#b116">[121]</ref> and ASLs [148]), however, the output of domain analysis is a domain-dependent executable specification language that embodies the domain objects and operations on those objects.</p><p>One of the limitations of "recycling" existing components is that the quality requirements for reusable artifacts exceed those for custom-developed components, and few of the existing components will qualify to be included in a base of reusable assets or will be worth expending effort on. Thus "recycling" is only cost-effective if it can be automated, fully, or to a large extent <ref type="bibr" target="#b21">[28]</ref>. Indexing, searching and browsing tools play an important role by organizing existing software knowledge for the purposes of (as an input to) domain engineering (see, e.g., <ref type="bibr" target="#b108">[ 113]</ref>), but do not providdgenerate components that are directly usable. In our own work, we built a set of tools that extract a structured representation of software components suited for a reuse-driven CASE tool from diverse and disconnected sources of documentation <ref type="bibr" target="#b108">[113]</ref>. However, the added value provided by such tools remains to be proven in a practical setting [ 1 131.</p><p>In the remainder of this section, we will focus on methods for building new reusable assets, namely, application generators and 00 components. Some of the issues related to indexing, retrieval, and browsing, as they relate to software components, will be discussed in various subsections of Section V.A. The interested reader can consult the literature on reverseengineering; a good starting point is the Jan. 1990 issue of IEEE Sofnyare.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Building Application Generators</head><p>Generally speaking, an application generator may be defined as a tool or a set of integrated tool, that inputs a set of suecifications and generates the code of an aDDlication within knowledge).</p><p>an implementation language. What distinguishes application generators from compilers of high-level and very high-level languages or automatic programming systems are the "specifications" or "programs" input by the developer, which are:</p><p>1)partial-the tool completes them by a set of domain- 1) user-friendliness, 2) usable by nonprofessional programmers, 3) support for fast-prototyping, 4) applications take an order of magnitude less time to de-It is next to impossible to give a more precise operational definition of what constitutes an application generator without excluding known classes of application generators. This is due to the fact that the specification language used-and hence the generation techniqudepends very heavily on the application domain. For the same reasons, it is difficult to design a development methodology for application generators that is appropriate for all application generators, and the development of application generators in general received little attention in the literature; by contrast developing with application generators has received a fair amount of attention (see, e.g., Viewed as translators, applications generators have a fairly standard architecture (system design). Further, the programming techniques for implementing translators (detailed design) are well-understood and fairly standardized. In fact, the design and implementation of translators are so well-understood and standardized that application generators themselves can be built using application generators [34] ! The major difficulties in building generators reside in: 1) recognizing cases when they are appropriate 1341, [891, 2) defining their requirements, in terms of defining the input language, the output language, and the "transformation grammar" [34], <ref type="bibr" target="#b84">[89]</ref> and 3) validating their outputs, i.e., verifying that the code generated does what it is supposed to do <ref type="bibr" target="#b66">[72]</ref>.</p><p>The first two difficulties are methodological in nature. Defining the input language involves striking the proper balance between a language that is sufficiently abstract to be usable by noncomputer experts, but also concrete enough so that executable code can be efficiently generated. Validating the generated code poses a number of technical-and theoreticalchallenges 1) identifying the requirements of the generator, 2) building the generator and 3) using the generator.</p><p>Cleaveland proposed a breakdown of the requirements phase into six subphases briefly summarized below [34]:</p><p>Recognizing domains: This step consists of assessing whether an application generator approach is appropriate or not. According to Levy, applications generators are appropriate for applications that embody a "complex synthetic set of rules" [89]; complex in the sense that no notation is known within which they can be described succinctly, and synthetic in the sense that they are man-made. This entails that the rules cannot be had right the first time, and they will keep evolving. This makes it appropriate for prototyping. Or, if we look at the full half of the cup instead, application generators are needed when several similar systems have to be built and maintained. This makes it suitable for stable and well-understood application domains. Cleaveland proposed a number of "appropriateness heuristics" including [ 341 :</p><p>1) recognizing recurring patterns between applications (code, design, architecture), 2) a "natural" or "emergent" separation between the functional (declarative) requirements and the implementation (procedural) of applications, or 3) a fairly systematic procedure to go from one to the other.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Defining domain boundaries:</head><p>This consists of identifying the parts of applications that will be generated, the parts that will have to be built by hand, and the interfaces between the two [34]. There is a trade-off between the range of applications that can be built with the generator (breadth) and how much of these applications will be automated (depth); the decision should be based on economic considerations [34], <ref type="bibr" target="#b84">[89]</ref>.</p><p>Defining an underlying model: This step consists of defining an abstract computational model for the application domain. It is abstract in the sense that it does not depend on a particular implementation technique. Different computational models are appropriate for different application domains <ref type="bibr" target="#b84">[89]</ref>. For example, a computational model appropriate for reactive systems could be finite state machines, while one appropriate for database applications could be relational calculus or algebra. Computational models are important for consistency, understandability, and validation <ref type="bibr" target="#b27">[34]</ref>. They also make it easier to systematize the implementation of a generator and the generation of a family of generators.</p><p>Defining the variant and the invariant parts: the invariant part of an application family consists of the implementation details of the application and all of the defaults assumed by the generator; the variant part consists of those aspects that the developer has to specify. The variant part includes input specifications as well as code escapes <ref type="bibr" target="#b27">[34]</ref>. Code escapes are used when a part of the application cannot be captured--concisely or at all-within the computational model; they defeat some of the advantages of generators (maintainability at the specification level, traceability, testability, etc.) and should be avoided whenever technically possible <ref type="bibr" target="#b27">[34]</ref> and economically justifiable [89].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Defining the specification input method:</head><p>The input method is essentially the user(deve1oper)-interface of the generator. Input methods depend on the underlying computational model and the target user (developer) community. Input methods include:</p><p>1) textual inputs (expressions), 2) graphical inputs (e.g., for user-interface builders A major concern with application generators is their testing: checking that they do generate the correct code. One of the ways programs are usually tested is by comparing their actual outputs to expected outputs. With program generators, we are not certain that the expected output is correct: it, itself, has to be tested. This additional level of indirection makes it that much harder to validate generators <ref type="bibr" target="#b66">[72]</ref>. The problem is more acute than with traditional high-level language compilers which translate imperative code into imperative code, and where there is an easier correspondence between source code and-nonoptimized-target code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Object Oriented Programming</head><p>In the past decade, object oriented programming has come to be considered a panacea to all computing aches. Software engineers view object orientation (00) as the answer to their numerous and intractable problems: enhancing software quality, reusability, and providing a seamless development methodology (see, e.g., <ref type="bibr" target="#b28">[35]</ref>, <ref type="bibr" target="#b31">[38]</ref>, <ref type="bibr" target="#b101">[106]</ref>). Database researchers recognize that 00 allows modeling the semantic behavior of data by encapsulating data with the procedures that manipulate them [25]. In the knowledge-based systems arena, 00 reincarnates old ideas such as procedural knowledge representation, inheritance, and distributed control [ 1411. While researchers may not agree on the specifics of the tenets of object orientation, there is a fairly wide consensus that it is an enabling technology for creating interchangeable and reusable software components. We first provide a brief tutorial on 00. Next, we discuss reusability issues across the 00 life cycle, i.e., analysis, design, and programming. This is by no means a survey of 00 research; our focus is on those aspects of 00 that make reuse inevitable, possible, or difficult.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. 1. Object Orientation IO1</head><p>The concept of "object" in programming was introduced by Dah1 and Nygaard in their language SIMULA <ref type="bibr" target="#b34">[41]</ref>. SIMULA was designed as a language for simulating dynamic physical systems. Physical objects were modeled by structures containing state variables and procedures used to manipulate them. Using today's jargon, we would say that objects are compilation units that encapsulate data with the procedures that manipulate them. One of the advantages of such structures, from a programming language point of view, was to separate the visibility of variables from their lifetime, i.e., a variable could be active outside the scope of its visibility. This is the basic idea behind information hiding. Information hiding enables us to build modules that are easier to understand and more reusable. Because of information hiding, "objects" can only be manipulated through public interfaces-sometimes called protocols or simply interfaces-i.e., a set of procedures that are "publicly" visible. This makes it possible to change the implementation details of an object without affecting its clients.</p><p>Intuitively, a class is (the description of) a collection of objects that share the same data structure and support the same operations. The description of a class includes a data template and a definition of the operations supported by the objectscalled instances-of the class. In some 00 languages and modular languages (e.g., Modula and Ada), a distinction is made between the spec$cation of a class (e.g., package specpcation in Ada) and its implementation (e.g., implementation module in Modula). Typically, the specification of a class corresponds to its public interface." An abstract class is a class that has a specification but no implementation. Overloading makes it possible for several classes to offedimplement the same operations; the compiler disambiguates operation references using the parametedoperand types. Polymorphism makes it possible for a variable to hold objects belonging to different classes. Dynamic binding delays the resolution of operation references until run-time when the actual type of the variable is known; this allows for greater flexibility in programming [ 1061. Overloading and polymorphism make it possible to develop general-purpose client code that is indifferent to the reimplementation and extension of server code. Classes can be organized along hierarchies supporting different kinds of "inheritance." The parallel with natural taxonomies, whereby a natural category "inherits" a number of properties from its ancestors, is tempting, sometimes useful, and often misleading <ref type="bibr" target="#b66">[72]</ref>. For the time being, let us just say that inheritance in programming languages is a built-in code-sharing mechanism that, without polymorphism and dynamic binding, would not be much different from various module import mechanisms in traditional languages.</p><p>In addition to its programming significance, 00 is also a modeling paradigm. As a computational model, 00 represents a significant departure from traditional process-oriented modeling approaches in which there is a clear divide between process and data. In process-oriented approaches, data are viewed as static entities, whose domain-dependent dynamic semantics are buried into processes which embody application-dependent tasks. Complexity in modeled systems is then reflected in the procedures. By contrast, 00 encapsulates data with their domain-wide dynamic semantics, and complexity in the modeled systems is reflected in the data instead. Presumably, this makes for partial models (components) that are reusable across various applications within the same domain <ref type="bibr" target="#b101">[106]</ref>. Further, because procedures evolve faster than data in domains, 00 models tend to be more resilient to change [ 1061. 17. This is the case in the Modula and Ada families of languages. In C t t , however, the specification must list the procedures and data variables that are not visible outside, but say so.</p><p>The modeling potential of 00 found its way into analysis and design (see, e.g., [ 1401, [ 1461, [ 1571). 00 proponents argue that 00 models, in addition to their reusability and resilience to change, are easier to understand and to communicate to end-users (see, e.g., <ref type="bibr" target="#b28">[35]</ref>). Typically, 00 analysis is concerned with the derivation of two views of a system: 1) a static or structural model, describing the objects of the domain and their relationships and 2) a dynamic or behavioral model, describing the functional and control aspects of the system as embodied in individual object operations and interobject interactions (see, e.g., partial surveys in [461, [ISS]).</p><p>Objects that have the same properties and exhibit the same behavior are grouped in classes. Class hierarchies start taking shape where classes that share application-signijicant data and application-meaningfu2 external behavior are grouped under more general classes. Identifying generalizations of classes at this level has several advantages, including:</p><p>1) enhancing the understandability of the models by reducing the number of independent concepts that an analysthser has to deal with,</p><p>2) providing a cross-check with data dictionaries to enforce consistency within the model and 3) identifying opportunities for code reuse [351, [ 1401, <ref type="bibr" target="#b126">[157]</ref>.</p><p>The last is justified by the intuitive realization that similar requirements in terms of external behaviors-an analysis-level product-generally lead to similar implementations. Object oriented design binds domain-level classes-a requirement-into computational structures that, in addition to "implementing" the required functionality, maximize code sharing and satisfy environmental and performance constraints (see, e.g., <ref type="bibr" target="#b24">[31]</ref>, <ref type="bibr" target="#b64">[70]</ref>, [140]). System (architectural) design includes partitioning a system into subsystems andor layers, choosing an overall control paradigm (e.g., event-driven versus hierarchical), and distributing data and processing (see, e.g., [ 1401). Class (detailed) design includes:</p><p>1) representation issues (e.g., of attributes, associations, and 2) algorithms, which are tightly coupled into representation</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3) object control paradigm [31], [140], [146].</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>collections), issues, and</head><p>There are a number of advantages to keeping design (and implementation) class hierarchies close to analysis-level hierarchies, including:</p><formula xml:id="formula_7">1) traceability [36],</formula><p>2) conceptual clarity (see, e.g., [39]), 3) reuse of interfaces (see, e.g., <ref type="bibr" target="#b30">[37]</ref>) and 4) potential for reusing application-meaning1 computations-by contrast to structure-manipulation operations which are inherently representatiodimplementation dependent.</p><p>Methodologists recognize that in some cases, environmental considerations may dictate different representations for behaviorally similar classes, leading to either suboptimal code reusdsharing or, if we insist, unsavory class hierarchies (lots of cancellations, unsafe inheritance, methods having awkward names, etc. [37]). They also suggest looking into alternatives to inheritance (e.g., delegation) that achieve the same goals [ 1401. In general, the transition from design to implementation is fairly straightforward. For the case of control-intensive (e.g., real-time) applications, the transformation can even be automated (see, e.g., [ 1051).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.2. Reusability Issues in Object Oriented Analysis</head><p>The proponents of 00 attribute a number of qualities to 00 analysis and to the resulting models, most of which are supposed to favor reuse. We will discuss these as well as other tenets of 00 analysis that may impact reuse positively or negatively.</p><p>An often-cited advantage of 00 analysis and 00 models is what Hoydalsvik and Sindre called problem orientation <ref type="bibr" target="#b64">[70]</ref>, i.e., the models are cast into terms of the problem domain. This makes models easily communicable to the target user community and favors greater user involvement in development and hence greater satisfaction with the final product (see, e.g., [35], <ref type="bibr" target="#b29">[36]</ref>). We share the view that this is only true in data-rich, processing-poor application domains where objects are intuitive and easy to identify [3] and where most of the processing consists of associative data access; these are domains where more traditional data modeling techniques are already known to be more appropriate than process-oriented techniques <ref type="bibr" target="#b39">[46]</ref>. In control-intensive applications, objects are synthetic (artificial) service providers rather than natural data holders, and most of the complexity is embedded in the dynamic model, which uses the same notations as those used in process-oriented techniques.</p><p>A second related advantage of 00 models is theirpresumed-resilience to evolution. Presumably, in application domains, processes change more often and faster than the entities of the domain, and hence a model structured around the data of the problem domain will be more stable [ 1061. To this, we add the fact that: 1) localization, i.e., changes should be localized in the model, even if they require considerable rework in a localized area, 2)conservative extension, meaning that the effect of a change on the work already done should be minimal, i.e., we should, as much as possible, extend existing work but not redo it and 3) model independence, in the sense that changes to structural (data) models have little impact on behavioral models, and vice-versa.</p><p>The authors modeled the ATM application using Rumbaugh et changes and cialization and extension quite handily.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>al.'s object modeling technique (OMT [ 1403)</head><p>and considered two "small change" scenarios to assess the stability properties. They observed that the structural model-called object model in OMT-was well-behaved, but that the behavioral models1* were not. They also observed that the models were somewhat interdependent because in one scenario, changes to the behavioral models led to revising the object model [go]. The authors recognized that theirs was not a controlled experiment and that no definitive conclusions could be drawn. We believe that some of the difficulties were specific to OMT, and to datadriven methods in general,IY but concur with their observation that ease of evolution may conflict with ease of description. The authors mentioned two modeling "tricks" that would have stabilized the models:</p><p>1) the use of abstract classes to leave room for future spe-</p><p>2) the use of '"ixins"2° to separate concerns and reuse them cialization or factoring of existing classes and independently;</p><p>both techniques have no meaning to the end user [go].</p><p>A third advantage of 00 analysis is that it lends itself naturally to domain analysis (versus single application analysis) and thus leads to more widely reusable components. This is attributed as much to the notation as it is to the process. For example, once it has been recognized that the class Checkinaccount is part of an application, it is difficult not to think of operations to deposit, withdraw, and give balance, even when the application at hand requires only one or two operations. Further, data-driven methodologies (e.g., OMT [ 1401) explicitly prescribe that analysts should rely on their knowledge of an application domain to complement the statement of the problem as a source for identifying the relevant objectdclasses. However, this approach has been criticized for being open-ended, i.e., analysts do not know when to stop adding objects and classes that may be relevant to the domain, but could be irrelevant to the application at hand, and thus unduly burdening the project at hand (see, e.g., <ref type="bibr" target="#b68">[74]</ref>, [125]). Usecuse driven or scenario-driven methodologies are supposed to alleviate this problem by focusing on the objects that participate in useful system behavior (see, e.g., [74], [138]). And finally, generalization enables developers to factor out the shared data and behavior between classes in (abstract) classes which are even more reusable than the actual (concrete) classes. We find it surprising that, despite the importance of the analysis-level hierarchical organization of classes on the 00 development life cycle, and the long-established research tradition in classification in artificial intelligence, there have been relatively few efforts to provide automated or semiautomated tools for building or maintaining class hierarchies</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="18.">Oh4T uses several complementary notations to represent behavior, including event flow diagram to =present messages exchanged between objects, and Haref statecharts for individual objects to represent objects' individual behaviors.</head><p>19. A method is considered to be data-driven if modeling starts by identifying the objects of the domaidapplication, before analyzing any desirable behavior the system has to have. Some aspects of 00 analysis have also been criticized for hindering reuse or for underusing the potential of 00 for reusability. One of the thorniest problems resides in the specification of interobject behavior (see, e.g., [3], <ref type="bibr" target="#b39">[46]</ref>, <ref type="bibr" target="#b127">[158]</ref>). An unspoken corollary of 00 is that any behavior that an object system may exhibit must be attached to an objectlclass within the system. This forces us to specify-and implement-the interaction between two objects as an operation on one of the two, i.e., it forces us to assign responsibility for a behavior involving two objects to one of the two objects. If that behavior (or the interaction underlying it) is contextual (specific to) a given application, the object made responsible for the joint behavior is not reusable across applications [109]. This led a number of researchers to propose dynamic entities, other than state-bearing application objects, that embody interobject behavior (e.g., relationships [ 1391, constraints [ 1091, contracts [65], etc.). Recognizing the need for such constructs has not made the identification of "behavioral boundaries" between objects any easier (see, e.g.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>, [3], [log], [1581).</head><p>A second set of problems deals with the related issues of view modeling and multiple inheritance. Multiple inheritance occurs when a class has two or more nonhierarchically related ancestor classes. Multiple inheritance may occur in natural taxonomies and has been supported by a number of knowledge representation languages (e.g., KL-ONE [24] and its derivatives). Further, automatic hierarchical classification (class factoring) algorithms that avoid redundancy may generate lattices rather than trees (see, e.g., [37], <ref type="bibr" target="#b49">[56]</ref>). Multiple inheritance, which is a powerful modeling concept, becomes a programming language nightmare when the transition is made to implementation. Further, it often results from integrating different roles that objects may play within the same application. Forcing all the roles on the same class definition has a number of disadvantages <ref type="bibr" target="#b57">[63]</ref>. First, the models tend to be hard to read and understand. For instance, generalization relationships become hard to understand as a class may descend from two unrelated superclasses, each representing a different role. Further, a unified nomenclature must be found for all the roles, inevitably losing meaning and significance. Second, this leads to suboptimal reuse as the individual roles cannot be reused (extended and/or specialized) independently </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.3. Reusability Issues in Object Oriented Design</head><p>In 00 software development the same basic set of concepts is used to describe the products of analysis, design, and implementation <ref type="bibr" target="#b60">[66]</ref>. Presumably, this helps make a seamless transition between analysis and design (see, e.g., [31], <ref type="bibr" target="#b28">[35]</ref>). The advantages of such a seamless transition are numerous and have been thoroughly documented*' (see, e.g., <ref type="bibr" target="#b28">[35]</ref> and Section IV.B.l). It has been known for some time that the mere use of an object notation is not sufficient to ensure a seamless transition from analysis to design, and that additional care must be taken to ensure that it is (see, e.g., [31], [Sl]). For instance, it is widely recognized that 00 design involves more than adding detail to analysis-level models, and analysis-level class hierarchies may need to be reorganized to take into account environmental and performance factors (see, e.g., [66],</p><p>[ 11 11, [ 1401). This may lead to design models where classes that have the same external (application-meaningful) behavior are no longer hierarchically related, leading to suboptimal code reuse [ 11 11. Worse yet, if we insist on maximizing code reuse, we may end up with two hierarchically related classes that do not share application semantics. This may lead to unsavory class hierarchies, with lots of cancellations, unsafe inheritance, awkward method names, unpredictable behavior, et.</p><p>[37], [8 13. Most methodologies recognize the problem, but don't do much about it beyond suggesting aggregatioddelegation as an alternative to inheritance for code sharing (see, e.g., [140]).</p><p>We believe that concerns for reusability and safety need not be contradictory if we view class design as consisting of two distinct and possibly asynchronous activities:</p><p>1) the development of computational structures that support generic, application-independent structure manipulations with given performance characteristics and 2) choosing, for a given application-meaningful analysislevel class, the structure that best matches its requirements.</p><p>To some extent, the above problems are due to the fact that computational structures are essentially designed one application class at a time and are, in a sense, prematurely bound to the semantics of application classes by both data types and names, i.e., before they can be refined and reused. Shlaer and Mellor recognize this problem, and the design phase of their methodology includes three steps:</p><p>1) building a system-wide design policy, 2) building mechanisms and code templates to support this</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3) populate the templates with analysis-level models [105],</head><p>However, while they insist that code templates are highly reusable, they provide no formal mechanisms for their reuse?* policy and functionalities that support editing existing templates.</p><p>In [ l l l ] , we proposed a design framework that makes it 1 ) reuse interfaces and application-meaningful behavior between design-level classes that do not share the same representation and 2) reuse representation and structure manipulation code to the fullest, without jeopardizing the interface conformance of two hierarchically related design-level classes.</p><p>possible to:</p><p>Our solution to the first challenge relies on:</p><p>1 ) defining a flavor of inheritance restricted to method inheritance, excluding memory structurez3 and 2) enforcing a strict discipline in designingkoding application-meaningful logic in a way that does not bind it to the representati~n.~~ Our solution to the second challenge relies on:</p><p>1 ) defining reusable design templates, including data structure definition and manipulation and 2) developing a mechanical procedure for "instantiating" a design-level class by mapping an analysis-level class over a design template [ 1 1 11.</p><p>Our design templates may be seen as generic data structures parameterized by both data component types and data component (field) names. A design template may be extended by adding new data components and/or operations. Because data component names are meaningless parameters, developers need to specify parameter mappings in case of ambiguity or multiple inheritance/extension [ 1 1 11.</p><p>We have not had reliable practical experience with our methodology to ascertain its effectiveness. For example, it is not clear how much of an application's logic can be coded (in an object-flavored PDL [ 1 111) without referring to an internal representation. Further, from a theoretical point of view, thomy subtyping issues with generic types are made even worse by the name parameterization [ l l l ] . It does build, however, on the proven principle that greater reuse can be achieved by delaying binding component specification to component realizatiodilementation and exemplifies the progressive move from a pure building-blocks approach, to one that includes some generation (see, e.g., [ 1491 and Section II.C).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.4. Reusability and Object Oriented Programming</head><p>Naturally, any impediments to reuse that may appear during analysis and design persist when the components are actually implemented. Implementation further binds components to a particular programming language and style, inevitably reducing their applicability. There is disagreement among methodologists whether language considerations should come into play during design or not (see, e.g., [140] vs. <ref type="bibr" target="#b24">[31]</ref>). This is an important question because different languages support different sets of 00 features (e.g., typed vs. untyped polymorphism, single versus multiple inheritance), with different reusability characteristics that may tip design trade-offs. For example, if we want to maximize code-sharing in a language that does not support multiple inheritance, it is not enough to "linearize" a lattice that maximizes code-sharing; in order to keep the same class hierarchy at design and implementation, we have to consider language features at the design level [37], <ref type="bibr" target="#b49">[56]</ref>.</p><p>In addition to the loss of reusability due to language power, some of the very basic tenets of 00 programming go against reusability. First, encapsulation and information hiding replace the traditional stamp coupling between modules, by common coupling" within modules [156]: All the methods within a class are common-coupled via the structure of the class. Further, inheritance in 00 programming languages violates encapsulation and information hiding [150]. For instance, in most 00 languages, a class has access to all the implementation details of its superclasses. Thus, methods can be-and often are-written in such a way that they depend on the implementation details of their superclasses: When those change, the entire class hierarchy beneath them may be affected. The C++ language addresses this problem by providing three access levels for attributes and methods:</p><p>1)private attributes and methods are accessible only to the 2) protected attributes and methods are accessible to the 3)public attributes and methods which are accessible to all These access levels are further modulated through the accessibility/visibility of the subclass relationship itself: A client objectA may be prevented from using knowledge that server B is a subclass of C, thereby preventing him from using facilities (e.g., operations) that B inherited from C [152]. Meyer argued that inheritance in class libraries is a mechanism that is useful only to the component builder, but that the component user (client) need not and should not be aware of inheritance relationships [ 1071. When the programming language does not have the built-in mechanisms to discipline the use of inheritance, programmer discipline ("always use access functions to read/write objects' attributes") or language preprocessors are needed [ 1 1 13.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.5. Current Trends</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>As object technology matures, the distinction between what it guarantees-no matter what-what it enables-if additional guidelines are used-and</head><p>what it cannot deliver, becomes clearer. Object oriented programming guarantees very little, in and of itself. It is mostly an adequate packaging technology for reusable components. The major obstacles and opportunities for building reusable components remain at the analysis and methods of the defining class, methods of the defining class and its subclasses and objects/methods [ 1521.</p><p>25. Two modules are stamp-coupled if they interact through a visible complex data structure, as when a procedure invokes another one whose parameters include a record. Two modules ace common-coupled if they interact through a hidden complex data structure, as when two procedures access the same "global" complex data structure. Common-coupling is less desirable than stamp-coupling because the dependency between the modules is hidden, making changes to the modules error-prone. design level. Research efforts in analysis and design shift from notations to processes. There are marked weaknesses in analysis and design heuristics and increasing demands for more formal processes, with verifiable properties (see, e.g., [3], <ref type="bibr" target="#b24">[31]</ref>, <ref type="bibr" target="#b64">[70]</ref>). One of the still open, yet fundamental issues that have a direct bearing on the reusability of components has to do with the identification of object's behavioral boundaries and the elicitation and representation of interobject behavior (see, e.g., [3], <ref type="bibr" target="#b126">[157]</ref>, <ref type="bibr" target="#b127">[158]</ref>). Succinctly put, given a high-level specification of the behavior of an object system (whose component objects may be known or not), how to distribute the behavior among component objects in a way that maximizes a given quality criterion-in this case, reusability. The answer to this and related questions may build on existing work on formal specification techniques for reactive systems <ref type="bibr">[ a ]</ref> . It is also becoming clear that not all global behaviors can be effectively distributed among objects (see, e.g., <ref type="bibr" target="#b64">[70]</ref>) and there is increasing interest in multi-paradigm programming, e.g., combining logic and 00 programming (see, e.g., <ref type="bibr" target="#b91">[96]</ref>).</p><p>A second major thrust in 00 research was motivated by practical experience, as it quickly became clear that classes and methods are too fine-grained reuse units to provide any substantive leverage and bigger reusable units need to be considered. For instance, objects seldom offer any interesting behavior on their own and it is often in combination (interaction) with other objects that any useful functionality is achieved <ref type="bibr" target="#b69">[75]</ref>. The idea of objectframeworks <ref type="bibr" target="#b36">[43]</ref>, as design-level collections of interactiqg and interchangeable objects, captured significant attention recently. <ref type="bibr" target="#b19">26</ref> The idea of reusable software (micro-)architectures is not new. However, object orientation's abstraction, parameterization and code-sharing mechanisms support elegant ways for developing and using frameworks (see, e.g., <ref type="bibr" target="#b66">[72]</ref>). 00 frameworks have been developed and used successfully in the area of graphical user interfaces (see, e.g., <ref type="bibr" target="#b36">[43]</ref>, <ref type="bibr" target="#b52">[58]</ref>, [ l lo]). A lot of attention has been devoted recently to the documentation of frameworks, both formally, in terms of specifying interobject interactions (see, e.g., <ref type="bibr" target="#b59">[65]</ref>), and informally, to describe their applicability and illustrate their use (see, e.g., discussions about pattern languages <ref type="bibr">[51]</ref>, <ref type="bibr" target="#b69">[75]</ref>, <ref type="bibr" target="#b82">[87]</ref>). It is interesting to note that, according to Krueger's classification of reuse approaches <ref type="bibr" target="#b78">[83]</ref>, the emphasis on 00 frameworks moves the reuse of 00 software from a pure component-oriented approach to a combination of "software schemas" and "software architectures" approach, i.e., occurring at a higher level of abstraction and providing much greater reuse leverage <ref type="bibr" target="#b78">[83]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>v. BUILDING WITH REUSABLE SOFTWARE</head><p>In this section, we discuss issues related to developing with reusable software. We focus on issues related to the buildingblocks approach because, as mentioned in Section III.A.2 and Section III.A.3, the generative approach does not affect much 26. For example, IEEEs Computer started a new department called Frameworks in the March 1994 issue. An entire conference is devoted to the documentation of frameworks. The seven-year-old Software Frameworks Association is a self-help nonprofit organization. For info, e-mail to info@frameworks.org. the steps that it does not automate. We will discuss in turn component retrieval, component composition and component adaptation. In component retrieval, we look at the problem of matching a set of requirements for a component to a database of component descriptions. The matching seeks a monolithic component that satisfies the requirements. With component composition, the matching seeks a combination of components (such as functional composition) that satisfies the requirements. Finally, we shall discuss component adaptation from the perspective of transformational systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Software Component Retrieval</head><p>Given a set of requirements, the first step in building with reusable components consists of finding a component that satisfies the requirements, either in its present form, or modulo minor modifications. When the number of components in the library is large, developers can no longer afford to examine and inspect each component individually to check its appropriateness. We need an automated method to perform at least a first-cut search that retrieves an initial set of potentially useful components. Such a method would match an encoded description of the requirements against encoded descriptions of the components in the library. The choice of the encoding methods, for both the requirements and the components, and of the matching algorithms involves a number of trade-offs between cost, complexity, and retrieval quality. We start by formulating the retrieval problem from a software reuse perspective. Next, we discuss some of the trade-offs involved in the choices mentioned above. Finally, we briefly describe a representative subset of related work in the literature.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1. The Component Retrieval Problem</head><p>We can formalize the component retrieval problem as follows. We make the distinction between a problem space and a solution space, where the problem consists of the developer's needs. We can further divide the problem space into:</p><p>1) actual problem space, as opposed to, 2) problem space as understood by the developer and 3) query space, which consists of the developer's perceived need's translation into a "query" that the component retrieval system can understand (see Fig. <ref type="figure">3</ref>).</p><p>I Fig. <ref type="figure">3</ref>. A model of component retrieval.</p><p>We use the term query to mean an expression of the developer's need. It can be as simple as a string fed into a string search command or as complex as a Z specification of the component. Depending on the level of expertise of the developer, hidher understanding of the need can be as close to the actual need as possible. Also, depending on the expressiveness of the language used to formulate queries, the developer (or some other agent) can translate those needs as accurately as possible.</p><p>From the solution space end, we can identify three subspaces:</p><p>1) component instances space, 2) component classes space and 3) codeshndices space.</p><p>The component instances space consists of components some of which may be equivalent in some respect. For example, two stable in-situ sorting algorithms are functionally equivalent. Two quicksort programs coded in exactly the same way, but such that variable names differ are functionally equivalent and performance equivalent-they generate the same machine code. Within the class space, these two components will be represented by the same class. The class space is the space of equivalence classes. The equivalence relationship may include functional equivalence (same input-output relation), performance equivalence (same time and space requirements), etc. The codes space consists of the descriptions of the component classes using an encoding or indexing language. In practice, the encoding step inevitably results in a loss of information. In the best case, "indexing" encodes only a subset of the properties of a component class, as when the encoded description of a program module does not state all the potential uses of the program. Depending on the relative size of that subset, indexing would project more or fewer distinct component classes into the same codes (or indices). Worse yet, the encoding can assign properties to classes that don't have them.</p><p>Matchers compare an encoded description of the developer's needs (query) to the encoded descriptions of the components in the library. The languages for describing queries and components should be identical or homomorphic. Given the number of translations and their complexity, there are ample opportunities for inaccuracy and ambiguity, and it is a wonder any needs get satisfied! Any one of the above steps have kept information retrieval (IR) researchers busy for years. A full survey of IR research is beyond the scope of this paper. We explore below the relation between encoding languages and methods and the corresponding matching algorithms, in general, and from a software reuse perspective.</p><p>A developer query may be seen as a predicate Q(.) that re- Ec() will be used for comparison. If LT is a logical implication, the algorithm returns classes C such that OX.) +Q(.). In this case, for all X such that DdX)</p><formula xml:id="formula_8">trieves software components X such that Q(X) is true. Each class C</formula><p>( Dc(X) ) is true, we are assured that Q(X) is true. 2) distance-based retrieval: The retrieval algorithm returns classes of items such that Dist(Dd.), Q(.)) (Dist Bc() , Q(.))) is smallest, where Dist is generally a metric that satisfies the following property:</p><formula xml:id="formula_9">[D(.) LT Q(.)l + [Dist(D(.), Q(.N = 01</formula><p>Intuitively, Dist. measures the extent by which D c ( ) ( Dc()) fails the partial-order relation. Needless to say, in either case, the quality of retrieval depends on the quality of indexing, i.e., the relation between 0, <ref type="bibr">(-)</ref> and Dc <ref type="bibr">(-)</ref> .</p><p>Independently of the retrieval used, queries seldom return software components that fit the needs exactly, especially when those needs are not very precise in the beginning. Thus, most likely, the components retrieved will have to be adapted, and the assessment stage consists of evaluating the retrieved components for the efforts required to modify them. We consider assessment to be an integral part of retrieval. For instance, developer queries should be seen from the following perspective:</p><p>Find components that satisfy the functional requirements Q(.) OR are eusy to modi@ so that they satisfy e(.).</p><p>In other words, a binary predicate IsEasyToAdaptTo(., Q(.)) should be appended, implicitly or explicitly, to any developer query. What makes a component Y easy to adapt to the set of requirements Q(.)? There are two kinds of criteria that make a component easy to adapt: 1) some general criteria related to the intrinsic quality of the 2) differences between the retrieved component and the re-In other words, the predicate IsEasyToAdaptTo(., Q(.)) can be seen as the conjunction of two predicates:</p><formula xml:id="formula_10">ZsEasyToAduptTo(X, e(.)) E EasyToModifyInGeneral(X) A [CostOfI mplementingDifference(DClm of X( .), Q( .)) on X is small]</formula><p>where Dclass of x(.), or DA.) for short, is the description of X's properties.</p><p>Criteria that make a component easy to understand and adapt include the complexity of the component (size, cyclomatic complexity, number of inputs and outputs, etc.) and the quality of its documentation <ref type="bibr" target="#b21">[28]</ref>, [131], <ref type="bibr" target="#b128">[159]</ref>. Estimating the cost of implementing the difference between DA.) and Q(.) on X poses two major difficulties. First and foremost, we have to develop a procedure that, based on the difference between two descriptions DA.) and Q(.), tells what kind of changes need to be incurred to components with description DA.) so that they fit in (satisfy) the description Q(.). In fact, distance-based retrieval is fairly useless i f the measure Dist doesn't correlate component to be adapted and quirements Q( .). somehow to the amount of effort required to adapt the component; this issue is discussed in more detail in the next section. Second, we need a way to estimate the costs of making various kinds of changes to a program. Changing a program may involve modifying its interface, its (internal) structure, or both. Clearly, the cost of adaptation depends on the scope of change (interface alone, versus internal logic) and extent of the change. As mentioned in Section III.B.4, more work is needed in this area.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2. Evaluating Retrieval Pe$ormance</head><p>Traditionally, retrieval quality is measured by recall and precision. Recall measures the ratio of number of retrieved and relevant items to the total number of relevant items in the informationhowledge base. Precision measures the ratio of the number of retrieved and relevant items to the number of retrieved documents. Such measures are only adequate for par- tial-order-based retrieval, which assumes that relevance is a Boolean function, and have been widely criticized for this reason. We add to this the concern for estimating the effort required to adapt a component that doesn't match the developer's requirements. In this section, we study the properties that the encoding schemes and retrieval algorithms need to have to address these problems.</p><p>First, it is interesting to discuss the conditions under which we can achieve 100% recall and 100% precision. With partialorder-based retrieval, perfect precision (only items that truly satisfy the query are returned) implies that indexing/encoding should be such that: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(.))]</head><p>The reader can check that condition (Al) is satisfied if for all C, Dc(.) LT Dc(.). If the partial order is logical implication, the condition [D, + E,] means that all that have been encoded ("said") about classes is accurate. We say that the encoding is sound. For perfect recall, encoding should be such that:</p><p>(vC)[( 0 , (.) LT e(.)) + (0, (.) LT e(.))] (A2) Condition (A2) is satisfied if for all C, E,(.) LT D,(.). If LT stands for logical implication, this says that all that is true (and functionally signacant) about a class C, and possibly more (erroneously), has been encoded in E,(.). Not surprisingly, to achieve perfect recall and precision, we need equivalence between the actual intension of classes (Dd.)) and their encoding ( E, (.) 1; logical equivalence if LT is logical implication. In practice, neither is possible, as mentioned in the previous section. With distance-based retrieval, we don't need logical equivalence but the encoding process should be such that the ranking produced by Dist using E,(.) is similar to that which would have been produced using the actual Dd.). The following must hold: Condition (Bl) means that if an item C1 is presented to the developer before item C,, then it is truly more relevantz7 than Cz. Condition (B2) means that if C1 is more relevant than Cz, then it will be presented to the developer before Cz. The reader can check that because, for a given query, Dist defines a total order on the class space, the two conditions are actually equivalent.</p><p>Another way of interpreting condition (Bl) (or (B2)) is to say that encoding is monotonic, or, introduces a consistent bias. A cautionary note is, however, in order:</p><p>In a reuse context, the thoroughness of component encoding is limited by the developer's willingness to formulate long and precise queries; there is no point in encoding every bit of relevant information about a component if a developer barely has the patience for typing string search regular expressions!</p><p>We now look at the issue of estimating the cost of adapting a component that does not match exactly the needs of the developer. Notwithstanding cases where a component fails to match the query on nonessential (nonfunctional) properties, distance-based retrieval implicitly assumes that the measure Disc somehow correlates to the effort required to adapt the component to match the query. It is fair to assume that the effort is related to the extent of structural changes needed to change the component. A component may be described by either its function (input-output relation, the "what") or its structure (the "how"). Typically, a developer queries the library for a component that fulfills a given purpose ("what"), i.e., by specifying its functional properties rather than by specifying or sketching its structure; the former being, supposedly, easier than the latter. Hence, for matching purposes, component classes are described by their functional properties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Therefore, in order to estimate the structural changes needed to apply to a component that fails a developer query, we need to have a model of the relation between functional requirements (function, types of inputs/outputs, etc.) and component structure.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="27.">The left-hand si&amp; of (Bl) has strict inequality (e) because we don't</head><p>care what happens for cases where oist(EC, (.), e(.)) = oist(EC, (.),q(.)), since encoding natucaUy maps distinct classes to equivalent codes.</p><p>The kind of knowledge needed to model a stnicture-function relationship is not much different from that needed in automatic programming. For instance, if we can characterize the structures that implement a given function, we are only one step away from generating those structures automatically based on the specification of the function! It is extremely difficult to characterize such structures, in no small measure because several algorithms, e.g., can implement the same function, and the same algorithm can implement several "functions," depending on the data it manipulates. However, we should mention that automatic programming systems do not generate all the possible programs that can satisfy a given set of requirements; one that does suffices. Further, we do not need to characterize the full range of (function, structure) pairs, but rather the structural modifications associated with "small" functional differences. In other words, if FS is the mapping that associates to a functionfa set of structures { s i } i = FSO, we do not need a characterization of FS, but rather of FS(f+ AB -FSO. This reduces the problem to finding types of functional differences that can be accommodated by (measurably) small structural differences?* knowing that several kinds of structural differences can accommodate a given functional change. In the next section, we will comment on the extent to which the encoding and retrieval methods discussed address this problem in one form or another.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3. A Survey of Existing Approaches</head><p>Existing approaches to software component retrieval cover a wide spectrum of component encoding methods and search or matching algorithms. The encoding methods differ with respect to their soundness, completeness, and the extent to which they support an estimate of the effort it takes to modify a component. Striving for any of these qualities makes encoding more complex and costlier. It also makes it possible to support more sophisticated retrieval, provided queries of equal richness and expressiveness to that of the encoding scheme are used. In practice, there is a limit to how complex queries can be for component search and reuse to be worthwhile (Section 1II.B. 1). Accordingly, overly complex encoding schemes are wasteful unless reusers are provided computer assistance in formulating equally complex queries. The approaches discussed below strike different balances between complexity and cost on one hand and retrieval quality on the other. Further, some are immediately practicable and have been used in a production setting, while others are mere theoretical explorations. We discuss three major classes of encoding and retrieval approaches, by increasing order of complexity:</p><p>1) text-based "encoding" and retrieval, 2) lexical descriptor-based encoding and retrieval and 3) specijication-based encoding and retrieval. With text-based encoding and retrieval, the textual representation of a component is used as an implicit functional descriptor: Arbitrarily complex string search expressions supplied by the reuser are matched against the textual representa-tion (see, e.g., [ 1131). The main advantage of such an approach is related to cost: No encoding is required, and queries are fairly easy to formulate. Its disadvantages have been thoroughly investigated in the information retrieval literature <ref type="bibr" target="#b13">[20]</ref>. Simply put, plain-text encoding is neither sound nor complete. Short of a full-fledged language understanding system that takes into account the context, the presence of a concept (term or phrase) in the text does not imply that the component is about that concept (e.g., "Unlike quicksort, this procedure..."). Conversely, the absence of a concept from the text does not mean that the component is not about that concept, as different developers and documenters may use a different terminology.</p><p>Plain text encoding and search, and variants thereof, have been used in a number of software libraries (e.g., <ref type="bibr">[481, 1931, [ 113]</ref>), alone or in conjunction with other search methods, and had fairly good recall and precision rates. In a controlled experiment performed at the Software Productivity Consortium, Frakes and Pole found that more sophisticated methods (see below) had no provable advantage over plain text retrieval in terms of recall and precision <ref type="bibr" target="#b42">[49]</ref>. However, they found that developers took 60% more time than with the best method to be satisfied that they had retrieved all the items relevant to their queries. This accounts for both the speed with which individual search statements/expressions can be formulated and the number of distinct search statements that had to be submitted to answer the same query. With traditional document retrieval systems such as library systems, longer search times are a mere annoyance. In a reuse context, bigger search times can make the difference between reusing and not reusing (Section III.B.l).</p><p>With lexical descriptor-based encoding, each component is assigned a set of key phrases that tell what the component "is about." We could define a two-place predicate ZsAbout (.,.), where key phrase K is assigned to a component (or component class) C iff ZsAbour(K, C). If C is assigned a set of phrases { Kl, ..., K,,), then IsAbout(C, Kl) h...h ZsAbout(C, K,,) is true, and the one-place predicate ZsAbout(., Kl) A...A ZsAbout(., K,,) may be considered as the description of the component (class) C (Section V.A.2). Typically, subject experts inspect the components and assign to them key phrases taken from a predefined vocabulary that reflects the important concepts in the domain of discourse (see, e.g., [6], <ref type="bibr" target="#b20">[27]</ref>, <ref type="bibr" target="#b108">[113]</ref>, <ref type="bibr">[1311)</ref>. Notwithstanding the possibility of human error and the coarseness of the indexing vocabulary, such encoding is sound, as opposed to plain-text encoding. Further, because a key phrase need not occur in a component's textual representation to be assigned to it, it is also more complete29 than plain text encoding. Reusers formulate their queries as Boolean expressions of key phrases. Let Q = E(K' sub 1, ..., K' sub m), a Boolean expression with terms PI, ..., K', . A component C with key phrases K,, ..., K,, is considered relevant to the Boolean expression (query) Q iff IsAbout(., K1) h...h IsAbout(., K,,) + E(ZsAbout(., r1), ..., [sAbout(., K',)), or, equivalently, if K1 A...K,, + Q = E(K'1, ..., K',,,). Boolean retrieval, as it is called, corresponds to what we called partial-order-based retrieval.</p><p>29 An encoding scheme can be considered complete only if it says everything of consequence about the component; that is hard to define.</p><p>In practice, the method presented above is refined in many ways. In one refinement, instead of using the one generic relation ZsAbout(.,.) between components and descriptors, several specific relations are used such as HasFunction( .,.), Applica-bleToDomain(.,.), Operateson(.,.), etc. 1271, <ref type="bibr" target="#b107">[112]</ref>, <ref type="bibr">[131]</ref>; this is commonly referred to as multifaceted classification in the information retrieval literature, where each facet corresponds to a relation, and the descriptions for each facet are logically ANDed. For example, if we use the facets HasFunction and Operateson, a routine that sorts both arrays and linked lists may be described by the one-place predicate [HasFunction(., Sorting)] A [Operateson (., Array) A Operates-On(., LinkedList)]. Similarly, reuser queries are now formulated using a conjunction of Boolean expressions, one for each facet on which the reuser wishes to search.</p><p>A second set of refinements amend the retrieval algorithm itself to handle approximate matches. We illustrate them for simple (single-facet) indexing; extending them to multifaceted indexing is fairly straightforward. First, if there is a partial order between key phrases themselves, the partial order may be used to extend queries. Assume for example that the key phrases are organized in a taxonomy. Let Kl and K2 be two phrases such that KI has an "is-a" relation with K2. By definition, any component C that is about K1 (ZsAbout(C, Kl)), by default, is also about KZ (ZsAbout(C, Kz)). However, the reverse is not true. Thus, in the process of looking for components that are about K2, the ones that are about Kl-and KZ'S descendants in general-would also do. This approach is used in MEDLINE <ref type="bibr" target="#b97">[102]</ref>, an on-line medical literature retrieval system operated and maintained by the (U.S.) National Library of Medicine. Two additional refinements turn Boolean retrieval-which is partial-order-based-into distance-based retrieval. The first ranks components by decreasing number of key phrases that match phrases from the query [ 1421. The second method is used when key phrases are organized in a taxonomy (see, e.g., <ref type="bibr">[134]</ref>) or a weighed semantic net in general (see, e.g., <ref type="bibr">[131]</ref>). The former has been used in the European ESPRIT Practitioner (software reuse) project (see, e.g., [ 1131). The latter has been more widely used in software libraries (see, e.g., <ref type="bibr" target="#b20">[27]</ref>, <ref type="bibr" target="#b41">[48]</ref>, <ref type="bibr">[131]</ref>). In Softclass, a prototype CASE tool with integrated support for reuse, we implemented three classes of lexical descriptor-based component retrieval algorithms that combine the above features with weighed facets and a number of fuzzy bells and whistles [ 1121. We are currently setting up a series of experiments to compare the different methods. However, we don't expect significant improvements to result from some of the refinements mentioned above.</p><p>Lexical descriptor-based encoding and retrieval suffers from a number of problems. First, an agreed (or agreeable) vocabulary has to be developed. That is both labor-intensive and conceptually challenging. Sorumgard et al. reported a number of problems developing and using a classification vocabulary [ 15 13. They experienced known problems in building indexing vocabularies for document retrieval, including trade-offs between precision and size of the vocabulary and the choice between what is referred to as precoordinated or post-coordinated indexing,M with the confusion that may result from mixing the two <ref type="bibr" target="#b120">[151]</ref>. Software-specific challenges include the fact that one-word or one-phrase abstractions are hard to come by in the software domain <ref type="bibr" target="#b78">[83]</ref>, <ref type="bibr" target="#b120">[151]</ref>.</p><p>Further, it is not clear whether indexing should describe the computational semantics of a component, as in "this procedure returns the record that has the highest value for a float field, among an array of records," or its application semantics31 as in "this procedure finds the highest paid employee within the employees file" [ 1511. Characterizing computational semantics is important for reuse across application domains. However, reusers may have the tendency to formulate their queries in application-meaningful terms. Formal specification methods suffer from the same problem, but to a lesser extent, since application semantics show up specifically as terminal symbols in the specification language. Finally, neither the encoding mechanism nor the retrieval algorithm lend themselves to as- sessing the effort required to modify a component that does not match the query perfectly. This is so because the descriptors have externally assigned (linguistic) meanings and bear no relationship to the structure of the components. For example, what does it mean for a component C to have the function Sort, i.e., what does it mean to have HasFunction(C, Sort)? it only means what we wish the symbol "Sort" to mean to us, and any relation between two symbols has to be posited by us, rather than proven by a formal proof system.</p><p>From the reuser's point of view, a familiarity with the vocabulary is needed in order to use a component retrieval system effectively [142]; a hierarchical (e.g., taxonomical) organization of the key phrases and proper browsing tools can alleviate the problem significantly [ 1 131. Further, queries tend to be fairly tedious to enter, especially for the case of multifaceted encoding. In Softclass, where software components are grouped into component categories, each with its own facets, queries are entered by filling out a simplified component template that stands for the prototypical component the developer wishes to retrieve <ref type="bibr" target="#b108">[113]</ref>; the filled out template is then internally translated into a Boolean query and matched against the component base. While this format does not handle all kinds of queries efficiently, we believe that it handles the most common queries efficiently [ 1 131.</p><p>Specification-based encoding and retrieval comes closest to achieving full equivalence between what a component is and does and how it is encoded. With text and lexical descriptorbased methods, retrieval algorithms treat queries and codes as mere symbols, and any meaning assigned to queries, component codes, or the extent of match between them is external to the encoding language. Further, being natural language-based, the codes are inherently ambiguous and imprecise. By contrast, specification languages have their own semantics within which 30. (Very) roughly speaking, with precoordinated indexing, several phrases for the same facet are to be interpreted disjunctively, while with postcoordinated indexing, they should be interpreted conjunclively; see <ref type="bibr" target="#b107">[112]</ref>.</p><p>3 1. Using our approach to object-oriented design (seec Section IV.C.3 and [ 11 11). generic design templates would be described by their computational semantics. Application data structures would be characterized explicitly by their application semantics, and implicitly, through the generic design template to which they map, by their computational semantics.</p><p>the fitness of a component to a query can be formally established <ref type="bibr" target="#b25">[32]</ref>, [108], <ref type="bibr" target="#b130">[161]</ref>, and "mismatches" between the two can be formally interpreted [108], [ 1611. Typically, the formal specification-based methods correspond to what we called partial order-based retrieval, using a partial-order relationship between specifications. This partial order is often used to preorganize the components of the library to reduce the number of comparisons between specifications-an often prohibitively costly operation [108], <ref type="bibr" target="#b110">[115]</ref>. The methods discussed in the literature differ in the expressiveness of the specification language. Also, different retrieval algorithms take advantage more or less fully of the power of the specification language. The subset of the language used for retrieval o j h has no effect on recall, but degrades precision, as in using operations' signatures instead of using signatures and pre-and postconditions.</p><p>In [108], A. Mili et al. describe a method for organizing and retrieving software components that uses relational specifications of programs and refinement (contravariance) ordering between them. Any given program is correct with respect to (satisfies) the specification to which it is attached, as well as the specifications that are "above" it. Hence, a specification retrieves the programs attached to it, as well as those attached to specifications that are "below" it. A theorem prover is used to establish a refinement ordering between two specifications. Two forms of retrieval are defined: exact retrieval, which fetches all the specifications that are more refined than a reuser-supplied specification, say K, and approximate retrieval, which is invoked whenever the exact retrieval fails, and which retrieves specifications that have the biggest "overlap"32 with K <ref type="bibr">[108]</ref>. One nice property about approximate retrieval is that, while it does not directly assess the effort required to modify a component, the difference actually means something (e.g., a program is found that gives the desired outputs for a subset of the inputs) and may suggest a way of modifying the returned programs to make them satisfy the requirements or use several of them in combination <ref type="bibr">[108]</ref>.</p><p>Chen et al. proposed a similar approach that uses algebraic specifications for abstract data types and an implementation partial ordering between them <ref type="bibr" target="#b25">[32]</ref>. Reusable components, which may be seen as abstract data types, are specified by both their signature and their behavioral axioms. However, while the implementation relationship takes into account the behavioral axioms, the retrieval algorithm uses only signatures, modulo a renaming of the "types" of the components to match those of the query <ref type="bibr" target="#b25">[32]</ref>; the authors did envision using an "interactive system [read semiautomatic] for algebraic implementation proofs" <ref type="bibr" target="#b25">[32]</ref>. Moorman-Zaremski and Wing propose an approach based exclusively on signature matching <ref type="bibr" target="#b130">[161]</ref>. The major advantage of their approach is that the information required for matching can be extracted directly from the code. They first define exact matches between function signatures, to within parameter names, and then define module signatures and partial matches between modules using various generalization and subtyping relationships [ 1611. They too envision taking into account behavioral specifications in future versions, using LARCH (cf. <ref type="bibr" target="#b54">[60]</ref>) specifications-which would then have to be encoded manually.</p><p>None of the formal specification-based methods we know about addresses directly (or successfully) the issue of assessing the effort required to modify a component returned by approximate retrieval (inexact match). Further specificationbased methods that include behavioral specifications (and not just signatures) suffer from considerable costs. First, there is the cost of deriving and validating formal specifications for the components of the library (see also <ref type="bibr">[ 1151)</ref>. This cost is recoverable because it could be amortized over several trouble-free uses of the components and is minimal if specifications are written before the components are implemented, which is the way it should be (and seldom is) done. The second cost has to do with the computational complexity, if not outright undecidability, of proof procedures. This cost can be reduced if actual proofs are performed only for those components that match a simplified form of the specifications, e.g., the signature; not much else can be done about the inherent complexity of proof procedures or their undecidability without sacrificing specification power. Last but not least, there is the cost for the reuser to write full-fledged specifications for the desired components. Because there is no evidence that specifications are either easier or shorter to write than programs, reusers need motivations other than time-savings, or computer assistance, to write specifications for the components they need. We believe that formal specification-based matching will remain a theoretical curiosity for the time being and will integrate only in the more formal development methods that address application domains such as reactive and real-time systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Component Composition</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>issues:</head><p>Under component composition, we address two dual sets of 1) Given a set of components, and a schema for composing them, check that the proposed composition is feasible (veriBcation) and satisfies a given set of requirements (validation); we refer to this as the composition verification and validation problem and 2)given a set of requirements, find a set of components within a component library whose combined behavior satisfies the requirements; we refer to this as the bottomup design problem.</p><p>The first problem benefits from a large body of work that is not often associated with reuse. A thorough coverage of this problem is beyond the scope of this paper. We will be content to highlight the general issues and describe a representative sample of work in this area (SectionV.B.1). The second problem, discussed in Section V.B.2, benefits from work on verification and validation of compositions, but presents challenging search problems of its own.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>32.</head><p>The overlap between two specifications is determined using the "meet" lattice operation [108].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.l. Composition Verification and Validation three challenges:</head><p>Component composition verification and validation poses 1) designing a language for describing compositions of components that lends itself to verification and validation, 2) performing verification and 3) performing validation.</p><p>There are two general methods for describing compositions of components. If we think of a component as consisting of a specification and a realization (or a set of realizations, see, e.g., <ref type="bibr" target="#b78">[83]</ref>), then composition may occur either at the specification level or at the realization (implementation) level (see also Section V.B.3). Specification languages usually provide builtin composition operators with well-defined semantics. For example, with relational specifications, any of the set theoretic and relational operations may be seen as a composition. In this case, we might say that the set of specifications is closed under composition, and verifying or validating a composition of specifications or validating it against a target specification is not different from verifying any individual specification or validating it against another specification. With regard to validation, we can expect the same challenges discussed for specification-based component encoding and retrieval (Section V.A.3). The problem with specification-level composition is that it is often difficult to characterize specificationlevel manipulations by manipulations on the actual realizations (programs) of these specifications [ 1081.</p><p>When composition takes place at the component realization level, we obtain a (much) smaller range of behavioral compositions, but we are assured that these compositions are feasible without additional development. Component compositions are usually described using the so-called module interconnection languages <ref type="bibr" target="#b55">[61]</ref>, <ref type="bibr">[129]</ref>. A module may be seen as having an internul structure, consisting of a set of data structures and a set of procedures that reference them, and an external interface specifying the external entities the module depends on and the internal entities the module exports. Module interconnection languages describe component (module) compositions by specifying:</p><p>1) the obligations of the individual participants and 2) the interactions between the components.</p><p>The specification of the obligations of the individual components consists, minimally, of the signatures of the operations they need to support; this is similar to Ada's constrained generics, where generic packages list the operations that type parameters have to support <ref type="bibr" target="#b101">[106]</ref>. It could also include the specification of the behavior of the operations. This is the approach followed in Helm et al.'s contracts <ref type="bibr" target="#b59">[65]</ref> and a number of algebraic specification-based interconnection languages such as Goguen's library interconnection language (LIL <ref type="bibr" target="#b51">[57]</ref>) and other derivatives of OBJ or LILEANNA <ref type="bibr" target="#b122">[153]</ref>, e.g., an application of LIL's concepts to ANNotated Ada packages. One of the interesting features of LIL is that obligations are specified in terms of theories, and a given module (in this case, an abstract data type) may satisfy a theory in different ways, called views <ref type="bibr" target="#b51">[57]</ref>. This has the advantage of ignoring operation names during verification, by focusing on their behavioral semantics instead.</p><p>The specification of the interactions between the components varies from simple call dependencies [61] to a fullfledged behavioral specification including interaction logic, aggregate-wide preconditions, postconditions, invariants, etc. (see, e.g., [61], <ref type="bibr" target="#b59">[65]</ref>, [log]). Behavioral interactions between components can also be specified implicitly in logic-based (or logic-flavored) languages. One such language is MELD, an 00 language developed by Kaiser and Garlan <ref type="bibr" target="#b73">[78]</ref>. In MELD, classes are represented by features. Methods are represented by ~emideclarative~~ constructs called action equations. When the same methods are implemented by two features, their action equations are merged. In case the merge creates dependencies, a topological sort determines which action equations are to be executed first <ref type="bibr" target="#b73">[78]</ref>. This constitutes, in our opinion, MELD'S most interesting feature for reuse by composition as it automates code-level integration. Validating the behavior of a composition of modules against a desired behavioral specification is generally a difficult problem [84], <ref type="bibr" target="#b132">[163]</ref>. One of the major difficulties is due to the fact that it is difficult to get a closed form expression for the behavior of the aggregate. This is due to the fact that the language used for describing compositions is different from that used for specifying individual components (see, e.g., [ 1631).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.2. Bottom-Up Development</head><p>Top-down development consists of decomposing the requirements for a module into requirements for a set of (simpler, more reusable, etc.) submodules and patterns of interactions between them. Informal requirements analysis and specification methods use informal heuristics to guide the decomposition process. Formal methods use various reduction and factoring mechanisms to decompose specifications (see, e.g., [30], <ref type="bibr" target="#b26">[33]</ref>). In both cases, the decomposition is guided by properties that the component submodules and their patterns of interactions have to have. For non-trivial requirements, a virtually limitless number of solutions of equal quality could be found. With bottom-up development, the major requirement is that the decomposition yields specifications for which components have already been developed. This is generally a very difficult problem.</p><p>Enumerating compositions of components within a library "until one is found that has the desired behavior" seems unthinkable at first. In practice, a number of practical and theoretical considerations can make the number of compositions to explore manageable. In exploring compositions of components when no single component is found that returns 0 given I. For example, if all the components in the library are single-parameter functions fi, ...,fa, then if for all i, f,(l) f 0, we try out jjU;(l)), for all 1 S i, j I n, and if none is found that returns 0, we try three levels deep function compositions, etc. <ref type="bibr" target="#b56">[62]</ref>. Hall showed that, in general, the number of compositions of components of depth d or less is doubly exponential in d , i.e., of the form O(n("")). However, a number of techniques help reduce that number considerably, without missing any potential solutions. Type-compatibility requirements considerably restrict the range of possible compositions. More dramatic results are obtained by dynamic programming: When generating compositions of depth d U;,o ... of,"), apply new components to all the combinations of distinct return values of depth d -1, rather than all combinations of distinct programs of depth d -1.</p><p>Hall tested his algorithm on a library of 161 Lisp functions. The retrieval system itself is written in Common Lisp. He limited the depth of compositions to three, with the level three functions limited to those that have a single input. Fifteen queries took an average of 20 seconds, and a maximum of 40 seconds, running on a SUN SPARC 11. In one example, a query provoked 2,400 component executions instead of a potential 10l6 executions <ref type="bibr" target="#b56">[62]</ref>. While more testing is needed to assess the efficiency of the algorithm, the processing times remain reasonable for a reasonably large library and show that the method could indeed be computationally practical. However, as Hall pointed out, this method could not be applied to retrieving nonexecutable reusable components <ref type="bibr" target="#b56">[62]</ref>. A less serious engineering difficulty has to do with multiplatform libraries, components that raise exception while being tested out or loop endlessly, and components with side-effects, all of which pose challenging but tractable engineering problems <ref type="bibr" target="#b56">[62]</ref>. We have started work on a combination of Hall's work and Moorman-Zaremski and Wing's work on signature matching <ref type="bibr" target="#b130">[161]</ref>. Assume that a developer is looking for a component that takes an input variable of type TI and produces an output variable of type T2. Failing to find such a component, an algorithm could find any of the compositions shown in Fig. <ref type="figure" target="#fig_18">4</ref>, that "concatenates" components based on type compatibility between their inputs and outputs. The function realization problem, as we called it, consists of finding all the composi- tions of functions (signatures) that consume no more than the inputs specified by the developer's query and produce at least the outputs specified by the developer's query <ref type="bibr" target="#b107">[112]</ref>. We showed in [ 1121 that the set cover problem, which is known to be NP-complete <ref type="bibr" target="#b47">[54]</ref>, could be reduced to the function realization problem. Worse, we know of no heuristic that guarantees a solution value within a constant factor of the optimum cover of a set <ref type="bibr" target="#b47">[54]</ref>, which suggests that none could be found for the function realization problem either. Fortunately, finding out whether a function signature has a realization or not can be done in polynomial time <ref type="bibr" target="#b107">[112]</ref>; bear in mind, though, that a realization does not necessarily exhibit the desired behavior. Because several realizations could be equivalent, we defined a "minimal" form for realizations called normal realization, where each function is needed (i.e., without it the composition would not be a realization), and where each function has the minimal possible depth, i.e., is "called as soon as all its inputs are available." We developed an algorithm for finding normal realizations and implemented it in Lisp <ref type="bibr" target="#b107">[112]</ref>.</p><p>Our method has the advantage of not requiring component execution, and like Moorman-Zaremski and Wing's method <ref type="bibr" target="#b130">[161]</ref>, the information required for search can be extracted from components themselves. However, programming language types alone can be hopelessly nondiscriminatory. A library written in a weakly typed language (e.g., C) is likely to have a handful of types, and the algorithm will have a dismal precision. Application-oriented definitions of types can sharpen the search but may miss out on some valid realizations <ref type="bibr" target="#b56">[62]</ref>. We are currently testing the algorithm on a library of data manipulation functions (string manipulation, data conversion, etc.). While we do not expect a good precision, we are hoping that an inspection of the results will help us recognize classes of realizations or subrealizations that should be pruned out of the search, thereby increasing the efficiency of the algorithm. However, we expect most of the gains to come from using richer semantics for types and type compatibility, and we are pursuing work in that direction as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Adapting Reusable Components</head><p>We use the term adaptation to refer to what happens to a component between the time a decision is made to reuse it and the time it has become part of the product. We recognize three potential subtasks, 1) what Krueger called selection <ref type="bibr" target="#b78">[83]</ref>: if a reusable component has a variable part or explicitly enumerated alternative implementations, select (the) one that is appropriate for the problem at hand, 2 ) modification: in case the component or any of its variants cannot be used as is and 3) integration, which is essentially a verification step that checks whether the component is compatible with its environment.</p><p>One of the major differences between selection and modification is that with selection, the changes to the component have been planned ahead of time. This is generally done using various parameterization and abstraction techniques and will be discussed briefly below. With modification, the changes are often unanticipated or poorly planned. As mentioned in Sections III.A.3 and 1II.B. 1, modifying reusable components may defeat both the quality and the productivity advantages of reuse. Hence, it should be automated as much as possible to save time and ensure that the modifications are quality-preserving. We discuss modification in the context of transformational systems. As for the integration of reusable components, what is not addressed by module interconnection languages discussed in Section V.B.l is not specific to the reusability of the components and will not be discussed further here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.I. Selection</head><p>Two commonly used selection mechanisms are specialization and instantiation of abstract software components. Abstraction has been supported by programming language constructs for some time <ref type="bibr">[143]</ref>. At the most basic level, declaring program constants or using variable-dimension arrays is a form of parameterized programming. Conditional compilation is another more sophisticated form of parameterized software, whereby different code sequences are compiled based on a number of system and environmental parameters. In this case, adaptation consists simply of setting the right environmental parameters. In general the mechanisms involved depend on the nature and complexity of the parameters, ranging from a simple compile or linkage-time binding (e.g., of an unresolved reference to a type T to a specific type), to a mix of substitutions, conditional compilation and code generation as in [16], and template-based approaches in general (see, e.g., [85], <ref type="bibr">[1371)</ref>.</p><p>Object oriented languages support a number of abstraction and selection mechanisms, including generic classes, abstract classes, and metaclasses with metaprogramming [721. Genericity supports the development of complex data structures with parameterized component types. For example, one could define a generic list structure LIST[TI whose node values (or "data" fields) are of a generic type T that supports comparison operators. In this case, selection consists of using the (e.g., declaring a variable of) data type LIST[&lt; &gt;I by specifying an actual type instead of the parameter T. The obligations of the type T may be specified explicitly in the specification of the generic type (called constrained genericity [ 1061) or implicitly based on what types will actually compile or execute. With abstract classes (Section 1V.B. l), selection consists of choosing among several concrete subclasses that conform to the behavior of the abstract class, or creating a subclass of our own, to address the specific needs of the application at hand <ref type="bibr" target="#b66">[72]</ref>. Note that subclassing alone does not guarantee that a class conforms to its superclasses, i.e., that the types they implement are in a subtype relationship. We showed in Section 1V.B .3 how design-level considerations may lead to situations where subclasses do not implement subtypes, and viceversa. Unfortunately, few programming languages (e.g., Eiffel <ref type="bibr" target="#b101">[106]</ref>) ensure that subclasses implement types that are in a subtype relationship, and subclassing remains essentially a code-sharing mechanism, with the problems we discussed in Sections IV.B.3 and IV.B.4. Finally, the use of metuclasses with metaprogramming may be seen as an 00 packaging (design) for program generators (Section IV.2) and will not be discussed further here; the reader is referred to <ref type="bibr" target="#b66">[72]</ref> for a more thorough discussion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.2. Mod$ication</head><p>Modification is required when a retrieved component has to be reworked to accommodate the needs of the application at hand. The need for modification may become clear during retrieval: The encoded description of the component does not match perfectly the query. Alternatively, a closer inspection of a component whose encoded description did match the query may reveal inadequacies. The latter case is possible because encoding is often incomplete: The encoded description leaves out some functional properties of the component. We saw in Section V.A.2 that the mismatch between a query and the encoding of a component may be more or less revealing as to the (extent of the) changes that need to be incurred to the component, depending on the completeness of the encoding. For the purposes of presentation, we consider the two situations as instances of the same problem: Given the specification of a desired component SO, the "closely matching" specification SC of an existing component C, and its realization Rc (i.e., implementation), find the realization for the desired componentcall it RD; the additional problem of working our way back from differences between encoded (partial) description used for retrieval to actual functional specifications raises similar issues because in both cases we have to walk our way back, upstream of an information-losing mapping (see Fig. <ref type="figure" target="#fig_19">5</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>?</head><p>."..--"-..""""""""""-"-"-."~ This problem is best understood in the context of a transformational view of software development. Software development is seen as a (possibly long) sequence of transformations, starting with more or less formal specifications, leading eventually to executable code [ 11. Fig. <ref type="figure" target="#fig_21">6</ref> shows the typical software life cycle for transformational systems. In such systems, software development consists of two major steps: 1) deriving formal specifications from user requirements-if the transformations to be applied are to do any substantive work and 2) applying a set of transformations on the formal specifications, gradually building a computer program, in either a target programming language or in a readily translatable language <ref type="bibr" target="#b118">[123]</ref>.</p><p>An important characteristic of transformational systems is the potential for maintaining software systems at the specifications level  Regardless of the "intelligence" of the transformations (e.g., their knowledge about their own appropriateness), the transformational approach has the following advantages: 1) relieving developers from labor-intensive, knowledge-2) virtually eliminating clerical errors, 3) ensuring correctness of the resulting programs by con-4)maintaining a record of development choices, their ra-It is this last characteristic of transformational systems that concerns us most in this paper, namely, the potential for software reuse. Maintenance has been recognized by a number of researchers as a particular form of reuse (see, e.g., [ 141). Balzer et al. recognized transformational systems' potential for enhancing software reuse, whereby reusable components are maintained and modified at the specification level rather than at the implementation level <ref type="bibr">[8]</ref>. While a number of researchers have recognized the importance of recording development decisions for reuse purposes, the transformational approach to software development makes explicit computer-supported use of those decisions to maintainheuse existing software.</p><p>The transformational approach makes maintenance and reuse easier, not only because it makes development easier in general, but also because "similar" inputs (e.g., formal specifications or any other intermediary form) often call for the same transformations to be applied. Cases where the same sequence of transformations cannot be replayed, e.g., the preconditions of one of the transformations fail to hold as a result of a modification, developer intervention is only needed from that point onward. Baxter studied the commutativity and dependencies between transformations to minimize the scope of modifications [ 171. Take the example of a program P that was derived from a specification S using the chain of transformations T, o ... o Ti o ... o TI and assume that S was modified into S' such that all transformations up to, not including, Ti (i.e., TI, ..., were applied successfully. Normally, a developer would have to intervene to choose an alternative transformation to Ti and proceed from that point to the end. However, if it is known that some transformation T,, for i c j S n, commutes with (thus, independent of) Ti, then it could be moved (applied) ahead of Ti, and the developer would have fewer transformations to consider. Generally speaking, replaying de-poor tasks, struction and tionale, or both for maintenance purposes. sign histories is not foolproof. The level of confidence in the replayed process depends on the knowledge embodiedlused in selecting transformations (e.g., completeness and soundness of preconditions) and the responsiveness of the transformation selection algorithm to specification changes. One can easily imagine a case where an innocuous change in specifications might require a significant change in program structure to maintain a similar level of performance.</p><p>Transformational systems have been criticized by some researchers for their limited range of applicability <ref type="bibr" target="#b118">[123]</ref>. The programs generated with this approach were mostly toy examples, as was the case with other AI-oriented automatic programming systems [9]. While, in principle, the transformational approach is not limited to small programs, the amount of knowledge that needs to be encoded to handle large software systems is prohibitively large. Most of the earlier transformational systems embody basic, domain-independent, programming knowledge. More recent efforts such as the DRACO system [ 12 11 support domain-specific specification languages, and transformations embody some form of domain knowledge. Software reuse research may well benefit from relaxing the formal correctness-preserving nature of transformations and fromusing more heuristic rules such as analogical reasoning <ref type="bibr" target="#b22">[29]</ref>, especially when we deal with informal or poorly structured software products (see, e.g., <ref type="bibr" target="#b89">[94]</ref>). Alternatively, we could settle for localized or partial transformational approaches, as opposed to ones covering the entire specification</p><formula xml:id="formula_11">+ program cycle.</formula><p>To the extent that software reuse benefits from automatically propagating software changes across development stages, work on configuration management systems and program dependencies is eminently relevant. Configuration management systems are concerned primarily with maintaining the integrity of software systems and the interoperability of components as they undergo change [ 1201. Minimally, such systems help localize the effects of changes <ref type="bibr" target="#b87">[92]</ref>. On a different scale, work on program dependencies is concerned primarily with the local effects of change, typically within a procedure. Typically, data and control flows within a program are analyzed, thereby identifying the parts that depend on a particular datumlcontrol statement. Such analyses support reuse in many ways: 1) localizing the effects of changes <ref type="bibr" target="#b112">[117]</ref>, <ref type="bibr">[126]</ref>, thus guiding reusers in the process of adapting retrieved components to their needs, 2) simplifying program structures [7 13, which enhances program readability and understandability and 3) "slicing" programs to extract specific functionalities <ref type="bibr" target="#b46">[53]</ref>, <ref type="bibr" target="#b65">[71]</ref>, in case the retrieved component does more than what is required.</p><p>The latter is an interesting dual to reuse by composition (see Section V.B). We should mention, however, that reliable flow analysis depends on a number of restrictive assumptions, such as the absence of side-effects and "global variables" (see, e.g., [ 1171, [ 1261). On the positive side, they help increase the reuse worth of code fragments by automating some of the code modification tasks and do not require the availability of design or analysis information. A combination of macroscopic con-figuration management and microscopic program flow analysis can help reduce the cost of maintaining and reusing software.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. SUMMARY AND DISCUSSION</head><p>Reuse is the default problem-solving strategy in most human activities [ S I , and software development is no exception.</p><p>Software reuse means reusing the inputs, the processes, and the outputs of previous software development efforts. Software reuse is a means toward an end: improving software development productivity and software product quality. Reuse is based on the premise that educing a solution from the statement of a problem involves more effort (labor, computation, etc.) than inducing a solution from that to a similar problem, one for which such efforts have already been expended. While the inherent complexities in software development <ref type="bibr" target="#b19">[26]</ref> make it a good candidate for explorations in reuse, it is far from obvious that actual gains will occur. The challenges are structural, organizational, managerial, and technical. In this paper, we discussed some of the most important issues, with an emphasis on the technical ones. Economic considerations, and costhenefit analyses in general, must be at the center of any discussion of software reuse. Notwithstanding differences between reuse approaches along the building blocks-generative dimension, it is useful to think of software reuse research in terms of attempts to minimize the average cost of a reuse occurrence (see Section III.B.l):</p><formula xml:id="formula_12">[Search + (1 -p) X (ApproxSearch + q x Aduptationold + (1 -q) x Developmentn,)]</formula><p>where Search(ApproxSearch) is the average cost of formulating a search statement to a library of reusable components, and either finding one that matches exactly (approximatively) the requirements, or be convinced that none exists, Adaptation,,, is the average cost of adapting a component returned by approximate retrieval, and Development,, the average cost of developing a component that has no match, exact or approximate, in the library. For reuse to be cost-effective, the above must be smaller than: p X Development,,,, + (1-p) X q X Development,,,,ox + (1p)</p><p>x (1q) X Development,,)</p><p>where Development,,,, and Development,,, represent the average cost of developing custom-tailored versions of components in the library that could have been used as is or adapted, respectively. Note that all these averages are time averages and not averages on individual components, i.e., a reusable component will be counted as many times as it is used.</p><p>Work on developing reusable software aims at maximizing p (probability of finding an exact match) and q (probability of finding an approximate match)--i.e., maximizing the coverage of the application domain-and minimizing Aduptationold for a set of common mismatches, i.e., packaging components in such a way that the most common mismatches are handled easily. Increasing p and 4 does not necessarily mean putting more components in the library; it could also mean putting components that are more frequently needed. Because adding components increases search costs (see Section 1II.B. l), we could use a two-pronged approach: 1) identify components that are generally useful and 2)try to cover the same set of needs with fewer compo-Identifying the components that are generally useful is sometimes called domain analysis and is an important activity for both application generator development (Section IV.B) and 00 software development (Section IV.C). Covering the same set of needs using fewer components involves two paradigms:</p><p>1) abstraction, essential to application generators, and very 2) composition, which is central to 00 software develop-Composition supports the creation of a virtually unlimited number of aggregates from the same set of components and reduces the risk of combinatorial explosion that would result from enumerating all the possible configurations (cf. Section II.C and [149]). In general, the higher the level of abstraction at which composition takes place, the wider the range of systems (and behaviors) that can be obtained (see Section V.B). The combination of abstraction and composition provides a powerful paradigm for constructing systems from reusable components and constitutes the major thrust behind research in 00 frameworks. It also exemplifies the ways in which software reuse addresses the scalability and focus issues in software engineering (see Section I).</p><p>Work on developing with reusable software aims at minimizing the cost of search (exact and approximate) and the cost of adaptation. Minimizing the cost of searches involves a number of trade-offs between the cost of formulating searches (Search and ApproxSearch) and the quality of the retrieval. For instance, the coverage probabilities p and q above should be replaced by smaller probabilities to take into account the less than perfect recall of search methods (see Secti0nV.A). Further, a search method that is not precise (i.e., returns irrelevant components) increases the cost of finding a component by forcing the developer to examine irrelevant components. As a rule of thumb, given a fixed amount of effort to be spent on formulating queries, we can achieve higher recall values only at the expense of lower precision, and vice-versa. To enhance both recall and precision, more effort should be spent formulating queries. We discussed a range of approaches that strike different balances between query complexity and retrieval quality (c.f. SectionV.A.3). However, there is an inherent practical limit to how complex queries can be, beyond which developers will not bother searching. As for adaptation, empirical evidence showed that the cost of modifying components in non-anticipated ways goes up very quickly with the scope and extent of the modifications Transformational systems reduce the first cost by enabling developers to make changes directly at the requirements level and reduce the second cost by propagating such changes in amostly-correctness-preserving way [ 171 (cf. Section V.C).</p><p>How far can we reduce the cost of reuse occurrences? If we achieve full coverage (p = 1) and develop a query language that is perfectly precise and that has perfect recall-that is called a specification language!-then we have achieved widespectrum automatic programming! The generative approach and the building blocks approach to software reuse approach full coverage from two different, but complementary directions, The generative approaches often have a perfect coverage within a subarea of the application domain and need to be extended "horizontally" to cover the entire domain. In order to maintain performance characteristics (e.g., code optimality), different modeldgenerators may be needed to cover a given domain. Conversely, the building blocks approach has the potential to cover an entire domain, but only sparsely so. To fill in the gaps, so to speak, abstract language constructs (e.g., module interconnection languages) are often added, yielding a coarse application-specific specification language whose atoms are concrete application components. As language constructs are added and increasingly abstract representations of components are used, we move progressively toward generative approaches based on very high-level languages [148]. Finally, it is interesting to note that in the context of the building blocks approach, perfect retrieval and effortless adaptation are only possible if the relation between specifications and implementations has been completely formalized. To some extent, software reuse turns the automatic programming problem into several optimization subproblems, allowing us to tackle software automation piecewise.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>2.</head><label></label><figDesc>Booch's C++ components include 18 implementations of dequeues corthe concurrency control algorithm, the memory allocation algorithm, and the ordering algorithm [149].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>the quality of what gets added to the reuse base [ 13 I]. The library team could also play an active role in creating reusable s o h a r e of all forms. Barnes studied the economic models for two such arrangements [IO]:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>[ 66 ]</head><label>66</label><figDesc>. Other 00-induced life cycle changes have been proposed in the literature that are motivated by considerations other than reuse, such as managing the risks inherent in switching to a new development technology [125].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>[95]), (see, e.g., [ 1 131, [ 1 16]), and developers (see, e.g., [47] and [113]).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>(</head><label></label><figDesc>see, e.g., [471, [951, [I 131, [ W ) :</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>8.</head><label></label><figDesc>Such reuse does away with the quality incentive, and may cost resources for debugging and testing. 9. It was found that experts classify program segments along functional lines, while novices classify program segments along syntacticdsuperfcial similarities. Also, experts use a mix of a bottom-up phase, collecting enough clues to formulate a hypothesis (a pakrn), followed by a top-down predictiveherification phase during which they check whether the remaining clues fit in the pattem, while novices use a straight bottom-up strategy, trying to understand programs one line at a time<ref type="bibr" target="#b90">[95]</ref>.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>e.g., [I 11, P21, [891, [ W ) . 16. I.e., are such that for a given two modules M1 and M2, FP(M1 + M2) = FP(M1) + FP(M2).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>2)</head><label></label><figDesc>partially or totally nonprocedural-declarative, graphi-Martin enumerated a number of mostly behavioral properties that application generators should exhibit, including dependent reasonable defaults and cal, etc. [98].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>[114], [154]). The material presented below is based mostly on the work of Levy [89] and Cleaveland [34], describing work at AT&amp;T Bell Labs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Levy identified a c o m e three-step methodology for developing with application generators (what he calls metaprogramming [tis]): velop than with traditional development, etc. [98].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>[ 119]), 3) interactive template-filling, etc. [34]. Defining the products: Generators can generate programs, documentation, tests programs or data, and even input to other generators [34]. Issues such as packaging for readability and/or integration and performance, e.g., are important for code fragments [ 341.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>1)</head><label></label><figDesc>information hiding minimizes the impact of data structure 2) hierarchical classification enables us to handle data spe-Lubars et al. set out to test the claim that 00 models are stable [go]. They define model stability in terms of three properties:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>[ 63 ]</head><label>63</label><figDesc>. The problem of providing different views of objects has been addressed in 00 programming languages for some time (see, e.g., [ 1451, and C++'s three visibility/access modes for class features [152]). Views as a modeling concept have been getting more attention recently (see, e.g., [63], [1221).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>[146]. 21 .</head><label>21</label><figDesc>Hoydalsvik argued that because analysis models should be probledapplication-oriented and design models should be solution-oriented, then any methodology that claims to bridge the two is not doing analysis comtly 22. The CASE tools that support Shlaer and Mellor may offer specific [701.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>23 .</head><label>23</label><figDesc>Theoretically, this flavor is nothing but subtyping. From a programming language point of view, it is a mix of class inheritance and delegation. 24. Roughly speaking, we use a stricter version of the private mechanism as used in C++. Our version makes sure that data fieldslstructures are private to the methods used to access them; no other method, even ones belonging to the same class, can access them [ 11 11.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>in the class space is characterized by a description represented as a predicate D d . ) such that all (and only) instances Y of the class C are such that DdY) is true. As mentioned above, encoding generally results into a loss of information by replacing the actual description Dc of a class C by a "simpler" description Dc(.). Accordingly, retrieval takes place by comparing Q(.) (the developer query) to the approximate descriptions of component classes ( Dc(.) s). We distinguish between two basic matching approaches: 1) partial-order-based retrieval: The retrieval algorithm returns classes of items such that Dd.) LT Q(.), for some partial-order relation LT. Notice that in practice</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>(.) LT e(.)) 4 (Dc(.) LT Q</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>[ 62 ]</head><label>62</label><figDesc>, Hall describes a component retrieval method that explores combinations of components when none of the individual components matches the user query. Users specify the desired behavior by giving an example input-output pair 4, 0 &gt;. The idea of retrieving components based on the output they actually produce when executed on a user-supplied input was first proposed by Podgurski and Pierce [127]. Hall extends Podgurski and Pierce's work by 33. Action equations am. essentially predicates. However, they do contain some control information such as iteration and sequencing.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Altemative compositions that could be considered by the composition retrieval algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>h i i d l e co ponent specitcationFig. 5 .</head><label>5</label><figDesc>Fig. 5. The component modification problem.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head></head><label></label><figDesc>[8]. According to this view, the complexity of software development lies not in the individual transformations, but in applying the "right" transformation when several alternatives are possible. Existing transformational systems provide varying levels of support for selecting the "right" transformations, ranging from simply enacting/executing transformations chosen by the developer to full automation [8], [ 1231.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Typical software life cycle in transformational system. Adapted from [l].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head></head><label></label><figDesc>what changes need to be made and 2) verifying and validating the component after the change.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Manuscript received April 1992; revised August 1993. H. Mili is with the Departement d'hformatique, universite du Quebec it</figDesc><table><row><cell>Montreal, Boite Postale 8888, Succ "A", Montreal, Quebec, H3C 3P8 Can-</cell></row><row><cell>ada.</cell></row><row><cell>F. Mili is with the School of Engineering and Computer Science, Oakland</cell></row><row><cell>University, Rochester, MI 483094401,</cell></row></table><note><p>A. Mili is with the Department of Computer Science, University of Ottawa, Ottawa, Ontario KIN 6N5 Canada. IEEECS Log Number S95009.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>and Level hvironmenta Supplier-Related Customer-Related Knowledge Knowledge</head><label></label><figDesc></figDesc><table /><note><p>or designs, as in application generators or the Programmer Apprentice's clich6s [137], duced andor used, cretehplemented)</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE II A</head><label>II</label><figDesc>CATEGORIZATION OF COMMON REUSE APPROACHES</figDesc><table><row><cell></cell><cell>I</cell><cell></cell><cell>I</cell><cell>Mappin!</cell><cell>howledge</cell><cell></cell><cell></cell></row><row><cell>Approach</cell><cell>Life Cycle</cell><cell>Covering</cell><cell>Description</cell><cell>Covering</cell><cell>Description</cell><cell>Spectrum</cell><cell>Examples</cell></row><row><cell></cell><cell>Stage</cell><cell></cell><cell>Type</cell><cell></cell><cell>Type</cell><cell></cell><cell></cell></row><row><cell>Source code</cell><cell>mostly de-</cell><cell>partial</cell><cell>composi-</cell><cell>partial</cell><cell>composition</cell><cell>wide spec-</cell><cell>RSL</cell></row><row><cell>components</cell><cell>sign</cell><cell></cell><cell>tional</cell><cell></cell><cell>al (mostly)</cell><cell>trum</cell><cell></cell></row><row><cell>(see [501,</cell><cell></cell><cell></cell><cell>(mostly)</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>~3 1 )</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>software</cell><cell>mostly de-</cell><cell>partial</cell><cell>composi-</cell><cell>partial</cell><cell>composi-</cell><cell></cell><cell></cell></row><row><cell>schemas (see</cell><cell>sign</cell><cell></cell><cell>tional</cell><cell>(mostly)</cell><cell>tional</cell><cell></cell><cell></cell></row><row><cell>e.g. [83], or</cell><cell></cell><cell></cell><cell>(mostly)</cell><cell></cell><cell>(mostly)</cell><cell></cell><cell></cell></row><row><cell>referred to as</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>reusable</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>program</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>patterns in</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>[77])</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Reusable</cell><cell>software</cell><cell>complete</cell><cell>composi-</cell><cell>partial</cell><cell>composi-</cell><cell></cell><cell></cell></row><row><cell>trans-</cell><cell>specifi-</cell><cell></cell><cell>tional</cell><cell></cell><cell>tional</cell><cell></cell><cell></cell></row><row><cell>formation</cell><cell>cations</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>systems (see</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>e.g. [191,</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>[501)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>, Arango et al. [4], and Baxter [ 171. They are discussed in more detail in 8V.C. Unix's Yacc, a number of commercial tools in business information processing (see e.g.[69] for a survey), a number of user interface building frameworks (see e.g. [ 1191 for a survey), etc. Discussed in more detail in 8V.B.</figDesc><table><row><cell>Application</cell><cell>User re-</cell><cell>complete</cell><cell>enumerated</cell><cell>complete</cell><cell>narrow, do-</cell><cell>narrow,</cell></row><row><cell>generators</cell><cell>quirements</cell><cell></cell><cell>(mostly)</cell><cell></cell><cell>main-</cell><cell>domain-</cell></row><row><cell>(see e.g.</cell><cell>complete</cell><cell></cell><cell></cell><cell></cell><cell>specific</cell><cell>specific</cell></row><row><cell>1831)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Very high-</cell><cell>software</cell><cell>complete</cell><cell>Emphatic-</cell><cell>complete</cell><cell>composi-</cell><cell>depends on</cell></row><row><cell>level lan-</cell><cell>specifi-</cell><cell></cell><cell>a&amp; com-</cell><cell></cell><cell>tional</cell><cell>the system</cell></row><row><cell>guages ~3 1 ,</cell><cell>cations</cell><cell></cell><cell>posi-tional</cell><cell></cell><cell></cell><cell></cell></row><row><cell>reusable</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>processor</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>1771. etc</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">for expressing</cell><cell></cell></row><row><cell cols="6">compositions moves up in terms of abstraction. This corresponds</cell><cell></cell></row><row><cell cols="6">closely to Simos's "reuse life cycle," which prescribes an evolution</cell><cell></cell></row><row><cell cols="6">of reuse approaches within organizations, following the maturing</cell><cell></cell></row><row><cell cols="6">of both the application domain and the expertise of developers</cell><cell></cell></row><row><cell cols="2">within that domain [ 1481.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note><p><p><p><p><p><p><p>Simos' ASL are application-specific languages</p>[148]</p>, PAISLey</p><ref type="bibr" target="#b131">[162]</ref> </p>SETL</p><ref type="bibr" target="#b77">[82]</ref> </p>and others are based on application-independent mathematical and computational abstractions. T}.TE.LP.ls 2.ce Table 2. A categorization of common reuse approaches..LP.sp.PP automation is achieved with application generators and very highlevel languages. With very high-level languages, automation is possible at the cost of code efficiency and design quality; very high-level languages are not intended to implement production quality software. Automation is possible with application generators because of a restriction of the application domain.' The restriction has the added advantage of making it practical to enumerate a set of template software specifications (or the correspondquirements It is fair to say that as we go down Table U, the focus shi&amp; f b m components to composition, and the language</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>[951, [103l.</head><label></label><figDesc></figDesc><table><row><cell>with only a sketchy understanding of how they work [95];</cell></row><row><cell>whether that is desirable or not is another issue.*</cell></row><row><cell>Program understanding involves the recognition of high-</cell></row><row><cell>level abstract patterns amid complex and detailed structures.</cell></row><row><cell>Studies have shown that experts and novices use different ap-</cell></row><row><cell>proaches to program understanding9 suggesting that reusers</cell></row><row><cell>and maintainers may need training in program understanding</cell></row><row><cell>or the support of tools that help them understand programs</cell></row><row><cell>1471,</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="28" xml:id="foot_0"><p>For example, we can compare graphical representations of programs obtained through data and control flow analysis, see, e.g.,<ref type="bibr" target="#b81">[86]</ref>.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>Some of the material in Sections III.A.3 and IV.C benefited from discussions and joint work with Robert Godin (professor of computer science, University of Quebec at Montreal), Gregor Bochmann (professor of computer science, University of Montrtal), and Piero Colagrosso (Bell Northern Research). Some of the background material for Section V.B was collected and compiled by Hassan Alaoui, a PhD student; the complexity results and algorithms for finding function realizations based on types are due to Odile Marcotte (professor of computer science, University of Quebec at Montrkal). H. Mili was supported by grants from the Centre de Technologie Tandem de Montreal (C'ITM), a division of Tandem Computers Inc., Cupertino, Calif, the Natural Sciences and Engineering Research Council (NSERC) of Canada, and the Fonds pour la Creation et 1'Aide B la Recherche (FCAR) of Qutbec, and Centre de Recherche en Informatique de Montrtal (CRIM) through the MACROSCOPE initiative and the Quebec Ministry of Higher Education's SYNERGIE programme (IGLOO Project). F. Mili was supported by grants from the National Science Foundation, and the School of Engineering and Computer Science, Oakland University. A. Mili was supported by grants from NSERC and the School of Graduate Studies and Research of the University of Ottawa (Ottawa, Canada).</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Hafedh Milli is an associate professor of computer science at the University of Quebec in Motreal, Canada He holds an engineering diploma from the Ecole Central de Paris, Paris, France, which was awarded in 1984, and a PhD in computer science from George Washington University, Washington, DC, which he earned in 1988  His research interests include object orientation, software reuse, information retrieval, and knowledge representation He has been leading or participating in a number of government-and industry-sponsored (BNR, IBM, DEC, Tandem Computers, CAE Electronics, DMR Group, National Bank of Canada, etc ) R&amp;D projects in the area of object orientation and software reuse He is founder and president of INFORMILI, Inc , a computer services company that specializes in training and consulting in 00 and software reuse. His research interests are in software engineering, ranging from the technical to the managerial aspects of the discipline.</p><p>His latest book, coauthored by J. Desharnais and F. Mili, deals with the mathematics of program construction. It is published by Oxford University Press, New York.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">What are the new paradigms?</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Agresti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">New Paradigms for Software Developynt</title>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Agresti</surname></persName>
		</editor>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="6" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Framework for a flexible development process</title>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">W</forename><surname>Agresti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">W</forename><surname>Agresti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Aksit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bergmans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">New Paradigms for Software Development</title>
		<meeting><address><addrLine>Vancouver, B.C., Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992">Oct. 18-22.1992</date>
		</imprint>
	</monogr>
	<note>Proc. OOPSLA &apos;92</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Software maintenance by transformation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Arango</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ira</forename><surname>Baxter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Freeman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pidgeon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Softwure</title>
		<imprint>
			<biblScope unit="page" from="27" to="39" />
			<date type="published" when="1986-05">May 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Domain engineering for software reuse</title>
		<author>
			<persName><forename type="first">G</forename><surname>Arango</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
		<respStmt>
			<orgName>Dept. Information and Computer Science, Univ. of California</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Cost-estimation models for the reuse and prototype software development</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">L</forename><surname>Stepoway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Balda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Gustafson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Balzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Cheatham</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Green</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. COMPCON S&apos;87</title>
		<meeting>COMPCON S&apos;87</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="1983-11">July 1990. Nov. 1983</date>
			<biblScope unit="page" from="39" to="45" />
		</imprint>
	</monogr>
	<note>Computer</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A 15 year perspective on automatic programming</title>
		<author>
			<persName><forename type="first">R</forename><surname>Balzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Engineering</title>
		<imprint>
			<biblScope unit="volume">268</biblScope>
			<biblScope unit="page" from="1" to="257" />
			<date type="published" when="1985-11">Nov. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A framework and economic foundation for software reuse</title>
		<author>
			<persName><forename type="first">B</forename><surname>Barnes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Durek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gaffney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pyster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Workshop Software Reusabiliry and Muintuinabiliry</title>
		<meeting>Workshop Software Reusabiliry and Muintuinabiliry</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Making reuse cost-effective</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">H</forename><surname>Barnes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">B</forename><surname>Bollinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="13" to="24" />
			<date type="published" when="1991-01">Jan. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The software engineering laboratory-an operational software experience</title>
		<author>
			<persName><forename type="first">V</forename><surname>Basili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Caldiera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Mcgany</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pajerski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Page</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Waligora</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th lnt &apos;1 Con5 Softwure Engineering</title>
		<meeting>14th lnt &apos;1 Con5 Softwure Engineering<address><addrLine>Melbourne, Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992">May 11-15,1992</date>
			<biblScope unit="page" from="370" to="381" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Software process evolution at the SE</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">R</forename><surname>Basili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Green</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Sofrwure</title>
		<imprint>
			<biblScope unit="page" from="58" to="66" />
			<date type="published" when="1994-07">July 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Viewing maintenance as reuse-oriented software development</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">R</forename><surname>Basili</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Softwure</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="19" to="25" />
			<date type="published" when="1990-01">Jan. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The future engineering of software: A management perspective</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">R</forename><surname>Basili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Musa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="90" to="96" />
			<date type="published" when="1991-09">Sept. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Incremental class dictionary leaming and optimization</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Bassett ; Softwure</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">D</forename><surname>Baxter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bergstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">J</forename><surname>Lieberherr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Biggerstaff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Richter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ECOOP &apos;91</title>
		<meeting>ECOOP &apos;91<address><addrLine>Geneva, Switzerland</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1986">July 1987. 1986. 1987. July 1987. Apr. 1992</date>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="73" to="89" />
		</imprint>
	</monogr>
	<note>Comm ACM</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">An eviuation of retrieval effectiveness for a full-text</title>
		<author>
			<persName><forename type="first">D</forename><surname>Blair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Maron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Document-Retrieval System Comm ACM</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A spiral model of software development and enhancement</title>
		<author>
			<persName><forename type="first">B</forename><surname>Boehm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="61" to="72" />
			<date type="published" when="1988-05">May 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Improving software productivity</title>
		<author>
			<persName><forename type="first">B</forename><surname>Boehm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Softwure</title>
		<imprint>
			<biblScope unit="page" from="43" to="57" />
			<date type="published" when="1987-09">Sept. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Megaprogramming</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">W</forename><surname>Boehm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computer Science Con$. Phoenix, Ariz</title>
		<imprint>
			<date type="published" when="1994-02">Feb. 1994</date>
		</imprint>
	</monogr>
	<note>Keynote speech</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">An overview of the KL-ONE knowledge representation system</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Brachman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Schmolze</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cognitive Science</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="171" to="216" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Object Oriented Concepts, Databases, and Applications</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bretl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Otis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Penney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schuchardt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">H</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Williams</surname></persName>
		</author>
		<editor>W. Kim</editor>
		<imprint>
			<date type="published" when="1985">1989. Mar. 1985</date>
			<publisher>Addison Wesley</publisher>
			<biblScope unit="page" from="289" to="299" />
		</imprint>
	</monogr>
	<note>The Gemstone data management system</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">No silver bullet: Essence and accidents of software engineering</title>
		<author>
			<persName><forename type="first">F</forename><surname>Brooks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="page" from="10" to="19" />
			<date type="published" when="1987-04">Apr. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The reusable software library</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Burton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Aragon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Bailey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">D</forename><surname>Koehler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Mayes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="page" from="25" to="33" />
			<date type="published" when="1987-07">July 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Identifying and qualifying reusable software components</title>
		<author>
			<persName><forename type="first">G</forename><surname>Caldiera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">R</forename><surname>Basili</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="61" to="70" />
			<date type="published" when="1991-02">Feb. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Derivational analogy in problem solving and knowledge acquisition</title>
		<author>
			<persName><forename type="first">J</forename><surname>Carbonell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Int&apos;l Machine Learning Workshop</title>
		<imprint>
			<date type="published" when="1983-06">June 1983</date>
			<pubPlace>Monticello, Ill.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Deriving modular designs from formal specifications</title>
		<author>
			<persName><forename type="first">D</forename><surname>Carrington</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Duke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Hayes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Welsh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. First ACM SIGSOFT Symp. Foundations mf Software Engineering</title>
		<title level="s">Software Engineering Notes</title>
		<meeting>First ACM SIGSOFT Symp. Foundations mf Software Engineering<address><addrLine>Los Angeles, Calif</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-07-10">Dec. 7-10, 1993</date>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="89" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">The process of 00 design</title>
		<author>
			<persName><forename type="first">D</forename><surname>De Champeaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Faure</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OOPSLA &apos;92</title>
		<meeting>OOPSLA &apos;92<address><addrLine>Vancouver, B.C., Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992">Oct. 18-22.1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">On the retrieval of reusable components</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Shicheng Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hennicker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jarke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Selected Papers from the Second Int &apos;1 Workshop on Software, Reusability Advances in Software</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Enhancing compositional reachability analysis with context constraints</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kramer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. First ACM SIGSOFT Symp. on the Foundations of Sofrware Engineering</title>
		<title level="s">Software Engineering Notes</title>
		<meeting>First ACM SIGSOFT Symp. on the Foundations of Sofrware Engineering<address><addrLine>Los Angeles, Calif</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-07-10">Dec. 7-10, 1993</date>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="115" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Building application generators</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">T</forename><surname>Cleaveland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Sofrware</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Coad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Yourdon</surname></persName>
		</author>
		<title level="m">Object Oriented Analysis</title>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
	<note>second edition</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">RE On the purpose of 00 analysis</title>
		<author>
			<persName><forename type="first">P</forename><surname>Coad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OOPSLA&apos;93</title>
		<meeting>OOPSLA&apos;93<address><addrLine>Washington, D.C</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993">Sept. 26 -Oct. 1, 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Interfaces and specifications for the Smalltalk-80 collection classes</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">R</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OOPSLA&apos;92</title>
		<meeting>OOPSLA&apos;92<address><addrLine>Vancouver, B.C., Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Object Oriented Programmhg: An Evolutionary Approach</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">J</forename><surname>Cox</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
			<publisher>Addison Wesley</publisher>
			<pubPlace>Reading, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Planning the software revolution</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">J</forename><surname>Cox</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Sofrware</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="25" to="35" />
			<date type="published" when="1990-11">Nov. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">The software factory: A historical interpretation</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Cusumano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEESoftware</title>
		<imprint>
			<biblScope unit="page" from="23" to="30" />
			<date type="published" when="1989-03">Mar. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Simula common base language</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Dahl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nygaard</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1970">1970</date>
			<publisher>Norvegian Computing Center</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical report S-22</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">The reuse capability model: A basis for improving an organization&apos;s reuse capability</title>
		<author>
			<persName><forename type="first">T</forename><surname>Davis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advances in Sofmare Reuse, Selected Papers from the Second Int&apos;l Workshop on Software Reusability Advances in Soffware Reuse</title>
		<imprint>
			<biblScope unit="page" from="24" to="26" />
			<date type="published" when="1993-03">Mar. 1993</date>
			<pubPlace>Lucca, Italy</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Design reuse and frameworks in the Smalltalk-80 programming system</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">P</forename><surname>Deutsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software Reusability</title>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Il</surname></persName>
		</editor>
		<editor>
			<persName><surname>Perlis</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1989">1989</date>
			<publisher>ACM Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">On the cruelty of really teaching computer science</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm ACM</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="398" to="399" />
			<date type="published" when="1989-12">Dec. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Reuse in the context of a transformation-based methodology</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Feather</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">l7T Proc. Workshop on Reusability in Programming</title>
		<imprint>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="50" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Object oriented and conventional analysis and design methodologies: Comparison and critique</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Fichman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">F</forename><surname>Kemerer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="22" to="39" />
			<date type="published" when="1992-10">Oct. 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Cognitive view of reuse and design</title>
		<author>
			<persName><forename type="first">G</forename><surname>Fischer</surname></persName>
		</author>
		<imprint>
			<publisher>IEEE</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">An information system for software reuse</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">B</forename><surname>Frakes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Nejmeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Reuse: Emerging Technology</title>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">An empirical study of representation methods for reusable software components</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">B</forename><surname>Frakes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Pole</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Productivity Consortium</title>
		<meeting><address><addrLine>Hemdon, Va</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992-05">May, 1992</date>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Report</note>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Reusable software engineering: Concepts and research directions</title>
		<author>
			<persName><forename type="first">P</forename><surname>Freeman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Tutorial: Software Reusability</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Freeman</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="page" from="10" to="23" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">The failure of pattem languages</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Gabriel</surname></persName>
		</author>
		<idno>18-22. 60-72</idno>
	</analytic>
	<monogr>
		<title level="j">J. Object Orientedriented Programming</title>
		<imprint>
			<biblScope unit="page" from="142" to="151" />
			<date type="published" when="1987-07">Feb. 1994. Mar. 24-26.1993. July 1988. Oct. July 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">A general economics model of software reuse</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Gaffney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Cruickshank</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th Int&apos;l Con$ Software Eng</title>
		<meeting>14th Int&apos;l Con$ Software Eng<address><addrLine>Melbourne, Australia</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1992">May 11-15. 1992</date>
			<biblScope unit="page" from="327" to="337" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Using program slicing in software maintenance</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">B</forename><surname>Gallagher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Lyle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Engineering</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">8</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m" type="main">Computers and intractability</title>
		<author>
			<persName><forename type="first">M</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName><surname>Johnson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<publisher>Freeman</publisher>
			<pubPlace>San Francisco</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Class management for software communities</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gibbs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tsichritzis</surname></persName>
		</author>
		<author>
			<persName><surname>Casais</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Nierstrasz</surname></persName>
		</author>
		<author>
			<persName><surname>Pintado</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">9</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Building and maintaining analysis-level class hierarchies using galois lattices</title>
		<author>
			<persName><forename type="first">R</forename><surname>Godin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mili</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM S I G P M Notices</title>
		<imprint>
			<biblScope unit="page">93</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title level="m">Proc</title>
		<meeting>null<address><addrLine>Washington, D.C</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993">Sept. 26 -Oct. 1, 1993</date>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="394" to="410" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Reusing and interconnecting software components</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Goguen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="page" from="16" to="28" />
			<date type="published" when="1986-02">Feb. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Information models, views, and controllers</title>
		<author>
			<persName><forename type="first">A</forename><surname>Goldberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Dr. Dobb&apos;s</title>
		<imprint>
			<date type="published" when="1990-07">July 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Early reuse practice lives up to its promise</title>
		<author>
			<persName><forename type="first">G</forename><surname>Gruman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Sopware</title>
		<imprint>
			<biblScope unit="page" from="87" to="91" />
			<date type="published" when="1988-11">Nov. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">An overview of the Larch family of specification languages</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">V</forename><surname>Guttag</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Homing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Wing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Sofrware</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="24" to="36" />
			<date type="published" when="1985-09">Sept. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<title level="m" type="main">Selected Papers from the Second Inr &apos;I Workshop on Sofrware Reusability Advances in Software Reuse</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Weedon</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">Mar. 24-26.1993</date>
			<publisher>IEEE C S Press</publisher>
			<biblScope unit="page" from="29" to="38" />
			<pubPlace>Lucca, Italy</pubPlace>
		</imprint>
	</monogr>
	<note>Object oriented module interconnection languages</note>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Generalized behavior-based retrieval</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Hall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th Int&apos;l Con$ Software Eng</title>
		<meeting>15th Int&apos;l Con$ Software Eng<address><addrLine>Baltimore, Md.</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1993">May 17-21, 1993</date>
			<biblScope unit="page" from="371" to="380" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Subject-oriented programming: A critique of pure objects</title>
		<author>
			<persName><forename type="first">W</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ossher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGPLAN Notices Proc. OOPSLA &apos;93</title>
		<meeting><address><addrLine>Washington D.C.</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993">Sept. 26 -Oct. 1,1993</date>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="411" to="428" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<monogr>
		<author>
			<persName><forename type="first">B</forename><surname>Harvey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kilov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mili</surname></persName>
		</author>
		<title level="m">Specification of behavioral semantics in 00 information modeling: Workshop report</title>
		<imprint>
			<publisher>ACM Press</publisher>
		</imprint>
	</monogr>
	<note>OOPS Messenger Addendum to the OOPSLA &apos;93 Proc.</note>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Contracts: Specifying behavioral compositions in 00 systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Helm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Holland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gangopadhyay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OOPSLA &apos;90</title>
		<meeting>OOPSLA &apos;90</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">The 00 system life cycle</title>
		<author>
			<persName><forename type="first">B</forename><surname>Henderson-Sellers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Edwards</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="143" to="159" />
			<date type="published" when="1990-09">Sept. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<monogr>
		<title level="m" type="main">Object oriented computing: Looking ahead to the year 2000</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Holt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Stanhope</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lausman</surname></persName>
		</author>
		<idno>ITRC TR-9101</idno>
		<imprint>
			<date type="published" when="1991-04">Apr. 1991</date>
		</imprint>
		<respStmt>
			<orgName>Information Technology Research Center, Univ. of Toronto</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">An expansive view of reusable software</title>
		<author>
			<persName><forename type="first">E</forename><surname>Horowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Munson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans, Software Engineering</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="477" to="487" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">A survey of application generators</title>
		<author>
			<persName><forename type="first">E</forename><surname>Horowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kemper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Narasimhan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEESoftware</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="1985-01">Jan. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">On the purpose of 00 analysis</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Hoydalsvik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sindre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OOPSLA &apos;93</title>
		<meeting>OOPSLA &apos;93<address><addrLine>Washington, D.C.</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1993">Sept. 26-Oct. 1, 1993</date>
			<biblScope unit="page" from="240" to="255" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">State constraints and pathwise decomposition of programs</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">iEEE Trans. Software Engineering</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="880" to="898" />
			<date type="published" when="1990-08">Aug. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<monogr>
		<title level="m" type="main">Getting more out of your classes: Building families of programs in OOP</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Intrator</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mili</surname></persName>
		</author>
		<idno>no. 234</idno>
		<imprint>
			<date type="published" when="1994-05-13">May 13. 1994</date>
		</imprint>
		<respStmt>
			<orgName>Dept. Maths and Computer Science, Univ. of Quebec at Montreal</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech report</note>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Experience report on a software reuse project: Its structure, activities, and statistical results</title>
		<author>
			<persName><forename type="first">S</forename><surname>Isoda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th Int&apos;l Con$ Software Engineering</title>
		<meeting>14th Int&apos;l Con$ Software Engineering<address><addrLine>Melboume, Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992">May 11-15, 1992</date>
			<biblScope unit="page" from="320" to="326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<monogr>
		<title level="m" type="main">Object Oriented Software Engineering: A Use Case Driven Approach</title>
		<author>
			<persName><forename type="first">I</forename><surname>Jacobson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>ACP Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Documenting frameworks using patterns</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OOPSLA &apos;92</title>
		<meeting>OOPSLA &apos;92<address><addrLine>Vancouver, B.C.</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1992">Oct. 18-22, 1992</date>
			<biblScope unit="page" from="63" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<monogr>
		<title level="m" type="main">MethodologylEnvironment Support for Reusability</title>
		<author>
			<persName><forename type="first">G</forename><surname>Jones</surname></persName>
		</author>
		<editor>Will Tracz</editor>
		<imprint>
			<date type="published" when="1990">Aug. 1991. 1990</date>
			<publisher>IEEE CS Press</publisher>
			<biblScope unit="page" from="90" to="103" />
		</imprint>
	</monogr>
	<note>Software Reuse: Emerging Technology</note>
</biblStruct>

<biblStruct xml:id="b71">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Canada</forename><surname>Ottawa</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">Oct. 22-25.1990.. 190-193, 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Reusability in programming: A survey of the state of the art</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Capers</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Engineering</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="488" to="494" />
			<date type="published" when="1984-09">Sept. 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Melding software systems from reusable building blocks</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Kaiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Garlan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="page" from="17" to="24" />
			<date type="published" when="1987-07">July 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">A reuse-based software development methodology</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">C</forename><surname>Kang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Sopware Reuse: Emerging Technology, Will Tracz</title>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page">194196</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">PARIS: A system for reusing partially interpreted schemas</title>
		<author>
			<persName><forename type="first">S</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Richter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">4</forename><surname>The</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Ninth Int&apos;l Con$ on Software Eng</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">Issues in the design and documentation of class libraries</title>
		<author>
			<persName><forename type="first">G</forename><surname>Kiczales</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lamping</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OOPSLA &apos;92 SIGPLAN Notices</title>
		<meeting>OOPSLA &apos;92 SIGPLAN Notices<address><addrLine>Vancouver, B.C</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1992">Oct. 18-22.1992</date>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="435" to="451" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">Software prototyping using the SETL programming language</title>
		<author>
			<persName><forename type="first">P</forename><surname>Kruchten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Schonberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schwartz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<monogr>
		<title level="m" type="main">Software reuse</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Krueger</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992-06">June 1992</date>
			<publisher>ACM Computing Surveys, ACM Press</publisher>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="131" to="183" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">Specifying modules to satisfy interfaces: A state transition system approach</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">U</forename><surname>Shankar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">Software engineering with reusable designs and code</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Lanergan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Grasso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Engineering</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="498" to="501" />
			<date type="published" when="1984-09">Sept. 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<monogr>
		<title level="m" type="main">Selected Papers from the Second Int&apos;l Workshop on Software Reusability Advances in Software Reuse</title>
		<author>
			<persName><forename type="first">J</forename><surname>Laski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Szermer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">Mar. 24-26, 1993</date>
			<publisher>IEEE CS Press</publisher>
			<biblScope unit="page" from="134" to="141" />
			<pubPlace>Lucca, Italy</pubPlace>
		</imprint>
	</monogr>
	<note>Regression analysis of reusable program components</note>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">Christopher Alexander: An introduction for 00 designers</title>
		<author>
			<persName><forename type="first">D</forename><surname>Lea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Software Engineering Notes</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="39" to="46" />
			<date type="published" when="1994-01">Jan. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">CYC: Toward programs with common sense</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Lenat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">V</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pittman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pratt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shepherd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM, special issue on Natural Language Processing</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="30" to="49" />
			<date type="published" when="1990-08">Aug. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">A metapcogramming method and its economic justification</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">S</forename><surname>Levy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. SofWure Engineering</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="272" to="277" />
			<date type="published" when="1986-02">Feb. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">Object oriented analysis for evolving systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Lubars</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Meredith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Potts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Richter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th Int&apos;l Conference on Software Engineering</title>
		<meeting>14th Int&apos;l Conference on Software Engineering<address><addrLine>Melbourne, Australia</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1992">May 11-15, 1992</date>
			<biblScope unit="page" from="173" to="185" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<monogr>
		<title level="m" type="main">Wide-spectrum support for software reusability software reuse: Emerging technology</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Lubars</surname></persName>
		</author>
		<editor>W. Tracz</editor>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>IEEE CS Press</publisher>
			<biblScope unit="page" from="275" to="281" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">A Graph Model for Software Evolution</title>
		<author>
			<persName><surname>Luqi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Engineering</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="917" to="927" />
			<date type="published" when="1990-08">Aug. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">An information retrieval approach for automatically constructing software libraries</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">S</forename><surname>Yoelle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Maarek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Kaiser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Engineering</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="800" to="813" />
			<date type="published" when="1991-08">Aug. 199 1</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<analytic>
		<title level="a" type="main">Exploiting reusable specifications through analogy</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">A</forename><surname>Maiden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Sutcliffe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="55" to="64" />
			<date type="published" when="1992-04">Apr. 1992</date>
		</imprint>
	</monogr>
	<note>Special issue on CASE</note>
</biblStruct>

<biblStruct xml:id="b90">
	<analytic>
		<title level="a" type="main">People-oriented software reuse: the very thought</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">A</forename><surname>Maiden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sutcliffe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Second Int&apos;l Workshop on Software Reuse</title>
		<imprint>
			<biblScope unit="page" from="176" to="185" />
			<date type="published" when="1993">March 24-26, 1993</date>
			<pubPlace>PressLucca, Italy</pubPlace>
		</imprint>
	</monogr>
	<note>Computer</note>
</biblStruct>

<biblStruct xml:id="b91">
	<analytic>
		<title level="a" type="main">Constraint technology for user-interface construction in ThingLab 11</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Maloney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Boming</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">N</forename><surname>Freeman-Benson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OOPSLA &apos;89</title>
		<meeting>OOPSLA &apos;89</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1989-10">Oct. 1989</date>
			<biblScope unit="page" from="381" to="388" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title level="a" type="main">Software reuse economics: cost-benefit analysis on a large-scale ada project</title>
		<author>
			<persName><forename type="first">J</forename><surname>Margono</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">E</forename><surname>Rhoads</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th Int&apos;l Conference on Software Engineering</title>
		<meeting>14th Int&apos;l Conference on Software Engineering<address><addrLine>Melbourne, Australia</addrLine></address></meeting>
		<imprint>
			<date>May 11-15</date>
			<biblScope unit="page" from="338" to="348" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<monogr>
		<title level="m" type="main">Fourth Generation Languages-Volume I: Principles</title>
		<author>
			<persName><surname>Martin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b94">
	<monogr>
		<title level="m" type="main">A Software Factory: An Overall Approach to Software Production Tutorial: Software Reusability</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Matsumoto</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984">1987. 1987. Oct. 1984. 39-63,1992</date>
			<biblScope unit="page" from="66" to="75" />
		</imprint>
	</monogr>
	<note>d. P. Freeman, E E E Press</note>
</biblStruct>

<biblStruct xml:id="b95">
	<monogr>
		<title level="m" type="main">Selected Papers from the Second Int&apos;l Workshop on Software Reusability Advances in Sofrivare Reuse</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Matsumoto</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">March 24-26. 1993</date>
			<publisher>IEEE CS Press</publisher>
			<biblScope unit="page" from="186" to="195" />
			<pubPlace>Lucca, Italy</pubPlace>
		</imprint>
	</monogr>
	<note>%Experiences from software reuse. in industrial process control applications</note>
</biblStruct>

<biblStruct xml:id="b96">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Mccain</surname></persName>
		</author>
		<title level="m">A software development methodology for reusable components Proc. 18th Hawaii Conference on Systems Sciences</title>
		<meeting><address><addrLine>Hawaii</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985-01">Jan. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b97">
	<analytic>
		<title level="a" type="main">MEDLINE: an introduction to on-line searching</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Mccam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. American Society for Information Science</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="181" to="192" />
			<date type="published" when="1980-05">May 1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b98">
	<monogr>
		<title level="m" type="main">The three R s of software automation: re-engineering, repository, Reusability</title>
		<author>
			<persName><forename type="first">C</forename><surname>Mcclure</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b99">
	<analytic>
		<title level="a" type="main">Mass produced software components</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mcilroy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Engineering Concepts and Techniques, 1968 NATO Conference on Software Engineering</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Buxton</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Naur</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Randell</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>PetrocelWCharter</publisher>
			<date type="published" when="1969">1969</date>
			<biblScope unit="page" from="88" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b100">
	<analytic>
		<title level="a" type="main">The Shlaer-Mellor Method</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mellor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tutorial notes, OOPSLA&apos;93</title>
		<meeting><address><addrLine>Washington, D.C</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1993">Sept. 26 -Oct. 1. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b101">
	<monogr>
		<title level="m" type="main">Object oriented software construction</title>
		<author>
			<persName><forename type="first">B</forename><surname>Meyer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>Prentice-Hall Int&apos;l</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b102">
	<analytic>
		<title level="a" type="main">Lessons from the design of the eiffel libraries</title>
		<author>
			<persName><forename type="first">B</forename><surname>Meyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Communications of the ACM</title>
		<imprint>
			<date type="published" when="1990-09">Sept. 1990</date>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="69" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b103">
	<analytic>
		<title level="a" type="main">Storing and retrieving software components: a refinement-bad approach</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mitlenneir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 16th Int&apos;l Con$ on Software Engineering</title>
		<meeting>16th Int&apos;l Con$ on Software Engineering<address><addrLine>Sorrento, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994-05">May 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b104">
	<analytic>
		<title level="a" type="main">An 00 model based on relations</title>
		<author>
			<persName><forename type="first">H</forename><surname>Mili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sibert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Intrator</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Systems and Software</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="139" to="155" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b105">
	<analytic>
		<title level="a" type="main">Building a graphical interface for an 00 tool for software reuse</title>
		<author>
			<persName><forename type="first">H</forename><surname>Mili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">E El</forename><surname>Wahidi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Intrator</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. TOOLS LISA &apos;92</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Meyer</surname></persName>
		</editor>
		<meeting>TOOLS LISA &apos;92<address><addrLine>Santa Barbara, Calif</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992-06">Aug. 2-6.1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b106">
	<analytic>
		<title level="a" type="main">Data abstraction in softclass, an 00 case tool for software reuse</title>
		<author>
			<persName><forename type="first">H</forename><surname>Mili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. TOOLS &apos;93</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Meyer</surname></persName>
		</editor>
		<meeting>TOOLS &apos;93<address><addrLine>Santa-Barbara. CA</addrLine></address></meeting>
		<imprint>
			<publisher>Pcentice-Hall</publisher>
			<date>Aug. 2-5</date>
			<biblScope unit="page" from="133" to="149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b107">
	<analytic>
		<title level="a" type="main">Intelligent component retrieval for software reuse</title>
		<author>
			<persName><forename type="first">H</forename><surname>Mili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Marcotte</surname></persName>
		</author>
		<author>
			<persName><surname>Kabbaj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd Maghrebian Con$ on Artificial Intelligence, and Software Engineering</title>
		<meeting>3rd Maghrebian Con$ on Artificial Intelligence, and Software Engineering<address><addrLine>Morocco</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994-11-14">Apr. 11-14, 1994</date>
			<biblScope unit="page" from="101" to="114" />
		</imprint>
	</monogr>
	<note>Rabat</note>
</biblStruct>

<biblStruct xml:id="b108">
	<analytic>
		<title level="a" type="main">Practitioner and Softclass: A Comparative Study of Two Software Reuse Research Projects</title>
		<author>
			<persName><forename type="first">H</forename><surname>Mili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Strickland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Boldyreff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Olsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Witt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Heger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Schecr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Elzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Systems and Software</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<date type="published" when="1994-05">May 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b109">
	<analytic>
		<title level="a" type="main">Third-generation versus fourth-generation development</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Misra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Jalics</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="8" to="14" />
			<date type="published" when="1988-07">July 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b110">
	<analytic>
		<title level="a" type="main">Software reusability through formal specifications</title>
		<author>
			<persName><surname>Th</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Moineau</surname></persName>
		</author>
		<author>
			<persName><surname>Gaudel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1st Int&apos;l Workshop on Software Reusability, Universitaet Dortmund</title>
		<meeting>1st Int&apos;l Workshop on Software Reusability, Universitaet Dortmund</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b111">
	<monogr>
		<title level="m" type="main">Selected Papersfrom the 2nd Int&apos;l Workshop on Software Reusability Advances in Software</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Morel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean</forename><surname>Faget</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">March 24-26, 1993</date>
			<publisher>IEEE CS press</publisher>
			<biblScope unit="page" from="80" to="88" />
			<pubPlace>ReuseLucca, Italy</pubPlace>
		</imprint>
	</monogr>
	<note>The REBOOT environment</note>
</biblStruct>

<biblStruct xml:id="b112">
	<analytic>
		<title level="a" type="main">Approximate reasoning about the semantic effects of program changes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Moriconi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">C</forename><surname>Winkler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Engineering</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="980" to="992" />
			<date type="published" when="1990-09">Sept. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b113">
	<analytic>
		<title level="a" type="main">Automated reuse of design plans</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mostow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Barley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Int&apos;l Con$ on Engineering Design</title>
		<imprint>
			<date type="published" when="1987">1987</date>
			<pubPlace>Boston, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b114">
	<analytic>
		<title level="a" type="main">User-Interface Tools: Introduction and Survey</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Special issue on user interfaces</title>
		<imprint>
			<date type="published" when="1989-01">Jan. 1989</date>
			<biblScope unit="page" from="15" to="23" />
		</imprint>
	</monogr>
	<note>Software</note>
</biblStruct>

<biblStruct xml:id="b115">
	<analytic>
		<title level="a" type="main">Maintaining configurations of evolving software systems</title>
		<author>
			<persName><forename type="first">K</forename><surname>Nacayanaswamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Scacchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Engineering</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="324" to="334" />
			<date type="published" when="1987-03">March 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b116">
	<analytic>
		<title level="a" type="main">The DRACO approach to constructing software from reusable components</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Neighbors</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Engineering</title>
		<imprint>
			<biblScope unit="page" from="564" to="574" />
			<date type="published" when="1984-09">Sept. 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b117">
	<analytic>
		<title level="a" type="main">Combination of inheritance hierarchies</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ossher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Harrison</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGPLAN Notices, Proc. OOPSLA&apos; 92</title>
		<meeting><address><addrLine>Vancouver, B.C., Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992">Oct. 18-22, 1992</date>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="25" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b118">
	<analytic>
		<title level="a" type="main">the 2nd. int&apos;l workshop on software reus</title>
		<author>
			<persName><forename type="first">H</forename><surname>Partsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Steinbruggen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computing Surveys</title>
		<meeting><address><addrLine>ReuseLucca, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987">March 24-26,1993. 1987</date>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="23" to="29" />
		</imprint>
	</monogr>
	<note>Classifying software for reusability</note>
</biblStruct>

<biblStruct xml:id="b119">
	<analytic>
		<title level="a" type="main">19 tic programming: myths and prospects p</title>
		<author>
			<persName><forename type="first">F</forename><surname>Somare ; Ani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Eddy</surname></persName>
		</author>
		<author>
			<persName><surname>Lorensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Center for n to Modem Information Re</title>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1987">June 13-15.1990. May 1. Aug. Sept. 1992. -4-8, 1987. 1991</date>
			<biblScope unit="page" from="48" to="62" />
		</imprint>
	</monogr>
	<note>Sop-</note>
</biblStruct>

<biblStruct xml:id="b120">
	<monogr>
		<title level="m" type="main">Selected papers from the 2nd Int&apos;l Workshop on Sofrware Reusability Advances in Sofnuare</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">S</forename><surname>Sorumgard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sindre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Stokke</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">March 24-26.1993</date>
			<publisher>IEEE CS Press</publisher>
			<biblScope unit="page" from="116" to="124" />
			<pubPlace>ReuseLucca, Italy</pubPlace>
		</imprint>
	</monogr>
	<note>Experiences from application of a faceted classification scheme</note>
</biblStruct>

<biblStruct xml:id="b121">
	<monogr>
		<title level="m" type="main">The C++ programming languages</title>
		<author>
			<persName><forename type="first">B</forename><surname>Stroustrup</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b122">
	<monogr>
		<title level="m" type="main">Selected Papersfrom the 2nd Int&apos;l Workshop on Software Reusability Advances in Sofrware</title>
		<author>
			<persName><forename type="first">W</forename><surname>Tracz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">March 24-26. 1993</date>
			<publisher>IEEE cs Press</publisher>
			<biblScope unit="page" from="66" to="78" />
			<pubPlace>ReuseLucca, Italy</pubPlace>
		</imprint>
	</monogr>
	<note>LILEANNA A parameterized programming language</note>
</biblStruct>

<biblStruct xml:id="b123">
	<analytic>
		<title level="a" type="main">Estimating size and effort in fourth-generation development</title>
		<author>
			<persName><forename type="first">J</forename><surname>Vemer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Tate</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sofrware</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="5" to="22" />
			<date type="published" when="1988-07">July 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b124">
	<monogr>
		<title level="m" type="main">Varieties of reusability tutorial: Software reusability</title>
		<author>
			<persName><forename type="first">P</forename><surname>Wegner</surname></persName>
		</author>
		<editor>Peter Freeman</editor>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="24" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b125">
	<analytic>
		<title level="a" type="main">Dimensions of 00 modeling, 00 computing</title>
		<author>
			<persName><forename type="first">P</forename><surname>Wegner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="2" to="20" />
			<date type="published" when="1992-10">Oct. 1992</date>
			<publisher>CS Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b126">
	<monogr>
		<title level="m" type="main">Designing 00 software</title>
		<author>
			<persName><forename type="first">R</forename><surname>Wirfs-Brock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wilkerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wiener</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b127">
	<analytic>
		<title level="a" type="main">Surveying current research in 00 design</title>
		<author>
			<persName><forename type="first">R</forename><surname>Wirfs-Brock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="105" to="124" />
			<date type="published" when="1990-09">Sept. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b128">
	<analytic>
		<title level="a" type="main">Can programmers reuse software</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">N</forename><surname>Woodfield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Embley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">T</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sofrware</title>
		<imprint>
			<biblScope unit="page" from="52" to="59" />
			<date type="published" when="1987-07">July 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b129">
	<monogr>
		<title level="m" type="main">Decline &amp; fall of the american programmer</title>
		<author>
			<persName><forename type="first">E</forename><surname>Yourdon</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Prentice-Hall: Englewood Cliffs</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b130">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Zaremski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Wing</surname></persName>
		</author>
		<title level="m">Signature matching: A key to reuse software engineering, Notes, Ist ACM SIGSOFT Symp. on the Foundations of Software Engineering</title>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="582" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b131">
	<analytic>
		<title level="a" type="main">Salient features of an executable specification language and its environment</title>
		<author>
			<persName><forename type="first">P</forename><surname>Zave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Schell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Sofrware Engineering</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="312" to="325" />
			<date type="published" when="1986-02">Feb. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b132">
	<analytic>
		<title level="a" type="main">Conjunction as composition</title>
		<author>
			<persName><forename type="first">P</forename><surname>Zave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jackson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Sofrware Engineering and Methodology</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="379" to="411" />
			<date type="published" when="1993-10">Oct. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
