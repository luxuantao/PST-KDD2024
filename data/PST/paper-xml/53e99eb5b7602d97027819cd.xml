<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Linear Dependent Types for Differential Privacy</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Marco</forename><surname>Gaboardi</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Pennsylvania</orgName>
								<orgName type="institution" key="instit2">Università di Bologna</orgName>
								<orgName type="institution" key="instit3">INRIA EPI Focus</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Andreas</forename><surname>Haeberlen</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Pennsylvania</orgName>
								<orgName type="institution" key="instit2">Università di Bologna</orgName>
								<orgName type="institution" key="instit3">INRIA EPI Focus</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Justin</forename><surname>Hsu</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Pennsylvania</orgName>
								<orgName type="institution" key="instit2">Università di Bologna</orgName>
								<orgName type="institution" key="instit3">INRIA EPI Focus</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Arjun</forename><surname>Narayan</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Pennsylvania</orgName>
								<orgName type="institution" key="instit2">Università di Bologna</orgName>
								<orgName type="institution" key="instit3">INRIA EPI Focus</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Benjamin</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Pennsylvania</orgName>
								<orgName type="institution" key="instit2">Università di Bologna</orgName>
								<orgName type="institution" key="instit3">INRIA EPI Focus</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Linear Dependent Types for Differential Privacy</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">50CBDBCE054E30E0D4368D57B3894186</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.3.2 [Programming Languages]: Language Classifications-Specialized application languages; F.3.3 [Theory of computation]: Studies of Program Constructs-Type structure General Terms Design</term>
					<term>Languages</term>
					<term>Theory differential privacy</term>
					<term>type systems</term>
					<term>linear logic</term>
					<term>dependent types</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Differential privacy offers a way to answer queries about sensitive information while providing strong, provable privacy guarantees, ensuring that the presence or absence of a single individual in the database has a negligible statistical effect on the query's result. Proving that a given query has this property involves establishing a bound on the query's sensitivity-how much its result can change when a single record is added or removed.</p><p>A variety of tools have been developed for certifying that a given query is differentially private. In one approach, Reed and Pierce <ref type="bibr" target="#b33">[34]</ref> proposed a functional programming language, Fuzz, for writing differentially private queries. Fuzz uses linear types to track sensitivity and a probability monad to express randomized computation; it guarantees that any program with a certain type is differentially private. Fuzz can successfully verify many useful queries. However, it fails when the sensitivity analysis depends on values that are not known statically.</p><p>We present DFuzz, an extension of Fuzz with a combination of linear indexed types and lightweight dependent types. This combination allows a richer sensitivity analysis that is able to certify a larger class of queries as differentially private, including ones whose sensitivity depends on runtime information. As in Fuzz, the differential privacy guarantee follows directly from the soundness theorem of the type system. We demonstrate the enhanced expressivity of DFuzz by certifying differential privacy for a broad class of iterative algorithms that could not be typed previously.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>An enormous amount of data accumulates in databases every daytravel reservations, hospital records, location data, etc. This information could potentially be very valuable, e.g., for scientific and medical research, but much of it cannot be safely released due to privacy concerns. Moreover, aggregation and anonymization are not sufficient to safeguard privacy: recent experience with the Netflix prize <ref type="bibr" target="#b29">[30]</ref>, for example, has shown how easy it is to leak sensitive information accidentally, even when the data is carefully sanitized before it is released.</p><p>Differential privacy <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b12">13]</ref> is a promising approach to this problem: it offers strong statistical privacy guarantees for certain types of queries, even in worst-case scenarios. Intuitively, this is accomplished by a) admitting only queries whose result does not depend too much on the data of any single individual, and b) adding some random noise to the result of each query. Thus, if we pick any individual I and remove all of I's data from the database before answering a query, the probability that the result is any given value v remains almost the same. This limits the amount of information that can be learned about a single individual by observing the result of the query.</p><p>Many specific queries have been shown to be differentially private, including machine learning algorithms such as empirical risk minimization <ref type="bibr" target="#b4">[5]</ref> and k-means, combinatorial optimization algorithms such as vertex cover and k-medians <ref type="bibr" target="#b17">[18]</ref>, and many others. But checking that a given query is differentially private can be both tedious and rather subtle. The key challenge is to prove an upper bound on the query's sensitivity, i.e., the maximum change in the query's output that can result from changing the data of a single individual. (Briefly, higher-sensitivity queries require more noise to maintain privacy.) Since most data analysts are not experts in differential privacy, they cannot benefit from its strong guarantees unless they have access to suitable tools.</p><p>The approach we focus on is to provide analysts with a programming language for differentially private queries: the analyst can formulate queries in this language and then submit them to a special compiler, which determines their "privacy cost" and rejects them if this cost exceeds a budget that has been specified by the analyst. This approach is attractive because differential privacy is compositional; for instance, the privacy cost of a sequence of differentially private computations is simply the sum of the individual costs. Thus, we can reason about large, complex queries by manually inspecting a few simple primitives and then suitably composing the analysis results of larger and larger subqueries. This is the basis of previous systems like PINQ <ref type="bibr" target="#b25">[26]</ref>, which provides a SQL-like language, Airavat <ref type="bibr" target="#b35">[36]</ref>, which implements a MapReduce framework, and Fuzz <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b33">34]</ref>, a higher-order functional language.</p><p>The analysis in Fuzz is based on a type system <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b33">34]</ref> that certifies queries as differentially private via two components: numeric annotations at the type level to describe the sensitivity of functions and a probability monad to represent probabilistic computations. Fuzz can certify many useful queries, but it fails for other important kinds of queries, including some fairly simple ones. For instance, iterative algorithms such as k-means can only be analyzed when the number of iterations is a constant, and there are other instances (such as a program that computes a cumulative distribution function for an arbitrary list of cutoffs) where even the type of the program cannot be expressed in Fuzz! Fuzz fails for these programs because their overall sensitivities are not simply a static composition of the sensitivities of subprograms; rather, they depend on some input data, such as the number of iterations or the list of numeric cutoffs. Numeric sensitivity annotations are not sufficient to express such dependencies between input data and sensitivity; however, as we show in this paper, these dependencies can be expressed with dependent types.</p><p>Dependent types enable static reasoning about information that will be available to a program only at runtime. But we must make a choice at the outset regarding the complexity of the dependencies we wish to support: richer dependencies would expand the range of queries that can be certified as differentially private, but systems with rich dependent types tend to require extensive program annotations, which would make DFuzz more difficult to use by nonexperts. At the extreme end of this spectrum would be a system like CertiPriv <ref type="bibr" target="#b2">[3]</ref>, which can certify a broad range of differentially private queries but requires the programmer to supply most of the proof. To preserve our goal of usability by non-experts, we instead work near the other end, choosing a lightweight form of dependent types that requires few annotations but still yields a powerful analysis.</p><p>We introduce a language called DFuzz-Dependent Fuzz-that combines a rich form of type-level sensitivity annotations with lightweight dependent types. The sensitivity annotations we consider are arithmetic expressions over real numbers. Our dependent types are a simple form of indexed types, where indices describe the size of data types and provide the programmer with dependent pattern matching in the style of Dependent ML <ref type="bibr" target="#b37">[38]</ref>. Sensitivity annotations and dependent types combine well, and the resulting language possesses strong metatheoretic properties. Most importantly, our type system (like that of Fuzz) natively captures the concept of differential privacy, since DFuzz enjoys an extension of the metric preservation property of <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b33">34]</ref>. To demonstrate the capabilities of DFuzz, we show that it can certify several examples from the differential privacy literature quite naturally, including Iterative Database Construction <ref type="bibr" target="#b18">[19]</ref>, k-means <ref type="bibr" target="#b3">[4]</ref>, k-medians <ref type="bibr" target="#b17">[18]</ref>, and the Cumulative Distribution Function <ref type="bibr" target="#b26">[27]</ref>.</p><p>In summary, we offer the following contributions:</p><p>• DFuzz, a core calculus for differential privacy that combines the earlier sensitivity analysis of Reed and Pierce <ref type="bibr" target="#b33">[34]</ref> with lightweight dependent types inspired by Dependent ML <ref type="bibr" target="#b37">[38]</ref> (Section 3);</p><p>• the fundamental metatheory for DFuzz, including an adaptation of the usual basic metatheory-substitution, preservation and progress-as well as a generalization of the metric preservation theorem from <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b33">34]</ref> (Sections 4 and 5); and</p><p>• four example programs that express algorithms from the differential privacy literature and can be successfully certified by DFuzz (Section 6).</p><p>We discuss related work in Section 7 and future research directions in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Background and Overview</head><p>Differential privacy We begin by reviewing some basic definitions. Suppose the private data is collected in a database that contains rows of the same type, and each individual's data is in a single row. Let db be the type of such databases, and assume for the mo-ment that we are interested in real-valued queries. Then the key definition of differential privacy (based on <ref type="bibr" target="#b12">[13]</ref>) is:</p><p>2.1 Definition: A randomized function f : db → R isdifferentially private if, for all possible sets of outputs S ⊆ R and for any two databases b, b that differ in only one row,</p><formula xml:id="formula_0">Pr[f (b) ∈ S] ≤ e • Pr[f (b ) ∈ S].</formula><p>Intuitively, this means that the presence or absence of one individual's data has only a small effect on the distribution of f 's (randomized) outputs. Here is a privacy parameter; the larger is, the more information about individuals is potentially revealed by the result. For small , the factor e can be thought of as 1 + . We will often refer to as the privacy cost of running f . We can extend the definition to data types other than db and R if we assign to each data type a metric that measures the distance between values. We write v ∼r v : τ to indicate that two values v and v of type τ are at most r apart. Thus we obtain:</p><p>2.2 Definition: A randomized function q : τ → σ is -differentially private if, for all sets S of closed values of type σ and for all v, v : τ such that v ∼r v : τ , we have:</p><formula xml:id="formula_1">P r[q(v) ∈ S] ≤ e r P r[q(v ) ∈ S]</formula><p>To determine whether a given query has this property, the following definition is useful:</p><formula xml:id="formula_2">2.3 Definition: A function f : τ → σ is c-sensitive for c ∈ R ≥0 if, for all v, v : τ with v ∼r v : τ , we have f (v) ∼c•r f (v ) : σ.</formula><p>In other words, a c-sensitive function magnifies changes in its inputs by at most a factor of c. When a function q is not c-sensitive for any c ∈ R ≥0 in the sense of the above definition, we will refer to it as ∞-sensitive. Real-valued functions with limited sensitivity can be converted into -differentially private queries using the Laplace mechanism (introduced in <ref type="bibr" target="#b12">[13]</ref>). Here, we write L β to denote the Laplace distribution with scaling parameter β.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Proposition:</head><p>Let f : db → R be a c-sensitive function, and let q : db → R be the randomized function q = λb. f (b) + N , where N is a random variable distributed according to L c/ . Then q is -differentially private.</p><p>In other words, the Laplace mechanism converts f into a randomized function q by adding noise from the Laplace distribution. Note that the parameter of the distribution-the 'magnitude' of the noise-depends on both c and : the stronger the privacy requirement (smaller ) and the higher the sensitivity of f (larger c), the more noise must be added to f 's result to preserve privacy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Linear types for differential privacy</head><p>The key idea behind static type systems for differential privacy is to provide a compositional analysis that tracks both the privacy cost and the sensitivity c of a function. For context, we sketch the analysis in Fuzz <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b33">34]</ref>, on which our work is based.</p><p>Fuzz has a linear type system: functions can have types of the form !rσ τ , where the modality !r is annotated with a numeric upper bound r on the function's sensitivity. For instance, the term λx.(2 • x) can be given the type !2R R to express the fact that f (x) = 2 • x is 2-sensitive in its argument x. <ref type="foot" target="#foot_0">1</ref> Fuzz checks these types with standard typing judgments of the form Γ e : σ, where the type environment Γ additionally contains hypotheses about sensitivity. For instance, a typing judgment x : !cσ e : τ means that e can be given type τ if e is at most c-sensitive in the free variable x.</p><p>As an illustration, consider the slightly more complex program (λz. and assigns monadic types to randomized computations. Accordingly, the concept of sensitivity is generalized so that the privacy cost of a differentially private function is interpreted as its sensitivity. Specifically, the type system guarantees that any program that can be given a type ! db R is differentially private, with privacy cost . 2  The full Fuzz type system is described in <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b33">34]</ref>, which also show how several practical programs can be successfully typechecked; one of these is k-means clustering, a machine learning algorithm that takes a list of points and computes centers around which the points cluster. However, as mentioned above, a key limitation of Fuzz is that its sensitivity annotations are purely numeric. In the case of k-means clustering, this is a major inconvenience: the sensitivity depends on the number of iterations of the algorithm, but Fuzz types cannot express the fact that a function's sensitivity in one parameter may depend on the value of another-the only way out is to hard-code the number of iterations. For instance, in Fuzz a k-means program performing two iterations can be typed as:</p><formula xml:id="formula_3">2iter-k-means : !∞L(R ⊗ R) !6 Bag(R ⊗ R) (L(R ⊗ R))</formula><p>This type says that 2iter-k-means is a program that, when provided with an initial list of centers (of type L(R ⊗ R)), produces a 6differentially private algorithm that maps a dataset to a new list of centers. A k-means program that performs a different number of iterations would have a different type. Worse, in Section 6, we will see several examples of practical algorithms whose types cannot be expressed in Fuzz, e.g., the IDC algorithm <ref type="bibr" target="#b18">[19]</ref>, in which the desired sensitivity is itself a parameter. This means that we cannot even add such operations to Fuzz as primitives.</p><p>In DFuzz, we overcome this limitation by adding dependent types. In particular, we add a lightweight form of dependent types that allow us to give the following type to a general algorithm for k-means:</p><formula xml:id="formula_4">k-means : ∀i, k.(!∞N[i] !∞L(R ⊗ R)[k] !3i Bag(R ⊗ R) (L(R ⊗ R)[k]))</formula><p>This type gives more precise information about the behavior of k-means: it says that k-means is a program that, when provided with a natural number i specifying the number of iterations (the sensitivity annotation is ∞ since this parameter does not need to be kept private) and a list of k centers, produces a 3i -differentially private algorithm that maps the dataset to a list of k centers. In the next section, we describe DFuzz's dependent types in more detail. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">DFuzz</head><formula xml:id="formula_5">τ ::= a | Z | α | A τ | τ<label>(types)</label></formula><p>A ::= !Rτ (modal types)  <ref type="figure" target="#fig_4">8</ref> (selected operational semantics rules). We describe each of these components below, omitting some secondary details for brevity. (In particular, we elide some linear data types like ⊗, &amp;, and ⊕. A full description is available in <ref type="bibr" target="#b13">[14]</ref>.)</p><formula xml:id="formula_6">S ::= i | 0 | S + 1 (size terms) R ::= k | r | S | R + R | R • R | ∞ (sensitivity terms) Φ ::= ∅ | S = 0 | S = i + 1 | Φ ∧ Φ (assumptions) C ::= S = S | R ≤ R<label>(</label></formula><p>Sizes and sensitivities The special feature of DFuzz types (Figure <ref type="figure">1</ref>) is that they can contain size or sensitivity information. This information is described by means of terms in a small language at the type level. A size term, written S, is a term that conforms to the grammar S ::= i | 0 | S + 1 where i is a size variable. Size terms are simple expressions over natural numbers; they are used to describe the size of data types. A sensitivity term, denoted R, is a term that conforms to the grammar</p><formula xml:id="formula_7">R ::= k | r | S | R + R | R • R | ∞</formula><p>where k is a sensitivity variable and r is a non-negative real constant, i.e., r ∈ R ≥0 . Sensitivity terms are simple expressions that consist of positive real numbers and the symbol ∞; they are used to describe program sensitivity. An annotation of ∞ means that φ 0 : ι We will use the metavariable I to range over sizes and sensitivities. Any size term is also a sensitivity term. This is important for expressing dependencies between sizes (for example, number of iterations) and sensitivities (for example, privacy cost). To ensure the correct behavior of size and sensitivity terms, and to prevent undesired substitutions, we consider size and sensitivity terms to be typed as well; to avoid confusion, we refer to the types for size and sensitivity terms as kinds. DFuzz uses two kinds: ι for size annotations and υ for sensitivity annotations. Kinds are assigned to terms via kind judgments of the form φ I : κ where φ is a kind environment, i.e., a set of kind assignments to size and sensitivity variables. The rules for deriving the judgment φ I : κ are presented in Figure <ref type="figure">3</ref>. Notice that we have a subkind relation on terms that is induced by the rule (k.&lt;:). This relation allows us to consider size terms as sensitivity terms. For notational convenience, we will sometime write sizes and sensitivities terms without making explicit their kind.</p><formula xml:id="formula_8">(k.0) φ ∞ : υ (k.∞) φ(i) = κ φ i : κ (k.Ax) r ∈ R ≥0 φ r : υ (k.</formula><p>We can interpret size terms over the domain N of natural numbers and sensitivity terms over the domain R ≥0 ∪ {∞} of nonnegative extended real numbers. To interpret expressions with free variables we need, as usual, a notion of assignment-that is, a mapping ρ from size variables to elements of N and from sensitivity variables to elements of R ≥0 ∪ {∞}. We write dom(ρ) for the domain of ρ; this is a set of variable-kind mappings of the shape i : κ where each variable i appears at most once.</p><p>Given a term φ I : κ and an assignment ρ such that φ ⊆ dom(ρ), we inductively define the interpretation I ρ:</p><p>• 0 ρ = 0</p><formula xml:id="formula_9">• i ρ = ρ(i) • S + 1 ρ = S ρ + 1 • r ρ = r • R1 + R2 ρ = R1 ρ + R2 ρ • R1 • R2 ρ = R1 ρ • R2 ρ • ∞ ρ = ∞</formula><p>where + and • are the usual sum and product extended to ∞:</p><formula xml:id="formula_10">∞ + r = r + ∞ = ∞ for every r ∈ R ≥0 ∪ {∞}, ∞ • r = r • ∞ = ∞</formula><p>for every r = 0, and</p><formula xml:id="formula_11">∞ • 0 = 0 • ∞ = 0</formula><p>(Note that this definition implicitly coerces size terms-natural numbers-into real numbers as needed.) The well-definedness of the interpretation is ensured by the following lemma:</p><p>3.1 Lemma: Let φ I : κ and φ ⊆ dom(ρ). Then:</p><formula xml:id="formula_12">• If κ = ι, then I ρ ∈ N. • If κ = υ, then I ρ ∈ R ≥0 ∪ {∞}.</formula><p>Proof: By induction on the derivation proving φ S : κ.</p><p>Data types and dependent pattern matching Our syntax of types offers just two representative algebraic data types: natural numbers N[S] and lists L(σ)[S] with elements of type σ (see Figure <ref type="figure">1</ref>). We could have gone further and included general algebraic datatype declarations and pattern matching, but this would add to the complexity of the notation without (we believe) raising new conceptual issues; we leave this generalization to future work.</p><p>Intuitively, the size of a natural number corresponds to its value (we consider a unary encoding of the natural numbers, and we assume the natural number 0 to be of size 0), and the size of a list corresponds to the number of elements in it (we assume nil to be of size 0). Types like N[S] and L(σ)[S] are inhabited only by terms whose evaluation produces a value of size S (if it terminates). The approach is reminiscent of Hayashi's singleton types <ref type="bibr" target="#b20">[21]</ref>.</p><p>To illustrate why size terms are helpful for expressiveness, let us consider the list data type in more detail. Values of the list type are built through the constructors nil and cons[S](e, g) (see Figure <ref type="figure" target="#fig_6">2</ref>), where cons carries the size S of the expression g as additional information. This information is used to support a simple form of dependent pattern matching: the case L destructor can, in addition to the usual term-level pattern matching, also perform type-level pattern matching. This is described by the following reduction rule (see Figure <ref type="figure" target="#fig_4">8</ref>)</p><formula xml:id="formula_13">case L cons[S](e1, e2) of nil → g1 | cons[i](y, x) → g2 → g2{e1/y}{e2/x}{S/i}</formula><p>in which the size S is propagated to the term g2. In a similar way, in the reduction rule (Op-Case s ) in Figure <ref type="figure" target="#fig_4">8</ref> for dependent pattern matching on N[S], the information n is propagated to the term g2.</p><p>The data type elimination rules in Figure <ref type="figure">6</ref> are crucial to making this technique work. For instance, the elimination rule for the list data type</p><formula xml:id="formula_14">φ; Φ; Γ e : L(τ )[S] φ; Φ ∧ S = 0; ∆ g1 : σ φ, i : ι; Φ ∧ S = i + 1; ∆, x : !RL(τ )[i], y : !Rτ g2 : σ φ; Φ; ∆ + R • Γ case L e of nil → g1 | cons[i](y, x) → g2 : σ</formula><p>adds assumptions (explained in detail below) to the contexts used to typecheck the two branches of the case construct, reflecting information gleaned by the case about the size S of the test value e. In the first branch, it is assumed that S = 0; this extra piece of information enables us to remember, at the typing judgment level, that e has been matched to nil. Conversely, in the second branch, it is assumed that S = i + 1, giving us a name i for the size of the tail of the list e, which appears in the type assumed for the pattern variable x. A similar mechanism is used in the elimination rule for the N[S] data type.</p><p>Assumptions and constraints More formally, a judgment φ; Φ; Γ e : σ contains, besides the usual environment Γ for term variables and the kind environment φ, an extra parameter Φ that records the assumptions under which the typing is obtained. Intuitively, the expression e can be assigned the type σ for any value of its free size variables satisfying Φ. Since assumptions Φ record the size constraints generated by the pattern matching rules, we consider assumptions that conform to the following grammar:</p><formula xml:id="formula_15">Φ ::= ∅ | S = 0 | S = i + 1 | Φ ∧ Φ</formula><p>An assumption Φ is well defined when it is associated with a kind environment φ that determines the kinds of the free size variables in Φ. We write φ Φ in this case. Given an assumption φ Φ and an assignment ρ such that φ ⊆ dom(ρ), the interpretation Φ ρ is defined inductively as follows:</p><formula xml:id="formula_16">• ∅ ρ = true • S = 0 ρ = ( S ρ = 0) • S = i + 1 ρ = ( S ρ = i ρ + 1) • Φ1 ∧ Φ2 ρ = Φ1 ρ ∧ Φ2 ρ</formula><p>where = is equality on natural numbers. The use of assumptions is crucial for the subtyping relation (Figure <ref type="figure">4</ref>). Indeed, subtyping judgments involve judgments of the shape</p><formula xml:id="formula_17">φ; Φ |= C</formula><p>where C is a constraint of the form R ≤ R or S = S . The meaning of a constraint C also follows directly from the interpretation of the size and sensitivity terms it contains. Given an assignment ρ for the size and sensitivity variables appearing in C, the interpretation C ρ is defined inductively as</p><formula xml:id="formula_18">• R ≤ R ρ = ( R ρ ≤ R ρ) • S = S ρ = ( S ρ = S ρ)</formula><p>where ≤ is the expected extension of ≤ to cover ∞. The judgment φ; Φ |= C asserts that the constraint C is a logical consequences of the assumption Φ, i.e. for every ρ such that Φ ρ = true we have C ρ = true. Analogously, we will also use the notation φ; Φ |= Ψ to denote the fact that the assumption Ψ is a logical consequence of the assumption Φ. We will see how these judgments are used later when we present the subtyping rules in detail.</p><p>Generalized sensitivities and the scaling modality Sensitivity terms are the key ingredients in the sensitivity analysis. They appear as decorations of the scaling modality !R. The scaling modality is used to define types with the shape !Rσ, which are used in turn in function types and in term environments. Suppose that a given expression e can be assigned the function type !Rσ τ :</p><p>φ; Φ; Γ e : !Rσ τ</p><p>Then we know that e is a function that maps elements of type σ to elements of type τ as long as Φ is satisfied, and that in this case R is an upper bound on the function's sensitivity. Two points merit further explanation. First, a static analysis cannot always describe the exact sensitivity of a program; we are always dealing with conservative upper bounds. Second, we say that R "describes" this upper bound because it is not necessarily a number: it can depend on size or sensitivity variables from φ, which can themselves be involved in assumptions from Φ. This dependency is central to the expressivity of DFuzz.</p><p>Modal types also appear in type environments. A typing judgment of the form φ; Φ; x1 : !R 1 σ1, . . . , xn : !R n σn e : σ says that the expression e is a function whose sensitivity in the i th argument is described by the sensitivity term Ri. Notice that this means that every function type comes with a sensitivity term associated to its input type. Indeed, here-unlike <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b33">34]</ref>-we are implicitly using the standard linear logic decomposition of the intuitionistic implication σ → τ = !σ τ and the observation that it suffices to have modal types appearing in negative position. For convenience, we will similarly use the notation σ → τ as a shorthand for non-sensitive functions, i.e., functions of a type !Rσ τ where R = ∞. Modal types can be combined by arithmetic operations</p><formula xml:id="formula_19">!Rσ+ !T σ = !R+T σ and T • !Rσ = !T •Rσ</formula><p>and these operations are lifted to type environments. The sum of two contexts is defined inductively as:</p><formula xml:id="formula_20">• ∅ + ∅ = ∅ • (Γ, x : A) + (∆, x : B) = (Γ + ∆), x : A + B • (Γ, x : A) + ∆ = Γ + (∆, x : A) = (Γ + ∆), x : A, if x ∈ dom(Γ, ∆)</formula><p>The product of a type environment with a sensitivity term T is:</p><formula xml:id="formula_21">• T • ∅ = ∅ • T • (Γ, x : A) = T • Γ, x : T • A</formula><p>It is worth emphasizing that the sum Γ + ∆ of two type environments Γ and ∆ is defined only in the case that for each x ∈ dom(Γ)∩dom(∆) the type A+B is defined, where x : A ∈ Γ and x : B ∈ ∆. This in turn requires that there is a type σ such that A = !R 1 σ and B = !R 2 σ. In all the binary rules in Figure <ref type="figure">5</ref> we implicitly assume this condition.</p><p>A sensitivity term can also appear as the annotation of a precise type R[R]. This class of types is close in spirit to the data types N[S] and L(σ)[S], since it classifies terms whose value is described by R. However, we have no destructor operation for this kind of type. We will see in Section 5.4 that these types can be used to dynamically specify the sensitivity of certain operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Subtyping and quantifiers</head><p>The assumptions introduced by pattern matching play a crucial role in the subtyping relation , which is defined by the rules in Figure <ref type="figure">4</ref>. A subtyping judgment has the shape φ; Φ σ τ where φ is a kind environment and Φ is an assumption. Intuitively, the subtyping relation φ; Φ σ τ says that (1) σ and τ are equal up to their decorations with size and sensitivity terms, and (2) the decoration of τ is more permissive than the decoration of σ under the assumption Φ. One main purpose of the subtyping relation is to capture the fact that an R-sensitive function is also R -sensitive for R ≤ R . This is ensured by the rule for the scaling modality:</p><formula xml:id="formula_22">φ; Φ |= R2 ≤ R1 φ; Φ |= σ1 σ2 φ; Φ |= !R 1 σ1 !R 2 σ2 (st.!)</formula><p>Indeed, the combination of this rule and the rule for function types</p><formula xml:id="formula_23">φ; Φ |= σ3 σ1 φ; Φ |= σ2 σ4 φ; Φ |= σ1 σ2 σ3 σ4 (st. )</formula><p>(which, as usual, is contravariant in its first argument) ensures that φ;</p><formula xml:id="formula_24">Φ !Rσ τ ! R σ τ iff φ; Φ |= R ≤ R .</formula><p>In other words, if we can prove that R ≤ R under assumption Φ, then every expression that can be given the type !Rσ τ can also be given the type ! R σ τ . Subtyping is also needed for putting the dependent pattern matching mechanism to work, to unify the contexts and the types in the two branches of a case rule. This is obtained by using subtyping judgments on data types. For instance, for natural numbers we have a rule φ;</p><formula xml:id="formula_25">Φ |= S = S φ; Φ |= N[S] N[S ] (st.N)</formula><p>that allows us to obtain the type</p><formula xml:id="formula_26">N[S ] from the type N[S] if we have φ; Φ |= S = S .</formula><p>Subtyping can be applied by using the rule ( .R) in Figure <ref type="figure">5</ref>. Moreover, it can be extended to type environments: the judgment φ; Φ |= Γ ∆ holds if for every x : A ∈ ∆ we have x : B ∈ Γ and φ; Φ |= B A. Note that the type environment Γ can contain variable assignments for variables that do not appear in ∆. Thus the rule ( .L) in Figure <ref type="figure">5</ref> can also be seen as a kind of weakening.</p><p>In order to be able to express the size and sensitivity dependencies in a uniform way, , we additionally enrich the type language with a universal quantifier ∀ and an existential quantifier ∃ over size and sensitivity variables (Figure <ref type="figure">6</ref>). For instance, the type</p><formula xml:id="formula_27">∀i : ι.(N[i] !iR R)</formula><p>can be assigned to a program that, given a value of type N[S], returns an S-sensitive function of type !SR R, for any size term S : ι. Similarly, the type</p><formula xml:id="formula_28">∀i : ι.(N[i] ∃k : υ.( !jR R))</formula><p>abstracts the sensitivity of the function that is returned when a term of this type is provided with a value of type N[S]. Finally, the type</p><formula xml:id="formula_29">∃i : ι.N[i]</formula><p>is the type of the ordinary natural numbers.</p><p>The probability layer To ensure differential privacy, we need to be able to write probabilistic computations. This is achieved in DFuzz by considering a grammar of programs with two layers (Figure <ref type="figure" target="#fig_6">2</ref>) . We have an expression layer that contains the constructors and destructors for each data type, and an additional probability state layer that contains the program constructions for describing probabilities over expressions and values. To mediate between the two layers, we use a monadic type τ , similar to the one found in Ramsey and Pfeffer's stochastic lambda calculus <ref type="bibr" target="#b31">[32]</ref>.</p><p>In order to describe probabilistic states, we need to have probability vectors p, i.e., lists of real numbers from the interval [0, 1] that sum up to 1. Probability vectors can be typed by means of a precise type of the shape P[S], where the size term S describes the length of the vector. Though S can range over variables, the typing rules for vectors only use types P[n] indexed by a constant natural number n. A probabilistic state s then is either an object of the shape {p, (s1, . . . , sn)} where p is a probabilistic vector, or an object of the shape do e. Intuitively, the former associates a discrete probability distribution, described by p, to a list of probabilistic states (s1, . . . , sn), whereas the latter turns an expression into a probabilistic state. Probabilistic states represent probabilistic computations in the sense that their evaluation results in final states that assign probabilities to values. For an example, the state {(0.2, 0.8), (do return 1, {(0.5, 0.5), (do return 2, do return 3)})} is a final state in which the value 1 is returned with probability 0.2 and the values 2 and 3 are each returned with probability 0.8 • 0.5 = 0.4.</p><p>We use three monadic expression forms to ensure that only expressions representing probabilistic computations can be turned into probabilistic states. The expression return e can be seen as representing the distribution that deterministically yields e; the monadic sequencing let x = e in e can be seen as a program that draws a sample x from the probabilistic computation e and then continues with the computation e ; and the explicit probability construction {e, (e1, . . . , en)} associates an expression e representing a probability vector with a list of random computations (e1, . . . , en). The typing rules (Figure <ref type="figure">7</ref>) ensure that we consider only well-formed expressions. In particular, the rule φ; Φ; Γ e : P[n] φ; Φ; ∆ ei : σ (∀i) φ; Φ; Γ + ∆ {e, (e1, . . . , en)} : σ ({e})</p><p>ensures that (1) e represents a probability vector, and (2) every ei is a probabilistic computation. Notice also that this rule is responsible for the well-formedness of the probabilistic states. It ensures that we associate lists of expressions of length n only with probability vectors of the same length. This is the reason for introducing the precise type P[n].</p><p>As a last remark, notice that the different components of a state represent independent computations, so, even though evaluation of expressions is defined sequentially, we define evaluation on states in parallel.</p><p>Sensitivity and primitive operations One last component that is necessary to make the framework practical is a way to add trusted primitive operations, i.e., operations that are known to preserve the properties of the type system. This is intuitively the meaning of the following typing rule from Figure <ref type="figure">6</ref>:</p><formula xml:id="formula_30">φ; Φ imply f R-sensitive σ → τ φ; Φ; Γ f : !Rσ τ (Ext)</formula><p>which says that we can add to DFuzz any primitive operation f of type !Rσ τ as long as we know that this operation represents a mathematical function f that maps values in the type σ to values in the type τ and that is R-sensitive under the assumption Φ.</p><p>At the operational level, the evaluation rules for the primitive operation f must respect the behavior of the function f . This is obtained by means of the two following rules (Figure <ref type="figure" target="#fig_4">8</ref>):</p><formula xml:id="formula_31">e → e f e → f e (Op-Ext-Tr) f v → f (v) (Op-Ext)</formula><p>We can also extend DFuzz with additional primitive types, as long as they are equipped with a metric that respects the properties we describe in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Basic Metatheory</head><p>In this section, we develop fundamental properties of DFuzz. In order to show the usual properties one would expect from our programming language-type preservation and progress-we additionally need to prove some properties that are particular to our use of size and sensitivity annotations. These will also be useful to prove the Metric Preservation Theorem in the next section. We give just proof sketches; full proofs are in <ref type="bibr" target="#b13">[14]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Properties of Sizes and Sensitivities</head><p>As we saw earlier, typing judgments in DFuzz have the form φ; Φ; Γ e : σ i.e., they are indexed by a set of kind assignments to index variables φ and an assumption Φ. Intuitively, the fact that the subtyping can prove statements using the assumptions in Φ is what makes the dependent pattern matching work: it enables us to recover the same type from the different branches.</p><p>Here, we prove some properties of the typing with respect to the assumption Φ. The first says that strengthening the assumption preserves the typing. The environment φ can contain free size and sensitivity variables; these can be thought of as placeholders for any size or sensitivity index term, and they can be instantiated with a concrete index term when necessary. This is captured by the next lemma:  (3) follows by induction on the derivation proving φ, i : κ; Φ; Γ e : σ, using Point 2 when needed. (4) follows by induction on the derivation proving φ, i : κ; Φ; Γ s : σ, using Point 3 when needed.</p><formula xml:id="formula_32">(case N 0 of 0 → e1 | x[i] + 1 → e2) → e1 (Op-Case 0 ) (case N s n of 0 → e1 | x[i] → e2) → e2{n/x}{n/i} (Op-Case s ) e → e (case L e of nil → e1 | cons[i](x, y) → e2) → (case L e of nil → e1 | cons[i](x, y) → e2) (Op-Case-List-Tr) e → e f e → f e (Op-Ext-Tr) (case L nil of nil → e1 | cons(x, y[i]) → e2) → e1 (Op-Case nil ) f v → f (v) (Op-Ext) (case L cons[S](v, w) of e1 | cons(x, y[i]).e2) → e2{v/</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Type Soundness and Type Preservation</head><p>Using the properties on size and sensitivities annotations detailed in the previous section, we are now ready to prove the usual properties we want a programming language to enjoy: substitution, type preservation, and progress. The proof of the Substitution Lemma is straightforward, except for the management of the term variable environments. The proof of Type Preservation, however, is not as straightforward because it requires managing the constraints and the size and sensitivity annotations in various places.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Theorem [Type Preservation]:</head><p>1. If e : σ and e → e , then e : σ. We can also prove Progress as usual:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Theorem [Progress]:</head><p>1. If e : σ, then either e → e , or e is a value. 2. If s : σ, then either s → s , or s is final.</p><p>Proof: Both parts proceed by induction on the given derivation, using part (1) as needed in part (2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Metric Preservation and -Differential Privacy</head><p>The design of the DFuzz type system is intimately related to the metric relation we present in this section. This connection is captured by the Metric Preservation Theorem (5.2.7), which states that the evaluations of two well typed expressions at a given distance result in two values at the same distance or less.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Metric Relations</head><p>To formalize the notion of sensitivity, we need a metric relation on programs and states that captures an appropriate notion of "information distance" for each type. For this purpose, we first introduce a metric relation ∼r on values and final states, and then extend it to a metric relation ≈r on expressions and states through substitutions of related values. Concretely, we begin with metric judgments on values and final states v ∼r v : σ f ∼r f : σ asserting, respectively, that values v, v and final states f , f are related at type σ and that they are no more than r apart, where r ∈ R ≥0 .</p><p>Using these metric judgments, we can also relate substitutions of values for variables in an environment Γ. First, we need some notation. Let Γ • be the environment obtained from Γ as follows:</p><formula xml:id="formula_33">Γ • = {xi : σi | xi : !R i σi ∈ Γ}</formula><p>Suppose that γ is a vector of positive reals indexed by variables in dom(Γ), i.e. γ = (x1 := r1, . . . , xn := rn). Then, we also define a metric judgment with shape:</p><formula xml:id="formula_34">δ ∼γ δ : Γ •</formula><p>This asserts that the substitutions δ and δ of values for the variables in dom(Γ) are related at the types described by Γ • , and that they are no more than γ apart. That is, for every value vi = δ(xi) and</p><formula xml:id="formula_35">v i = δ (xi) we have vi ∼ γ(x i ) v i .</formula><p>Finally, we have judgments for expressions and states:</p><p>Γ e ≈r e : σ Γ s ≈r s : σ</p><p>These assert that the expressions e, e and states s, s are related at the type σ, and that they are no more then r apart, in the type environment Γ.</p><p>Given an environment Γ = (x1 : !R 1 σ1, . . . , xn : !R n σn) and a variable-indexed vector of positive reals γ = (x1 := r1, . . . , xn := rn), we define γ Γ as n i=1 ri • Ri . By definition, γ Γ can assume values in R ≥0 ∪ {∞}. In what follows, we will be particularly interested in the cases where γ Γ is finite.</p><p>All these metric judgments are defined inductively by the rules in Figure <ref type="figure">9</ref> where |b1 b2| is the size of the symmetric difference between the two databases b1 and b2. It is worth noting that the metric on expressions considers only expressions that are typable with no constraints and no free size variables. This ensures that the index r in the relations ∼r and ≈r is actually a value r ∈ R ≥0 .</p><p>The metric presented here, like the one used in <ref type="bibr" target="#b32">[33]</ref>, differs significantly from the one presented in <ref type="bibr" target="#b33">[34]</ref> in its treatment of nonvalue expressions and states. In particular, we do not require the relation on expressions to be closed under reduction. This makes the proof of metric preservation easier, and, as we will see, it is sufficient to ensure differential privacy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Metric Preservation</head><p>The Metric Preservation Theorem (5.2.7), which we present at the end of this section, can be seen as an extension of the Type Preservation Theorem (4.2.2). We can read it as asserting that the evaluation of expressions and states preserves not only their types but also the distances between related input values, up to a constant factor given by the metric relation.</p><p>The proof of the metric preservation theorem involves five major steps. The goal of these steps is to ensure that the different metric relations respect the properties of the type system. The first step is to show that the metric on expressions and states internalizes a sort of weakening:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Lemma:</head><p>1. If ∆ e ≈r e : σ and r ≤ p, then ∆ e ≈p e : σ. 2. If ∆ s ≈r s : σ and r ≤ p, then ∆ s ≈p s : σ.</p><p>Proof: The proof of ( <ref type="formula" target="#formula_43">1</ref>) is by inversion on the rule proving ∆ e ≈r e : σ, using the fact that, if v ∼ r v : τ and r ≤ p , then v ∼ p v : τ . The base case of (2) follows from (1); the inductive case follows directly by induction hypothesis.</p><p>The second step is to show that the metric relation is well behaved with respect to the subtyping relation. This is formalized by the following lemma.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Lemma [Subtyping on metrics]:</head><p>1. If e ≈r e : σ, and ∅; ∅ σ τ , then e ≈r e : τ . (2) by induction on the derivation proving s ≈r s : σ.</p><p>The third technical lemma is an intermediate step to show that the two metric relations ∼r and ≈r coincide on expressions and states that happen to be values and final states, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.3">Lemma:</head><p>1. Suppose ∅; ∅; Γ e : τ . If δ1 ∼γ δ2 : Γ • and δ1e is a value, then δ2e must also be a value, and δ1e ∼ γ Γ δ2e : τ . 2. Suppose ∅; ∅; Γ s : τ . If δ1 ∼γ δ2 : Γ • and δ1s is final, then δ2s must also be final, and δ1s ∼ γ Γ δ2s : τ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.4">Corollary:</head><formula xml:id="formula_36">1. v ≈r v : τ iff v ∼r v : τ . 2. f ≈r f : τ iff f ∼r f : τ .</formula><p>The last important property that the metric inherits from the DFuzz type system is a substitution property on the judgments involving the relation ≈r.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.5">Lemma [Substitution into ≈]:</head><p>The following rule is admissible:</p><formula xml:id="formula_37">∆1 e1 ≈r 1 e 1 : τ1 ∆2, x : !Rτ1 e2 ≈r 2 e 2 : τ2 R • ∆1 + ∆2 e2{e1/x} ≈ r 1 R +r 2 e 2 {e 1 /x} : τ2</formula><p>Combining these four results, we can prove the main lemma:</p><formula xml:id="formula_38">5.2.6 Lemma [Metric Compatibility]: Suppose δ ∼γ δ : Γ • such that γ Γ ∈ R ≥0 . Then:</formula><p>1. If ∅; ∅; Γ e : σ and δe → g, then ∃g . δ e → g and g ≈ γ Γ g : σ. 2. If ∅; ∅; Γ s : σ and δs → s f , then ∃s f . δ s → s f and s f ≈ γ Γ s f : σ.</p><p>Proof: By induction on the typing derivation proving ∅; ∅; Γ e : σ and ∅; ∅; Γ f : σ, respectively, with further case analysis on the evaluation step taken and using Corollary (5.2.4) and the Substitution Lemma (5.2.5).</p><p>The Metric Compatibility lemma is the main ingredient we need to prove that well-typed programs map related input values to related output values:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.7">Theorem [Metric Preservation]:</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">If</head><p>e ≈r e : σ and e → e f , then ∃e f . e → e f and e f ≈r e f : σ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">If</head><p>s ≈r s : σ and s → s f , then ∃s f . s → s f and s f ≈r s f : σ.</p><p>Proof: (1) By inversion on the rule proving the judgment e ≈r e : σ, using the Metric Compatibility Lemma (5.2.6); (2) by induction on the derivation proving the judgment s ≈r s : σ, again using Lemma (5.2.6).</p><p>We can then make a corresponding statement about the complete evaluation → of two expressions or two states, where → is the reflexive, transitive closure of the step relation →:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.8">Theorem [Big-Step Metric Preservation]:</head><p>1. If e ≈r e : σ and e → v, then there exists v such that e → v and v ∼r v : σ. 2. If s ≈r s : σ and s → f , then there exists f such that e → f and f ∼r f : σ. To formalize this, we need to define the probability Pr f [v] that a final state f yields a value v. We recursively define:</p><formula xml:id="formula_39">∅; ∅; ∅ v : σ v ∼0 v : σ ∅; ∅; ∅ f : σ f ∼0 f : σ ∅; ∅; ∅ n : N[S] n ∼0 n : N[S] ∅; ∅; ∅ r : R[R] r ∼0 r : R[R] ∅; ∅; ∅ nil : L(σ)[0] nil ∼0 nil : L(σ)[0] v1 ∼r 1 v 1 : σ v2 ∼r 2 v 2 : L(σ)[S] cons[S](v1, v2) ∼r 1 +r 2 cons[S](v 1 , v 2 ) : L(σ)[S + 1] v ∼r v : σ r ≤ r v ∼ r v : σ |r1 -r2| =</formula><formula xml:id="formula_40">Pr do return v [v] = 1 if v = v 0 otherwise Pr {(p 1 ,...,pn),(f 1 ,...,fn)} [v] = n i=1 pi Pr f i [v]</formula><p>Note that, by the typing rule for probabilistic states ({s}), the tuples (p1, . . . , pn), (f1, . . . , fn) must have the same length. The metric on probability distributions is carefully chosen so that the metric on final states corresponds to the relation on probability distributions needed in the definition of differential privacy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.1">Lemma:</head><p>Let f : σ and f : σ be two closed final states such that f ∼r f : σ for some r ∈ R ≥0 . Then, for every value v : σ,</p><formula xml:id="formula_41">Pr f [v] ≤ e r Pr f [v].</formula><p>Thus, we can show that the type system can verify that a program is -differentially private. The above theorem shows that in order to ensure that the execution of a program e corresponds to an -differentially private randomized function from values in σ to values in τ , it is sufficient to check that the program e has a type of this form:</p><p>e : ! σ τ</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Primitive Operations for Privacy</head><p>As outlined in Section 3, one important property of DFuzz is that it can be extended by means of primitive operations. In particular, we are interested in adding two basic building blocks, allowing us to build more involved differentially private examples. The first operation we add is the Laplace mechanism (Proposition (2.4)), with the following signature:</p><formula xml:id="formula_42">add noise : ∀ : υ.R[ ] → ! R R</formula><p>Note that, unlike the version presented in Fuzz, this primitive allows the level of noise (and thus, the level of privacy) to be specified by the user. Another primitive operation that fits well in our framework is the exponential mechanism <ref type="bibr" target="#b27">[28]</ref> exp noise :∀s : υ, :</p><formula xml:id="formula_43">υ.R[s] → Bag(σ) → (σ → !sdb R) → R[ ] → ! db σ<label>(1)</label></formula><p>where Bag(σ) is a primitive type representing a multiset of objects of type σ. The exponential mechanism takes a set of possible outputs, a quality score that assigns to each element in the range a number (depending on the database), and the database itself. The quality score is at most s-sensitive in the database, and here we allow this sensitivity to be passed in as a parameter. The algorithm privately outputs an element of the range that approximately maximizes the quality score.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Case Studies</head><p>To illustrate how DFuzz's dependent types expand the range of programs that can be certified as differentially private, we now present four examples of practical algorithms that can be implemented in DFuzz, but not in Fuzz. Each algorithm is taken from a different paper from the differential privacy literature (specifically, <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b26">27]</ref>). The first three algorithms rely on the following new feature that is enabled by DFuzz's dependent types:</p><p>Iterative privacy: The ability to express a dependency between the total privacy cost of a function and a parameter that is chosen at runtime, such as a number of iterations.</p><p>The last example illustrates how allowing slightly more complex sensitivity annotations can increase the expressivity, and it also shows another important use for dependent types:</p><p>Privacy-utility tradeoff: The ability of a function to control its own privacy cost, e.g., by scaling the precision of an iterated operation to make the total cost independent of the number of iterations.</p><p>We are experimenting with a prototype implementation of DFuzz, and we present the examples in the actual syntax used by the prototype, an extension of Fuzz that closely follows the concrete syntax from Figure <ref type="figure" target="#fig_6">2</ref> (for instance, we write sample x=e; e' to denote let x = e in e ); we only omit instantiations of size/sensitivity terms for brevity. The examples also use some additional constructs, such as (a,b) for tensor products of types a and b, with associated primitive operations. Details of these extensions are available in <ref type="bibr" target="#b13">[14]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Iterative Privacy</head><p>k-means <ref type="bibr" target="#b3">[4]</ref> Our first example (Figure <ref type="figure" target="#fig_9">10</ref>) is k-means clustering, an algorithm from data mining that groups a set of data points into k clusters. Given a set of points and an initial guess for the k cluster centers, the algorithm iteratively refines the clusters by first associating each point with the closest center, and then moving each center to the middle of its associated points; the differentially private version ensures privacy by adding some noise to the refined centers. The k-means algorithm can be implemented in DFuzz as follows: Here, iterate is a caller-supplied procedure performing Note that the sensitivity of kmeans in the database db depends on two other parameters: the number of iterations [i] and the privacy cost per iteration [e] that the analyst is willing to tolerate. This is enabled by the dependent types in DFuzz; in contrast, Fuzz is only able to typecheck a simplified version of k-means in which both parameters are hard-coded. <ref type="bibr" target="#b18">[19]</ref> Our second example (Figure <ref type="figure" target="#fig_2">11</ref>) is an algorithm that can efficiently answer exponentially many queries with good accuracy. This is done by first constructing a public approximation of the private database, which can then be used to answer queries without further privacy cost. IDC builds the approximation iteratively: given an initial guess, it uses a private distinguisher (PA) to find a query that would be inaccurate on the current approximation and then applies a database update algorithm (DUA) to refine the approximation. PA and DUA are parameters of the algorithm, and the sensitivity of an IDC instance depends on the sensitivities of its PA. This can be expressed in DFuzz as follows: Several choices for PA and DUA have been proposed in the sample approx = (IDC n eps db qs PA DUA); sample q = PA qs approx db; sample actual = add_noise eps (eval_q q db); return (DUA approx q actual) } Figure <ref type="figure" target="#fig_2">11</ref>. Iterative Database Function in DFuzz literature; some can be written directly in DFuzz (e.g., the exponential distinguisher from <ref type="bibr" target="#b21">[22]</ref>), and others can be added as trusted primitives (e.g., the sparse distinguisher from <ref type="bibr" target="#b34">[35]</ref>). By contrast, a parametric IDC cannot be written in plain Fuzz because there is no way to express the dependency between the sensitivity of the PA/DUA and the sensitivity of the overall algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Iterative Database Construction</head><p>Cumulative Distribution Function <ref type="bibr" target="#b26">[27]</ref> Our third example (Figure <ref type="figure" target="#fig_1">12</ref>) is an algorithm that computes the CDF function. Given a database of numeric records and a list of buckets defined by cutoff values, it computes the number of records in each bucket. <ref type="bibr" target="#b26">[27]</ref> presents three variants of this algorithm with different privacy/utility tradeoffs, only one of which was previously supported in Fuzz.  on the number of cutoff values or "buckets." Since Fuzz cannot capture such a dependency, this CDF variant is not just impossible to write in Fuzz-it cannot even be added as a trusted primitive, since there is no way to express its type signature. In contrast, DFuzz can directly support this program, and it could also support the last version in <ref type="bibr" target="#b26">[27]</ref> with a small extension that we discuss in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Privacy-Utility Tradeoff</head><p>Our fourth and most complex example shows how DFuzz enables programmers to write functions that control their own privacy cost, and it also illustrates how small extensions to the language for sensitivity annotations can further increase expressivity. The extension we use here introduces a new operation R1 ˜ R2 on sensitivity terms R1 and R2 that provides a limited form of division. The interpretation is extended accordingly as follows:</p><formula xml:id="formula_44">R1 ˜ R2 ρ = r s if R1 ρ = r ∧ R2 ρ = s ∧ r, s / ∈ {0, ∞} R1 ˜ R2 ρ = 0 if R1 ρ = 0 ∨ R2 ρ = ∞ R1 ˜ R2 ρ = ∞ otherwise</formula><p>The behavior of the ˜ operator is different from that of the ordinary division operator: ˜ does not enjoy the usual properties of division with respect to multiplication and addition, i.e., it is not the inverse of multiplication, and it does not enjoy the usual distributivity laws. However, it does have two key properties. First, Lemma (3.1) still holds for the system that includes ˜ . If the usual division ÷ were added instead, the interpretation would no longer be total because r ÷ 0 and ∞ ÷ ∞ are in general undefined when ÷ is the inverse of • and enjoys the usual distributivity laws. The choice of ˜ ensures the preservation of the metatheoretic results of Sections 4 and 5.</p><p>Second, the interpretation of ˜ satisfies the following inequality (the need for which will become apparent shortly) for every ρ:</p><formula xml:id="formula_45">(R1 ˜ (R2 + 1)) • R2 ρ ≤ R1 ρ<label>(2)</label></formula><p>In terms of ˜ , we can add a safe division primitive to the language for terms:</p><formula xml:id="formula_46">div : ∀i : υ.∀j : υ.R[i] → R[j + 1] → R[i ˜ (j + 1)]</formula><p>Note that the div operation is simply a restriction of the usual division to positive real numbers that we make total by restricting the domain of the denominator to reals greater than or equal to 1.</p><p>k-medians <ref type="bibr" target="#b17">[18]</ref> With this extension, we can implement our fourth example (Figure <ref type="figure" target="#fig_12">13</ref>): an algorithm for k-medians, a classic problem in combinatorial optimization. Given a database V of locations, with distances between locations, a desired number k of (say) factories to build, and a private demand set D ⊆ V , the goal is to select a set F ⊆ V of k locations to minimize the cost, defined to be the sum of the distances from each demand point to the closest factory. In the program, the distances are given implicitly via the cost function, which maps sets of factory locations to costs. The algorithm starts with an initial random choice F0 of k locations and runs several iterations, each time using the exponential mechanism (Equation (1) in Section 5.4) to find the best location to swap for a location in the candidate set of factories. After building up a collection of candidate factory sets, the mechanism uses the exponential mechanism once more to choose the best configuration. The helper function kmedians_aux runs the main loop, which repeatedly tries to improve the cost of a set of locations by replacing a location from the set with one that is not in the set. The outer kmedians function simply chooses an initial (random) set of factory locations and sets up the privacy and iteration constants.</p><p>The program uses several primitive functions for manipulating bags: bagcontains checks the membership in bags, bagproduct builds the Cartesian product of two bags, bagadd adds an element to a bag, bagswap swaps two element in a bag, and bagselect chooses subset of a given size from a bag uniformly at random. The helper function score measures how much a swap can improve the cost of a set of locations. It can also be written in DFuzz (see <ref type="bibr" target="#b13">[14]</ref>).</p><p>The key challenge in implementing k-medians is that it scales the privacy level of the exponential mechanism to achieve a con- To derive the correct type for kmedians, DFuzz must prove that, in the call to the auxiliary function kmedians_aux, the sensitivity of D is at most eps. This involves checking a subtyping application that requires the following inequality between sensitivity terms:</p><formula xml:id="formula_47">((e ˜ (i + 1)) ˜ (2 • s + 1)) • (2 • s) • i ≤ e</formula><p>This inequality follows from two applications of Equation ( <ref type="formula" target="#formula_45">2</ref>). Thus, with the additional ˜ operator, algorithms that scale their privacy cost depending on the number of iterations can be expressed and verified in DFuzz, using dependent types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Related Work</head><p>Differential privacy Our system provides differential privacy <ref type="bibr" target="#b11">[12]</ref>, one of the strongest privacy guarantees that has been proposed to date. Alternatives include randomization, l-diversity, and kanonymity, which are generally less restrictive but can be vulnerable to certain attacks on privacy <ref type="bibr" target="#b23">[24]</ref>. Differential privacy offers a provable bound on the amount of information an attacker can learn about any individual, even with access to auxiliary information.</p><p>PINQ <ref type="bibr" target="#b25">[26]</ref> is an SQL-like differentially private query language embedded in C#; Airavat <ref type="bibr" target="#b35">[36]</ref> is a MapReduce-based solution using a modified Java VM. Both PINQ and Airavat check privacy at runtime, while DFuzz uses a static check. The other previous work in this area is Fuzz <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b33">34]</ref>, on which DFuzz is based. DFuzz has a richer type system: while Fuzz uses linear types to track sensitivity, DFuzz uses a combination of linear indexed types and lightweight dependent types, which substantially expands the set of differentially private queries that can be certified successfully.</p><p>Another recent language-based solution is CertiPriv <ref type="bibr" target="#b2">[3]</ref>. This is a machine-assisted framework-built on top of the Coq proof assistant-for reasoning about differential privacy from first principles. CertiPriv can certify even more queries than DFuzz, including queries that do not rely on standard building blocks such as the Laplace mechanism-indeed, it can be used to prove the correctness of the Laplace mechanism itself. However, this comes at the cost of much higher complexity and less automation, making CertiPriv more suitable for experts who are expanding the boundaries of differential privacy. In contrast, DFuzz's certification is automatic, allowing it to target a broader class of potential users.</p><p>Other work in this area include Xu <ref type="bibr" target="#b38">[39]</ref>, who considered differential privacy in a distributed setting, using a probabilisitc process calculus, and Mohan et al. <ref type="bibr" target="#b28">[29]</ref>, who introduce a platform for private data analysis that optimizes error for certain queries.</p><p>Linear dependent types Linear types, inspired by Girard's linear logic <ref type="bibr" target="#b14">[15]</ref>, have emerged as key tools to support fine grained reasoning about resource management <ref type="bibr" target="#b36">[37]</ref>. In this context, the idea of using indexed modalities !p for counting multiple uses of the same resource, as we do, emerged early on. Bounded Linear Logic <ref type="bibr" target="#b15">[16]</ref> introduced modalities indexed by polynomial expressions. Those are similar to our sensitivity annotations with the essential difference that they are polynomials over natural numbers, while we consider polynomials over the reals augmented with ∞. This approach has been extended in <ref type="bibr" target="#b8">[9]</ref> by constrained universal and existential quantifiers, providing mechanisms for polymorphism and abstraction over polynomial expressions similar to the ones made available by our quantifiers over size and sensitivity variables.</p><p>Different forms of lightweight dependent types form the basis for programming languages such as Dependent ML, ATS, and Epigram. Moreover, they have also started to be incorporated in more standard programming languages, such as Haskell <ref type="bibr" target="#b39">[40]</ref>. In all these approaches the types can express richer properties of the program that can then be ensured automatically by type checking.</p><p>ATS <ref type="bibr" target="#b6">[7]</ref> is a language that combines linear and dependent types. Its type system is enriched with a notion of resources that is a type-level representation of memory locations. The management of location resources uses a linear discipline. This aspect makes ATS useful for reasoning about properties of memory and pointers. However, linear types as used in ATS are not enough to reason about the sensitivity of programs.</p><p>Linear indexed types and lightweight dependent types have also been combined in <ref type="bibr" target="#b7">[8]</ref> with the aim of providing a general framework for implicit complexity. The approach in <ref type="bibr" target="#b7">[8]</ref> is similar in spirit to the one developed in the current paper; however, it considers only type-level terms that represent natural numbers, and its typing judgments are parametric in an equational program providing for the semantics of the type-level language. Moreover, <ref type="bibr" target="#b7">[8]</ref> allows a further dependency between different modal operators that is not needed for our analysis. More recently, Krishnaswami et al. <ref type="bibr" target="#b22">[23]</ref> proposed a language that combines linear (non-indexed) types with dependent types in order to provide program modules with a refined control of their state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related notions of privacy and sensitivity</head><p>The study of database privacy and statistical databases has a long history. Recent work includes Dalvi, Ré, and Suciu's study of probabilistic database management systems <ref type="bibr" target="#b9">[10]</ref>, and Machanavajjhala et al.'s comparison of different notions of privacy with respect to real-world census data <ref type="bibr" target="#b24">[25]</ref>.</p><p>Quantitative Information Flow is concerned with how much one piece of a program can affect another, but measures this in terms of how many bits of entropy leak during one execution. While Differential Privacy and Quantitative Information Flow are clearly related concepts, the question of establishing formal relations between them has been approached only recently <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref>.</p><p>Provenance analysis in databases tracks the input data actually used to compute a query's output, and is also capable of detecting that the same piece of data was used multiple times to produce a given answer <ref type="bibr" target="#b16">[17]</ref>.</p><p>Palamidessi and Stronati <ref type="bibr" target="#b30">[31]</ref> recently proposed a constraintbased approach to compute the sensitivity of relational algebra queries. Their analysis is able in particular to compute the exact sensitivity for a wide range of queries. In contrast, the goal of our approach is to provide an upper bound on the sensitivity not only of relational queries but also for higher order functional programs.</p><p>Chaudhuri et al. in <ref type="bibr" target="#b5">[6]</ref> study automatic program analyses that establish sensitivity (which they call robustness) of numerical programs. Their approach can also used to ensure differential privacy, although they do not study this application in depth. Our approach differs in that we ensure differential privacy through a logically motivated type system, rather than a program analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusions and Future Work</head><p>We have presented a new core language, DFuzz, for differentially private queries. Like its predecessor, Fuzz, DFuzz has a type system with strong metatheoretic properties, which guarantee that all queries of a certain type are differentially private. The key novelty in DFuzz is a lightweight form of linear dependent types that track size and sensitivity information; this considerably expands the range of programs that can be certified as differentially private. We have demonstrated the expressivity of DFuzz using four example algorithms from the differential privacy literature that can be implemented in Fuzz only in greatly simplified form, or not at all.</p><p>Prototype We are currently working on an algorithmic version of DFuzz and a prototype implementation. The key implementation challenge is related to checking the subtype relation. A natural approach to this problem is to generate numeric and logical constraints that would have to be satisfied in order to type the program, and to then pass these constraints to an external solver. In the case of DFuzz, some of the constraints are over real numbers, but they are of a form that is supported by the Z3 solver <ref type="bibr" target="#b10">[11]</ref>. Since DFuzz's additional constructs and annotations are erasable at runtime, a prototype can share a backend with Fuzz, and is thus able to take advantage of Fuzz's defenses against side channels <ref type="bibr" target="#b19">[20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Possible extensions</head><p>The languages for size and sensitivity annotations we have used in this paper are fairly restrictive, but this is merely a design choice, and not an inherent limitation of the approach. As we have shown in the k-medians example, allowing more complex size and sensitivity annotations can increase the expressivity, though it may also make the generated constraints harder to solve.</p><p>There are other simple increments to the annotation languages that would increase DFuzz's expressivity. For example, <ref type="bibr" target="#b26">[27]</ref> provides a higher-utility algorithm for the cumulative distribution function that uses a divide-and-conquer approach. The resulting sensitivity is proportional to the logarithm of the number of buckets. If logarithms of sizes were added to the annotation language, it would become possible to implement this algorithm. (Of course, this addition would again come at the cost of increasing the difficulty of constraint solving.) Another possible direction would be to include more general data types, as in <ref type="bibr" target="#b37">[38]</ref>, in addition to the precise types L(σ)[S] and N[S] we have focused on. For instance, the private Facility Location algorithm, as presented in <ref type="bibr" target="#b17">[18]</ref>, is similar to k-medians, but, instead of a fixed number of factories to build, we are given a fixed cost per factory, and the goal is to minimize the total cost. This algorithm requires recursion over generalized trees, which we speculate could be implemented in DFuzz if support for sized versions of these data types were added.</p><p>Limitations and future work We designed DFuzz to certify algorithms for which the differential privacy property can essentially be proven with a rich compositional sensitivity analysis to show that the noise is drawn from an appropriate distribution. However, in the differential privacy literature there are algorithms whose analysis requires more involved reasoning. One example is the private version of the Unweighted Vertex Cover algorithm that was presented in <ref type="bibr" target="#b17">[18]</ref>. One way to handle the analysis for this algorithm would be to use the probabilistic relational reasoning that is the basis of the CertiPriv framework <ref type="bibr" target="#b2">[3]</ref>. The ability to reason about relations between different programs and data, i.e., about closely neighboring databases, seems crucial to this approach. However, by using the CertiPriv framework, one loses the ability to reason about differential privacy in an automated way. One natural way to preserve the automatic approach and to nevertheless expand the scope of the analysis would be to combine the approach of DFuzz with a limited form of relational reasoning.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>κ</head><label></label><figDesc>::= ι | υ (kinds) Z ::= N[S] | L(τ )[S] | R[R] | P[S](precise types)α ::= R | db (basic types)a ::= ∀i : κ.τ | ∃i : κ.τ (quantified types)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 .Figure 2 .</head><label>12</label><figDesc>Figure 1. DFuzz Types</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>4. 1 . 1</head><label>11</label><figDesc>Lemma [Assumption Strengthening]: Suppose that φ; Ψ |= Φ. Then, we have: 1. If φ; Φ |= C, then φ; Ψ |= C. 2. If φ; Φ |= σ τ , then φ; Ψ |= σ τ . 3. If φ; Φ; Γ e : σ, then φ; Ψ; Γ e : σ. 4. If φ; Φ; Γ s : σ, then φ; Ψ; Γ s : σ. Proof: (1) follows directly from the transitivity of the logical implication; (2) follows by induction on the derivation proving φ; Φ |= σ τ , using Point 1 when needed. (3) follows by induction on the derivation proving φ; Φ; Γ e : σ, using Point 2 when needed. (4) follows by induction on the derivation proving φ; Φ; Γ s : σ, using Point 3 when needed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>4. 1 . 2</head><label>12</label><figDesc>Lemma [Instantiation]: 1. If φ, i : κ; Φ |= C, then, for every φ I : κ, we have φ; Φ{I/i} |= C{I/i}. 2. If φ, i : κ; Φ |= σ τ , then, for every φ I : κ, we have φ; Φ{I/i} |= σ{I/i} τ {I/i}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. Selected Evaluation Rules</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>4. 2 . 1</head><label>21</label><figDesc>Theorem [Substitution]: If φ; Φ; Γ, x : !Rτ e : σ and φ; Φ; ∆ g : τ , then φ; Φ; Γ + R • ∆ e{g/x} : σ. Proof: By induction on the derivation proving φ; Φ; Γ, x : !Rτ e : σ.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>2 .</head><label>2</label><figDesc>If s : σ and s → s , then s : σ. Proof: Part (1) proceeds by induction on the derivation proving e : σ and case analysis on the possible derivations for e → e , using the Substitution Lemma (4.2.1). Lemmas (4.1.1) and (4.1.2) are needed when the step taken comes from a dependent pattern matching rule. Part (2) now follows by induction on the derivation proving s : σ and case analysis on the possible derivations for s → s , using Point 1 when needed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>2 .</head><label>2</label><figDesc>If s ≈r s : σ, and ∅; ∅ σ τ , then s ≈r s : τ .Proof: (1) by induction on the derivation proving e ≈r e : σ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>5. 3 . 2</head><label>32</label><figDesc>Theorem [ -Differential Privacy]: The execution of any closed program e such that e : ! σ τ is an -differentially private function from σ to τ . That is, for all closed values v, v : σ such that v ∼r v : σ, and all closed values w : τ , if do(e v) → f and do(e v ) → f , then Pr f [w] ≤ e r Pr f [w]. Proof: By using the fact that {v/x} ∼ (x:=r) {v /x} : (x : σ), we have that do(e x){v/x} ≈r do(e x){v /x} : τ . So, by the Big-step Metric Preservation Theorem (5.2.8), we obtain f ≈r f : τ . We conclude by Corollary (5.2.4) and Lemma (5.3.1).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 10 .</head><label>10</label><figDesc>Figure 10. k-means in DFuzz an update of the centers (details omitted for brevity).Note that the sensitivity of kmeans in the database db depends on two other parameters: the number of iterations [i] and the privacy cost per iteration [e] that the analyst is willing to tolerate. This is enabled by the dependent types in DFuzz; in contrast, Fuzz is only able to typecheck a simplified version of k-means in which both parameters are hard-coded.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>function IDC (iter : Nat[i]) (eps : num[e]) (db :[2 * i * e] db_type) (qs : query bag) (PA : (query bag) -&gt; approx_db -&gt; db_type -o[e] Circle query) (DUA : approx_db -&gt; query -&gt; num -&gt; approx_db) (eval_q : query -&gt; db_type -o[1] num) : Circle approx_db { case iter of 0 =&gt; return init_approx | n + 1 =&gt;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 12 .</head><label>12</label><figDesc>Figure 12. Cumulative Distribution Function in DFuzz</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 13 .</head><label>13</label><figDesc>Figure 13. k-medians in DFuzz</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>3 • z + 8)(5 • x) It is easy to see that x : !5R 5 • x : R and λz.3 • z + 8 : !3R R, and Fuzz thus uses the typing rule Γ e : !rτ σ ∆ g : τ Γ + r∆ e g : σ to infer x : !15R (λz.3 • z + 8)(5 • x) : R. This reflects the fact that 3 • (5 • x) + 8 = 15 • x + 8 is 15-sensitive in x. To turn this (deterministic) program into a (randomized) differentially private one, Fuzz introduces a probability monad</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>(s1, . . . , sn)} ≈r+s {p , (s 1 , . . . , s n )} : τ Γ e ≈r e : τ Γ do e ≈r do e : τ δ1 ∼γ δ2 : Γ• ∅; ∅; Γ, ∆ e : σ ∆ δ1e ≈ γ Γ δ2e : σ vi ∼r i v i : σi (∀i) {v1/x1, • • • , vn/xn} ∼ (x 1 :=r 1 ,••• ,xn:=rn) {v 1 /x1, • • • , v n /xn} : (x1 : σ1, . . . , xn : σn)</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>r</cell><cell>|b1 b2| = r</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>r1 ∼r r2 : R</cell><cell>b1 ∼r b2 : db</cell></row><row><cell>x : !Rσ e ≈r e : τ</cell><cell></cell><cell></cell><cell></cell></row><row><cell>λx.e ∼r λx.e : !Rσ</cell><cell>τ</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">| ln(ri/r i )| ≤ s</cell><cell>(∀i)</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">(r1, . . . , rn) ∼s (r 1 , . . . , r n ) : P[n]</cell></row><row><cell cols="2">p ∼r p : P[n]</cell><cell>fi ∼s f i : τ (∀i)</cell><cell>p ∼r p : P[n]</cell><cell>ei ≈s e i : τ (∀i)</cell></row><row><cell cols="3">{p, (f1, . . . , fn)} ∼r+s {p , (f 1 , . . . , f n )} : τ</cell><cell cols="2">{p, (e1, . . . , en)} ∼r+s {p , (e 1 , . . . , e n )} : τ</cell></row><row><cell>p ∼r p : P[n]</cell><cell cols="2">Γ si ≈s s i : τ (∀i)</cell><cell></cell></row><row><cell cols="4">Γ {p, Figure 9. Metric Rules</cell></row><row><cell cols="3">5.3 Well-Typed Programs are -Differentially Private</cell><cell></cell></row></table><note><p><p><p>x : !∞σ e ≈r e : σ fix x.e ∼r fix x.e : σ v ∼r v : σ{I/i} pack(v, I) as ∃i : κ.σ ∼r pack(v , I) as ∃i : κ.σ : ∃i : κ.σ</p>∀ R : κ v{R/i} ∼r v {R/i} : σ{R/i} Λi.v ∼r Λi.v : ∀i : κ.σ</p>The Big-Step Metric Preservation Theorem (5.2.8) ensures that programs map related inputs to related outputs. Combined with the properties of the probability layer, this allow us to show that welltyped programs are differentially private.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>To understand why, consider the following version, implemented in DFuzz: Note that the sensitivity in this version depends</figDesc><table><row><cell>function cdf</cell><cell></cell></row><row><cell cols="2">(eps : num[e]) (buckets : list(num)[i])</cell></row><row><cell cols="2">(db :[i * e] num bag) : Circle list(num)[i]</cell></row><row><cell>{</cell><cell></cell></row><row><cell cols="2">case buckets of</cell></row><row><cell>[]</cell><cell>=&gt; return []</cell></row><row><cell cols="2">| (x :: y) =&gt;</cell></row><row><cell cols="2">let (lt,gt) = bag_split (fun n =&gt; n&lt;x) db;</cell></row><row><cell cols="2">sample count = add_noise eps (bag_size lt);</cell></row><row><cell cols="2">sample bigger = cdf eps y gt;</cell></row><row><cell cols="2">return (count :: bigger)</cell></row><row><cell>}</cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>In<ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b33">34]</ref> the symbol ! appears both in types (as here) and in terms (to help guide typechecking algorithms). Here, for simplicity, we elide uses in terms.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>The main novelty of DFuzz is the way it combines a lightweight form of dependent types, à la Dependent ML<ref type="bibr" target="#b37">[38]</ref>, with a sensitivity analysis inspired by the one in<ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b33">34]</ref>. This combination requires several ingredients, which are formally defined in Figure1(type grammar), Figure2(program syntax), Figure3(kinding<ref type="bibr" target="#b1">2</ref> In<ref type="bibr" target="#b33">[34]</ref>, a fixed value of was baked into the metric on distributions. In contrast, we use the convention from<ref type="bibr" target="#b32">[33]</ref>, where the privacy parameter is not fixed, and is made explicit in the type annotation.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments We thank Emilio Jesús Gallego Arias for many valuable comments on the final version of this work. We thank Mário S. Alvim, Loris D'Antoni, Sanjeev Khanna, Aaron Roth, and the anonymous reviewers for their helpful comments. This research was supported by ONR grants N00014-09-1-0770 and N00014-12-1-0757, and NSF grant #1065060. Marco Gaboardi was supported by the European Community's Seventh Framework Programme (FP7/2007-2013) under grant agreement n • 272487.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">On the relation between Differential Privacy and Quantitative Information Flow</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Alvim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Andres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chatzikokolakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Palamidessi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICALP</title>
		<meeting>ICALP</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Information-theoretic Bounds for Differentially Private Mechanisms</title>
		<author>
			<persName><forename type="first">G</forename><surname>Barthe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Köpf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CSF</title>
		<meeting>CSF</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Probabilistic relational reasoning for differential privacy</title>
		<author>
			<persName><forename type="first">G</forename><surname>Barthe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Köpf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Olmedo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zanella Béguelin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. POPL</title>
		<meeting>POPL</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Practical privacy: the SuLQ framework</title>
		<author>
			<persName><forename type="first">A</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Dwork</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Mcsherry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nissim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. PODS</title>
		<meeting>PODS</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Differentially private empirical risk minimization</title>
		<author>
			<persName><forename type="first">K</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Monteleoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Sarwate</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mach. Learn. Res</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="1069" to="1109" />
			<date type="published" when="2011-07">July 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Proving programs robust</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lublinerman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Navidpour</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. FSE</title>
		<meeting>FSE</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Combining programming with theorem proving</title>
		<author>
			<persName><forename type="first">C</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Xi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICFP</title>
		<meeting>ICFP</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="66" to="77" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Linear dependent types and relative completeness</title>
		<author>
			<persName><forename type="first">U</forename><surname>Lago</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gaboardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE LICS &apos;11</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="133" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Bounded linear logic, revisited</title>
		<author>
			<persName><forename type="first">U</forename><surname>Lago</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hofmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TLCA</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5608</biblScope>
			<biblScope unit="page" from="80" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Probabilistic databases: diamonds in the dirt</title>
		<author>
			<persName><forename type="first">N</forename><surname>Dalvi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ré</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="86" to="94" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Z3: An efficient SMT solver</title>
		<author>
			<persName><forename type="first">L</forename><surname>De Moura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Bjørner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. TACAS</title>
		<meeting>TACAS</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Differential privacy</title>
		<author>
			<persName><forename type="first">C</forename><surname>Dwork</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICALP</title>
		<meeting>ICALP</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Calibrating noise to sensitivity in private data analysis</title>
		<author>
			<persName><forename type="first">C</forename><surname>Dwork</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Mcsherry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nissim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. TCC</title>
		<meeting>TCC</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Linear dependent types for differential privacy</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gaboardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Haeberlen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hsu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Narayan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<ptr target="http://privacy.cis.upenn.edu/papers/dfuzz-long.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Linear logic</title>
		<author>
			<persName><forename type="first">J</forename><surname>Girard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comp. Sci</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="102" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Bounded linear logic</title>
		<author>
			<persName><forename type="first">J</forename><surname>Girard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Scedrov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">97</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="66" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Provenance semirings</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Karvounarakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. PODS</title>
		<meeting>PODS</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Differentially private combinatorial optimization</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ligett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Mcsherry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Talwar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SODA</title>
		<meeting>SODA</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Iterative constructions and private data release</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ullman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. TCC</title>
		<meeting>TCC</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Differential privacy under fire</title>
		<author>
			<persName><forename type="first">A</forename><surname>Haeberlen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Narayan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Security</title>
		<meeting>USENIX Security</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Singleton, union and intersection types for program extraction</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hayashi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. TACS</title>
		<meeting>TACS</meeting>
		<imprint>
			<publisher>Springer Berlin / Heidelberg</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">526</biblScope>
			<biblScope unit="page" from="701" to="730" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">What can we learn privately?</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Kasiviswanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">K</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nissim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Raskhodnikova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. FOCS</title>
		<meeting>FOCS</meeting>
		<imprint>
			<date type="published" when="2008-10">Oct. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Superficially substructural types</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">R</forename><surname>Krishnaswami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Turon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dreyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Garg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICFP</title>
		<meeting>ICFP</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">t-closeness: Privacy beyond k-anonymity and l-diversity</title>
		<author>
			<persName><forename type="first">N</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Venkatasubramanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICDE</title>
		<meeting>ICDE</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Privacy: Theory meets practice on the map</title>
		<author>
			<persName><forename type="first">A</forename><surname>Machanavajjhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kifer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Abowd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gehrke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Vilhuber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICDE</title>
		<meeting>ICDE</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Privacy integrated queries: an extensible platform for privacy-preserving data analysis</title>
		<author>
			<persName><forename type="first">F</forename><surname>Mcsherry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD</title>
		<meeting>SIGMOD</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Differentially-private network trace analysis</title>
		<author>
			<persName><forename type="first">F</forename><surname>Mcsherry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mahajan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGCOMM</title>
		<meeting>SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Mechanism design via differential privacy</title>
		<author>
			<persName><forename type="first">F</forename><surname>Mcsherry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Talwar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. FOCS</title>
		<meeting>FOCS</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">GUPT: privacy preserving data analysis made easy</title>
		<author>
			<persName><forename type="first">P</forename><surname>Mohan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Thakurta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Culler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD</title>
		<meeting>SIGMOD</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Robust de-anonymization of large sparse datasets</title>
		<author>
			<persName><forename type="first">A</forename><surname>Narayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shmatikov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE S&amp;P</title>
		<meeting>IEEE S&amp;P</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Differential privacy for relational algebra: Improving the sensitivity bounds via constraint systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Palamidessi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stronati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Proc. QAPLS</title>
		<imprint>
			<biblScope unit="volume">85</biblScope>
			<biblScope unit="page" from="92" to="105" />
			<date type="published" when="2012">2012</date>
			<publisher>EPTCS</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Stochastic lambda calculus and monads of probability distributions</title>
		<author>
			<persName><forename type="first">N</forename><surname>Ramsey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pfeffer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. POPL</title>
		<meeting>POPL</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Distance makes the types grow stronger: A calculus for differential privacy</title>
		<author>
			<persName><forename type="first">J</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gaboardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<ptr target="http://privacy.cis.upenn.edu/papers/fuzz-long.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Distance makes the types grow stronger: A calculus for differential privacy</title>
		<author>
			<persName><forename type="first">J</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICFP</title>
		<meeting>ICFP</meeting>
		<imprint>
			<date type="published" when="2010-09">Sept. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">The median mechanism: Interactive and efficient privacy with multiple queries</title>
		<author>
			<persName><forename type="first">A</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Roughgarden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. STOC</title>
		<meeting>STOC</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Airavat: security and privacy for MapReduce</title>
		<author>
			<persName><forename type="first">I</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T V</forename><surname>Setty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kilzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shmatikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Witchel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NSDI</title>
		<meeting>NSDI</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Advanced Topics in Types and Programming Languages, chapter Substructural Type Systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>The MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Dependent types in practical programming</title>
		<author>
			<persName><forename type="first">H</forename><surname>Xi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pfenning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. POPL</title>
		<meeting>POPL</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Modular reasoning about differential privacy in a probabilistic process calculus</title>
		<author>
			<persName><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note>Manuscript</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Giving Haskell a promotion</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Yorgey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Weirich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cretin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">Peyton</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vytiniotis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P M</forename><surname>Es</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. TLDI</title>
		<meeting>TLDI</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
