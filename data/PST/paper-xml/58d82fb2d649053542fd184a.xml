<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Graphlet Decomposition: Framework, Algorithms, and Applications</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2016-02-15">15 Feb 2016</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Nesreen</forename><forename type="middle">K</forename><surname>Ahmed</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Intel Labs</orgName>
								<orgName type="institution" key="instit2">Intel Corporation</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jennifer</forename><surname>Neville</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Purdue University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ryan</forename><surname>Rossi</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Palo Alto Research Center (PARC)</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Nick</forename><forename type="middle">G</forename><surname>Duffield</surname></persName>
							<affiliation key="aff3">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution">Texas A&amp;M University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Theodore</forename><forename type="middle">L</forename><surname>Willke</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Intel Labs</orgName>
								<orgName type="institution" key="instit2">Intel Corporation</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Graphlet Decomposition: Framework, Algorithms, and Applications</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2016-02-15">15 Feb 2016</date>
						</imprint>
					</monogr>
					<idno type="arXiv">arXiv:1506.04322v2[cs.SI]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T08:57+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Graphlet</term>
					<term>Motif</term>
					<term>Graph Mining</term>
					<term>Graph Kernel</term>
					<term>Classification</term>
					<term>Graph Features</term>
					<term>Higher-order Graph Statistics</term>
					<term>Biological Networks</term>
					<term>Visual Graph Analytics</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>From social science to biology, numerous applications often rely on graphlets for intuitive and meaningful characterization of networks at both the global macro-level as well as the local micro-level. While graphlets have witnessed a tremendous success and impact in a variety of domains, there has yet to be a fast and efficient approach for computing the frequencies of these subgraph patterns. However, existing methods are not scalable to large networks with millions of nodes and edges, which impedes the application of graphlets to new problems that require large-scale network analysis. To address these problems, we propose a fast, efficient, and parallel algorithm for counting graphlets of size k = {3, 4}-nodes that take only a fraction of the time to compute when compared with the current methods used. The proposed graphlet counting algorithms leverages a number of proven combinatorial arguments for different graphlets. For each edge, we count a few graphlets, and with these counts along with the combinatorial arguments, we obtain the exact counts of others in constant time. On a large collection of 300+ networks from a variety of domains, our graphlet counting strategies are on average 460x faster than current methods. This brings new opportunities to investigate the use of graphlets on much larger networks and newer applications as we show in the experiments. To the best of our knowledge, this paper provides the largest graphlet computations to date as well as the largest systematic investigation on over 300+ networks from a variety of domains.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Recursive decomposition of networks is a widely used approach in network analysis to factorize the complex structure of real-world networks into small subgraph patterns of size k nodes. These patterns are called graphlets <ref type="bibr" target="#b27">(Pr?ulj, Corneil and Jurisica, 2004)</ref>. Graphlets (also known as motifs <ref type="bibr" target="#b25">(Milo, Shen-Orr, Itzkovitz, Kashtan, Chklovskii and Alon, 2002)</ref>) are defined as subgraph patterns recurring in real-world networks at frequencies that are statistically significant from those in random networks. Given a network, we can count the number of embedding of each graphlet in the network, creating a profile of sufficient statistics that characterizes the network structure <ref type="bibr" target="#b32">(Shervashidze, Petri, Mehlhorn, Borgwardt and Vishwanathan, 2009)</ref>. While knowing the graphlet frequencies does not uniquely define the network structure, it has been shown that graphlet frequencies often carry significant information about the local network structure in a variety of domains <ref type="bibr" target="#b15">(Holland and Leinhardt, 1976;</ref><ref type="bibr" target="#b4">Faust, 2010;</ref><ref type="bibr" target="#b6">Frank, 1988)</ref>. This is in contrast to global topological properties (e.g., diameter, degree distribution), where networks with similar/exact global topological properties can exhibit significantly different local structures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.">Graphlets, Scalability, &amp; Applications</head><p>From social science to biology, graphlets have found numerous applications and were used as the building blocks of network analysis <ref type="bibr" target="#b25">(Milo et al., 2002)</ref>. In social science, graphlet analysis (typically known as k-subgraph census) is widely adopted in sociometric studies <ref type="bibr" target="#b15">(Holland and Leinhardt, 1976;</ref><ref type="bibr" target="#b6">Frank, 1988)</ref>. Much of the work in this vein focused on analyzing triadic tendencies as important structural features of social networks (e.g., transitivity or triadic closure) as well as analyzing triadic configurations as the basis for various social network theories (e.g., social balance, strength of weak ties, stability of ties, or trust <ref type="bibr" target="#b10">(Granovetter, 1983)</ref>). In biology <ref type="bibr" target="#b27">(Pr?ulj et al., 2004;</ref><ref type="bibr" target="#b23">Milenkoviae and Pr?ulj, 2008)</ref>, graphlets were widely used for protein function prediction <ref type="bibr" target="#b32">(Shervashidze et al., 2009)</ref>, network alignment <ref type="bibr" target="#b24">(Milenkovi?, Ng, Hayes and Pr?ulj, 2010)</ref>, and phylogeny <ref type="bibr" target="#b19">(Kuchaiev, Milenkovi?, Memi?evi?, Hayes and Pr?ulj, 2010)</ref> to name a few. More recently, there has been an increased interest in exploring the role of graphlet analysis in computer networking <ref type="bibr" target="#b5">(Feldman and Shavitt, 2008;</ref><ref type="bibr" target="#b12">Hales and Arteconi, 2008;</ref><ref type="bibr" target="#b1">Becchetti, Boldi, Castillo and Gionis, 2008</ref>) (e.g., for web spam detection, analysis of peer-to-peer protocols and Internet AS graphs), chemoinformatics <ref type="bibr" target="#b28">(Ralaivola, Swamidass, Saigo and Baldi, 2005;</ref><ref type="bibr" target="#b16">Kashima, Saigo, Hattori and Tsuda, 2010)</ref>, image segmentation <ref type="bibr" target="#b41">(Zhang, Song, Liu, Liu, Bu and Chen, 2013)</ref>, among others <ref type="bibr" target="#b40">(Zhang, Han, Yang, Song, Yan and Tian, 2013)</ref>.</p><p>While graphlet counting and discovery have witnessed a tremendous success and impact in a variety of domains from social science to biology, there has yet to be a fast and efficient approach for computing the frequencies of these patterns. For instance, Shervashidze et al. <ref type="bibr" target="#b32">(Shervashidze et al., 2009)</ref> takes hours to count graphlets on relatively small biological networks (i.e., few hundreds/thousands of nodes/edges) and uses such counts as features for graph classification <ref type="bibr" target="#b37">(Vishwanathan, Schraudolph, Kondor and Borgwardt, 2010)</ref>. Previous work showed that graphlet counting is computationally intensive since the number of possible k-subgraphs in a graph G increases exponentially with k in O(|V | k ) and can be computed in O(|V |.? k-1 ) for any bounded degree graph, where ? is the maximum degree of the graph <ref type="bibr" target="#b32">(Shervashidze et al., 2009)</ref>.</p><p>To address these problems, we propose a fast, efficient, and parallel algorithm for counting graphlets of size k = {3, 4}-nodes that take only a fraction of the time to compute when compared with the current methods used. The proposed graphlet counting algorithm leverages a number of proven combinato-rial arguments for different graphlets. For each edge, we count a few graphlets, and with these counts along with the combinatorial arguments, we obtain the exact counts of others in constant time. On a large collection of 300+ networks from a variety of domains, our graphlet counting strategies are on average 460x faster than current methods. This brings new opportunities to investigate the use of graphlets on much larger networks and newer applications as we show in our experiments. To the best of our knowledge, this paper provides the largest graphlet computations to date as well as the largest systematic investigation on over 300+ networks.</p><p>Furthermore, a number of important machine learning tasks are likely to benefit from such an approach, including graph anomaly detection <ref type="bibr" target="#b26">(Noble and Cook, 2003)</ref>, as well as using graphlets as features for improving community detection <ref type="bibr" target="#b31">(Schaeffer, 2007)</ref>, role discovery <ref type="bibr" target="#b30">(Rossi and Ahmed, 2015b)</ref>, graph classification <ref type="bibr" target="#b37">(Vishwanathan et al., 2010)</ref>, and relational learning <ref type="bibr" target="#b7">(Getoor and Taskar, 2007)</ref>.</p><p>We test the scalability of our proposed approach experimentally on 300+ networks from a variety of domains, such as biological, social, and technological domains. We compare our approach to the state-of-the-art exact counting methods such as RAGE <ref type="bibr" target="#b21">(Marcus and Shavitt, 2012)</ref>, FANMOD <ref type="bibr" target="#b39">(Wernicke and Rasche, 2006)</ref>, and Orca <ref type="bibr" target="#b14">(Ho?evar and Dem?ar, 2014)</ref>. We found that RAGE <ref type="bibr" target="#b21">(Marcus and Shavitt, 2012)</ref> took 2400 seconds to count graphlets on a small 26k node graph, whereas our proposed method is 460x faster, taking only 0.01 seconds. We also note that FANMOD <ref type="bibr" target="#b39">(Wernicke and Rasche, 2006)</ref>, another recent approach, takes 172800 seconds, and Orca <ref type="bibr" target="#b14">(Ho?evar and Dem?ar, 2014)</ref> takes 2.5 seconds for the same small graph. Our exact graphlet analysis is well-suited for shared-memory multi-core architectures (CPU and GPU), distributed architectures (MPI), and hybrid implementations that leverage the advantages of both.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2.">Contributions</head><p>? Algorithms. A fast, efficient, and parallel graphlet counting algorithm that leverages a number of combinatorial arguments that we show for different graphlets. The combinatorial arguments we show in this paper enable us to obtain significant improvement on the scalability of graphlet counting. ? Scalability. The proposed graphlet counting algorithm achieves on average 460x runtime improvement over the state-of-the-art methods. In addition, we analyze graphlet counts on graphs of sizes that are beyond the scope of the state-of-the-art (e.g., on graphs with hundred million nodes and billion edges). ? Effectiveness. Largest graphlet computations to date and largest systematic evaluation on over 300+ large-scale networks from a variety of domains. ? Applications. We systematically investigate a variety of existing and new applications for graphlet counting, such as finding unique patterns in graphs, graph similarity, and graph classification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Background</head><p>Graphlets are subgraph patterns recurring in real-world networks at frequencies that are significantly higher than those in random networks <ref type="bibr" target="#b25">(Milo et al., 2002</ref>; </p><formula xml:id="formula_0">g4 8 4-node-2-star 0.33 2 1.0 -1.00 0 1 2 2 1 2 g4 9 4-node-2-edge 0.33 1 1.0 1.00 0 1 2 1 0 2 g4 10 4-node-1-edge 0.17 1 0.5 1.00 0 1 2 1 0 3 g4 11 4-node- independent 0.00 0 0.0 0.00 0 0 1 ? 0 4 (k = 3)-Graphlets g3 1 triangle 1.00 2 2.0 1.00 1 2 3 1 0 1 g3 2 2-star 0.67 2 1.33 -1.00 0 1 2 2 1 1 g3 3 3-node-1-edge 0.33 1 0.67 1.00 0 1 2 1 0 2</formula><p>g3 4 3-nodeindependent 0.00 0 0.00 0.00 0 0 1 ? 0 3</p><formula xml:id="formula_1">(k = 2)-Graphlets g2 1 edge 1.00 1 1.0 1.00 0 1 2 1 0 1</formula><p>g2 2 2-nodeindependent 0.00 0 0.0 0.00 0 0 1 ? 0 2 <ref type="bibr" target="#b27">Pr?ulj et al., 2004)</ref>. Previous work showed that graphlets can be used to define universal classes of networks <ref type="bibr" target="#b25">(Milo et al., 2002)</ref>. Moreover, graphlets are at the heart and foundation of many network analysis tasks (e.g., network classification, network alignment, etc.) <ref type="bibr" target="#b27">(Pr?ulj et al., 2004;</ref><ref type="bibr" target="#b23">Milenkoviae and Pr?ulj, 2008;</ref><ref type="bibr" target="#b13">Hayes, Sun and Pr?ulj, 2013)</ref>. In this paper, we introduce an efficient algorithm to compute the number of embedding of each graphlet of size k = {2, 3, 4} nodes in the network (see Table <ref type="table" target="#tab_0">1</ref> for notation).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Notation and Definitions</head><p>Given an undirected simple input graph G = (V, E), a graphlet of size k nodes is defined as any subgraph G k ? G which consists of a subset of k nodes of the graph G. In this paper, we mainly focus on computing the frequencies of induced graphlets. An induced graphlet is an induced subgraph that consists of all edges between its nodes that are present in the input graph (as described in Definition 1). In addition, we distinguish between connected and disconnected graphlets (see Table <ref type="table" target="#tab_0">1</ref>). A graphlet is connected if there is a path from any node to any other node in the graphlet (see Definition 2). Table <ref type="table" target="#tab_0">1</ref> provides a summary of the notation and properties of all possible induced graphlets of size k = {2, 3, 4}.</p><p>Definition 1. Induced Graphlet: an induced graphlet</p><formula xml:id="formula_2">G k = (V k , E k ) is a sub- graph that consists of a subset of k vertices of the graph G = (V, E) (i.e., V k ? V )</formula><p>together with all the edges whose endpoints are both in this subset (i.e.,  <ref type="bibr" target="#b11">(Gross, Yellen and Zhang, 2013)</ref>.</p><formula xml:id="formula_3">E k = {?e ? E | e = (u, v) ? u, v ? V k }). Definition 2. Connected Graphlet: a graphlet G k = (V k , E k ) is connected</formula><p>A graphlet g ki ? G k is embedded in the graph G, if and only if there is an injective mapping ? : V g k i ? V , with e = (u, v) ? E g k i if and only if e = (?(u), ?(v)) ? E. Table <ref type="table" target="#tab_0">1</ref> shows that |G k | = {2, 4, 11} when k = {2, 3, 4} respectively. Further, given a family G k = {g k1 , g k2 , ..., g km } of graphlets of size k nodes, we define f (g ki , G) as the relative frequency of any graphlet g ki ? G k in the input graph G.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Relationship to Graph Complement</head><p>The complement of a graph G, denoted by ?, is the graph defined on the same vertices as G such that two vertices are connected in ? if and only if they are not connected in G. Therefore, the graph sum G + ? gives the complete graph on the set of vertices of G. There are direct relationships between the frequencies of graphlets and the frequencies of their complement. For each graphlet g ki , there exists a non-isomorphic complementary graphlet pattern ?ki , such that two vertices are connected in ?ki if and only if they are not connected in g ki <ref type="bibr" target="#b11">(Gross et al., 2013)</ref>. For example, cliques and independent sets of size k nodes are pairs of complementary graphlets. Similarly, chordal cycles of size 4 nodes are complementary to the 4-node-1edge graphlet (see Table <ref type="table" target="#tab_0">1</ref>). It is also worth noting that the 4-path graphlet is a self-complementary pattern, which means the 4path is isomorphic to itself. From this discussion, it is clear that the number of embeddings of each graphlet g ki ? G k in the input graph G is equivalent to the number of embeddings of its complementary graphlet ?ki in the complement graph ?. In other words, f (g ki , G) = f (? ki , ?) <ref type="bibr" target="#b11">(Gross et al., 2013)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Relationship to Graph/Matrix Reconstruction Theorems</head><p>The graph reconstruction conjecture <ref type="bibr" target="#b11">(Gross et al., 2013)</ref>, states that an undirected graph G can be uniquely determined up to an isomorphism, from the set of all possible vertex-deleted subgraphs of G (i.e., {G v } v?V ) <ref type="bibr" target="#b22">(McKay, 1997)</ref>. Verification of this conjecture for all possible graphs up to 6 vertices was carried by Kelly <ref type="bibr" target="#b17">(Kelly, 1957)</ref>, and later was extended to up to 11 vertices by <ref type="bibr" target="#b22">McKay (McKay, 1997)</ref>. Clearly, if two graphs are isomorphic (i.e., G ? = G ), then their graphlet frequencies would be the same (i.e., f k (G) = f k (G )), but the reverse remains a conjecture for the general case of graphs. In contrast, the matrix reconstruction theorem has been resolved <ref type="bibr" target="#b20">(Manvel and Stockmeyer, 1971)</ref>, which states that any N ? N matrix can be reconstructed from its list of all possible principal minors obtained by the deletion of the k-th row and the k-th column <ref type="bibr" target="#b20">(Manvel and Stockmeyer, 1971)</ref>, which is the foundation of a class of graph kernels called the graphlet kernel <ref type="bibr" target="#b32">(Shervashidze et al., 2009)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">Related Work</head><p>In this section, we briefly discuss some of the related work, highlighting various graph mining and machine learning tasks that would benefit from our approach. Much of the previous work focused on counting certain types of graphlets (e.g., only connected graphlets such as cliques and cycles) <ref type="bibr" target="#b18">(Kloks, Kratsch and M?ller, 2000;</ref><ref type="bibr" target="#b39">Wernicke and Rasche, 2006;</ref><ref type="bibr" target="#b14">Ho?evar and Dem?ar, 2014)</ref>. However, a number of graph mining and machine learning tasks rely on counting all graphlets of a certain size.</p><p>For example, some previous work used the full spectrum of graphlet frequencies to define a domain-independent coordinate system in which collections of graphs can be compactly represented and analyzed within a common space <ref type="bibr" target="#b36">(Ugander, Backstrom and Kleinberg, 2013)</ref>. Moreover, a variety of graph kernels have been proposed in machine learning (e.g., graphlet, subtree, and random walk kernels) <ref type="bibr" target="#b37">(Vishwanathan et al., 2010;</ref><ref type="bibr" target="#b3">Costa and De Grave, 2010;</ref><ref type="bibr" target="#b32">Shervashidze et al., 2009)</ref> to bridge the gap between graph learning and kernel methods. And some types of the graph kernels, in particular the graphlet kernel, rely on counting all graphlets. However, a general limitation of most graph kernels (including the graphlet kernel) is that they scale poorly to large graphs with more than few hundreds/thousands of nodes <ref type="bibr" target="#b37">(Vishwanathan et al., 2010)</ref>. Thus, our fast algorithms would speedup the computations of these methods and their related applications in graph modeling, similarity, and comparisons.</p><p>Recently, there is an increased interest in sampling and other heuristic approaches for obtaining approximate counts of various graphlets <ref type="bibr" target="#b2">(Bhuiyan, Rahman, Rahman and Al Hasan, 2012;</ref><ref type="bibr" target="#b9">Gonen and Shavitt, 2009)</ref>. However, our approach focuses on exact graphlet counting and thus sampling methods are outside the scope of this paper. Nevertheless, the analysis and combinatorial arguments we show in this paper can be used along with efficient sampling methods to provide more accurate and efficient approximations.</p><p>In addition, the aim and scope of this paper is different from the aforemen-tioned problem of graph reconstruction. While graph reconstruction tries to test for the notion of isomorphism and structure equivalence between graphs, our goal is to relax the notion of equivalence to some form of structural similarity between graphs, such that the graph similarity is measured using the feature representation of graphlets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Framework</head><p>In this section, we describe our approach for graphlet counting that takes only a fraction of the time to compute when compared with the current methods used.</p><p>We introduce a number of combinatorial arguments that we show for different graphlets. The proposed graphlet counting algorithm leverages these combinatorial arguments to obtain significant improvement on the scalability of graphlet counting. For each edge, we count only a few graphlets, and with these counts along with the combinatorial arguments, we derive the exact counts of the others in constant time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Searching Edge Neighborhoods</head><p>Our proposed algorithm iterates over all the edges of the input graph G = (V, E).</p><p>For each edge e = (u, v) ? E, we define the neighborhood of an edge e, denoted by N (e), as the set of all nodes that are connected to the endpoints of ei.e., N (e) = {N (u) \ {v}} ? {N (v) \ {u}}, where N (u) and N (v) are the set of neighbors of u and v respectively. Given a single edge e = (u, v) ? E, we explore the subgraph surrounding this edge -i.e., the subgraph induced by both its endpoints and the nodes in its neighborhood. We call this subgraph the egonet of the edge e, where e is the center (ego) of the subgraph.</p><p>We search for possible graphlet patterns of size k = {3, 4} in the egonets of all edges in the graph. By searching egonets of edges, we first map the problem to the local (lower-dimensional) space induced by the neighborhood of each edge, and then merge the search results for all edges. Searching over a local lowdimensional space of edge neighborhoods is clearly more efficient than searching over the global high-dimensional space of the whole graph. Moreover, searching over a local low-dimensional space of edge neighborhoods is amenable to parallel implementation, which offers additional speedup over iterative methods. Note that exhaustive search of the egonet of any edge e ? E yields at least O(? k-1 ) asymptotically, where ? is the maximum degree in G. Clearly, exhaustive search is computationally intensive for large graphs, and our approach is more efficient as we will show next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Counting Graphlets of Size (k = 3) Nodes</head><p>Algorithm 1 (TriadCensus) shows how to count graphlets of size k = 3 for each edge. There are four possible graphlets of size k = 3 nodes, where only g 31 (i.e., triangle patterns) and g 32 (i.e., 2-star patterns) are connected graphlets (see Table <ref type="table" target="#tab_0">1</ref>).</p><p>Algorithm 1 Our exact triad census algorithm for counting all 3-node graphlets. The algorithm takes an undirected graph as input and returns the frequencies of all 3-node graphlets f (G 3 , G).</p><formula xml:id="formula_4">1: procedure TriadCensus(G = (V, E)) 2:</formula><p>Initialize Array X 3:</p><formula xml:id="formula_5">parallel for e = (u, v) ? E do 4: Staru = ?, Starv = ?, Trie = ? 5: for w ? N (u) do 6: if w = v then continue 7:</formula><p>Add w to Staru and set X(w) = 1 8:</p><formula xml:id="formula_6">for w ? N (v) do 9: if w = u then continue 10: if X(w) = 1 then found triangle 11:</formula><p>Add w to Trie</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>12:</head><p>Remove w from Staru 13:</p><p>else Add w to Starv 14:</p><formula xml:id="formula_7">f (g 3 1 , G) += |Trie| 15: f (g 3 2 , G) += |Staru| + |Starv| 16: f (g 3 3 , G) += |V | -|N (u) ? N (v)| 17: for w ? N (u) do X(w) = 0 18: end parallel 19: f (g 3 1 , G) = 1 /3.f (g 3 1 , G) 20: f (g 3 2 , G) = 1 /2.f (g 3 2 , G) 21: f (g 3 4 , G) = |V | 3 -f (g 3 1 , G) -f (g 3 2 , G) -f (g 3 3 , G) 22: return f (G 3 , G)</formula><p>Connected graphlets of size k = 3.</p><p>Lines 5-13 of Algorithm 1 show how to find and count triangles incident to an edge. For any edge e = (u, v), a triangle (u, v, w) exists, if and only if w is connected to both u and v. Let Tri e be the set of all nodes that form a triangle with e = (u, v), and |Tri e | be the number of such triangles. Then, Tri e is the set of overlapping nodes in the neighborhoods of u and v -Tri e = N (u) ? N (v). Note that Algorithm 1 counts each triangle three times (one time for each edge in the triangle), and therefore we divide the total count by 3 as in Equation ( <ref type="formula" target="#formula_8">1</ref>),</p><formula xml:id="formula_8">f (g 31 , G) = 1 3 . e=(u,v)?E |Tri e |<label>(1)</label></formula><p>Now we need to count 2-star patterns (i.e., g 32 ). For any edge e = (u, v), let Star e be the set of all nodes that form a 2-star with e, and |Star e | be the number of such star patterns. A 2-star pattern (u, v, w) exists, if and only if w is connected to either u or v but not both. Accordingly, Star e = Star u ?Star v , where Star u and Star v are the set of nodes that form a 2-star with e centered at u and v respectively. More formally, Star u can be defined as Star u = {w ? N (u)\{v}|w / ? N (v)}, and Star v can be defined as Star v = {w ? N (v) \ {u}|w / ? N (u)}. Similar to counting triangles, Algorithm 1 counts each 2-star pattern two times (one time for each edge in the 2-star). Thus, we divide the sum for all edges by 2 as follows,</p><formula xml:id="formula_9">f (g 32 , G) = 1 2 . e=(u,v)?E |Star u | + |Star v | (2)</formula><p>Disconnected graphlets of size k = 3.</p><p>There are two disconnected graphlets of size k = 3 nodes, g 33 (i.e., the 3-node-1edge pattern) and g 34 (i.e., the independent set defined on 3 nodes) (see Table <ref type="table" target="#tab_0">1</ref>). Lines 16 and 21 show how to count these patterns. Equation ( <ref type="formula">3</ref>) shows that the number of 3-node-1-edge graphlets per edge e is equivalent to the number of all nodes that are not in the neighborhood subgraph (egonet) of edge e (i.e.,</p><formula xml:id="formula_10">V \ {N (u) ? N (v)}), f (g 33 , G) = e=(u,v)?E |V | -|N (u) ? N (v)| (3)</formula><p>where</p><formula xml:id="formula_11">|N (u) ? N (v)| = |Tri e | + |Star e | + |{u, v}|.</formula><p>Note that the number of 3node-1-edge graphlets can be computed in o(1) for each edge.</p><p>Given that the total number of graphlets of size 3 nodes is N 3 , Equation (4) shows how to compute the frequency of g 34 , which clearly can be done in o(1),</p><formula xml:id="formula_12">f (g 34 , G) = |V | 3 -f (g 31 , G) + f (g 32 , G) + f (g 33 , G)<label>(4)</label></formula><p>The complexity of counting all graphlets of size k = 3 is O(|E|.?) asymptotically as we show next in Lemma 1.</p><p>Lemma 1. Algorithm 1 counts all graphlets of size k = 3-nodes in O(|E|.?).</p><p>Proof. For each edge e = (u, v) such that e ? E, the runtime complexity of counting all triangle and 2-star patterns incident to e (i.e., Tri e , Star e respectively) is O(|N (u)|+|N (v)|), and is asymptotically O(?) where ? is the maximum degree in the graph. Further, the runtime complexity of counting all 3-node-1-edge patterns of size k = 3 incident to e can be counted in constant time o(1). Therefore, the total runtime complexity for counting all graphlets of size k = 3 in the graph is</p><formula xml:id="formula_13">O e?E (? + o(1)) = O(|E|.?).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Counting Graphlets of Size (k = 4) Nodes</head><p>An exhaustive search of the egonet of any edge to count all 4-node graphlets independently yields O(? 3 ) asymptotically, where ? is the maximum degree in G. Clearly, exhaustive search is computationally intensive for large graphs. On the other hand, our approach is hierarchical and more efficient as we show next.</p><p>For each edge e = (u, v), we start by finding triangles and 2-star patterns. Our central principle is that any 4-node graphlet g 4i can be decomposed into four 3-node graphlets <ref type="bibr" target="#b11">(Gross et al., 2013)</ref>, obtained by deleting one node from g 4i each time. Thus, we jointly count all possible 4-node graphlets by leveraging the knowledge obtained from finding 3-node graphlets and some combinatorial arguments that describe the relationships between pairs of graphlets. We summarize this procedure in the following steps:</p><p>? Step 1: For each edge e, find all neighborhood nodes forming triangle and 2-star patterns with e. ? Step 2: For each edge e, use the knowledge from step 1 to count only 4-cliques and 4-cycles. ? Step 3: For each edge e, use the knowledge from step 1 and some combinatorial arguments to compute unrestricted counts for all 4-node graphlets in constant time.</p><p>? Step 4: Merge the counts from all edges in the graph, and use combinatorial arguments involving unrestricted counts to obtain the counts of all other graphlets.</p><p>Note that we refer to the unrestricted counts as the counts that can be computed in constant time and using only the knowledge obtained from step 1. Next, we discuss the details of our approach. We start by discussing the graphlet transition diagram to show the pairwise relationships between different 4-node graphlets. Then, we discuss a general principle for counting 4-node graphlets, which leverages the graphlet transition diagram and some combinatorial arguments to improve the performance of graphlet counting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Graphlet Transition Diagram</head><p>Assume that each graphlet is a state, Fig. <ref type="figure" target="#fig_0">1</ref> shows all possible ?1 edge transitions between the states of all 4-node graphlets. We can transition from one graphlet to another by the deletion (denoted by dashed right arrows) or addition (denoted by solid left arrows) of a single edge. We define six different classes of possible edge roles denoted by the colors from black to orange (see Table in the top-right corner in Fig. <ref type="figure" target="#fig_0">1</ref>). An edge role is an edge-level connectivity pattern (e.g., a chord edge), where two edges belong to the same role (i.e., class) if they are similar in their topological features. For each edge, we define a topological feature vector that consists of the number of triangles and 2-stars incident to this edge. Then, we classify edges to one of the six roles based on their feature vectors. Thus, all edges that appear in 4-node graphlets are colored by their roles. In addition, the transition arrows are colored similar to the edge roles to denote which edge type should be deleted/added to transition from one graphlet to another. Note that a single edge deletion/addition changes the role (class) of other edges in the graphlet. The table in the top-left corner of Fig. <ref type="figure" target="#fig_0">1</ref> shows the number of edge roles per each graphlet.</p><p>For example, consider the 4-clique graphlet (g 41 ), where each edge participates exactly in two triangles. Therefore, all the edges in a 4-clique graphlet (g 41 ) belong to the first role (denoted by the black color). Similarly, consider the 4-chordalcycle (g 42 ), where each edge (except the chord edge) participates exactly in one triangle and one 2-star. Therefore, all edges in a 4-chordalcycle "g 42 " belong to the second role (denoted by the blue color) except for the chord edge which belongs to the first role (denoted by the black color). Fig. <ref type="figure" target="#fig_0">1</ref> shows how to transition from the 4-clique to the 4-chordalcycle "g 42 " by deleting one (any) edge from the 4-clique. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">General Principle for Counting Graphlets of size k = 4</head><p>Generally speaking, suppose we have N (e) distinct 4-node subgraphs that contains an edge e = (u, v),</p><formula xml:id="formula_14">N (e) = {u, v, w, r} | w, r ? V \ {u, v} ? w = r<label>(5)</label></formula><p>Each subgraph {u, v, w, r} in this collection may satisfy one or two properties a i , a j ? A = {T, S u , S v , I}. These properties describe the topological properties of nodes w and r with respect to edge e, such that A w = a i if {u, v, w} forms subgraph pattern a i , and A r = a j if {u, v, r} forms subgraph pattern a j . For example, A w = T if w forms a triangle with e, and A w = S u or S v if w forms a 2star with e centered around u or v respectively. Also, A w = I if w is independent (disconnected) from e. We clarify these properties by example in Fig. <ref type="figure">2</ref>.</p><p>Let N (e) ai,aj denote the number having properties a i , a j ? A,</p><formula xml:id="formula_15">N (e) ai,aj = {u, v, w, r} w,r?V \{u,v} ?w =r ?Aw=ai,Ar=aj<label>(6)</label></formula><p>Now that we defined the topological properties of nodes w and r relative to edge e, we need to define whether nodes w and r are connected themselves. Let e wr represent whether w and r are connected or not, such that e wr = 1 Fig. <ref type="figure">2</ref>. Let T denote the nodes forming triangles with edge (u, v) (i.e., V 2 , V 3 ), whereas Su and Sv denote the nodes forming 2-stars centered at u and v respectively (i.e., V 1 , V 4 ), and let I denote the nodes that are not connected to edge e (i.e., V 5 , V 6 ). Further, the dotted lines represent edges incident to these nodes.</p><p>if (w, r) ? E and e wr = 0 otherwise. Accordingly, let N </p><p>For example, N (e) T,T,1 is the number of all graphlets {u, v, w, r} containing edge e, where both w and r are forming triangles with e and there exist an edge between w and r. Using Equations ( <ref type="formula" target="#formula_15">6</ref>) and ( <ref type="formula" target="#formula_16">7</ref>), we provide a general principle for graphlet counting in the following theorem.</p><p>Theorem 1. General Principle for Graphlet Counting: Given a graph G, for any edge e = (u, v) in G, and for any properties a i , a j ? A, the number of 4-node graphlets {u, v, w, r} satisfies the following rule,</p><formula xml:id="formula_17">N (e) ai,aj ,0 = N (e) ai,aj -N (e) ai,aj ,1<label>(8)</label></formula><p>Proof. Suppose there is a subgraph {u, v, w, r} containing edge e, where nodes w and r satisfy a i , a j properties respectively, and (w, r) ? E. Then the expression on the right side counts this subgraph once in the N (e) ai,aj term, and once in the N (e) ai,aj ,1 . By the principle of inclusion-exclusion <ref type="bibr" target="#b33">(Stanley, 1986)</ref>, the total contribution of the subgraph {u, v, w, r} in N (e) ai,aj ,0 is zero. Thus, N (e) ai,aj ,0 is the number of graphlets having properties a i , a j , but (w, r) / ? E.</p><p>Clearly, it is sufficient to compute N ai,aj is an unrestricted count and can be computed in constant time using the knowledge we have from finding 3-node graphlets.</p><p>To simplify the discussion in the following sections, we precisely show how to compute N (e) ai,aj , the number of 4-node graphlets {u, v, w, r} such that w, r satisfy property a i , a j ? A respectively. Let W ai be the set of nodes with property a i ? A (i.e., W ai = {w ? V \ {u, v} | A w = a i , ?a i ? A}), and similarly R aj be the set of nodes with property a j ? A (i.e., R aj = {r ? V \ {u, v} | A r = a j , ?a j ? A}). If a i = a j , then W ai = R aj . Thus,</p><formula xml:id="formula_18">N (e) ai,ai = |W ai | 2 = 1 2 .(|W ai | -1).|W ai | (9)</formula><p>However, if a i = a j , then W ai and R aj are mutually exclusive (i.e., W ai ? R aj = ?). Thus, we get the following,</p><formula xml:id="formula_19">N (e) ai,aj = |W ai |.|R aj | (10)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Analysis &amp; Combinatorial Arguments</head><p>In this section, we discuss combinatorial arguments involving unrestricted counts that can be computed computed directly from our knowledge of 3-node graphlets. These combinatorial arguments capture the relationships between the counts of pairs of 4-node graphlets. The proofs of these relationships are based on Theorem 1 and the transition diagram in Fig. <ref type="figure" target="#fig_0">1</ref>. For each pair of graphlets g 4i and g 4j , we show the relationship for each edge in the graph (in Corollary 1-14), then we show a generalization for the whole graph (in Lemma 2-8).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1.">Relationship between 4-Cliques &amp; 4-ChordalCycles</head><p>Corollary 1. For any edge e = (u, v) in the graph, the number of 4-cliques containing e is N (e)</p><p>T,T,1 . Corollary 2. For any edge e = (u, v) in the graph, the number of 4-chordalcycles, where e is the chord edge of the cycle (denoted by the black color in Fig. <ref type="figure" target="#fig_0">1</ref>), is N (e) T,T,0 . Lemma 2. For any graph G, the relationship between the counts of 4-cliques (i.e., f (g 41 , G)) and 4-chordalcycles (i.e., f (g 42 , G)) is,</p><formula xml:id="formula_20">f (g 42 , G) = e?E |Tri e | 2 -6.f (g 41 , G)</formula><p>Proof. From Theorem 1 and the addition principle <ref type="bibr" target="#b33">(Stanley, 1986)</ref>, the total count for all edges in G is, </p><p>Given that N (e)</p><p>T,T is the number of 4-node subgraphs {u, v, w, r} containing e, such that A w = T, A r = T . Thus, from Eq. ( <ref type="formula">9</ref>), N</p><p>T,T = |Trie| 2 . From Corollary 1, each 4-clique will be counted 6 times (once for each edge in the clique). Thus,</p><formula xml:id="formula_23">the total count of 4-cliques in G is f (g 41 , G) = 1 6 . e?E N (e)</formula><p>T,T,1 . Similarly, from Corollary 2, each 4-chordalcycle is counted only once for each chord edge. Thus, the total count of 4-chordalcycles in</p><formula xml:id="formula_24">G is f (g 42 , G) = e?E N (e)</formula><p>T,T,0 . By direct substitution in Eq. ( <ref type="formula" target="#formula_21">11</ref>), this lemma is true.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2.">Relationship between 4-Cycles &amp; 4-Paths</head><p>Corollary 3. For any edge e = (u, v) in the graph, the number of 4-cycles containing e is N (e) Su,Sv,1 . Corollary 4. For any edge e = (u, v) in the graph, the number of 4-paths containing e, where e is the middle edge in the path (denoted by the green color in Fig. <ref type="figure" target="#fig_0">1</ref>), is N (e) Su,Sv,0 . Lemma 3. For any graph G, the relationship between the counts of 4-cycles (i.e., f (g 44 , G)) and 4-paths (i.e., f (g 46 , G)) is,</p><formula xml:id="formula_25">f (g 46 , G) = e?E |Star u |.|Star v | -4.f (g 44 , G)</formula><p>Proof. From Theorem 1 and the addition principle <ref type="bibr" target="#b33">(Stanley, 1986)</ref>, the total count for all edges in G is, From Corollary 3, each 4-cycle will be counted 4 times (once for each edge in the cycle). Thus, the total count of 4-cycles in</p><formula xml:id="formula_26">G is f (g 44 , G) = 1 4 . e?E N (e)</formula><p>Su,Sv,1 . Similarly, from Corollary 4, each 4-path is counted only once for each middle edge in the path. Thus, the total count of 4-paths in</p><formula xml:id="formula_27">G is f (g 46 , G) = e?E N (e)</formula><p>Su,Sv,0 . By direct substitution in Eq. ( <ref type="formula">12</ref>), this lemma is true.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.3.">Relationship between 4-TailedTriangles &amp; 4-ChordalCycles</head><p>Corollary 5. For any edge e = (u, v) in the graph, the number of 4-tailedtriangles where e is part of both the triangle and 2-star patterns (denoted by the blue color in Fig. <ref type="figure" target="#fig_0">1</ref>), is N (e) T,Su?Sv,0 . Corollary 6. For any edge e = (u, v) in the graph, the number of 4-chordalcycles where e is a cycle edge (denoted by the blue color in Fig. <ref type="figure" target="#fig_0">1</ref>), is N (e) T,Su?Sv,1 . Lemma 4. For any graph G, the relationship between the counts of 4-chordalcycles (i.e., f (g 42 , G)) and 4-tailedtriangles (i.e., f (g 43 , G)) is,</p><formula xml:id="formula_28">2.f (g 43 , G) = e?E |Tri e |.(|Star u | + |Star v |) -4.f (g 42 , G)</formula><p>Proof. From Theorem 1 and the addition principle <ref type="bibr" target="#b33">(Stanley, 1986)</ref>, the total count for all edges in G is, </p><formula xml:id="formula_29">4-chordalcycle in G is f (g 42 , G) = 1 4 . e?E N (e)</formula><p>T,Su?Sv,1 . Similarly, from Corollary 5, each 4-tailedtriangle will be counted 2 times (once for each blue edge as in Fig. <ref type="figure" target="#fig_0">1</ref>). Thus, the total count of 4-tailedtriangle in</p><formula xml:id="formula_30">G is f (g 43 , G) = 1 2 . e?E N (e)</formula><p>T,Su?Sv,0 . By direct substitution in Eq. ( <ref type="formula">13</ref>), this lemma is true.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.4.">Relationship between 4-TailedTriangles &amp; 3-Stars</head><p>Corollary 7. For any edge e = (u, v) in the graph, the number of 4-tailedtriangles with e as the tail edge (denoted by the green color in Fig. <ref type="figure" target="#fig_0">1</ref>) and u is part of the triangle, is N Sv,Sv,0 . Lemma 5. For any graph G, the relationship between the counts of 3-stars (i.e., f (g 45 , G)) and 4-tailedtriangles (i.e., f (g 43 , G)) is,</p><formula xml:id="formula_31">3.f (g 45 , G) = e?E |Star u | 2 + |Star v | 2 -f (g 43 , G)</formula><p>Proof. From Theorem 1 and the addition principle <ref type="bibr" target="#b33">(Stanley, 1986)</ref>, the total count for all edges in G is, </p><p>Given that N . Now, from Corollary 8, each 3-star is counted 3 times (once for each edge in the star). Thus, the total count</p><formula xml:id="formula_33">of 3-stars in G is f (g 45 , G) = 1 3 . e?E N (e)</formula><p>S.,S.,0 . Similarly, from Corollary 7, each 4-tailedtriangle will be counted once for each tail edge (denoted by the green color in Fig. <ref type="figure" target="#fig_0">1</ref>). Thus, the total count of 4-tailedtriangle in</p><formula xml:id="formula_34">G is f (g 43 , G) = e?E N (e)</formula><p>S.,S.,1 . This holds whether the patterns are centered around u or v. By direct substitution in Eq. ( <ref type="formula" target="#formula_32">14</ref>), this lemma is true.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.5.">Relationship between 4-TailedTriangles &amp; 4-Node-1-Triangles</head><p>Corollary 9. For any edge e = (u, v) in the graph, the number of 4-node-1triangle is N (e) T,I,0 .</p><p>Corollary 10. For any edge e = (u, v) in the graph, the number of 4-tailedtriangles with e participating in the triangle but not connected to the tail edge (denoted by the red color in Fig. <ref type="figure" target="#fig_0">1</ref>), is N (e) T,I,1 .</p><p>Proof. Suppose there is a subgraph {u, v, w, r} containing e. {u, v, w, r} is a 4tailedtriangle with e participating in the triangle but not connected to the tail edge, if and only if there are some nodes w, r such that w ? Tri e , r N (e), and (w, r) ? E. This means r is independent of e, and w forms a triangle with e. As such, A w = T and A r = I and e wr = 1. More generally, any subgraph {u, v, w, r} containing e contributes once in the count N (e) T,I,1 if and only if it is a 4-tailedtriangle with e participating in the triangle but not connected to the tail edge. In Theorem 1, we showed that N Lemma 6. For any graph G, the relationship between the counts of 4-tailedtriangles (i.e., f (g 43 , G)) and 4-node-1-triangles (i.e., f (g 47 , G)) is,</p><formula xml:id="formula_35">3.f (g 47 , G) = e?E Tri e . (|V | -|N (u) ? N (v)|) -f (g 43 , G)</formula><p>Proof. From Theorem 1 and the addition principle <ref type="bibr" target="#b33">(Stanley, 1986)</ref>, the total count for all edges in G is, T,I,1 . Similarly, from Corollary 9, each 4-node-1-triangle will be counted 3 times (once for each edge in the triangle). Thus, the total count of 4-node-1-</p><formula xml:id="formula_36">triangles in G is f (g 47 , G) = 1 3 . e?E N (e)</formula><p>T,I,0 . By direct substitution in Eq. ( <ref type="formula">15</ref>), this lemma is true.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.6.">Relationship between 4-Paths &amp; 4-node-2-Stars</head><p>Corollary 11. For any edge e = (u, v) in the graph, the number of 4-paths where e is the start or end of the path (denoted by the purple color in Fig. <ref type="figure" target="#fig_0">1</ref>), is N (e) Su?Sv,I,1 . Corollary 12. For any edge e = (u, v) in the graph, the number of 4-node-2stars where e is one of the star edges (denoted by the purple color in Fig. <ref type="figure" target="#fig_0">1</ref>), is N (e) Su?Sv,I,0 . Lemma 7. For any graph G, the relationship between the counts of 4-paths (i.e., f (g 46 , G)) and 4-node-2-stars (i.e., f (g 48 , G)) is,</p><formula xml:id="formula_37">2.f (g 48 , G) = e?E |Star e |.(|V | -|N (u) ? N (v)|) -2.f (g 46 , G)</formula><p>Proof. From Theorem 1 and the addition principle <ref type="bibr" target="#b33">(Stanley, 1986)</ref>, the total count for all edges in G is, Corollary 11, each 4-path is counted 2 times (for both the start and end edges in the path, denoted by the purple in Fig. <ref type="figure" target="#fig_0">1</ref>). Thus, the total count of 4-paths in</p><formula xml:id="formula_38">G is f (g 46 , G) = 1 2 . e?E N (e)</formula><p>Su?Sv,I,1 . Similarly, from Corollary 12, each 4-node-2-star will be counted 2 times (once for each edge in the star, denoted by the purple in Fig. <ref type="figure" target="#fig_0">1</ref>). Thus, the total count of 4-node-2-star in</p><formula xml:id="formula_39">G is f (g 48 , G) = 1 2 . e?E N (e)</formula><p>Su?Sv,I,0 . By direct substitution in Eq. ( <ref type="formula">16</ref>), this lemma is true.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.7.">Relationship between 4-node-2-edges &amp; 4-node-1-edge</head><p>Corollary 13. For any edge e = (u, v) in the graph, the number of 4-node-2edges where e is any of the two independent edges in the graphlet (denoted by the orange color in Fig. <ref type="figure" target="#fig_0">1</ref>), is N (e) I,I,1 . Corollary 14. For any edge e = (u, v) in the graph, the number of 4-node-1-edge where e is an isolated/single edge in the graphlet (denoted by the orange color in Fig. <ref type="figure" target="#fig_0">1</ref>), is N (e) I,I,0 . Lemma 8. For any graph G, the relationship between the counts of 4-node-2edge graphlets (i.e., f (g 49 , G)) and 4-node-1-edge graphlets (i.e., f (g 410 , G)) is,</p><formula xml:id="formula_40">f (g 410 , G) = e?E |V | -|N (u) ? N (v)| 2 -2.f (g 49 , G)</formula><p>Proof. From Theorem 1 and the addition principle <ref type="bibr" target="#b33">(Stanley, 1986)</ref>, the total count for all edges in G is, </p><p>Given that N . Now, from Corollary 13, each 4-node-2-edge is counted 2 times (for the two edges in the graphlet, denoted by the orange in Fig. <ref type="figure" target="#fig_0">1</ref>). Thus, the total count of 4-node-</p><formula xml:id="formula_42">2-edges in G is f (g 49 , G) = 1 2 . e?E N<label>(e)</label></formula><p>I,I,1 . Similarly, from Corollary 14, each 4-node-1-edge will be counted once (for the isolated/single edge in the graphlet, denoted by the orange in Fig. <ref type="figure" target="#fig_0">1</ref>). Thus, the total count of 4-node-1-edge in</p><formula xml:id="formula_43">G is f (g 410 , G) = e?E N (e)</formula><p>I,I,0 . By direct substitution in Eq. ( <ref type="formula" target="#formula_41">17</ref>), this lemma is true.</p><p>While it is straightforward to compute N </p><formula xml:id="formula_44">(18) = e?E |E| -|N (u) \ {v}| -|N (v) \ {u}| -|{e}| -[6.f (g 41 , G) + 4.f (g 42 , G) + 2.f (g 43 , G)] -[4.f (g 44 , G) + 2.f (g 46 , G)]</formula><p>Finally, the number of 4-node-independent graphlets (g 411 ) is,</p><formula xml:id="formula_45">f (g 411 , G) = |V | 4 - 10 i=1 f (g 4i , G) (19)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Algorithm</head><p>Algorithm 2 (GraphletCounting) shows how to count all graphlets of size k = {3, 4} nodes efficiently (using Lemma 2-8). As discussed previously, we start by finding all triangle and 2-star patterns in Lines 7-15 (i.e., Step 1). Then, in Lines 18-19 we only count 4-cliques and 4-cycles (i.e., Step 2). Then, Lines 21-32 compute unrestricted counts for all 4-node graphlets in constant time (using knowledge from Step 1 and 2, i.e.,</p><p>Step 3), and finally Lines 35-37 compute the final counts (using the lemma proved in Section 4.3) (i.e., Step 4). Our approach counts all 4-cliques and 4-cycles in O(m.?.T max ) and O(m.?.S max ) respectively, where T max is the maximum number of triangles incident to an edge and T max ? for sparse graphs, and S max is the maximum number of stars incident to an edge and S max ? ?, as we show in Lemma 9 and 10. This is more efficient than O(|V |.? 3 ) given by <ref type="bibr" target="#b32">(Shervashidze et al., 2009)</ref>, and O(?.|E|+|E| 2 ) given by <ref type="bibr" target="#b21">(Marcus and Shavitt, 2012)</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Experiments</head><p>We proceed by first demonstrating how fast our algorithm (Algorithm 2) counts all graphlets of size k = {3, 4} (both connected and disconnected graphlets) on various networks. We make all our implementations, further experiments, and proofs available in an online appendix 1 . In this paper, we show detailed results for Algorithm 2 Our exact graphlet census algorithm for counting all 3, 4-node graphlets.</p><p>The algorithm takes an undirected graph as input and returns the frequencies of all 3, 4-node graphlets</p><formula xml:id="formula_46">1: procedure GraphletCounting(G = (V, E)) 2:</formula><p>Initialize Array X 3:</p><p>N T,T = 0, N Su,Sv = 0, N T,Su?Sv = 0, N S.,S. = 0 parallel for e = (u, v) ? E do 6:</p><p>60 networks categorized in 8 broad classes from social, facebook <ref type="bibr" target="#b35">(Traud, Mucha and Porter, 2012)</ref>, biological, web, technological, co-authorship, infrastructure, among other domains <ref type="bibr" target="#b29">(Rossi and Ahmed, 2015a</ref>) (see the links<ref type="foot" target="#foot_1">2</ref> for data download). And, in the online appendix, we present a more extensive collection of 300+ networks, including both large sparse networks as well as dense networks from the DIMACs challenge<ref type="foot" target="#foot_2">3</ref> . Note that for all of the networks, we discard edge weights, self-loops, and edge direction. To the best of our knowledge, this is the largest study for graphlet counting, and these are the largest graphlet computations published to date. Our own implementation of Algorithm. 2 uses shared memory, but the algorithm is well-suited for other architectures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Efficiency &amp; Runtime</head><p>Table <ref type="table" target="#tab_2">2</ref> describes the properties of the 60 networks considered here. It also shows the counts of graphlets of size k = {3, 4} and states the time (seconds) taken to count all graphlets. We only show counts of connected graphlets due to space limitations, however all counts are available in the online appendix. Notably, Algorithm 2 takes only few seconds to count all graphlets for large social, web, and technological graphs (among others). For example, for a large road network (i.e., inf-road-usa) with 24M nodes and 29M edges, Algorithm 2 takes only 4 seconds to count all graphlets. Also as shown in Table <ref type="table" target="#tab_2">2</ref>, for large facebook networks with nearly 2M edges, Algorithm 2 takes only 15 seconds, and for large web graphs with nearly 8M edges, Algorithm 2 takes only 25 seconds. We compare the empirical runtime of Algorithm 2 to the state-of-the-art baseline method RAGE <ref type="bibr" target="#b21">(Marcus and Shavitt, 2012)</ref>. For social and facebook networks, we observed that Algorithm 2 is on average 460x faster than RAGE. For all other networks, we observed that Algorithm 2 is on average 600x faster than RAGE. Notably, Algorithm 2 takes only 7 seconds to count graphlets of facebook networks with 1.3M edges, while RAGE takes almost an hour for the same networks. For larger networks with millions of nodes/edges, RAGE was timed out (as it did not finish within 30 hours of runtime). Moreover, for dense graphs from the DIMACS challenge, RAGE takes almost 17 minutes, while Algorithm 2 takes less than a second. We also compared to the baseline method FANMOD <ref type="bibr" target="#b39">(Wernicke and Rasche, 2006)</ref> and Orca <ref type="bibr" target="#b14">(Ho?evar and Dem?ar, 2014)</ref>, we found that for a facebook network with 250k edges, FANMOD takes roughly 2.5 hours for counting all graphlets, RAGE takes almost 7 minutes for the same network, and Orca takes almost 10 seconds, while Algorithm 2 takes less than a second. Note that both RAGE and Orca count only connected graphlets, while our algorithm and FANMOD count both connected and disconnected graphlets.</p><p>In Figure <ref type="figure" target="#fig_17">3</ref>, we plot the runtime of Algorithm 2 for a representative subset of 150 social and information networks. The figure shows that our algorithm exhibits nearly linear-time scaling over networks ranging from 1K to 100M nodes.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Scaling</head><p>We used a 2-processor Intel Xeon 3.10 Ghz E5-2687W server, each processor has 8 cores, and each core can run two threads. The two processors share 20MB of L3 cache and 256GB of memory. We evaluate the speedup of our parallel algorithm (i.e., how much faster our proposed algorithm is when we increase the number of cores), and we used the OpenMP library for multi-core parallelization. In the following plots, we show the speedups versus the number of processing units (cores). All speedups are computed relative to the runtime of Algorithm 2 with one processor. To avoid possible variance, all experiments are repeated 5 times and averaged. Figures <ref type="figure">4</ref><ref type="figure">5</ref>show the speedup plots for a variety of graphs. We discuss a few observations from the plots presented here. The first and most important observation that we make is that we obtain significant speedups from the parallel implementation of Algorithm 2. Figures <ref type="figure">4</ref><ref type="figure">5</ref>show strong scaling results for a variety of graphs from social, web, and technological domains. Algorithm 2 scales to 16 cores and yields a speedup of 10-15 folds. For example, as shown in Figure <ref type="figure">4</ref>, we achieve almost linear scaling for the socfb-Penn94 graph (15-fold speedup for 16 cores).</p><p>The second observation links the performance of Algorithm 2 to the characteristics of the graphs. We observe the most significant speedups for social and Facebook networks (see Figure <ref type="figure">4</ref>). We obtain near linear speedup as we increase the number of cores. Social networks are computationally intensive relative to the other graphs. This is due to their clustering characteristics and the existence of a large number of small communities (i.e., triangles, cliques, and cycles) in social networks.</p><p>The third observation we make is related to the optimal number of problems to dynamically assign to each processing unit when more work is requested (i.e., batch size b). That is the optimal performance that would be achieved when b jobs are assigned in batch. Overall, we observed small performance fluctuations and found the optimal value of b when we changed between 1 and 256 edges respectively. Interestingly, this observation is largely true only for sparse graphs, whereas graphs that are relatively dense (e.g., DIMACs graphs) work better when b is small (e.g., even as small as b = 1). This is likely due to the properties of these graphs and the auto-optimizer that we built into the library which automatically adapts the implementation of the algorithms to use additional data structures and achieve better performance for those relatively dense graphs at the cost of using additional space. Thus, our auto-optimizer appropriately balances the time and space trade-offs.</p><p>Note that the results for the job size experiments use degree for ordering the neighbors of each node in the succinct graph representation as well as for ordering the edge jobs to solve. In both cases, the ordering is from largest to smallest.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Applications</head><p>We also show some applications that could benefit from our fast graphlet counting algorithm (Algorithm 2), which facilitates exploring and understanding networks and their structure. Graphlets provide an intuitive and meaningful characterization of a network at the global macro-level as well as the local micro-level, Fig. <ref type="figure">6</ref>. Facebook social networks of California Universities. Using the space of graphlets of size k = 4, Caltech is noticeably different than others, which is consistent with the findings in <ref type="bibr" target="#b35">(Traud et al., 2012)</ref>.</p><p>thus, they are useful for numerous applications. At the macro-level, graphlets are useful for finding similar networks (graph similarity queries), or finding networks that disagree most with that set (graph anomalies), or exploring a time-series of networks, among numerous other possibilities. Alternatively, graphlets are also extremely useful for characterizing networks and their behavior at the local node/edge-level as known as the micro-level. For instance, given an edge (u, v) ? E, find the top-k most similar edges (with applications in security, role discovery, entity-resolution, link prediction, and other related matching/similarity applications). Also, graphlets could be used for ranking nodes/edges to find unique patterns and anomalies such as large stars, cliques, etc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Large-Scale Graph Comparison &amp; Classification</head><p>Graphlets are also useful for large-scale comparison and classification of graphs.</p><p>In this case, we relax the notion of equivalence and isomorphism to some form of structural similarity between graphs, such that the graph similarity is measured using feature-based graphlet counts. In this section, we show how graphlets could be useful for network analysis, anomaly detection, and graph classification. First, we study the full data set of Facebook100, which contains 100 Facebook networks that represent a variety of US schools <ref type="bibr" target="#b35">(Traud et al., 2012)</ref>. We plot the GFD (i.e., graphlet frequency distribution) score pictorially in Figure <ref type="figure">6</ref> for all California schools. The GFD score is simply the normalized frequencies of graphlets of size k <ref type="bibr" target="#b27">(Pr?ulj et al., 2004)</ref>. In our case, we use k = 4. The figure shows Caltech noticeably different than others, consistent with the results in <ref type="bibr" target="#b35">(Traud et al., 2012)</ref> which shows how Caltech is well-known to be organized almost exclusively according to its undergraduate "Housing" residence system, in contrast to other schools that follow the predominant "dormitory" residence system. The residence system seems to impact the organization of the social community structures at Caltech. Second, we use counts of graphlets of size k = {2, 3, 4}-nodes as features to represent each graph in a large collection of graphs. Using the graphlet feature representation, we learn a model to predict the unknown label of each unlabeled graph (e.g., the label could be the function of protein graphs). We test our approach on protein graphs (D&amp; D collection of 1178 protein graphs) and chemical compound graphs (MUTAG collection of 188 chemical compound graphs) <ref type="bibr" target="#b37">(Vishwanathan et al., 2010)</ref>. We extract the graphlet features using Algorithm 2. Then, we learn a model using SVM (RBF kernel), and we use 10-fold validation for evaluation. Table <ref type="table" target="#tab_3">3</ref> shows the accuracy of this approach is 76% for protein function prediction, and 86% for mutagenic effect prediction. Note that by using all graphlet-based features up to size 4 nodes, we were able to obtain better accuracy than previous work (which achieved maximum 75% and 83% accuracy for D&amp; D and MUTAG respectively <ref type="bibr" target="#b32">(Shervashidze et al., 2009)</ref>). Moreover, Algorithm 2 extracts all the features (graphlet counts) in almost one second. This yields a significant improvement over the graphlet feature extraction approach that was proposed in <ref type="bibr" target="#b32">(Shervashidze et al., 2009)</ref>, which takes 2.45 hours to extract graphlet features from the D&amp; D collection.</p><p>Third, we compute graphlet counts on a 2 billion edge social network called Friendster. Friendster is an on-line gaming network. Before re-launching as a game website in 2011, Friendster was an online social network where users can form friendship links with each others. This data is provided by The Web Archive Project before the death of the social network. In these experiments, we use the induced subgraph of the nodes that either belong to at least one community or are connected to other nodes that belong to at least one community. Table <ref type="table" target="#tab_2">2</ref> shows a significantly large number of 4-path (chains of 4 connected nodes) and 3stars compared to the number of 4-cliques and triangles. Although the induced subgraph that we used from Friendster is clearly biased toward communities, the patterns that represent communities, such as cliques and triangles, are less likely in the induced graph. For example, the frequency of 4-path patterns is 0.58, while the frequency of 4-cliques is 0.000014. These results indicate that something wrong happened to the social network. Previous work on the autopsy of Friendster showed that there was a collapse in the community structure of Friendster, a cascade in user departure due to bad decisions in the design and interface changes. In a similar fashion, the low frequency of community-related graphlets (e.g., cliques) in Friendster also indicates the collapse of the social network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Finding Large Stars, Cliques, and other Patterns Fast</head><p>How can we quickly and efficiently find large cliques, stars, and other unique patterns? Further, how can we identify the top-k largest cliques, stars, etc? Note that many of these problems are NP-hard, e.g., finding the clique of maximum size is a well-known NP-hard problem <ref type="bibr" target="#b11">(Gross et al., 2013</ref>). To answer these Fig. <ref type="figure" target="#fig_21">7</ref>. Visualization of the human diseasome network: A network of disorders and disease genes linked by known disorder-gene associations <ref type="bibr" target="#b8">(Goh et al., 2007)</ref>. Edges are weighted/colored by their number of incident star graphlets of size 4 nodes, nodes are weighted/colored by their triangle counts. The large star on the right denoted by light blue color corresponds to colon cancer; the large star on the lower left denoted by lime green color corresponds to deafness; and the large star on the right denoted by lime green color corresponds to leukemia. Notably this figure highlights the few phenotypes (such as colon cancer, leukemia, and deafness) correspond to hubs (large stars) that are connected to a large number of distinct disorders, which is consistent with <ref type="bibr" target="#b8">(Goh et al., 2007)</ref>.</p><p>and other related queries, we leverage the proposed parallel graphlet counting method in Algorithm 2. The idea is clearly shown in Figure <ref type="figure" target="#fig_21">7</ref>. Figure <ref type="figure" target="#fig_21">7</ref> provides a visualization of the human diseasome network <ref type="bibr" target="#b8">(Goh et al., 2007)</ref>, where we used Alg. 2 to rank (weight) all the edges in the network by the number of star patterns of size 4 nodes. The intuition behind the method is that if an edge (or node) has a (relatively) large number of stars of 4 nodes (cliques, or another graphlet of interest), then it is also likely to be part of a star of a large size. Recall that removing a node from a k-star or k-clique forms a star or clique of size k -1 <ref type="bibr" target="#b11">(Gross et al., 2013)</ref>. Accordingly, edges with large weights are likely to be members of large stars. Thus, as shown in Figure <ref type="figure" target="#fig_21">7</ref>, a visualization based on our fast graphlet counting method can help to quickly highlight such large stars by using the counts (of stars of size 4 nodes) as edge weights or colors. Notably,   <ref type="bibr" target="#b8">(Goh et al., 2007)</ref>.</p><p>Note that the same approach is also applicable for finding cliques and other interesting patterns, since edges with a high number of 4-cliques are likely to be members of the largest clique in the network. Figure <ref type="figure" target="#fig_20">8</ref> shows how we can find large cliques in the terroristRel data <ref type="bibr" target="#b42">(Zhao, Sen and Getoor, 2006)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.">Real-time Visual Graphlet Mining</head><p>Visual analytics is the science of analytical reasoning facilitated by interactive visual interfaces <ref type="bibr" target="#b34">(Thomas and Cook, 2005)</ref>. This work develops an interactive visual graph analytics platform based on the proposed fast graphlet decomposition algorithm. In particular, we integrate interactive visualization with our state-of-the-art parallel graphlet decomposition algorithm in order to support discovery, analysis, and exploration of such data in real-time.</p><p>We utilize this multi-level graphlet analysis engine that uses graphlets as a basis for exploring, analyzing, and understanding complex networks interactively in real-time. And, we highlight other key aspects including filtering, querying, ranking, manipulating, and a variety of multi-level network analysis and statistical techniques based on graphlets.</p><p>Notably, our proposed algorithm is shown to be fast and efficient for real- time interactive exploration and mining of graphlets. We expect this tool to be extremely useful to biologists and others interested in understanding biological (protein, brain networks, etc.) as well as chemical networks.</p><p>There are a number of important and unique challenges in designing methods for interactive exploration and mining of graphlets in real-time. In particular, the real-time requirement of such a system requires fast parallel methods to achieve real-time interactive rates (e.g., with response times within microseconds or less). In particular, we derived dynamic update methods that are localized, that is, the update methods leverage the local structure of the graph for efficiently updating the counts when nodes/edges are selected, inserted, removed, etc. Thus, given a single node or edge, the method updates the graphlet counts for that edge (as opposed to recomputing the full graphlet decomposition).</p><p>Figure <ref type="figure" target="#fig_15">9</ref> uses the interactive graphlet mining tool for real-time exploration of the brain neural network from C. Elegans <ref type="bibr" target="#b38">(Watts and Strogatz, 1998)</ref>. Additionally, the tool is also useful for exploring many other types of networks, e.g., a terrorist relationship network is shown in Figure <ref type="figure" target="#fig_0">10</ref> whereas Figure <ref type="figure" target="#fig_23">11</ref> uses graphlets as a basis for understanding and characterizing the communities and their structure. As an aside, the graph in Figure <ref type="figure" target="#fig_23">11</ref> is generated using the block Chung-Lu graph model. Thus, it is straightforward to see how graphlets can be used to characterize synthetic graph generators and for evaluating their utility (e.g., if the synthetic graph preserves the distribution of graphlets observed in a real-world network.).</p><p>The visual graphlet analytics tool is designed for rapid interactive visual exploration and graph mining . Graphlets are computed on-the-fly upon a simple drag-and-drop of a graph file into the web browser. Additionally, the graphlet counts are updated efficiently after each selection, insertion, deletion, or change to the graph data. Furthermore, it is designed to be consistent with the way humans learn via immediate-feedback upon every user interaction (e.g., change of a slider for filtering) <ref type="bibr">(Ahlberg,</ref>. Illustration of the graphlet methods for real-time interactive graphlet analysis. This demonstrates the efficiency and effectiveness of the proposed methods for interactive real-time graphlet computations. In the screenshot above, the user selects a subgraph to interactively analyze via direct manipulation of the visualization using the mouse. That is, the user adjusts the rectangular region above to highlight the subgraphs to analyze. The graphlet statistics are updated each time a node/edge is added or removed from the rectangular region used to select the subgraph to explore via graphlets. Thus, the user can see how the graphlet statistics change as nodes and edges are added (or removed) from the user-specified rectangular region (which in turn indicates the nodes and edges to include in the analysis). Note that we leverage localized graphlet update methods to achieve the performance required for real-time interactive graphlet mining and sense-making. <ref type="bibr">derman, 1992;</ref><ref type="bibr" target="#b34">Thomas and Cook, 2005)</ref>. Users have rapid, incremental, and reversible control over all graph queries with immediate and continuous visual feedback.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion &amp; Future Work</head><p>In this paper, we proposed a fast, efficient, and parallel algorithm for counting graphlets of size k = {3, 4}-nodes that take only a fraction of the time to compute when compared with the current methods used. The proposed graphlet counting algorithm leverages a number of proven combinatorial arguments for different graphlets. For each edge, we count a few graphlets, and with these counts along with the combinatorial arguments, we obtain the exact counts of others in constant time. We systematically investigate the scalability of our algorithm on a large collection of 300+ networks from a variety of domains. In future work, we aim to extend our proposed algorithm to higher-order graphlets. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. (4-node) graphlet transition diagram: Figure shows all possible ?1 edge transitions between the set of all 4-node graphlets. Dashed right arrows denote the deletion of one edge to transition from one graphlet to another. Solid left arrows denote the addition of one edge to transition from one graphlet to another. Edges are colored by their feature-based roles, where the set of feature are defined by the number of triangles and 2-stars incident to an edge (see Table in the top-right corner). We define six different classes of edge roles colored from black to orange (see Table in the top-right corner). Dashed/solid arrows are colored similar to the edge roles to denote which edge would be deleted/added to transition from one graphlet to another. The table in the top-left corner shows the number of edge roles per each graphlet.</figDesc><graphic url="image-1.png" coords="11,148.17,142.26,242.18,180.91" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>,e wr denotes the number of 4-node graphlets {u, v, w, r}, where w, r satisfy property a i , a j ? A and e wr ? {0, 1}, N (e) ai,aj ,e wr = {u, v, w, r} w,r?V \{u,v} ?w =r ?Aw=ai,Ar=aj ?e wr ?{0,1}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>,1 only, and use Theorem 1 to compute N (e) ai,aj ,0 in constant time. Note that N (e)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>is the number of 4-node subgraphs {u, v, w, r} containing e, such that w, r A w = S u , A r = S v . Thus, from Eq. (10), N (e) Su,Sv = |Star u |.|Star v |.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>is the number of 4-node subgraphs {u, v, w, r} containing e, such that A w = T, A r = S u ? S v . Thus, from Eq. (10), N (e) T,Su?Sv = |Tri e |.(|Star u | + |Star v |). Now, from Corollary 6, each 4-chordalcycle is counted 4 times (once for each edge in the cycle). Thus, the total count of</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>In a similar fashion, the number of 4-tailedtriangles with e as the tail edge and v is part of the triangle is N (e) Sv,Sv,1 . Thus, the total number of 4-tailedtriangles with e as the tail edge and u ? v is part of the triangle is N For any edge e = (u, v) in the graph, the number of 3-star centered around u is N (e) Su,Su,0 .Again, the number of 3-stars centered around v is N (e) Sv,Sv,0 . Thus, the total number of 3-stars centered around u or v is N</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>is the number of 4-node subgraphs {u, v, w, r} containing e, such thatA w = S u ? A r = S u or A w = S v ? A r = S v .Thus, from Eq. (9), N (e) S.,S. = |Staru| 2 + |Starv| 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>is the number of 4-node subgraphs {u, v, w, r} containing e, such that A w = T, A r = I. And, the number of nodes independent of e is |V | -|N (u) ? N (v)|. Thus, from Eq. (10), N (e) T,I = Tri e . |V | -|N (u) ? N (v)| . Now, from Corollary 10, each 4-tailedtriangle is counted one time (once for the red edge as in Fig.1). Thus, the total count of 4-tailedtriangles in G is f (g 43 , G)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>is the number of 4-node subgraphs {u, v, w, r} containing e, such that A w = S u ? S v , A r = I. And, the number of nodes independent of e is |V | -|N (u) ? N (v)|. Thus, from Eq. (10), N (e) Su?Sv,I = |Star e |. (|V | -|N (u) ? N (v)|), such that |Star e | = |Star u | + |Star v |. Now, from</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>is the number of 4-node subgraphs {u, v, w, r} containing e, such that A w = I, A r = I. And, the number of nodes independent of e is |V | -|N (u) ? N (v)|. Thus, from Eq. (9), N (e) I,I = |V |-|N (u)?N (v)| 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>,0 , as they require searching outside the local edge neighborhood. However, since N (e) I,I,1 is the number of edges outside the egonet of e, it can be computed as, N (e) I,I,1 = |E| -|N (u) \ {v}| -|N (v) \ {u}| -|{e}| -</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Lemma 9 .</head><label>9</label><figDesc>Alg. 2 counts all 4-cliques in O(|E|.?.T max ), where T max is the maximum number of triangles incident to an edge.Proof. For each edge e = (u, v) ? E, the runtime complexity of counting all 4cliques incident to e is equivalent to finding the set of all edges e = (w, w ) such that {e = (w, w ) ? E|w, w ? Tri e ? w = w }, where Tri e is the set of triangles incident to e. First, we show in Lem. 1 that the runtime complexity of finding all triangles incident to e is O(?). Second, as described in Alg. 2 the runtime complexity of checking whether any two distinct nodes w, w ? Tri e are connected by an edge e = (w, w ) is O( w?Trie ?) = O(|Tri e |.?), and can be computed asymptotically O(T max .?), where T max is the maximum triangle degree (i.e., the maximum number of triangles incident to an edge and T max ?). Therefore, the total runtime complexity is O e?E (? + T max .?) = O(|E|.?.T max ). Lemma 10. Alg. 2 counts all 4-cycles of size k = 4 in O(|E|.?.S max ), where S max is the maximum number of 2-stars incident to an edge (proof is similar to Lem. 9). Proof. For each edge e = (u, v) ? E, the runtime complexity of counting all 4-cycles incident to e is equivalent to finding the set of all edges e = (w, w ) such that {e = (w, w ) ? E|w ? Star u ? w ? Star v , w = w }. First, we show in Lem. 1 that the runtime complexity of finding all 2-star patterns incident to e is O(?). Second, Alg. 2 shows the runtime complexity of checking whether any two distinct nodes w ? Star u , and w ? Star v are connected by an edge e = (w, w ) is O( w?Staru ?) = O(|Star u |.?), and is asymptotically O(S max .?) (where S max is the maximum number of 2-stars incident to an edge, and S max ? ?). Therefore, the total runtime complexity is O e?E (? + S max .?) = O(|E|.?.S max ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>I = 0, N Su?Sv ,I = 0, N I,I = 0, N I,I,1 = 0 5:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Fig. 3 .</head><label>3</label><figDesc>Fig.3. The empirical runtime of our exact graphlet counting (Alg.2) in social and information networks scales almost linearly with the network dimension.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Fig. 4 .Fig. 5 .</head><label>45</label><figDesc>Fig. 4. Strong scaling results for Facebook and social networks.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Visualization of the terroristRel network: A network of terrorists and their relationships. Terrorists are linked to each other if they contact each other, use the same facility, are members of the same family, or belong to the same terrorist organization. Edges and nodes are weighted/colored by their number of incident cliques of size 4 nodes. Notably this figure highlights how the structure of terrorist networks is decomposed of various clique patterns (terrorist organization) and how these cliques are interconnected. The figure highlights the largest clique on the top left denoted by dark blue.</figDesc><graphic url="image-4.png" coords="28,95.91,129.78,346.69,221.02" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>Figure 7</head><label>7</label><figDesc>Figure7highlights the few phenotypes (such as colon cancer, leukemia, and deafness) correspond to hubs (large stars) that are connected to a large number of distinct disorders, which is consistent with the findings in<ref type="bibr" target="#b8">(Goh et al., 2007)</ref>.Note that the same approach is also applicable for finding cliques and other interesting patterns, since edges with a high number of 4-cliques are likely to be members of the largest clique in the network. Figure8shows how we can find large cliques in the terroristRel data<ref type="bibr" target="#b42">(Zhao, Sen and Getoor, 2006)</ref>.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Exploration of the brain neural network of C. Elegans (Watts and Strogatz, 1998) using our interactive graphlet visual analytics tool. Nodes are colored by their k-core number and weighted by betweenness, whereas the links are colored by eccentricity.</figDesc><graphic url="image-5.png" coords="29,130.58,129.79,277.34,187.09" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Interactive graphlet exploration of community structure via direct manipulation and selection of the visual representation</figDesc><graphic url="image-7.png" coords="31,102.84,129.79,332.81,174.64" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic url="image-3.png" coords="27,143.26,144.18,252.00,297.34" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic url="image-6.png" coords="30,102.84,129.78,332.83,216.51" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Summary of graphlet notationSummary of the notation and properties for the graphlets of size k = {2, 3, 4}. Note that ? denotes density, ? and d denote the max and mean degree, whereas assortativity is denoted by r. Also, |T | denotes the total number of triangles, K is the max k-core number, ? denotes the Chromatic number, whereas D denotes the diameter, B denotes the max betweenness, and |C| denotes the number of components. Note that if |C| &gt; 1, then r, D, and B are from the largest component.</figDesc><table><row><cell></cell><cell>Graphlet</cell><cell>Description</cell><cell>Complement ?</cell><cell>?</cell><cell>d</cell><cell>r</cell><cell cols="2">|T | K</cell><cell>?</cell><cell cols="2">D B |C|</cell></row><row><cell cols="3">(k = 4)-Graphlets</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>g4 1</cell><cell>4-clique</cell><cell>1.00</cell><cell cols="3">3 3.0 1.00</cell><cell>4</cell><cell>3</cell><cell>4</cell><cell>1</cell><cell>0</cell><cell>1</cell></row><row><cell>Connected</cell><cell>g4 2 g4 3 g4 4 g4 5</cell><cell>4-chordalcycle 4-tailedtriangle 4-cycle 3-star</cell><cell>0.83 0.67 0.67 0.50</cell><cell cols="3">3 2.5 -0.66 3 2.0 -0.71 2 2.0 1.00 3 1.5 -1.00</cell><cell>2 1 0 0</cell><cell>2 2 2 1</cell><cell>3 3 2 2</cell><cell>2 2 2 2</cell><cell>1 2 1 3</cell><cell>1 1 1 1</cell></row><row><cell></cell><cell>g4 6</cell><cell>4-path</cell><cell>0.50</cell><cell cols="3">2 1.5 -0.50</cell><cell>0</cell><cell>1</cell><cell>2</cell><cell>3</cell><cell>2</cell><cell>1</cell></row><row><cell>Disconnected</cell><cell>g4 7</cell><cell>4-node-1-triangle</cell><cell>0.50</cell><cell cols="3">2 1.5 1.00</cell><cell>1</cell><cell>2</cell><cell>3</cell><cell>1</cell><cell>0</cell><cell>2</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 .</head><label>2</label><figDesc>Runtime &amp; Statistics for a Subset of 60 Networks. The numbers are appended by K for thousands, M for millions, B for billions, T for trillions, and P for quadrillions.</figDesc><table><row><cell>Seconds</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3 .</head><label>3</label><figDesc>Accuracy &amp; Standard Error for Classification of Large Collection of Biological &amp; Chemical Graphs. We used counts of all graphlets of size k = {2, 3, 4} as features.</figDesc><table><row><cell>graph</cell><cell cols="5">Type No. Graphs Accuracy(%) Total Time(sec) Avg Time per G (sec)</cell></row><row><cell>D&amp;D</cell><cell>Protein</cell><cell cols="2">1178 76.13 ? 0.03</cell><cell>1.05</cell><cell>8.95x10 -4</cell></row><row><cell cols="2">MUTAG Chemicals</cell><cell>188</cell><cell>86.4 ? 0.21</cell><cell>0.14</cell><cell>7.47x10 -4</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>http://nesreenahmed.com/graphlets</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>http://networkrepository.com/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>http://dimacs.rutgers.edu/Challenges/</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>if X(w) = 1 then found triangle</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>13:</head><p>Add w to Trie and set X(w) = 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>14:</head><p>Remove w from Staru </p><p>// Get Unrestricted Counts for 4-Node Connected Graphlets Use Lemma 2-6 to compute f (g 4 i , G) for i = 1 : 8 36:</p><p>Use Eq. ( <ref type="formula">18</ref>) to compute f (g 4 9 , G) and Lemma 8 for f (g 4 10 , G) 37:</p><p>Use Eq. ( <ref type="formula">19</ref>) to compute f (g 4 11 , G) X(w) = 0 52:</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Dynamic queries for information exploration: An implementation and evaluation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ahlberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Williamson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SIGCHI</title>
		<meeting>of SIGCHI</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="619" to="626" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Efficient semi-streaming algorithms for local triangle counting in massive graphs</title>
		<author>
			<persName><forename type="first">L</forename><surname>Becchetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Boldi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Castillo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gionis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Guise: Uniform sampling of graphlets for large graph analysis</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Bhuiyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rahman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rahman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Al Hasan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note>ICDM</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Costa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>De Grave</surname></persName>
		</author>
		<title level="m">Fast neighborhood subgraph pairwise distance kernel, in &apos;ICML</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A puzzle concerning triads in social networks: Graph constraints and the triad census</title>
		<author>
			<persName><forename type="first">K</forename><surname>Faust</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Social Networks</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="221" to="233" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Automatic large scale generation of internet pop level maps</title>
		<author>
			<persName><forename type="first">D</forename><surname>Feldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Shavitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE GLOBECOM</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Triad count statistics</title>
		<author>
			<persName><forename type="first">O</forename><surname>Frank</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Disc. Math</title>
		<imprint>
			<biblScope unit="page" from="141" to="149" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><surname>Getoor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Taskar</surname></persName>
		</author>
		<title level="m">Introduction to statistical relational learning</title>
		<imprint>
			<publisher>MIT press</publisher>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The human disease network</title>
		<author>
			<persName><forename type="first">K.-I</forename><surname>Goh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Cusick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Valle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Childs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vidal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-L</forename><surname>Barab?si</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PNAS</title>
		<imprint>
			<biblScope unit="volume">104</biblScope>
			<biblScope unit="issue">21</biblScope>
			<biblScope unit="page" from="8685" to="8690" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Approximating the number of network motifs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Shavitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Internet Mathematics</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="349" to="372" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The strength of weak ties: A network theory revisited</title>
		<author>
			<persName><forename type="first">M</forename><surname>Granovetter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sociological theory</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="201" to="233" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Handbook of Graph Theory</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yellen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Zhang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>Chapman &amp; Hall/CRC</publisher>
		</imprint>
	</monogr>
	<note>Second Edition, 2nd edn</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Motifs in evolving cooperative networks look like protein structure networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hales</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Arteconi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Networks and Heterogeneous Media</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Graphlet-based measures are suitable for biological network comparison</title>
		<author>
			<persName><forename type="first">W</forename><surname>Hayes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Pr?ulj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="483" to="491" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A combinatorial approach to graphlet counting</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ho?evar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dem?ar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="559" to="565" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Local structure in social networks</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">W</forename><surname>Holland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Leinhardt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sociological Methodology</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="1" to="45" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Graph kernels for chemoinformatics</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kashima</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Saigo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hattori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Tsuda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Chemoinformatics and Advanced Machine Learning Perspectives: Complex Computational Methods and Collaborative Techniques</title>
		<imprint>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A congruence theorem for trees</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Kelly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pacific Journal of Mathematics</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="961" to="968" />
			<date type="published" when="1957">1957</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Finding and counting small induced subgraphs efficiently</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kloks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kratsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>M?ller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Info. Proc. Letters</title>
		<imprint>
			<biblScope unit="volume">74</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="115" to="121" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Topological network alignment uncovers biological function and phylogeny</title>
		<author>
			<persName><forename type="first">O</forename><surname>Kuchaiev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Milenkovi?</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Memi?evi?</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hayes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Pr?ulj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Royal Society Interface</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">50</biblScope>
			<biblScope unit="page" from="1341" to="1354" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">On reconstruction of matrices</title>
		<author>
			<persName><forename type="first">B</forename><surname>Manvel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">K</forename><surname>Stockmeyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematics Magazine</title>
		<imprint>
			<biblScope unit="page" from="218" to="221" />
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Rage-a rapid graphlet enumerator for large networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Marcus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Shavitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Networks</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="810" to="819" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Small graphs are reconstructible</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">D</forename><surname>Mckay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Australasian Journal of Combinatorics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="123" to="126" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Uncovering biological network function via graphlet degree signatures</title>
		<author>
			<persName><forename type="first">T</forename><surname>Milenkoviae</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Pr?ulj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cancer informatics</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">257</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Optimal network alignment with graphlet degree vectors</title>
		<author>
			<persName><forename type="first">T</forename><surname>Milenkovi?</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">L</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hayes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Pr?ulj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cancer informatics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">121</biblScope>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Network motifs: simple building blocks of complex networks</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shen-Orr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Itzkovitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kashtan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chklovskii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Alon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">298</biblScope>
			<biblScope unit="issue">5594</biblScope>
			<biblScope unit="page" from="824" to="827" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Graph-based anomaly detection</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Noble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Cook</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Modeling interactome: scale-free or geometric?</title>
		<author>
			<persName><forename type="first">N</forename><surname>Pr?ulj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Corneil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Jurisica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">18</biblScope>
			<biblScope unit="page" from="3508" to="3515" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Graph kernels for chemical informatics</title>
		<author>
			<persName><forename type="first">L</forename><surname>Ralaivola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Swamidass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Saigo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Baldi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural Networks</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1093" to="1110" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The network data repository with interactive graph analytics and visualization</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Rossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">K</forename><surname>Ahmed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Ninth AAAI Conference on Artificial Intelligence</title>
		<meeting>the Twenty-Ninth AAAI Conference on Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2015">2015a</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Role discovery in networks</title>
		<author>
			<persName><forename type="first">R</forename><surname>Rossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ahmed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TKDE</title>
		<imprint>
			<date type="published" when="2015">2015b</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Graph clustering</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">E</forename><surname>Schaeffer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Science Review</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Efficient graphlet kernels for large graph comparison</title>
		<author>
			<persName><forename type="first">N</forename><surname>Shervashidze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Petri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Mehlhorn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Borgwardt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vishwanathan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
	<note>AISTATS</note>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Stanley</surname></persName>
		</author>
		<title level="m">What Is Enumerative Combinatorics?</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Illuminating the Path: the research and development agenda for visual analytics</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Cook</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>IEEE Computer Society</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Social structure of facebook networks</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Traud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Mucha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Porter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Physica A: Statistical Mechanics and its Applications</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Subgraph frequencies: Mapping the empirical and extremal geography of large graph collections</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ugander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Backstrom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kleinberg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>WWW</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Graph kernels</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">V N</forename><surname>Vishwanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">N</forename><surname>Schraudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kondor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Borgwardt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JMLR</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="1201" to="1242" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Collective dynamics of small-world networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Watts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Strogatz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">393</biblScope>
			<biblScope unit="issue">6684</biblScope>
			<biblScope unit="page" from="440" to="442" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Fanmod: a tool for fast network motif detection</title>
		<author>
			<persName><forename type="first">S</forename><surname>Wernicke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Rasche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1152" to="1153" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Discovering discriminative graphlets for aerial image categories recognition</title>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Tian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Image Processing</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="5071" to="5084" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">Probabilistic graphlet cut: Exploiting spatial structure cue for weakly supervised image segmentation</title>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Chen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Event classification and relationship labeling in affiliation networks</title>
		<author>
			<persName><forename type="first">B</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Getoor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML Workshop on Statistical Network Analysis (SNA)</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
