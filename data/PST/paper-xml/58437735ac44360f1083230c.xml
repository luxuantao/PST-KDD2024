<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Server-Aided Public Key Encryption with Keyword Search</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Rongmao</forename><surname>Chen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Transactions on Information Forensics and Security IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY</orgName>
							</affiliation>
						</author>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Guomin</forename><surname>Yang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Transactions on Information Forensics and Security IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Fuchun</forename><surname>Guo</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Transactions on Information Forensics and Security IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Xinyi</forename><surname>Huang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Transactions on Information Forensics and Security IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Xiaofen</forename><surname>Wang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Transactions on Information Forensics and Security IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yongjun</forename><surname>Wang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Transactions on Information Forensics and Security IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Server-Aided Public Key Encryption with Keyword Search</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">6F09AE228FC262D2A4D6E6E0ECC2A717</idno>
					<idno type="DOI">10.1109/TIFS.2016.2599293</idno>
					<note type="submission">This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIFS.2016.2599293, IEEE Transactions on Information Forensics and Security IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY 1 This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIFS.2016.2599293, IEEE Transactions on Information Forensics and Security IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:35+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Public key encryption with keyword search</term>
					<term>server-aided</term>
					<term>off-line keyword guessing attack</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Public Key Encryption with Keyword Search (PEKS) is a well-known cryptographic primitive for secure searchable data encryption in cloud storage. Unfortunately, it is inherently subject to the (inside) off-line keyword guessing attack (KGA), which is against the data privacy of users. Existing countermeasures for dealing with this security issue mainly suffer from low efficiency and are impractical for real applications. In this work, we provide a practical and applicable treatment on this security vulnerability by formalizing a new PEKS system named Server-Aided Public Key Encryption with Keyword Search (SA-PEKS). In SA-PEKS, to generate the keyword ciphertext/trapdoor, the user needs to query a semi-trusted third party called Keyword Server (KS) by running an authentication protocol and hence security against the off-line KGA can be obtained. We then introduce a universal transformation from any PEKS scheme to a secure SA-PEKS scheme using the deterministic blind signature. To illustrate its feasibility, we present the first instantiation of SA-PEKS scheme by utilizing the FDH-RSA signature and the PEKS scheme proposed by Boneh et al. in Eurocrypt  2004. Finally, we describe how to securely implement the client-KS protocol with a rate-limiting mechanism against on-line KGA and evaluate the performance of our solutions in experiments.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>C Loud storage outsourcing is of increasing interest in recent years for enterprises and organizations to reduce the burden of maintaining big data. In reality, end users may prefer to encrypt their outsourced data for privacy protection as they may not entirely trust the cloud storage server. This makes deployment of traditional data utilization service, such as plaintext keyword search over textual data or query over database, a difficult task. One of the typical solutions is the searchable encryption which allows the user to search and retrieve the encrypted data, and meanwhile preserve the data privacy. Searchable encryption can be realized in either symmetric <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b1">[2]</ref> or asymmetric encryption setting <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b3">[4]</ref>. The symmetric searchable encryption (SSE) is proposed by Song et al. <ref type="bibr" target="#b0">[1]</ref> and later a formal treatment by Curtmola et al. <ref type="bibr" target="#b1">[2]</ref>. Despite the high efficiency in SSE schemes, they suffer from complicated secret key distribution problem. Searchable encryption in public key setting, originating from store-and-forward system, such as email system, in which a receiver can search data en-</p><p>• Copyright (c) 2013 IEEE. Personal use of this material is permitted. However, permission to use this material for any other purposes must be obtained from the IEEE by sending a request to pubs-permissions@ieee.org. Email: rc517@uowmail.edu.au, {ymu,gyang,fuchun}@uow.edu.au, xyhuang@fjnu.edu.cn, wangxuedou@sina.com, wwyyjj1971@126.com. • * Corresponding author. Tel: +61 2 42392120; Fax: +61 2 4221 4170.</p><p>crypted under the receiver's public key on an outsourced storage system, is initiated by Boneh et al. <ref type="bibr" target="#b2">[3]</ref>. They firstly introduced a more flexible primitive, namely Public Key Encryption with Keyword Search (PEKS) that enables a user to search encrypted data in the asymmetric encryption setting. In a PEKS system, using the receiver's public key, the sender attaches some encrypted keywords (referred to as PEKS ciphertexts) with the encrypted data. The receiver then sends the trapdoor of a to-be-searched keyword to the server for data searching. Given the trapdoor and the PEKS ciphertext, the server can test whether the keyword underlying the PEKS ciphertxt is equal to the one selected by the receiver. If so, the server sends the matching encrypted data to the receiver.</p><p>Motivation of This Work. Unfortunately, despite being free from secret key distribution, PEKS schemes suffer from an inherent security problem regarding the keyword privacy, namely (inside) off-line Keyword Guessing Attack (KGA). Specifically, given a trapdoor, the adversarial server can choose a guessing keyword from the keyword space and then use the keyword to generate a PEKS ciphertext. The server then can test whether the guessing keyword is the one underlying the trapdoor. This guessing-then-testing procedure can be repeated until the correct keyword is found. As the keyword always could leak some sensitive information of the user data, it is therefore of practical importance to overcome this security threat for secure and searchable encrypted data outsourcing.</p><p>In <ref type="bibr" target="#b4">[5]</ref>, Peng et al. proposed the notion of Public-key Encryption with Fuzzy Keyword Search (PEFKS) where each keyword corresponds to an exact trapdoor and a fuzzy trapdoor. The server is only provided with the fuzzy trapdoor and thus can no longer learn the exact keyword. However, in their scheme, the malicious server is still able to identify a small set the underlying keyword belongs to and thus the keyword privacy is not well preserved from the server. On the other hand, their scheme is impractical as the receiver has to locally find the matching ciphertext by using the exact trapdoor to filter out the non-matching ones from the set returned from the server. Another work by Chen et al. <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b6">[7]</ref> proposed a new framework of PEKS, namely Dual-Server Public Key Encryption with Keyword Search (DS-PEKS) to achieve the security against inside KGA. Their central idea is to disallow the stand-alone testing of PEKS by splitting the testing functionality of the PEKS system into two parts which are handled by two independent servers. Therefore, the security against the off-line KGA can be obtained as long as the two servers do not collude. Nevertheless, the two-server PEKS may still suffer from the inefficiency as the keyword searching is now separately processed by two servers.</p><p>In this work, we aim at designing a more practical treatment to address this security issue. Moreover, we are interested in building a system that works transparently with any existing PEKS system. That is, the system will be backward-compatible and make no modification on the implementation details of the underlying PEKS system.</p><p>Our Contributions. The contributions of this paper are fourfold. First, we formalize a new PEKS system named Server-Aided Public Key Encryption with Keyword Search (SA-PEKS) to address the security vulnerability against (inside) offline KGA in existing PEKS systems. Our proposed solution can work transparently with any existing PEKS system and hence is much more applicable in practice. Secondly, we present a generic construction of SA-PEKS scheme with formal security analysis. Precisely, we propose a universal transformation from any PEKS scheme to an SA-PEKS scheme by utilizing a deterministic blind signature. Thirdly, to illustrate the feasibility of the proposed generic transformation, an instantiation of the SA-PEKS scheme is presented in this paper. We instantiate the scheme from the FDH-RSA blind signature and the PEKS scheme proposed by Boneh et al. <ref type="bibr" target="#b2">[3]</ref>. Lastly, we present the implementation of our solution and analyze its performance in experiments. Particularly, we show how to securely implement the client-KS protocol with a rate-limiting mechanism against on-line KGA.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Related Work</head><p>Traditional PEKS. Following Boneh et al.'s seminal work <ref type="bibr" target="#b2">[3]</ref>, Abdalla et al. <ref type="bibr" target="#b7">[8]</ref> formalized anonymous IBE (AIBE) and presented a generic construction of searchable encryption from AIBE. In order to construct a PEKS secure in the standard model, Khader <ref type="bibr" target="#b8">[9]</ref> proposed a scheme based on the k-resilient IBE. In <ref type="bibr" target="#b9">[10]</ref>, an interesting primitive called searchable public-key ciphertexts with hidden structures (SPCHS) was proposed for efficient keyword search without sacrificing semantic security of the encrypted keywords.</p><p>Secure Channel-Free PEKS. Baek et al. <ref type="bibr" target="#b10">[11]</ref> proposed a new PEKS scheme, which is referred to as a secure channel-free PEKS (SCF-PEKS). Rhee et al. <ref type="bibr" target="#b11">[12]</ref> later enhanced Baek et al.'s security model <ref type="bibr" target="#b10">[11]</ref> for SCF-PEKS where the attacker is allowed to obtain the relationship between the nonchallenge ciphertexts and the trapdoor. They also presented [14] demonstrated that outside adversaries that capture the trapdoors sent in a public channel can reveal the encrypted keywords through off-line keyword guessing attacks and they also showed off-line keyword guessing attacks against the (SCF-)PEKS schemes in <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b14">[15]</ref>. The first PEKS scheme secure against outside keyword guessing attacks was proposed by Rhee et al. <ref type="bibr" target="#b15">[16]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">SERVER-AIDED PEKS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">An Overview</head><p>SA-PEKS is motivated by the observation that the offline KGA can be dealt with by employing a semi-trusted third party, namely Keyword Server (KS) which is separated from the Storage Server (SS), as shown in Figure .1. Roughly speaking, in an SA-PEKS system, the KS owns the public/secret key pair (pk, sk). Users authenticate themselves to the KS and are provisioned with per-user credentials. Different from the PEKS framework where the PEKS ciphertext and the trapdoor are derived from the original keyword directly, the user needs to interact with the KS in an authenticated way to obtain the pre-processed keyword, namely KS-derived keyword, before the generation of the PEKS ciphertext and the trapdoor. More specifically, given an original keyword w, the sender has to access the KS through authentication and run an interactive protocol with the KS. At the end of the protocol execution, the sender gets the corresponding KS-derived keyword of w as ksd w . The sender then generates the PEKS ciphertext by regarding the KS-derived keyword ksd w as the final keyword. Similarly, taking as input a specified keyword w , the receiver runs the interactive protocol with the KS to obtain the KSderived keyword ksd w and then generates the corresponding trapdoor. It is required that the derivation algorithm from original keyword to KS-derived keyword should be deterministic, otherwise the SA-PEKS cannot work correctly. That is, if w = w , then we have that ksd w = ksd w . We can see that in this way, the generation of PEKS ciphertexts and trapdoors turns to be in an on-line manner (through protocol) and hence the security against the off-line KGA can be obtained. Moreover, the KS can function as a single point of control for implementing rate-limiting measures to reduce the on-line KGA rate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Formal Definition</head><p>Definition 4 (Server-Aided PEKS). An SA-PEKS scheme is defined by the six-tuple (SA-KeyGen KS , SA-KeyGen R , SA-KSD, SA-PEKS, SA-Trapdoor, SA-Test) as follows. SA-KeyGen KS (λ). Taking as input the security parameter λ, outputs the public/private key pair of the KS as (pk ks , sk ks ). SA-KeyGen R (λ). Taking as input parameter λ, it outputs the public/private key pair of the receiver as (pk R , sk R ). SA-KSD(pk ks , sk ks , w). Taking as input the key pair of the KS and the keyword w, it returns the KS-derived keyword ksd w . SA-PEKS(pk R , ksd w ). Taking as input the public key pk R of the receiver and the KS-derived keyword ksd w , the sender outputs the PEKS ciphertext of w as CT ksdw . SA-Trapdoor(sk R , ksd w ). Taking as input the secret key sk R of the receiver and the KS-derived keyword ksd w , the receiver outputs the the trapdoor as T ksd w . SA-Test(pk R , CT ksdw , T ksd w ). Taking as input the public key pk R , the PEKS ciphertext CT ksdw and the trapdoor T ksd w , the SS outputs T rue if w = w ; otherwise outputs F alse. Correctness. It is required that for any two keywords w, w , ksd w ← SA-KSD(pk ks , sk ks , w), ksd w ← SA-KSD(pk ks , sk ks , w ), CT ksdw ← SA-PEKS(pk R , ksd w ) and T ksd w ← SA-Trapdoor(sk R , ksd w ), we have that SA-Test(pk R , CT ksdw , T ksd w ) = T rue if w = w . Remark 1. The algorithm SA-KSD is an interactive protocol between the user (sender/receiver) and the KS. Both the KS and the user take as input the public information pk ks . The private input of the KS is sk ks while that for the user is the original keyword. The KS and the user engage in the KSderived keyword issuing protocol and stop in polynomial time. When the protocol completes, the private output of the user contains the KS-derived keyword. Without loss of generality, we assume that the user can verify the validity of the KS-derived keyword by using the public information and hence the algorithm SA-KSD always outputs the KSderived keyword upon the successful completion of the interactive protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Security Models</head><p>In this subsection, we define the security models for the SA-PEKS in terms of the adversarial SS, the honest but curious KS and adversarial users respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Adversarial Storage Server (SS).</head><p>Here we propose a new notion, namely Semantic-Security against Chosen Keyword Guessing Attack (SS-CKGA) for the SA-PEKS. Similar to the notion of SS-CKA in PEKS, SS-CKGA guarantees that the PEKS ciphertext in the SA-PEKS does not reveal any information about the underlying keyword. The difference between the SS-CKGA and SS-CKA is that the adversary against the SA-PEKS is allowed to obtain the matching trapdoor of the challenge PEKS ciphertext.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 5 (SS-CKGA).</head><p>The SS-CKGA game is as follows.</p><p>Setup. The challenger generates key pairs (pk R , sk R ),</p><p>(pk ks , sk ks ) and sends (pk R , pk ks ) to the attacker. We refer to such an adversary A in the above game as an SS-CKGA adversary and define its advantage as</p><formula xml:id="formula_0">Adv SS-CKGA SS,A (λ) = Pr[b = b ] -1/2.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Honest but Curious Keyword Server (KS).</head><p>It is required that the protocol cannot reveal any information about the private input of the user to the KS or other outside attackers. We refer to such an adversary A in the above game as an IND-CKA adversary and define its advantage as</p><formula xml:id="formula_1">Adv IND-CKA KS,A (λ) = Pr[b = b ] -1/2.</formula><p>Adversarial Users. It is a requirement that only the KS can generate the correct KS-derived keywords, otherwise the security of SA-PEKS falls to that of original PEKS, i.e., being insecure against off-line KGA. Also, we should prevent an adversarial user from generating the KS-derived keyword based on the previous KS-derived keywords obtained from the KS. Therefore, to best capture such a security requirement, we define the notion of One-More-Unforgeability under Chosen Keyword Attack (OMU-CKA) as follows. Definition 7 (OMU-CKA). The OMU-CKA game is defined as, Setup. The challenger runs algorithm KeyGen(λ) to obtain key pair (pk ks , sk ks ). The attacker is given pk ks . KSD-Query. The attacker can adaptively query the challenger for the KS-derived keyword for at most q k distinct original keywords of his choice w 1 , w 2 , ..., w q k through the protocol. Output. Finally, the attacker outputs q k + 1 pairs {w i , ksd wi } i∈[1,q k +1] and wins the game if (1) w i = w j , for any i, j ∈ [1, q k + 1] where i = j, and (2) ksd wi is a valid KS-derived keyword of w i for any i ∈ [1,</p><formula xml:id="formula_2">q k + 1].</formula><p>We refer to such an adversary A in the above game as an OMU-CKA adversary and define its advantage Adv OMU-CKA U ,A (λ) to be the probability that A wins in the above game.</p><p>Based on the security models defined above, we give the following security definition for an SA-PEKS scheme. Definition 8 (Secure SA-PEKS). We say that an SA-PEKS is secure if for any polynomial time attacker A i (i = 1, 2, 3), we have that Adv SS-CKGA SS,A 1 (λ), Adv IND-CKA KS,A 2 (λ) and Adv OMU-CKA U ,A 3 (λ) are all negligible functions of the security parameter λ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">PEKS-TO-SA-PEKS TRANSFORMATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Blind Signature</head><p>Before introducing the universal transformation, we briefly review the definition of blind signature. Blind signature was introduced by Chaum <ref type="bibr" target="#b16">[17]</ref>.</p><p>Syntax. Formally, a blind signature scheme is an interactive scheme that consists of a tuple of algorithms (Kg, Sign, User, Vf). Suppose that the system security parameter is λ. The signer generates a key pair via the key generation algorithm (pk, sk) $ ← Kg(λ). To obtain a signature on a message m ∈ {0, 1} * , the user and signer engage in an interactive signing protocol dictated by the algorithms User(pk, m) and Sign(sk). After the protocol completes, the User algorithm locally outputs a signature σ m on m. To verify the validity of a signature σ m , the verification algorithm Vf takes as input pk, m and σ m , outputs T rue if the signature is valid and F alse otherwise. A blind signature scheme has correctness if Vf(pk, m, σ m ) = T rue for any (pk, sk) $ ← Kg(λ), any message m and any signature σ m output by User(pk, m) after interacting with Sign(sk).</p><p>A blind signature is deterministic if for each public key pk and each message m, there exists only one signature σ m such that Vf(pk, m, σ) = T rue. Security. The security of blind signature is twofold: unforgeability and blindness. We say a blind scheme is one-moreunforgeable if any polynomial time adversary that queries the signing oracle with q s distinct messages can only forge q s +1 valid message/signature pairs with negligible probability. Another notion, namely blindness, requires that the signer cannot tell apart the message it is signing. To be more precise, the blindness condition says that it should be infeasible for a malicious signer to decide which of the two messages has been signed first in two executions with an honest user.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">A Universal Transformation</head><p>In this subsection, we show a universal transformation from PEKS to SA-PEKS. Given a deterministic blind signature scheme BS = (Kg, Sign, User, Vf) and a PEKS scheme PEKS = (KeyGen, PEKS, Trapdoor, Test), the resulting SA-PEKS scheme is as follows. Let H : {0, 1} * × {0, 1} * → {0, 1} * be a cryptographic collision-resistant hash function. SA-KeyGen KS (λ). Take as input the security parameter λ and output the public/private key pair of the KS by running the algorithm Kg of BS as (pk ks , sk ks ) $ ← Kg(λ). SA-KeyGen R (λ). Take as input the parameter λ and output the key pair of the receiver by running the algorithm KeyGen of PEKS as (pk R , sk R ) $ ← KeyGen(λ). SA-KSD(pk ks , sk ks , w). Take as input the key pair of the KS and the keyword w, the user (sender/receiver) runs the algorithm User(pk ks , w) and the KS runs the algorithm Sign(sk ks ) of BS in an interactive signing protocol to obtain the valid signature σ w of w. The user finally obtains the KS-derived keyword as ksd w = H(w, σ w ).</p><p>SA-PEKS(pk R , ksd w ). Take as input the public key pk R and the KS-derived keyword ksd w , the sender runs the algorithm PEKS of PEKS as, CT ksdw ← PEKS(pk R , ksd w ). It then outputs CT ksdw as the PEKS ciphertext of w. SA-Trapdoor(sk R , ksd w ). Take as input the secret key sk R of the receiver and the KS-derived keyword ksd w , the receiver runs the algorithm Trapdoor of PEKS as, T ksd w ← Trapdoor(sk R , ksd w ). It then outputs T ksd w as the trapdoor of w . SA-Test(pk R , CT ksdw , T ksd w ). Take as input the public key pk R , the PEKS ciphertext CT ksdw and the trapdoor T ksd w , the SS runs the algorithm Test of PEKS as, T rue/F alse ← PEKS(pk R , CT ksdw , T ksd w ). It then outputs T rue/F alse as the testing result. Correctness Analysis. One can see that the correctness condition of this construction holds due to the collision-resistant hash function H, the deterministic scheme BS and the correctness of PEKS. To be more precise, for any keywords w, w , we have that σ w = σ w and hence ksd w = ksd w if w = w ; otherwise, we have that ksd w = ksd w . Therefore, due to the correctness of PEKS, we have that T rue ← PEKS(pk R , CT ksdw , T ksd w ) when w = w ; otherwise, F alse ← PEKS(pk R , CT ksdw , T ksd w ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Security Analysis</head><p>SS-CKGA Security. Formally, the SS-CKGA security of the above SA-PEKS scheme SA-PEKS is guaranteed by the following theorem.</p><p>Theorem 1. Let hash function H be a random oracle. Suppose that there exits a polynomial-time adversary A that can break the SS-CKGA security of the above scheme SA-PEKS with advantage Adv SS-CKGA</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SS,A</head><p>, then there exists a polynomial-time adversary B that can break the one-more unforgeability of the underlying signature scheme BS with advantage at least</p><formula xml:id="formula_3">Adv OMU BS,B ≥ 1/q H • Adv SS-CKGA SS,A</formula><p>, where q H is the number of queries to H.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>We prove the theorem by constructing an algorithm B who simulates the challenger in the SS-CKGA model to play the game with A. The goal of B is to break the one-more-unforgeability security of the scheme BS. Suppose that B is given the public key pk ks of BS. Then B interacts with A as follows.</p><p>In the Setup stage, B runs the algorithm KeyGen to generate the key pair (pk R , sk R ) and gives pk R , pk ks to the adversary A. In the Query-I stage, when A queries a keyword w for the PEKS ciphertext (or the trapdoor), B first interacts with the signing oracle to obtain the signature of w and accesses to the random oracle H for the KS-derived keyword ksd w . B then generates the PEKS ciphertext CT ksdw (or the trapdoor T ksdw ) using (pk R , sk R ) and returns the result to A. In the Challenge stage, upon receiving two challenge keywords w 0 , w 1 from A, instead of querying w b to the signing oracle for the signature σ w b , B just picks randomly r and generates the challenge PEKS ciphertext and trapdoor (CT * , T * ) of w b by regarding r as the signature of w b . A then sends (CT * , T * ) to A. In the Query-II stage, B simulates as that in Query-I stage. In the Ouput stage, after A outputs its guess b on b, B picks an input-element from the random oracle H randomly and outputs it as its forgery signature.</p><p>Let Q be the event that A queried (w b , σ w b ) to the random oracle H. Then the advantage of A wins in the above game is Adv SS-CKGA</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SS,A</head><p>= Pr[b = b|Q]+Pr[b = b|Q]-1/2. One can note that in the above simulation, if event Q does not happen, that is, A did not ever query H with (w b , σ w b ), then the above game is identical to the original SS-CKGA game from the view of A due to the property of random oracle H. However, the probability of A wins in this game under this case is at most 1/2 since (CT * , T * ) is independent of b, i.e. Pr[b = b|Q] = 1/2. Therefore, we have that</p><formula xml:id="formula_4">Pr[b = b|Q] = Adv SS-CKGA SS,A</formula><p>, which means that the event Q happens with probability Adv SS-CKGA</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SS,A</head><p>. Therefore, B can successfully forgery a signature as (w b , σ w b ) with advantage</p><formula xml:id="formula_5">Adv OMU BS,B ≥ 1/q H • Adv SS-CKGA SS,A</formula><p>, if the number of queries to H is q H . IND-CKA Security. As for the IND-CKA security which guarantees that except the user no other entity can learn any information about the private input (keyword) of the user, we have the following theorem. Proof: We prove the theorem above by constructing an algorithm B who runs the adversary A as a subroutine to break the security of blindness of the underlying scheme BS as follows. Suppose the challenger in the blindness security attack game against the scheme BS is C.</p><p>In the Setup stage, B receives the public/private key pair (pk, sk) from C, sends the key pair to A and then receives the challenge keywords (w 0 , w 1 ) from A. B then forwards (w 0 , w 1 ) as the challenge message to C. In the Challenge stage, B simulates as the adversarial signer from the view of C and as the challenger of the IND-CKA game against the scheme SA-PEKS from the view of A. Once C starts the first execution of the signing protocol, B starts the KSderived keyword issuing protocol with A and forwards the message between A and C. During the second execution of the protocol, B interacts with C honestly using the public/private key pair (pk, sk). In the Ouput stage, after A outputs its guess b , B outputs b as its guess to C.</p><p>It is easy to see that the above simulation is indistinguishability from the IND-CKA game from the view of A. Therefore, we have that Adv Blindness OMU-CKA Security. Here we discuss the OMU-CKA security of our universal transformation. This notion guarantees that a user cannot forge a new KS-derived keyword without the help of the KS even if it has seen many KS-derived keywords before. Formally, we have the following theorem. , then there exists a polynomial-time adversary B that can break the one-moreunforgeability security of the underlying signature scheme BS with advantage at least Adv OMU BS,B ≥ Adv OMU-CKA U ,A</p><p>.</p><p>Proof: We give the proof of the theorem above by constructing an algorithm B who invokes the adversary A to break the one-more-unforgeability security of the scheme BS as follows.</p><p>In the Setup stage, B receives the public key pk ks from the signing oracle and sends pk ks to A. In the KSD-Query stage, upon receiving a queried keyword w, B queries w to the signing oracle to obtain the signature σ w , returns the hash value of the returned signature as H(w, σ w ) to A as the KS-derived keyword of w. In the Ouput stage, if A outputs q k + 1 valid pairs {(w i , ksd wi )} 1≤i≤q k +1 where q k is the KS-derived keyword query number. Then for each i, B looks up w i in the hash query record for the corresponding signature σ i and outputs {(w i , σ i )} 1≤i≤q k +1 as the q k + 1 valid message/signature pairs as its forgery signatures. Otherwise, B aborts.</p><p>One can see that the simulation above by B is indistinguishable from the original OMU-CKA game from the view of the adversary A, therefore, A can successfully output q k + 1 valid keyword/KS-derived keywords pairs with the advantage Adv OMU-CKA U ,A (λ). That is, B can break the onemore-unforgeability security of BS with advantage at least</p><formula xml:id="formula_6">Adv OMU BS,B ≥ Adv OMU-CKA U ,A</formula><p>. Based on the theorems above, we have the following observation.</p><p>Theorem 4. The universal transformation above results in a secure SA-PEKS scheme if the underlying blind signature is secure in terms of one-more-unforgeability and blindness.</p><p>Further Discussions On the Multi-tiered Security. Ideally, we hope that the adversary does not have authorized access to the KS. This means that the adversary can launch neither off-line nor on-line KGA. However, in reality, the adversary (including the adversarial SS) may have remote access to the KS. In this case, the resulting SA-PEKS still remains SS-CKA secure as long as the underlying PEKS is SS-CKA secure. However, we should note that even in this case, the adversarial SS cannot efficiently launch the KGA since it needs to query the signature of each guessing keyword in an on-line manner through the protocol and hence the bruteforce attack will be rendered less effective. As will shown in Section 6.1, with an effective rate-limiting mechanism, the on-line KGA can be slowed down significantly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Stronger Security Against Curious KS</head><p>One may concern that the curious KS could also lunch the off-line KGA by intercepting the transferred trapdoor from the communication channel between the SS and the receiver.</p><p>To achieve the stronger security against such a curious KS, we could follow the idea of secure channel free PEKS (SCF-PEKS) <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b17">[18]</ref>. The feasibility of such a solution is due to that our proposed solution can work transparently with any existing PEKS system and hence the above universal transformation is also applicable for the SCF-PEKS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>User Signer</head><p>Input: N, e, m Input: </p><formula xml:id="formula_7">N, d r $ ← Z * N m ← r e H(m) mod N , m σ ← (m) d mod N σ σ ← r -1 σ mod N</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">INSTANTIATIONS OF SA-PEKS 4.1 Underlying Schemes</head><p>Following the above universal transformation, here we show an instantiation of the proposed SA-PEKS scheme based on the FDH-RSA blind signature <ref type="bibr" target="#b18">[19]</ref> and the PEKS scheme (denoted by BCOP-PEKS) proposed by Boneh et al. in <ref type="bibr" target="#b2">[3]</ref>. We start with the introduction of the two building blocks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FDH-RSA.</head><p>The RSA blind signature is described in Fig. <ref type="figure" target="#fig_3">2</ref>. The signer has public key N, e and private key N, d where ed ≡ 1 mod φ(N ), modulus N is the product of two distinct primes of roughly equal length. The user uses a hash function H : {0, 1} * → Z * N to hash the message m to an element of Z N and then blinds result with a random group element r $ ← Z * N . The resulting blinded hash, denoted m is then sent to the signer. The signer signs m with its private key d by computing σ ← (m) d mod N and sends back σ. The user then derives the signature by removing the blinding element through σ ← r -1 σ mod N . The correctness can be obtained due to the fact that σ = (m) d mod N = (r e H(m)) d mod N = rH(m) d mod N and hence σ = r -1 σ mod N .</p><p>We can see that the blindness security of the above FDH-RSA is guaranteed by the one-time element chosen randomly to blind the signed message. As for the unforgeability security, based on the result from <ref type="bibr" target="#b18">[19]</ref>, we have the conclusion that the FDH-RSA blind signature scheme is polynomially-secure against one-more forgery if the RSA known-target inversion problem is hard. More details can be found in <ref type="bibr" target="#b18">[19]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>BCOP-PEKS.</head><p>Here, we show the PEKS scheme proposed in <ref type="bibr" target="#b2">[3]</ref>. This scheme is based on a variant of the Computation Diffie-Hellman Problem. Let G 1 , G T be two multiplicative groups with the same prime order p. Let g be the generator of G 1 and I be the identity element of G T . A symmetric bilinear map is a map e :</p><formula xml:id="formula_8">G 1 × G 1 → G T such that e(u a , v b ) = e(u, v) ab for all u, v ∈ G 1 and a, b ∈ Z p .</formula><p>It is worth noting that e can be efficiently computed and e(g, g) = I. Then the non-interactive searchable encryption scheme works as follows.</p><p>KeyGen. The input security parameter determines the size p of the groups G 1 , G T . The algorithm then picks a random α $ ← Z * p , a generate g of G 1 and choose two hash functions</p><formula xml:id="formula_9">H 1 : {0, 1} * → G 1 and H 2 : G T → {0, 1} log p . Then it outputs pk R = (g, h = g α , H 1 , H 2 ), sk R = α.</formula><p>PEKS. For a keyword w, pick a random r $ ← Z * p and compute t = e(H 1 (w), h r ). The sender then outputs the PEKS ciphertext as CT w = (g r , H 2 (t)). Trapdoor. For a keyword w , The receiver outputs the trapdoor as T w = H 1 (w ) α ∈ G 1 . Test. The server takes as input CT w = (A, B) and T w , if H 2 (e(T w , A)) = B, outputs T rue, F alse otherwise. The correctness of the PEKS scheme above can be easily obtained. In terms of security, the scheme is secure against the SS-CKA <ref type="bibr" target="#b2">[3]</ref> but insecure against the off-line KGA. Actually, the off-line KGA against the BCOP-PEKS scheme can be launched in a much simpler way. Given a trapdoor T w * = H 1 (w * ) α , the attacker can easily test whether its guessing keyword w is the underlying keyword of T w * by checking e(T w * , g) ? = e(H 1 (w), h).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Resulting SA-PEKS</head><p>Here we show the resulting SA-PEKS derived from the FDH-RSA and the BCOP-PEKS schemes. The details are described in Fig. <ref type="figure" target="#fig_5">3</ref>. Note that the KS-derived keyword issuing protocol in our scheme requires that N &lt; e should be verified by the user. This is to avoid that the KS may generate the keys dishonestly in order to learn some information about the keyword. This condition ensures that gcd(φ(N ), e) = 1 even if N is maliciously generated and thus ensures that the map f e : Z * N → Z * N , defined by f e (x) = x e mod N for all x ∈ Z * N , is a permutation on Z * N . Since f e is a permutation and the user can verify the validity of the signature, even a malicious KS cannot force the output of signature to be a fixed value.</p><p>It is easy to see that for any two keywords w, w , if w = w , then ksd w = H(w, σ w ) = H(w, H(w) d ) = H(w , H(w ) d ) = ksd w . Therefore, as for the corresponding PEKS ciphertext CT ksdw = (A, B) and the trapdoor T ksd w , we have that H 2 (e(T ksd w , A)) = H 2 (e(H 1 (ksd w ), h r )) = B. Otherwise, H 2 (e(T ksd w , A)) = B as ksd w = ksd w .</p><p>Security Analysis. The security of the resulting SA-PEKS scheme can be easily obtained based on Theorem 4, as the FDH-RSA is one-more-unforgeable and of blindness. Formally, we have the following collusion.</p><p>Corollary 1. The above concrete SA-PEKS scheme is secure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">IMPLEMENTATION AND PERFORMANCE</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">The Client-KS Protocol</head><p>Motivated by the work in <ref type="bibr" target="#b19">[20]</ref>, we show a protocol for client-KS interaction and the rate-limiting strategies which limit client queries to slow down on-line keyword guessing attack. Our design goal is to give a low-latency protocol to avoid performance degrading. The proposed protocol relies on a CA providing the KS and each client with a unique verifiable TLS certificates As shown in Fig. <ref type="figure">4</ref>, the execution of protocol consists of the Mutual Authentication (MA) phase and the Query-Response (QR) phase, of which the first one is over HTTP while the later one is over UDP.</p><p>Phase I: Mutual Authentication. The MA procedure starts with a TLS handshake with mutual authentication, initiated by a client. The KS responds immediately with the verification key pk of the underlying blind signature scheme, a hash Let G 1 , G T be two groups with prime order p and the bilinear map e : G 1 × G 1 → G T . The public RSA-exponent e is fixed as part of the scheme. Let H : {0, 1} * × {0, 1} * → {0, 1} * be a cryptographic collision-resistant hash function.</p><p>SA-KeyGen KS (λ). The algorithm runs Kg(λ, e) to get N, d such that ed ≡ 1 mod φ(N ) and N &lt; e. It chooses hash function H : {0, 1} * → Z * N , and then outputs pk ks = (N, e, H, H), sk ks = (N, d). SA-KeyGen R (λ). The algorithm takes as input the security parameter, determines the size p of the groups G 1 , G T and picks a random α $ ← Z * p , a generate g of G 1 , computes h = g α and chooses hash functions</p><formula xml:id="formula_10">H 1 : {0, 1} * → G 1 and H 2 : G T ← {0, 1} log p . it then outputs pk R = (g, h, H 1 , H 2 ), sk R = α.</formula><p>SA-KSD. For a keyword w, the algorithm runs the KS-derived keyword issuing protocol to obtain the valid signature σw of w as follows.</p><p>User (N, e, H, w) KS(N, d)</p><formula xml:id="formula_11">If e ≤ N then abort r $ ← Z * N w ← r e • H(w) mod N w σ ← (w) d mod N σ σw ← r -1 σ mod N If σ e w mod N = H(w) then abort Else return σw</formula><p>The user (sender/receiver) then computes ksdw = H(w, σw) = H(w, H(w) d ), and outputs ksdw as the KS-derived keyword of w.</p><p>SA-PEKS. For a KS-derived keyword ksdw, the sender picks a random r $ ← Z * p , computes t = e(H 1 (ksdw), h r ), CT ksdw = (g r , H 2 (t)). The algorithm outputs CT ksdw as the PEKS ciphertext of ksdw. SA-Trapdoor. For a KS-derived keyword ksd w , the receiver computes T ksd w = H 1 (ksd w ) α , and outputs T ksd w as the trapdoor of ksd w .  Per-Client Rate-Limiting Mechanism Against On-line KGA. We explore the so-called exponential delay mechanism to achieve a balancing between defence against the on-line KGA and the latency of a KS request. For the first query, the KS performs the response with an initial small delay t I , and the delay time is doubled after each query from the same client. The doubling then stops at an upper limit t U . The KS maintains synchronized epochs and an active client list. It checks the status of active clients after each epoch. The delay would be reset to the initial value if the client makes no queries during an entire epoch. It would also drop any new query from the active client who is in the list and awaiting responses. We remark that our strategy would not bring much communication delay for the normal user who usually performs the query at a low rate.</p><p>Protocol Security. Attackers can attempt to eavesdrop and even tamper with the communications between clients and the KS. In the protocol, due to the mutual authentication TLS handshake in the session initialization, no adversary can start a session pretending to be a valid client. Moreover, without the session key K S , no adversary can create a fresh query packet without a successful MAC forgery. Packets can neither be replayed across sessions due to the randomly picked session identifier nor be replayed within a session due to the increasing sequence number.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Latency of Protocol.</head><p>For the client-KS protocol, we implement FDH-RSA (RSA1024) using SHA256 in the standard way. Similar to <ref type="bibr" target="#b19">[20]</ref>, the PKI setup uses RSA2048 certificates and ECDHE-RSA-AES128-SHA ciphersuite is fixed for the handshake in our protocol. In our implementation, the client machine is located in a university LAN and equipped with Linux system (more precise, 2.6.35-22-generic version) with an Intel(R) Core(TM) 2 Duo CPU of 3.33 GHZ and 2.00-GB RAM. Table .1 shows the latency of different phases in the form of median time plus/minus one standard deviation over 500 trials. We can note that when the KS load is low (e.g., 1000 queries/second (q/s)), the latency is quite small and actually almost the smallest possible time (1 Round-Trip Time (RTT) of Ping operation). The time increases with the growth of the query rate. Specifically, the latency is around 157±40 milliseconds when the query rate is 3000 q/s and becomes 376±44 milliseconds when the query rate increases to 7000 q/s. It is worth noting that we only take the successful operations into account in our experiment. That is, all the replies that timed out three times were excluded from the median calculation.</p><p>Performance Against On-line KGA. To evaluate how our rate-limiting mechanism works in real settings, we estimate the effect of on-line KGA against our protocol in experiments. In our protocol, the proposed rate-limiting mechanism, i.e., exponential delay mechanism, gives a balancing between on-line KGA speed and KS request latency, as the delay increases exponentially with the growth of queries from a client. For the exponential delay mechanism in our experiment, we set the initial small delay t I to 10 milliseconds and the epoch duration t E to one week. We then evaluate the performance of protocol, i.e., the maximum query rates (in queries per second) by setting the upper limit t U to different values. To evaluate the effectiveness of the introduced mechanism, we also run the protocol without rate-limiting. The maximum query rates that an attacker who compromised a client can achieve are given in Table .2. One can note from the result that our exponential delay mechanism can significantly slow down the on-line KGA. Specifically, the attack rate is around 2700 q/s if we put no rate-limiting on the KS. By forcing the exponential delay mechanism, the attack rate can be significantly reduced to less than 10 q/s. The attack rate decreases with the growth of the upper limit t U and is only 1.21 q/s if we set t U to 1000 ms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">The Instantiated Scheme</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Comparison of Schemes</head><p>Computation. As shown in Table <ref type="table" target="#tab_3">3</ref>, compared to the BCOP scheme <ref type="bibr" target="#b2">[3]</ref> (the underlying PEKS scheme of our SA-PEKS construction), our scheme requires 4 additional RSA exponentiations during the generation of PEKS ciphertext and trapdoor. In the testing phase, our scheme has the same computation cost as the BCOP scheme. While the scheme <ref type="bibr" target="#b4">[5]</ref> can also achieve a certain level of security against off-line KGA, its computation cost is much higher due to the additional pairing computation. Precisely, in our scheme, the computation cost of PEKS generation, trapdoor generation and testing are 2Exp Communication. We compare the communication cost of our scheme and the schemes in <ref type="bibr" target="#b2">[3]</ref> and <ref type="bibr" target="#b4">[5]</ref> in terms of the PEKS ciphertext, the trapdoor and the matching data set returned to the receiver (denoted as Ω in Table <ref type="table" target="#tab_3">3</ref>). To be more precise, comparing to the underlying PEKS scheme <ref type="bibr" target="#b2">[3]</ref>, our scheme requires two additional Z * N elements transmitted between the KS and the user per generation of the PEKS ciphtertext or the trapdoor. We remark that this result is independent of the underlying PEKS scheme, as our solution works transparently with any existing PEKS system. Note that in our implementation of the client-KS protocol described above, we utilize FDH-RSA (RSA1024) and hence the corresponding communication overhead for each user is 2048 bits. The scheme presented in <ref type="bibr" target="#b4">[5]</ref> requires two PEKS ciphertexts for each keyword and thus the size of PEKS ciphertext is doubled compared to the BCOP scheme <ref type="bibr" target="#b2">[3]</ref>. Moreover, the data set transferred from the SS to the receiver is of the same size (i.e., Ω) for our scheme and the BCOP scheme while it is 2Ω or 3Ω for the scheme <ref type="bibr" target="#b4">[5]</ref>.</p><formula xml:id="formula_12">G1 +4Exp Z * N +2Hash G1 + 1Pairing G1,G T , 1Hash G1 +1Exp G1 +4Exp Z *</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Storage.</head><p>Regarding the storage cost, our scheme only introduces very small overhead for each user. That is, each user needs to store the public parameters (i.e., N, e, H) of the FDH-RSA blind signature to obtain the KS-derived keyword before the computation of each PEKS ciphertext and trapdoor. It is worth noting that the scheme <ref type="bibr" target="#b4">[5]</ref> requires the receiver to keep the exact trapdoor per query in order to filter out the non-matching data from the set from the SS.  </p><formula xml:id="formula_13">[3] 2Exp G 1 +2Hash G 1 + 1Pairing G 1 ,G T 1Hash G 1 +1Exp G 1 1Hash G 1 + 1Pairing G 1 ,G T G 1 + log p G 1 Ω XJWW [5] 4Exp G 1 +4Hash G 1 +2 Pairing G 1 ,G T 2 Hash G 1 +2Exp G 1 2Hash G 1 + 2Pairing G 1 ,G T 2G 1 + 2 log p G 1 2Ω or 3Ω Our Scheme 2Exp G 1 +2Exp Z * N +2Hash G 1 + 1Pairing G 1 ,G T 1Hash G 1 +1Exp G 1 +2Exp Z * N 1Hash G 1 + 1Pairing G 1 ,G T 2Z * N + G 1 + log p 2Z * N + G 1 Ω 0 10<label>20</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Experiment Results</head><p>To evaluate the efficiency of our scheme in experiments, we implement the scheme utilizing the GNU Multiple Precision Arithmetic (GMP) library and Pairing Based Cryptography (PBC) library. The following experiments are based on coding language C on a Linux system (more precise, 2.6.35-22-generic version) with an Intel(R) Core(TM) 2 Duo CPU of 3.33 GHZ and 2.00-GB RAM. For the elliptic curve, we choose an MNT curve with a base field of size 159 bits, |p|=160 and |q|=80.</p><p>We mainly analyze the computation cost of PEKS generation, trapdoor generation and testing in the schemes of <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b4">[5]</ref> and our scheme. As shown in Fig. <ref type="figure">5</ref> and Fig. <ref type="figure">6</ref>, the computation cost of our scheme is only slightly higher than that of the BCOP scheme in terms of PEKS generation and trapdoor generation. It is because that the computation involved in the underlying FDH-RSA scheme is quite small. Since our solution does not introduce any additional operation in the testing phase, the corresponding computation cost remains the same as the undeylying PEKS system, as illustrated in Fig. <ref type="figure" target="#fig_11">7</ref>.</p><p>As for the scheme in <ref type="bibr" target="#b4">[5]</ref> which achieves a certain level of security against off-line KGA, the computation cost is more than that of the PEKS scheme in <ref type="bibr" target="#b2">[3]</ref> and our scheme in terms of all the operations. Particularly, it takes about 2 seconds to generate a PEKS ciphertext for the scheme in <ref type="bibr" target="#b4">[5]</ref> when the keyword number is 50, while that of the scheme in <ref type="bibr" target="#b2">[3]</ref> and our scheme is around 0.9 second and 1 second, respectively. For the trapdoor generation, the computation is slightly higher than that of our scheme as the exponentiation in G 1 is usually more expensive than the exponentiation in Z * N . To be more precise, the time of trapdoor generation for 50 keywords in <ref type="bibr" target="#b4">[5]</ref> is about 0.12 seconds while that of our scheme is 0.08 seconds. Regarding the testing operation, the computation cost in <ref type="bibr" target="#b4">[5]</ref> is almost twice that of our scheme. Specifically, the computation cost of testing is around 1.6 second for the scheme in <ref type="bibr" target="#b4">[5]</ref> and 0.8 seconds for our scheme. This is because the testing in <ref type="bibr" target="#b4">[5]</ref> requires an additional pairing computation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUDING REMARKS</head><p>In this work, we provided a practical and applicable treatment on (inside) off-line KGA by formalizing a new PEKS system, namely Server-Aided Public Key Encryption with Keyword Search (SA-PEKS). We introduced a universal transformation from any PEKS scheme to a secure SA-PEKS scheme, also with the first instantiation of SA-PEKS scheme and showed how to securely implement the client-KS protocol with a rate-limiting mechanism against on-line KGA. The experimental results showed that our proposed scheme achieves much better efficiency while providing resistance against both off-line and on-line KGAs.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. System Model of Server-Aided PEKS</figDesc><graphic coords="2,347.30,43.70,181.41,113.38" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Query- I .</head><label>I</label><figDesc>The attacker can adaptively query the challenger for the trapdoor and PEKS ciphertext of any keyword. Challenge. The attacker sends the challenger two keywords w 0 , w 1 . The restriction here is that none of w 0 nor w 1 has been queried in the Query-I. The challenger picks b $ ← {0, 1} and generates ksd w b ← SA-KSD(pk ks , sk ks , w b ), CT * ← SA-PEKS(pk R , ksd w b ), T * ← SA-Trapdoor(sk R , ksd w b ). The challenger then sends (CT * , T * ) to the attacker. Query-II. The attacker can continue the query for the trapdoor and PEKS ciphertext of any keyword of its choice except of the challenge keywords w 0 , w 1 . Output. Finally, the attacker outputs its guess b ∈ {0, 1} on b and wins the game if b = b .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Formally, we define the notion of Indistinguishability against Chosen Keyword Attack (IND-CKA) as follows. Definition 6 (IND-CKA). The IND-CKA game is defined as, Setup. The challenger runs the algorithm KeyGen(λ) and sends the attacker the public/private key pair (pk ks , sk ks ). The attacker then sends the challenger two keywords w 0 , w 1 . Challenge. The challenger picks b $ ← {0, 1}, runs the KS-derived keyword issuing protocol with the attacker by taking as input the keyword w b . Output. After the protocol execution completes, the attacker outputs its guess b ∈ {0, 1} on b and wins the game if b = b .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Theorem 2 .</head><label>2</label><figDesc>If there exits a polynomial-time adversary A that can break the IND-CKA security of the above scheme SA-PEKS with advantage Adv IND-CKA KS,A , then there exists a polynomialtime adversary B that can break the blindness security of the underlying signature scheme BS with advantage at least Adv Blindness BS,B ≥ Adv IND-CKA KS,A .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Theorem 3 .</head><label>3</label><figDesc>If there exits a polynomial-time adversary A that can break the OMU-CKA security of the above scheme SA-PEKS with advantage Adv OMU-CKA U ,A</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Blind signing protocol for FDH-RSA</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>SA-Test. The SS takes as input CT ksdw = (A, B) and T ksd w , and checks H 2 (e(T ksd w , A)) ? = B. If yes, output T rue, else output F alse.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 3 .Fig. 4 .</head><label>34</label><figDesc>Fig. 3. An SA-PEKS scheme from FDH-RSA and BCOP-PEKS scheme</figDesc><graphic coords="7,88.96,429.83,170.09,170.08" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>N</head><label></label><figDesc>and 1Hash G1 + 1Pairing G1,G T respectively, where Exp G1 , Exp Z * N denote the computation of one exponentiation in G 1 and Z * N respectively, Hash G1 denotes the cost of one hashing operation in G 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 5 .Fig. 6 .</head><label>56</label><figDesc>Fig. 5. Computation Cost of PEKS Generation (excluding latency)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Computation Cost of Testing</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>• R. Chen, Y. Mu, G. Yang , F. Guo and X. Wang are with the Centre for Computer and Information Security Research, School of Computing and Information Technology, University of Wollongong, Aus-</figDesc><table /><note><p>tralia. R. Chen and Y. Wang are with the College of Computer, National University of Defense Technology, China. X. Huang is with the School of Mathematics and Computer Science, Fujian Normal University, China. X. Wang is also with School of Computer Science and Engineering and Big Data Research Center, University of Electronic Science and Technology of China, Chengdu, Sichuan, 611731, China.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE 1</head><label>1</label><figDesc></figDesc><table><row><cell cols="2">Latency of Protocol Under Different Load</cell></row><row><cell>Operation</cell><cell>Latency (ms)</cell></row><row><cell>Ping (1 Round-Trip Time)</cell><cell>96 ±02</cell></row><row><cell>MA Phase</cell><cell>312 ± 48</cell></row><row><cell>QR Phase (1000 q/s)</cell><cell>103 ± 32</cell></row><row><cell>QR Phase (2000 q/s)</cell><cell>134 ±43</cell></row><row><cell>QR Phase (3000 q/s)</cell><cell>157 ±40</cell></row><row><cell>QR Phase(4000 q/s)</cell><cell>193 ±46</cell></row><row><cell>QR Phase (5000 q/s)</cell><cell>252 ±51</cell></row><row><cell>QR Phase (6000 q/s)</cell><cell>327 ±49</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE 2 KGA</head><label>2</label><figDesc>Rate for Different Rate Limiting Approaches</figDesc><table><row><cell>Setting</cell><cell>Attack Rate (queries/second)</cell></row><row><cell>No Rate Limiting</cell><cell>2700</cell></row><row><cell>t U = 400 ms</cell><cell>8.23</cell></row><row><cell>t U = 600 ms</cell><cell>4.21</cell></row><row><cell>t U = 800 ms</cell><cell>2.54</cell></row><row><cell>t U = 1000 ms</cell><cell>1.21</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE 3</head><label>3</label><figDesc>Comparisons between Existing Works and Our Scheme</figDesc><table><row><cell>Schemes</cell><cell>PEKS Ciphertext</cell><cell>Computation Trapdoor</cell><cell>Testing</cell><cell>Communication PEKS Ciphertext Trapdoor</cell><cell>Testing</cell></row><row><cell>BCOP</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENT</head><p>We thank the anonymous reviewers for their insightful feedbacks on this work. The work of Yongjun Wang is supported by the National Natural Science Foundation of China (Grant No. 61472439).</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Yi Mu received his PhD from the Australian National University in 1994. He currently is professor and the co-director of Centre for Computer and Information Security Research at University of Wollongong, Australia. His current research interests include information security and cryptography. Yi Mu is the editor-in-chief of International Journal of Applied Cryptography and serves as associate editor for ten other international journals. He is a senior member of the IEEE and a member of the IACR. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Guomin</head></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Practical techniques for searches on encrypted data</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">X</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="44" to="55" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Searchable symmetric encryption: improved definitions and efficient constructions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Curtmola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kamara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="79" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Public key encryption with keyword search</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Crescenzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Persiano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="506" to="522" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Private searching on streaming data based on keyword frequency</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Bertino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vaidya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Xing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Dependable and Secure Computing</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="155" to="167" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Public-key encryption with fuzzy keyword search: A provably secure scheme under keyword guessing attack</title>
		<author>
			<persName><forename type="first">P</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computers</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="2266" to="2277" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A new general framework for secure public key encryption with keyword search</title>
		<author>
			<persName><forename type="first">R</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Mu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACISP</title>
		<imprint>
			<biblScope unit="page" from="59" to="76" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Dual-server public-key encryption with keyword search for secure cloud storage</title>
		<author>
			<persName><forename type="first">R</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Mu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Forensics and Security</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="789" to="798" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Searchable encryption revisited: Consistency properties, relation to anonymous ibe, and extensions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abdalla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Catalano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kiltz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kohno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lange</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Malone-Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Neven</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Paillier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CRYPTO</title>
		<imprint>
			<biblScope unit="page" from="205" to="222" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Public key encryption with keyword search based on k-resilient IBE</title>
		<author>
			<persName><forename type="first">D</forename><surname>Khader</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Science and Its Applications -ICCSA</title>
		<imprint>
			<biblScope unit="page" from="298" to="308" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Generating searchable public-key ciphertexts with hidden structures for fast keyword search</title>
		<author>
			<persName><forename type="first">P</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Susilo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Domingo-Ferrer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Forensics and Security</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1993" to="2006" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Public key encryption with keyword search revisited</title>
		<author>
			<persName><forename type="first">J</forename><surname>Baek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Safavi-Naini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Susilo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Science and Its Applications ICCSA</title>
		<imprint>
			<biblScope unit="page" from="1249" to="1259" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Improved searchable public key encryption with designated tester</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">S</forename><surname>Rhee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Susilo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>ASIACCS</publisher>
			<biblScope unit="page" from="376" to="379" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Off-line keyword guessing attacks on recent keyword search schemes over encrypted data</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Byun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">S</forename><surname>Rhee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Secure Data Management, Third VLDB Workshop, SDM</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="75" to="83" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Off-line keyword guessing attacks on recent public key encryption with keyword search schemes</title>
		<author>
			<persName><forename type="first">W</forename><surname>Yau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Heng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Goi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ATC</title>
		<imprint>
			<biblScope unit="page" from="100" to="105" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">On the integration of public key data encryption and public key encryption with keyword search</title>
		<author>
			<persName><forename type="first">J</forename><surname>Baek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Safavi-Naini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Susilo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Information Security ISC</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="217" to="232" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Secure searchable public key encryption scheme against keyword guessing attacks</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">S</forename><surname>Rhee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Susilo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kim</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>IEICE Electronic Express</publisher>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="237" to="243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Blind signature system</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CRYPTO</title>
		<imprint>
			<biblScope unit="page">153</biblScope>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Trapdoor security in a searchable public-key encryption scheme with a designated tester</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">S</forename><surname>Rhee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Susilo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Systems and Software</title>
		<imprint>
			<biblScope unit="volume">83</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="763" to="771" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The one-more-rsa-inversion problems and the security of chaum&apos;s blind signature scheme</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Namprempre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pointcheval</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Semanko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptology</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="185" to="215" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Dupless: Serveraided encryption for deduplicated storage</title>
		<author>
			<persName><forename type="first">S</forename><surname>Keelveedhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ristenpart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="179" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">degrees in computer science from National University of Defense Technology, China in 2011 and 2013, respectively, and is currently pursuing the full-time PhD degree in the School of Computing and Information Technology</title>
		<author>
			<orgName type="collaboration">Rongmao Chen received the B.S. and M.S.</orgName>
		</author>
	</analytic>
	<monogr>
		<title level="m">His major research interests include cryptography, data security and privacy in cloud computing, and network security</title>
		<imprint/>
		<respStmt>
			<orgName>University of Wollongong</orgName>
		</respStmt>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
