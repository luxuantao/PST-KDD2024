<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Schema Mappings, Data Exchange, and Metadata Management</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Phokion</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
							<email>kolaitis@almaden.ibm.com</email>
							<affiliation key="aff0">
								<orgName type="institution">IBM Almaden Research Center</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Santa</forename><surname>Cruz</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">IBM Almaden Research Center</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Schema Mappings, Data Exchange, and Metadata Management</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">29AB286043F46005FA4778DE7101127B</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:59+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Schema mappings are high-level specifications that describe the relationship between database schemas. Schema mappings are prominent in several different areas of database management, including database design, information integration, data exchange, metadata management, and peer-topeer data management systems. Our main aim in this paper is to present an overview of recent advances in data exchange and metadata management, where the schema mappings are between relational schemas. In addition, we highlight some research issues and directions for future work.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Schema mappings are specifications that describe the relationships between schemas at a high level. These specifications are typically given in a logical formalism that captures the interaction between schemas at a logical level without spelling out implementation details relevant to the physical level. Schema mappings are widely used in all data management applications that involve data sharing or data transformation. In particular, schema mappings are essential building blocks in information integration, data exchange, metadata management, and peer-to-peer data managements systems. In this paper, we present an overview of recent advances in data exchange and metadata management, where the schema mappings are between relational schemas. We also highlight a number of research issues and suggest directions for future work. Most of the results presented here are based on joint work with Ronald Fagin, Renée J. Miller, Lucian Popa, and Wang-Chiew Tan reported in <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b15">15]</ref>. In some respects, this paper can be construed as a companion to Lenzerini's paper <ref type="bibr" target="#b23">[23]</ref> from his invited tutorial on data integration in PODS 2002, even though it does not aspire to be as comprehensive and encyclopedic as Lenzerini's survey.</p><p>Data exchange, also known as data translation, is the prob-lem of taking data structured under a schema, called the source schema, and transforming it into data structured under another schema, called the target schema. Data exchange has been described as the "oldest database problem" <ref type="bibr">[7]</ref>. An early low-level tool for data exchange between hierarchical databases was the EXPRESS system, developed at the IBM San Jose Research Laboratory in the 1970s <ref type="bibr" target="#b34">[34]</ref>. Data exchange has been a recurrent problem that has taken a new significance with the advent of semi-structured data and the resulting need to exchange data between heterogeneous schemas.</p><p>There are obvious similarities, but also clear differences, between data integration and data exchange. In both frameworks, schema mappings are used to specify the relationships between the schemas involved. In data integration, the goal is to synthesize data from different sources into a unified view under a global schema; this view is virtual, in that the data remain in the sources and are accessed by users symbolically via the global schema. In data exchange, the goal is to take a given source instance and transform it to a target instance such that it satisfies the specifications of the schema mapping and also "reflects" the given source data as accurately as possible; unlike data integration, this target instance is a materialized instance, not a virtual view.</p><p>Consider a schema mapping between a source schema and a target schema. It is often the case that, given a source instance, there may be multiple target instances, called solutions, that satisfy the specifications of the schema mapping under consideration. This state of affairs gives rise to certain fundamental questions about the semantics and the algorithmics of data exchange. Given a source instance, which solutions are "better" than others? Which solution should one choose to materialize and how difficult is it to compute such a good solution? What is the semantics of target queries and how difficult is it to evaluate such queries? Both information integration and data exchange use the concept of the certain answers as the standard semantics of query answering, a concept that originated in the study of incomplete databases <ref type="bibr" target="#b35">[35]</ref>. The two frameworks, however, adopt different approaches to obtain the certain answers of queries. In data integration, queries posed against the global schema are usually processed via rewriting to queries posed against the source schemas. In data exchange, however, it is natural to try to process target queries by making use of the materialized target instance; furthermore, this may be the only reasonable approach in cases in which the source instance becomes inaccessible af-ter the exchange has taken place. In turn, this raises the question: for which target queries can the certain answers be obtained by evaluating them on a good solution? Schema mappings are metadata. <ref type="bibr">Bernstein [6]</ref> has made a compelling case for the importance of developing both the theory and the practice of metadata management. To this effect, Bernstein has introduced a conceptual framework in which metadata is managed by combining certain basic generic operators on schema mappings, such as composition, merge, match, and inverse. Complex transformations on schema mappings can be obtained by repeated combinations of these basic operators; moreover, schema evolution can be dissected and analyzed using the same operators.</p><p>The first main challenge in metadata management is to develop rigorous semantics for each of the basic operators. Once this is achieved, the next challenge is to investigate the properties of these operators for different schema-mapping languages. A prominent issue in this investigation has to do with the closure properties of schema-mapping specification languages. For instance, is a given schema-mapping specification language closed under composition? In other words, can the composition of two schema mappings be expressed in the same language used to express each of the components of the composition? Another important issue has to do with the algorithmic properties of the basic operators and the schema-mapping specification languages used to express them. In particular, for which schema-mapping specification languages are the basic operators efficiently computable?</p><p>The remainder of this paper is organized as follows. In Section 2, we introduce schema mappings and the data exchange problem. In Section 3, we present an overview of results about data exchange with schema mappings specified by tuplegenerating dependencies between relational schemas. In Section 4, we focus on the semantics and the computational complexity of query answering in data exchange. In Section 5, we give an account of results about the composition operator as a case study in metadata management. Finally, in Section 6 we conclude with some brief remarks on the connection of this work to Clio, a schema mapping and data exchange tool developed at the IBM Almaden Research Center.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Schema Mappings &amp; Data Exchange</head><p>A relational schema or, simply, a schema, is a finite sequence R = R1, . . . , R k of relation symbols, each of which has a fixed arity. An instance I over R is a sequence R I 1 , . . . , R I k such that each R I i is a finite relation of the same arity as Ri. To keep the notation simple and when no confusion arises, we will use Ri to denote both the relation symbol and the relation R I i that interprets it. Given a tuple t occurring in a relation R, denote by R(t) the association between R and t, and call it a fact. Clearly, an instance can be identified with the collection of its facts.</p><p>Let S = S1, . . . , Sn and T = T1, . . . , Tm be two schemas with no relation symbols in common. We write S, T for the schema S1, . . ., Sn, T1, . . ., Tm . If I is an instance over S and J is an instance over T, then we write I, J for the instance K over the schema S, T such that S K i = S I i and</p><formula xml:id="formula_0">T K j = T J j , for 1 ≤ i ≤ n and 1 ≤ j ≤ m.</formula><p>Definition 2.1. Let S and T be two schemas with no relation symbols in common.</p><p>A schema mapping is a triple M = (S, T, Σ) such that Σ is a set of formulas of some logic L over S, T . In such a schema mapping, S is called the source schema, and T is called the target schema. Definition 2.2. Let M = (S, T, Σ) be a schema mapping.</p><p>• An instance of M is an instance I, J over S, T that satisfies every formula in the set Σ.</p><p>• We write Inst(M) to denote the space of all instances I, J of M.</p><p>• Let I be an instance over S. We say that an instance J over T is a solution for I under M if I, J ∈ Inst(M). We write SOL(M, I) for the collection of all solutions for I under M.</p><p>Let M = (S, T, Σ) be a schema mapping. Intuitively, the formulas in Σ express constraints between the source schema S and the target schema T. We assume that the satisfaction relation between formulas and instances of the logic L used to specify the constraints of schema mappings is preserved under isomorphisms; this means that if an instance satisfies a formula of L, then every isomorphic instance also satisfies that formula. Clearly, this property is shared by all standard logical formalisms, such as first-order logic, secondorder logic, and Datalog. It follows that the set Inst(M) of instances of M is closed under isomorphisms, that is, if I, J ∈ Inst(M) and I , J is isomorphic to I, J , then we also have I , J ∈ Inst(M).</p><p>Note that a schema mapping M = (S, T, Σ) is not a mapping in the mathematical sense; in effect, it is a schema S, T partitioned into two parts S and T, together with a set Σ of constraints. Nonetheless, every schema mapping M gives rise to a mathematical mapping such that, for every source instance I, it returns the collection SOL(M, I) of all target instances J that are solutions for I under M.</p><p>It should be pointed out that a source instance I may not have any solutions; furthermore, if I has solutions, then these solutions need be unique up to isomorphism. As a matter of fact, a source instance may have an arbitrary finite number or an infinite number of non-isomorphic solutions. For example, consider a schema mapping M in which the source schema S contains a binary relation symbol E, the target schema T contains a binary relation symbol H, and the set Σ consists of the first-order formula</p><formula xml:id="formula_1">∀x∀y(E(x, y) → ∃z(H(x, z) ∧ H(z, y))).</formula><p>Intuitively, this schema mapping transforms edges in E to paths of length 2 in H. Clearly, every source instance has a solution; in fact, for every source instance, there are infinitely many non-isomorphic solutions since solutions are preserved by augmenting H with an arbitrary number of new edges. With these considerations in mind, we are now ready to introduce the basic problems in schema mappings and data exchange. Several remarks are in order now. First, note that, in defining the existence-of-solutions problem and the data exchange problem, we have kept the schema mapping M fixed, so that the input to these two problems is just a source instance I. Although we will not pursue this here, it is also meaningful to consider the variants of these problems in which both a schema mapping M and a source instance I are part of the input. In Vardi's <ref type="bibr" target="#b36">[36]</ref> taxonomy of problems in database theory, this means that here we are focusing on the data complexity of these two problems, instead of their combined complexity.</p><p>Up to this point, we have not been explicit about the logic L used to specify schema mappings. As a guiding principle, we want to use logics that are powerful enough to express interesting constraints occurring in applications, while at the same time are well-behaved enough so that the existence-ofsolutions problem is tractable or, at the very least, decidable. It is not hard to see that if arbitrary formulas of first-order logic are allowed in the specification of schema mappings, then there are schema mappings for which the existence-ofsolutions problem is undecidable. Indeed, as described in <ref type="bibr" target="#b15">[15]</ref>, we can write a fixed first-order sentence specifying a schema mapping M * such that a solution J exists for a source instance I if and only if I is the encoding of a Turing machine and J is the encoding of a terminating computation on some input. Consequently, the existence-of-solutions problem for M * is undecidable. This implies that, instead of full firstorder logic or some extension of it, we will have to use suitably restricted fragments of first-order logic or some other more tractable logical formalism to specify schema mappings.</p><p>Finally, let us comment on the data exchange problem associated with a schema mapping M = (S, T, Σ). As formulated in Definition 2.3, this problem asks, given a source instance I, to find a solution J for I under M. As noted earlier, a source instance I may have many (in fact, infinitely many) non-isomorphic solutions. In such cases, which is the "right" solution to return as the answer to the data exchange problem? What criteria should we use to differentiate between solutions? How can we select a solution J to materialize that, in addition to merely satisfying the constraints in Σ, represents the source instance I as faithfully as possible?</p><p>The issues raised in the preceding remarks pave the road for the work that will be presented in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Data Exchange with Tuple-&amp; Equality-Generating Dependencies</head><p>Starting with Codd's <ref type="bibr" target="#b9">[9]</ref> work on functional dependencies, a large variety of constraints in relational databases, called dependecies, were investigated in depth during the 1970s and the 1980s. Most of the constraints studied during this period can be expressed by formulas of first-order logic, and fall into one of two classes: tuple-generating dependencies and equality-generating dependencies. Taken together, these two classes have the same expressive power as the class of embedded implicational dependencies <ref type="bibr" target="#b12">[12]</ref> (see <ref type="bibr" target="#b22">[22,</ref><ref type="bibr">Section 3]</ref> for a discussion about the taxonomy of constraints in relational databases).</p><p>A tuple-generating dependency, in short tgd, is a first-order formula of the form</p><formula xml:id="formula_2">(∀x)(ϕ(x) → (∃y)ψ(x, y)),</formula><p>where ϕ(x) is a conjunction of atoms<ref type="foot" target="#foot_0">1</ref> such that the variables of each atom are among those in x, and each variable in x occurs in at least one of the atoms of ϕ(x); furthermore, ψ(x, y) is a conjunction of atoms with variables among those in x and y. In effect, every tgd expresses the containment of one conjunctive query in another conjunctive query. Both inclusion dependencies and multivalued dependencies are special cases of tgds. An important subclass of tgds is the collection of full tgds; by definition, these are the tgds whose right-hand side of the implication has no existential quantifiers, that is, they tgds of the form (∀x)(ϕ(x) → ψ(x)).</p><p>For example,</p><formula xml:id="formula_3">(∀x1∀x2∀x3)(E(x1, x2) ∧ E(x2, x3) → E(x1, x3))</formula><p>is a full tgd constraining E to be a transitive relation, while</p><formula xml:id="formula_4">∀x∀y(E(x, y) → ∃z(H(x, z) ∧ H(z, y)))</formula><p>is a tgd, but not a full one.</p><p>An equality-generating dependency, in short egd , is a firstorder formula of the form</p><formula xml:id="formula_5">(∀x)(ϕ(x) → (xi = xj)),</formula><p>where xi, xj are among the variables in x, and ϕ(x) is a conjunction of atoms such that the variables of each atom are among those in x, and each variable in x occurs in at least one of the atoms of ϕ(x). Clearly, functional dependencies are a special case of egds.</p><p>In what follows, we will drop the universal quantifiers in front of tgds and egds, and will implicitly assume such quantification; all existential quantifiers, however, will be written explicitly.</p><p>Tuple-generating dependencies have been extensively used in data integration to specify constraints between the source schema and the global schema (see <ref type="bibr" target="#b23">[23]</ref> for an overview). Furthermore, as we will describe next, tuple-generating dependencies and equality-generating dependencies were used in a systematic study of data exchange <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b14">14]</ref>.</p><p>Let S and T be two schemas with no relation symbols in common. In what follows, we will focus on schema mappings M of the form (S, T, Σst ∪ Σt) such that Σst is a set of s-t tgds and Σt is a set of target tgds and target egds. The data exchange problem for such schema mappings was first investigated in <ref type="bibr" target="#b13">[13]</ref> in a study motivated by the following considerations. There are many situations in which source data have to be translated to target data in such a way that "directional" constraints are satisfied, that is, a condition on the source implies a condition on the target. This is modelled using s-t tgds in the schema mapping. Furthermore, the data in the target may have to obey additional constraints, such as key constraints or inclusion dependencies. In turn, this is modelled using target egds and target tgds.</p><formula xml:id="formula_6">I S T Σ st J Σ t</formula><p>It goes without saying that one could expand the framework to include source constraints, target-to-source tgds, or more complex constraints, such as tgds ϕ(x) → (∃y)ψ(x, y) in which both ϕ(x) and ψ(x, y) are conjunctions of atoms over the schema S, T . As regards source constraints, it is natural to assume that the source data to be exchanged has already been preprocessed, and so the data satisfies all underlying source constraints; moreover, as will be seen later on, source constraints have no direct role in defining the semantics of data exchange. As regards target-to-source constraints or more complex constraints, their presence undoubtedly enhances the modelling power of the framework, but it is usually accompanied by a steep increase in the computational complexity of algorithmic problems in data exchange (see, for instance, <ref type="bibr" target="#b17">[17]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Universal Solutions in Data Exchange</head><p>Before proceeding further, we should become specific about the values that occur in source instances and in target instances. Assume that Const is the set of all values that may occur in source instances; we call these values constants. Let Var be an infinite set of values, called labelled nulls, such that Const ∩ Var = ∅. We stipulate that the target instances created in data exchange have values in Const ∪ Var. If J is a target instance, then we write Var(J) for the set of all labelled nulls occurring in relations in J.</p><p>Let M = (S, T, Σst ∪Σt) be a schema mapping such that Σst is a set of s-t tgds and Σt is a set of target tgds and target egds. Recall that the data exchange problem associated with M asks: given a source instance I, find a solution J for I under M, that is, a target instance J such that I, J satisfies Σst ∪ Σt.</p><p>It is possible that, for a given source instance I, no solution exists. For example, let M be a schema mapping such that</p><formula xml:id="formula_7">Σst = {E(x, y) ∧ E(y, z) → H(x, z)} Σt = {H(x, y) ∧ H(x, z) → y = z}.</formula><p>If I is a source instance containing the facts E(1, 2), E(2, 3), E <ref type="bibr" target="#b1">(1,</ref><ref type="bibr" target="#b4">4)</ref>, E(4, 5), then no solution for I exists, since every solution must contain the facts H(1, 3) and H <ref type="bibr" target="#b1">(1,</ref><ref type="bibr" target="#b5">5)</ref>, thus vi-olating the target egd in Σt.</p><p>At the other extreme, it is easy to see that if Σt = ∅, then solutions always exist. Moreover, in this case, every source instance I has infinitely many non-isomorphic solutions, since if extra facts are added to a solution for I, then the resulting instance is still a solution for I.</p><p>Example 3.1. Let M be a schema mapping such that</p><formula xml:id="formula_8">Σst = {E(x, y) → (∃z)(H(x, z) ∧ H(z, y))} Σt = ∅.</formula><p>Let I be the source instance consisting of just the fact E(1, 2). The set SOL(M, I) of solutions for I under M contains, among others, the following target instances:</p><formula xml:id="formula_9">J1 = {H(1, 1), H(1, 2)} J2 = {H(1, 2), H(2, 2)} J3 = {H(1, u), H(u, 2)} J4 = {H(1, u), H(u, 2), H(u, u)} J n = {H(1, vi) : 1 ≤ i ≤ n} ∪ {H(vi, 2) : 1 ≤ i ≤ n},</formula><p>where u and vi, 1 ≤ i ≤ n, are labelled nulls in Var.</p><p>Which member of SOL(M, I) should we choose to materialize and return as answer to the data exchange problem on input I? What properties should a solution possess that would make it more desirable for data exchange than other solutions? Intuitively, although every solution for I satisfies the specifications of the schema mapping M, we would like to materialize a solution that carries no more and no less information than is required for data exchange. But how can this intuition be turned into a precise concept?</p><p>In some respects, this state of affairs is reminiscent of the unification problem in logic programming <ref type="bibr" target="#b2">[2]</ref>. Two given terms may or may not be unifiable; if they are, then they can have more than one unifier. In the latter case, the preferred unifier is the most general unifier , which is a unifier with the property that every unifier can be obtained from it via a substitution.</p><p>In <ref type="bibr" target="#b13">[13]</ref>, the concept of a universal solution was introduced, and a case was made that universal solutions are the preferred solutions in data exchange because they are the "most general" solutions in data exchange. The concept of universal solution makes use of the concept of homomorphism; the precise definitions of these concepts are as follows.</p><p>Definition 3.2. Let M = (S, T, Σst ∪ Σt) be a schema mapping such that Σst is a set of s-t tgds and Σt is a set of target tgds and target egds.</p><p>Let J1 and J2 be two target instances. A homomorphism h : J1 → J2 is a function h : Const∪Var(J1) → Const∪Var(J2) with the following two properties.</p><p>1. For every constant c ∈ Const, we have that h(c) = c. 2. For every fact P (t) of J1, we have that P (h(t)) is a fact of J2 (where, if t = (c1, . . . , cm), then h(t) = (h(c1), . . . , h(cm))).</p><p>Definition 3.3. Let M = (S, T, Σ st ∪ Σt) be a schema mapping such that Σst is a set of s-t tgds and Σt is a set of target tgds and target egds.</p><p>If I is a source instance, then a universal solution for I is a solution J for I such that for every solution J for I, there is a homomorphism h : J → J .</p><p>Intuitively, a homomorphism between two relational structures is a mapping that preserves facts. The definition of homomorphism we just gave is essentially the standard definition of homomorphism between relational structures in which some elements (in the present case, the constants) have been distinguished and can be mapped only to themselves. The concept of homomorphism is a fundamental algebraic concept that been extensively studied in graph theory <ref type="bibr" target="#b21">[21]</ref> and in constraint satisfaction <ref type="bibr" target="#b16">[16]</ref>. Many basic NP-complete problems can be cast as homomorphism problems. As an illustration, it is easy to verify that a graph G = (V, E) is 3-colorable if and only if there is a homomorphism from G to K3, the complete graph with 3 nodes. Furthermore, homomorphisms are tightly connected to conjunctive-query processing and optimization, since conjunctive-query containment can also be cast as a homomorphism problem <ref type="bibr" target="#b8">[8]</ref>.</p><p>By definition, universal solutions can be mapped homomorphically to every solution; consequently, every solution can be obtained from a given universal solution via a homomorphism and an augmentation with extra facts (tuples in relations). In this sense, universal solutions are indeed the "most general" solutions in data exchange: they carry no more and no less information than is needed for data exchange purposes.</p><p>Let us illustrate this intuition by examining the solutions listed in Example 3.1. Solution J1 is not universal, since no homomorphism from J1 to J2 exists (or to any of the other solutions listed). Although J1 satisfies the s-t tgd E(x, y) → (∃z)(H(x, z) ∧ H(z, y)), it contains extra information, as it uses the constant 1 to witness the existential quantifier ∃z. Similarly solution J2 is not universal, since no homomorphism from J2 to J1 exists. In contrast, solution J3 is a universal solution for I. For instance, there is a homomorphism h from J3 to J1 with h(u) = 1, and a homomorphism g from J3 to J n with g(u) = v1. Solution J4 is not universal, even though it contains the universal solution J3. Intuitively, the reason is that J4 also contains the self-loop H(u, u), a fact not specified in the data exchange. Formally, every homomorphism maps self-loops to self-loops, thus there is no homomorphism from J4 to J3 (or to any of the other solutions listed). Finally, each J n is a universal solution. For instance, there is a homomorphism hn from J n to J3 with g(vi) = u, for every i ≤ n.</p><p>In logic programming, a most general unifier of two unifiable terms is known to be unique up to isomorphism. In contrast, the universal solutions for a given source instance I need not have this property. For instance, in Example 3.1, all solutions J n are universal and pairwise non-isomorphic, as they have different sizes. Nonetheless, it follows immediately from Definition 3.3 that all universal solutions for a given source instance I are homomorphically equivalent, which means that if J and J are universal solutions for I, then there is a homomorphism h from J to J , and a homomorphism h from J to J. Furthermore, according to the next result from <ref type="bibr" target="#b13">[13]</ref>), universal solutions embody in a certain sense the entire space of solutions; this is analogous to the most general unifier of two terms encapsulating the entire space of unifiers of the two terms. Theorem 3.4. Let M = (S, T, Σst∪Σt) be a schema mapping such that Σst is a set of s-t tgds and Σt is a set of target tgds and target egds. Assume that I and I are two source instances, J is a universal solution for I, and J is a universal solution for I . The following statements are equivalent:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">SOL(M, I) ⊆ SOL(M, I ).</head><p>2. There is a homomorphism h : J → J.</p><p>Consequently, SOL(M, I) = SOL(M, I ) if and only if J and J are homomorphically equivalent.</p><p>Let M = (S, T, Σst ∪Σt) be a schema mapping such that Σst is a set of s-t tgds and Σt is a set of target tgds and target egds. We mentioned earlier that if Σt = ∅, then every source instance I has a solution. Moreover, in this case, every source instance I has a universal solution. In general, however, a given source instance I may have no solution. Furthermore, it is possible that a solution exists for a given source instance I, but no universal solution for I exists <ref type="bibr" target="#b13">[13]</ref>. This state of affairs dictates that restrictions have to imposed on the target constraints used, so that the existence of solutions implies the existence of universal solutions (the converse is always trivially true). At the same time, we would like to have restrictions that yield polynomial-time algorithms for testing whether a solutions exists and for computing a universal solution, whenever a solution exists.</p><p>The chase procedure is an indispensable algorithmic tool for reasoning about dependencies <ref type="bibr" target="#b26">[26,</ref><ref type="bibr" target="#b4">4,</ref><ref type="bibr" target="#b5">5]</ref> and, in particular, for testing whether a given set of dependencies logically implies another given dependency. As it turns out, the chase procedure is versatile enough to be adapted for productive use in data exchange. Specifically, in <ref type="bibr" target="#b13">[13]</ref>, the concept of a weakly acyclic set of target tgds was introduced and then used to show that a variant of the chase procedure yields a polynomial-time algorithm for testing for solutions and for computing universal solutions in every schema mappings M in which the set Σt of target constraints is the union of a set of target egds with a weakly acyclic set of target tgds. Definition 3.5. [Weakly acyclic set of tgds] Let Σ be a set of tgds over a schema T. Construct the following directed graph, called the dependency graph:</p><p>• The nodes of the dependency graph are pairs (R, A) such that R is a relation symbol in T and A is an attribute of R; call such a pair a position.</p><p>• The edges of the dependency graph are created according to the following rules. For every tgd ϕ(x) → ∃yψ(x, y) in Σ, for every x in x that occurs in ψ, and for every occurrence of x in φ in position (R, Ai):</p><p>1. For every occurrence of x in ψ in position (S, B j ), add an edge (R, Ai) → (S, Bj) (if it does not already exist).</p><p>2. In addition, for every existentially quantified variable y and for every occurrence of y in ψ in position (T, C k ), add a special edge (R, Ai) * → (T, C k ) (if it does not already exist).</p><p>We say that the set Σ is weakly acyclic if the dependency graph has no cycle going through a special edge.</p><p>Clearly, if Σ is a set of full tgds, then Σ is weakly acyclic, since the absence of existential quantifiers in the tgds of Σ implies that the dependency graph has no special edges. It is also easy to verify that if Σ is an acyclic set of inclusion dependencies <ref type="bibr" target="#b10">[10]</ref>, then Σ is weakly acyclic as well. In contrast, the singleton set Σ = {H(x1, x2) → ∃yH(x2, y)} is not weakly acyclic, because the dependency graph has a self-loop with a special edge, namely (H, B) * → (H, B). Note also that each of the two singleton sets Σ1 = {H(x1, x2) → ∃yH(x1, y)} and Σ2 = {H(x1, x2) → ∃yH(y, x2)} is weakly acyclic, but not acyclic; however, their union Σ1 ∪ Σ2 is not weakly acyclic as it contains the cycle (H,</p><formula xml:id="formula_10">A) * → (H, B) * → (H, A)</formula><p>The intuition behind the dependency graph and the concept of a weakly set of tgds is as follows. Suppose we try to construct a target instance that satisfies a set Σt of target tgds by using the chase procedure. The non-special edges in the dependency graph keep track of the fact that a value may propagate from position (R, Ai) to position (S, Bj) during the chase. The special edges keep track of the fact that propagation of a value from position (R, Ai) to position (S, Bj) also creates a labelled null in every position that has an existentially quantified variable. If a cycle goes through a special edge, then a labelled null appearing in a certain position during the chase may determine the creation of another labelled null, in the same position, at a later chase step. Thus, this process may continue for ever. In contrast, if the set Σt is weakly acyclic, it can be shown that the chase procedure will terminate after polynomially many steps. Moreover, if target egds are also present, then the only extra complication is that the chase may fail, but this failure will be detected within polynomially many steps.</p><p>The next result from <ref type="bibr" target="#b13">[13]</ref> yields a broad sufficient condition for the tractability of the existence-of-solutions problem in data exchange and for the efficient computation of a universal solution, whenever a solution exists. Theorem 3.6. Let M = (S, T, Σst∪Σt) be a schema mapping such that Σst is a set of s-t tgds and Σt is the union of a set of target egds with a weakly acyclic set of target tgds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• Given a source instance I, a universal solution for I exists if and only if a solution for I exists.</head><p>• There is a polynomial-time algorithm based on the chase procedure such that, given a source instance I, it tests whether a solution for I exists and, if so, it produces a universal solution solution J for I.</p><p>To appreciate the wide applicability of the preceding Theorem 3.6, note that its hypothesis is fulfilled by every schema mapping M = (S, T, Σst ∪ Σt) such that Σst is a set of s-t tgds and Σt satisfies one of the following properties:</p><p>• Σt is a set of target egds (that is, Σt contains no target tgds).</p><p>• Σt is the union of a set of target egds with a set of target full tgds.</p><p>• Σt is the union of a set of target egds with an acyclic set of inclusion dependencies.</p><p>It remains an interesting open problem to identify other broad classes of schema mappings that have the following properties: (1) for a given instance, universal solutions exist if and only if solutions exist; (2) there are polynomial-time algorithms for determining, given a source instance, whether a solution exists and for computing a universal solution, whenever a solution exists.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Core: The Smallest Universal Solution</head><p>We have made a case that universal solutions are the preferred solutions in data exchange. At the same time, we pointed out that, although all universal solutions for a given source instance are homomorphically equivalent to each other, they need not be isomorphic. In particular, the source instance I in Example 3.1 has infinitely many non-isomorphic universal solutions, since, for every n ≥ 1, the target instance J n has size (number of facts) 2n and is a universal solution for I. This raises the question: are some universal solutions "better" than others? Is there a "best" universal solution that we should choose to materialize and, if so, is it efficiently computable?</p><p>The pursuit of the "best" universal solution was undertaken in <ref type="bibr" target="#b14">[14]</ref> using a small is beautiful approach. The main finding of this investigation is that there is a smallest universal solution, which is thus the most economical one to materialize in terms of size. This smallest universal solution is unique up to isomorphism and coincides with the core of all universal solutions. Furthermore, although computing the core of arbitrary relational structures is an intractable problem, it turns out that there are broad classes of schema mappings for which the core of the universal solutions is computable in polynomial time. In the remainder of this section, we present an overview of these findings.</p><p>Let G = (V, E) be an (undirected) graph, where V is the set of its nodes and E is the set of its edges; this means that E is a non-empty binary relation on V that is symmetric and irreflexive (no self-loops</p><formula xml:id="formula_11">). A subgraph of G is a graph G = (V , E ) such that V ⊆ V and E ⊆ E; it is a proper subgraph if E is a proper subset of E.</formula><p>Definition 3.7. Let G = (V, E) be a graph.</p><formula xml:id="formula_12">• A subgraph G = (V , E</formula><p>) is a core of G if the following two conditions hold:</p><p>1. There is homomorphism from G to G .</p><p>2. There is no homomorphism from G to a proper subgraph of G .</p><p>• G is a core if it is a core of itself.</p><p>Cores have been studied in depth by graph theorists <ref type="bibr" target="#b20">[20,</ref><ref type="bibr" target="#b21">21]</ref>. For every n ≥ 2, the complete graph Kn with n nodes is a core; for every n ≥ 1, the odd cycle C2n+1 is also a core. It is also easy to see that a graph G is 2-colorable if and only if K2 is a core of G. In particular, K2 is a core of every even cycle C2n. There is an abundance of cores. As a matter of fact, it has been shown that almost all finite graphs are cores <ref type="bibr" target="#b24">[24]</ref>, which means that, under the uniform probability measure, the asymptotic probability of a finite graph being a core is equal to 1. The next proposition summarizes some well known and easy to prove properties of cores of finite graphs.</p><p>Proposition 3.8. Let G be a finite graph.</p><p>• G has a core.</p><p>• The cores of G are pairwise isomorphic; thus, we can talk about the core of G, denoted by core(G).</p><p>• There is one-to-one homomorphism from core(G) to G.</p><p>• G is homomorphically equivalent to its core. It follows that two graphs are homomorphically equivalent if and only if their cores are isomorphic.</p><p>It should be noted that there are infinite graphs that have no cores; thus, the hypothesis that G is finite in Proposition 3.8 is of the essence. The concept of a core is perfectly meaningful for directed graphs and, more generally, for arbitrary relational structures. Proposition 3.8 easily extends to every finite relational structure, so that every finite relational structure has a core, which is unique up to isomorphism. Cores of relational databases have been studied in the context of conjunctive-query processing <ref type="bibr" target="#b8">[8]</ref>, since minimizing a conjunctive query amounts to finding the core of the canonical database associated with the query (this is the database whose facts are the conjuncts of the conjunctive query).</p><p>For our purposes here, we will focus on cores of target instances in schema mappings M = (S, T, Σst ∪ Σt) in which Σst is a set of s-t tgds and Σt is a set of target egds and target tgds. The definition of the core of a target instance is entirely analogous to that of the core of a graph, except that the homomorphisms considered must obey Definition 3.3 and, thus, map constants to themselves. This means, that we consider only homomorphisms h between target instances such that h(c) = c, for every c ∈ Const. In what follows, if J is a target instance, we will write core(J) to denote the (unique up to isomorphism) core of J.</p><p>Let I be a source instance for which universal solutions exist.</p><p>As we saw earlier, all universal solutions for I are homomorphically equivalent. Consequently, Proposition 3.8 (extended to target instances) implies that the cores of the universal solutions for I are isomorphic; in other words, all universal solutions for I have the same core up to isomorphism. In <ref type="bibr" target="#b14">[14]</ref>, it was shown that the core of a solution for a source instance I is itself a solution for I. It follows that the core of universal solutions is itself a universal solution, hence it is the smallest universal solution. We collect these facts into a proposition.</p><p>Proposition 3.9. Let M = (S, T, Σst ∪ Σt) be a schema mapping in which Σst is a set of s-t tgds and Σt is a set of target egds and target tgds.</p><p>1. If I is a source instance and J is a solution for I, then core(J) is a solution for I.</p><p>2. If I is a source instance and J is a universal solution for I, then also core(J) is a universal solution.</p><p>3. If I is source instance for which a universal solution exists, then there is a universal solution J0 having the following properties:</p><p>• J0 is a core and is isomorphic to the core of every universal solution for I. Note that if M = (S, T, Σ) is a schema mapping in which Σ is a set of arbitrary dependencies (say, arbitrary first-order formulas), then the core of a solution for a source instance I need not be a solution for I. Thus, the first part of Proposition 3.9 depends crucially on the assumption that the dependencies in the schema mapping M are s-t tgds, target egds, and target tgds. The other parts of Proposition 3.9 follow the first part, the definitions, and Proposition 3.8. Returning to Example 3.1, we see that solution J3 is the smallest universal solution for I, and so is the isomorphic solution J 1 .</p><p>The core of the universal solutions is the preferred universal solution to materialize in data exchange, since it is the unique most compact universal solution. In turn, this raises the question of how to compute cores of universal solutions. Theorem 3.6 asserts that universal solutions can be computed in polynomial time using the chase, provided the set of target tgds is weakly acyclic. However, the result of the chase procedure, while a universal solution, need not be the core of the universal solutions. Consequently, different algorithmic tools are needed for computing the core of the universal solutions in data exchange.</p><p>Let us consider for a moment the computational complexity of computing the core of a graph. As mentioned earlier, a graph G is 3-colorable if and only if there is a homomorphism from G to K3, the complete graph with 3 nodes. From this, it follows that a graph G is 3-colorable if and only if core(G ⊕ K3) = K3, where G ⊕ K3 is the disjoint union of G and K3. Consequently, unless P = NP, there is no polynomial-time algorithm for computing the core of a given structure. Indeed, if such an algorithm existed, then we could determine in polynomial time whether a graph is 3colorable by first running the algorithm to compute the core of G ⊕ K3 and then checking if the answer is equal to K3.</p><p>This intractability of computing the core of graphs and, more generally, of finite relational structure was already realized by Chandra and Merlin <ref type="bibr" target="#b8">[8]</ref> in their work on conjunctive-query minimization. Later on, Hell and Nešetřil <ref type="bibr" target="#b20">[20]</ref> showed that the following problem, called Core Recognition, is coNPcomplete: given a graph G, is it a core? Finally, in <ref type="bibr" target="#b14">[14]</ref>, it was shown that the following problem, called Core Identification, is DP-complete: given two graphs G and H, is H the core of G? The class DP consists of all decision problems that can be written as an intersection of NP-problem and a coNP-problem <ref type="bibr" target="#b31">[31,</ref><ref type="bibr" target="#b32">32]</ref>. Since DP contains both NP and coNP as subclasses, DP-complete problems are regarded as "harder" than NP-complete problems.</p><p>The preceding complexity-theoretic results reveal that, unless P = NP, computing the core of a graph (or, of a finite relational structure) is an intractable problem. In data exchange, however, the goal is to compute the core of a universal solution, rather than the core of an arbitrary instance. Therefore, the intractability of computing the core of an arbitrary instance does not automatically imply the intractability of computing the core of universal solutions. In fact, as we are about to see, for certain large classes of schema mappings, polynomial-time algorithms for computing the core of universal solutions do exist.</p><p>Let M = (S, T, Σst ∪Σt) be a schema mapping such that Σst is a set of s-t tgds and Σt is a set of target egds (no target tgds). For such schema mappings, a polynomial-time algorithm, called the blocks algorithm, for computing the core of universal solutions was given in <ref type="bibr" target="#b14">[14]</ref>. A conceptually simpler polynomial-time algorithm, called the greedy algorithm, for the same task was subsequently given in the full version of <ref type="bibr" target="#b14">[14]</ref>. Intuitively, given a source instance I, the greedy algorithm first determines whether solutions for I exist, and then, if solutions exist, computes the core of the universal solutions for I by successively removing tuples from a universal solution for I, as long as I and the instance resulting in each step satisfy the s-t tgds in Σst.</p><p>Before describing the greedy algorithm, let us recall that a fact is an expression of the form R(t) indicating that the tuple t belongs to the relation R; moreover, every instance can be identified with the set of all facts arising from the relations of that instance.</p><p>Algorithm 3.10. Greedy Algorithm Parameter: Schema mapping M = (S, T, Σst ∪ Σt) such that Σst is a set of s-t tgds and Σt is a set of target egds.</p><p>Input: source instance I.</p><p>Output: the core of the universal solutions for I, if solutions exist; "failure", otherwise.</p><p>1. Chase I with Σst to produce a target instance J that is a universal solution for I under the schema mapping M = (S, T, Σst).</p><p>2. Chase J with Σt; if the chase fails, then stop and return "failure"; otherwise, let J be the universal solution for I produced by the chase.</p><p>3. Initialize J * to be J . 4. While there is a fact R(t) in J * such that I, J * -{R(t)} satisfies Σst, set J * to be J * -{R(t)}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Return J * .</head><p>The following result about the greedy algorithm was established in the full version of <ref type="bibr" target="#b14">[14]</ref>.</p><p>Theorem 3.11. Assume that (S, T, Σst ∪ Σt) is a data exchange setting such that Σst is a set of s-t tgds and Σt is a set of target egds. Then Algorithm 3.10 is a correct, polynomialtime algorithm for testing for the existence of solutions and for computing the core of universal solutions, if solutions exists.</p><p>In <ref type="bibr" target="#b14">[14]</ref>, it was left as an open problem to determine whether there are polynomial-time algorithms for computing the core in richer schema mappings. In the meantime, Gottlob <ref type="bibr" target="#b18">[18]</ref> obtained a number of results concerning the computation of cores in data exchange. In particular, he established that if M = (S, T, Σst ∪ Σt) is a schema mapping such that Σst is a set of s-t tgds and Σt is set of target egds and target full tgds, then the core of universal solutions can be computed in polynomial time using a sophisticated extension of the blocks algorithm. It remains to be seen whether these tractability results extend to schema mappings in which the set of target constraints is the union of a set of target egds with a weakly acyclic set of target tgds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Query Answering in Data Exchange</head><p>Suppose that a schema mapping M = (S, T, Σ) is used to exchange data from a source schema S to a target schema T. Suppose also that a query q over the target schema T is posed. What does answering this query using source data mean? As we have seen earlier, given a source instance I, there may be infinitely many solutions J for I; furthermore, if q is evaluated on different solutions J for I, it is possible that different answers are produced. This ambiguity raises the conceptual problem of giving precise semantics to query answering in data exchange. Similar conceptual problems were encountered much earlier in the study of incomplete databases; they were addressed by introducing the concept of the certain answers as the semantics of query answering (see <ref type="bibr" target="#b35">[35]</ref> for a survey). The certain answers were also adopted as the standard semantics of query answering in information integration (see <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b23">23]</ref>). What indefinite databases and information integration have in common is that queries are posed not against a single database, but rather against the set of all possible databases in certain contexts, that is, all databases satisfying a certain specification. By definition, the certain answers of a query q are the tuples that occur in the intersection of all q(J)'s, as J ranges over all databases satisfying the specification at hand. This concept is also perfectly meaningful in data exchange, where the schema mapping can be viewed as a specification of the solutions for a given source instance. Thus, in data exchange, given a source instance I, the possible databases are the solutions for I. Definition 4.1. Let M = (S, T, Σ) be a schema mapping and let q be a query over the target schema T.</p><p>• If I is source instance, then the certain answers of q on I with respect to M, denoted certainM(q, I), is the set certainM(q, I) = {q(J) : J ∈ SOL(M, I)}.</p><p>• Computing the certain answers of q is the following decision problem: given a source instance I and a tuple t of constants from I, is t in certainM(q, I)?</p><p>On the face of it, the definition of the certain answers is highly non-effective, since evaluating certainM(q, I) entails computing the intersection of infinitely many sets. In information integration, the main approach to computing the certain answers is to try to rewrite queries over the target to queries over the sources. In data exchange, one would like to take advantage of the materialized solution and use it to obtain the certain answers of target queries. As shown in <ref type="bibr" target="#b13">[13]</ref>, the certain answers of unions of conjunctive queries can be obtained using a universal solution. Recall that a conjunctive query is a first-order formula of the form ∃wχ(x, w), where χ(x, w) is a conjunction of atoms. A union of conjunctive queries is a finite disjunction of conjunctive queries. The following result is from <ref type="bibr" target="#b13">[13]</ref>.</p><p>Theorem 4.2. Assume that M = (S, T, Σst ∪ Σt) is a schema mapping such that Σst is a set of s-t tgds and Σt is a set of target egds and target tgds. Let q be a union of conjunctive queries over the target schema T.</p><p>• If I is a source instance and J is a universal solution for I, then certainM(q, I) = q(J) ↓ , where q(J) ↓ is the set of all "null-free" tuples in q(J), that is, all tuples t in q(J) such that every value in t is a constant in Const.</p><p>• Assume further that Σt is the union of a set of target egds with a weakly acyclic set of target tgds. Then there is a polynomial-time algorithm for computing the certain answers of q.</p><p>The preceding Theorem 4.2 provides further evidence for the goodness of universal solutions in data exchange. The proof of the first part of this result uses the existence of homomorphisms from a universal solution to every solution, and the preservation of conjunctive queries under homomorphisms.</p><p>The second part follows immediately by combining the first part with Theorem 3.6 and the fact that every fixed conjunctive query can be evaluated in polynomial time. As an illustration of Theorem 4.2, let us consider again the schema mapping M and the source instance I = {E(1, 2}) in Example 3.1. Let q(x) be the conjunctive query ∃wH(x, w). Using the definitions, it is easy to verify that certainM(q, I) = {1}.</p><p>Recall that the target instance J3 = {H(1, u), H(u, 2)} is a universal solution for I. Clearly, q(J3) = {1, u}, hence q(J3) ↓ = {1} = certainM(q, I), as predicted by Theorem 4.2.</p><p>Conjunctive queries with inequalities ( =) form one of the most extensively studied extensions of conjunctive queries. By definition, a conjunctive query with inequalities is a firstorder formula of the form ∃wχ(x, w), where χ(x, w) is a conjunction of atoms and inequalities u = v; a union of conjunctive query with inequalities is a finite disjunction of conjunctive query with inequalities. Conjunctive queries with inequalities are more expressive than conjunctive queries; this increase in expressive power, however, often comes at a price.</p><p>In particular, as we are about to see, Theorem 4.2 does not extend to unions of conjunctive queries with inequalities.</p><p>First, it is easy to see that the certain answers of conjunctive queries with inequalities cannot be obtained by simply evaluating them on some universal solution and then discarding all tuples containing nulls. Intuitively, the reason for this is that a conjunctive query with inequalities need not be preserved under homomorphisms; thus, if it holds on some universal solution, then it need not hold on every solution.</p><p>Concretely, let M be the schema mapping in Example 3.1, let p(x) be the query ∃w(H(x, w) ∧ w = x), and let I0 be the source instance consisting of just the fact E(1, 1). Clearly, certainM(p, I0) = ∅, since J0 = {H(1, 1)} is a solution for I0 and p(J0) = ∅. At the same time, the target instance J5 = {(1, u), (u, 1)} is a universal solution for I0 (in fact, it is the core of the universal solutions for I0), and p(J5) ↓ = {1}.</p><p>The next result from <ref type="bibr" target="#b13">[13]</ref> pinpoints the computational complexity of computing the certain answers of unions of conjunctive queries with inequalities; in particular, it shows that this problem can be intractable, unless at most one inequality is allowed in every conjunctive query in the union.</p><p>Theorem 4.3. Assume that M = (S, T, Σst ∪ Σt) is a schema mapping such that Σst is a set of s-t tgds and Σt is the union of a set of target egds with a weakly acyclic set of target tgds.</p><p>• If q is a union of conjunctive queries with at most one inequality per conjunctive query, then the certain answers of q are polynomial-time computable.</p><p>• If q is a union of conjunctive queries with inequalities, then the certain anwers of q is a coNP problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• Computing the certain answers of unions of conjunctive queries with inequalities can be a coNP-complete problem, even if the union consists of two conjunctive queries each of which has at most two inequalities, and the schema mapping has no target constraints.</head><p>Abiteboul and Duschka <ref type="bibr" target="#b1">[1]</ref> showed that there is a single conjunctive query with seven inequalities and a schema mapping with no target constraints for which computing the certain answers in a coNP-complete problem. In <ref type="bibr" target="#b13">[13]</ref>, it was conjectured that there is a single conjunctive query with two inequalities and a schema mapping with no target constraints for which computing the certain answers is a coNP-complete problem. This conjecture has recently been proved by Madry <ref type="bibr" target="#b27">[27]</ref>. In fact, the s-t tgds in the schema mapping constructed by Madry (as well as in the schema mapping constructed by Abiteboul and Duschka), are sound views in LAV, which means that they are s-t tgds of the form R(x) → ∃yψ(x, y) with R a relation symbol in the source schema S. Combined with Theorem 4.3, these results yield a rather complete picture of the complexity of the certain answers of conjunctive queries with inequalities.</p><p>We saw earlier that the certain answers of conjunctive queries with inequalities cannot always be obtained by evaluating them on some universal solution and then discarding all tuples containing a null value. In fact, this fails even if the universal solution chosen is the core of the universal solutions.</p><p>Nonetheless, among all universal solutions, the core gives the best approximation to the certain answers of unions of conjunctive queries. This is made precise in the next proposition, which is proved using the fact that the core has one-to-one homomorphisms to every universal solution.</p><p>Proposition 4.4. Assume that M = (S, T, Σst ∪ Σt) is a schema mapping such that Σst is a set of s-t tgds and Σt is a set of target egds and target tgds. Assume also that I is a source instance for which universal solutions exist and let J0 be the core of the universal solutions for I. If q is a union of conjunctive queries with inequalities, then • q(J0) ⊆ q(J), for every universal solution J for I;</p><formula xml:id="formula_13">• q(J0) ↓ = {q(J) : J is universal for I} ⊆ certainM(q, I).</formula><p>The concept of the certain answers in data exchange was arrived at by taking the solutions for an instance to be the possible databases. We have made a case, however, that the universal solutions are the preferred solutions in data exchange. This suggests an alternative semantics of query answering in data exchange by taking the universal solutions for an instance to be the possible databases in the definition of the certain answers. The following concept of the universalcertain answers, in short u-certain answers, was introduced in the full version of <ref type="bibr" target="#b14">[14]</ref>. Definition 4.5. Let M = (S, T, Σ) be a schema mapping and let q be a query over the target schema T.</p><p>• If I is source instance, then the u-certain answers of q on I with respect to M, denoted u-certainM(q, I), is the set u-certainM(q, I) = {q(J) : J is universal for I}.</p><p>• Computing the u-certain answers of q is the following decision problem: given a source instance I and a tuple t of constants from I, does t ∈ u-certainM(q, I)?</p><p>From the definitions, it follows immediately that certainM(q, I) ⊆ u-certainM(q, I).</p><p>Furthermore, if q is a union of conjunctive queries and I is a source instance for which universal solutions exist. then Theorem 4.2 implies that certainM(q, I) = u-certainM(q, I).</p><p>Let M = (S, T, Σst ∪Σt) be a schema mapping such that Σst is a set of s-t tgds and Σt is a set of target egds. By Theorem 3.11, given a source instance I, we can decide in polynomial time whether a solution for I exists and, if it does, construct the core J0 of the universal solutions for I in polynomial time. From this fact and Proposition 4.4, it follows that if q is a union of conjunctive queries with inequalities, then u-certainM(q, I) can be evaluated in polynomial time, since u-certainM(q, I) = q(J0) ↓ . Thus, we have established the following result.</p><p>Corollary 4.6. Let M = (S, T, Σst ∪ Σt) be a schema mapping such that Σst is a set of s-t tgds and Σt is a set of target egds. If q is a union of conjunctive queries with inequalities, then there is a polynomial-time algorithm for computing u-certainM(q, I).</p><p>To appreciate the preceding Corollary 4.6, note that it is not at all clear how this result can be proved without using the concept of the core and Theorem 3.11. Note also that, by Gottlob's recent results <ref type="bibr" target="#b18">[18]</ref>, Corollary 4.6 extends to all schema mappings M in which Σt is a set of target egds and target full tgds.</p><p>We saw that the u-certain answers semantics coincides with the certain answers semantics on unions of conjunctive queries, but the two may digress on unions of conjunctive queries with inequalities. The u-certain answers semantics has a definite computational advantage over the certain answers semantics, as the former is polynomial-time computable in settings in which the latter is coNP-complete. Several questions merit further investigation. How do these two semantics compare from a pragmatic point of view? In other words, which of the two captures better the intent of the user? How do they compare on queries that more expressive than the ones considered here? More broadly, are there are other semantics that are meaningful for query answering in data exchange? And what criteria can we develop to compare the quality of query answering in data exchange under different semantics?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Composing Schema Mappings</head><p>Suppose that we have two schema mappings such that the target schema of the first is the source schema of the second. We would like to have a composition operator that takes two such schema mappings as input and produces a third schema mapping that has the same effect as applying the two original schema mappings one after the other. Such an operator could be a powerful component in a data exchange tool that is able to automatically synthesize several consecutive schema mappings into a single schema mapping that captures the combined effect of all schema mappings in the sequence. Indeed, the resulting single schema mapping could then be used during the run-time phase for direct data exchange or for query answering, potentially yielding performance benefits. The concept of the composition operator occupies also a central place in Bernstein's metadata management framework <ref type="bibr" target="#b6">[6]</ref>. The reason for this is that composition is a key building block in constructing more powerful metadata operators. In particular, schema evolution can be analyzed via repeated applications of composition. , respectively. The goal is to have a composition operator that, given two such schema mappings, produces a schema mapping M13 = (S1, S3, Σ13) that is "equivalent" to the successive applications of M12 and M23. It is not clear, however, what being "equivalent" exactly means in this context. Therefore, the first step in the study of the composition operator on schema mappings is to develop rigorous semantics for this operator.</p><p>Madhavan and Halevy <ref type="bibr" target="#b25">[25]</ref> were the first to propose and investigate a precise semantics for the composition operator. Since one of their primary motivations was query answering in peer-to-peer data management systems, their definition carries a class Q of queries over the schema S3 as a parameter. Specifically, it is stipulated that, for every query q in Q, the certain answers of q with respect to the composition M13 coincide with the certain answers obtained by successively applying M12 and M23. The dependence on the class of queries results to inequivalent semantics for different classes of queries. Indeed, as shown in <ref type="bibr" target="#b15">[15]</ref>, the semantics of the composition w.r.t. conjunctive queries is different from those w.r.t. conjunctive queries with inequalities. Also, even for a fixed class of queries, the composition of two schema mappings need not be unique up to logical equivalence.</p><p>A different semantics for the composition operator was given and thoroughly investigated in <ref type="bibr" target="#b15">[15]</ref>. This semantics has a set-theoretic flavor and is obtained by simply composing the spaces Inst(M12) and Inst(M23) of the instances (recall Definition 2.2) of the schema mappings M12 and M23.  Once the semantics of the composition operator has been put in place, several technical issues arise. As mentioned in the Introduction, the first key issue is the closure of schemamapping specification languages under composition. More precisely, let M12 = (S1, S2, Σ12) and M23 = (S2, S3, Σ23) be two schema mappings in which Σ12 and Σ23 are sets of formulas of some logic L. Is the composition of these two schema mappings definable in L? In other words, is there a set Σ13 of L-formulas such that M12 • M23 = (S1, S3, Σ13)? If so, can such a set be effectively constructed? Last but not least, what is the computational complexity of the composition query of two given schema mappings?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Composing s-t tgds</head><p>The aforementioned issues were investigated in <ref type="bibr" target="#b15">[15]</ref> for schema mappings of the form (S, T, Σst), where Σst is a set of s-t tgds (no target constraints). In a nutshell, it was shown there that the language of s-t full tgds is closed under composition, while on the contrary the language of s-t tgds is not. Furthermore, the composition query of two schema mappings specified by s-t tgds may be NP-complete. These findings are described in more detail in the next result.  • There exist schema mappings M12 and M23 such that Σ12 is a finite set of s-t tgds, Σ23 is a finite set of s-t full tgds, and the following hold for the composition of these two schema mappings:</p><p>1. The composition query of M12•M23 is NP-complete.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">The composition M12•M23</head><p>is not definable by any formula of least fixed-point logic LFP. In particular, the composition M12 • M23 is not definable by any formula of first-order logic or of Datalog.</p><p>Several remarks are in order now. To begin with, note that the proof of the first part of Theorem 5.2 actually gives an algorithm for finding a set Σ13 of s-t full tgds that defines the composition; this set, however, can be exponentially larger than the sets Σ12 and Σ23. The same state of affairs holds true for the second part of Theorem 5.2. In certain respects, these two parts contain the best positive results about the composition of finite sets of s-t tgds. Indeed, the last part of Theorem 5.2 implies that the composition of a finite set of s-t tgds with a finite set of s-t full tgds need not be definable by a finite set of s-t tgds. The next example from <ref type="bibr" target="#b15">[15]</ref> illustrates this phenomenon. In <ref type="bibr" target="#b15">[15]</ref>, it is shown that the composition M12 • M23 is not definable by any set (finite or infinite) of s-t tgds. The reason for this is that every set of s-t tgds is preserved under homomorphisms of target instances, while the composition query of M12 and M23 is not. It is not hard, however, to show that the composition M12 • M23 of these two schema mappings is definable by the following first-order formula: ∀e(Emp(e) → ∃mMgr(e, m)) ∧ ∀e((∀x(Mgr(e, x) → (e = x))) → SelfMgr(e)).</p><p>Consequently, the composition query of M12 and M23 is a polynomial-time query.</p><p>The last part of Theorem 5.2 asserts that the composition of a finite set of s-t tgds with a finite set of s-t tgds need not be first-order definable; moreover, the associated composition query may actually be NP-complete. This was proved in <ref type="bibr" target="#b15">[15]</ref> via reduction from 3-Colorability that we now give. </p><formula xml:id="formula_14">= {E(x, y) → F (x, y), E(x, y) → ∃uC(x, u), E(x, y) → ∃vC(y, v)} Σ23 = {(C(x, u) ∧ C(y, v) ∧ F (x, y) → D(u, v))}.</formula><p>Given a graph G = (V, E), let I1 be the instance over S1 consisting of the edge relation E of G, and let I3 be the instance over the schema S3 with D = {(r, g), (g, r), (b, r), (r, b), (g, b), (b, g)}.</p><p>In words, D is the edge relation of the complete graph K3 on three nodes r, g, b. It is now easy to verify that G is 3-colorable if and only if I1, I3 is in Inst(M12) • Inst(M23). Thus, the composition query of M12 and M23 is NP-complete. In addition, since the above reduction is expressible in firstorder logic, results by Dawar <ref type="bibr" target="#b11">[11]</ref> imply that the composition query of M12 and M23 is not definable in least fixed-point logic LFP, a logic that is well known to subsume both firstorder logic and Datalog.</p><p>Observe that each s-t tgd in Σ12 has at most one existential quantifier, while Σ23 consists of a single s-t full tgd. Thus, the preceding construction draws a rather sharp boundary on the definability of the composition of schema mappings specified by finite sets of s-t tgds. More precisely, the composition of a finite set of s-t full tgds with a finite set of s-t tgds is always definable by a first-order formula (and, in fact, definable by a finite conjunction of s-t tgds), while the composition of a finite set of s-t tgds having at most one existential quantifier with a set consisting of a single s-t full tgd may not even be LFP-definable (and, a fortiori, not firstorder definable). Similarly, the computational complexity of the associated composition query may jump from solvable in polynomial time to NP-complete.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Second-order tgds</head><p>What is the "right" specification language for expressing the composition of schema mappings specified by finite sets of s-t tgds? There are two main desiderata in such a specification language. First, it should be powerful enough to express the composition of schema mappings specified by finite sets of s-t tgds, while at the same time it should itself be closed under composition. Second, it should enjoy good algorithmic properties for data exchange purposes.</p><p>A class of existential second-order formulas, called secondorder tuple-generating dependencies ( SO tgds), was introduced and studied in <ref type="bibr" target="#b15">[15]</ref>. In informal terms, an SO tgd is a source-to-target dependency suitably extended with existentially quantified function symbols. The composition of two finite sets of s-t tgds is always definable by an SO tgd. Moreover, the composition of two SO tgds is always definable by an SO tgd. Finally, SO tgds have good properties for data exchange, since the chase procedure can be extended to SO tgds so that it produces polynomial-time computable universal solutions in schema mapping specified by SO tgds. We now formally define SO tgds.  (</p><formula xml:id="formula_15">)<label>1</label></formula><p>It follows that every finite set of s-t tgds is logically equivalent to a single SO tgd.</p><p>Next, consider the schema mappings M12 and M23 used in the reduction from 3-Colorability. It is easy to verify that the composition M12 • M23 is definable by the SO tgd ∃f (∀x∀y(E(x, y) → D(f (x), f(y)))).</p><p>(</p><formula xml:id="formula_16">)<label>2</label></formula><p>Since this composition is not first-order definable, it follows that the above SO tgd is not logically equivalent to any finite set of s-t tgds. Thus, SO tgds properly subsume s-t tgds. </p><p>As noted earlier, this composition is not definable by any set (finite or infinite) of s-t tgds, but is first-order definable.</p><p>Note that an equality between terms occurs in SO tgd (3), but not in SO tgds (1) and <ref type="bibr" target="#b2">(2)</ref>. In <ref type="bibr" target="#b15">[15]</ref>, it was shown that allowing equalities in SO tgds is of the essence, because no SO tgd without equalities can define the composition of the two schema mappings in Example 5.3. This also suggests that formulating the concept of SO tgds was a rather delicate matter. For example, a naive way to arrive at secondorder dependencies is to Skolemize s-t tgds. However, the fragment of existential second-order logic obtained this way lacks the expressive power to express the composition of finite sets of s-t tgds, since formulas in this fragment do not contain equalities.</p><p>As noted earlier, the conjunction of finitely many SO tgds is logically equivalent to a single SO tgd. Thus, instead of considering schema mappings specified by finite sets of SO tgds, it suffices to consider schema mappings specified by a single SO tgds. The next result from <ref type="bibr" target="#b15">[15]</ref> asserts that such schema mappings are closed under composition.</p><p>Theorem 5.5. SO tgds are closed under composition, that is, if M12 = (S1, S2, Σ12) and M23 = (S2, S3, Σ23) are two schema mappings in which Σ12 and Σ23 are SO tgds, then there is an SO tgd Σ13 such that M12 • M23 = (S1, S2, Σ13).</p><p>Corollary 5.6. The composition of two finite sets of s-t tgds is definable by an SO tgd.</p><p>In <ref type="bibr" target="#b15">[15]</ref>, an algorithm is presented for constucting an SO tgd that defines the composition of two given SO tgds. The algorithm runs in exponential time; it can be shown that this task requires exponential time. Also in <ref type="bibr" target="#b15">[15]</ref>, it is shown that, when it comes to data exchange, SO tgds have the same good algorithmic properties as s-t tgds.</p><p>Theorem 5.7. Let M = (S, T, Σ) be a schema mapping in which Σ is an SO tgd.</p><p>• There is a polynomial-time algorithm based on an extension of the chase procedure such that, given a source instance I, it tests whether a solution for I exists and, if so, it produces a universal solution J for I.</p><p>• If q is a union of conjunctive queries over T, then there is a polynomial-time algorithm for computing the certain answers of q.</p><p>The results presented in this section make a strong case that SO tgds possess the right balance between high expressive power and good algorithmic properties. On the one hand, they are powerful enough to express the composition of finite sets of s-t tgds, while being themselves closed under composition. On the other hand, they are amenable to the chase procedure, so that there are polynomial-time algorithms for constructing a universal solution and for computing the certain answers of unions of conjunctive queries.</p><p>Finally, note that the semantics of composition of schema mappings presented here has also been considered by Melnik <ref type="bibr" target="#b28">[28]</ref> in his doctoral dissertation. In addition, Nash, Bernstein and Melnik <ref type="bibr" target="#b30">[30]</ref> have recently investigated the composition of schema mappings specified by (first-order) embedded implicational dependencies that need not be s-t tgds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Concluding Remarks</head><p>In this paper, we presented an overview of a body of work on data exchange and composition of schema mappings between relational schemas. This work was originally motivated by Clio, a schema mapping and data exchange system built at the IBM Almaden Research Center <ref type="bibr" target="#b29">[29,</ref><ref type="bibr" target="#b33">33]</ref>. Our initial goal was to provide a formal justification for certain engineering choices made in Clio; this led to the formulation of the concept of universal solutions and to the subsequent investigation of foundational and algorithmic issues in data exchange and metadata management. Some of the findings of this investigation influenced the development of Clio, which, in the meantime, has evolved from a prototype to an industrialstrength tool <ref type="bibr" target="#b19">[19]</ref>. In particular, SO tgds form the core of Clio's Mapping Specification Language; moreover, the composition algorithm for SO tgds has been incorporated in Clio.</p><p>It should be noted that Clio actually supports data exchange between XML and relational schemas, in all four combinations. Many conceptual and technical challenges arise in the study of the foundations of data exchange and metadata management for XML schemas. Arenas and Libkin <ref type="bibr" target="#b3">[3]</ref> have already addressed some of the challenges in data exchange between XML schemas.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :•</head><label>1</label><figDesc>Figure 1: The Data Exchange Problem</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Data Exchange with Source-to-Target Dependencies Σst and Target Dependencies Σt</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>13 Figure 3 :</head><label>133</label><figDesc>Figure 3: Composing Schema Mappings</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Definition 5 . 1 .</head><label>51</label><figDesc>Let M12 = (S1, S2, Σ12) and M23 = (S2, S3, Σ23) be two schema mappings such that the schemas S1, S2, S3 have no relation symbols in common. A schema mapping M13 = (S1, S3, Σ13) is a composition of M12 and M23 if for every instance I1 over S1 and every instance I3 over S3, the following are equivalent: 1. I1, I3 |= Σ13; 2. There is an instance I2 over S2 such that I1, I2 |= Σ12 and I2, I3 |= Σ23. In symbols, M13 = (S1, S3, Σ13) is a composition of M12 and M23 if and only if Inst(M13) = Inst(M12) • Inst(M23), where • denotes the set-theoretic composition of two binary relations. The preceding Definition 5.1 can be construed as the natural definition of the operational semantics of the composition operator on schema mappings. The following basic facts are immediate consequences of this definition. If both M = (S1, S3, Σ) and M = (S1, S3, Σ ) are compositions of M12 and M23, then the sets Σ and Σ are</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Theorem 5 . 2 .</head><label>52</label><figDesc>Let S1, S2, S3 be three schemas with no relation symbols in common, and let M12 = (S1, S2, Σ12) and M23 = (S2, S3, Σ23) be two schema mappings.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Example 5 . 3 .</head><label>53</label><figDesc>Consider the following three schemas S1, S2 and S3: schema S1 consists of a single unary relation symbol Emp of employees; schema S2 consists of one binary relation symbol Mgr associating each employee with a manager; schema S3 consists of a binary relation symbol Mgr and an additional unary relation symbol SelfMgr, intended to store employees who are their own managers. Consider now the schema mappings M12 = (S1, S2, Σ12) and M23 = (S2, S3, Σ23), where Σ12 = {Emp(e) → ∃mMgr (e, m)} Σ23 = {Mgr (e, m) → Mgr(e, m), Mgr (e, e) → SelfMgr(e)}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Consider the following three schemas S1, S2 and S3: schema S1 consists of a single binary relation symbol E; schema S2 consists of two binary relation symbols C and F ; schema S3 consists of one binary relation symbol D. Consider now the schema mappings M12 = (S1, S2, Σ12) and M23 = (S2, S3, Σ23), where Σ12</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Definition 5 . 4 .</head><label>54</label><figDesc>Let S and T be two schemas with no relation symbols in common. A second-order tuple-generating dependency (SO tgd) over S, T is a formula of the form ∃f1 ... ∃fm (∀x1(φ1 → ψ1)) ∧ ... ∧ (∀xn(φn → ψn)), where • Each fi is a function symbol. • Each φi is a conjunction of 1. atomic formulas R(y1, ..., y k ), where R is a k-ary relation symbol of the schema S and y1, . . .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Finally, the</head><label></label><figDesc>composition M12 • M23 of the schema mappings in Example 5.3 is definable by the SO tgd ∃f ( ∀e(Emp(e) → Mgr(e, f (e))) ∧ ∀e(Emp(e) ∧ (e = f (e)) → SelfMgr(e))).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>•</head><label></label><figDesc>If both Σ12 and Σ23 are finite sets of s-t full tgds, then Consequently, the composition query of M 12 and M23 is a polynomial-time query.• If both Σ12 and Σ23 are finite sets of s-t tgds, then the composition query of M12 and M23 is in NP.</figDesc><table /><note><p><p>the composition M12 • M23 is definable by a finite set of s-t full tgds. Consequently, the composition query of M12 and M23 is a polynomial-time query.</p>• If Σ12 is a finite set of s-t full tgds and Σ23 is a finite set of s-t tgds, then the composition M12 •M23 is definable by a finite set of s-t tgds.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>, y k are variables in x i , not necessarily distinct, and 2. equalities of the form t = t , where t and t are terms built from the function symbols fi and the variables xj. • Each ψi is a conjunction of atomic formulas S(t1, ..., t l ), where S is an l-ary relation symbol of the schema T and t1, . . . , t l are terms built from the function symbols fi and the variables xj. • Each variable in x i appears in a relational atomic formula of φi.It is easy to see that the conjunction of finitely many SO tgds is logically equivalent to a single SO tgd. Note also that SO tgds subsume s-t tgds. As a matter of fact, every s-t tgd σ is equivalent to an SO tgd without equalities obtained by Skolemizing σ. Specifically, if σ is a s-t tgd of the form</figDesc><table /><note><p>∀x1 . . . ∀xm(ϕ(x1, . . . , xm) → ∃y1 . . . ∃ynψ(x1, . . . , xm, y1, . . . , yn)), then σ is equivalent to the SO tgd ∃f1 . . . ∃fn(∀x1 . . . ∀xm(ϕ(x1, . . . , xm) → ψ(x1, . . . , xm, f1(x1, . . . , xm), . . . , fn(x1, . . . , xm))).</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>An atom is an expression R(t), where R is a relation symbol and t is a tuple of variables. A conjunctive query q(x) is a first-order formula of the form ∃wχ(x, w), where χ(x, w) is a conjunction of atoms.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>The work reported here is the result of a fruitful and enjoyable collaboration with my colleagues Ronald Fagin, Renée J. Miller, Lucian Popa, and Wang-Chiew Tan. I am grateful to Ronald Fagin for reading earlier versions of this paper and offering numerous valuable comments, corrections, and suggestions for improvement.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Complexity of Answering Queries Using Materialized Views</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">M</forename><surname>Duschka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Database Systems (PODS)</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="254" to="263" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Logic programming</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Apt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Van Leeuween</surname></persName>
		</editor>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">B</biblScope>
			<biblScope unit="page" from="493" to="474" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">XML data exchange: Consistency and query answering</title>
		<author>
			<persName><forename type="first">M</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Database Systems (PODS)</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A Proof Procedure for Data Dependencies</title>
		<author>
			<persName><forename type="first">C</forename><surname>Beeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Association for Computing Machinery (JACM)</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="718" to="741" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Formal Systems for Tuple and Equality Generating Dependencies</title>
		<author>
			<persName><forename type="first">C</forename><surname>Beeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. on Computing</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="76" to="98" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Applying Model Management to Classical Meta-Data Problems</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference on Innovative Data Systems Research (CIDR)</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="209" to="220" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Generic Model Management: A Database Infrastructure for Schema Manipulation</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Keynote Address, IDM 2003 Workshop</title>
		<meeting><address><addrLine>Seattle, Washington</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-09">September 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Optimal Implementation of Conjunctive Queries in Relational Data Bases</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Merlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Theory of Computing (STOC)</title>
		<imprint>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="77" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Further normalization of the data base relational model</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">F</forename><surname>Codd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Data Base Systems</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Rustin</surname></persName>
		</editor>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1972">1972</date>
			<biblScope unit="page" from="33" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Functional and Inclusion Dependencies: A Graph Theoretic Approach</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Cosmadakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Kanellakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Computing Research</title>
		<imprint>
			<publisher>JAI Press</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="163" to="184" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A Restricted Second Order Logic for Finite Structures</title>
		<author>
			<persName><forename type="first">A</forename><surname>Dawar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">143</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="154" to="174" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Horn Clauses and Database Dependencies</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Association for Computing Machinery (JACM)</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="952" to="985" />
			<date type="published" when="1982-10">Oct. 1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Data Exchange: Semantics and Query Answering</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Database Theory (ICDT)</title>
		<imprint>
			<date type="published" when="2003">2003. 2003</date>
			<biblScope unit="page" from="207" to="224" />
		</imprint>
	</monogr>
	<note>Full version to appear in a Special Issue of Theoretical Computer Science with selected papers from ICDT</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Data Exchange: Getting to the Core</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Database Systems (PODS)</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="90" to="101" />
		</imprint>
	</monogr>
	<note>TODS</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Composing Schema Mappings: Second-Order Dependencies to the Rescue</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-C</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Database Systems (PODS)</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="83" to="94" />
		</imprint>
	</monogr>
	<note>TODS</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The Computational Structure of Monotone Monadic SNP and Constraint Satisfaction: A Study through Datalog and Group Theory</title>
		<author>
			<persName><forename type="first">T</forename><surname>Feder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Preliminary version in Proc. 25th ACM Symp. on Theory of Computing</title>
		<imprint>
			<date type="published" when="1993">1998. May 1993</date>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="612" to="622" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Peer Data Exchange</title>
		<author>
			<persName><forename type="first">A</forename><surname>Fuxman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-C</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Database Systems (PODS)</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Computing Cores for Data Exchange: New Algorithms and Practical Solutions</title>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Database Systems (PODS)</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Clio grows up: from research prototype to industrial tool</title>
		<author>
			<persName><forename type="first">L</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Roth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGMOD International Conference on Management of Data (SIGMOD)</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The Core of a Graph</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Nešetřil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Mathematics</title>
		<imprint>
			<biblScope unit="volume">109</biblScope>
			<biblScope unit="page" from="117" to="126" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Graphs and Homomorphisms</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Nešetřil</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>Oxford University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Elements of Relational Database Theory</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Kanellakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Models and Sematics</title>
		<title level="s">Handbook of Theoretical Computer Science</title>
		<imprint>
			<publisher>Elsevier and MIT Press</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">B</biblScope>
			<biblScope unit="page" from="1073" to="1156" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Data Integration: A Theoretical Perspective</title>
		<author>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Database Systems (PODS)</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="233" to="246" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">A probabilistic approach to the dychotomy problem</title>
		<author>
			<persName><forename type="first">T</forename><surname>Luczak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Nešetřil</surname></persName>
		</author>
		<idno>640</idno>
		<imprint>
			<date type="published" when="2003">2003</date>
			<pubPlace>Prague</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Charles University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Composing Mappings Among Data Sources</title>
		<author>
			<persName><forename type="first">J</forename><surname>Madhavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Halevy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Very Large Data Bases (VLDB)</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="572" to="583" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Testing Implications of Data Dependencies</title>
		<author>
			<persName><forename type="first">D</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">O</forename><surname>Mendelzon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems (TODS)</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="455" to="469" />
			<date type="published" when="1979-12">Dec. 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Data exchange: on complexity of answering queries with inequalities</title>
		<author>
			<persName><forename type="first">A</forename><surname>Madry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>In press</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Generic Model Management: Concepts and Algorithms</title>
		<author>
			<persName><forename type="first">S</forename><surname>Melnik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">2967</biblScope>
			<date type="published" when="2004">2004</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Schema Mapping as Query Discovery</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hernández</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Very Large Data Bases (VLDB)</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="77" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Composition of mappings given by embedded dependencies</title>
		<author>
			<persName><forename type="first">A</forename><surname>Nash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Melnik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Database Systems (PODS)</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">The Complexity of Facets and Some Facets of Complexity</title>
		<author>
			<persName><forename type="first">C</forename><surname>Papadimitriou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Theory of Computing (STOC)</title>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="229" to="234" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Computational Complexity</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Papadimitriou</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Translating Web Data</title>
		<author>
			<persName><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Velegrakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Hernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Very Large Data Bases (VLDB)</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="598" to="609" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">EXPRESS: A Data EXtraction, Processing, amd REStructuring System</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">C</forename><surname>Shu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Housel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Ghosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">Y</forename><surname>Lum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems (TODS)</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="134" to="174" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Logical Approaches to Incomplete Information: A Survey</title>
		<author>
			<persName><forename type="first">R</forename><surname>Van Der Meyden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logics for Databases and Information Systems</title>
		<imprint>
			<publisher>Kluwer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="307" to="356" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">The complexity of relational query languages</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th ACM Symp. on Theory of Computing</title>
		<meeting>14th ACM Symp. on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="137" to="146" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
