<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Outsourced Symmetric Private Information Retrieval</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Stanislaw</forename><surname>Jarecki</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">U. California Irvine</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Hugo</forename><surname>Krawczyk</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">IBM Research</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Marcel</forename><surname>Rosu</surname></persName>
							<email>marcelrosu@gmail.com</email>
							<affiliation key="aff2">
								<orgName type="institution">U. California Irvine</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Michael</forename><surname>Steiner</surname></persName>
							<email>msteiner@us.ibm.com</email>
							<affiliation key="aff3">
								<orgName type="institution">IBM Research</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Outsourced Symmetric Private Information Retrieval</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">9CDFE6098E5B8695FC1CA7B3FEB7A184</idno>
					<idno type="DOI">10.1145/2508859.2516730</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In the setting of searchable symmetric encryption (SSE), a data owner D outsources a database (or document/file collection) to a remote server E in encrypted form such that D can later search the collection at E while hiding information about the database and queries from E . Leakage to E is to be confined to well-defined forms of data-access and query patterns while preventing disclosure of explicit data and query plaintext values. Recently, Cash et al. presented a protocol, OXT, which can run arbitrary boolean queries in the SSE setting and which is remarkably efficient even for very large databases.</p><p>In this paper we investigate a richer setting in which the data owner D outsources its data to a server E but D is now interested to allow clients (third parties) to search the database such that clients learn the information D authorizes them to learn but nothing else while E still does not learn about the data or queried values as in the basic SSE setting. Furthermore, motivated by a wide range of applications, we extend this model and requirements to a setting where, similarly to private information retrieval, the client's queried values need to be hidden also from the data owner D even though the latter still needs to authorize the query. Finally, we consider the scenario in which authorization can be enforced by the data owner D without D learning the policy, a setting that arises in court-issued search warrants.</p><p>We extend the OXT protocol of Cash et al. to support arbitrary boolean queries in all of the above models while withstanding adversarial non-colluding servers (D and E ) and arbitrarily malicious clients, and while preserving the remarkable performance of the protocol.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Consider a database DB composed of collection of documents or records and an application that needs to search DB based on the keywords contained in these records. For example, DB can be a medical relational database with records indexed by a set of attributes (e.g., name, zipcode, medical condition, etc.), an email repository indexed by English words and/or envelope information (date, sender, receivers, etc.), a collection of webpages indexed by text and metadata, etc. A search query consists of a boolean expression on keywords that returns all documents whose associated keywords satisfy that expression. In this paper we are concerned with applications where the database is outsourced to an external server E and search is performed at E privately. That is, E stores an encrypted version of the original database DB (plus some metadata) and answers encrypted queries from clients such that the client obtains the documents matching his query without E learning plaintext information about the data and queries.</p><p>The most basic setting of private data outsourcing as described above is where the owner of the data itself, D, is the party performing the search at E . In this setting, D initially processes DB into an encrypted database EDB and sends it to E . D only keeps a set of cryptographic keys that allows her to later run encrypted searches on E and decrypt the matching documents returned by E . This setting is known as searchable symmetric encryption (SSE) and has been studied extensively <ref type="bibr" target="#b29">[29,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b16">16,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b24">24]</ref>. While most of the research has focused on single-keyword searches (i.e., return all documents containing a given keyword), recently Cash et al. <ref type="bibr" target="#b9">[9]</ref> provided the first SSE solution, the OXT protocol, that can support in a practical and private way arbitrary boolean queries on sets of keywords and in very large DBs. The leakage to E , which is formally specified and proven in <ref type="bibr" target="#b9">[9]</ref>, is in the form of data-access and query patterns, never as direct exposure of plaintext data or searched values.</p><p>In this work we are concerned with richer outsourcing scenarios where multiple third parties (clients) access the data at E but only through queries authorized by the data owner D. For example, consider a hospital outsourcing an (encrypted) database to an external service E such that clients (doctors, administrators, insurance companies, etc.) can search the database but only via queries authorized according to the hospital's policy and without these clients learning information on non-matching documents. As before, E should learn as little as possible about data and queries.</p><p>In this multi-client scenario (to which we refer as MC-SSE), D provides search tokens to clients based on their queries and according to a given authorization policy. Security considers multiple clients acting maliciously and possibly colluding with each other (trying to gain information beyond what they are authorized for) and a semi-trusted server E which acts as "honest-but-curious" but does not collude with clients. Extending SSE solutions to the multiclient scenario is straightforward when (a) search tokens are fully determined by the query and (b) the SSE protocol does not return false positives (returning false positives, i.e. documents that do not match a query, is allowed in SSE since the recipient in that case is the owner of the data but not in the multi-client setting where clients are not allowed to learn data they were not authorized for). In such cases, D would receive the client's query, generate the corresponding SSE search tokens as if D herself was searching the database, and provide the tokens to the client together with a signature that E can check before processing the search. However, for enabling general boolean queries, the SSE OXT protocol of <ref type="bibr" target="#b9">[9]</ref> requires a number of tokens that is not known a-priori (it depends on the searched data, not only on the query) and therefore the above immediate adaptation does not work.</p><p>Our first contribution is in extending the OXT protocol from <ref type="bibr" target="#b9">[9]</ref> to the MC-SSE setting while preserving its full boolean-query capabilities and performance. In this extension, D provides the client C with a set of query-specific trapdoors which the client can then transform into search tokens as required by OXT. The set of trapdoors given to C is fully determined by the query and independent of the searched data. An additional subtle technical challenge posed by OXT is how to allow E to verify that the search tokens presented by C are authorized by D. The simple solution is for D to sign the trapdoors, however in OXT these trapdoors need to be hidden from E (otherwise E can learn information about unauthorized searches) so a simple signature on them cannot be verified by E . Our solution uses a homomorphic signature by D on the trapdoors that C can then transform homomorphically into signatures on the search tokens. We show that forging the tokens or their signatures is infeasible even by fully malicious clients.</p><p>The resulting MC-OXT protocol preserves the full functional properties of OXT, namely support for arbitrary boolean queries, the same level of privacy (i.e., same leakage profile) with respect to E , and the same remarkable performance. Privacy with respect to clients is near-optimal (see Section 3.1 for why such leakage may be inevitable) with leakage confined only to information on the number of documents matching one of the query terms (typically, the leastfrequent term).</p><p>Next, we extend the MC-OXT protocol to an even more challenging setting we call Outsourced Symmetric Private Information Retrieval (OSPIR), where on top of the MC-SSE requirements, one asks that client queries be hidden from D -similarly to the Private Information Retrieval (PIR) primitive. This requirement arises in important outsourcing scenarios. In the medical database example mentioned above, the hospital authorizes doctors or other parties to search the medical database according to certain policy; however, in some cases the actual query values are to be kept secret from the hospital itself (due to privacy, liability and regulatory requirements). Only the minimal information for determining the compliance of a query to the policy should be disclosed to the hospital. For example, the policy may indicate that only conjunctions with a minimal number of terms are allowed or that the query needs to include at least three of a set of attributes, etc. In such a case, there is no need for the hospital to learn the particular values being searched (such as a specific last name or medical condition). In other cases, as in outsourced patent or financial information search, the provider D may want to enforce that a client C pays for the type of query it is interested in but C wants to keep his query hidden from both D and E . Applications to intelligence scenarios are discussed in <ref type="bibr" target="#b18">[18]</ref> (see also <ref type="bibr" target="#b32">[32]</ref>).</p><p>Thus, we relax the query privacy requirement with respect to D to allow for minimal information needed for D to determine policy compliance. Specifically, we consider the case where keywords are formed by pairs of attribute-values. For example, in a relational database, attributes are defined by the database columns (e.g., SSN, name, citizenship, etc.), while in an email repository attributes can refer to envelope information such as sender and receivers or to the message body (in which case the values are, say, English words). In this case, a policy defines the class of boolean expressions allowed for a given client and the attributes that may be used as inputs into these expressions. In order to enforce the policy, D learns the boolean expression and attributes but nothing about the searched values. For policies defined via classes of attributes (e.g. allowing any attribute from the set of attributes {name, city, zipcode}) leakage to D can be further reduced by revealing the class and not the specific attributes in the query.</p><p>Our most advanced result is extending the OXT protocol to the above OSPIR setting. The resultant protocol, OSPIR-OXT, adds some crucial new ingredients to OXT: It uses oblivious PRFs (OPRF) for hiding the query values from D, uses attribute-specific keys for enforcing policy compliance, and uses homomorphic signatures (or the more general abstraction of shared OPRFs) for query verification by E . A further extension of the protocol accommodates an external policy manager, e.g., a judge in a warrant-based search, who checks policy compliance and allows server D to enforce the policy without learning the attributes being searched.</p><p>Performance-wise our extensions to OXT preserve the protocol's performance in both pre-processing (creating EDB) and search phases. OSPIR-OXT adds to the computational cost by adding a few exponentiations but these are generally inexpensive relative to the I/O cost (especially thanks to common-base exponentiation optimizations). The protocols we provide for MC-SSE and OSPIR models support encrypted search over database containing tens of billions record-keyword pairs, for example a full snapshot of English Wikipedia or a 10-TByte, 100M-record US-census database (see <ref type="bibr">Sections 4.3 and 4.4)</ref>.</p><p>We achieve provable security against adaptive adversarial honest-but-curious server E , against arbitrarily malicious (but non-colluding<ref type="foot" target="#foot_0">1</ref> with E ) server D, and against arbitrarily malicious clients. Our security models extend the SSE model <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b9">9]</ref> to the more complex settings of MC-SSE and OSPIR. In all cases security is defined in the real-vsideal model and is parametrized by a specified leakage function L(DB, q). A protocol is said to be secure with leakage profile L(DB, q) against adversary A if the actions of A on adversarially-chosen input DB and queries set q can be simulated with access to the leakage information L(DB, q) only (and not to DB or q). This allows modeling and bounding partial leakage allowed by SSE protocols. It means that even an adversary that has full information about a database, or even chooses it, does not learn anything from the protocol execution other than what can be derived solely from the defined leakage profile.</p><p>Related work: Searchable symmetric encryption (SSE) has been extensively studied <ref type="bibr" target="#b29">[29,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b16">16,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b24">24]</ref> (see <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b11">11]</ref> for more on related work). Most SSE research focused on single-keyword search, and after several solutions with complexity linear in the database size, Curtmola et al. <ref type="bibr" target="#b13">[13]</ref> present the first solution for single-keyword search whose complexity is linear in the number of matching documents. They also improve on previous security models, in particular by providing an adaptive security definition and a solution in this model.</p><p>Extending single-keyword SSE to search by conjunctions of keywords was considered in <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b2">2]</ref>, but all these schemes had O(|DB|) search complexity. The first SSE which can handle very large DBs and supports conjunctive queries is the OXT protocol discussed above, given by Cash et al. <ref type="bibr" target="#b9">[9]</ref>. The MC-SSE and OSPIR schemes we present are based on this protocol and they preserve its performance and privacy characteristics.</p><p>Extension of the two-party client-server model of SSE to the multi-client setting was considered by Curtmola et al, <ref type="bibr" target="#b13">[13]</ref>, but their model disallowed per-query interaction between the data owner and the client, leading to a relatively inefficient implementation based on broadcast encryption. Multi-client SSE setting which allows such interaction was considered by Chase and Kamara <ref type="bibr" target="#b11">[11]</ref> as SSE with "controlled disclosure", and by Kamara and Lauter <ref type="bibr" target="#b23">[23]</ref>, as "virtual private storage", but both considered only singlekeyword queries and did not support query privacy from the data owner. De Cristofaro et al. <ref type="bibr" target="#b12">[12]</ref> extended multi-client SSE to the OSPIR setting, which supports query privacy, but only for the case of single-keyword queries. In recent independent work, Pappas et al. <ref type="bibr" target="#b27">[27]</ref> provide support for boolean queries in a setting similar to our OSPIR setting (but with honest-but-curious clients).</p><p>SSE schemes which support efficient updates of the encrypted database appeared in <ref type="bibr" target="#b30">[30,</ref><ref type="bibr" target="#b24">24]</ref> for single-keyword SSE. The OXT SSE scheme of <ref type="bibr" target="#b9">[9]</ref> which supports arbitrary boolean queries, has been extended to the dynamic case in <ref type="bibr" target="#b8">[8]</ref>, and the same techniques apply to the MC-SSE and OS-PIR schemes presented in this paper.</p><p>Recently Islam et al. <ref type="bibr" target="#b19">[19]</ref> showed that frequency analysis revealed by access control patterns in SSE schemes can be used to predict single-keyword queries. Such attacks, although harder to stage, are possible for conjunctive queries as well, but the general masking and padding countermeasures suggested in <ref type="bibr" target="#b19">[19]</ref> are applicable to the MC-OXT and OSPIR-OXT protocols.</p><p>In other directions, SSE was extended to the public key setting, allowing any party to encrypt into the database, first for single-keyword search <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b31">31,</ref><ref type="bibr" target="#b1">1,</ref><ref type="bibr" target="#b3">3,</ref><ref type="bibr">6,</ref><ref type="bibr" target="#b28">28]</ref>, and later for conjunctive queries as well <ref type="bibr">[6]</ref>, but all these PKSE schemes have O(|DB|) search complexity. Universally composable SSE was introduced by <ref type="bibr" target="#b25">[25]</ref>, also with O(|DB|) search complexity.</p><p>Multi-client SSE and OSPIR models are related to the work on multi-client ORAM, e.g. see the recent work of Huang and Goldberg <ref type="bibr" target="#b17">[17]</ref>, which aims for stronger privacy protection of client's queries from server E , but multi-client ORAM supports DB lookups by (single) indexes instead of (boolean formulas on) keywords, and they can currently support much smaller DB sizes.</p><p>Paper organization. We first present our protocols for the case of conjunctive queries: in Section 2 we recall the basic OXT protocol <ref type="bibr" target="#b9">[9]</ref>, suitably reformulated for our generalizations, in Section 3 we address the multi-client SSE model, and in Section 4 we handle the OSPIR model. In Section 4.2 we explain how to extend support for general boolean queries. Our security models and claims are presented concisely in Section 5 -a complete treatment is deferred to the full version <ref type="bibr" target="#b20">[20]</ref>. While the main implementation details and performance analysis is deferred to a companion paper <ref type="bibr" target="#b8">[8]</ref>, we provide some information on computational cost and performance measurements from our implementation in Section 4.3 and 4.4, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">SSE AND THE OXT PROTOCOL</head><p>We first recall the SSE OXT protocol from <ref type="bibr" target="#b9">[9]</ref> that forms the basis for our solution to searchable encryption in the more advanced MC and OSPIR models. SSE protocols and formal setting <ref type="bibr" target="#b9">[9]</ref>. Let λ be a security parameter. A database DB = (indi, Wi) d i=1 is a list of identifier and keyword-set pairs, where indi ∈ {0, 1} λ is a document identifier and Wi ⊆ {0, 1} * is a list of keywords in that document. We set W to d i=1 Wi. A query ψ( w) is specified by a tuple of keywords w ∈ W * and a boolean formula ψ on w. We write DB(ψ( w)) for the set of identifiers of documents that "satisfy" ψ( w). Formally, this means that indi ∈ DB(ψ( w)) iff the formula ψ( w) evaluates to true when we replace each keyword wj with true or false depending on if wj ∈ Wi or not (in particular DB(w) = {indi s.t. w ∈ Wi}). Below we let d denote the number of records in DB, m = |W|, and N = w∈W |DB(w)|.</p><p>A searchable symmetric encryption (SSE) scheme Π consists of an algorithm EDBSetup and a protocol Search fitting the following syntax. EDBSetup takes as input a database DB and a list of document decryption keys RDK, and outputs a secret key K along with an encrypted database EDB. The search protocol proceeds between a client C and server E , where C takes as input the secret key K and a query ψ( w) and E takes as input EDB. At the end of the protocol C outputs a set of (ind, rdk) pairs while E has no output. We say that an SSE scheme is correct if for all DB, RDK and all queries ψ( w), for (K, EDB) ← EDBSetup(DB, RDK), after running Search with client input (K, φ( w)) and server input EDB, the client outputs DB(φ( w)) and RDK[DB(φ( w))] where RDK[S] denotes {RDK[ind] | ind ∈ S}. Correctness can be statistical (allowing a negligible probability of error) or computational (ensured only against computationally bounded attackers -see <ref type="bibr" target="#b9">[9]</ref>).</p><p>Note (conjunctive vs. Boolean queries). Throughout the paper we present our protocols for the case of conjunctive queries where a query consists of n keywords w = (w1, . . . , wn) and it returns all documents containing all these keywords. The adaptation to the case of boolean queries is described in Section 4.2.</p><p>to encrypt that document. When a client retrieves the index ind of a document matching its query, it also retrieves the record-decrypting key rdk needed to decrypt that record. This mechanism is not strictly needed in the SSE setting (where rdk could be derived from ind using a PRF with a secret key known to C) and it is not part of the original OXT in <ref type="bibr" target="#b9">[9]</ref>, but it is needed in the more advanced models considered later. This extension does not change the functionality and security properties of OXT as analyzed in <ref type="bibr" target="#b9">[9]</ref>).</p><p>Note (retrieval of matching encrypted records). Our formalism defines the output of the SSE protocol as the set of ind identifiers pointing to the encrypted records matching the query, together with the associated record decryption key. For the sake of generality, we do not model the processing and retrieval of encrypted records. This allows us to decouple the storage and processing of document payloads (which can be done in a variety of ways, with varying types of leakage) from the storage and processing of the metadata, which is the focus of our protocols. SSE Security. The SSE setting considers security w.r.t. an adversarial server E , hence security is parametrized via a leakage function capturing information learned by E from the interaction with C. See Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The OXT Protocol</head><p>The OXT protocol <ref type="bibr" target="#b9">[9]</ref> is presented in Figure <ref type="figure" target="#fig_0">1</ref>; see <ref type="bibr" target="#b9">[9]</ref> for full design rationale and analysis. Here we provide a high level description as needed for the extensions to this protocol we introduce in the following sections.</p><p>The basis of OXT is the following simple search algorithm over unencrypted databases. The algorithm uses two types of data structures. First, for every keyword w there is an inverted index (a list) Iw pointing to the indices ind of all documents that contain w. Then, for every document ind there is a list L ind of all keywords contained in document ind. To search for a conjunction w = (w1, . . . , wn), the client chooses the estimated least frequent keyword<ref type="foot" target="#foot_2">2</ref> in w, say w1, and checks for each ind ∈ Iw 1 whether wi ∈ L ind , i = 2, . . . , n. If this holds for all 2 ≤ i ≤ n then ind is added to the result set. As a performance optimization, instead of maintaining a list L ind for each ind, one can fix a hash function f and keep a data structure representing the set X = {f (w, ind) : w ∈ W, ind ∈ DB(w)}. Thus, the check w ∈ L ind can be replaced with the check f (w, ind) ∈ X. Protocol OXT adapts this algorithm to the encrypted setting as follows (we start with the description of a simplified version, corresponding to protocol BXT in <ref type="bibr" target="#b9">[9]</ref>, and then move to the more specific details of OXT).</p><p>For each keyword w ∈ W an inverted index (corresponding to Iw above), referred to as TSet(w), is built pointing to all the ind values of documents in DB(w). Each TSet(w) is identified by a string called stag(w) and ind values in TSet(w) are encrypted under a secret key Ke. Both stag(w) and Ke are computed as a PRF applied to w with secret keys known to C only. In addition, a data structure called XSet is built as an "encrypted equivalent" of the above set X as follows. First, for each w ∈ W, a value xtrap(w) = F (KX , w) is computed where KX is a secret PRF key then for each ind ∈ DB(w) a value xtag = f (xtrap(w), ind) is added to XSet where f is an unpredictable function of its inputs (e.g., f can be a PRF used with xtrap(w) as the key and ind as input). The output EDB from the EDBSetup phase includes TSet = {TSet(w)} w∈W and the set XSet. In the Search protocol for a conjunction (w1, . . . , wn), the client C chooses the conjunction's s-term (i.e., the estimated least frequent keyword in the conjunction, which we assume to be w1), computes stag(w1) and Ke using C's secret keys and computes xtrap i = F (KX , wi) for each i = 2, . . . , n. It then sends (Ke, stag, xtrap 2 , . . . , xtrap n ) to the server E . E uses stag to retrieve TSet(w1), uses Ke to decrypt the ind values in TSet(w1), and sends back to C those ind for which f (xtrap i , ind) ∈ XSet for all i = 2, . . . , n.</p><p>The OXT protocol from Figure <ref type="figure" target="#fig_0">1</ref> follows the above logic but instantiates it in a way that minimizes leakage to E . Rather than assuming a specific implementation of TSet, <ref type="bibr" target="#b9">[9]</ref> abstracts this data structure through an API that we adopt here. Specifically, the abstract TSetSetup operation receives a collection T of lists t(w) for each w ∈ W and builds the TSet data structure out of these lists; it returns TSet and a key KT . Then, TSetRetrieve(TSet, stag(w)) instantiates the retrieval of a TSet(w) via its handle stag(w) which is computed by a function TSetGetTag(KT , w) (typically a PRF). The elements in the t(w) lists are called tuples and their contents are defined by the OXT protocol. A TSet implementation provides two crucial security properties <ref type="bibr" target="#b9">[9]</ref>: privacy in that the TSet datastructure does not reveal anything about the tuple lits in T except their summary length w |T[w]|; and correctness in that (except for negligible probability) TSetRetrieve(TSet, stag) returns T[w] for stag = TSetGetTag(KT , w), and it returns an empty set for all other stag values.</p><p>Next, we note that using the protocol described above leads to significant leakage in that the xtrap value allows E to check whether xtag = f (xtrap, ind) ∈ XSet for each value ind ever seen by E , revealing correlation statistics between each s-term and each x-term ever queried by C. This motivates the main mechanism in OXT, i.e. the instantiation of the function f via a two-party computation in which E inputs an encrypted value ind, C inputs xtrap and the ind-decryption key, and E gets the value of xtag = f (xtrap, ind) without learning either the xtrap or ind values themselves. For this OXT uses a blinded DH computation over a group G (with generator g of prime order p). However, to avoid the need for interaction between E and C in the Search phase, the blinding factors are pre-computed and stored as part of the tuples in the TSet lists. Specifically, indexes ind are replaced in the computation of f with dedicated per-record values xind ∈ Z * p (computed as Fp(KI , ind) where Fp is a PRF with range Z * p ), xtrap(w)'s are implemented as g Fp(K X ,w) (KI and KX are secret keys kept by C), and xtag is re-defined as (xtrap(w)) xind . The blinding factor in the underlying twoparty computation is pre-computed during EDBSetup and stored in the TSet. Namely, each tuple corresponding to a keyword w and document index ind contains a blinded value yc = xind • z -1 c for xind = Fp(FI , ind) where zc is an element in Z * p derived (via a PRF) from w and a tuple counter c (this counter, incremented for each tuple in the tuple list associated with w, ensures independence of each blinding value zc).</p><p>During search, the server E needs to compute the xtag values g Fp(K X ,w i )•xind for each xind in TSet(w1) and then test these for membership in XSet. To enable this the client sends, for the c-th tuple in t, an n-long array xtoken[c] de-EDBSetup(DB, RDK) Key Generation. D picks key K S for PRF Fτ and keys K T , K X , K I for PRF Fp. Fτ and Fp are PRF's which output strings in respectively {0, 1} τ and Z * p , and τ is a security parameter. • Initialize XSet to an empty set, and initialize T to an empty array indexed by keywords from W.</p><p>• For each w ∈ W, build the tuple list t and insert elements into set XSet as follows:</p><p>-Initialize t to be an empty list.</p><p>-Set strap ← Fτ (K S , w) and (Kz, Ke) ← (Fτ (strap, 1), Fτ (strap, 2)).</p><p>-Initialize c ← 0; then for all ind in DB(w) in random order:</p><formula xml:id="formula_0">* Set rdk ← RDK(ind), e ← Enc(Ke, (ind|rdk)), xind ← Fp(K I , ind). * Set c ← c + 1, zc ← Fp(Kz, c), y ← xind • z -1 c .</formula><p>Append (e, y) to t. * Set xtag ← g Fp(K X ,w)•xind and add xtag to XSet.</p><p>-T[w] ← t.</p><p>• Create (TSet, K T ) ← TSetSetup(T), and output key K = (K S , K X , K T , K I ) and EDB = (TSet, XSet).</p><p>Search protocol Client C on input K defined as above and a conjunctive query w = (w 1 , . . . , wn):</p><p>• Sets stag ← TSetGetTag(K T , w 1 ); strap ← Fτ (K S , w 1 ), (Kz, Ke) ← (Fτ (strap, 1), Fτ (strap, 2)).</p><p>• Sends to the server E the message (stag, xtoken <ref type="bibr" target="#b1">[1]</ref>, xtoken <ref type="bibr" target="#b2">[2]</ref>, . . .) where xtoken[•] are defined as:</p><formula xml:id="formula_1">-For c = 1, 2, . . ., until E sends stop: * Set zc ← Fp(Kz, c) and set xtoken[c, i] ← g Fp(K X ,w i )•zc for i = 2, . . . , n. * Set xtoken[c] ← (xtoken[c, 2], . . . , xtoken[c, n]).</formula><p>Server E on input EDB = (TSet, XSet) responds as follows:</p><p>• Retrieve t ← TSetRetrieve(TSet, stag) from TSet.</p><p>• For c = 1, . . . , |t| do:</p><p>-Retrieve (e, y) from the c-th tuple in t</p><formula xml:id="formula_2">-If ∀i = 2, . . . , n : xtoken[c, i] y ∈ XSet then send e to client C.</formula><p>• When last tuple in t is reached, sends stop to C and halt.</p><p>For each received e client C computes (ind|rdk) ← Dec(Ke, e) and outputs (ind, rdk). </p><formula xml:id="formula_3">[c, i] yc ∈ XSet for all i = 2, . . . , n. This protocol is correct because xtoken[c, i] yc = g Fp(K X ,w i )•zc•xind•z -1 c = g Fp(K X ,w i )•xind</formula><p>, meaning that the server correctly recomputes the pseudorandom values in the XSet. Putting these ideas together results in the OXT protocol of Figure <ref type="figure" target="#fig_0">1</ref>. Note that C sends the xtoken arrays (each holding several values of the form g Fp(K X ,w i )•zc ) until instructed to stop by E . There is no other communication from server to client (alternatively, server can send the number of elements in TSet(w) to the client who will respond with such number of xtoken arrays). Note. The OXT protocol in Figure <ref type="figure" target="#fig_0">1</ref> derives keys Ke, Kz slightly differently than in the OXT description of <ref type="bibr" target="#b9">[9]</ref>. The modified key derivation is closer to what we need for MC-OXT and OSPIR-OXT protocols presented in the following sections, without affecting the functionality or security of OXT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">MULTI-CLIENT SSE</head><p>We present an extension of the OXT protocol for the multiclient SSE (MC-SSE) setting described in the introduction and in more detail below. The extension preserves the functionality of OXT, supporting any boolean query, and superb performance, while securely serving multiple clients, all of which can behave maliciously.</p><p>Multi-Client SSE Setting. In MC-SSE there is the owner D of the plaintext database DB, an external server E that holds the encrypted database EDB, and clients that receive tokens from D in order to perform search queries at E . In other words, D is outsourcing her search service to a third party but requires clients to first obtain search tokens from her. Her goal is to ensure service to clients via E while leaking as little as possible information to E about the plaintext data and queries, and preventing clients from running any other DB queries than those for which D issued them a token. This is a natural outsourcing setting of increasing value in cloud-based platforms, and it was described by Chase and Kamara <ref type="bibr" target="#b11">[11]</ref> as an SSE with controlled disclosure.</p><p>Formally, the MC-SSE setting changes the syntax of an SSE scheme by including an additional algorithm GenToken which on input the secret key K, generated by the data owner D in the EDBSetup procedure, and a boolean query ψ( w), submitted by client C, generates a search-enabling value token. Then, procedure Search is executed by server E on input EDB, but instead of the client C running on input K and query ψ( w) (as in SSE), C runs on input consisting only of the search token token. Correctness is defined similarly to the SSE case, namely, assuring (except for negligible error probability) that C's output sets DB(ψ( w)) and RDK[DB(ψ( w))]. Security is treated in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The MC-OXT Protocol</head><p>We describe the changes to OXT from Figure <ref type="figure" target="#fig_0">1</ref> needed to support boolean queries in the MC-SSE setting. As before, the protocol is described for conjunctions with the adaptation to boolean queries described in Section 4.2.</p><p>EDBSetup(DB, RDK). This pre-processing phase is identical to the one in OXT except for the addition of a key KM shared between D and E . The output from this phase is K = (KS, KX , KT , KM ) kept by D and EDB = (KM , TSet, XSet) stored at E . GenToken(K, w). This is the new MC-specific phase in which D, using key K, authorizes C for a conjunction w = w1, . . . , wn and provides C with the necessary tokens to enable the search at E . We assume w1 to be the s-term (and chosen by D who has knowledge of term frequencies). Specifically, D performs the following operations. She sets stag ← TSetGetTag(KT , w1) and strap ← Fτ (KS, w1), same as C does in OXT. Then, for i = 2, ..., n, she picks ρi ← Z * p and sets bxtrap i ← g Fp(K X ,w i )•ρ i . Finally, she sets env ← AuthEnc(KM , (stag, ρ2, ..., ρn)) and outputs token = (env, strap, bxtrap 2 , . . . , bxtrap n ) (which C uses in the search phase).</p><p>To see how this enables search as in OXT, first note that with xtrap i = g Fp(K X ,w i ) , i = 2, . . . , n, the client can produce the values g Fp(K X ,w i )•zc needed in the Search phase of OXT. Hence, D could just provide the xtrap i values to C. However, D needs to be able to sign (or MAC) these values so that E can check that C is authorized to this query and, e.g., did not truncate a conjunction or mix parts from different queries. Signing the plain xtrap values does not work since these values must not be seen by E (it would allow E to learn information from unauthorized searches). The solution is to provide C with a homomorphic signature that C can convert into individual signatures for all tokens sent to E . This is accomplished as follows: D picks one-time blinding factors ρ2, . . . , ρn and provides C with blinded (or MAC'ed) xtrap values bxtrap i = xtrap ρ i i for j = 2, . . . , n, while providing the blinding factors (ρ2, . . . , ρn) to E in an encrypted and authenticated envelope env. To produce g Fp(K X ,w i )•zc during Search, C will compute bxtrap zc i and E will raise this value to 1/ρi. Security relies on the fact that if C provides E with values other than those given by D, then when raised to 1/ρi by E (where ρi is random and unknown to C) the resulting values will not correspond to elements of XSet except with negligible probability.</p><p>Search Protocol. The Search protocol reflects the above changes: On token = (env, strap, bxtrap 2 , ..., bxtrap n ), C computes (Kz, Ke) from strap as in OXT. Then, it sends to E the value env as well as the sequence bxtoken <ref type="bibr" target="#b1">[1]</ref>, bxtoken <ref type="bibr" target="#b2">[2]</ref>, . . . which contains the same values as xtoken <ref type="bibr" target="#b1">[1]</ref>, xtoken <ref type="bibr" target="#b2">[2]</ref>, . . . in OXT up to the blinding exponents ρi. Specifically, the values bxtoken[c, i],</p><p>for i = 2, . . . , n, are computed by C as (bxtrap i ) zc . On the receiving side, E verifies the authenticity of env and decrypts it to find stag, which it uses to retrieve TSet(w1), and ρ2, . . . , ρn. The only change from OXT is that the operation xtoken[c, i] y is replaced with bxtoken[c, i] y/ρ i . Note (masking the size of TSet(w1)). MC-OXT leaks to C the size of TSet(w1) = DB(w1) given by the number of bxtoken vectors requested by E . Note that the exact size of this set can easily be masked by E requesting more bxtoken values from C than needed. We observe that some form of leakage on the frequency of the least frequent term in the conjunction appears to be inherent even for plaintext search algorithms. Indeed, it is likely (though there seem to be no proven lower bounds) that running time will be noticeably different for conjunctions with all terms being infrequent from the case that all terms are very frequent, except if short searches are artificially padded to full database size (or if conjunctions are pre-computed). Two considerations in masking the size of TSet(w1) are that (i) the masked size should be chosen as a step function of |TSet(w1)| (and not, say, a fixed linear function); (ii) During search, E should return to C all results matching a query only after E received all the bxtoken vectors from C; indeed, sending the results as soon as they are found to match the query would leak information on |TSet(w)| to C (since no ind's will be returned after C sends |TSet(w)| tokens). In the full version <ref type="bibr" target="#b20">[20]</ref> we show a strategy applied by D during EDBSetup to allow E to send results as soon as they are found while avoiding the above leakage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">OUTSOURCED SYMMETRIC PIR</head><p>The OSPIR (for Outsourced Symmetric PIR) setting augments the MC-SSE setting with an additional requirement: The database owner D should learn as little as possible about queries performed by clients while still being able to verify the compliance of these queries to her policy. Here we extend MC-OXT to this setting by augmenting the token generation component GenToken to support "blinding" by the client of query requests sent to D, and adding a mechanism for D to enforce policy-compliance of the query when only having access to their blinded versions. OSPIR-OXT supports attribute-based policies where D learns information about query attributes but nothing about values (e.g., D may learn that a query includes a last-name, a zipcode and two words from a text field but nothing about the actual queried keywords). The security model adds D as a new adversarial entity trying to learn C's hidden query values. Refer to the introduction for more discussion about the OSPIR setting and attribute-based policies. OSPIR SSE Syntax. An OSPIR-SSE scheme replaces the GenToken procedure which in MC-SSE is executed by the data owner D on the cleartext client's query w, with a two-party protocol between C and D that allows C to compute a search-enabling token without D learning w. In addition, D should be able to enforce an attribute-based queryauthorization policy on these queries. For this, we assume that keyword set W is partitioned into m attributes, and let I(w) denote the attribute of keyword w. <ref type="foot" target="#foot_3">3</ref> An attributebased policy is represented by a set of attribute-sequences P s.t. a conjunctive query w = (w1, ..., wn) is allowed by policy P if and only if the sequence of attributes av( w) = (I(w1), ..., I(wn)) corresponding to this query is an element in set P. Using this notation, the goal of the GenToken protocol is to let C compute token corresponding to its query w only if av( w) ∈ P. Reflecting these goals, an OSPIR-SSE scheme is a tuple Σ = (EDBSetup, GenToken, Search) where EDBSetup is an algorithm run by D on inputs (DB, RDK) with outputs (EDB, K), GenToken is a protocol run by C on input w and by D on input (P, K), with C outputting token or ⊥ and D outputting av, and Search is a protocol run by C on input token and by E on input EDB, with C outputting a set of ind's matching his query and the corresponding set of rdk's.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The OSPIR-OXT Protocol</head><p>The OSPIR-OXT protocol addresses the above OSPIR setting by enhancing MC-OXT with query-hiding techniques that allow D to authorize queries without learning the queried values. Most changes with respect to MC-OXT are in the GenToken protocol. EDBSetup remains mostly unchanged except for the implementation of the PRFs, and Search is essentially unmodified.</p><p>We introduce the two main tools used in the design of GenToken. First, instead of the use of regular PRFs for stag and xtag computations in OXT and MC-OXT, the OSPIR-OXT protocol uses an an "oblivious PRF" (OPRF) computation between C and D. A PRF F (K, w) is called oblivious <ref type="bibr" target="#b26">[26]</ref> if there is a two-party protocol in which C inputs w, D inputs K, C learns the value of F (K, w) and D learns nothing. A simple example is the Hashed DH OPRF which we use in our implementation of the OSPIR-OXT protocol, defined as F (K, x) = H(x) K where H is a hash function onto G \ {1} where G is a group of prime order p, and K is chosen at random in Z * p . In this case, the OPRF protocol consists of C sending a = H(x) r for random r in Z * p , D sending back b = a K and C computing H(x) K as b 1/r . The second tool used in GenToken is needed to enforce an attribute-based policy and guarantee that only queries on authorized attributes can generate valid tokens for search at E . To enforce such policies we have D use a different key for each possible attribute; for example, when a stag (or xtag) is requested for attribute 'zipcode' the key that D inputs into the OPRF computation is different than the key used for attribute 'name' or attribute 'text'. The point is that if C claims to be querying zipcode but actually enters the keyword "Michael" into the OPRF computation, the output for C will be the tag F (Kzip, "Michael"), where Kzip is a zipcode-specific key, which will match no tag stored at E .</p><p>To obtain OSPIR-OXT we combine the above two tools with an authorization mechanism similar to the one used in MC-OXT via a homomorphic signature (using the ρi exponents) for binding together the n tokens corresponding to an n-term conjunctive query in a way that E can verify. We describe the changes to MC-OXT (defined via Figure <ref type="figure" target="#fig_0">1</ref> and the modifications in Section 3) required by OSPIR-OXT. We first replace the PRF Fp used in computing xtrap and xtag values with a PRF FG which maps w directly onto the group G generated by g, i.e. we set xtrap as FG(KX , w) instead of g Fp(K X ,w) , hence xtag = (xtrap) xind will now be computed as FG(KX , w) xind instead of g Fp(K X ,w)•xind . We similarly replace the PRF Fτ used in computing the strap value with the PRF FG, i.e. we set strap as FG(KS, w) instead of Fτ (KS, w).</p><p>(Since we use strap as a key to Fτ in deriving (Kz, Ke), we assume that a PRF Fτ key can be extracted from a random group element.)</p><p>We also make a specific assumption on the implementation of the function TSetGetTag used to derive stag(w) value, i.e., the handle pointing to the set TSet(w) which is computed as TSetGetTag(KT , w). First, we assume that TSetGetTag is implemented using PRF FG. Second, to enable enforcement of attribute-based policies we assume that the key KT in TSetGetTag is formed by an array of FG keys KT = (KT <ref type="bibr" target="#b1">[1]</ref>, ..., KT [m]), where <ref type="bibr">KT [i]</ref> is the key to be used only for keywords with attribute I(w) = i. For notational convenience we define a PRF F m G s.t. F m G (KT , w) = FG(KT [I(w)], w), and we set stag(w) = TSetGetTag(KT , w) to F m G (KT , w). Since we explicitly handle the keys used in the TSetGetTag implementation we also need to modify the TSet API: We will initialize TSet as TSet ← TSetSetup (T), where T indexes the tuple lists t(w) not by the keywords w but by the corresponding stag(w) values. (This API change does not affect existing TSet implementations <ref type="bibr" target="#b9">[9]</ref> because they internally use stag(w) = TSetGetTag(KT , w) to store the t(w) list.) The PRF we use in the computation of xtag's will be similarly attribute-partitioned. Namely, KX is also an array of m independent FG keys KX = (KX <ref type="bibr" target="#b1">[1]</ref>, . . . , KX [m]), the xtrap value for keyword w is defined as F m G (KX , w), and the xtag corresponding to keyword w and index xind is set to (F m G (KX , w)) xind . In OSPIR-OXT, there are two two-party protocols involved in the computation of FG. In the first case, the protocol implements an OPRF computation in which C enters an input w, D enters a key KS, and the output is FG(KS, w) for C and ⊥ for D. In the second case, F m G is computed via a protocol, that we call a shared OPRF (S-OPRF), in which C inputs w and i = I(w), and D enters a key K and additional input ρ ∈ Z * p ; the output learned by D is i, and the output learned by C is (F m G (K, x)) ρ = (FG(K[i], x)) ρ . Note that the pair of outputs ((F m G (K, x)) ρ , ρ) can be seen as a secret sharing of F m G (K, x), hence the name shared-OPRF. OSPIR-OXT uses the OPRF protocol to let C learn the strap value corresponding to the w1 s-term, i.e. strap = FG(KS, w1), without D learning w1. The S-OPRF protocol is used to let C compute a blinded stag bstag = [F m G (KT , w1)] ρ 1 and the blinded xtraps bxtrap i = [F m G (KI , wi)] ρ i , for i = 2, ..., n. The functionality of the blinding ρi is the same as in the case of MC-OXT, namely, as a form of homomorphic signature binding and authorizing stag and xtrap's that E can verify. As in MC-OXT, E will receive the corresponding (de)blinding factors ρ1, . . . , ρn in the authenticated envelope env.</p><p>To simplify the description of OSPIR-OXT, we assume that both OPRF and S-OPRF protocols take a single round of interaction between C and D, as is indeed the case for several efficient OPRF's of interest <ref type="bibr" target="#b14">[14,</ref><ref type="bibr" target="#b21">21]</ref>, including the Hashed Diffie-Hellman OPRF <ref type="bibr" target="#b22">[22]</ref> used in our implementation below. We denote C's initial computation in the OPRF protocol as (a, r) ← OPRF.C1(x) (a is the value sent to D and r is randomness used by C), D's response computation as b ← OPRF.D(K, a), and C's local computation of the final output as OPRF.C2(b, r). We use the corresponding notation in the case of S-OPRF, except that S-OPRF.D takes as an input a triple (K, i, a) where i is an attribute and outputs a pair (b, ρ). See below for a simple implementation of these procedures for the case of the Hashed Diffie-Hellman OPRF.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>GenToken protocol</head><p>• Client C, on input w = (w 1 , ..., wn) where w 1 is chosen as s-term:</p><p>-Compute (as, rs) ← OPRF.C 1 (w 1 ), and (a i , r i ) ← S-OPRF.C 1 (w i ) for each i = 1, ..., n.</p><p>-Send (as, a 1 , ..., an) and av = (I(w 1 ), ..., I(wn)) to D.</p><p>• Data owner D, on input policy P and master key K = (K S , K X , K T , K I , K P , K M ):</p><p>-Abort if av is not in policy set P. Otherwise set av as D's local output.</p><p>-Compute bs ← OPRF.D(K S , as).</p><p>-Compute (b 1 , ρ 1 ) ← S-OPRF.D(K T , I 1 , a 1 ), and (b i , ρ i ) ← S-OPRF.D(K X , I i , a i ) for i = 2, .., n.</p><p>-Set env ← AuthEnc(K M , (ρ 1 , ρ 2 , ..., ρn)) and send (env, bs, b 1 , ..., bn) to C.  Keys. Select key KS for FG; KT and KX for F m G ; KI for Fp; and KM for the authenticated encryption scheme.</p><p>EDBSetup. Follow the EDBSetup procedure of MC-OXT except for computing strap ← FG(KS, w) and xtag ← (F m G (KX , w)) xind , and for implementing the TSetGetTag procedure as TSetGetTag(KT , w) = F m G (KT , w), which means that we compute stag(w) ← F m G (KT , w); index t(w) in T by stag(w) instead of by w itself; and generate TSet using the modified API procedure TSetSetup (T).</p><p>GenToken protocol. This is the main change with respect to OSPIR-OXT; it follows the above mechanisms and is presented in Figure <ref type="figure" target="#fig_2">2</ref>.</p><p>Search protocol. Same as MC-OXT except that stag is not included under env but rather it is provided to E by C as bstag from which E computes stag ← (bstag) 1/ρ 1 .</p><p>Instantiation via Hashed Diffie-Hellman OPRF. Our implementation and analysis of OSPIR-OXT assumes the use of Hashed DH OPRF mentioned above, namely, FG(K, x) = (H(x)) K . The instantiations of OPRF and S-OPRF protocols in this case are as follows. OPRF.C1(x) and S-OPRF.C1(x) both pick random r in Z * p , set a ← (H(x)) r , and output (a, r). Procedure OPRF.D(K, a), where K ∈ Z * p is a key for PRF FG, outputs b ← a K . Procedure S-OPRF.D(K, i, a), where i ∈ {1, ..., m} and K</p><formula xml:id="formula_4">= (K[1], . . . , K[m]) ∈ (Z * p ) m is a key for PRF F m G , picks random ρ in Z * p , computes b ← a K[i]</formula><p>•ρ , and outputs (b, ρ). Procedures OPRF.C1(b, r) and S-OPRF.C1(b, r) both output b 1/r . Note that if parties follow the protocol, C's final output is equal to (H(x)) K = FG(K, x) in the OPRF protocol, while in the S-OPRF protocol it is equal to (H(x))</p><formula xml:id="formula_5">K[i]•ρ , which is equal to (F m G (K, x)) ρ if i = I(x)</formula><p>. These OPRF and S-OPRF protocols emulate their corresponding ideal functionalities in ROM under socalled One-More Gap Diffie-Hellman assumption <ref type="bibr" target="#b22">[22]</ref>, see Section 5.</p><p>Figure <ref type="figure">3</ref> shows the OSPIR-OXT scheme instantiated with the above Hashed DH OPRF. It helps to visualize the entire protocol and it reflects our actual implementation. In </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Supporting Boolean Queries</head><p>For simplicity we presented our protocols for the case of conjunctions. The protocols can be readily adapted to search boolean queries in "searchable normal form (SNF)", i.e., of the form "w1 ∧φ(w2, . . . , wm)" (intended to return any document that matches keyword w1 and in addition satisfies the formula φ on the remaining keywords). In this case, OXT and its derivatives change only in the way E determines which tuples match a query (i.e., which values e it sends back to C). Specifically, in OXT the c-th tuple matches if and only if xtoken[c, i] y/ρ i ∈ XSet for all 2 ≤ i ≤ n. Instead, for boolean queries as above, E will have a set of boolean variables v2, . . . , vn and will set vi to the truth value of the predicate xtoken[c, i] y/ρ i ∈ XSet. A tuple is matching if and only if the result of evaluating φ on these values returns true. The complexity of boolean search is same as for conjunctions, i.e., proportional to |DB(w1)|, and leakage to E is the same as for a conjunctive query on the same set of keywords except that E also learns the expression φ being evaluated. See <ref type="bibr" target="#b9">[9]</ref> for details and support of other forms of boolean queries.</p><p>In the OSPIR-SSE setting, supporting boolean queries requires policies that are defined in terms of such queries. Specifically, a policy will determine a set of allowed pairs (ψ, I) where ψ is a symbolic boolean expression and I a sequence of attributes, one per each variable in ψ. Thus, leakage to D will include I (as in the case of conjunctions) plus the symbolic expression being evaluated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Computational Cost</head><p>Here we provide an operations count for OSPIR-OXT when instantiated with the DH-based OPRF noting its (mild) overhead over the original OXT protocol from <ref type="bibr" target="#b9">[9]</ref>. The computational cost of OSPIR-OXT is easy to quantify by inspecting Figure <ref type="figure">3</ref> in Page .</p><p>The cost of pre-processing (EDBSetup) is dominated by operations related to the group G, mainly exponentiations: For every w ∈ W:</p><p>1. One hashing operation, H(w), of keyword w into an element of the group G.</p><p>2. Two exponentiations: strap(w) = (H(w)) K S and stag(w) = (H(w)) k i .</p><p>3. For every ind in DB(w): One exponentiation H(w) e i •xind for computing an XSet element.</p><p>The first two items are specific to OSPIR-OXT while the third is from the original OXT protocol, except that here the base for exponentiation is changed from the generator g in OXT to the value H(w). Hence the overhead introduced by OSPIR-OXT is given by the first two items and the variable base. Importantly, the overhead for the first two items is only linear in |W|, typically much smaller than the number of exponentiations in OXT (item 3), namely one per pair (w, ind) for ind ∈ DB(w). As for the latter exponentiations, while the bases are variable, each H(w) is typically used with a very large number of exponentiations (as the number of documents containing w) hence allowing for significant same-base optimizations. The hashing of w into the group G (item 1) is modeled as a random oracle, hence it rules out algebraic implementations such as g h(w) . For the elliptic curves groups we use, H is realized by sampling a field element e and a bit b from a PRNG seeded with w until (e, b) is the compressed representation of a valid group element.</p><p>Depending on the particular nature of a curve, the generic square root algorithms required in solving the Weierstrass equation, though, can be extremely inefficient: Our original implementation for the chosen NIST 224p curve using OpenSSL's standard algorithms was more than an order of magnitude slower than a normal exponentiation and considerably more when common-base optimization is used. By implementing our own algorithm inspired by <ref type="bibr" target="#b4">[4]</ref> and optimizing it for this particular field, we could reduce the cost down to the order of an exponentiation. Once all these optimizations are in place, the performance of OSPIR-OXT is remarkable as shown in Section 4.4 and, in much more details, in a companion paper <ref type="bibr" target="#b8">[8]</ref>.</p><p>The dominating cost of GenToken is just 2n + 1 exponentiations for the client and n + 1 for D.</p><p>Finally, the cost of query processing between C and E (Search) on a n-term SNF expression is as follows:</p><p>1. C computes n -1 exponentiations for each tuple in TSet(w1)</p><p>2. E performs up to n-1 exponentiations for each element in TSet(w1).</p><p>Note that C can apply same-base optimization to the exponentiations since each term in the SNF expression has its own fixed base. On the other hand, E cannot use same-base optimizations. However, note that as soon as one of the values xtoken[c, i] y/ρ i for a conjunction is found not to be in XSet, the other terms for this conjunction do not have to be evaluated (hence avoiding the need for these exponentiations). Similarly, for general Boolean expressions, early termination can be exploited to reduce costly computation. This highlights an important optimization for query processing (especially for queries with large TSet(w1) sets): Besides choosing the s-term as a term with high-entropy to keep TSet(w1) small, also choose the evaluation order of x-terms of an SNF expression such that it maximizes the probability of early termination and, hence, reduces the number of (expected) exponentiations executed by E , e.g., for conjunctions order the x-terms in descending order of entropy (equivalently, ascending order of frequency). Note (frequency ordering). In the OSPIR setting the client may not know the frequency of terms in the database and D will not know the query values to choose such terms optimally. Thus, the exact mechanism for determining the above ordering will depend on the specific setting. In our implementation we decide on ordering based on typical entropy of attributes; e.g., assuming last names have more entropy than names, and names more entropy than addresses, etc. (note that an attribute-based ordering is more privacy-preserving for the client than a value-based one).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Implementation and performance</head><p>The practicality of the proposed schemes was validated by experiments on DBs which included e.g. English-language Wikipedia <ref type="bibr" target="#b13">(13,</ref><ref type="bibr">284,</ref><ref type="bibr">801</ref>  See <ref type="bibr" target="#b8">[8]</ref> for details on implementation and performance as well as for the extension of OXT and OSPIR-OXT to support dynamic databases (where documents can be added, deleted and modified).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">SECURITY</head><p>We analyze security of the OSPIR-SSE scheme. We focus on the OSPIR case as it is the more comprehensive setting and it contains MC-SSE as a special case. The SSE-OXT protocol is analyzed in the SSE setting in <ref type="bibr" target="#b9">[9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Security and Correctness Def nitions</head><p>SSE security definitions where the only adversarial entity is server E are provided in prior work. Here we follow the definitions from <ref type="bibr" target="#b9">[9]</ref> -which in turn follow <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b13">13]</ref> -and extend them to the MC setting by considering multiple malicious clients and to the OSPIR setting by adding also the data owner D as an adversarial entity. All security definitions follow the ideal/real model framework of secure computation and are parametrized by a leakage function L bounding the information leaked to an adversarial party in addition to the intended output for that party. Specifically, we ask that whatever an adversary can do by running the real protocol on data and queries chosen by the adversary, a simulator can do solely on the basis of the leakage function.</p><p>Correctness. We say that an OSPIR-SSE scheme Σ = (EDBSetup, GenToken, Search) is computationally correct if for every efficient algorithm A, there is a negligible probability that the following experiment outputs 0. On inputs (DB, RDK) and w(1) , . . . , w(m) provided by A, execute (K, EDB) ← EDBSetup(DB, RDK); and for i = 1, 2, . . ., execute protocol GenToken on C's input w(i) and D's inputs (P, K), denote C's output as token (i) , execute protocol Search between C on input token (i) and E on input EDB and denote C's outputs as a pair (indSet (i) , rdkSet (i) ). Output 1 if for each i we have that indSet (i) = DB( w(i) ) and rdkSet (i) = RDK[DB( w(i) )]. Otherwise output 0.</p><p>Security against adversarial server E . Security against adversarial (honest-but-curious) E has been the focus of prior SSE work. Adapting the definition of L-semantic security against adaptive attacks (by the server E ) from <ref type="bibr" target="#b9">[9]</ref> to our setting is straightforward and is omitted here.</p><p>Security against adversarial clients. The definition captures the information leaked to a malicious client in addition to the intended output DB( w) and the corresponding record-decrypting keys RDK[DB( w)]. The definition compares the real execution to an emulation of an interaction with algorithm I-SSE L , which models an ideal functionality of the OSPIR-SSE scheme instantiated with the leakage function L. The interactive algorithm I-SSE L , running on local input (DB, RDK, P), answers queries w ∈ W * by checking if av( w) ∈ P. If the check verifies, then it replies to this w with a triple (DB( w), RDK[DB( w)], L(DB, w)), and if av( w) ∈ P then it sends back a rejection symbol ⊥. Definition 1. Let Π = (EDBSetup, GenToken, Search) be an OSPIR-SSE scheme. Given algorithms L, A, and S = (S0, S1, S2) we define experiments (algorithms) Real Π A (λ) and Ideal Π A,S (λ) as follows: Real Π A (λ): A(1 λ ) chooses (DB, RDK, P), and the experiment runs (K, EDB) ← EDBSetup(DB, RDK). Adversary A can then adaptively invoke instances of the protocol GenToken and Search, interacting with party D running on input K and P in the first case and with party E running on input EDB in the second case. Note that A can behave arbitrarily in all these protocol instances. Let q be the number of GenToken instances and let avi be D's local output in the i-th instance. If at any point A halts and outputs a bit b, the game outputs (b, av1, . . . , avq).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ideal Π</head><p>A,S (λ): A(1 λ ) chooses (DB, RDK, P) as above, while the experiment initializes S = (S0, S1, S2) by running st ← S0(1 λ ). Subsequently, each time A invokes an instance of protocol GenToken, it interacts with the experiment running S1(st, P), whereas if A invokes an instance of protocol Search, it interacts with the experiment running S2(st). Both S1 and S2 algorithms are allowed to update the global simulator's state st while interacting with A. Both can issue queries w to I-SSE L (DB, RDK, P). Let q be the number of these queries and let avi = I( wi), where wi is the i-th query. As above, if at any point A halts and output a bit b, the game outputs (b, av1, . . . , avq).</p><p>We call Π L-semantically-secure against malicious clients if for any efficient algorithm A there is an efficient algorithm S s.t. the statistical difference between tuples (b, av1, . . . , avq) output by experiments Real Π A and Ideal Π A,S is a negligible function of the security parameter λ.</p><p>Security against adversarial data owner. Security against a data-owner D models privacy of the client's queries w against malicious D, given an adaptive choice of the client's queries. Similarly to the case of security against either the client C or the EDB-storing server E , this security definition also allows for leakage of some information L( w) regarding the query w to D. Definition 2. Let Π = (EDBSetup, GenToken, Search) be an OSPIR-SSE scheme. Given algorithms L, A, and S we define experiments (algorithms) Real Π A (λ) and Ideal Π A,S (λ) as follows: Real Π A (λ): Adversary A(1 λ ) can adaptively invoke any number of GenToken instances by specifying a query w and interacting with party C running the GenToken protocol on input w. At any point A can halt and output a bit, which the game uses as its own output. Ideal Π A,S (λ): Adversary A(1 λ ) can adaptively invoke any number of GenToken instances as above, but for any query w which A specifies, it interacts with S running on input L( w). As above if A halts and output a bit, the game uses this bit as its own output.</p><p>We call Π L-semantically-secure against malicious data owner if for any efficient alg. A there is an efficient alg. S s.t.</p><formula xml:id="formula_6">Pr[Real Π A (λ)=1] -Pr[Ideal Π A,S (λ)=1] ≤ neg(λ).</formula><p>Note (non-collusion between D and E ). We stress that even though the data owner D can be arbitrarily malicious, we assume that D and E do not collude. Indeed, client's security in the OSPIR-OXT scheme we propose is not maintained against such collusion. Moreover, providing query-privacy from D under collusion with E would have the (impractical) cost of a single-server symmetric PIR protocol. The hospital example mentioned in the introduction, is a case where such non-collusion requirement makes sense. Indeed, it is the hospital interest not to learn the queries: It helps avoiding liability and complying with regulations as well as withstanding potential insider attacks. Similarly, for a service providing private access to a database (e.g. to a patent repository) preserving client privacy is part of its very business model. See also <ref type="bibr" target="#b18">[18]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Security of OSPIR-OXT</head><p>Correctness of OSPIR-OXT. We first argue that protocol OSPIR-OXT is correct.</p><p>Theorem 3. The OSPIR-SSE scheme OSPIR-OXT instantiated with the Hashed Diffie-Hellman OPRF is computationally correct assuming that the DDH assumption holds, that the T-set implementation is computationally correct, that Fp is a secure PRF, and assuming the Random Oracle Model for hash function H.</p><p>Since T-set implementation is computationally correct, any correctness errors can only come from collisions in PRF functions, including function FK X ,K I effectively used in computing xtag values, defined as FK X ,K I (w, ind) = (F m G (KX , w)) Fp(K I ,ind) . But assuming the PRF property of Fp, and the PRF property of F m G , which holds under DDH in ROM, function FK X ,K I is a PRF too, and so collision probability is negligible, resulting in negligible error probability over the execution of the OSPIR-OXT correctness experiment.</p><p>Security of OSPIR-OXT. Using the security notions explained above we describe the security properties of the OSPIR-SSE scheme OSPIR-OXT instantiated with the Hashed Diffie-Hellman OPRF, as shown in Figure <ref type="figure">3</ref>. We first state the OM-GDH security assumption required for the security of the OPRF and S-OPRF sub-protocols of this OSPIR-OXT instantiation. One-More Gap Diffie-Hellman (OM-GDH). Let G = G λ be a prime order cyclic group of order p = p(λ) generated by g. We say that the One-More Gap Diffie-Hellman (OM-GDH) assumption holds in G if Adv ddh G,A (λ) is negligible for all efficient adversaries A, where Adv ddh G,A (λ) is defined as the probability that A wins the following game: (1) The game chooses random t in Z * p and two random elements h1, h2 in G; (2) A, on input h1, h2, specifies a single query a to the Diffie-Hellman oracle, which on input a returns b ← a t ; (3) A can make any number of queries to a Decisional Diffie-Hellman oracle DDHt(•, •), which on input (h, v) returns 1 if v = h t and 0 otherwise; (4) Finally A outputs two values v1, v2, and we say that A wins the game if v1 = (h1) t and v2 = (h2) t . Security against adversarial server E . The OSPIR-SSE scheme OSPIR-OXT is Loxt-semantically-secure against adaptive server E under the same assumptions and for the same leakage function Loxt as the underlying SSE scheme OXT of <ref type="bibr" target="#b9">[9]</ref>. This is because the specific PRF's used by OSPIR-OXT in EDB construction are instantiations of general PRF's considered in OXT, and because E 's view of the Search protocol in the OSPIR-OXT scheme can be generated from E 's view of Search in the OXT scheme. Specifically, each ρi in env is random in Z * p , and bstag and each bxtoken[c, i] value in Figure <ref type="figure">3</ref>  Theorem 4. Let L be a defined as L(DB, w) = Mask (|DB(w1)|) for w = (w1, ..., wn). OSPIR-SSE scheme OSPIR-OXT instantiated with the Hashed Diffie-Hellman OPRF is Lsemantically-secure against malicious clients assuming that the One-More Gap Diffie-Hellman assumption holds in G, that Fp is a secure PRF, that the T-set implementation is (computationally) correct, that (AuthEnc, AuthDec) is an IND-CPA and Strongly-UF-CMA authenticated encryption scheme, and assuming the Random Oracle Model for hash function H. <ref type="bibr" target="#b20">[20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof. See full version</head><p>Security against adversarial data owner D. In our OSPIR-SSE scheme a malicious D learns nothing about clients' query w = (w1, . . . , wn) except for the vector of attributes av( w) = (I(w1), . . . , I(wn)).</p><p>Theorem 5. Let L be a leakage function defined as L( w) = av( w). OSPIR-SSE scheme OSPIR-OXT instantiated with the Hashed Diffie-Hellman OPRF is L-semantically-secure against malicious data owner.</p><p>Proof. See full version <ref type="bibr" target="#b20">[20]</ref>.</p><p>Note that the D's view of the GenToken protocol in the OSPIR-OXT scheme consists of the attribute vector av( w) and the values as, a1, ..., an. In the Hashed DH OPRF instantiation of this scheme in Figure <ref type="figure">3</ref>, these values are formed as aj ← H(wj) r j for random rj 's in Z * p (additionally, as is set to a1). Since G is of prime order, every element in G\{1} is a generator, and thus each aj is uniform in G. Thus D's view of the GenToken protocol can be trivially simulated from L( w) = av( w).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Extensions: Reducing Leakage to D</head><p>In the full version <ref type="bibr" target="#b20">[20]</ref> we show how to adapt OSPIR-OXT to a setting where a third party, called a policy manager, authorizes queries while D can enforce them without learning the policy, the boolean expression or the queried attributes; only the number of such attributes is learned by D. This setting is precisely what is needed to implement searches authorized by a warrant while keeping the searched information hidden from all parties except the authorized searcher.</p><p>In addition, OSPIR-OXT can be extended (even without introducing a policy manager) so that the leakage about queried attributes to D is further limited to the minimum needed to make policy decisions (e.g., D may not need to know the exact attributes in a query but only the attribute classes they belong to).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: OXT: Oblivious Cross-Tags SSE Scheme</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>•</head><label></label><figDesc>C outputs token = (env, strap, bstag, bxtrap 2 , ..., bxtrap n ) where strap ← OPRF.C 2 (bs, rs), bstag ← S-OPRF.C 2 (b 1 , r 1 ), and bxtrap i ← S-OPRF.C 2 (b i , r i ) for i = 2, ..., n.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Token Generation in OSPIR-OXT</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Figure 3 we denote keys KT and KX of PRF F m G by vectors of exponents in Z * p , respectively (k1, . . . , km) and (e1, . . . , em), where m is the number of attributes. Also, because of the specific OPRF instantiation we equate as to a1 in C's message of the GenToken protocol, instead of computing these two blinded versions of keyword w1 separately, as in Figure 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>can be computed by exponentiating values stag and xtoken[c, i] in Figure 1 to, respectively, ρ1 and ρi. Security against adversarial client C. Let Mask(|DB(w1)|) denote an upper bound on |DB(w1)| used by E to mask the size of TSet(w1) when responding to C's queries as described at the end of Section 3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>records / 2,732,311,945 indexed tuples), and a synthetic US census database (100 million records / 22,525,274,592 index tuples, resulting in EDB with 1.7 TB TSet and 0.4 TB XSet). To illustrate search efficiency, in the census DB case we executed complex queries like</figDesc><table><row><cell>SELECT id WHERE fname='CHARLIE' AND</cell></row><row><cell>sex='Female' AND NOT (state='NY' OR</cell></row><row><cell>state='MA' OR state='PA' OR state='NJ)</cell></row><row><cell>in about 4 seconds on an IBM Blade dual Intel 4-core Xeon</cell></row><row><cell>processor and storage provided by a (low-end) 6.2TB RAID-</cell></row><row><cell>5 storage system. Preprocessing of such large DBs (TSet</cell></row><row><cell>and XSet creation) has been feasible by, among other things,</cell></row><row><cell>optimization of common-base exponentiations, achieving ag-</cell></row><row><cell>gregated (parallel) rate of about 500,000 exp.'s/sec. for the</cell></row><row><cell>NIST 224p elliptic curve.</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>See Section 5.1.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>Note (the array RDK). Our SSE syntax, and the OXT description in Figure1, includes as input to EDBSetup an array RDK that contains, for each document in DB, a key rdk used</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><p>The estimated least frequent keyword is called the conjunction's sterm; the other terms in a conjunction are called x-terms.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3"><p>We assume that the string representing w has its attribute encoded into it, i.e. w = (i, val) for i = I(w), so that Ryan as a first name is distinguished from Ryan as a last name.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgment</head><p>Supported by the Intelligence Advanced Research Projects Activity (IARPA) via Department of Interior National Business Center (DoI / NBC) contract number D11PC20201. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright annotation thereon. Disclaimer: The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of IARPA, DoI/NBC, or the U.S. Government.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Group operations. G is a cyclic group of prime order p generated by an element g. H is a hash function with range in G \ {1}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>EDBSetup(DB, RDK)</head><p>Key Generation. D picks key K S and two vectors of elements K T = (k 1 , . . . , km) and K X = (e 1 , . . . , em) at random in Z * p (m = number of attributes); key K I for PRF Fp; and key K M for a symmetric authenticated encryption AuthEnc. Fp and Fτ are PRF's which outputs strings in respectively Z * p and {0, 1} τ , and τ is a security parameter. • Initialize XSet to an empty set, and initialize T to an empty array indexed by group elements in G.</p><p>• For each w = (i, val) ∈ W, build the tuple list t and add elements to set XSet as follows:</p><p>-Initialize t to an empty list.</p><p>• Create TSet ← TSetSetup (T), and output key K = (K S , K X , K T , K I , K M ) and EDB = (TSet, XSet, K M ).</p><p>GenToken protocol Client C on input a conjunctive query w = (w 1 , ..., wn), where w 1 is chosen as s-term, proceeds as follows:</p><p>p and set a j ← (H(w j )) r j for j = 1, . . . , n. • Send to D the blinded queries a 1 , . . . , an and the attribute sequence av = (I(w 1 ), . . . , I(wn)).</p><p>Data owner D on input policy P and key K proceeds as follows:</p><p>• Abort if av ∈ P . Otherwise set av as a local output. Pick ρ 1 , . . . , ρn</p><p>• Reply to C with (strap , bstag , bxtrap 2 , . . . , bxtrap n ) and env = AuthEnc K M (ρ 1 , . . . , ρn).</p><p>C sets:</p><p>r -1 j (∀ j=2,...,n );</p><p>• token ← (env, strap, bstag, bxtrap 2 , . . . , bxtrap n ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Search protocol</head><p>Client C on input token proceeds as follows:</p><p>• Set (Kz, Ke) ← F (τ (strap, 1), F (strap, 2)), and send to E the message (env, bstag, bxtoken <ref type="bibr" target="#b1">[1]</ref>, bxtoken <ref type="bibr" target="#b2">[2]</ref>, . . .) defined as follows:</p><p>- Server E on input EDB = (TSet, XSet, K M ) responds as follows:</p><p>• Upon receiving env, bstag from C, decrypt/verify env; if verification fails return "no results" and stop.</p><p>• Set stag ← (bstag) 1/ρ 1 and retrieve t ← TSetRetrieve(TSet, stag) from TSet.</p><p>• For c = 1, . . . , |t| do:</p><p>-Receive bxtoken[c] from C and retrieve value (e, y) from the c-th tuple in t.</p><p>-Check if bxtoken[c, i] y/ρ i ∈ XSet for all i = 2, . . . , n. If so, send e to C (else nothing is returned for this tuple).</p><p>-When last tuple in t is reached, send stop to C and halt.</p><p>For each received e client C computes (ind|rdk) ← Dec(Ke, e) and outputs (ind, rdk). </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Searchable encryption revisited: Consistency properties, relation to anonymous IBE, and extensions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abdalla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Catalano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kiltz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kohno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lange</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Malone-Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Neven</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Paillier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">3621</biblScope>
			<biblScope unit="page" from="205" to="222" />
			<date type="published" when="2005-08">2005. Aug. 2005</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Achieving efficient conjunctive keyword searches over encrypted data</title>
		<author>
			<persName><forename type="first">L</forename><surname>Ballard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kamara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Monrose</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICICS 05</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Qing</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Mao</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>López</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Wang</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005-12">Dec. 2005</date>
			<biblScope unit="volume">3783</biblScope>
			<biblScope unit="page" from="414" to="426" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Deterministic and efficiently searchable encryption</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Boldyreva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>O'neill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Menezes</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4622</biblScope>
			<biblScope unit="page" from="535" to="552" />
			<date type="published" when="2007-08">2007. Aug. 2007</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Bernstein</surname></persName>
		</author>
		<ptr target="http://cr.yp.to/papers/sqroot.pdf" />
		<title level="m">Faster square roots in annoying finite fields</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Public key encryption with keyword search</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Di Crescenzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Persiano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Cachin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Camenisch</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">3027</biblScope>
			<biblScope unit="page" from="506" to="522" />
			<date type="published" when="2004-05">2004. May 2004</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Conjunctive, subset, and range queries on encrypted data</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Vadhan</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4392</biblScope>
			<biblScope unit="page" from="535" to="554" />
			<date type="published" when="2007-02">2007. Feb. 2007</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Efficient conjunctive keyword search on encrypted data storage system</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Byun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EuroPKI</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="184" to="196" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Dynamic Searchable Encryption in Very Large Databases: Data Structures and Implementation</title>
		<author>
			<persName><forename type="first">D</forename><surname>Cash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jaeger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jarecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jutla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-C</forename><surname>Roşu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Steiner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>Manuscript</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Highly-scalable searchable symmetric encryption with support for boolean queries. Crypto&apos;2013</title>
		<author>
			<persName><forename type="first">D</forename><surname>Cash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jarecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jutla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rosu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Steiner</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2013/169" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="issue">169</biblScope>
			<date type="published" when="2013-03">2013. Mar. 2013</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Privacy preserving keyword searches on remote encrypted data</title>
		<author>
			<persName><forename type="first">Y.-C</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACNS 05</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Ioannidis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Keromytis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005-06">June 2005</date>
			<biblScope unit="volume">3531</biblScope>
			<biblScope unit="page" from="442" to="455" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Structured encryption and controlled disclosure</title>
		<author>
			<persName><forename type="first">M</forename><surname>Chase</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kamara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2010</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010-12">Dec. 2010</date>
			<biblScope unit="page" from="577" to="594" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Efficient techniques for privacy-preserving sharing of sensitive information</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">D</forename><surname>Cristofaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Tsudik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Mccune</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Balacheff</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A.-R</forename><surname>Sadeghi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Sasse</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Y</forename><surname>Beres</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">6740</biblScope>
			<biblScope unit="page" from="239" to="253" />
			<date type="published" when="2011">2011</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Searchable symmetric encryption: improved definitions and efficient constructions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Curtmola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kamara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS 06</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Juels</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">N</forename><surname>Wright</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Vimercati</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006-11">Oct. / Nov. 2006</date>
			<biblScope unit="page" from="79" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Keyword search and oblivious pseudorandom functions</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Freedman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2005</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005-02">Feb. 2005</date>
			<biblScope unit="volume">3378</biblScope>
			<biblScope unit="page" from="303" to="324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">E.-J</forename><surname>Goh</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
		<title level="m">Secure indexes. Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2003">2003/216, 2003</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Secure conjunctive keyword search over encrypted data</title>
		<author>
			<persName><forename type="first">P</forename><surname>Golle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Staddon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">R</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACNS 04</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Jakobsson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Zhou</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004-06">June 2004</date>
			<biblScope unit="volume">3089</biblScope>
			<biblScope unit="page" from="31" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Outsourced private information retrieval with pricing and access control</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Goldberg</surname></persName>
		</author>
		<idno>2013-11</idno>
		<imprint>
			<date type="published" when="2013-02">Feb. 2013</date>
		</imprint>
		<respStmt>
			<orgName>Centre for Applied Cryptographic Research (CACR), University of Waterloo</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Security and Privacy Assurance Research (SPAR) Program -BAA</title>
		<author>
			<persName><surname>Iarpa</surname></persName>
		</author>
		<ptr target="http://www.iarpa.gov/solicitations_spar.html/" />
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Access pattern disclosure on searchable encryption: Ramification, attack and mitigation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Islam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kuzu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kantarcioglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Network and Distributed Systems Security (NDSS 2012)</title>
		<meeting>the Symposium on Network and Distributed Systems Security (NDSS 2012)<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<publisher>Internet Society</publisher>
			<date type="published" when="2012-02">Feb. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Outsourced symmetric private information retrieval</title>
		<author>
			<persName><forename type="first">S</forename><surname>Jarecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jutla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Rosu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Steiner</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2013/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Efficient oblivious pseudorandom function with applications to adaptive OT and secure computation of set intersection</title>
		<author>
			<persName><forename type="first">S</forename><surname>Jarecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">5444</biblScope>
			<biblScope unit="page" from="577" to="594" />
			<date type="published" when="2009-03">2009. Mar. 2009</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Fast secure computation of set intersection</title>
		<author>
			<persName><forename type="first">S</forename><surname>Jarecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SCN 10</title>
		<imprint>
			<biblScope unit="page" from="418" to="435" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Cryptographic cloud storage</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kamara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Lauter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Financial Cryptography Workshops</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="136" to="149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Dynamic searchable symmetric encryption</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kamara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Papamanthou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Roeder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of CCS</title>
		<meeting>of CCS</meeting>
		<imprint>
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">UC-secure searchable symmetric encryption</title>
		<author>
			<persName><forename type="first">K</forename><surname>Kurosawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ohtaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Financial Cryptography</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page">285</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Number-theoretic constructions of efficient pseudo-random functions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">38th FOCS</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1997-10">Oct. 1997</date>
			<biblScope unit="page" from="458" to="467" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Blind Seer: A Scalable Private DBMS</title>
		<author>
			<persName><forename type="first">V</forename><surname>Pappas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Vo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Krell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kolesnikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Keromytis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Malkin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>Manuscript</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Multi-dimensional range query over encrypted data</title>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bethencourt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">T</forename><surname>-H. Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">X</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2007 IEEE Symposium on Security and Privacy</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2007-05">May 2007</date>
			<biblScope unit="page" from="350" to="364" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Practical techniques for searches on encrypted data</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">X</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2000 IEEE Symposium on Security and Privacy</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2000-05">May 2000</date>
			<biblScope unit="page" from="44" to="55" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Computationally efficient searchable symmetric encryption</title>
		<author>
			<persName><forename type="first">P</forename><surname>Van Liesdonk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sedhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Doumen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">H</forename><surname>Hartel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Jonker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Workshop on Secure Data Management (SDM)</title>
		<meeting>Workshop on Secure Data Management (SDM)</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="87" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Building an encrypted and searchable audit log</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">R</forename><surname>Waters</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Balfanz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Durfee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">K</forename><surname>Smetters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<publisher>The Internet Society</publisher>
			<date type="published" when="2004-02">2004. Feb. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Terrorism Agency to Tap a Vast Database of Citizens</title>
		<author>
			<persName><forename type="middle">U S</forename><surname>Wsj</surname></persName>
		</author>
		<ptr target="http://alturl.com/ot72x" />
	</analytic>
	<monogr>
		<title level="j">Wall Street Journal</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
