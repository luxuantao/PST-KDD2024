<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Formal Verification of Circuit-Switched Network on Chip (NoC) Architectures using SPIN</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Anam</forename><surname>Zaman</surname></persName>
							<email>anam.zaman@seecs.nust.edu.pk</email>
						</author>
						<author>
							<persName><forename type="first">Osman</forename><surname>Hasan</surname></persName>
							<email>osman.hasan@seecs.nust.edu.pk</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">School of Electrical Engineering and Computer Science</orgName>
								<orgName type="institution">National University of Sciences and Technology (NUST)</orgName>
								<address>
									<settlement>Islamabad</settlement>
									<country key="PK">Pakistan</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">School of Electrical Engineering and Computer Science</orgName>
								<orgName type="institution">National University of Sciences and Technology (NUST)</orgName>
								<address>
									<settlement>Islamabad</settlement>
									<country key="PK">Pakistan</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Tsinghua University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Formal Verification of Circuit-Switched Network on Chip (NoC) Architectures using SPIN</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2023-01-01T13:29+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Simulation techniques cannot cope with the distributive and reactive nature of Network on chip (NoC) architectures very well and thus compromise on the accuracy of the analysis results. Formal verification has been used to overcome these challenges but, to the best of our knowledge, has been mainly used for the verification of packet-switched NoC's. The main focus of this paper is on the formal verification of circuit-switched NoC's, which provide a dedicated channel for all communications with full bandwidth and thus are found to be more efficient than packet-switched NoCs in many contexts. In particular, the paper presents a generic methodology for the formal verification of circuit-switched NoC using the SPIN model checker. The proposed methodology provides generic modelling guidelines and identifies some properties, including deadlock freedom, starvation freedom, mutual exclusion and liveness, that are quite useful in the context of circuit-switched NoC. For illustration purposes, we use our methodology to verify the programmable NoC (PNoC) architecture, which is one of the most widely used circuit-switched NoC.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Traditional bus-based communication architecture is not able to pace up with contemporary System on chips (SoCs). It has become hard to deliver data from point to point during a single clock cycle. Moreover use of multiple buses increases design complexity and reduces scalability <ref type="bibr" target="#b14">[15]</ref>. Data synchronization of on-chip modules via a global clock leads to high power consumption and electromagnetic interference (EMI) problems <ref type="bibr" target="#b2">[3]</ref>. The concept of Network on chips (NoC) <ref type="bibr" target="#b6">[7]</ref> integrates network theoretic concepts for on-chip communication between various processor cores of SoC architectures and offers a promising solution for the above-mentioned problems. It not only handles the synchronization issues but its modular nature allows it to be used with standard interfaces. Besides the scalability, NoC architectures are well-known to facilitate design-flow parallelism and reduce power consumption compared to the traditional bus based interconnects <ref type="bibr" target="#b14">[15]</ref> [3] <ref type="bibr" target="#b7">[8]</ref>.</p><p>The communication network in a NoC consists of wires and routers <ref type="bibr" target="#b2">[3]</ref>  <ref type="bibr" target="#b6">[7]</ref>. Memories, processors and other IP-block are connected to the router and the routing algorithm manages all the communication. The network layer of a NoC helps in transmitting data by using switching algorithms <ref type="bibr" target="#b22">[23]</ref>, which are categorized into packet and circuit based techniques. Packet-switched based NoC divides the data into packets which are transmitted to the dedicated node. Once received, data packets reassemble the sequence to recover the message. Under heavy data, such as video streaming, flow packets may get lost or sometimes get corrupted. Thus, packet switching needs a protocol for reliable data transfer. Circuit-switched, on the other hand, ensures reliable data transfer by defining a dedicated path between nodes. It guarantees full bandwidth and provides quality of service. The messages arrive in the same manner as they were transmitted. Circuit switched based NoC is ideal for voice based services <ref type="bibr" target="#b2">[3]</ref>  <ref type="bibr" target="#b14">[15]</ref> and has been known to perform better than packet switched based NoC in many aspects <ref type="bibr" target="#b9">[10]</ref>  <ref type="bibr" target="#b20">[21]</ref>.</p><p>One of the main challenges in NoC architectures is their functional verification. Due to the distributed and reactive behaviors of NoC architectures, generating interesting test patterns for simulations is a major issue. This fact coupled with the non-exhaustive nature of simulation for analyzing large designs, makes a rigorous analysis of NoC architectures impossible. Especially when considering many-core systems, the number of different communication signals, grows exponentially with the number of cores. Even if some corner cases can be specifically targeted, there is no proof that these represent a worst-case scenario, and it is never possible to consider or even foresee all corner cases. Thus, simulation based analysis cannot be considered complete and often results in missing critical bugs, which is a very undesirable characteristic, given the safety and financial critical nature of the present-age manycore chips, where the NoC architectures are usually deployed <ref type="bibr" target="#b22">[23]</ref>  <ref type="bibr" target="#b6">[7]</ref>.</p><p>Formal verification methods <ref type="bibr">[2] [26]</ref> have been used to overcome the above-mentioned limitations for many hardware designs. The main idea behind formal verification is to analyze the behavior of systems using mathematical reasoning or rigorous state-space exploration. The system implementation and specification are given to the formal verification tools and the goal is to identify corner cases in which the system model does not conform to its specifications.</p><p>Theorem proving <ref type="bibr" target="#b13">[14]</ref> use deductive techniques for verifying the relationship between the logical specification and logical implementation of the given systems. The verification process may require explicit user guidance and thus can be quite tedious, especially when using more expressive higher-order logic <ref type="bibr" target="#b4">[5]</ref>. Model checking <ref type="bibr" target="#b4">[5]</ref> is the second mainstream formal verification method and involves the computer based mathematical modeling of the given system in the form of an automata or state-space. This model is then used within a computer to automatically verify that it meets rigorous specifications of intended behavior. Due to its mathematical nature of these formal verification methods, 100% completeness and soundness of the analysis can be guaranteed. Model checking seems to suit the context of NoC verification the best due to its automatic and hence user-friendly nature and the fact that the behavior of NoC architectures can be easily expressed in terms of a state-space. Moreover, the ability to provide counter examples in case of failures and the automatic nature of model checking makes it a more preferable choice for industrial usage as compared to the other interactive formal verification approaches like theorem proving.</p><p>Model checking has been successfully used for analyzing packet switched based NoC architectures (e.g. <ref type="bibr" target="#b22">[23]</ref> [31] <ref type="bibr">[11] [25]</ref>). However the main focus of these works is to verify particular aspects of NoC architectures in a very ad-hoc manner. Chen et all. <ref type="bibr" target="#b10">[11]</ref> implemented the bi-network on chip (BiNoC) model in state graph manipulator (SGM). They checked four critical properties of the given NoC router, namely mutual exclusion, starvation freedom, deadlock freedom and conditions for traffic congestions. They successfully verified the mutual exclusion property but faced state-space explosion problem while verifying the deadlock-freedom and traffic congestion. On the other hand, starvation freedom property failed proving that Bi-NoC model is not a fair one. Hermes NoC was formally verified by Vinitha et all. <ref type="bibr" target="#b22">[23]</ref>. Using the SPIN model checker, they verified reliable data transfer along with valid path selection by the router. Salaun et all. <ref type="bibr" target="#b24">[25]</ref> also contributed to this field by verifying an asynchronous NoC. They used the model checking tool available in the CADP toolbox and verified the deadlock freedom along with correct sequencing of communications in a protocol. Holcomb <ref type="bibr" target="#b15">[16]</ref> checked the Quality of Service (QoS) for the 2D-mesh NoC by verifying performance properties, such as latency bounds and synthesis of optimal buffer sizes, using the SAT based model checker ABC.</p><p>Theorem proving has also been widely used for NoC verification. Borrione <ref type="bibr" target="#b7">[8]</ref> presented a formal meta-model for reasoning about network specifications, from the transport to the data link layer of the OSI architectural model. The model was instantiated on Octagon, Hermes and Spidergon NoC and verification flow was adopted by the ACL2 theorem prover. Another GeNoC was formalized by Broek <ref type="bibr" target="#b28">[29]</ref> and is verified for both packet and circuit-switched based NoC in ACL2. They also verified that the 2D-mesh architecture <ref type="bibr" target="#b29">[30]</ref>, based on the Hermes NoC, behaves according to the specification. Moreover they extended their work <ref type="bibr" target="#b31">[32]</ref> by adding two theorems to GeNoC, i.e, the network is deadlock free and can evacuate all injected messages.</p><p>Besides the main stream formal methods, like model checking and theorem proving, some other formal methods have also been used for the formal verification of NoC architectures.</p><p>For example, EventB formalism is used to ascertain the architectural correctness of NoCs <ref type="bibr" target="#b3">[4]</ref>. ForEVeR tool has been used to identify bugs in the NoC fabric <ref type="bibr" target="#b23">[24]</ref>. Evaluation under self similar traffic is observed is <ref type="bibr" target="#b26">[27]</ref>. Based on the abovementioned literature review, it can be observed that most of the existing work on the formal verification of NoC is focused on packet-switched NoC. Similarly, none of these techniques provide a complete cross level verification of NoC and all of them use different sets of evaluation parameters for NoC verification.</p><p>This paper tends to overcome the above-mentioned limitations and proposes a generic methodology for the formal verification of any circuit switched NoC architecture. The main idea behind the proposed methodology is to use the SPIN model checker <ref type="bibr" target="#b16">[17]</ref>, which is an open source tool for the formal verification of distributed software systems. We can formally model or specify the behavior of NoC architectures in the PROcess MEta LAnguage (PROMELA) language. These models can then be verified to exhibit the desired functional properties using the SPIN model checker as it directly accepts PROMELA models. The main contribution of the paper lies in identifying the modeling techniques and abstractions that are tailored towards the circuit-switched based NoC architectures. Moreover, we also identify a set of properties that are of interest in the context of NoC and thus can be used with some adaptation to verify any NoC architecture.</p><p>In order to illustrate the utilization and effectiveness of the proposed methodology for the formal verification of realworld NoC architectures, we present the analysis of the Programmable Network on chip (PNoC) architecture <ref type="bibr" target="#b14">[15]</ref>, which a circuit-switched based NoC. It is a lightweight NoC architecture that is specifically designed for FPGA based systems and ensures data transfers with minimal overhead on a dedicated path. PNoC allows flexibility of having numerous router to node configurations along with parameterizable addresses. The main reason behind the choice of this case study is the above-mentioned strengths of this lightweight scheme compared to other traditional NoC techniques, like CLICH Ë <ref type="bibr" target="#b19">[20]</ref>, which consists of a fixed 2D mesh with one routing switch per computing node that makes it unsuitable for heavy data flow applications. Millberg also employed the same switching technique in their Nostrum NOC implementation <ref type="bibr" target="#b21">[22]</ref>.</p><p>The rest of the paper is organized as follows: Section II provides an overview of model checking and the SPIN model checker. The proposed methodology adopted for the verification of circuit-switched based NoC is discussed in Section III. Section IV presents the formal verification of the PNoC architecture. Finally Section V concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. PRELIMINARIES A. Model checking:</head><p>Model checking is a formal verification method for reactive systems. It is an algorithmic technique in which a state-based model of the given system is developed and its specifications are formulated in temporal logic. The model checker then automatically and exhaustively validates that the model is obeying the specifications. Model checking also facilitates debugging by providing error-trails <ref type="bibr" target="#b5">[6]</ref>  <ref type="bibr" target="#b16">[17]</ref>. The verification is based on exhaustive state-space exploration and thus for large models the computation memory and time requirements grow exponentially, i.e, a problem that is usually referred to as the state-space explosion problem. A common remedy to this problem is to abstract away some of the uninteresting details of the model. Similarly, bounded and symbolic model checking techniques are also very helpful in coping with the state-space explosion problem <ref type="bibr" target="#b13">[14]</ref>. Some of the widely used model checking tools are NuSMV, PRISM, CADP and SPIN. We have chosen the SPIN model checker for our work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. SPIN model checker:</head><p>The SPIN model checker is a general tool for verifying the correctness of asynchronous distributed software models in a rigorous and mostly automated fashion <ref type="bibr" target="#b16">[17]</ref>. SPIN utilizes PROMELA (Programming Meta language), which offers communication and concurrency primitives inspired by the process algebras <ref type="bibr" target="#b18">[19]</ref>, as its formal specification language. PROMELA is primarily based on the Dijkstras guarded command language and has a syntax very much like C. The components of the given distributed system are modeled as processes, which are asynchronous in nature. It also supports multiple instances of a process. These processes communicate with each other via channels, which can be buffered or rendezvous. Variables can be declared globally or locally and can have different data types, such as int, bool, byte and short <ref type="bibr" target="#b5">[6]</ref>  <ref type="bibr" target="#b16">[17]</ref>. Arrays and structures are also supported by SPIN. SPIN also supports random interactive guided simulation, which allows user to manually select every proceeding step in the simulation. Verification properties are written in SPIN using the Linear Temporal Logic (LTL). Propositional connectives and temporal operators used in LTL properties are shown in Table <ref type="table">1</ref>  <ref type="bibr" target="#b9">[10]</ref>. The properties are translated to Buchi automaton and then the SPIN built-in search algorithms, i.e., Depth First Search (DFS) or Breadth First Search (BFS) algorithm, search the state-space to check if that property holds for the given model or not. SPIN also has the capability of finding deadlocks or non-progress cycles. The state-space is expanded according to the DFS or BFS mode. Advance options not only allow the user to manually adjust memory size for state-space storage but also limit the state-space expansion.</p><p>Many model checking tools exist and each one excels in one or a set of application domains. For example, NuSMV <ref type="bibr" target="#b11">[12]</ref> is known to provide excellent results for hardware verification and CBMC <ref type="bibr" target="#b12">[13]</ref> and SLAM <ref type="bibr" target="#b27">[28]</ref> are widely used for software verification. The SPIN <ref type="bibr" target="#b16">[17]</ref> model checker caters for a wide range of applications, including both hardware and software systems and protocol verification. Many tools, such as the ABC model checker <ref type="bibr" target="#b8">[9]</ref>, support the verification of only synchronous. SPIN, on the other hand, supports both synchronous as well as asynchronous design verification. Moreover, some other unique characteristics of SPIN include the provision of the visual trail of errors, assertion based verification and the inbuilt properties checking mechanism for deadlocks and livelocks in the system. Finally, SPIN offers state-space reduction by using the partial order technique and the user is allowed to select between the exhaustive or partial space searching options. Thus, we found SPIN as most suitable tool for PNOC verification III. PROPOSED METHODOLOGY There are some general requirements that every NoC is expected to meet. Its architecture should be generic, scalable and able to cope up with faults. In terms of performance, it should exhibit small latency and guaranty throughput. The proposed formal verification methodology for circuit-switched NoC architectures, depicted in Figure <ref type="figure" target="#fig_2">3</ref>, caters for all of these requirements and is primarily composed of the following steps:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Modeling Generic Circuit-Swicthed Based NoC in SPIN</head><p>The proposed methodology allows us to model generic circuit-switched NoC architectures, i.e., any NoC with arbitrary number of nodes and finite number of routers. Each node has a unique identity registered in the router with which it is connected. The router consists of a set of input and outputs, a controller and a communication switch. Router controller registers the address of all of its connected nodes. Moreover, it entertains the request of each node and schedules their access to utilize the switch. The communication switch or the switch box creates the communication path of the target and the master node.</p><p>The following steps allow us to model any NoC architecture in SPIN:</p><p>• Identify process: The first modeling step is to identify the processes in the given NoC architecture. We usually associate a process with every module, i.e., node, router and switch box of the given NoC. The behavior of every module is expressed in the process using its corresponding Finite-State Machine (FSM). Nodes of the circuitswitched NoCs do not require packetisation of the data with long overheads. Multiple nodes, can be modeled as  • Identify Input outputs: Communication among various modules of the NoC is done via channels and thus each process needs to have its own input and output channels. Channels are responsible for delivering message among different processes. It is important to note that SPIN allows unidirectional channels only.</p><p>• Initialization: All the processes and inter module channels have to be initialized. The processes with active prefix allows them to be running in the initial system state but they have a limitation that they cannot accept any argument.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Functional Verification using Simulation</head><p>Once the model is ready in PROMELA, its complete FSM can be seen by the automaton viewer of the SPIN model checker for sanity check. Next we propose to check it via the random and interactive simulation methods of SPIN.</p><p>The randomized test vectors often reveal some critical flaws in the bugs, which can be fixed by updating the PROMELA model. The main motivation of performing this simulation is to be able to catch PROMELA modeling flaws, that usually happen due to human errors before going to the rigorous and thus comparatively time consuming formal verification phase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Formal Function Verification</head><p>As depicted in Figure <ref type="figure" target="#fig_2">3</ref>, we propose to check four functional properties for NoCs, explained below, by model checking.</p><p>Deadlock Freedom: NoC architectures are quite susceptible to enter deadlocks, i.e., a situation under which two nodes are waiting for one another to transmit or receive data. Such deadlocks stall the entire communication and have to be absolutely avoided <ref type="bibr">[11] [18]</ref>. Deadlocks in NoC are mainly introduced from the behavior of the router module. It is almost impossible to guarantee that there is no deadlock in a given router using simulation due to the huge number of possibilities that may cause deadlocks. Whereas, model checking can detect them automatically by checking a no-deadlock condition as an LTL property. Deadlocks may be reported due to a PROMELA modeling error or it could be a result of a system bug. Thus, in case of finding a deadlock, the corresponding error trail must be executed on the NoC model in PROMELA using simulation to identify the cause for addressing it.</p><p>Liveness: SPIN has the capability of verifying liveness properties without providing explicit LTL specifications. This property tracks non-progressing cycles in the system, which are associated with processes that do not halt in their non-critical section or infinitely trap in a non-ending loop.</p><p>Behavioral Properties: The behavioral properties of the given NoC architecture can be checked by formally specifying them in LTL. The translation from LTL to Buchi automaton is handled automatically by SPIN. In the proposed methodology for verifying circuit-switched NoC architectures, we call for verifying mutual exclusion and starvation freedom properties to check the behavior of the given NoC.</p><p>-Mutual exclusion: This property ensures that hardware resources are utilized by one source at a time. It is very important to check this property in the context of NoC since multiple utilization of resources may result in effecting the reliable data transfer. Moreover, the data may not reach the specific target node. Finally it violates circuit-switch behavior, which only allows one node at a time to utilize its resource -Starvation freedom: This property ensures fairness of resource utilization such that no single node will share the resource for a long time. Holding a resource by a single node can lead other requesting nodes to be a continuous wait state, resulting in delayed data transfer. Assertion based verification: SPIN supports assertion based verification as well and thus many interesting conditions can be checked during the verification process. For example, it is extremely undesirable if two nodes are granted access to share the datelines in circuit-switched based NoC and this scenario can be checked by using the following assertion:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Assert(grant1==1&amp;&amp;grant2==1)</head><p>It is a common occurrence to encounter state-space explosion problem during the verification phase. In this case, we propose to reduce the size of the model and thus the state-space by reducing the range granularity of variables or restricting the number nodes in the model.</p><p>The proposed methodology is general enough to be used to formally verify any circuit-switched NoC architecture. For illustrating its practical utilization and effectiveness, we use it in the next section for the formal verification of programmable NoC (PNoC) <ref type="bibr" target="#b14">[15]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. CASE STUDY: PNOC</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Programmable network on chip (PNoC):</head><p>Programmable Network-On-Chip (PNOC) <ref type="bibr" target="#b14">[15]</ref> is a circuitswitched NoC architecture and thus allows data transfers on a dedicated connection. Moreover, it requires no overhead for packetisation, packet header processing or packet buffering. This topology contains series of subnets where multiple nodes are connected to a single router through the router port interfaces. A light handshaking mechanism is required to establish or remove connection from a node. This flexible system allows runtime insertion and removal of nodes. PNoC has a small set of single bit controls signals and receiving (rx), transmitting (tx) signals. Figure <ref type="figure" target="#fig_5">4</ref> shows the connection between two nodes and a single router and more details about the signals can be found in <ref type="bibr" target="#b14">[15]</ref>. The behavior of PNoC nodes, router, switch box and communication processes, which are the main components of any circuit-switched NoC architecture, is explained below;</p><p>Nodes are processing units which can send or receive data. A PNoC node has five control signals and a set of receiving (rx) and transmitting (tx) signals. It can request for service while specifying the target nodes address on the tx address line.</p><p>Router is the core communication block as it controls the circuit switching among the nodes. It listens to node requests and then grants permission to the master node after consulting its routing table. In case when multiple nodes request simultaneously, it non-deterministically grants access to any one of them. Moreover, it also notifies the slave node to establish connection. Once the connection is established between two nodes then they can freely share data. If the desired node or hardware resource (switch box) is busy in entertaining other services, the router sends a pend signal to the requesting node. The router also de-asserts the pend signal after the resource node becomes free. Moreover, it also listens to the release signal from the node incase the node wants to terminate the connection.</p><p>Switch box is the unit that physically connects all the appropriate rx and tx signals of two nodes.</p><p>To establish connection between nodes and router, a simple handshaking mechanism is performed. Master node sends Fig. <ref type="figure">2</ref>. PNoC architecture request to the router along with the address of target node. Router consults its routing table and checks whether the communication link and slave node is free for data communication. Once approved, it sends grant to master and informs the slave node via the slave grant signal. Moreover, it connects rx and tx lines of the master and slave nodes via a switch box. In the write mode, the master node sets tx valid=1 and tx rnw=0, and then captures the returned data from the slave node on rx data lines upon receiving rx valid=1. In the read mode, master nodes set tx valid=1 and tx rnw=1. If the slave wants to suspend the data transfer then it can do so by deasserting its cts signal.</p><p>Once the communication link is established, data is freely shared between nodes and on completion, the node sends a release signal to the router, which ends the communication.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Formal Verification of PNOC in SPIN</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1) Modeling of PNoC in PROMELA</head><p>The PROMELA modeling of PNoC mainly involves three modules, i.e., nodes, router and switch box. We have modeled and analyzed the PNoC for three different configurations i.e., one router with two, four and eight nodes. Nodes are generic in nature and thus have been instantiated multiple times. The pseudo codes of these models along with some description is given below: PNoC Node:</p><p>The node module in PNoC can initiate requests to the router to communicate with other nodes. The node that generates the request is termed as a master node and targeting node is termed as a slave node. The PROMELA model of a PNoC node is given in Pseudo code 1.</p><p>A node is initialized to be in the idle mode. Every node can initiate a request to the router with the address of the target node. This behavior is modeled non-deterministically, such that the request generation and the target node-address are both chosen in a non-deterministic fashion. In case of request generation, the node move to the receiving mode, where it waits for either grant, pend or slave grant signal. On receiving the grant signal, it moves to the node write mode (if the node wants to transmit data) where it sends a set of communication signals. Once the data is being transferred, the node moves to the node windup mode where it sends the release signal to the router; thus requesting end of data transfer. Similarly, if the node wants to read data from other nodes on receiving grant, it moves to the node read mode, where by using a set of communication signals, it receives data and upon completion, it also sends the release signal to the router, thus demanding end of connection.</p><p>When node has to act as a slave upon receiving slave grant, it moves to the slave mode and acts according to the request of read or write from master node. If the hardware resource, such as switch is used by some other node then the router sends a pend signal to the node under consideration, so that it waits until the pend is over and again requests for communication. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PNoC Router:</head><p>The behavior of the router is given in Pseudo code 2. It receives the requests from nodes and consults its routing table to check the availability of the targeting node's address.</p><p>Once the switch becomes free, then the router sends a grant signal to the master and slave nodes. Once the connection is established, the router starts to wait for their release signal. Upon receiving the release signal from both of the communicating nodes, it again moves to the router idle mode, where it waits for further requests of nodes. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Pseudo code of switch box:</head><p>The switch box, mentioned in Pseudo code 3, is controlled by router. All the tx lines are connected to the rx lines of the switch box and vice versa. The switch box is usually in switch idle state. If router enable the switch box then it connects its rx lines with tx lines. Thus, corresponding nodes send their data on these lines. Once data is transferred, the router disables the switch box and disconnects the connection. The switch box again moves to its idle position.</p><p>Pseudo code 3: Switch Box switch idle: ::enable?enb; If enb==0-&gt;goto switch idle; If enb==1-&gt; ::rx_valid connects tx_valid ::rx_rnw connects tx_rnw ::rx_cts connects tx_cts ::rx_data connects tx_data ::rx_addr connects tx_addr-&gt; goto switch idle Initialization process: An initialization process is used to initialize the router, nodes, all of the channels involved in networking and switch box. At first all the global channels are initialized, then the nodes and the router are initialized. For example, for the case of 8 nodes, the code for the node module would be instantiated 8 times.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2) Simulation of PNoC</head><p>After modeling the PNoC architecture in SPIN, simulation is the first check that evaluates its functionality. PNoC modules are modeled in a non-deterministic way. At first, guidedsimulation is performed in order to ensure that all the signals are received properly. Random simulation allows the nodes to behave nondeterministically, a node can randomly send request and address of any other slave node. Any of the 8 nodes can send a request of communication with any other node connected to router. Router listens to these requests and acts accordingly. The track of this randomness can visually be seen via simulation based trails. In this way many unpredicted errors or bugs can be found.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3) Formal verification of PNoC</head><p>As described in our methodology, we checked the liveness and deadlock freedom of our PROMELA model of PNOC and no deadlock and non-progress states were found.</p><p>We also checked the mutual exclusion property to ensure that that hardware resources are utilized by one source at a time. When a PNoC's router sends a grant signal to a node then this particular node should be the only one to use the respective resources. We checked this behavior by using the zero-one-hot relation for all grant signals of all the nodes. In LTL format it can be written as follows:</p><formula xml:id="formula_0">LTL p0 [] (!(grant1 &amp; grant2 &amp; grant3 &amp; grant4 &amp; ......grantn));</formula><p>The grant signal is asserted only when the node is given the authority to read or write as a master. Thus, in order to ensure mutual exclusion only one of the grant signals can be 1. This property was verified for our model of the PNoC, which ensures the mutual exclusions holds for every possible configuration of our model, something that cannot be ascertained via simulation very easily.</p><p>The starvation freedom of our model was checked by ensuring the fairness of resource utilization, i.e., no single node should occupy a resource for a long time. In the case of PNoC, resources are allocated by giving the grant=1 signal to the nodes. Thus, we checked the starvation property by observing the priority array of the router, which stores the process ID of the master nodes. In order to ensure starvation freedom in the PNoC architecture, there should be no continuous repetition of the same process ID in the priority array. This behavior can be expressed as a LTL property as follows: This property states that if any node is granted 1 than eventually in the future it will assert its release signal. In other words, it ensures that no node is granted 1 forever.</p><p>Fairness is also checked by the array method. The node that is given the grant stores its ID in the get id function, which is basically defines an array of node IDs. Thus, the fairness can be ensured if no two consecutive entries in this array are same using the following assertion:</p><formula xml:id="formula_1">Id_one=Array[i]; Id_two=Array[i+1];</formula><p>Assert(Id_one==Id_two);</p><p>We also checked the data reliability of the PNoC architecture by ensuring that the data transmitted from one node is accurately received at the target node. The limitation for checking this behavior is that it can be checked only after complete data reception. Therefore, the assertion based verification is the only way to check this behavior since model checking using LTL properties cannot be used to verify it. This behavior can be checked by the following assertion:</p><formula xml:id="formula_2">Assert (rx_data!=tx_data)</formula><p>This assertion would raise a flag if the transmitted data is not found to be equal to the received data at any point in time of the system execution. This property becomes true only when the data reception is complete at the slave node, which is consistent with the expected behavior as well.</p><p>For the above-mentioned verification of PNoC, a Quad core 2.5 GHz processor running windows 7 professional, SPIN version 6.2.3 along with the ispin version 1.1.0. was used. The PNoC verification is done for a maximum of eight nodes and a single router, which comprises of 11 processes and 500 lines of code.</p><p>The verification was done for the exhaustive storage mode along with the option of working up to maximum depth of 257269. The detail of resource utilization and verification time of each property verified is shown in Figures <ref type="figure">5 and 6</ref>, respectively, for different number of nodes.</p><p>V. CONCLUSIONS This paper presents a formal verification methodology for circuit-switched based NoC architecture. The proposed method mainly utilizes the SPIN model checker to verify the functional properties and quality of service of the given NoC. To the best of our knowledge, this is the first model checking approach for verifying circuit-switched based NoC. For illustration purposes, the paper presents the formal verification of PNoC architecture, which is circuit-switched based flexible NoC. This case study clearly indicates the applicability of the proposed methods to verify other circuit-switched PNoC architectures. We plan to apply our methodology to other circuit-switched PNoC architectures presented in <ref type="bibr" target="#b14">[15]</ref>. Moreover, another interesting future direction is to look at the performance of various circuit-switch PNoC architectures using a probabilistic model checker, like PRISM <ref type="bibr" target="#b0">[1]</ref>.  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Authorized licensed use limited to: Tsinghua University. Downloaded on December 31,2022 at 07:25:34 UTC from IEEE Xplore. Restrictions apply.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Proposed methodology</figDesc><graphic url="image-1.png" coords="4,48.96,57.59,258.39,143.78" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Memory utilization for different node</figDesc><graphic url="image-3.png" coords="7,48.96,57.59,255.13,173.85" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>LTLp5 []((grant[n]==1)-&gt;&lt;&gt;(Release[n]==1));</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Authorized licensed use limited to: Tsinghua University. Downloaded on December 31,2022 at 07:25:34 UTC from IEEE Xplore. Restrictions apply.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Verification Results</figDesc><graphic url="image-4.png" coords="8,61.10,57.59,226.77,181.42" type="bitmap" /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0">Authorized licensed use limited to: Tsinghua University. Downloaded on December 31,2022 at 07:25:34 UTC from IEEE Xplore. Restrictions apply.</note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Authorized licensed use limited to: Tsinghua University. Downloaded on December 31,2022 at 07:25:34 UTC from IEEE Xplore. Restrictions apply.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Prism: A tool for automatic verification of probabilistic systems</title>
		<author>
			<persName><forename type="first">G</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Norman</forename><forename type="middle">A</forename><surname>Hinton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kwiatkowska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Parker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Tools and Algorithms for the Construction and Analysis of Systems</title>
				<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="441" to="444" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Formal methods: Theory becoming practice</title>
		<author>
			<persName><forename type="first">J</forename><surname>Abria</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Universal Computer Science</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">5</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Survey of network on chip (noc) architectures &amp; contributions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Iskander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Shankar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Engineering, Computing and Architecture</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="13" to="27" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Formal verification of fault tolerant noc-based architecture</title>
		<author>
			<persName><forename type="first">M</forename><surname>Andriamiarina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Daoud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Belarbi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Tanougast</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">First International Workshop on Mathematics and Computer Science</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Principles of model checking</title>
		<author>
			<persName><forename type="first">C</forename><surname>Baier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Katoen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Ben-Ari</surname></persName>
		</author>
		<title level="m">Principles of the Spin Model Checker</title>
				<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Xpipes: A network-on-chip architecture for gigascale systems-on-chip</title>
		<author>
			<persName><forename type="first">L</forename><surname>Benini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bertozzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Circuits and Systems Magazine</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="18" to="31" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Formal approach to the verification of networks on chip</title>
		<author>
			<persName><forename type="first">D</forename><surname>Borrione</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Helmy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Pierre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schmaltz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EURASIP J. Embedded Systems</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Abc: An academic industrial-strength verification tool</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Brayton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mishchenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of the 22nd International Conference on Computer Aided Verification</title>
				<meeting>eeding of the 22nd International Conference on Computer Aided Verification</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010-07">July 2010</date>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="page" from="24" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Evaluation and design tradeoffs between circuit-switched and packet-switched nocs for applicationspecific socs</title>
		<author>
			<persName><forename type="first">K.-C</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-S</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-F</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conference</title>
				<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="143" to="148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Formal modeling and verification for network-on-chip</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hsiung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Cherng Lan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Green Circuits and Systems</title>
				<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="299" to="304" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<author>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Giunchiglia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Roveri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NUSMV: a new Symbolic Model Verifier. Number 1633 in</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>Trento, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999-07">July 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Hardware verification using ANSI-C programs as a reference</title>
		<author>
			<persName><forename type="first">Edmund</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Kroening</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ASP-DAC 2003</title>
				<meeting>ASP-DAC 2003</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2003-01">January 2003</date>
			<biblScope unit="page" from="308" to="311" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Handbook of Practical Logic and Automated Reasoning</title>
		<author>
			<persName><forename type="first">J</forename><surname>Harrison</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Pnoc: a flexible circuit-switched noc for fpga-based systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Hilton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">E</forename><surname>Nelson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and Digital Techniques</title>
		<imprint>
			<biblScope unit="volume">153</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="181" to="188" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
	<note>IEE Proceedings</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Formal verification and synthesis for quality-of-service in on-chip networks</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Holcomb</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
		<respStmt>
			<orgName>University of California, Berkeley</orgName>
		</respStmt>
	</monogr>
	<note>Master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The model checker spin</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Holzmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="279" to="295" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Formal verification of deadlock recovering algorithm of heterogeneous noc routing support</title>
		<author>
			<persName><forename type="first">L</forename><surname>Ribeiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Otero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dillenburg</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Formal verification of requirements using spin: A case study on web services</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kazhamiakin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pistore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Roveri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conf. Software Eng. and Formal Methods</title>
				<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="406" to="414" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jantsch</forename></persName>
		</author>
		<title level="m">A network on chip architecture and design methodology</title>
				<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="105" to="112" />
		</imprint>
	</monogr>
	<note>IEEE Computer Society Annual Symposium on VLSI</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">An architecture and compiler for scalable on-chip communication</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Laffely</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Srinivasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tessier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Very Large Scale Integration</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="711" to="726" />
			<date type="published" when="2004">2004</date>
			<publisher>VLSI) Systems</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The nostrum backbone -a communication protocol stack for networks on chip</title>
		<author>
			<persName><forename type="first">R</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Thid</forename><forename type="middle">S</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Millberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Nilsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jantsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on VLSI Design</title>
				<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="693" to="696" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Application of formal methods for system-level verification of network on chip</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">A</forename><surname>Palaniveloo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sowmya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Computer Society Annual Symposium on VLSI</title>
				<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Forever: A complementary formal and runtime verification approach to correct noc functionality</title>
		<author>
			<persName><forename type="first">R</forename><surname>Parikh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Bertacco</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Embedded Computing Systems</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Formal verification of chp specifications with cadp illustration on an asynchronous network-onchip</title>
		<author>
			<persName><forename type="first">G</forename><surname>Salaun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Serwe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Thonnart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Vivet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Asynchronous Circuits and Systems</title>
				<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="73" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Comparison of noc routing algorithms using formal methods</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Sharifi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mohammadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sirjani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Parallel and Distributed Processing Techniques and Applications</title>
				<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="385" to="410" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A comparative performance evaluation of network-onchip architectures under self-similar traffic</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kundu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Parikh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chattopadhyay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Advances in Recent Technologies in Communication and Computing</title>
				<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="163" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A decade of software model checking with slam</title>
		<author>
			<persName><forename type="first">V</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Levin</forename><forename type="middle">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="page">6876</biblScope>
			<date type="published" when="2011-07">July 2011</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A generic implementation model for the verification of networks-on-chips</title>
		<author>
			<persName><forename type="first">T</forename><surname>Van Den Broek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schmaltz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on the ACL2 Theorem Prover and Its Application</title>
				<meeting><address><addrLine>Boston MA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="130" to="134" />
		</imprint>
		<respStmt>
			<orgName>Northeastern Univ.</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Towards formally verified networkson-chips</title>
		<author>
			<persName><forename type="first">T</forename><surname>Van Den Broek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schmaltz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Formal Methods in Computer Aided Design</title>
				<meeting>Formal Methods in Computer Aided Design</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="184" to="187" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Formal verification methodology consideration for network on chips</title>
		<author>
			<persName><forename type="first">B</forename><surname>Venu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Advances in Computing, Communications and Informatics</title>
				<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="220" to="225" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Formal specification of networks-on-chips: Deadlock and evacuation</title>
		<author>
			<persName><forename type="first">F</forename><surname>Verbeek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schmaltz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automation and Test in Europe</title>
				<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="1701" to="1706" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
