<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Gradual Release: Unifying Declassification, Encryption and Key Release Policies</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Aslan</forename><surname>Askarov</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">Chalmers University of Technology</orgName>
								<address>
									<postCode>412 96</postCode>
									<settlement>Göteborg</settlement>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Andrei</forename><surname>Sabelfeld</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">Chalmers University of Technology</orgName>
								<address>
									<postCode>412 96</postCode>
									<settlement>Göteborg</settlement>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Gradual Release: Unifying Declassification, Encryption and Key Release Policies</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">B4017FF4C1EA9328969CB86EC5A1BB7D</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:40+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Information security has a challenge to address: enabling information-flow controls with expressive information release (or declassification) policies. Existing approaches tend to address some aspects of information release, exposing the other aspects for possible attacks. It is striking that these approaches fall into two mostly separate categories: revelation-based (as in information purchase, aggregate computation, moves in a game, etc.) and encryption-based declassification (as in sending encrypted secrets over an untrusted network, storing passwords, etc.).</p><p>This paper introduces gradual release, a policy that unifies declassification, encryption, and key release policies. We model an attacker's knowledge by the sets of possible secret inputs as functions of publicly observable outputs. The essence of gradual release is that this knowledge must remain constant between releases. Gradual release turns out to be a powerful foundation for release policies, which we demonstrate by formally connecting revelation-based and encryption-based declassification. Furthermore, we show that gradual release can be provably enforced by security types and effects.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Information security <ref type="bibr" target="#b31">[32]</ref> has a challenge to address: enabling information flow controls with expressive information release (or declassification) policies <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b41">42,</ref><ref type="bibr" target="#b33">34]</ref>. In a scenario of systems that operate on data with different sensitivity levels, the goal is to provide security assurance via restricting the information flow within the system. However, allowing no flow whatsoever from secret (high) inputs to public (low) outputs (as prescribed by noninterference <ref type="bibr" target="#b15">[16]</ref>) is too restrictive because many systems deliberately declassify information from high to low.</p><p>Characterizing and enforcing declassification policies is the focus of an active area of research <ref type="bibr" target="#b33">[34]</ref>. However, existing approaches tend to address selected aspects of informa-tion release, exposing the other aspects for possible attacks. It is striking that these approaches fall into two mostly separate categories: revelation-based (as in information purchase, aggregate computation, moves in a game, etc.) and encryption-based declassification (as in sending encrypted secrets over an untrusted network, storing passwords, etc.). It is essential that declassification policies support a combination of these categories: for example, a possibility to release the result of encryption should not be abused to release cleartext through the same declassification mechanism.</p><p>This paper introduces gradual release, a policy that unifies declassification, encryption, and key release policies. As we explain below, the latter is not only a useful feature, but also a vital component for connecting revelationbased and encryption-based declassification. We model an attacker's knowledge by the sets of possible secret inputs as functions of publicly observable outputs. The essence of gradual release is that this knowledge must remain constant between releases. Gradual release turns out to be a powerful foundation for release policies, which we demonstrate by formally connecting revelation-based and encryption-based declassification.</p><p>When it comes to handling encryption, there is a demand for expressing rich policies beyond declassification at the point of encryption. To this end, a desirable ingredient in declassification policies is reasoning about released keys. In bit commitment, premature revelation of the bit should be prevented by not releasing the secret key until necessary. In a media distribution scenario-when large media is distributed in encrypted form, and the key is supplied on the date of media release-early key release should be prevented. In addition, key release policies are important for mental poker <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b3">4]</ref> (for playing poker without a trusted third party), where the participants reveal their keys for each other at the end of the game, in order to prove that they were not cheating during the game. In this protocol too, it should not be possible to release secret keys prematurely or encrypt with a key that has already been released.</p><p>Gradual release allows for reasoning about newly generated and released keys. In fact, this combination turns out to be crucial for connecting revelation-based and encryptionbased declassification. We show that gradual release for revelation-based declassification can be represented by a rewardingly simple encryption-based declassification: declassifying an expression corresponds to encrypting the expression with a fresh key and immediately releasing the key.</p><p>As a result, gradual release is, to the best of our knowledge, the first framework to unify revelation-based and encryption-based declassification policies. Furthermore, we show that gradual release can be provably enforced by security types and effects.</p><p>Structure-wise, Section 2 introduces gradual release, illustrates its properties, and shows how to enforce it by a security type system for a simple declassification-enabled language. Section 3 enriches the language with key generation, encryption, and key release primitives. Section 4 applies gradual release to the enriched language. Section 5 presents a type and effect system that enforces gradual release for the enriched language. Section 6 provides useful examples of typed programs. Section 7 discusses related work, and Section 8 concludes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Gradual release</head><p>Gradual release is a general notion, defined in terms of events (which are classified into low and high, with some of the low ones classified as release events). Of particular interest are language-based instantiations of this model, where events are generated by program constructs. A direct benefit of such instantiations is the possibility of enforcing gradual release by static analysis. To be concrete (but without loss of generality), we present gradual release for a simple imperative language with declassification. We show that gradual release is a conservative extension of noninterference and demonstrate how to provably enforce gradual release by a security type system.</p><p>Language Figure <ref type="figure" target="#fig_0">1</ref> presents the syntax of the language, which contains expressions e and commands c. For simplicity, we assume that variables are assigned one of the two security levels: L (low) or H (high), forming a simple security lattice, where L H. These levels are recorded in the security environment Γ, a mapping from variable names to security levels. The construct declassify(e) in an assignment is provided for declassifying the level of e to L. </p><formula xml:id="formula_0">Γ if ∀x . Γ(x) L =⇒ M 1 (x) = M 2 (x). This is denoted as M 1 ∼ Γ M 2 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Semantics and low events</head><p>As is standard, expressions evaluate according to rules of the form M, e ⇓ n, where M, e is a configuration consisting of the memory M and the expression to evaluate e, and n is the resulting value. Semantics for commands are expressed by small-step transitions between configurations. These transitions have either the form M, c A transition is low if it is due to an assignment to a low variable or termination. The event α ∈ { , } records whether the transition is low (reflected by the label , where is either the projection M L of the low part of M or a termination event ↓) or otherwise (reflected by the empty label ). We write M, c -→ * M , c (resp. M, c -→ * M ) when M , c (resp. M ) is reachable from M, c by a sequence of small steps, where represents the sequence of generated low events. We classify the termination event ↓ as low. If an event in a sequence is a termination event, then no other events may be generated after it.</p><p>A particular kind of low events are due to declassify commands. We refer to those events as release events. Release events record the points of intentional information release by a command. The complete semantics of the language is available in an accompanying technical report <ref type="bibr" target="#b4">[5]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Knowledge</head><p>We let the attacker observe the low projection M 0 L of the initial memory M 0 , and all intermediate low events 1 , . . . , n generated during a run of a command c. Given these observations, the attacker may infer the set of initial memories that could possibly have led to these events. We refer to this set as the attacker's knowledge about the initial memory.</p><p>Semantically, the knowledge is a set of tuples, where each tuple represents a possible initial memory. For example, consider the program l := h 1 + h 2 and a sample run that yields a low event where (l) = 10. The attacker's knowledge in this case is all such memories that the sum of h 1 and h 2 is 10:</p><formula xml:id="formula_1">h 1 h 2 . . . { (1,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>. . }</head><p>Note that in our terminology knowledge corresponds to uncertainty about the tuples in the knowledge set: any of the tuples is a possible input. The actual knowledge of the attacker is that tuples outside the knowledge set are not possible inputs.</p><p>As the computation progresses, the uncertainty might decrease because new observations might render some initial inputs impossible. This means that the knowledge set may shrink with time.</p><p>Let L(c, M 0 L ) be the set of possible low event sequences that a program c may generate along terminating traces that start in some memory whose low projection is M 0 L :</p><formula xml:id="formula_2">L(c, M 0 L ) { | ∃M, M . M L = M 0 L ∧ M, c -→ * M }</formula><p>Based on a program c, a low projection of the initial memory M 0 L , and a (possibly empty) sequence of low events ∈ L(c, M 0 L ), where L(c, M 0 L ) denotes the prefix closure of L(c, M 0 L ), the knowledge is defined as:</p><formula xml:id="formula_3">k(c, M 0 L , ) {M | M L = M 0 L ∧ ∃M , c . M, c -→ * M , c ∨ M, c -→ * M }</formula><p>This set records all possible inputs that lead to observing when starting with initial memories that agree with M 0 L on the low variables. This definition of knowledge is termination-sensitive (cf. <ref type="bibr" target="#b31">[32]</ref>) because observing that program does not enter an infinite loop may lead to refining the knowledge.</p><p>Given a command c and the low projection of a memory M 0 L , we also define the initial knowledge k(c, M 0 L ) that corresponds to all possible initial memories that lead to termination:</p><formula xml:id="formula_4">k(c, M 0 L ) {M | M L = M 0 L ∧ ∃M , . M, c -→ * M }</formula><p>Using this definition, we define a termination-insensitive (cf. <ref type="bibr" target="#b31">[32]</ref>) version of knowledge as:</p><formula xml:id="formula_5">k ↓ (c, M 0 L , ) k(c, M 0 L , ) ∩ k(c, M 0 L )</formula><p>As we expect, the attacker may not "forget" the knowledge about the initial states, i.e., each new observable event may only refine the knowledge: Proposition 1 (Monotonicity of knowledge). For a command c, some M 0 L , and n ∈ L(c, M 0 L ), where n = 1 , . . . , n , we have</p><formula xml:id="formula_6">∀i . 1 ≤ i ≤ n . k ↓ (c, M 0 L , i-1 ) ⊇ k ↓ (c, M 0 L , i )</formula><p>where k ↓ (c, M 0 L , 0 ) k(c, M 0 L ). The proofs of this and the following results are available in an accompanying technical report <ref type="bibr" target="#b4">[5]</ref>.</p><p>Noninterference We present a definition of noninterference and demonstrate how to represent it in the knowledgebased setting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1 (Noninterference</head><formula xml:id="formula_7">). A command c satisfies non- interference if whenever M 1 ∼ Γ M 2 , M 1 , c 1 -→ * M 1 , and M 2 , c 2 -→ * M 2 then 1 = 2 (and M 1 ∼ Γ M 2 ).</formula><p>The definition requires that when starting with lowequivalent memories, terminating traces must agree on their low events (and, as a consequence, on the low parts of the resulting memories). This corresponds to the absence of flows from high to low data.</p><p>We show that this flavor of noninterference is straightforwardly expressible in the knowledge-based setting:</p><formula xml:id="formula_8">Proposition 2. A command c satisfies noninterference if and only if ∀M 0 L , ∈ L(c, M 0 L ) . k ↓ (c, M 0 L , ) = k(c, M 0 L )</formula><p>The proposition states that the attacker's knowledge does not benefit from observing a run of a noninterfering program: all memories that agree with M 0 L on the low part are possible inputs regardless of the observed low events .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Gradual release</head><p>With every new low event produced by a program run, the attacker's knowledge may become more precise, i.e., the set of possible initial memories may become smaller. The only intentional points when this knowledge may be narrowed down are the release events, as specified by declassification primitives. Gradual release accepts changes in the knowledge that are caused by the release events and requires that no other low events may affect the knowledge.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2 (Gradual release). A command c satisfies gradual release if for all M 0</head><p>L and ∈ L(c, M 0 L ), where n = 1 , . . . , n , n ≥ 1, of which r1 , . . . , rm are all release events, we have:</p><formula xml:id="formula_9">∀i . 1 ≤ i ≤ n . (∀j . r j = i) =⇒ k ↓ (c, M 0 L , i-1 ) = k ↓ (c, M 0 L , i )</formula><p>where, as before, k ↓ (c, M 0 L , 0 ) k(c, M 0 L ). The gradual release requirement on the evolution of knowledge is illustrated in Figure <ref type="figure" target="#fig_2">2</ref>, where the vertical axis is uncertainty, and the horizontal axis is time.</p><p>In the examples throughout the paper, variables l, l 1 , . . . and h, h 1 , . . . are assumed to be low and high, respectively. Examples of programs that are rejected by gradual release are: where the knowledge is narrowed down from all possible high inputs to exactly one, and:</p><formula xml:id="formula_10">if h then l := declassify(h1)</formula><p>where the knowledge is narrowed down to memories where h is zero in the case when no low events are observable before termination.</p><p>Examples of programs that are accepted by gradual release are:</p><formula xml:id="formula_11">l := declassify(h)</formula><p>where the release event due to declassification justifies the change in the knowledge, and:</p><formula xml:id="formula_12">l:=declassify(h != 0); if l then l1 := declassify(h1)</formula><p>where the non-zero test expression is explicitly released before the choice whether to declassify h 1 is made.</p><p>In contrast to some declassification definitions (e.g., <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b32">33]</ref>, but in agreement with others (e.g., <ref type="bibr" target="#b28">[29]</ref>), gradual release assumes that the attacker observes more information about traces (namely, effects of assignments to low variables) than visible initial/final values. Moreover, the attacker observes some events produced by partial program executions. This enables natural extensions to languages with input/output: low assignments can be viewed as implicit output on a low channel. Note that breaches in security due to events that are not happening are caught by gradual release thanks to termination events. Recall that in the second insecure example above, if the only observable event by the attacker is termination, then the attacker may deduce that the assignment in the conditional did not happen, and that the initial value of h must be zero.</p><p>In a recent classification of declassification <ref type="bibr" target="#b33">[34]</ref>, release policies are classified with respect to the what, who, where, and when dimensions of declassification. Under this classification, gradual release is primarily a where policy because it emphasizes that release is only allowed via declassification points. This allows us capturing some flows that are not represented by other dimensions. For example, the following program is accepted by pure what definitions such as delimited release <ref type="bibr" target="#b32">[33]</ref> that ignore the where aspect: Note that at the point of declassification, the attacker learns nothing about the value of h 2 . However, after reaching the assignment l 2 := h 2 the attacker's knowledge will allow inferring the value h 2 . This is rejected by the release policy because the assignment l 2 := h 2 is not a declassification.</p><p>Compared to several where definitions, gradual release does not rely on state resetting in-between transitions. Consider, for example, the following program:</p><formula xml:id="formula_13">l := declassify (h); l := h;</formula><p>This innocent program is a false negative for the intransitive downgrading <ref type="bibr" target="#b26">[27]</ref>, non-disclosure <ref type="bibr" target="#b1">[2]</ref>, flow locks <ref type="bibr" target="#b7">[8]</ref>, and WHERE <ref type="bibr" target="#b25">[26]</ref> definitions. These definitions reject the program above because they demand security in the presence of state resetting. The program is rejected by them because resetting the secret state after declassification may reintroduce secret into h before it is assigned to l. However, the program is secure according to gradual release because the attacker does not gain any new knowledge from observing the effect of the last assignment.</p><p>As a sanity check for our definition, we show that for programs without release, gradual release is equivalent to noninterference. This property is known as the conservativity principle of declassification <ref type="bibr" target="#b33">[34]</ref>. The principle follows from Proposition 2 and because the attacker's knowledge for declassification-free programs must remain constant over the execution of the program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 3. If a command c is free of declassification then c satisfies gradual release if and only if c satisfies noninterference.</head><p>A final remark on the dimensions: although gradual release is primarily a where policy, it can be also viewed as a relative what policy. Indeed, what attacker learns remains constant with respect to the last release point. Further, it is possible to fully integrate the what dimension into gradual release. Assume a knowledge evolution sequence that is provided explicitly as a policy (for example, in terms of escape hatch expressions as in delimited release <ref type="bibr" target="#b32">[33]</ref>). In addition to the demand on constant knowledge in-between releases, an enhanced policy might require that each refinement of knowledge is in strict accordance with what can be learned from observing the respective escape hatch expression from the sequence in the policy.</p><p>Enforcement It is straightforward to enforce gradual release by a security type system. Figure <ref type="figure">3</ref> presents the typing rules for expressions and commands. The rules for catching explicit and implicit flows are standard <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b38">39]</ref>. The</p><formula xml:id="formula_14">(T-INT) Γ n : L (T-VAR) Γ(x) = σ Γ x : σ (T-OP) Γ e 1 : σ 1 Γ e 2 : σ 2 Γ e 1 op e 2 : σ 1 σ 2 (T-SKIP) Γ, pc skip (T-ASGN) Γ e : σ pc σ Γ(x) Γ, pc x := e (T-SEQ) Γ, pc c 1 Γ, pc c 2 Γ, pc c 1 ; c 2 (T-IF) Γ e : σ Γ, pc σ c i i = 1, 2 Γ, pc if e then c 1 else c 2 (T-WHILE) Γ e : σ Γ, pc σ c Γ, pc while e do c (T-DECL) pc Γ(x) Γ, pc x := declassify(e)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 3. Type rules for the simple language</head><p>only non-standard rule is (T-DECL), which disallows declassification inside of conditionals and loops with sensitive guards. We call such a conditional or loop high context and track it with the context type variable pc. By requiring pc Γ(x) at declassification points, we ensure that if pc is H then we might be inside a high context, and, hence, we may not assign the result of declassification to a variable at level L.</p><p>Note that no information about the declassified expression e is used in the rule for declassification (T-DECL). This is sensible because gradual release is a where policy, not a what policy, and so the value (and even the syntax) of the declassified expression is unimportant. That the type system enforces gradual release is guaranteed by the following theorem: Theorem 1. If Γ, pc c then c satisfies gradual release.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Language with cryptographic primitives and key release</head><p>This section presents an enriched language that includes cryptographic primitives and key release features.</p><p>Syntax Figure <ref type="figure" target="#fig_5">4</ref> displays the syntax of the language, which is based on the one presented in <ref type="bibr" target="#b2">[3]</ref>. Values and keys have corresponding security levels. Values are either low (L) or high (H). The key levels declare the maximum value security level the key can safely encrypt. In particular, a key at level high key (HK) may safely encrypt low and high values, whereas a key at level low key (LK) may only safely encrypt low values. Keys at level RK correspond to the previously secret keys that have been released and may only safely encrypt public values.</p><p>Basic types t consist of integers int and ciphertexts enc γ τ obtained by encrypting data of primitive type τ with keys at level γ. Primitive types τ consist of basic types labeled with security levels t σ, key types key γ, and pairs (τ, τ ) of primitive types.</p><p>Apart from expressions for encryption and decryption, expressions are standard: integers, variables, total binary operators, pair formation, and projection. Commands include the standard commands of an imperative language, a command for generating a new key at a given security level, and a command for releasing keys.</p><p>We assume that all variables x used in program text are typed with primitive types according to a typing environment Γ as x : Γ(x). We also define the low projection Γ L of the typing environment, which only includes low variables. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Semantics</head><formula xml:id="formula_15">= n | k | (v, v) | u</formula><p>The system is parameterized over two symmetric encryption schemes-one for the low key level γ = LK, and one for the high key level γ = HK-represented by triples </p><formula xml:id="formula_16">SE γ = (K γ , E γ , D γ ),</formula><formula xml:id="formula_17">γ (k , E γ (k , v)) = v.</formula><p>The reason for the use of different encryption schemes for different security levels is to lay the ground for extensions to systems with more than two security levels. In such a system we would have one encryption schema at each security level, trusted to encrypt values up to and including the security level. As stated above, the key sets Key LK and Key HK of the two different encryption schemes are distinct. We assume that lk ranges over Key LK and hk over Key HK .</p><p>The full environment (or, simply, environment) E is a tuple (M, G, R), where the memory environment M is a mapping from variable names to values; the key-stream environment G is a mapping from key levels to streams that generate fresh keys; and the released-key environment R is a set of released keys.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Semantics for expressions</head><p>Similarly to the simple language in Section 2, the semantics for expressions have the form M, e ⇓ v, where v is the result of evaluating expression e in memory M .</p><p>Figure <ref type="figure" target="#fig_6">5</ref> presents the rules specific to the treatment of cryptography. Encryption (S-ENC) and decryption (S-DEC) both use the encryption schemes SE γ introduced above. The rest of the rules can be found in the full version <ref type="bibr" target="#b4">[5]</ref> of the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Semantics for commands</head><p>Similarly to Section 2, the semantics for commands have either the form E, c α -→ E , c , where E and E are the initial and resulting environments, c and c are the initial and resulting commands, and α ∈ { , } is an event annotation (where is the projection E L of the environment E = (M , G , R ) defined as</p><formula xml:id="formula_18">E L = (M L , G (L), R )); or the form E, c ↓ -→ E , which</formula><p>indicates termination in the environment E . The distinctive primitive of the language is a key release command release(k) that updates the set of released keys with the value of the key k, in case the key is high. In Figure <ref type="figure" target="#fig_7">6</ref>, we display the two most interesting rules for commands. Key generation (S-NEWKEY) takes a variable name and a level of the key to be generated and assigns the topmost element in the key stream associated to that level in the key-stream environment to the variable. The rule (S-KEY-RELEASE) for the key release primitive generates a release event and updates the set of released keys R in the environment. The rest of the rules can be found in the full version <ref type="bibr" target="#b4">[5]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Gradual release for the enriched language</head><p>This section applies the gradual release approach to the language defined in Section 3. Although the language does not have a declassification construct, we show how to model revelation-based declassification using key generation, encryption, key release, and decryption. We formally connect this model to gradual release in the simple language from Section 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Encryption model</head><p>We adopt the encryption model of <ref type="bibr" target="#b2">[3]</ref> and consider nondeterministic encryption schemes with initial vectors. As foreshadowed in Section 3, encryption schemes are represented as triples of the form (K, E, D), where K is a key generation algorithm, E is an encryption algorithm, and D is a decryption algorithm. The encryption algorithm is a function of a key, a plaintext, and an initial vector (which we sometimes omit when its value is unimportant). For the same key and plaintext it returns different ciphertexts depending on the value of the initial vector. Two ciphertexts are low-related if they have been encrypted with the same initial vector iv:</p><formula xml:id="formula_19">∀k 1 , k 2 , v 1 , v 2 . E(k 1 , v 1 , iv) . = E(k 2 , v 2 , iv)</formula><p>This relation has the following properties: (i) different ciphertexts produced by one plaintext and one key have different initial vectors and are not low-related, and (ii) since every plaintext and key produce ciphertexts using all initial vectors, for each ciphertext produced by one plaintext and key there will be exactly one low-related ciphertext for every other choice of plaintext and key. This construction prevents occlusion, which would happen if we treated all ciphertexts as equal, as illustrated in an example that follows Proposition 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Low-equivalence</head><p>Let E 1 ∼ Γ E 2 denote that the environments E 1 and E 2 are low-equivalent with respect to the environment type Γ (i.e., their low projections are the same).</p><p>The low-equivalence relation, presented in Figure <ref type="figure">7</ref>, draws on one in <ref type="bibr" target="#b2">[3]</ref>. In addition, it also reflects that once a key has been released, it is unsafe to encrypt with this key or, more precisely, assign the result of the encryption to a low variable.</p><p>Low-equivalence is defined structurally with respect to the type of its arguments and the set of released keys r. For example, two high keys are indistinguishable (i.e., related by low-equivalence) if none of them has been released (rule (LE-KEY-SK)). On the other hand, only equivalent values of (S-ENC) </p><formula xml:id="formula_20">M, e 1 ⇓ k M, e 2 ⇓ v k ∈ Key γ u = E γ (k , v) M, encrypt γ (e 1 , e 2 ) ⇓ u (S-DEC) M, e 1 ⇓ k M, e 2 ⇓ u k ∈ Key γ v = D γ (k , u) M, decrypt γ (e 1 , e 2 ) ⇓ v</formula><formula xml:id="formula_21">G(γ) = k • ks (M, G, R), newkey(x, γ) -→ (M [x → k ], G[γ → ks], R) (S-KEY-RELEASE) M, e ⇓ k k ∈ Key γ (M, G, R), release(e) r:(ML,G(L),S∪R) -→ (M, G, S ∪ R)</formula><p>where The rules that define the low-equivalence of encrypted values are worth highlighting. The rules (LE-ENC-L1) and (LE-ENC-L2) both require ciphertexts to be low-related by the relation .</p><formula xml:id="formula_22">S = {k } if γ = HK, ∅ otherwise</formula><p>= on encrypted values. Their additional demands on the ciphertexts depend on whether the encryption key is released and what its type is. The first rule (LE- ENC-L1), when γ = RK, requires that low-equivalent ciphertexts obtained with released keys must agree on the value of the key and plaintext (because anyone can decrypt them). This is achieved by demanding that keys and plaintexts are low-equivalent with respect to the types tolow (key γ) and tolow (τ ). The function tolow (•), defined in Figure <ref type="figure">7</ref>, converts high primitive types into low ones.</p><p>Similarly to released keys, the demand for low keys (LE- ENC-L1, γ = LK) is that plaintexts are low-equivalent with respect to the type tolow (τ ). The only demand for encryption with high keys (LE-ENC-L2) is that the resulting values should be low-equivalent with respect to the primitive type τ of the encryption type.</p><p>Uninitialized values (denoted by •) are low-equivalent (rule (LE-ENC-L3)). The rule (LE-ENC-H) relates high ciphertexts if one of them is uninitialized or their primitive type structures are the same (an auxiliary predicate struct(τ, v), which holds whenever v has type structure τ , is given in Figure <ref type="figure">7</ref>). Note that an uninitialized value is lowequivalent to any other value. This is also reflected in the rule (LE-MEM), where v • is either a value or •.</p><p>Gradual release for the enriched language Before we proceed to gradual release for the enriched language, we define low-equivalence on event sequences.</p><p>Note that the released-key environments, which are explicitly recorded by low events, provide only a par-tial view of what keys may be known to the attacker. For example, the value of the key k 2 in the expression encrypt HK (k 1 , (x, k 2 )) is not contained in the released-key environment after k 1 is released. Nevertheless, using k 2 for encrypting high values after the release of k 1 would be disastrous since the attacker knows the exact value of k 2 and, hence, can decrypt ciphertexts encrypted with it. Therefore, the set of all released keys r is computed, in a Dolev-Yao style <ref type="bibr" target="#b13">[14]</ref>, by traversing low events and accumulating the keys that depend on the ones that are already released. We use an accumulator function r(τ, v, R) defined inductively on a variable type τ , a value of that type v, and an initial set of released keys R:</p><formula xml:id="formula_23">r(enc γ τ L, u,R) = {r(tolow (τ ), v, R) | ∃v, k . v = D γ (k , u) ∧ (k ∈ R ∨ γ = LK)} r(enc γ τ H, u, R) = ∅ r(int σ, v, R) = ∅ r(key LK, k , R) = ∅ r(key HK, k , R) = ∅ r(key RK, k , R) = {k } r((τ 1 , τ 2 ), (v 1 , v 2 ), R) = r(τ 1 , v 1 , R) ∪ r(τ 2 , v 2 , R)</formula><p>For a given typing environment Γ and a sequence of low events ( 1 , . . . , n ), where i = (M i , G i , R i ), we let:</p><formula xml:id="formula_24">r 0 = R n , and r j = n i=1 {r(Γ(x), M i (x), r j-1 ) | x ∈ dom (Γ)}</formula><p>The set r is then defined as r k such that r k = r k+1 . Such a k exists because the set of keys that can be extracted from the sequence of low events is finite.</p><p>Two sequences of low events and are low-equivalent if the numbers of events in each of the sequences are the same, the sets of all released keys that are computed from each of them are equivalent, and the sequences agree on every respective element, i.e., memories, key generating streams, and released-key environments are low-equivalent:</p><formula xml:id="formula_25">(LE-KEY-LK) lk ∼ r key LK lk (LE-KEY-RK) hk ∈ r hk ∼ r key RK hk (LE-KEY-SK) hk i ∈ r i = 1, 2 hk 1 ∼ r key HK hk 2 (LE-INT-L) n ∼ r int L n (LE-INT-H) n 1 ∼ r int H n 2 (LE-ENC-L3) • ∼ r encγ τ L • (LE-PAIR) v 11 ∼ r τ1 v 21 v 12 ∼ r τ2 v 22 (v 11 , v 12 ) ∼ r (τ 1,τ2) (v 21 , v 22 ) (LE-MEM) ∀x ∈ dom (Γ).M i (x) = v • i (i = 1, 2) =⇒ v • 1 ∼ r Γ(x) v • 2 M 1 ∼ r Γ M 2 (LE-KGEN1) k 1 ∼ r key γ k 2 K 1 ∼ r γ K 2 k 1 • K 1 ∼ r γ k 2 • K 2 (LE-KGEN2) G 1 (HK) ∼ r HK G 2 (HK) G 1 (LK) ∼ r LK G 2 (LK) G 1 ∼ r G 2 (LE-ENC-H) ∃j . u j = • ∨ struct(enc γ τ H, u i ) (i = 1, 2) u 1 ∼ r encγ τ H u 2 (LE-ENC-L2) ∃v i , k i . v i = D γ (k i , u i ) i = 1, 2 k 1 ∼ r key HK k 2 v 1 ∼ r τ v 2 u 1 . = u 2 u 1 ∼ r encHK τ L u 2 (LE-ENC-L1) ∃v i , k i . v i = D γ (k i , u i ) i = 1, 2 k 1 ∼ r tolow (key γ) k 2 v 1 ∼ r tolow (τ ) v 2 u 1 . = u 2 u 1 ∼ r encγ τ L u 2 tolow (t σ) = t L tolow (key LK) = key LK tolow (key HK) = key RK tolow (key RK) = key RK tolow ((τ 1 , τ 2 )) = (tolow (τ 1 ), tolow (τ 2 )) struct(int σ, n) struct(key γ, k ) struct(τ 1 , v 1 ) struct(τ 2 , v 2 ) struct((τ 1 , τ 2 ), (v 1 , v 2 )) ∃v, k . v = D γ (k , u) struct(key γ, k ) struct(τ, v) struct(enc γ τ σ, u) Figure 7. Low-equivalence R i = R i r( n ) = r( n ) = r M i ∼ r Γ M i G i ∼ r G i i = 1 . . . n</formula><p>n ∼ Γ n Similarly to the simple language, we define the set of possible low-event sequences. We assume that initial environments (which we indicate with a superscript as in E 0 ) have the form (M, G, ∅), i.e., their released-key sets are empty. In such an environment, we let M (x) = • for all such x that x : enc γ τ σ, i.e., all variables of ciphertext type are uninitialized. Given a command c and a projection of an initial environment E 0 L , the set of possible low events L(c, E 0 L ) is:</p><formula xml:id="formula_26">L(c, E 0 L ) { | ∃E, E . E L ∼ Γ E 0 L ∧ E, c -→ * E }</formula><p>The definition of knowledge is in order, also similar to the one for the simple language. Given the low projection of an initial environment E 0 L and a (possibly empty) sequence of low events ∈ L(c, E 0 L ), where L(c, E 0 L ) denotes the prefix closure of L(c, E i L ), the knowledge k(c, E 0 L , ) of the attacker is defined as:</p><formula xml:id="formula_27">k(c, E 0 L , ) {E | E L ∼ Γ E 0 L ∧ ∃E , c , . ( E, c -→ * E , c ∨ E, c -→ * E ) ∧ ∼ Γ }</formula><p>A new ingredient-the low-equivalence of low-event sequences ∼ Γ -is used in the definition, which allows for relating ciphertexts that are obtained from different keys and plaintexts. This prevents the knowledge from becoming more precise. Otherwise, publishing a result of an encryption with a high key would narrow down the knowledge about the key and the plaintext behind the ciphertext to their exact values, which is infeasible to infer for the attacker. Accordingly, the definition of the initial knowledge is:</p><formula xml:id="formula_28">k(c, E 0 L ) {E | E L ∼ Γ E 0 L ∧ ∃E , . E, c -→ * E } and the termination-insensitive knowledge is: k ↓ (c, E 0 L , ) k(c, E 0 L , ) ∩ k(c, E 0 L )</formula><p>The definition of gradual release for the enriched language follows Definition 2 for the simple language:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3 (Gradual release). A command c satisfies gradual release if for all low projections of initial environments E 0</head><p>L such that R 0 = ∅ and sequences of low events ∈ L(c, E 0 L ), where n = ( 1 , . . . , n ), n ≥ 1, of which r1 , . . . , rm are all release events, we have:</p><formula xml:id="formula_29">∀i . 1 ≤ i ≤ n . (∀j . r j = i) =⇒ k ↓ (c, E 0 L , i-1 ) = k ↓ (c, E 0 L , i )</formula><p>where k ↓ (c, E 0 L , 0 ) k(c, E 0 L ). We illustrate the definition by simple examples (more interesting examples are deferred to Section 5).</p><p>The following program is accepted by gradual release:</p><p>k := newkey(HK); l := encryptHK(k, h);</p><p>Different low-event sequences that can be produced by this program correspond to different values of the variable l.</p><p>Since the encryption key is high, every value of l is lowequivalent to ciphertexts produced by all other possible keys and plaintexts. Therefore, for each possible sequence of low events that this program may generate, the knowledge contains all possible keys and plaintexts, i.e., it is equal to the initial knowledge and remains constant throughout all runs. Gradual release rejects the following program:</p><p>k := newkey(HK); l := encryptHK(k, h); l':= h;</p><p>Similar to an example in Section 2, the last assignment narrows down the set of possible initial values for the variable h to exactly one. On the other hand, gradual release accepts this program:</p><p>k := newkey(HK); l:=encryptHK(k, h); release (k); l':= h;</p><p>There are four low events in this program: the encryption, release statement, last assignment, and termination. As in the previous example, publishing the result of encryption does not change the knowledge. The release statement, however, triggers a change in the low-equivalence for the value of l: once the key k is released, it is only related with ciphertexts that agree with l both on the value of the key and the plaintext. This corresponds to refining the knowledge to the exact values of k and h. Thus, the last assignment to l does not make the knowledge more precise. Gradual release accepts this program since the only point where the knowledge changes is the release event.</p><p>Conservativity with respect to cryptographicallymasked flows As a sanity check, we demonstrate that Definition 3 is a conservative extension of possibilistic noninterference.</p><p>Our possibilistic security definition is based on the one of cryptographically-masked flows <ref type="bibr" target="#b2">[3]</ref>, although it represents an attacker that observes event sequences rather than final environments. Assume T (c, E) is the set of possible event sequences generated by a command c in an environment E. A command c satisfies possibilistic noninterference if:</p><formula xml:id="formula_30">∀E 1 , E 2 . E 1 ∼ Γ E 2 ∧ T (c, E j ) = ∅, j = 1, 2 =⇒ ∀ 1 ∈ T (c, E 1 ) ∃ 2 ∈ T (c, E 2 ) . 1 ∼ Γ 2</formula><p>That is, for every pair of low-equivalent environments and configurations that terminate in these environments, and for each event sequence generated by running the first configuration there is a low-equivalent event sequence generated by running the second one (and vice versa by symmetry).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 4. If a command c is free of key release primitives, then c satisfies gradual release if and only if c satisfies possibilistic noninterference.</head><p>This proposition parallels Proposition 3. If there is no key release, then the attacker's knowledge must stay unchanged throughout execution. Therefore, this proposition reduces to showing an analogue of Proposition 2, which is straightforward.</p><p>Consider the following code, which is inspired by an occlusion example from <ref type="bibr" target="#b2">[3]</ref>. The program below is intuitively insecure: depending on the value of h the value of y is either a new encryption, or the copy of x. An attacker observing that x and y are different can derive that the first branch has been taken.</p><p>x := encryptHK(k1, h1); if h then y := encryptHK(k2, h2); else y := x;</p><p>Thanks to the initial-vector mechanism (described in the beginning of the section), the program is rejected by both gradual release and possibilistic noninterference. An initial memory M , where the value for h is 1, produces a sequence of low events where the final values v x and v y of x and y, respectively, are such that v x . = v y . On the other hand, a memory M , where the value of h is 0 is not a part of the knowledge. Indeed, under M , it is possible to produce a low-event sequence where v = v x and v is the final value of both x and y under M , but then, since the second branch is taken, it implies v . = v y . This means that we cannot reach the final memory with the value v y for y from the memory M , and, therefore, M is not a part of the knowledge. Because the knowledge is refined, and there are no release events to justify the refinement, the above program is rejected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Relation to gradual release for the simple language</head><p>As another sanity check, we establish a relation to the definition of gradual release (Definition 2) for the simple language (Section 2). The combination of the key generation, encryption/decryption, and key release features in the enriched language turns out to be crucial for connecting encryptionbased declassification to revelation-based information release. We can translate the general revelation-based declassification command in the following way: for some fresh temporary variable t. Assuming that the transformation does not change other commands than de-classifications, we arrive at the following formal connection between the two definitions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 5. A command c in the simple language satisfies gradual release (Definition 2) if and only if command c</head><p>obtained from c by transformation (c → c ) in the enriched language satisfies gradual release (Definition 3).</p><p>As an example, consider the following command in the simple language: In the context with no information about the values of the variables of h 1 and h 2 , this program (as well as the source of the transformation) is rejected by the gradual release since the last assignment leaks the exact value of the variable h that is unknown to the attacker otherwise.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Enforcement</head><p>This section presents a type and effect system that enforces gradual release for the enriched language. The type system uses an extended typing environment in which type annotations for keys are lifted to contain unique names κ ∈ KeyNames:</p><formula xml:id="formula_31">ext. basic types t ::= int | enc κ τ ext. prim. types τ ::= t σ | key κ | (τ , τ )</formula><p>Such an environment can be easily obtained by enumerating all occurrences of key types in the variable environment Γ; the resulting extended environment is denoted as Γ.</p><p>The type system is also parameterized over a dependency analysis that tracks possible and definite key dependencies in a program. A dependency relation is maintained throughout the typing rules, which makes the type system aware of the key names that may or must have been released at every program point. Since key names may appear inside tuples and encryption types, dependency relations track dependencies between extended types. The typing rules for commands thus have the form A, Γ, pc c ⇒ A , where A and A are the initial and final dependency relations.</p><p>To access the dependency relation, the typing rules employ an interface which we describe below. An accompanying technical report <ref type="bibr" target="#b4">[5]</ref> describes a graph transformationbased implementation that matches this interface. ::= upd (A, conn) analysis comb.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Analysis interface and requirements</head><p>::= join (A 1 , A 2 ) fresh type ::= fresh (A, τ) may-type ::= type May (A, τ ) must-type ::= type Must (A, τ )</p><p>Type connectors together with the operator upd (A, conn) are used for updating the dependency relation. The τ connector marks the extended type τ as unrelated to any other type. The τ1 → τ2 connector indicates that if τ1 is released then τ2 is released as well. The κ connector specifies that the key name κ is released.</p><p>Joining relations is done by the operator join (A 1 , A 2 ) which combines the information from A 1 and A 2 . The operator fresh (A, τ) takes a dependency relation A and a primitive type τ and returns an extended type τ that has the same structure as τ , but the key names in it are fresh. This operator may be used in the extended environment construction and in the typing rule for variable lookup.</p><p>Obtaining the results of the analysis is done via the functions type May (A, τ ) and type Must (A, τ ). These functions cast the extended type τ to a primitive type taking into account all possible (resp. definite) key dependencies in A.</p><p>Given an environment E = (M, G, R), a dependency relation A, and an extended typing environment Γ, we say that A enforces E, denoted by A, Γ |= E, when for all key names that occur in Γ the following holds:</p><p>1. If the analysis returns that a key name may not have been released, then key values in the memory environment associated with that name are not in the set of all released keys 2. If the analysis returns that a key name must have been released, then key values in the memory environment associated with that name are in the set of all released keys.</p><p>Our demands on the analysis implementation can be expressed as follows:</p><p>(T-VAR) </p><formula xml:id="formula_32">Γ(x) = τ1 τ : fresh (A, Γ(x)) A = upd (A, τ , τ → τ1 , τ1 → τ ) A, Γ x : τ , A (T-ENC1) A, Γ e 1 : key κ, A 1 A 1 , Γ e 2 : τ , A 2 type May (A 1 , key κ) = key HK A 3 = upd (A 2 , key κ → τ ) A, Γ encrypt HK (e 1 , e 2 ) : enc κ τ L, A 3 (T-ENC2) A, Γ e 1 : key κ, A 1 A 1 , Γ e 2 : τ , A 2 type May (A 1 , key κ) = key γ γ = HK lvl (τ ) = σ A 3 = upd (A 2 , key κ → τ ) A, Γ encrypt γ (e 1 , e 2 ) : enc κ τ σ, A 3 (T-DEC1) A, Γ e 1 : key κ 1 , A 1 A 1 , Γ e 2 : enc κ2 τ σ, A 2 type Must (A 1 , key κ 1 ) = key γ A, Γ decrypt γ (e 1 , e 2 ) : τ σ , A 2 (T-DEC2) A, Γ e 1 : key κ 1 , A 1 A 1 , Γ e 2 : enc κ2 τ σ, A 2 type Must (A 1 , key κ 1 ) = key RK type Must (A 2 , key κ 2 ) = key RK A, Γ decrypt RK (e 1 , e 2 ) : tolow (τ ) σ , A 2</formula><formula xml:id="formula_33">A, Γ, pc c ⇒ A ∧ A, Γ |= E ∧ E, c -→ * E =⇒ A , Γ |= E</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Expression typing rules</head><p>The rules for expressions have the form A, Γ e : τ, A , where A tracks dependencies created by the expression e. Figure <ref type="figure" target="#fig_11">8</ref> presents the rules for non-standard expressions, while the other rules can be found in <ref type="bibr" target="#b4">[5]</ref>.</p><p>The rule for variable lookup (T-VAR) looks up the type of the variable in the extended environment and creates a fresh type in the dependency relation that is connected to the original variable. The two rules for encryption correspond to encryption with high non-released keys, and to encryption with keys that have low or released levels. In the first case, the rule (T-ENC1) allows the resulting type of the expression to have the low type L, if it is known that the key name used for encryption is definitely not released. The second rule (T-ENC2) preserves the original level of the plaintext σ; it uses the function lvl (•) that returns the Both rules update the dependency relations with information that the release of the ciphertext is now dependent on the release of the encryption key. The rules for decryption require that the level of the key used for decryption matches the key level of the encrypted value. The result of decryption is tainted by the security level of the encrypted value, where the taint function is defined as follows:</p><formula xml:id="formula_34">(T-SKIP) A, Γ, pc skip ⇒ A (T-ASGN) Γ(x) = τ A, Γ e : τ , A pc lvl (Γ(x)) type May (A , τ ) &lt;: Γ(x) type Must (A , τ ) &lt;: Γ(x) A = upd (A , τ , τ → τ , τ → τ ) A, Γ, pc x := e ⇒ A (T-SEQ) A, Γ, pc c 1 ⇒ A A , Γ, pc c 2 ⇒ A A, Γ, pc c 1 ; c 2 ⇒ A (T-IF) A, Γ e : int σ, A A , Γ, pc σ c i ⇒ A i i = 1, 2 A, Γ, pc if e then c 1 else c 2 ⇒ join (A 1 , A 2 ) (T-WHILE) join (A, A ), Γ e : int σ, A A , Γ, pc σ c ⇒ A A, Γ, pc while e do c ⇒ join (A , A ) (T-NEWKEY) Γ(x) = key γ γ = RK Γ(x) = τ A = upd (A, τ ) pc lvl (Γ(x)) A, Γ, pc newkey(x, γ) ⇒ A (T-RELEASE) A, Γ e : key κ, A pc = L A = upd (A , κ ) A, Γ, pc release(e) ⇒ A</formula><formula xml:id="formula_35">(t σ) σ = t (σ σ ) (τ 1 , τ 2 ) σ = (τ σ 1 , τ σ 2 ) (key LK) L = key LK (key RK) L = key RK (key HK) σ = key HK</formula><p>The interesting case, which uses the must analysis, is the rule (T-DEC2) that relaxes the returning value if both encryption and decryption keys are known to be released.  The rule for assignment (T-ASGN) looks up the type of the variable in both normal and extended environments. It evaluates the type of the expression to assign in the extended environment and its may and must types, as recorded in the dependency relation. We require both of these types to be a subtype of the variable type. Next, we update the dependency relation with the new dependency between extended types. As is standard, the rule also checks that the pc label is bounded by the security level of the assigned variable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Command typing rules</head><p>The rule (T-SEQ) propagates the updated dependencies through sequential composition. The rule for conditionals (T-IF) evaluates the security level of the guard to check both branches; the resulting dependency relation is obtained by joining the resulting relations for c 1 and c 2 . In a similar flavor, the rule (T-WHILE) demands that there exists a pair of dependency relations A and A such that we can type the loop body in an environment starting from A and producing A . In addition, A is a result of evaluating loop guard in an environment obtained by joining A and A .</p><p>The rule (T-NEWKEY) for new key generation checks that the pc label is no greater than the level of the key to generate. It looks up the extended type of the key variable in the extended environment and removes dependencies of this type in the dependency relation. The rule (T-RELEASE) is the one where key names are marked as released. It also enforces that release only happens in low context (under low pc).</p><p>Figure <ref type="figure" target="#fig_14">10</ref> demonstrates the key-related part of enforcement of the type system for high keys. The type system tracks the state in a simple automaton for each key name and rejects the program if its (statically approximated) execution paths might lead to a transition that is not prescribed by the automaton. Soundness We denote by A 0 dependency relations that contain no released-key names. The type system provably enforces gradual release for the enriched language: Theorem 2. If A 0 , Γ, pc c ⇒ A then c satisfies gradual release.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Examples</head><p>This section provides examples of secure programming in the context of media distribution, mental poker, and bit commitment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Media distribution</head><p>In this example we consider the scenario of media distribution. Large media is distributed in encrypted form prior to the official release date. On the date of release, secret keys are supplied to the consumers.</p><p>This protocol can be implemented in our language as follows: The media is distributed via variable outMedia, whose type enc HK (int H) L says that it stores low data which results from encrypting high data with high keys. At the media release time, the high key is released and published in the variable outK, whose type says that it stores released keys. This program is typable by the type system from Section 5 and, thus, is secure.</p><p>Note that premature key release is prevented by the type system. For example, if the lines release(k); outMedia := encryptHK(k,media); are moved ahead of the encryption, then the program will be rejected as insecure.</p><p>Mental poker A pattern similar to media distribution is used in mental poker <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b3">4]</ref> protocols. Encryptions during the game correspond to card shuffling without trusted third party. At the end of the game, there is a verification phase to verify that no player was cheating. As with the fragment above, the type system guarantees that keys may not be released before the game phase is over.</p><p>Bit commitment using symmetric cryptography Bit commitment is a common building block in security protocols. We are primarily concerned with the confidentiality of the committed bit for our purposes. In a typical run between two principals, one of the principals commits its bid by encrypting a tuple consisting of the bid and a random value obtained from the other principal. The tuple is encrypted using a fresh key, which is later released in the revelation phase. The following listing shows an example implementation of the protocol for the committing principal. The comments in the program connect the protocol steps to the code. This program, too, is typable by the type system from Section 5 and, thus, is secure.</p><p>To see how premature key release attacks are stopped, observe that the type system prevents from confusing steps 2 and 3 in the protocol implementation. The type system guarantees that no encryption with a released key may take place.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related work</head><p>Much recent and ongoing work on language-based information security concerns policies for declassification. However, many policies tend to emphasize only some of the what, who, where, and when dimensions of declassification, leaving the other dimensions vulnerable for attacks <ref type="bibr" target="#b33">[34]</ref>. As mentioned in Section 1, it is striking that these approaches (an overview of which can be found in <ref type="bibr" target="#b33">[34]</ref>) fall into two mostly separate categories: revelation-based and encryption-based declassification.</p><p>Compared to other approaches to declassification, the distinctive features of gradual release include a transparent underlying semantic guarantee (the intuition of what is assured is clear), its scalability to rich policies (which include encryption and key release), and its practical enforcement.</p><p>The need for key release policies is motivated by a mental poker case study <ref type="bibr" target="#b3">[4]</ref>, where an important phase of the protocol is based on key revelation and verification that the participants were not cheating during the game.</p><p>Gradual release is inspired by work on deducible information flow <ref type="bibr" target="#b12">[13]</ref> (which builds on earlier work <ref type="bibr" target="#b40">[41,</ref><ref type="bibr" target="#b24">25]</ref> on possibilistic security) that characterizes noninterferencelike policies for abstract event systems in terms of what secret events can be deducible from public output events. Deducible information flow, however, has not been investigated in the context of information release (apart from simple partial flows) or language-based security.</p><p>A logic-based approach to representing attackers' knowledge about system events has been investigated in <ref type="bibr" target="#b18">[19]</ref>. This approach is based on Sutherland's nonde-ducibility <ref type="bibr" target="#b35">[36]</ref> Similarly to these approaches, we do not consider user strategies <ref type="bibr" target="#b39">[40,</ref><ref type="bibr" target="#b29">30]</ref> that can infer additional knowledge.</p><p>Our starting point in modeling information flow in the presence of encryption is cryptographically-masked flows <ref type="bibr" target="#b2">[3]</ref>. In the present work, we recast cryptographicallymasked flows in terms of small-step semantics, which is needed for sensitivity as to when keys are released.</p><p>Secrecy by typing [1] offers a type system for enforcing secrecy for a calculus that models cryptographic protocols.</p><p>The assumption is that the attacker may not decrypt ciphertexts encrypted with secret keys. Key release and general declassification policies are, however, not considered.</p><p>Cryptographic types <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b10">11]</ref> facilitate access-control enforcement in a distributed programming language. However, they provide no information-flow guarantees.</p><p>Noninterference modulo trusted functions <ref type="bibr" target="#b19">[20]</ref> is based on the indistinguishability of program segments that are free of trusted cryptographic functions. In the spirit of intransitive noninterference <ref type="bibr" target="#b30">[31]</ref>, noninterference modulo trusted functions is a where declassification policy that does not provide guarantees for traces with declassification events.</p><p>Examples of when and where definitions that do not address cryptographic primitives are noninterference "until" <ref type="bibr" target="#b9">[10]</ref>, intransitive downgrading <ref type="bibr" target="#b26">[27]</ref>, non-disclosure <ref type="bibr" target="#b1">[2]</ref>, flow locks <ref type="bibr" target="#b7">[8]</ref>, and WHERE <ref type="bibr" target="#b25">[26]</ref>. Noninterference "until" ignores the remainder of a trace once a declassification has happened. The other definitions rely on attacker models that are stronger than necessary <ref type="bibr" target="#b33">[34]</ref>: wrapping release statements by downgrading commands <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b25">26]</ref>, flow declarations <ref type="bibr" target="#b1">[2]</ref> or flow locks <ref type="bibr" target="#b7">[8]</ref> would pose stronger requirements on security than gradual release because they demand security in the presence of state resetting (cf. Section 2).</p><p>Secrecy despite compromise <ref type="bibr" target="#b17">[18]</ref> explores the problem of compromised principals within π-calculi, where secure channels can be modeled via shared secret keys, and compromised principals correspond to released keys. This work, however, only tracks a limited form of information flow: explicit flows.</p><p>Relative secrecy discusses release policies associated with particular primitives: releasing the result of matching a query to a secret password <ref type="bibr" target="#b37">[38]</ref> and releasing the result of computing a one-way function <ref type="bibr" target="#b36">[37]</ref>. The underlying guarantee is that the attacker cannot learn the secret in polynomial time in the size of the secret by running a program that satisfies relative secrecy.</p><p>A notable line of work <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b22">23]</ref> deals with computational guarantees for languages with statically distinguished keys. Computational attacker models have been also investigated in the context of π calculus <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b27">28]</ref>. No general declassification policies are supported by these approaches.</p><p>Declassification policies based on intransitive noninterference have been explored for reactive systems <ref type="bibr" target="#b5">[6]</ref>. A dis-tinguishing feature of this work is the possibility of computational characterization of data declassification. While our goal (of having a practically enforceable security condition at the programming-language level) is initially different, we share the ultimate goal of considering computational adversaries with <ref type="bibr" target="#b5">[6]</ref> (see the future work).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>We have presented gradual release, a framework for unifying declassification, encryption, and key release policies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contributions</head><p>The benefits of the framework include the following:</p><p>• Policy-perimeter defense The framework is the first to provide assurance for policies that include all of declassification, encryption, and key release;</p><p>• Connection between revelation-based and encryptionbased declassification Not only does the framework combine revelation-based and encryption-based policies, but also formally connects the two kinds of declassification: gradual release for revelation-based declassification can be represented by a reassuringly simple encryption-based declassification: declassifying an expression corresponds to encrypting the expression with a fresh key and immediately releasing the key. In this light, the framework is the first to unify revelationbased and encryption-based declassification policies.</p><p>• Conservativity We have shown that gradual release for programs with no declassification or encryption is equivalent to a form of noninterference; in addition, we have shown that gradual release with no key release (but possibly with encryption) is equivalent to a form of possibilistic noninterference; and</p><p>• Type-based enforcement We have demonstrated that gradual release can be enforced by type and effect systems. The benefit of cryptographic and key-release primitives is truly realized in a distributed setting. A natural extension of our language is one with actors that run concurrently and interact with each other by sending and receiving messages on declared channels. While we can build on the messagepassing enabled language <ref type="bibr" target="#b2">[3]</ref> for which cryptographicallymasked flows were introduced, we cannot directly reuse its security model because it considers actors in isolation. In presence of key release, it is not sufficient to view the actors independently because a key release by one actor may affect other actors. Thus, a goal for future work in this direction is to reason about whole-system security. In general, this involves reasoning about information flows due to blocking, scheduling, races, and other flows that may arise in concurrent systems (cf. <ref type="bibr" target="#b31">[32]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Future work</head><p>Although not in the scope of this paper, a high-priority direction for work on cryptographically-masked flows (with and without key release) is showing that semantic security under chosen plaintext attack (SEM-CPA) <ref type="bibr" target="#b16">[17]</ref> (i.e., whatever is efficiently computable about the cleartext given the ciphertext, is also efficiently computable without the ciphertext) with an appropriate message authentication code (e.g., INT-PTXT <ref type="bibr" target="#b6">[7]</ref>) for the underlying cryptographic primitives is sufficient for the semantic security of programs (with ample restrictions on key cycles) that satisfy the condition of cryptographically-masked flows.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>eFigure 1 .</head><label>1</label><figDesc>Figure 1. Simple imperative language</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>α-→</head><label></label><figDesc>M , c , which corresponds to a step from configuration M, c to configuration M , c , or the form M, c ↓ -→ M , which corresponds to termination in the memory M .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Gradual release</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>h1 := h2; h2 := 0; l1 := declassify (h2); h2 := h1; l2 := h2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>First we define values and environments, which are used in the following definitions of the semantics for expressions and commands. Let n ∈ Z range over integers and k ∈ Key = Key LK ∪ Key HK range over keys, where Key LK and Key HK are disjoint. We assume that released keys belong to the set of high keys Key HK . Values are built up by ordinary values: integers, keys, and pairs of values; together with encrypted values u ∈ U = U LK ∪ U HK . values ∈ Value v ::</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Enriched language</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Selected semantic rules for expressions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Selected semantic rules for commands</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>l</head><label></label><figDesc>:= declassify(e) → k := newkey(HK); t := encrypt HK (k, e); release(k); l := decrypt RK (k, t);</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>if h then l := declassify(h1); else l := declassify(h2); l' := h; The transformation produces the following result in the enriched language: if h then k := newkey(HK); t := encryptHK(k, h1); release (k); l := decryptRK(k, t); else k := newkey(HK); t := encryptHK(k, h2); release (k); l := decryptRK(k, t); l' := h; This command is semantically equivalent to the following: k := newkey (S); if h then h' := h1 else h' := h2; t := encryptHK(k, h'); release (k); l := decryptRK(k, t); l':= h;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Let A denote a key dependency relation. The interface for accessing A is then defined by the following syntax: type connectors conn ::= τ | τ1 → τ2 | κ analysis transf.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. Selected type rules for expressions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. Type rules for commands</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>Figure 9 presents the command type rules. The rules for a command c have the form A, Γ, pc c ⇒ A where A and A are the dependency relations before and after executing c.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 10 .</head><label>10</label><figDesc>Figure 10. Enforcement for high keys</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>While gradual release emphasizes the where dimension of information release it only offers a relative (to the previous point of release) assurance as to what data is released. As sketched in Section 2, it is possible to fully integrate the what dimension by connecting each release point to a policy that regulates what can be leaked.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2007" xml:id="foot_0"><p>IEEE Symposium on Security and Privacy(SP'07) 0-7695-2848-1/07 $20.00 © 2007</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>l := h 2007 IEEE Symposium on Security and Privacy(SP'07) 0-7695-2848-1/07 $20.00 © 2007</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2007" xml:id="foot_2"><p>IEEE Symposium on Security and Privacy(SP'07)</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2007" xml:id="foot_3"><p>IEEE Symposium on Security and Privacy(SP'07) 0-7695-2848-1/07 $20.00 ©</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We wish to thank Daniel Hedin and David Sands for helpful discussions on an earlier draft of this paper. This work was funded in part by the Sixth Framework programme of the European Community under the MOBIUS project FP6-015905, in part by VINNOVA, and in part by the Swedish Research Council.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Secrecy by typing in security protocols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="749" to="786" />
			<date type="published" when="1999-09">Sept. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On declassification and the non-disclosure policy</title>
		<author>
			<persName><forename type="first">A</forename><surname>Almeida Matos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Boudol</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Computer Security Foundations Workshop</title>
		<meeting>IEEE Computer Security Foundations Workshop</meeting>
		<imprint>
			<date type="published" when="2005-06">June 2005</date>
			<biblScope unit="page" from="226" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Cryptographicallymasked flows</title>
		<author>
			<persName><forename type="first">A</forename><surname>Askarov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hedin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sabelfeld</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Symp. on Static Analysis</title>
		<meeting>Symp. on Static Analysis</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2006-08">Aug. 2006</date>
			<biblScope unit="page" from="353" to="369" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Security-typed languages for implementation of cryptographic protocols: A case study</title>
		<author>
			<persName><forename type="first">A</forename><surname>Askarov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sabelfeld</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. European Symp. on Research in Computer Security</title>
		<meeting>European Symp. on Research in Computer Security</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2005-09">Sept. 2005</date>
			<biblScope unit="volume">3679</biblScope>
			<biblScope unit="page" from="197" to="221" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Gradual release: Unifying declassification, encryption and key release policies</title>
		<author>
			<persName><forename type="first">A</forename><surname>Askarov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sabelfeld</surname></persName>
		</author>
		<ptr target="http://www.cs.chalmers.se/∼aaskarov/sp07full.pdf" />
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
		<respStmt>
			<orgName>Chalmers University of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Intransitive non-interference for cryptographic purposes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Backes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pfitzmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. on Security and Privacy</title>
		<meeting>IEEE Symp. on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2003-05">May 2003</date>
			<biblScope unit="page" from="140" to="153" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Authenticated encryption: Relations among notions and analysis of the generic composition paradigm</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Namprempre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -Asiacrypt 2000</title>
		<imprint>
			<date type="published" when="2000-01">Jan. 2000</date>
			<biblScope unit="volume">1976</biblScope>
			<biblScope unit="page" from="531" to="545" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Flow locks: Towards a core calculus for dynamic flow policies</title>
		<author>
			<persName><forename type="first">N</forename><surname>Broberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sands</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. European Symp. on Programming</title>
		<meeting>European Symp. on Programming</meeting>
		<imprint>
			<biblScope unit="volume">3924</biblScope>
			<biblScope unit="page" from="180" to="196" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Practical mental poker without a TTP based on homomorphic encryption</title>
		<author>
			<persName><forename type="first">J</forename><surname>Castellà-Roca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Domingo-Ferrer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Riera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Borrell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Progress in Cryptology-Indocrypt</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003-12">Dec. 2003</date>
			<biblScope unit="volume">2904</biblScope>
			<biblScope unit="page" from="280" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Security policies for downgrading</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Computer and Communications Security</title>
		<imprint>
			<date type="published" when="2004-10">Oct. 2004</date>
			<biblScope unit="page" from="198" to="209" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Type-based distributed access control</title>
		<author>
			<persName><forename type="first">T</forename><surname>Chothia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Duggan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vitek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Computer Security Foundations Workshop</title>
		<meeting>IEEE Computer Security Foundations Workshop</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="170" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Certification of programs for secure information flow</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Denning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Denning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. of the ACM</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="504" to="513" />
			<date type="published" when="1977-07">July 1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Nondeterministic nointerference and deducible information flow</title>
		<author>
			<persName><forename type="first">C</forename><surname>Dima</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Enea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gramatovici</surname></persName>
		</author>
		<idno>2006-01</idno>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
		<respStmt>
			<orgName>University of Paris 12, LACL</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">On the security of public-key protocols</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dolev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">29</biblScope>
			<biblScope unit="page" from="198" to="208" />
			<date type="published" when="1983-08">Aug. 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Cryptographic types</title>
		<author>
			<persName><forename type="first">D</forename><surname>Duggan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Computer Security Foundations Workshop</title>
		<meeting>IEEE Computer Security Foundations Workshop</meeting>
		<imprint>
			<date type="published" when="2002-06">June 2002</date>
			<biblScope unit="page" from="238" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Security policies and security models</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Goguen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. on Security and Privacy</title>
		<meeting>IEEE Symp. on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="1982-04">Apr. 1982</date>
			<biblScope unit="page" from="11" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Journal of Computer and System Sciences</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="270" to="299" />
		</imprint>
	</monogr>
	<note>Probabilistic encryption</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Secrecy despite compromise: Types, cryptography, and the pi-calculus</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jeffrey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CON-CUR&apos;05, number 3653 in LNCS</title>
		<meeting>CON-CUR&apos;05, number 3653 in LNCS</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2005-08">Aug. 2005</date>
			<biblScope unit="page" from="186" to="201" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Secrecy in multi-agent systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Halpern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>O'neill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Computer Security Foundations Workshop</title>
		<meeting>IEEE Computer Security Foundations Workshop</meeting>
		<imprint>
			<date type="published" when="2002-06">June 2002</date>
			<biblScope unit="page" from="32" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Trusted declassification: High-level policy for a security-typed language</title>
		<author>
			<persName><forename type="first">B</forename><surname>Hicks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcdaniel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hicks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGPLAN Workshop on Programming Languages and Analysis for Security</title>
		<meeting>ACM SIGPLAN Workshop on Programming Languages and Analysis for Security</meeting>
		<imprint>
			<date type="published" when="2006-06">June 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Semantics and program analysis of computationally secure information flow</title>
		<author>
			<persName><forename type="first">P</forename><surname>Laud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. European Symp. on Programming</title>
		<meeting>European Symp. on Programming</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001-04">Apr. 2001</date>
			<biblScope unit="volume">2028</biblScope>
			<biblScope unit="page" from="77" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Handling encryption in an analysis for secure information flow</title>
		<author>
			<persName><forename type="first">P</forename><surname>Laud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. European Symp. on Programming</title>
		<meeting>European Symp. on Programming</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003-04">Apr. 2003</date>
			<biblScope unit="volume">2618</biblScope>
			<biblScope unit="page" from="159" to="173" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A type system for computationally secure information flow</title>
		<author>
			<persName><forename type="first">P</forename><surname>Laud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vene</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Fundamentals of Computation Theory</title>
		<meeting>Fundamentals of Computation Theory</meeting>
		<imprint>
			<date type="published" when="2005-08">Aug. 2005</date>
			<biblScope unit="volume">3623</biblScope>
			<biblScope unit="page" from="365" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A probabilistic poly-time framework for protocol analysis</title>
		<author>
			<persName><forename type="first">P</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Scedrov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Computer and Communications Security</title>
		<imprint>
			<date type="published" when="1998-11">Nov. 1998</date>
			<biblScope unit="page" from="112" to="121" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Possibilistic definitions of security -An assembly kit</title>
		<author>
			<persName><forename type="first">H</forename><surname>Mantel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Computer Security Foundations Workshop</title>
		<meeting>IEEE Computer Security Foundations Workshop</meeting>
		<imprint>
			<date type="published" when="2000-07">July 2000</date>
			<biblScope unit="page" from="185" to="199" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Controlling the what and where of declassification in language-based security</title>
		<author>
			<persName><forename type="first">H</forename><surname>Mantel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Reinhard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. European Symp. on Programming</title>
		<meeting>European Symp. on Programming</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Controlled downgrading based on intransitive (non)interference</title>
		<author>
			<persName><forename type="first">H</forename><surname>Mantel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sands</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Asian Symp. on Programming Languages and Systems</title>
		<meeting>Asian Symp. on Programming Languages and Systems</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004-11">Nov. 2004</date>
			<biblScope unit="volume">3302</biblScope>
			<biblScope unit="page" from="129" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Probabilistic polynomial-time process calculus and security protocol analysis</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. European Symp. on Programming</title>
		<meeting>European Symp. on Programming</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001-04">Apr. 2001</date>
			<biblScope unit="volume">2028</biblScope>
			<biblScope unit="page" from="23" to="29" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Enforcing robust declassification and qualified robustness</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sabelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zdancewic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Computer Security</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="157" to="196" />
			<date type="published" when="2006-05">May 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Information-flow security for interactive programs</title>
		<author>
			<persName><forename type="first">K</forename><surname>O'neill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Clarkson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Computer Security Foundations Workshop</title>
		<meeting>IEEE Computer Security Foundations Workshop</meeting>
		<imprint>
			<date type="published" when="2006-07">July 2006</date>
			<biblScope unit="page" from="190" to="201" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Noninterference, transitivity, and channelcontrol security policies</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Rushby</surname></persName>
		</author>
		<idno>CSL-92-02</idno>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>SRI International</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Language-based informationflow security</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sabelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J. Selected Areas in Communications</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="5" to="19" />
			<date type="published" when="2003-01">Jan. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A model for delimited information release</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sabelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. International Symp. on Software Security (ISSS&apos;03)</title>
		<meeting>International Symp. on Software Security (ISSS&apos;03)</meeting>
		<imprint>
			<biblScope unit="volume">3233</biblScope>
			<biblScope unit="page" from="174" to="191" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Declassification: Dimensions and principles</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sabelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sands</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Computer Security</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Adleman</surname></persName>
		</author>
		<title level="m">Mental poker. Mathematical Gardner</title>
		<imprint>
			<date type="published" when="1981">1981</date>
			<biblScope unit="page" from="37" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">A model of information</title>
		<author>
			<persName><forename type="first">D</forename><surname>Sutherland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. National Computer Security Conference</title>
		<meeting>National Computer Security Conference</meeting>
		<imprint>
			<date type="published" when="1986-09">Sept. 1986</date>
			<biblScope unit="page" from="175" to="183" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Secure introduction of one-way functions</title>
		<author>
			<persName><forename type="first">D</forename><surname>Volpano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Computer Security Foundations Workshop</title>
		<meeting>IEEE Computer Security Foundations Workshop</meeting>
		<imprint>
			<date type="published" when="2000-07">July 2000</date>
			<biblScope unit="page" from="246" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Verifying secrets and relative secrecy</title>
		<author>
			<persName><forename type="first">D</forename><surname>Volpano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Symp. on Principles of Programming Languages</title>
		<meeting>ACM Symp. on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="2000-01">Jan. 2000</date>
			<biblScope unit="page" from="268" to="276" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">A sound type system for secure flow analysis</title>
		<author>
			<persName><forename type="first">D</forename><surname>Volpano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Irvine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Computer Security</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="167" to="187" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Information flow in nondeterministic systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T</forename><surname>Wittbold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. on Security and Privacy</title>
		<meeting>IEEE Symp. on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="144" to="161" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">A general theory of security properties</title>
		<author>
			<persName><forename type="first">A</forename><surname>Zakinthinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">S</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. on Security and Privacy</title>
		<meeting>IEEE Symp. on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="1997-05">May 1997</date>
			<biblScope unit="page" from="94" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Challenges for information-flow security</title>
		<author>
			<persName><forename type="first">S</forename><surname>Zdancewic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Programming Language Interference and Dependence (PLID)</title>
		<meeting>Programming Language Interference and Dependence (PLID)</meeting>
		<imprint>
			<date type="published" when="2004-08">Aug. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
