<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Epsilon Transformation Language</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Dimitrios</forename><forename type="middle">S</forename><surname>Kolovos</surname></persName>
							<email>dkolovos@cs.york.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of York</orgName>
								<address>
									<postCode>YO10 5DD</postCode>
									<settlement>Heslington</settlement>
									<region>York</region>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Richard</forename><forename type="middle">F</forename><surname>Paige</surname></persName>
							<email>paige@cs.york.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of York</orgName>
								<address>
									<postCode>YO10 5DD</postCode>
									<settlement>Heslington</settlement>
									<region>York</region>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Fiona</forename><forename type="middle">A C</forename><surname>Polack</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of York</orgName>
								<address>
									<postCode>YO10 5DD</postCode>
									<settlement>Heslington</settlement>
									<region>York</region>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">The Epsilon Transformation Language</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">414773B8DE5556F211433BAC27B4BF43</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T10:10+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Support for automated model transformation is essential for realizing a Model Driven Development (MDD) process. However, model transformation is only one of the many tools in a model engineering toolkit. To apply MDD in the large, automated support for a number of additional tasks such as model comparison, merging, validation and model-to-text transformation, is essential. While a number of successful model transformation languages have been currently proposed, the majority of them have been developed in isolation and as a result, they face consistency and integration difficulties with languages that support other model management tasks. We present the Epsilon Transformation Language (ETL), a hybrid model transformation language that has been developed atop the infrastructure provided by the Epsilon model management platform. By building atop Epsilon, ETL is seamlessly integrated with a number of other taskspecific languages to help to realize composite model management workflows.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The ability to automatically transform between models expressed in different languages (metamodels), technical spaces <ref type="bibr" target="#b6">[1]</ref>, or levels of abstraction is of paramount importance to the wide-spread adoption of Model-Driven Development (MDD). Although various approaches to automated model transformation have been proposed, the current consensus is that specialized languages, such as QVT <ref type="bibr" target="#b7">[2]</ref> and ATL <ref type="bibr" target="#b8">[3]</ref>, which provide a mixture of declarative and imperative constructs, are most suitable for specifying model transformations.</p><p>While model transformation has been characterized as the heart and soul of MDD <ref type="bibr" target="#b9">[4]</ref>, it constitutes only one of the tools in the model engineering toolkit; automating other tasks such as model-to-text transformation, model comparison, validation and merging is of significant, if not of equal, importance. Moreover, it is essential that task-specific languages used in a model engineering environment are consistent and interoperable, so that the users can compose complex workflows of model management operations with enhanced reuse and minimal (unintentional) diversity.</p><p>While a number of successful hybrid model transformation languages have been currently proposed, most of them appear to be isolated in the sense that they have been developed from the ground up, in most cases only building conceptually on a subset of OCL for model navigation and querying. This introduces unnecessary diversity to the model engineering toolkit and requires a potential user to learn and use similar -but inconsistent -languages to automate different model management tasks.</p><p>Motivated by this, we present the Epsilon Transformation Language (ETL), a hybrid model transformation language that has been built atop the infrastructure provided by the Epsilon Eclipse GMT component <ref type="bibr" target="#b10">[5]</ref>. By building on Epsilon, ETL achieves syntactic and semantic consistency and enhanced interoperability with a number of additional languages, also been built atop Epsilon, and which target tasks such as model-to-text transformation, model comparison, validation, merging and unit testing.</p><p>The rest of the paper is organized as follows. In Section 2 we provide a detailed discussion on our motivation for designing and implementing a new model transformation language. Section 3 briefly discusses Epsilon and the advantages of building new model management languages atop it. In Section 4 we present the abstract and concrete syntax of ETL as well as an informal discussion of its execution semantics. In Section 5 we demonstrate how ETL can be used together with other languages that build atop Epsilon to realize composite model management operations. Finally, in Section 6 we conclude.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background and Motivation</head><p>To date, a large number of languages have been proposed for specifying and executing transformations between models conforming to (potentially) different metamodels. In this section we provide an overview of the different styles of transformation adopted by transformation languages, and discuss issues of integrating transformation languages with other languages used to perform tasks such as model-to-text transformation, model validation, comparison and merging. Finally, we examine four of the most widely used and actively developed transformation languages in terms of the styles that they offer, and their integrability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Styles</head><p>Three styles are generally recognized in model transformation languages: declarative, imperative and hybrid, each one demonstrating particular advantages and shortcomings <ref type="bibr" target="#b11">[6]</ref>. Purely declarative transformation languages are generally considered to more suitable for scenarios where the source and target metamodels are similar to each other in terms of structure and organization. However, such languages are challenging to use in cases where significant sequential processing and complex mappings are involved. By contrast, purely imperative transformation languages are capable of addressing a wider range of transformation scenarios. Nevertheless, they typically operate at a low level of abstraction which means that users need to manually address issues such as tracing, resolving target elements with their source counterparts, and orchestrating the transformation execution. To address those shortcomings, hybrid languages provide a declarative rule-based execution scheme as well as imperative features for handling complex transformation scenarios.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Integration with Other Model Management Languages</head><p>While model transformation is a very important component in the model engineering toolkit, it is not the only one. A model management workflow typically involves other tasks such as model validation, comparison, merging and code generation, each of which may be supported by a different language. As an example, consider the steps required to generate a data-intensive application from a UML model: This simple workflow involves three different model-management languages: a validation language for step 1, a model-to-model transformation language for step 2 and a model-to-text transformation language for steps 3 and 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Model Format and Runtime Interoperability</head><p>The simplest way in which two model management languages can interoperate is by being able to access the same type of models. However, in this case, in every step of the workflow, each language runtime has to load the models from their physical location and store them (if necessary) afterwards. Thus, if Mv, Mt, Mg are (respectively) languages for validation, model-to-text and model-to-model transformation, and if they can only be integrated by accessing the same type of models, the workflow above would involve the following steps: Loading and storing big models is a resource-and time-consuming activity, and even this simple example demonstrates that using languages that interoperate only at the model format level introduces a number of (potentially expensive) model loading and storing steps which could otherwise be unnecessary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">Code Consistency and Reuse</head><p>Another significant issue when using many languages to implement the steps of a workflow is reuse and consistency of code. Consider, once again, a worfklow in which we want to carry out validation, transformation, and model-to-text generation tasks, as above. When managing UML2 models, a typical activity in all three tasks is to examine model elements to check if they have certain stereotypes attached. If the three languages selected for these tasks were OCL, ATL and MOFScript, respectively, then the user would need to specify the same helper operation (which checks whether a specified stereotype is attached) three times, using similar but inconsistent syntaxes, as illustrated in Listings 1.2, 1.1 and 1.3 respectively. Duplication of code in different languages introduces a maintenance problem and is also a potential source of coding errors as it requires the user to work concurrently with similar but inconsistent syntaxes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Overview of the Most Widely-Used Transformation Languages</head><p>Due to the large number of transformation languages, and the imposed space limitations, in this section we only concentrate on those transformation languages which, to our knowledge, are most widely-used and actively developed. These languages are: QVT <ref type="bibr" target="#b12">[7]</ref> which is the currently adopted OMG standard, ATL <ref type="bibr" target="#b8">[3]</ref> that is probably the most widely-used transformation language today, Kermeta <ref type="bibr" target="#b13">[8]</ref>, and XTend, which is the transformation language of the popular openArchitectureWare framework <ref type="bibr" target="#b14">[9]</ref>.</p><p>With respect to integration, only XTend is integrated with additional model management languages of the openArchitectureWare framework that target other tasks such as code generation (XPand) and model validation (Check). Nevertheless, XTend is a purely imperative language and as discussed in Section 2.1, imperative languages require the user to implement transformation rules, scheduling and support for traceability almost from scratch for each transformation.</p><p>Kermeta adopts a different approach to model management by providing a generalpurpose imperative language which can be used to perform all model management tasks. However, being purely imperative, the language also suffers from the aforementioned shortcomings.</p><p>ATL is the most successful hybrid model transformation language to date. It integrates with the TCS tool <ref type="bibr" target="#b15">[10]</ref> which provides support for model-to-text and text-tomodel transformations. Moreover, it has been shown that ATL can be used to perform other tasks, such as model validation <ref type="bibr" target="#b16">[11]</ref> and merging <ref type="foot" target="#foot_1">1</ref> , for which however the language is, to our view, not particularly suitable as it is not tailored to the specific requirements of these tasks.</p><p>Finally, QVT -the current OMG standard for model transformation -adopts a hybrid style by providing both declarative and imperative constructs. With regards to integration, the OMG has also standardized a model-to-text transformation language (MOF2Text) <ref type="bibr" target="#b17">[12]</ref> which reuses parts of QVT, and both QVT and MOF2Text are aligned with OCL. Nevertheless, the OMG has not (yet) proposed languages for tasks such as model comparison and merging nor a solution for specifying and orchestrating multistep model management workflows. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Motivation</head><p>Throughout this section we have argued that existing hybrid model transformation languages suffer from integration problems with languages that support other tasks. On the other hand, languages such as Kermeta and XTend, which can be used in the context of a framework that supports other model management tasks as well, are purely imperative and thus suffer from the problems discussed in Section 2.3. Driven by this motivation, in Section 4 we present the Epsilon Transformation Language (ETL), a hybrid model transformation language that integrates seamlessly with a number of other model management languages developed atop the Epsilon model management platform.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Epsilon</head><p>Epsilon is a component of the Eclipse GMT project <ref type="bibr" target="#b18">[13]</ref> that provides infrastructure for implementing uniform and interoperable model management languages. It can be used to manage models of diverse metamodels and technologies. At the core of Epsilon is the Epsilon Object Language (EOL) <ref type="bibr" target="#b19">[14]</ref>, an OCL-based imperative language that provides features such as model modification, multiple model access, conventional programming constructs (variables, loops, branches etc.), user interaction, profiling, and support for transactions. Although EOL can be used as a general-purpose model management language, its primary aim is to be reused in task-specific languages. Thus, a number of task-specific languages have been implemented atop EOL, including those for model comparison (ECL) <ref type="bibr" target="#b20">[15]</ref>, model merging (EML) <ref type="bibr" target="#b21">[16]</ref>, model validation (EVL) <ref type="bibr" target="#b22">[17]</ref>, model refactoring (EWL) <ref type="bibr" target="#b23">[18]</ref> and model-to-text transformation (EGL) <ref type="bibr" target="#b24">[19]</ref>.</p><p>With regard to the types of models supported, Epsilon provides the Epsilon Model Connectivity (EMC) layer that is used to provide a uniform interface for models of different modelling technologies. Currently, EMC drivers have been implemented to support EMF <ref type="bibr" target="#b25">[20]</ref> (XMI 2.x), MDR <ref type="bibr" target="#b26">[21]</ref> (XMI 1.x), Z <ref type="bibr" target="#b27">[22]</ref> and XML. Also, to enable users to compose workflows that involve a number of individual model management tasks, Epsilon provides ANT <ref type="bibr" target="#b28">[23]</ref> tasks and an inter-task communication framework discussed in detail in <ref type="bibr" target="#b29">[24]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">The Epsilon Transformation Language</head><p>The aim of ETL is to contribute model-to-model transformation capabilities to Epsilon. More specifically, ETL needs to be able to capture and execute specifications of transformation scenarios that involve an arbitrary number of input and output models of different modelling languages and technologies at a high level of abstraction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Style</head><p>As discussed in Section 2.1, hybrid transformation languages are very appropriate for constructing flexible, expressive, and abstract model transformations. Therefore, ETL has been designed as a hybrid language that implements a task-specific rule definition and execution scheme, but which also inherits the imperative features of EOL to handle complex transformations where necessary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Source and Target Models</head><p>The majority of model-to-model transformation languages assume that only two models participate in each transformation: the source model and the target model. Nevertheless, it is often essential to be able to access/update additional models during a transformation (such as trace or configuration models). Building on the facilities provided by EMC and EOL, ETL enables specification of transformations that can transform an arbitrary number of source models into an arbitrary number of target models.</p><p>Another common assumption is that the contents of the target models are insignificant and thus a transformation can safely overwrite its contents. By contrast, ETL -like all Epsilon languages -enables users to specify for each involved model separately if its contents need to be preserved or not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Abstract Syntax</head><p>As illustrated in Figure <ref type="figure" target="#fig_1">1</ref>, ETL transformations are organized in modules (ETLModule). A module can contain any number of transformation rules (TransformationRule) and EOL operations <ref type="bibr" target="#b19">[14]</ref>. Each rule has a unique name (in the context of the module) and also specifies one source<ref type="foot" target="#foot_2">2</ref> and one or more target parameters. A transformation rule can also extend a number of other transformation rules and be declared as abstract, primary and/or lazy. To limit its applicability to a subset of elements that conform to the type of the source parameter, a rule can optionally define a guard which is either an EOL expression or a block of EOL statements. Finally, each rule defines a block of EOL statements (body) where the logic for populating the property values of the target model elements is specified.</p><p>Besides transformation rules, an ETL module can also optionally contain a number of pre and post named blocks of EOL statements which, as discussed later, are executed before and after the transformation rules respectively. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Concrete Syntax</head><p>The concrete syntax of a transformation rule is displayed in Listing 1.4. The optional abstract, lazy and primary attributes of the rule are specified using respective annotations. The name of the rule follows the rule keyword and the source and target parameters are defined after the transform and to keywords. Also, the rule can define an optional comma-separated list of rules it extends after the extends keyword. Inside the curly braces (), the rule can optionally specify its guard either as an EOL expression following a column (:) (for simple guards) or as a block of statements in curly braces (for more complex guards). Finally, the body of the rule is specified as a sequence of EOL statements. Pre and post blocks have a quite simple syntax that, as presented in Listing 1.5, consists of the identifier (pre or post), an optional name and the set of statements to be executed enclosed in curly braces. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Execution Semantics</head><p>Having discussed the abstract and concrete syntax of the language, in this section we provide an informal discussion on its execution semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.1">Rule and Block Overriding</head><p>An ETL module can import a number of other ETL modules. In this case, the importing ETL module inherits all the rules and pre/post blocks specified in the modules it imports (recursively). If the module specifies a rule or a pre/post block with the same name, the local rule/block overrides the imported one respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.2">Rule Execution Scheduling</head><p>When an ETL module is executed, the pre blocks of the module are executed first in the order in which they have been specified.</p><p>Following that, each non-abstract and non-lazy rule is executed for all the elements on which it is applicable<ref type="foot" target="#foot_3">3</ref> . To be applicable to a particular element, the element must have a kind-of relationship with the type defined in the rule's sourceParameter and must also satisfy the guard of the rule (and all the rules it extends). When a rule is executed on an applicable element, the target elements are initially created by instantiating the targetParameters of the rules, and then their contents are populated using the EOL statements of the body of the rule.</p><p>Finally, when all rules have been executed, the post blocks of the module are executed in the order in which they have been declared.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.3">Resolution of Source Elements in the Target Models</head><p>Finding the target elements that have been (or can be) transformed from particular source elements by other rules is a recurring task in the body of a transformation rule. To automate this task and reduce coupling between rules, ETL provides the equivalents() and equivalent() built-in operations that automatically resolve source elements to their transformed counterparts in the target models.</p><p>When the equivalents() operation is applied on a single source element (as opposed to a collection of them), it inspects the established transformation trace and invokes the applicable rules (if necessary) to calculate the counterparts of the element in the target model. When applied to a collection it returns a Bag containing Bags that in turn contain the counterparts of the source elements contained in the collection. The equivalents() operation can be also invoked with an arbitrary number of rule names as parameters to invoke and return only the equivalents created by specific rules. Unlike the main execution scheduling scheme discussed above, the equivalents() operation invokes both lazy and non-lazy rules.</p><p>With regard to the ordering of the results of the equivalents() operations, the returned elements appear in the respective order of the rules that have created them. An exception to this occurs when one of the rules is declared as primary, in which case its results precede the results of all other rules.</p><p>ETL also provides the convenience equivalent() operation which, when applied to a single element, returns only the first element of the respective result that would have been returned by the equivalents() operation discussed above. Also, when applied to a collection the equivalent() operation returns a flattened collection (as opposed to the result of equivalents() which is a Bag of Bags in this case). As with the equivalents() operation, the equivalent() operation can also be invoked with or without parameters.</p><p>The semantics of the equivalent() operation are further illustrated through a simple example. In this example, we need to transform a model that conforms to the Tree metamodel displayed in Figure <ref type="figure">2</ref> into a model that conforms to the Graph metamodel of Figure <ref type="figure">3</ref>. More specifically, we need to transform each Tree element to a Node, and an Edge that connects it with the Node that is equivalent to the tree's parent. This is achieved using the rule of Listing 1.6.</p><p>In lines 1-3, the Tree2Node rule specifies that it can transform elements of the Tree type in the Tree model into elements of the Node type in the Graph model. In line 4 it specifies that the name of the created Node should be the same as the name of the source Tree. If the parent of the source Tree is defined (line 7), the rule creates a new Edge (line 8) and sets its source property to the created Node (line 9) and its target property to the equivalent Node of the source Tree's parent (line 10). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Interactive Transformations</head><p>Using the user interaction facilities of EOL discussed in <ref type="bibr" target="#b30">[25]</ref>, an ETL transformation can be made interactive by prompting the user for input during its execution. For example in Listing 1. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.7">Summary</head><p>This section has provided a detailed discussion on the Epsilon Transformation Language (ETL). Unlike most contemporary model transformation languages, ETL is capable of transforming an arbitrary number of source models into an arbitrary number of target models. ETL adopts a hybrid style and features declarative rule specification using advanced concepts such as guards, abstract, lazy and primary rules, and automatic resolution of target elements from their source counterparts. Also, as ETL is based on EOL reuses its imperative features to enable users to specify particularly complex, and even interactive, transformations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Integration with Other Model Management Languages</head><p>Integration of ETL with other model management languages of the Epsilon platform is achieved in two ways. First, since all languages of the Epsilon platform build atop EOL, they can all import and use libraries of operations specified in EOL. Therefore, with regard to the example of Section 2.2.1, if Mv, Mt and Mg are EVL, ETL and EGL respectively, the hasStereotype(s : String) operation will only need to be defined once in an EOL library which can then be imported by the different model management programs.</p><p>Besides reuse of code, ETL is integrated with other Epsilon languages at runtime through the workflow mechanism discussed in <ref type="bibr" target="#b29">[24]</ref>. More specifically, the worfklow supports the epsilon.etl task for executing ETL transformations. Listing 1.9demonstrates using the epsilon.etl task in the context of the worfklow outlined in Section 2.2.1.</p><p>In line 7 the loadModels target loads the UML and DB model (without reading the existing contents of the DB model due to the readOnLoad=false property in line 14). Once the models have been loaded, they are made accessible to any subsequent Epsilon tasks in the workflow. In line 18, the validate target uses EVL to validate the UML model. In line 24, the transform target uses ETL to transform between the two models. The ETL task also specifies that it exports its internal trace as a variable named transTrace which the storeTransformationTrace EOL task in Line 33 can then read and store in the form of a trace model. Finally, the uml2java and db2sql code generation targets in lines 41 and 47 use EGL to generate the Java and SQL source code from the UML and DB models respectively. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions</head><p>In this paper we have raised the issue of consistency and integration between model transformation languages and languages that target other model management tasks such as code generation, model comparison, merging and validation. We have presented the Epsilon Transformation Language (ETL), a hybrid model transformation language that has been built atop the infrastructure provided by the Epsilon model management platform. We have also shown that ETL can be seamlessly integrated with existing languages of the Epsilon platform that target a wide range of model management tasks using a workflow mechanism built atop ANT.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Listing 1 . 1 . 2 Listing 1 . 2 .Listing 1 . 3 .</head><label>1121213</label><figDesc>The hasStereotype() helper expressed in ATL 1 helper context UML2!Element def:hasStereotype(s:String): Boolean self.getAppliedStereotypes()-&gt;exists(st | st.name = s); The hasStereotype() helper expressed in OCL 1 package uml 2 context Element 3 def Operations: 4 let hasStereotype(s : String) : Boolean = 5 getAppliedStereotypes()-&gt;exists(st | st.name = s) 6 endpackage The hasStereotype() helper expressed in MOFScript 1 uml.Element::hasStereotype(s : String): Boolean { 2 result = self.getAppliedStereotypes()-&gt;exists(st | st.name = s); 3 }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. ETL Abstract Syntax</figDesc><graphic coords="7,41.69,328.81,302.69,66.41" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Listing 1 . 5 .</head><label>15</label><figDesc>Concrete Syntax of Pre and Post blocks 1 (pre|post) &lt;name&gt; { 2 statement+ 3 }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Listing 1 . 6 .</head><label>16</label><figDesc>Exemplar ETL rule demonstrating the equivalent() operation 1 rule Tree2Node 2 transform t : Tree!Tree 3 to n : Graph!Node {</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 .</head><label>1</label><figDesc>Feature Matrix of Model Transformation Languages</figDesc><table><row><cell cols="2">Language Style</cell><cell>Integrations?</cell></row><row><cell>XTend</cell><cell cols="2">Imperative XPand, Check</cell></row><row><cell cols="3">Kermeta Imperative General-purpose language</cell></row><row><cell>ATL</cell><cell>Hybrid</cell><cell>TCS, Can also perform model validation, merging</cell></row><row><cell>QVT</cell><cell>Hybrid</cell><cell>MOF2Text, OCL</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>8, we modify the Tree2Node rule originally presented in Listing 1.6 by adding a guard part that uses the user-input facilities of EOL (more specifically the UserInput.confirm(String,Boolean) operation) to enable the user select manually at runtime which of the Tree elements need to be transformed to respective Node elements in the target model and which not.</figDesc><table><row><cell></cell><cell>Listing 1.8. Exemplar Interactive ETL Transformation</cell></row><row><cell cols="2">1 rule Tree2Node</cell></row><row><cell>2</cell><cell>transform t : Tree!Tree</cell></row><row><cell>3</cell><cell>to n : Graph!Node {</cell></row><row><cell>4</cell><cell></cell></row><row><cell>5</cell><cell>guard : UserInput.confirm</cell></row><row><cell>6</cell><cell>('Transform tree ' + t.label + '?', true)</cell></row><row><cell>7</cell><cell></cell></row><row><cell>8</cell><cell>n.label := t.label;</cell></row><row><cell>9</cell><cell>var target : Graph!Node ::= t.parent;</cell></row><row><cell>10</cell><cell>if (target.isDefined()) {</cell></row><row><cell>11</cell><cell>var edge := new Graph!Edge;</cell></row><row><cell>12</cell><cell>edge.source := n;</cell></row><row><cell>13</cell><cell>edge.target := target;</cell></row><row><cell>14</cell><cell>}</cell></row><row><cell>15 }</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>Listing 1.9. Implementation of the Workflow of Section 2.2.1 using the Epsilon ANT workflow</figDesc><table><row><cell cols="2">1 &lt;project default="main"&gt;</cell></row><row><cell>2</cell><cell></cell></row><row><cell>3</cell><cell>&lt;target name="main"</cell></row><row><cell>4</cell><cell>depends="uml2java,db2sql,storeTransformationTrace"&gt;</cell></row><row><cell>5</cell><cell>&lt;/target&gt;</cell></row><row><cell>6</cell><cell></cell></row><row><cell>7</cell><cell>&lt;target name="loadModels"&gt;</cell></row><row><cell>8</cell><cell>&lt;epsilon.loadModel name="UML" type="MDR"&gt;</cell></row><row><cell>9</cell><cell>...</cell></row><row><cell>10</cell><cell>&lt;property name="readOnLoad" value="true"/&gt;</cell></row><row><cell>11</cell><cell>&lt;/epsilon.loadModel&gt;</cell></row><row><cell>12</cell><cell>&lt;epsilon.loadModel name="DB" type="EMF"&gt;</cell></row><row><cell>13</cell><cell>...</cell></row><row><cell>14</cell><cell>&lt;property name="readOnLoad" value="false"/&gt;</cell></row><row><cell>15</cell><cell>&lt;/epsilon.loadModel&gt;</cell></row><row><cell>16</cell><cell>&lt;/target&gt;</cell></row><row><cell>17</cell><cell></cell></row><row><cell>18</cell><cell>&lt;target name="validate" depends="loadModels"&gt;</cell></row><row><cell>19</cell><cell>&lt;epsilon.evl src="UMLConstraints.evl"&gt;</cell></row><row><cell>20</cell><cell>&lt;model ref="UML"/&gt;</cell></row><row><cell>21</cell><cell>&lt;/epsilon.evl&gt;</cell></row><row><cell>22</cell><cell>&lt;/target&gt;</cell></row><row><cell>23</cell><cell></cell></row><row><cell>24</cell><cell>&lt;target name="transform" depends="validate"&gt;</cell></row><row><cell>25</cell><cell>&lt;epsilon.etl src="UML2DB.etl"</cell></row><row><cell>26</cell><cell>exporttransformationtrace="transTrace"&gt;</cell></row><row><cell>27</cell><cell></cell></row><row><cell>28</cell><cell>&lt;model ref="UML"/&gt;</cell></row><row><cell>29</cell><cell>&lt;model ref="DB"/&gt;</cell></row><row><cell>30</cell><cell>&lt;/epsilon.etl&gt;</cell></row><row><cell>31</cell><cell>&lt;/target&gt;</cell></row><row><cell>32</cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>A. Vallecillo, J. Gray, A. Pierantonio (Eds.): ICMT 2008, LNCS 5063, pp. 46-60, 2008. c Springer-Verlag Berlin Heidelberg 2008</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>http://ssel.vub.ac.be/ssel/research:mdd:casestudies#mergemodel modelmerge</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><p>While an ETL module can transform multiple input models, each rule can transform only one type of model elements.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3"><p>As discussed in the sequel, lazy rules are invoked explicitly using the equivalents() operation.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The work in this paper was supported by the European Commission via the MOD-ELPLEX project, co-funded by the European Commission under the "Information Society Technologies" Sixth Framework Programme (2006)(2007)(2008)(2009).</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.4">Overriding the Semantics of the EOL SpecialAssignment Operator</head><p>As discussed above, resolving the equivalent(s) or source model elements in the target model is a recurring task in model transformation. Furthermore, in most cases resolving the equivalent of a model element is immediately followed by assigning/adding the obtained target model elements to the value(s) of a property of another target model element. For example, in line 10 of Listing 1.6 the equivalent obtained is immediately assigned to the target property of the generated Edge. To make transformation specifications more readable, ETL overrides the semantics of the SpecialAssignment (::= in terms of concrete syntax) operator that EOL provides to set its left-hand side, not to the element its right-hand side evaluates to, but to its equivalent as calculated using the equivalent() operation discussed above. Using this feature, line 10 of the Tree2Node rule can be rewritten as shown in Listing 1.7</p><p>Listing 1.7. Rewritten Line 10 of the Tree2Node Rule Demonstrated in Listing 1.6 1 edge.target ::= t.parent;</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m">&lt;target name=&quot;storeTransformationTrace&quot; depends=&quot;transform,storeDBmodel&quot;&gt; 34 &lt;epsilon.eol src=&quot;StoreTransformationTrace.eol&quot;&gt; 35 &lt;uses ref=&quot;transTrace&quot;/&gt; 36 &lt;model ref=&quot;UML&quot;/&gt; 37 &lt;model ref=&quot;DB</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">41 &lt;target name=&quot;uml2java&quot; depends=&quot;validate&quot;&gt; 42 &lt;epsilon.egl src=&quot;Uml2Java.egl&quot;&gt; 43 &lt;model ref=</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">47 &lt;target name=&quot;db2sql&quot; depends=&quot;transform&quot;&gt; 48 &lt;epsilon.egl src=&quot;DB2Sql.egl&quot;&gt; 49 &lt;model ref=</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m">51 &lt;/target&gt; 52 53 &lt;target name=&quot;storeDBmodel&quot;&gt; 54 &lt;epsilon.storeModel model=&quot;DB</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">56 57 &lt;/project&gt; A more complex and detailed case study that demonstrates using ETL together with other languages provided by the Epsilon platform is available in</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Technical spaces: An initial appraisal</title>
		<author>
			<persName><forename type="first">I</forename><surname>Kurtev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bezivin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Aksit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Tenth International Conference on Cooperative Information Systems (CoopIS), Federated Conferences Industrial Track</title>
		<meeting>Tenth International Conference on Cooperative Information Systems (CoopIS), Federated Conferences Industrial Track<address><addrLine>California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<ptr target="http://www.omg.org/cgi-bin/doc?ptc/05-11-01.pdf" />
		<title level="m">MOF QVT Final Adopted Specification</title>
		<imprint/>
		<respStmt>
			<orgName>Object Management Group</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Transforming Models with ATL</title>
		<author>
			<persName><forename type="first">F</forename><surname>Jouault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Kurtev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MoDELS 2005</title>
		<editor>
			<persName><forename type="first">J.-M</forename><surname>Bruel</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">3844</biblScope>
			<biblScope unit="page" from="128" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Model Transformation the Heart and Soul of Model-Driven Software Development</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sendall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Kozaczynski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="42" to="45" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Extensible Platform for Specification of Integrated Languages for mOdel maNagement</title>
		<ptr target="http://www.eclipse.org/gmt/epsilon" />
	</analytic>
	<monogr>
		<title level="m">Epsilon)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Classification of Model Transformation Approaches</title>
		<author>
			<persName><forename type="first">K</forename><surname>Czarnecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Helsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOP-SLA 2003 Workshop on Generative Techniques in the Context of Model-Driven Architecture</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<ptr target="http://qvtp.org/" />
		<title level="m">QVT Partners Official Web-Site</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Chauvel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Fleurey</surname></persName>
		</author>
		<ptr target="http://www.kermeta.org" />
		<title level="m">Kermeta Language Overview</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title/>
		<author>
			<persName><surname>Openarchitectureware</surname></persName>
		</author>
		<ptr target="http://www.openarchitectureware.org/" />
	</analytic>
	<monogr>
		<title level="j">Official Web-Site</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">TCS: a DSL for the Specification of Textual Concrete Syntaxes in Model Engineering</title>
		<author>
			<persName><forename type="first">F</forename><surname>Jouault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bézivin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Kurtev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc GPCE 2006: Proceedings of the fifth international conference on Generative programming and Component Engineering</title>
		<meeting>GPCE 2006: eedings of the fifth international conference on Generative programming and Component Engineering</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Using ATL for Checking Models</title>
		<author>
			<persName><forename type="first">F</forename><surname>Jouault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bezívin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. International Workshop on Graph and Model Transformation (GraMoT)</title>
		<meeting>International Workshop on Graph and Model Transformation (GraMoT)<address><addrLine>Tallinn, Estonia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-09">September 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<ptr target="http://www.omg.org/docs/ptc/06-11-01.pdf" />
		<title level="m">MOF Model to Text Transformation Language Language Final Adopted Specification</title>
		<imprint/>
		<respStmt>
			<orgName>Object Management Group</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<ptr target="http://www.eclipse.org/gmt" />
		<title level="m">Eclipse GMT -Generative Modeling Technology, Official Web-Site</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The Epsilon Object Language (EOL)</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Kolovos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">F</forename><surname>Paige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">A C</forename><surname>Polack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECMDA-FA 2006</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Rensink</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Warmer</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4066</biblScope>
			<biblScope unit="page" from="128" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Model Comparison: A Foundation for Model Composition and Model Transformation Testing</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Kolovos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">F</forename><surname>Paige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">A C</forename><surname>Polack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1st International Workshop on Global Integrated Model Management (GaMMa), ACM/IEEE ICSE 2006</title>
		<meeting>1st International Workshop on Global Integrated Model Management (GaMMa), ACM/IEEE ICSE 2006<address><addrLine>Shanghai, China</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="13" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Merging Models with the Epsilon Merging Language (EML)</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Kolovos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">F</forename><surname>Paige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">A C</forename><surname>Polack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE 9th International Conference on Model Driven Engineering Languages and Systems (Models/UML 2006)</title>
		<meeting>ACM/IEEE 9th International Conference on Model Driven Engineering Languages and Systems (Models/UML 2006)<address><addrLine>Genova, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-10">October 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">On the Evolution of OCL for Capturing Structural Constraints in Modelling Languages</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Kolovos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">F</forename><surname>Paige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">A C</forename><surname>Polack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Dagstuhl Workshop on Rigorous Methods for Software Construction and Analysis</title>
		<meeting>Dagstuhl Workshop on Rigorous Methods for Software Construction and Analysis</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Update Transformations in the Small with the Epsilon Wizard Language</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Kolovos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">F</forename><surname>Paige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Rose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">A C</forename><surname>Polack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Special Issue for TOOLS Europe</title>
		<imprint>
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">The Epsilon Generation Language (EGL)</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Rose</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, The University of York</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">MEng Thesis</note>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><surname>Eclipse</surname></persName>
		</author>
		<author>
			<persName><surname>Org</surname></persName>
		</author>
		<ptr target="http://www.eclipse.org/emf" />
		<title level="m">Eclipse Modelling Framework</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<ptr target="http://mdr.netbeans.org" />
		<title level="m">Meta Data Repository</title>
		<imprint/>
		<respStmt>
			<orgName>Sun Microsystems</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Using Z: Specification, Refinement, and Proof</title>
		<author>
			<persName><forename type="first">J</forename><surname>Woodcock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Davies</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Prentice Hall, Englewood Cliffs</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title/>
		<ptr target="http://ant.apache.org" />
	</analytic>
	<monogr>
		<title level="j">The Apache Ant Project</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Kolovos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">F</forename><surname>Paige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">A C</forename><surname>Polack</surname></persName>
		</author>
		<ptr target="http://www.cs.york.ac.uk/∼dkolovos/publications/AntWorkflow.pdf" />
		<title level="m">A Framework for Composing Modular and Interoperable Model Management Tasks. Under review</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Novel Features in Languages of the Epsilon Model Management Platform</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Kolovos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">F</forename><surname>Paige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">A C</forename><surname>Polack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd Workshop on Modeling in Software Engineering, 30th International Conference on Software Engineering (ICSE)</title>
		<meeting>2nd Workshop on Modeling in Software Engineering, 30th International Conference on Software Engineering (ICSE)<address><addrLine>Leipzig, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-05">May 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Implementing the Interactive Applications Case Study using Epsilon</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Kolovos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">F</forename><surname>Paige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Rose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">A C</forename><surname>Polack</surname></persName>
		</author>
		<ptr target="http://www.dsmforum.org/events/MDD-TIF07/Epsilon.2.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proc. Model-Driven Development Tool Implementers Forum (MDD-TIF), Tools Europe</title>
		<meeting>Model-Driven Development Tool Implementers Forum (MDD-TIF), Tools Europe</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
