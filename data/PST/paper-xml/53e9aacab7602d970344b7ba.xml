<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Computer Animation with Scripts and Actors</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Craig</forename><forename type="middle">W</forename><surname>Reynolds</surname></persName>
							<email>reynolds@rand-ai</email>
							<affiliation key="aff0">
								<orgName type="institution">Information International Inc</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">III</orgName>
								<address>
									<addrLine>5933 Slauson Ave</addrLine>
									<postCode>90230</postCode>
									<settlement>Culver City</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Computer Animation with Scripts and Actors</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">917811C4500B63B03DC32ABDFF949CA1</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T09:11+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>1.3 [Computer Graphics]</term>
					<term>!.3.5 [CG]: Computational Geometry and Object Modeling</term>
					<term>1.3.6 [CG]: Methodology and Techniques--Languages</term>
					<term>1.3.7 [CG]: Three-Dimensional Graphics and Realism--Animation&apos; General Terms: Design, Languages Lisp, Procedural Animation Languages, Motion Picture Production</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A technique and philosophy for controlling computer animation is discussed. Using the Actor/Scriptor Animation System (ASAS) a sequence is described by the animator as a formal written SCRIPT, which is in fact a program in an animation/graphic language. Getting the. desired animation is then equivalent to "debugging" the script. Typical images manipulated with ASAS are synthetic, 3D perspective, color, shaded images. However, the animation control techniques are independent of the underlying software and hardware of the display system, so apply to other types (still, B&amp;W, 2D, line drawing ...). Dynamic (and static) graphics are based on a set of geometric object data types and a set of geometric operators on these types. Both sets are extensible. The operators are applied to the objects under the control of modular animated program structures. These structures (called actors) allow parallelism, independence, and optionally, synchronization, so that they can render the full range of the time sequencing of events.</p><p>Actors are the embodiment of imaginary players in a simulated movie. A type of animated number can be used to drive geometric expressions (nested geometrical operators) with dynamic parameters to produce animated objects. Ideas from programming styles used in current Artificial Intelligence research inspired the design of ASAS, which is in fact an extension to the Lisp programming environment. ASAS was developed in an academic research environment and made the transition to the "real world" of commercial motion graphics production.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Introduction</head><p>This paper describes the Actor/Scriptor Animation System (ASAS), which is a way of thinking about and describing computer graphic animation. ASAS is basically a notation for animated graphics. The notation for an animated sequence (the script) can be automatically read and converted into animated images by an ASAS interpreter. As in the case of musical notation being interpreted by a group of musicians--or the script of a video production being executed by a host of actors, camera, audio, lighting and video technicians--ASAS allows the creation and use of any number of simulated particpants, "actors" each of which can control one or more aspects of the animation. The ability of ASAS actors to operate independently or (by communicating with each other) to act in synchronization allows a simple and unambiguous description of the function of each actor. ASAS differs from "performance" based real time computer graphics systems as well as from command or "menu" based systems. Writing the ASAS notation for an animated sequence will probably take longer than the final running time of the sequence. On the other hand, an ASAS script is typically more compact than a simple listing of the value of all relevant parameters for each frame, as might be required in a commandmenu system. This results from the fact that ASAS is a procedural notation, a programming language for animation and graphics. In fact ASAS is a "full" programming language and includes all of the typical modern structured programming features (procedures (recursive), local variables, "if then else"s loops, typed data structures and generic operators). Additionally ASAS supports independent, parallel, "animated" program structures (actors), and includes a rich set of geometric and photometric objects and generic operators on these objects.</p><p>The existence of a formal notation for a field of endeavor leads to a workable procedure for the development of an idea. Like an algorithm being debugged by a computer programmer, or a musical score being revised, an ASAS script being developed is both unambiguous and precisely modifiable. It is possible to change just one small aspect while keeping everything else exactly the same. This property of notation allows the process of progressive refinement ("tweaking") to be used to converge on the desired algorithm, music or animation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>History</head><p>ASAS was developed at the Architecture Machine Group at MIT as two thesis projects between 1975 and 1978 <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b23">24]</ref>. "ASAS 0" was not a full implementation, but "ASAS 1" did actually work, Figure <ref type="figure">1</ref>: An Arch Fractal despite a very slow and uninteresting display package. In 1979 ASAS w a s integrated into the Digital Scene Simulation system of Information International Inc. cIIr', "tripled"] in Culver City, California. In this instance, ASAS is not used to make images directly, but serves as a p r e p r o c e s s o r for tit's existing 3D, hidden surface and shaded graphics system. Hence "ASAS 2" functioned as a true language compiler, translating from the animator's s c r i p t to the c o m m a n d sequence for the display software. The inconvenience of having the display s u p p o r t in a separate software package is offset by the m u c h w i d e r range of graphic features m a d e available to the ASAS user t h r o u g h the very advanced III software. After three years of commercial use the system w a s refined and became "ASAS 3". The current reference for the language is the unfinished ASAS U s e r ' s</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Manual 3.0. [26]</head><p>The design of ASAS w a s influenced by s o m e concepts from research in the Artificial Intelligence field. The basic concept of graphic databases and animation scripts as p r o g r a m s (procedural embedding of knowledge) w a s inspired by Terry Winograd's pioneering w o r k in c o m p u t e r linguistics. In Winograd's system natural language w a s represented by a procedural data structure. [30] The concept of message passing actors w a s from Carl Hewitt's body of w o r k in ~actor systems Â° such as PLASMA. <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b13">14]</ref> (Similar concepts exist in Smalltalk <ref type="bibr" target="#b10">[11]</ref>, Simula <ref type="bibr" target="#b4">[5]</ref> a n d Modula [32].) An animation system in development at about the s a m e time as ASAS by Ken Kahn shared some concepts w i t h ASAS. <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17]</ref> Kahn's system had w h a t Hewitt calls a "uniform actor basis" and so p e r h a p s a theoretically "cleaner" structure. <ref type="bibr">Kahn</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ASAS and Lisp</head><p>As a p r o g r a m m i n g language, ASAS "stands on the shoulders of giants" because of its relationship to the p r o g r a m m i n g language Lisp. ASAS can be considered to be either implemented in, or an extension to, Lisp. The rich programm i n g e n v i r o n m e n t of ASAS is due largely to Lisp, since all Lisp primitives and utilities are usable from ASAS (and vice versa). A Lisp interpreter plus the ASAS software yields an ASAS interpreter. ASAS w a s developed under MagicSixLisp at The Architecture Machine Group at MIT and w a s painlessly transplanted to r u n u n d e r MIT MacLisp at III.</p><p>For a long time Lisp has had a reputation as s o m e w h a t of a "toy" language, a powerful but quaint tool used by g n o m i s h academic artificial intelligence researchers, but not a language really suited for commercial use. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ASAS Expressions</head><p>ASAS and Lisp use a simple, if unusual, notation. A "parenthesized prefix notation" is used for operators, control structures and data. An ASAS e x p r e s s i o n is either:</p><p>(1) a n u m b e r (2) a symbol ("variable")</p><p>(3) a parenthesized list of expressions.</p><p>If the expression is a list, the first (leftmost) thing is the n a m e of an operator (or "function") and any other expressions in the list are parameters for the operator. W h e n an e x p r e s s i o n is evaluated (or "executed"), n u m b e r s evaluate to themselves, symbols to their currently defined value, and a list (eg: "(plus a (abfl b))" ) evaluates to the result of applying the operator ("plus ~) to the recursively evaluated p a r a m e t e r s (values of "a" and "(abs b)"). For example, to define the symbol ~wheels" to be the n u m b e r of tricycles times 3, w e w o u l d write:</p><p>(define wheels (times tricycles 3))</p><p>Normal ASAS operators (like times) evaluate each of their parameters, while certain operators have special evaluation patterns (like define, w h i c h does not evaluate its first parameter, these are called "macros"). To define a simple operator (call it "thrice") w h i c h multiplies its single p a r a m e t e r ('x") by three:</p><p>(defop thrice (param: x) (times x 3))</p><p>an equivalent definition in MacLisp would be:</p><p>(defun thrice (x) (times x 3))</p><p>The first example could then be rewritten:</p><p>(define wheels (thrice tricycles))</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Special Symbols</head><p>Within a script certain aspects of the production are controlled by the values given to some special symbols. None of these symbols are actually "reserved words", but it is best to use the script symbols background and camera only for the purpose of defining the current color of the graphical background of the image and the current camera description (as a pov, see the section on geometric objects). The initial ASAS environment has other symbols defined to various frequently used objects (axes, colors, basic solids), it is good practice to know these and avoid redefining them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Geometric Objects</head><p>In addition to the data types found in most programming languages, ASAS provides a set of geometric (and photometric)</p><p>objects: vector, color, polygon, solid, group, pov, subworld, and light.</p><p>The vector represents a position in three dimensional Cartesian space. It allows three (defop parameters, the X, Y and Z coordinates. Trailing zero coordinates may be omitted.</p><p>A color object may be specified either by its Red, Green and Blue components, or by Intensity, Hue, Saturation. The two operators are called rgb and ihs, each of which accept three numbers between 0 and 1.</p><p>A simple polygon contains a color and a list of vectors, the "boundary". The cut-hole operator allows the construction of polygons with "holes and islands" (that is, multiple (defop boundaries). The color can be a group of a front color and a back color. The boundary points may be listed separately or as a group of vectors. Here is a polygon expression for a certain blue triangle:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(polygon blue (vector 1 0 O) (vector 0 1 O) (defop (vector 0 0 1))</head><p>A solid represents a bounded region of space, a closed polyhedron. It is composed of vertices and faces (as vectors and polygons) in addition to topological connection information.</p><p>Several geometric objects can be "glued together" into a group object, which is then manipulated as a whole by the geometric operators. A group expression allows any number of parameters -geometrical objects to be grouped together, including other groups. The "point of view" object (pov) is used to define the point of view of an observer (for example the ASAS camera) or of an object. That is, a pov describes the three coordinate axis basis vectors and the position of the origin of an arbitrary coordinate space. We refer to such spaces by names like "eye space" and "an object's local coordinate space". Note: a pov plays a role very similar to a "4X4 homogeneous transform matrix" in other 3D graphics systems (there is a simple transformation from a pov to a 4X4 matrix) but a pov is a geometrical object composed of vectors and can be manipulated just like any other object.</p><p>A subworld is an object associated with a pov. This allows ASAS to manipulate a complex object by modifying only the pov, hence various "instances" of an object may share the same underlying data. Subworlds also allow ASAS to work with "levels of abstraction" in a graphic database, when a subworld is formed it notes the "overall size" and "typical color" of its contents. At display time this allows efficient tree structured clipping (when an entire subworld is offscreen) and handling of detail too small to see (when an entire subworld lies within a single pixel). <ref type="bibr" target="#b3">[4]</ref> Hence the user can build levels of abstraction to make an Arch Fractal (~iven an arch element). into a geometric database by the nesting of subworld objects.</p><p>Objects to be seen in shaded images are illuminated by light objects. Lights are composed of a position vector and a color.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Geometric Operators</head><p>ASAS's geometric operators are the tools the animator uses to shape, move and orient objects. An object's shape may come directly from the action of operators, or parts encoded by hand with a digitizer can be assembled with the operators. The same operators are used both for static arrangements, or to create animated motion, by operating frame by frame under the control of an actor.</p><p>In many command/menu based graphics systems it is difficult to precisely specify the correct ordering of geometric transformation. For example, there will be a "rotate" command which accepts three numbers, the angles of rotation for each axis.</p><p>Often there is no mention of in what order the rotations are applied, let alone a way to specify the desired order. In ASAS, the animator explictly determines the ordering of operations by the structure of the nesting of the expressions written in the script.</p><p>The basic operators are ~generic", they can be given any type of geometric object and operate on it as is appropriate for that objecrs type. ASAS operators NEVER modify the object they are operating on. The value returned by an operator is a geometrically modified copy of the original object with otherwise the same type and structure.</p><p>A notational shorthand is provided for the common occurence of a series of operations to be performed on a single object. The object to be operated upon can be made the "current" object (using the grasp operator). The "grasped" object will then be redefined by calls to operators which do not explicitly specify an object to operate on.</p><p>Two basic types of geometric operators are provided by ASAS, "global" and "local" (sometimes called "self relative").The ASAS global geometric operators are called: scale, move, rotate, stretch and mirror.</p><p>Generally these operators apply the named geometrical transform to any given geometrical object The transforms are relative to the origin and major axes of the global coordinate space. The parameter types to each are numbers and vectors as appropriate. ("Stretch" is a differential scaling for each axis, specified by a vector of scale factors).</p><p>As an example of the usage of the ASAS global operators see Figures <ref type="figure">1</ref> and<ref type="figure" target="#fig_2">2</ref>, these show how last year's SIGGRAPH cover was constructed.</p><p>The "local" operators are similar in effect to the global operators, except that they are based on an object's OWN coordinate system rather than the global coordinate system. A subworid carries along its own little coordinate system, its pov. Not only does this allow efficient modification of the subworld but it also provides a reference for operations in the object's local coordinate space. The local operators were inspired by the "turtle" of the LOGO graphics language <ref type="bibr" target="#b1">[2]</ref>, and are intended to be a three dimensional analog of the turtle operations (walk forwards or backwards, turn right or left). This notion of a 3D turtle (more of a deep sea swimming turtle than a land crawling tortoise) was first used by Jim Stansfield and then refined by Henry Lieberman in a 3D line drawing extension to LOGO. A good treatment of this subject can be found in <ref type="bibr" target="#b0">[1]</ref>. Usually objects will be defined so that the origin of their local coordinate space is at the center of the object. For this reason we will informally refer to the "origin of the local coordinate system" as the "center". Local operators are provided for moving, rotating, scaling and "zooming" relative to the local coordinate system. All of these operators accept one or two parameters, the second optional parameter is the object to operate on, if none is specified, the currently grasped object is redefined. Various other ASAS operators are available but will not be discussed here. There are recolor and cut-hole, and interp the general purpose interpolater, row and ring which make regular groups of objects, and prism which makes solids by projecting a polygon. Here are some examples of some of them, an operator to make a n-sided regular polygon (inscribed within a unit radius circle), and an operator to make a prism with regular "ends": This summary of ASAS operators suffers because of the language's extensibility; the full list is endless since the user invents new ones as needed. Beyond simple combinations of basic linear operations, there is a large class of nonlinear "bending" operators. For example consider "curl-up" which takes a long thin object and curls it into a spiral (Escher fans will know the application for that).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Scripts and Animate Blocks</head><p>The main program an ASAS user writes is called a script, which is a special type of defop. A script handles the setting up and setting down needed to produce an animated sequence (or write a file for later production by another system). The script expression includes a name and any number of subexpressions. The effect is to define an operator with that name which opens production, evaluates each expression, in the body, and closes production. There is no restriction, but the things in the body are usually either animate expressions ("animate blocks") or production utilities (such as "make N blank frames", "put this slate text", or "make an N second countdown").</p><p>An animate block is a special type of loop. Each time around the loop, after it evaluates its body, a flame of animation is produced automatically. Usually the body contains cue expressions ("cue at frame N .... "L These cause objects to be made visible (with the see operator) or start, stop or direct actors. Animate blocks are exited when a cut operator is evaluated.</p><p>This example script contains one animate block, which starts two similar actors at different times. Both actors then run until the end of the block.</p><p>(script spinning-cubes</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(local: (runtime 96)</head><p>(midpoint (half runtime)))</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(animate (cue (at O) (start (spin-cube-actor green))) (cue (at midpoint) (start (spin-cube-actor blue))) (cue (at runtime) (cut))))</head><p>(Note: cut accepts an optional frame number, and will cut only if that is the current frame, so that third cue could have been written as "(cut runtime)") When an animate block is exited, all of the actors associated with it are stopped. Hence animate blocks are somewhat like the "scenes" of a movie, the coarse structure of the action.</p><p>While an ASAS "cue" is in fact simply a number (a frame number relative to the current animate block) it should not be thought of as a constant. Because of the computational nature of a script it can be quite easy to move cues around, since all cue points can be handled symbolically (by name rather than by a literal number). For example it is a simple rrlatter to change the overall runtime of a script (for a "quick run through" test) if all cue points are defined relative to one variable (e.g. "runtime"). Library macros exist to facilitate just such a scheme. The animator may find it necessary for artistic reasons to move a cue point within a script, again this will be quite painless if everything which is supposed to begin or end at that cue point refers to it only symbolically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Actors</head><p>The control structure of an animation system would be very simple if we could assume that all sequences to be produced had at most one independently animated feature at any one time. On the other hand, if we assume that there may be any number of fully independent animated features (starting and stopping at random times, happening at different rates, running in syne or not) then conventional control structures are no longer the most appropriate.</p><p>An ASAS actor can be thought of several ways. Most basically an actor is a "chunk" of code which will be executed once each frame. Usually an actor (or a team of them) is responsible for one visible element in an animation sequence, hence it contains all values and computations which relate to that object. In this sense an actor serves to modularize and localize the code related to one aspect, isolating it from unrelated code. From a formal point of view, an actor is an independent computing process in a non-hierarchical system with synchronized activation and able to communicate with other actors by message passing.</p><p>When an actor is "on" (between being started and stOped), it will be awakened once each flame, its local variables restored, its body evaluated, its variables saved, then put back to sleep.</p><p>(Hence an actor has properties between a "closure" and a "process" in recent Lisp implementations.) Actors are put into action with the start operator, which takes an actor and returns the "actor instance id", a unique number for each active</p><p>actor. An actor can deactivate itself, or can be gunned down by the script or another actor, this is done with the StOp operator which accepts an "actor instance id". Run is a combination of start and stop, it starts an actor with a predetermined stop cue. This is the definition of the operator "spin-cube-actor" used in the script "spinning-cubes":</p><p>(defop spin-cube-actor (param: color)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(actor (local: (angle O)</head><p>(d-angle (quo 3 runtime)) (my-cube (recolor color cube)))</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(see (rotate angle y-axis my-cube)) (define angle (plus angle d-angle))))</head><p>It expects one parameter, a color, and returns an actor object.</p><p>The actor itself has three local variables, each of which is assigned an initial value in this case: "angle" is the current angle of rotation for this actors cube, "d-angle" is the incremental velocity of the angle, "my-cube" is a recolored version of ASAS's predefined "cube" solid. Each frame the actor constructs the rotated version of "my-cube" and passes it to the displayer, the current "angle" is updated for the next frame.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Animated Numbers</head><p>In the last example the symbol "angle" took on a series of numeric values, frame by frame, forming an arithmetic series. But for more complex time behavior (quadratic or cubic curves) the inline code to handle and update all those linear difference terms becomes a burden. To avoid this, ASAS supports an animated numeric object called a newton (as in Newtonian mechanics). Newtons can be used any place a number would be used, such as a coordinate in a vector or the angle parameter for rotate. Between frames however, newtons are automatically updated to the next value in their predefined sequence. The newton data structure holds its future as a chain of piecewise cubic curves with selectable degree of continuity at the joints.</p><p>A newton can be specified in terms of position, velocity, acceleration and delta acceleration ("jerk" or "jerkiness") when those values are known. But more typically newtons are defined with utilities which produce curves with certain properties. Animators are familiar with terms like "slow in" or "slow out" meaning that an action should start (or end) with zero velocity (first derivative). The five most common curves (or pieces of curves) used in ASAS are: hold, linear, slowin, slowout and slowio. Hold accepts a value and a length of time, each of the others takes a starting and ending value and a time. SIowio (slow in and slow out) has zero derivatives at both ends. When none of the standard curves are appropriate an interpolating cubic spline fit is used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Actors and Behavior Simulation</head><p>Some animation is made to match a preconceived image, especially in commercial production. Other times, animation is produced as an experiment, the answer to "what would happen if ...". In the second type, which might be called "behavior simulation", the animator sets up a little world by defining the rules of behavior and selecting the cast of characters. When the behavior simulation is run we obtain images of what went on in the little world.</p><p>A classic example of this sort of thing is to try to build a computer graphic simulation of a flock of birds. We must define the behavior of a single bird so that when a lot of instances of the bird are simulated, they flock convincingly. The flock seems to be following a leader, but each time they turn, a new bird becomes the leader. The flock changes direction like a single unit, yet it is just an assembly of individuals. The flock is a dense cluster, but the birds do not often collide.</p><p>ASAS actors provide a convenient way of implementing such behavior simulations. As mentioned before, one of the features of actors is the way they promote "separation of powers", independent modules of code which do not interfere with each other. This allows an actor to take the part of one characters in the simulation. If the same sort of character occurs many times in the simulation (e.g. many copies of BIRD) we can use independent "instances" of a given "class" of actors.</p><p>The other key feature of actors which makes them suitable for behavior simulation is the ability to pass messages. Clearly the birds in the flock are exchanging information, through the action of light and sound on the bird's senses each one is aware of where the others are and where they are going (in an intrinsically depth sorted order!) In an actor simulation of the flock we would not go to the extent of modeling light and sound, but we could realistically have each bird broadcasting to everyone the message "I am here (x y z) and I'm heading (dx dy dz)". In that implementation, each bird would have to put the others in order of importance, probably using a ~hidden bird algorithm".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Message Passing</head><p>ASAS messages are handled by two special operators: send and receive. Send composes messages and posts them at the recipient's mailbox. Receive reads each message in the mailbox, responding to each in a manner depending on the type of message. (ASAS actors act once each frame, not whenever a message comes, hence mail may pile up between frames so the mailbox is implemented as a FIFO queue.)</p><p>Send takes an address, a "message type" (optional), and any other specific message data (numbers, geometric objects, symbols). The address is either an actor id or a special symbol; uall" means send to all actors and ~script" and "animate" can be used to send messages to the surrounding script or animate block.</p><p>The "message type" is any symbol used to describe the type of message, it must match the message type in the recipient's receive construct. For example, these sends (1) tell "bouncer" to speedup by 10 percent and (2) announce to all birds where we are:</p><p>(send bouncer speedup 1.10)</p><p>(send all bird-state cur-position cur-velocity)</p><p>The receive construct has a body much like a case construct.</p><p>Each message in the mailbox is examined in turn, the "message type" of each is compared with the type of the various clauses.</p><p>If one of the clauses in the body of the receive matches the incoming message type, the body of the clause is evaluated in response to the message. Message type "any" in a clause will match any incoming message. The contents of a message (past the type) may be accessed by specifying parameter bindings for the clause type. For example, this actor knows how to receive only "speedup" and "slowdown" message:</p><p>(receive ((speedup f) (define speed (times speed f)))</p><p>((slowdown f) (define speed (quo speed f)))</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(any (print 'What?)))</head><p>The message passing mechanism described above is based on a more primative operator called in. The in operator allows the evaluation of any expression "inside" the local variable space of an actor, thus allowing examining and setting the local variables of the actor. This is a useful but dangerous tool which should be used only in a well designed protocol.  W h e n the artistic concept is s o m e w h a t settled, w o r k is started on its c o m p u t e r graphic realization. The first step is to create a geometrical model of the s h a p e s of the objects to be used in the animation. Unless the geometry of the object is regular e n o u g h to allow it to be constructed u n d e r p r o g r a m control, the shape definition is done by h a n d in a laborious process similar to technnical drafting w e call "encoding". Often s o m e mix of manual data entry and processing by various ~geometrical tool" p r o g r a m s is used to obtain a finished object shape description.</p><p>As the objects are being finalized, the technical director begins to write the ASAS scripts and related programs. W h e n the g r o u p is working m a n y closely related scenes, for instance during production on a feature film, m a n y of the "sets" or environments will be shared between several scenes. In such cases it becomes convenient to set u p "libraries" of c o m m o n ASAS function and object definitions. Contributions are made to these "public libraries" by all animators working on a project. Usually the motions in an animated sequence are so specifically planned out in advance that an outline of the script can be written before any of the objects are available for test pictures. At this stage the ASAS script is very abstract, references are made to symbolic constants w h o s e values are not yet known. W h e n object files are ready and the script is roughed out the "graphical debugging" begins.</p><p>Often design constraints are stated in such an indirect fashion ("have the camera pointing such that the logo is positioned here and oriented like in this sketch") that the only workable w a y to find the desired numerical parameters is experimentally with graphical feedback. After specific "key" frames have been composed, and the transitions between t h e m defined, a motion test is made. Usually this test is made in either line ("vector") or low resolution shaded image mode. The symbolic nature of ASAS scripts make it easy to adjust the runtime of a sequence, making preliminary tests at 10:1 speed ratios allows faster turn around. Also the script can be simplified for these tests, by d r o p p i n g out certain elements, replacing others w i t h "standins", all these changes can be made u n d e r the control of ASAS script flags. Often the motion test will reveal problems in the "feel" of the dynamics of the animation or unexpected behavior between the key frames.</p><p>Another pass or two is m a d e to finalize the motion and then attention is shifted to the color, lighting, shading and other "photometeric" parameters of the animation. Key frames are examined on a high resolution video display and color tests are made onto the type of color film w h i c h will be used for the final image. Often a p a r a m e t e r will be determined with a "wedge test", making a series of frames w h i c h differ only by a single p a r a m e t e r value (e.g. the a m o u n t of ambient light in the scene), w i t h the gamut of values laid out, the final value can be easily be selected.</p><p>W h e n all has been decided, a high resolution final filming is made. Typically w h e n the result is screened, the client will find at least one reason to reject the w o r k and the whole process goes back to the beginning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C o n c l u s i o n</head><p>This p a p e r has presented ASAS, a general p u r p 6 s e programming language w h i c h has been extended to include geometric objects and operators, parallel control structures and other features to make it useful for animated c o m p u t e r graphic applications. ASAS makes use of an abstract c o m p u t i n g element called an actor, w e have seen h o w actors p r o m o t e modularity and h o w they can simulate a wide range of behavior by exchanging messages with each other. In three years of commercial use ASAS has proved itself a workable and practical tool. While the specific feature a user w a n t s may not already be a part of the language, the extensibility of ASAS allows it to g r o w with its users. ASAS has expanded o u r "complexity barrier" a n o t h e r notch, allowing us to attempt w o r k with m o r e independently animated elements than before.</p><p>The a u t h o r is not p r e p a r e d to state that w h e n the ULTIMATE c o m p u t e r animation system is built, it will be p r o g r a m m i n g language based. But it is hard to visualize a system w h i c h allows arbitrary extensions into unexpected realms w i t h o u t being fully programmable. However, p r o g r a m m i n g and making aesthetic judgements seem to be disjoint in most people's thinking processes. The user of a graphics p r o g r a m m i n g system m u s t always be on guard against c o m p r o m i s i n g aesthetic judgements to simplify the programming! The solution used in o u r commercial w o r k is to make the production a joint effort of several people, s o m e responsible for artistic issues and others responsible for technical issues.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>'s w o r k placed m o r e e m p h a s i s on e m b e d d i n g c o m m o n -s e n s e and theatrical knowledge in animation characters, and less e m p h asis on complex graphics.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>These critisisms are misdirected, Lisp is one of the most elegant and useable algorithmic notations ever devised. The bad reputation is due mainly to p o o r implementations or u n d e r p o w e r e d computers. Because Lisp trades off r a w computational efficiency for expressive p o w e r and usability, a well designed interpreter and a fast m a c h i n e are required for a production environment. Today there are several good Lisp systems for various types of general p u r p o s e c o m p u t e r s (MacLisp [20], InterLISP [29], ...) and currently three firms are selling specially designed Lisp machines (Lisp Machine Inc., Symbolics Inc., and Xerox)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: How</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>arch-element top-color bot-color levels fractal-ratio height width leg-width) (local: (total-levels levels) (offset-dist (half (dif width leg-width))) (sub-tower-offset-1 (vector offset-dist 0 0)) (sub-tower-offset-2 (mirror x-axis sub-tower-offset-I))) (arch-tower levels)) arch-tower (param: levels) (if (zerop levels) (then nothing) (else (add-arch-level (arch-tower (dif levels 1)))))) add-arch-level (param: sub-tower) (grasp sub-tower (scale fractal-ratio) (move (vector 0 height 0)) (rotate 0.25 y-axis)) (grasp arch-element (recolor (interp (quo levels total-levels) bot-color top-color))) (subworld (group arch-element (move subtower-offset-1 sub-tower) (move subtower-offset-2 sub-tower))))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Note: the relationship between global and local operators is similar to the that of pre-and post-multiplication of transform matrices. Also note: when objects other than flubworlds or povs are passed to self relative operators they are first put into an identity ("home") subworld, then operated on. scale up about local center scale down about local center move along local +Z axis move along local -Z axis rotate to left about local Y axis rotate to right about local Y axis rotate upward about local X axis rotate downward about local X axis rotate clockwise about local Z axis rotate counter-clockwise about local Z axis scale up local Z axis scale down local Z axis move along arbitrary local vector scale each local axis independently resets back to original definition spaceExamples: an operator sequence which (if evaluated each frame) will cause the AIRPLANE (that is, the sequence of objects which form the animated value of the variable AIRPLANE) to perform "barrel rolls", and one to cause the CAMERA to pan around while zooming out:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>polygon color sides)))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>C o m m e r c i a l P r o d u c t i o n</head><label></label><figDesc>at I I IASAS frequently plays a central role in commercial animation production at III, although other techniques of animation control are used. Projects made w i t h ASAS include, "MICROMA" animated logo, "LBS" animated logo, "NEWS CENTER 2" TV n e w s s h o w intro, two TV commercials for "TORNADO", various magazine ads, all of the t h e m e animation for the III 1981 Sample Reel (~The Juggler"), about half of the special effects for the Ladd C o m p a n y ' s feature motion picture ~LOOKER", and all of the animation and still images III is making for the recently released Disney feature "TRON".Copyright 0 1982 by Walt Disney Productions and Information International, Inc.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Solar Sailer Escape Sequence from TRON</figDesc><graphic coords="7,61.29,209.05,230.00,98.00" type="bitmap" /></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>[30] Winograd, T. Understanding Natural Language, Academic Press, 1974.</p><p>[31] Winston, P. and Horn, B. Lisp, Addison Wesley, 1981.</p><p>[32] Wirth, N. "MODULA: a Language for Modular Multiprogramming", Software, Practice and Experience 7,1; 1977 pp.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3-35.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Note</head><p>This entire paper is an example of computer graphics. All pictures were produced with Digital Scene Simulation, and directly (digitally) converted into four color halftones in the Infocolor format.The text was edited and composed on TECS, and assembled with a Page Makeup System. Camera ready, full page art (including typesetting and halftone generation) was produced with a COMp80/2-Pagesetter. All of these systems are products of Information International Inc.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">H</forename><surname>Abelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Turtle</forename><surname>Didessa</surname></persName>
		</author>
		<author>
			<persName><surname>Geometry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Series in Artificial Intelligence</title>
		<imprint>
			<date type="published" when="1981">1981</date>
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The LOGO Primer</title>
		<author>
			<persName><forename type="first">H</forename><surname>Austin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">MIT A.I. Lab. Logo Working Paper</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The Calculi of Lambda Conversions</title>
	</analytic>
	<monogr>
		<title level="j">Annals of Mathematical Studies</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<date type="published" when="1941">1941. 1965</date>
			<publisher>Klaus Reprint Co</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">~Hierarchical Geometric Models for Visible Surface Algorithms</title>
		<author>
			<persName><forename type="first">J</forename><surname>Clark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CACM</title>
		<imprint>
			<date type="published" when="1976-10">October 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Myhrhaug, and Nygaard The SIMULA 67 Common Base Language</title>
		<author>
			<persName><surname>Dahl</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1968">1968</date>
			<publisher>Norwegian Computing Centre</publisher>
			<pubPlace>Oslo</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The Digital Component of the Circle Graphics Habitat</title>
		<author>
			<persName><forename type="first">T</forename><surname>Defanti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings NCC</title>
		<imprint>
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Notes on Structured Programming</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1969-08">August 1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">GLIDE: A Language for Design Information Systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Eastman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Henrion</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH &apos;77 Proceedings</title>
		<meeting><address><addrLine>San Jose, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1977-07">July 1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Towards the Design of an Intrinsically Graphical Language</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Futrelle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Barta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH &apos;78 Pl~gceedings</title>
		<meeting><address><addrLine>Atlanta, GA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1978-08">August 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">PICTUREBALM: A Lisp-based Graphics Language System with Flexible Syntax and Hierarchical Data Structure</title>
		<author>
			<persName><forename type="first">G</forename><surname>Goates</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Griss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Herron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH &apos;80 Proceedings</title>
		<meeting><address><addrLine>Seattle, WA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1980-07">July 1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">SMALLTALK-72 Instruction Manual Learning Research Group</title>
		<author>
			<persName><forename type="first">A</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Xerox Palo Alto Research</title>
		<imprint>
			<date type="published" when="1976-03">March 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Actor Semantics of PLANNER-73</title>
		<author>
			<persName><forename type="first">I</forename><surname>Gre!f</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hewitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SIGPLAN-SIGACT Conf</title>
		<meeting>of ACM SIGPLAN-SIGACT Conf<address><addrLine>Palo Alto, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1975-01">January 1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Towards a Programming Apprentice</title>
		<author>
			<persName><forename type="first">C</forename><surname>Hewitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MIT AI Lab Working Paper 90</title>
		<imprint>
			<date type="published" when="1975-01">January 1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Parallelism and Synchronization in Actor System</title>
		<author>
			<persName><forename type="first">C</forename><surname>Hewitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Atkinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Programming Languages</title>
		<meeting><address><addrLine>L. A. CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1977-01">January 1977</date>
			<biblScope unit="volume">4</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">An extended ALGOL-60 for Shaded Computer Graphics</title>
		<author>
			<persName><forename type="first">B</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN/SIGGRAPH Symposium on Graphical Languages</title>
		<imprint>
			<date type="published" when="1976-04">April 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">An Actor-Based Computer Animation Language</title>
		<author>
			<persName><forename type="first">K</forename><surname>Kahn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Prec. of the ACM-SIGGRAPH Workshop on User-Oriented Design of Computer Graphics Systems</title>
		<imprint>
			<date type="published" when="1976-10">October 1976</date>
			<pubPlace>Pittsburg, PA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A Computational Theory Of Animation</title>
		<author>
			<persName><forename type="first">K</forename><surname>Kahn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">MIT A.I. Lab. Working Paper</title>
		<imprint>
			<biblScope unit="volume">145</biblScope>
			<date type="published" when="1977-04">April 1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Computing with Text-Graphic Forms</title>
		<author>
			<persName><forename type="first">F</forename><surname>Larkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference Record of the 1980 LISP Conference</title>
		<meeting><address><addrLine>Stanford University</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1980-08">August 1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A Structure from Manipulation for Text-Graphic Objects</title>
		<author>
			<persName><forename type="first">F</forename><surname>Larkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH &apos;80 Proceedings</title>
		<meeting><address><addrLine>Seattle, WA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1980-07">July 1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">MacLisp Reference Manual, Revision O, MIT Project MAC</title>
		<author>
			<persName><forename type="first">D</forename><surname>Moon</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1975-12">December 1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Principles of Interactive Computer Graphics</title>
		<author>
			<persName><forename type="first">W</forename><surname>Newman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sproull</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1973">1973 and 1979</date>
			<publisher>McGraw-Hill</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A High Level Language Extension for Creating and Controlling Dynamic Pictures</title>
		<author>
			<persName><forename type="first">G</forename><surname>Pfister</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN/SIGGRAPH Symposium on Graphical Languages</title>
		<imprint>
			<date type="published" when="1976-04">April 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Multi-processed Music Synthesis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Preissler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1976-05">May 1976</date>
		</imprint>
	</monogr>
	<note type="report_type">BS Thesis MIT EECS Department</note>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">A Multiproeessing Approach to Computer Animation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Reynolds</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1975-08">August 1975</date>
		</imprint>
		<respStmt>
			<orgName>MIT EECS Department</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">SB thesis</note>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Computer Animation in the World of Actors and Scripts</title>
		<author>
			<persName><forename type="first">C</forename><surname>Reynolds</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1976-05">May 1976</date>
		</imprint>
		<respStmt>
			<orgName>MIT (Architecture Machine Group</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">SM thesis</note>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Actor / Scriptor Animation System User</title>
		<author>
			<persName><forename type="first">C</forename><surname>Reynolds</surname></persName>
		</author>
		<imprint>
			<publisher>Information International Inc</publisher>
		</imprint>
	</monogr>
	<note>s Manual 3.0, (ASASUM 3. in preparation</note>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">A Parallel Processing Model of Musical Structures</title>
		<author>
			<persName><forename type="first">S</forename><surname>Smoliar</surname></persName>
		</author>
		<idno>242</idno>
		<imprint>
			<date type="published" when="1971-09">September 1971</date>
		</imprint>
		<respStmt>
			<orgName>MIT AI Lab</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">SCHEME -An Interpreter for Extended Lambda Calculus</title>
		<author>
			<persName><forename type="first">G</forename><surname>Sussman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Steele</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">MIT AI Lab Memo</title>
		<imprint>
			<biblScope unit="volume">349</biblScope>
			<date type="published" when="1975-12">December 1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">InterLISP Reference Manual</title>
		<author>
			<persName><forename type="first">W</forename><surname>Teitelman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1978">1978</date>
		</imprint>
		<respStmt>
			<orgName>Xerox Palo Alto Research Center</orgName>
		</respStmt>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
