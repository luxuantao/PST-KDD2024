<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Modeling of Discrete Event Systems using Finite Automata With Variables</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Markus</forename><surname>Sköldstam</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Knut</forename><surname>Åkesson</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Martin</forename><surname>Fabian</surname></persName>
						</author>
						<title level="a" type="main">Modeling of Discrete Event Systems using Finite Automata With Variables</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D101C9C0EEA7830666FA7C4DF6C2741D</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T10:21+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>To get industrial acceptance of supervisory control theory, there is a need to bridge the gap between the signalbased industrial reality and the event-based supervisory control framework. This paper tries to do this by introducing a modeling formalism with automata extended with variables, guard expressions and action functions. The formalism is suitable for modeling plants and specifications in the supervisory control framework. An algorithm that transforms a set of extended automata into a set of ordinary automata with equivalent behavior, is presented. This allows the user to model complex behaviors with a compact representation, and at the same time use existing algorithms for analysis.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Discrete event systems (DES) are models of systems that at each time instant occupy a discrete state, and perform state-changes on the occurrence of events. Examples of such systems are manufacturing systems, communication networks and embedded systems. The behavior of a DES is described by the sequences of events that may occur, and the sequences of states that may be visited. Supervisory control theory <ref type="bibr" target="#b0">[1]</ref> is a general approach to synthesize control systems for DES. A supervisor may be generated using models of the plant and the specification, such that it is minimally restrictive with respect to the plant behavior, while still guaranteeing that the specification is upheld. Traditionally, regular languages and finite automata <ref type="bibr" target="#b1">[2]</ref> have been used both for modeling and analysis of discrete event systems in the supervisory control community.</p><p>Though a large amount of promising research results have been achieved in academia, industrial acceptance of the supervisory control theory is scarce. Only a few examples have been reported <ref type="bibr" target="#b2">[3]</ref>. A number of issues that hinder industrial use have been identified by various researchers <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>. Two main issues are the discrepancy between the signalbased reality and the event-based automata framework, and the lack of a compact representation of large models.</p><p>In many industrial applications, parts of a system, such as sensors, actuators and buffers, are conveniently modeled using variables. Guard expressions are used to restrict the behavior of the system and action functions are used to update variables. Physical signals that are stored in memories or sent between controllers are naturally modeled as global variables in DES models. Using variables, guards and actions help us to compactly represent large and complicated DES.</p><p>A number of frameworks have been introduced that allow compact representations of discrete event systems with Department of Signals and Systems, Chalmers University of Technology, Sweden. Corresponding author: markus.skoldstam@chalmers.se complex behavior and large state-spaces. Many of these are inspired by Statecharts <ref type="bibr" target="#b5">[6]</ref>, which extends automata with hierarchy, concurrency, and communication using variables, guards and actions. While most of the concepts introduced in Statecharts are useful for modeling supervisory control problems, Statecharts is not in its original formulation suitable for supervisory control. In the supervisory control framework it is essential to model what may occur instead of what should occur, this has large consequences for how the interaction between subsystems are modeled. In Statecharts there is a causality between subsystems, this is not desired in the supervisory control framework.</p><p>Modeling frameworks based on automata extended with variables, suitable for supervisory control, are presented in <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b9">[10]</ref>. In <ref type="bibr" target="#b6">[7]</ref> it is assumed that a variable can be updated by at the most one extended automaton and in order to do synthesis the state-space needs to be extended by additional states. In <ref type="bibr" target="#b7">[8]</ref> automata with variables are used to implement a supervisor. The authors encode the states of a given supervisor using boolean variables. The variables are used in guards and actions attached to the events of the model. In <ref type="bibr" target="#b8">[9]</ref> supervisory control is applied to a number of automata with variables. To ensure a least restrictive supervisor it is assumed that all variables are local i.e. not shared between automata. This is a quite strong restriction because variables cannot be used to model any interaction between subsystems. In <ref type="bibr" target="#b9">[10]</ref> a state transition structure with a data collection used for parameterized and non-regular discrete event systems is introduced.</p><p>Though extended frameworks allow compact representations of huge state-spaces, and hence simplify the modeling of systems of industrially interesting sizes, the states do not disappear and hence potentially pose a problem when it comes to analysis. The main problem is the state-space explosion that typically occurs when the behavior of interacting sub-systems is studied. For ordinary automata, especially in the context of supervisory control, there exists a large body of work for fighting this state-space explosion. For extended frameworks, less has been done. An attractive approach is to develop algorithms that benefit from the structure given by extended modeling frameworks, see <ref type="bibr" target="#b10">[11]</ref> and its references.</p><p>Without doubts, developing effective synthesis algorithms for automata that share variables needs to be explored further. However, it is equally important to be able to use existing algorithms that have been tested and have been proven to handle systems with large state-spaces. In this paper we present no new algorithms for analysis of extended automata models. Our approach is to transform extended models into ordinary automata models with the same behavior. This way we can use extended automata for modeling and regular automata for analysis. In order to fully understand the relation between regular finite automata and extended finite automata, we feel that a new and very detailed definition of extended automata is needed. Since we only model physical systems with finite state-spaces and the current variable values are part of the system state, we only consider variables that have finite domains of definition.</p><p>We present a modeling formalism with automata extended with variables, guard expressions and action functions. We attach guards and actions functions to transitions since this admits local design techniques of systems consisting of many different parts. In comparison to previous work we do not put any restrictions on how variables are shared between extended automata, thus all extended automata are allowed to update all variables as long as the composition is well defined. The presented framework has been implemented in the supervisory control tool Supremica <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b12">[13]</ref>. In <ref type="bibr" target="#b13">[14]</ref> it is argued that the extended finite automata (EFA) introduced in this paper may be used as a basis for efficiently representing control problems that consists of mixed logic and supervisory control problems.</p><p>We start with a motivating example of a model of a system with a complex controller specification (Section II). Section III and Section IV provide the notations used for finite automata (FA) and extended finite automata (EFA), which is our modeling framework. In Section V we present and prove a basic algorithm that transforms a single EFA to an equivalent FA. It is explained how the algorithm is extended to handle an arbitrary number of interacting EFA, and how to use the algorithm to efficiently analyze the behavior EFA models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. MODELING A DOSING TANK</head><p>This section illustrates some of the advantages of using EFA as a modeling tool compared with FA. We have chosen to model a unit in a chemical batch plant. The system consists of a tank and a user. The tank has an inlet valve, an outlet valve and two sensors to check the filling of the tank, S1 at the bottom and S2 at the top of the tank. Filling the tank or emptying the tank, can be requested to start or stop by the user. To meet the user requests, a supervisor/controller is designed that closes and opens the valves appropriately.</p><p>The plant and the supervisor are modeled in figures 1 and 2, respectively. Inlet Valve the opening/closing of the valves such that the following conditions are satisfied: a. the inlet and outlet valves are never open at the same time; b. discharging or filling can only start when a request is present, v req = 1; c. discharging can only start when the tank is completely filled, v s2 = 1; d. filling can only start when the tank is empty, v s1 = 0; e. for the inlet valve to close the tank must be full, v s2 = 1; f. for the outlet valve to close the tank must be empty, v s1 = 0. In figure 2 all these requirements are expressed using guard formulas over the variables. The presented EFA model of the dosing tank may be compared to the FA model in <ref type="bibr" target="#b14">[15]</ref>, where the same process is modeled without variables. EFA facilitates the modeling of many systems and it is reasonable to expect that the benefits of using EFA for modeling increase when the complexity of the modeled system increases.</p><formula xml:id="formula_0">open in vout = 0 ∧ vs1 = 0 ∧ vreq = 1 vin := 1 close in vs2 = 1 vin := 0 Outlet Valve open out vin = 0 ∧ vs2 = 1 ∧ vreq = 1 vout := 1 close out vs1 = 0 vout := 0</formula><p>46th IEEE CDC, New Orleans, USA, Dec. <ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr">2007</ref> ThB04.3</p><p>III. AUTOMATA Typically, system behaviors are modeled using deterministic finite-state automata (FA). In what follows the word "ordinary" will be used synonymously with "deterministic finite-state".</p><p>A deterministic finite-state automaton A is a 4-tuple A = Q, Σ, →, q 0 where Q is a finite set of states; Σ (the alphabet) is a nonempty finite set of events; →⊆ Q × Σ × Q is the state transition function mapping elements of Q × Σ into singletons of Q and q 0 ∈ Q is the initial state.</p><p>The transition function is written in infix notation p σ → q. In particular, p σ → denotes that there exists a state q such that p σ → q. This notation is extended to strings in Σ * in the natural way by letting</p><formula xml:id="formula_1">p ǫ → p for all p ∈ Q; p sσ → q if p s → r and r σ → q for some r ∈ Q.</formula><p>For convenience, the notation A s → q is introduced as a short hand for q 0 s → q, where q 0 is the initial state of A. The behavior of a FA is described by its language. The language of A denoted L(A) is defined as</p><formula xml:id="formula_2">L(A) = {s ∈ Σ * : A s →}.</formula><p>To deal with interacting automata we use full synchronous composition (FSC) <ref type="bibr" target="#b15">[16]</ref>. This composition operator models that an event can occur in the synchronized system if and only if it can occur in all automata that share the event. Let A j = Q j , Σ j , → j , q j 0 , j = 1, 2 be two automata. The full synchronous composition (FSC) of A 1 and A 2 is</p><formula xml:id="formula_3">A 1 A 2 = Q 1 × Q 2 , Σ 1 ∪ Σ 2 , →, (q 1 0 , q 2 0 ) , where (p 1 , p 2 ) σ → (q 1 , q 2 ), σ ∈ Σ 1 ∩Σ 2 if p i σ → i q i , i = 1, 2; (p 1 , p 2 ) σ → (q 1 , q 2 ), σ ∈ Σ 1 \ Σ 2 if p 1 σ → 1 q 1 and p 2 = q 2 ; (p 1 , p 2 ) σ → (q 1 , q 2 ), σ ∈ Σ 2 \ Σ 1 if p 2 σ → 2 q 2 and p 1 = q 1 .</formula><p>The composition operator is easily extended to simultaneous composition of multiple automata.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. EXTENDED AUTOMATA</head><p>An Extended Finite Automaton (EFA) is an augmentation of the ordinary automaton with guard formulas and action functions. We associate the guards and actions to the transitions in the automaton. The transitions in the EFA are enabled if and only if the guard formula is true and when a transition is taken, updating actions of a set of variables may follow. To define guard predicates we use the characteristic function χ W of a set W . χ W is defined by</p><formula xml:id="formula_4">χ W (v) = 1 if v ∈ W 0 if v / ∈ W ,</formula><p>and is sometimes called the indicator function of W . If χ W (v) = 1 the predicate "v ∈ W " is true, and if χ W (v) = 0 the predicate is false. Definition 1 (Extended Automaton): An extended finite-state automaton E is a 6-tuple</p><formula xml:id="formula_5">E = Q × V, Σ, G, A, →, (q 0 , v 0 ) ,</formula><p>where:</p><p>(i) Q × V is the extended finite set of states, where Q is a finite set of locations and V is the finite domain of definition of the variables; (ii) Σ is a nonempty finite set of events (the alphabet);</p><formula xml:id="formula_6">(iii) G = {χ W | W ∈ 2 V } is the set of guard predicates over V . (iv) A = {a | a is a function from V to V } is a collection of action functions. (v) →⊆ Q × Σ × G × A × Q is the state transition relation. (vi) (q 0 , v 0 ) ∈ Q × V is the initial state.</formula><p>We have extended the states of the ordinary automaton to Q × V , where</p><formula xml:id="formula_7">V = V 1 × ... × V n . The finite set V is the domain of definition of an n-tuple of variables v = (v 1 , . . . , v n ) with initial values v 0 = (v 1 0 , . . . , v n 0 ) ∈ V .</formula><p>Formally speaking, the inclusion of G and A in the definition of E are superfluous since they only depend on V . In what follows, we therefore omit G and A when specifying an EFA.</p><p>The guards are predicates over the variables that relate each element of V , to either 1 (true) or 0 (false). We are interested in deterministic EFA, and therefore the actions are functions. Action functions a ∈ A maps the variable values of the present state to the variable values of the next state. Guards and actions are written as</p><formula xml:id="formula_8">k = g(v), where k ∈ {0, 1}; w := a(v) = (a 1 (v), . . . , a n (v)),</formula><p>where w ∈ V.</p><p>For convenience we use the symbol Ξ to denote implicit actions that update variables to their current value. Unlike explicit actions, Ξ can be overridden when EFA are synchronized, see <ref type="bibr" target="#b16">[17]</ref>. If a i = Ξ, we say that a i is a don't care updating of the variable v i .</p><p>The transition relation is written as p σ → g/a q, where p, q ∈ Q, σ ∈ Σ, g ∈ G and a ∈ A . If g is absent, it is assumed that g always evaluates to true. If a is absent, it is assumed that a = (Ξ, Ξ, . . . , Ξ) and no variable is updated during the transition 1 . Note that, the state transition relation is well defined when the guard always evaluates to false and no transition can take place. Actions and guards can be used to hide variable values in system transitions. However, it is sometimes convenient to write out the states (locations and variable values) explicitly in system transitions.</p><p>Definition 2 (Explicit State Transition Relation): Let E = Q × V, Σ, →, (q 0 , v 0 ) be an EFA. The explicit state transition relation of E is defined as</p><formula xml:id="formula_9">→ := {(p, v, σ, q, w) ∈ Q × V × Σ × Q × V | ∃p σ → g/a q such that g(v) = 1 and a(v) =: w or g(v) = 1, v = w and a = Ξ}.</formula><p>The explicit state transition relation is written (p, v) σ → (q, v ′ ) and it is extended to strings in Σ * in the usual recursive way. The language L(E) of an EFA E is 1 We consider event driven transitions. Dynamic transitions that take place when the guard becomes true are not considered here.</p><p>46th IEEE CDC, New Orleans, USA, Dec. <ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr">2007</ref> ThB04.3</p><formula xml:id="formula_10">L(E) = {s ∈ Σ * | (q 0 , v 0 ) s →}.</formula><p>In section V, we will need the notion of deterministic EFA.</p><p>Definition 3 (Deterministic EFA):</p><formula xml:id="formula_11">An EFA E = Q × V, Σ, →, (q 0 , v 0 ) is deterministic if (p, v) σ → (q, v ′ ) and (p, v) σ → (q ′ , v ′′ ) always implies (q, v ′ ) = (q ′ , v ′′ ).</formula><p>Note that for an EFA to be deterministic all explicit transitions (not just the reachable) must have this property. This seemingly strong condition is needed to ensure that the synchronized product of two deterministic EFA remains deterministic. Observe that if the guards are distinct, we support the possibility of having multiple transitions from the same location triggered by the same event. Verifying if a given EFA is deterministic can be non-trivial for EFA with large state-spaces. However, sufficient conditions that guarantee deterministic EFA are straightforward to formulate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Full Synchronous Composition, EFA</head><p>To simplify the notation when defining the full synchronous product of EFA, we assume that the EFA share all variables. This is no restriction since it is always possible to add don't care variables that are never updated. We will also assume that shared variables between EFA have the same initial values. As for ordinary automata, the composition operator models that an event can occur in the synchronized system if and only if it can occur in all EFA that share the event.</p><p>Definition 4 (FSC, EFA):</p><formula xml:id="formula_12">Let E k = Q k × V, Σ k , → k , (q k 0 , v 0 ) , k = 1, 2</formula><p>, be two EFA using the shared variables v = (v 1 , . . . , v n ). The Full Synchronous Composition (FSC) of E 1 and E 2 is</p><formula xml:id="formula_13">E 1 E 2 = Q 1 × Q 2 × V, Σ 1 ∪ Σ 2 , →, (q 1</formula><p>0 , q 2 0 , v 0 ) , where the state transition relation → is defined as</p><formula xml:id="formula_14">* (p 1 , p 2 ) σ → g/a (q 1 , q 2 ), σ ∈ Σ 1 ∩ Σ 2 if ∃(p 1 , σ, g 1 , a 1 , q 1 ) ∈→ 1 , ∃(p 2 , σ, g 2 , a 2 , q 2 ) ∈→ 2 such that: (i) g = g 1 ∧ g 2 ,</formula><p>(ii) For i = 1, . . . , n and ∀v ∈ V :</p><formula xml:id="formula_15">a i (v) =        a i 1 (v) if a i 1 (v) = a i 2 (v) a i 1 (v) if a i 2 (v) = Ξ a i 2 (v) if a i 1 (v) = Ξ v i otherwise ; * (p 1 , p 2 ) σ → g/a (q 1 , q 2 ), σ ∈ Σ 1 \ Σ 2 if (p 1 , σ, g, a, q 1 ) ∈→ 1 and p 2 = q 2 ; * (p 1 , p 2 ) σ → g/a (q 1 , q 2 ), σ ∈ Σ 2 \ Σ 1 if (p 2 ,</formula><p>σ, g, a, q 2 ) ∈→ 2 and p 1 = q 1 . Note that if the action functions of E 1 and E 2 explicitly try to update a shared variable to different values, the variable is, by default, not updated. Thus, the synchronized EFA may not have the intended behavior. A sufficient condition to avoid this possibility is:</p><p>Definition 5 (Action Consistent EFA):</p><formula xml:id="formula_16">Let E k = Q k × V, Σ k , → k , (q k 0 , v 0 ) , k = 1, 2, be two extended automata with shared variables v = (v 1 , . . . , v n ). E 1 and E 2 are action consistent if ∀(p 1 , σ, g 1 , a 1 , q 1 ) ∈→ 1 and ∀(p 2 , σ, g 2 , a 2 , q 2 ) ∈→ 2 it is true that: * ∀v ∈ V such that g 1 (v) ∧ g 2 (v) is true then a i 1 (v) = a i 2 (v) or one of a i 1 (v) and a i 2 (v) is a don't care updating of v i , i = 1 . . . n.</formula><p>Similar to definition 3, the action consistency condition is a global requirement and may be computationally expensive to check.</p><p>V. TRANSFORMING EFA TO FA Much research has been put into developing efficient algorithms and data structures for solving supervisory control problems formulated with ordinary automata. It has therefore been an important goal of our research to show how a set of EFA may be transformed into another set of equivalent FA.</p><p>In this section an algorithm for transforming EFA into equivalent FA is presented. The transformation is inspired by a translation from UML Statecharts to Finite-State Machines discussed in <ref type="bibr" target="#b17">[18]</ref>. The algorithm relies on variables with finite domain of definition. It collects the information stored in the guards and actions and builds two kinds of automata, variable automata and location automata, both with relabeled event sets. The variable automata model the updating of the variables, and the location automata has the same structure as the original extended automata. From a practical point of view it is important to point out that the transformation does not destroy the modular structure, this is important because the modular structure may be exploited by efficient verification and synthesis algorithms.</p><p>Definition 6: (Isomorphic FA) Let E = Q × V, Σ E , → E , (q 0 , v 0 ) be an EFA and A = R, Σ A , → A , r 0 be a FA. Let → E be the explicit state transition relation of E. E and A are isomorphic if the following conditions hold.</p><p>(i) Σ E =Σ A (ii) There exists a bijective function f from Q × V to R, such that f (q 0 , v 0 ) = r 0 and (q, v)</p><formula xml:id="formula_17">s → E (q ′ , v ′ ) ⇔ f (q, v) s → A f (q ′ , v ′ ).</formula><p>We place no restriction on the naming of the states in automata and therefore we call all ordinary automata that are isomorphic with the extended automaton E, the isomorphic FA of E. Note that, the isomorphic FA of a given EFA is obtained by replacing the state transitions relation → with the explicit state transition relation →.</p><p>A benefit of using EFA as a modeling tool is that the values of the variables in state transitions can be hidden. Usually, the explicit state transition relation → is not known. Instead the notation p σ → g/a q is used to describe system transitions in models. Here, we present an algorithm that transforms EFA models into FA models by extracting the information in the guard and action functions. This is done by building location automata and variable automata, introducing relabeled events, composing the system using the full synchronous composition and in the last step, changing back to the original event names.</p><p>Algorithm 1 presents in detail how a single EFA is transformed to its isomorphic FA. It is assumed that the 46th IEEE CDC, New Orleans, USA, Dec. <ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr">2007</ref> ThB04.3</p><p>guards have been parsed and written in disjunctive normal form g = g 1 ∨ . . . ∨ g j , where each and-clause</p><formula xml:id="formula_18">g i (v) = g i,1 (v 1 ) ∧ . . . ∧ g i,n (v n ), i = 1 . . . j, compares the variables with a constant in V = V 1 × • • • × V n .</formula><p>In Algorithm 1 |g| denotes the number of and-clauses of a guard written in disjunctive normal form and if</p><formula xml:id="formula_19">a k (v k ) = Ξ, it is understood that v k σi → a k (v k ) means a self loop at v k .</formula><p>We also assume that all actions are written as a(v) = (a 1 (v 1 ), . . . , a n (v n )). Any guard-action pair can be represented by multiple guard-action pairs where each action function has this form. It can be achieved by stepping through the domain of definition of all variables and creating multiple assignment functions.</p><p>Algorithm 1 (Basic Transformation Algorithm):</p><formula xml:id="formula_20">Let E = Q × V, Σ, →, (q 0 , v 0 )</formula><p>be an extended finite automaton where V = (V 1 , . . . , V n ) is the domain of definition for the variables v = (v 1 , . . . , v n ). The following steps build the isomorphic finite ordinary automaton A and define a renaming function Ψ(•):</p><p>1 For each transition p σ → g/a q in E, introduce |g| new events, all with unique names. Create a one to one mapping between each renamed event and an andclause g i in the guard g. 2 Collect all relabeled events in the alphabet Σ ′ . 3 Build a location automaton A loc = Q, Σ ′ , →, q 0 representing the location changes of E. Each transition p σ → g/a q is divided into regular transitions in A loc using the relabeled events in Σ ′ . The number of and-clauses |g| of the guard determine the number of transitions obtained from p σ → g/a q. 4 Build variable automata</p><formula xml:id="formula_21">A k v = V k , Σ ′ , →, v k 0 k = 1 . . . n, representing the updating of the variables. For each event σ i in Σ ′ , create transitions v k σi → a k (v k ) in G k v if g i,k (v k ) is true.</formula><p>5 Implement the guard by synchronizing all ordinary automata</p><formula xml:id="formula_22">A loc A 1 v • • • A n v .</formula><p>6 Let Ψ(•) be the mapping that maps each relabeled event in Σ ′ to its original event in Σ. The finite automaton A is obtained by applying Ψ(•) to all events in A loc A 1 v • • • A n v . Proposition 1: Algorithm 1 transforms an extended automaton E = Q × V, Σ, →, (q 0 , v 0 ) into its isomorphic ordinary automaton A.</p><p>Proof: It follows immediately that A has the same alphabet as E. The states of A are Q × V 1 × • • • × V n so we have a trivial bijective mapping between the states of A and the states of E. It remains to prove that the transition relation of A equals the explicit transition relation → of E. According to definition 2, we need to show that the transitions in A obtained from p σ → g/a q are all transitions (p, v) σ → (q, a(v)), such that g(v) is true. Let V i = (V 1 i , . . . , V n i ) ∈ V be the set where the and-clause g i evaluates to true. The set of all v such that g(v) is true can then be written as {V 1 , . . . , V j }, where j = |g|. For each transition p σ → g/a q in E, Algorithm 1 can be described as follows. For i = 1, . . . , |g|:</p><formula xml:id="formula_23">(i) Create α ∈ Σ ′ and p α → q in A loc , where α is unique. (ii) For k = 1, . . . n, create v k α → a k (v k ) for all v k ∈ V k i in A k v .</formula><p>(iii) Synchronizing all transitions in the ordinary automata triggered by α gives:</p><formula xml:id="formula_24">(p, v) α → (q, a(v)), ∀v ∈ V i in A loc A 1 v • • • A n v .</formula><p>(iv) Replacing all transitions in the synchronized system triggered by α with transitions triggered by σ gives:</p><formula xml:id="formula_25">(p, v) σ → (q, a(v)) ∀v ∈ V i in A.</formula><p>Hence,</p><formula xml:id="formula_26">p σ → g/a q in E is mapped to (p, v) σ → (q, a(v)) in A, if g(v) is true.</formula><p>Algorithm 1 transforms an EFA into a single monolithic ordinary automaton. We are interested in synthesis and verification of DES and we want to avoid the state-space explosion problem when all components are synchronized. Therefore we only implement the first four steps of the algorithm. Before the monolithic automaton is computed in step five, we have a model consisting of a number of ordinary automata A loc , A 1 v , . . . , A n v , whose alphabet Σ ′ , consists of relabeled events from the original alphabet Σ. We can relate L</p><formula xml:id="formula_27">(E) to L(A loc A 1 v • • • A n v</formula><p>) by extending the mapping Ψ(•) to strings; Ψ(ǫ) = ǫ, and Ψ(sσ) = t if Ψ(s) = r and rΨ(σ) = t for some r ∈ Σ * . Since Ψ(•) projects relabeled events to their original events, it follows that Ψ(L(</p><formula xml:id="formula_28">A loc A 1 v • • • A n v )) = L(E).</formula><p>Let ∼ be the equivalence relation on strings s, t in</p><formula xml:id="formula_29">L(A loc A 1 v • • • A n v )</formula><p>, where s ∼ t if Ψ(s) = Ψ(t). If the extended automaton E is deterministic then so is the isomorphic ordinary automaton A. This implies that if s ∼ t, then s and t visit the same states in</p><formula xml:id="formula_30">A loc A 1 v • • • A n v .</formula><p>Hence, the language that describes the behavior (or state-changes) of the ordinary automata model is L Typically, models are built using a number of interacting EFA. EFA that share variables and interact via the FSC can through their guard-action pairs exchange information during the synchronization process. In order to build ordinary automata that represent the synchronized behavior of multiple EFA, access to all guards and updating actions is needed for each transition in the synchronized system. The transformation must consider all components simultaneously. This fact implies that Algorithm 1 must be applied to all combinations of transitions in the synchronized system.</p><formula xml:id="formula_31">(A loc A 1 v • • • A n v )/∼. Most importantly, since Ψ(•) is a bijective mapping between L(E) and L(A loc A 1 v • • • A n v )/∼</formula><formula xml:id="formula_32">Let E k = Q k × V, Σ k , → k , (q k 0 , v 0 ) , k = 1, . . . , m be interacting EFA whose shared variables v = (v 1 , . . . , v n ) have domain V = (V 1 , . . . , V n ).</formula><p>The overall behavior of 46th IEEE CDC, New Orleans, USA, Dec. <ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr">2007</ref> ThB04.3</p><p>the system is described by the composition of all components using the FSC,</p><formula xml:id="formula_33">E = E 1 • • • E m .</formula><p>To obtain an isomorphic ordinary automaton A of the EFA E, we apply Algorithm 1 to all transitions p σ → g/a q of E, where p = (p 1 , . . . , p m ) and q = (q 1 , . . . , q m ) are locations in E 1 • • • E m . The difference is that the number of location automata in step 3 increase to m, i.e. instead of only one location automaton we have A k loc = Q k , Σ ′ , →, q k 0 , k = 1, . . . , m. By building the location automata and variable automata transition by transition the modular ordinary automata model (in step 4 of Algorithm 1) can be implemented using an algorithm that only consumes a polynomial amount of space. A FA model of the dosing tank, without relabeled events, is given figure <ref type="figure" target="#fig_3">3</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. CONCLUSIONS</head><p>The proposed modeling framework of extended finite automata (EFA) can be used to design supervisors for complex systems where ordinary finite automata (FA) modeling requires complex and possibly non-intuitive solutions. Due to the use of variables, guard expressions and action functions, the EFA formalism can hide information and represent systems more compact than FA. However, developing effective synthesis algorithms for automata that share variables is not an easy task. To overcome this difficulty we have provided an algorithm that transforms systems modeled by automata with shared variables into equivalent ordinary automata models. By examining the information exchange between all components of the model, we avoid building the product of the extended model and instead, we obtain an equivalent modular FA model. The algorithm is feasible for any finite modular system whose EFA share variables with finite domain. The modeling framework and supporting algorithms have been implemented in the supervisory control tool Supremica. Since Supremica also implements state-ofthe-art algorithms and data structures for dealing with large scale problems we hope that this work will facilitate the adaptation of the supervisory control ideas into industrial applications.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. A plant model of the dosing tank.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. A supervisor for the dosing tank.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>we can use the relabelled ordinary automata model obtained in step 4 of Algorithm 1 to analyze EFA models.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3.A model of the dosing tank example consisting of ordinary automata. It has been generated using the first four steps of Algorithm 1.</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The control of discrete event systems</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Ramadge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M</forename><surname>Wonham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE</title>
		<imprint>
			<biblScope unit="volume">77</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="81" to="98" />
			<date type="published" when="1989-01">Jan. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Hopcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Introduction to Automata Theory, Languages, and Computation</title>
		<title level="s">ser. Series in Computer Science</title>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
	<note>nd ed.</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Supervisory control of a rapid thermal multiprocessor</title>
		<author>
			<persName><forename type="first">S</forename><surname>Balemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Hoffmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gyugyi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wong-Toi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">F</forename><surname>Franklin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="1040" to="1059" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">PLC-based implementation of supervisory control for discrete event systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fabian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hellgren</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<pubPlace>Tampa, FL, USA</pubPlace>
		</imprint>
	</monogr>
	<note>in 37th Decision and Control</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Unity in diversity, diversity in unity: Retrospective and prospective views on control of discrete event systems</title>
		<author>
			<persName><forename type="first">X.-R</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Giua</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M</forename><surname>Wonham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Van Schuppen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Event Dynamic Systems</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="253" to="264" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Statecharts: A visual formalism for complex systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="231" to="274" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Modeling of discrete event systems using finite state machines with parameters</title>
		<author>
			<persName><forename type="first">Y.-L</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCA00</title>
		<meeting><address><addrLine>Anchorage, Alaska</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-09">Sept. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Embedded supervisory control of discreteevent systems</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gohari</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005-08">2005. August 2005</date>
			<biblScope unit="page" from="410" to="415" />
			<pubPlace>Edmonton, Canada</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Supervisory control on concurrent discrete event systems with variables (extended version)</title>
		<author>
			<persName><forename type="first">B</forename><surname>Gaudin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">H</forename><surname>Deussen</surname></persName>
		</author>
		<ptr target="http://www.benoit.gaudin1.free.fr" />
		<imprint>
			<date type="published" when="2006">2006</date>
			<pubPlace>Berlin</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Technical University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Synthesis of supervisors for parameterized and infinity non-regular discrete event systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Oliveira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kaestner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st IFAC Workshop on Dependable Control of Discrete Systems (DCDS&apos;07)</title>
		<meeting>the 1st IFAC Workshop on Dependable Control of Discrete Systems (DCDS&apos;07)</meeting>
		<imprint>
			<date type="published" when="2007-06">June 2007</date>
			<biblScope unit="page" from="77" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Nonblocking supervisory control of state tree structures</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wonham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="782" to="793" />
			<date type="published" when="2006-05">May 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">www.supremica.org. The official website for the Supremica project</title>
		<author>
			<persName><surname>Supremica</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Supremica-an integrated environment for verification, synthesis and simulation of discrete event systems</title>
		<author>
			<persName><forename type="first">K</forename><surname>Åkesson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fabian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Flordal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Malik</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006-07">July 2006</date>
			<biblScope unit="page" from="384" to="385" />
			<pubPlace>Ann Arbor, MI, USA</pubPlace>
		</imprint>
	</monogr>
	<note>in 8th Discrete Event Systems, WODES &apos;06</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Towards a framework for integrated supervisory and logic control</title>
		<author>
			<persName><forename type="first">K</forename><surname>Åkesson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sköldstam</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="83" to="88" />
			<pubPlace>Paris, France</pubPlace>
		</imprint>
	</monogr>
	<note>st Dependable Control of Discrete Event Systems&apos;07</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Modular control-loop detection</title>
		<author>
			<persName><forename type="first">P</forename><surname>Malik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">8th Discrete Event Systems, WODES &apos;06</title>
		<meeting><address><addrLine>Ann Arbor, MI, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-07">July 2006</date>
			<biblScope unit="page" from="119" to="124" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Communicating sequential processes</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">ser. Series in Computer Science</title>
		<imprint>
			<date type="published" when="1985">1985</date>
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Spivey</surname></persName>
		</author>
		<title level="m">The Z Notation: A Reference Manual</title>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A case study in verification of uml statecharts: the profisafe protocol</title>
		<author>
			<persName><forename type="first">R</forename><surname>Malik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mühlfeld</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Universal Computer Science</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="138" to="151" />
			<date type="published" when="2003-02">Feb. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title/>
		<author>
			<persName><surname>Ieee Cdc</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">Dec. 12-14, 2007 ThB04.3</date>
			<pubPlace>New Orleans, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
