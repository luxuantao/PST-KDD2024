<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An Overview of the mCRL2 Toolset and Its Recent Advances</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Sjoerd</forename><surname>Cranen</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Eindhoven University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jan</forename><forename type="middle">Friso</forename><surname>Groote</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Eindhoven University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jeroen</forename><forename type="middle">J A</forename><surname>Keiren</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Eindhoven University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Frank</forename><forename type="middle">P M</forename><surname>Stappers</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Eindhoven University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Erik</forename><forename type="middle">P</forename><surname>De Vink</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Eindhoven University of Technology</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Centrum Wiskunde &amp; Informatica</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Wieger</forename><surname>Wesselink</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Eindhoven University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Tim</forename><forename type="middle">A C</forename><surname>Willemse</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Eindhoven University of Technology</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">An Overview of the mCRL2 Toolset and Its Recent Advances</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">1AD0E26BF8063B14AE1C7CCCD3EF6FB4</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The analysis of complex distributed systems requires dedicated software tools. The mCRL2 language and toolset have been developed to support such analysis. We highlight changes and improvements made to the toolset in recent years. On the one hand, these affect the scope of application, which has been broadened with extended support for data structures like infinite sets and functions. On the other hand, considerable progress has been made regarding the performance of our tools for state space generation and model checking, due to improvements in symbolic reduction techniques and due to a shift towards parity gamebased solving. We also discuss the software architecture of the toolset, which was well suited to accommodate the above changes, and we address a number of case studies to illustrate the approach.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Distributed systems and parallel programs are becoming increasingly common as a result of easy access to cheap multi-core processors and the popularity of paradigms such as cloud computing. These systems are notoriously difficult to design correctly. To a large extent this is caused by the concurrency that results in a lack of insight in the global configuration of a system, and the sheer number of different configurations in which a system can be at any moment. Design flaws may result in loss of data or hanging software. Race conditions are a well-known example of such flaws. While an occasional hiccup may be tolerable for non-critical applications, this may be unacceptable if an application causes significant financial losses or increases safety risks.</p><p>The mCRL2 toolset is designed to reason about distributed and concurrent systems. mCRL2 is based on the process algebra μCRL <ref type="bibr" target="#b6">[7]</ref> and inherits its axiomatic view on processes. In μCRL, various methodologies for manually proving correctness of processes based on axiomatic reasoning were developed; these were adopted in mCRL2. The mCRL2 language, like its predecessor, is designed in such a way that it does not restrict the expressive freedom of the user. The data theory is still rooted in the theory of ADTs, but now comes with many builtin data types. Compared to μCRL, the process language has changed slightly but crucially, so semantics can be provided to languages with a notion of true concurrency.</p><p>The introduction of parameterised boolean equation systems <ref type="bibr" target="#b22">[23]</ref> in the mCRL2 toolset clearly marks the transition to a verification paradigm based on model checking. The model checking approach complements the axiomatic verification methodology offered in the toolset. Currently, the mCRL2 toolset consists of over 60 tools that together allow visualisation, simulation, minimisation and model checking of complex systems. This paper aims to offer an overview of the toolset and its usage. We highlight its conceptual and technical essentials, of which we illustrate the domain of application, emphasising on recent developments.</p><p>First, we provide a cursory overview of the mCRL2 language. We then explain the notions of linear process and equation system, which play a fundamental role in many of the algorithms implemented in the mCRL2 toolset. The most recent improvements and additions are highlighted, addressing amongst others tool performance, support for analysing real-time systems, and solving equation systems via parity games. To broaden the scope of application, mCRL2 interfaces with other specification languages. We report on initial investigations to reduce the work needed to keep these interfaces up-to-date.</p><p>As the code base of the mCRL2 toolset has expanded substantially over the last few years, maintainability has become an important aspect in the development of the toolset. We describe our efforts to reduce the amount of hand-written code, and to improve readability and documentation of our software. These and other concerns, such as interoperability, have led to architectural changes that we mention briefly.</p><p>The uses of the language and tools are sketched by summarising a selection of illustrative case studies conducted with mCRL2. We indicate where recently added techniques were instrumental for these case studies. Finally, we position our toolset in the broader context of verification tooling, and give an outlook on the challenges ahead. Documentation, sources and binaries of the mCRL2 toolset can be downloaded from the mCRL2 website www.mcrl2.org. The toolset is open source; the associated boost license allows free use for any purpose. A user manual also containing a tutorial can be found in the user documentation section of the website. The tutorial introduces the reader to the basic concepts and syntax and provides guidance for the tools most commonly used. Lecture notes used for a master course at Eindhoven University of Technology and Delft University of Technology, approaching a final draft, are available from the mCRL2 website too.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">mCRL2: Approach, Applications and Challenges</head><p>The mCRL2 language consists of three different sublanguages: a data language, a process language, and a property language. Following the philosophy underlying mCRL2, convenience of modelling and expressiveness have been leading in the respective definitions. We briefly discuss the three sublanguages below. For an in-depth treatment of the language, we refer to the website and the publications and material mentioned there.</p><p>In mCRL2 data and transformations on data are described using abstract data types. This allows users to create their own data types by defining the appropriate constructors and by providing functions operating on the data types. The mCRL2 data language has built-in support for commonly used data types, like the booleans, natural numbers, integers and reals. The usual operations on these data structures are predefined. Complex types can be constructed using type constructors such as sets, lists, and functions over any data type. Notation for built-in data types stays close to mathematics: numbers are written as sequences of decimals, without a limit on the size of the numbers. Sets are written using set comprehension. Functions are first-class citizens, and can be used to obtain concise models. The language allows in-line lambda abstraction as well as function updates. For example, the function doubling every natural number can be defined using the lambda abstraction lambda n:Nat.n+n. The function that doubles every natural number, but maps the number 4 to 0 can be defined using a function update ( lambda n:Nat.n+n ) <ref type="bibr">[ 4-&gt;0 ]</ref>.</p><p>The behaviour of a system is described by processes, composed from a set of user-defined actions and a set of operators on actions and processes. These operators include multi-action composition, sequential, alternative and parallel composition and abstraction operators. The language also offers primitives to model real-time systems. Processes are defined in the context of data definitions describing the data types that are used and the operations upon them. This permits the modelling of systems whose behaviour crucially depends on the data that is exchanged: actions can be parameterised by data and if-then-else constructs allow for specifying conditional process behaviour. The semantics of processes is defined using a structural operational semantics, which associates with every expression in the language a labelled transition system (LTS). Such a labelled transition system is viewed as a graph consisting of vertices and edges, where each edge is labelled with an action, which in turn can have data parameters. The information contained in vertices is represented by a process expression and a valuation of its data parameters, but is unobservable; behaviour is determined by the actions.</p><p>High-level properties can be described using an extension of Kozen's propositional modal μ-calculus. Least and greatest fixpoint operators, which may be nested arbitrarily, can be used in combination with modal operators to describe requirements of increasing complexity. In this manner it is for instance possible to specify fairness properties, thereby staying true to the design philosophy that the modeller should not be restricted in his or her expressive freedom. The property language is equipped with constructs for reasoning about timed processes. Semantically, expressions in the property language identify a set of states in a given labelled transition system (namely, those states that satisfy the property).</p><p>Although unrestrictive, the μ-calculus is an intricate formalism. Its usability is improved by providing a set of powerful, intuitive macros, inspired by the regular expressions found in PDL. In many practical situations, this eliminates the need for fixpoint operators. For instance, safety properties asserting that a system should not exhibit a sequence of actions matching the regular expression r simply becomes [r]false. The existence of such a sequence is expressed as &lt; r&gt;true. By mixing regular expressions and fixpoints, one can build more complex formulae that are still easy to read. For instance, the expression nu X.&lt; r&gt;X asserts that there is an infinite path of action sequences matching the regular expression r. If, for instance, r a*.b, it says that there is a path consisting of an infinite number of b actions, interrupted by finite sequences of a actions.</p><p>The ability to use parameterised actions in the process specification language requires similar capabilities in the property language. Like processes, properties are therefore interpreted in the context of a data specification. Fixpoint variables and actions can be parameterised with data, boolean expressions may contain data variables, and universal and existential quantification over (possibly infinite) data types are allowed. Action formulae denote (potentially infinite) sets of parameterised actions. For example, one may write true to denote the set of all actions, or exists n:Nat.val( n &gt; 5 )&amp;&amp; s(n) to denote the set of s(n) actions, where n&gt;5. The property [ true*. exists n: Nat.val( n &gt; 5 ) &amp;&amp; s(n) ]false then expresses that such an action never occurs.</p><p>The expressiveness of the mCRL2 property language makes it well-suited for reasoning about complex distributed systems. Its expressivity is witnessed by the fact that one can easily encode the counting μ-calculus <ref type="bibr" target="#b25">[26]</ref> in it, which is known to be strictly more expressive than the propositional μ-calculus. The incorporation of data even enables succinct transformations from popular temporal logics. In <ref type="bibr" target="#b11">[12]</ref>, we reported on a linear transformation from CTL ¦ to our μ-calculus; the transformation of CTL ¦ to the equational propositional modal μ-calculus is exponential <ref type="bibr" target="#b4">[5]</ref>.</p><p>The expressive power of the mCRL2 language also has serious consequences as far as automation is concerned. Heuristics are required to work around the general undecidability of the data theory. Quantifier elimination cannot simply rely on exhaustive enumeration of all elements of a data type in case the carrier of the latter is of infinite size. The ability to use unrestricted mixing of least and greatest fixpoints in the μ-calculus may lead to computationally intractable decision problems. In the past years, we have made significant improvements in the mCRL2 toolset to cope with the consequences of the expressive power of the mCRL2 language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The mCRL2 Toolset</head><p>The mCRL2 toolset consists of over 60 tools that together allow for analysing complex system designs formally described in the mCRL2 language. Internally, the toolset relies on two types of objects, viz. linear processes <ref type="bibr" target="#b20">[21]</ref> and parameterised boolean equation systems <ref type="bibr" target="#b22">[23]</ref>. The toolset offers full control over these objects, equipping users with tools to manipulate and transform them. Below, we explain these concepts in more detail, and we indicate what progress was made in recent years.</p><p>Linear Processes. Any analysis on mCRL2 specifications is preceded by an automated transformation of the specification to the linear process format.</p><p>Technically, a linear process is again an mCRL2 process specification adhering to a restricted grammar, which essentially is a syntactic format for the singlestep transition relation that a process induces. That is, a linear process is a recursive equation, in the untimed setting, of the following form:</p><formula xml:id="formula_0">P Ôd:DÕ ô iÈI ô ei:Di c i Ôd, e i Õ α i Ôd, e i Õ ¤ P Ôf i Ôd, e i ÕÕ</formula><p>The state space is represented by variable d of sort D. In practice, this is a vector of variables of complex sorts. Each i È I describes a condition-action-effect expression, stating that a multi-action α i , consisting of actions with parameters that depend on variable d and local variable e i , can be executed, provided boolean condition c i evaluates to true for the values for d and e i . The result of executing this multi-action is a state transition to f i Ôd, e i Õ. The choice between the different condition-action-effect expressions from I is resolved nondeterministically. The transformation to the linear process format is based on the expansion laws of the parallel operator of the mCRL2 process specification language. User control over linear processes is one of the distinguishing advantages of the mCRL2 toolset.</p><p>Behaviour-preserving transformations on linear processes are useful for reducing their complexity by either reducing the complexity of the data types occurring in a linear process, reducing the number of data parameters of a process, or by replacing data expressions with simpler ones. In some instances these techniques even allow one to handle processes with infinite state spaces. Typical situations in which such manipulations are very effective occur when verifying data transfer protocols, where the payload of messages is not important.</p><p>More recently, an experimental tool was developed to transform linear processes with real-valued data sorts, representing infinite state spaces such as timed systems, into linear processes representing finite ones. The tool performs a form of predicate abstraction, where the predicates are limited to linear equations over the real-valued parameters of the process.</p><p>Linear processes can be simulated, and their state space can be explicitly generated and stored. State space generation from a linear process is sped up considerably by caching the evaluation of summands in the spirit of <ref type="bibr" target="#b5">[6]</ref>, and by pruning parts of the linear process that do not contribute transitions. Typically these techniques speed up state space exploration by a factor 10 to 100. Explicit state spaces can be reduced using behavioural equivalences like strong and branching bisimulation. Implementations of simulation preorders and equivalences, as well as a divergence preserving variant of branching bisimulation have also been made available. Moreover, LTSs can be analysed using a variety of advanced, interactive visualisation techniques for both small and large state spaces in 2D and 3D <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b39">39]</ref>.</p><p>Parameterised Boolean Equation Systems (PBESs) or just equation systems, for short, are essentially systems of least and greatest fixpoint equations over predicates involving parameterised predicate variables. Typically, a single equation has the form μXÔd:DÕ ϕ or νXÔd:DÕ ϕ. Here, X is a predicate variable, d is a formal variable of some sort D, and ϕ is a predicate formula in positive form, containing boolean expressions, predicate variables, conjunctions, disjunctions and existential and universal quantifications. The μ and ν sign indicate whether, respectively, the least or largest solution for X satisfying the equation is desired. Thus, an equation system is viewed as a finite, ordered sequence of equations for distinct predicate variables.</p><p>The problem of deciding whether a given property expressed in the μ-calculus holds for a given process specification is automatically encoded in an equation system such that the property holds for the specification if and only if the solution to the equation system is true <ref type="bibr" target="#b21">[22]</ref>. Apart from model checking problems, also the equivalence of two processes modulo a process equivalence can be decided by encoding it into an equation system, following the encoding of <ref type="bibr" target="#b8">[9]</ref>. This transformation is interesting when comparing infinite state spaces. Comparing finite state spaces is more efficient using traditional algorithms.</p><p>We are primarily interested in the solution of a PBES, as it is also the answer to the encoded problem. In many cases, however, manipulations and simplifications are needed before the equation system can actually be solved within the available memory and time. In the past years, we have added new tools implementing solution-preserving manipulations. Inspired by a similar technique operating on linear processes, an algorithm has been added that removes data parameters from propositional variables if they do not affect the solution, see <ref type="bibr" target="#b33">[34]</ref>. Other tools implement the automated detection of invariants of equation systems <ref type="bibr" target="#b34">[35]</ref> and use these to simplify the predicates in the equations, again without affecting the solution to the encoded verification problem. The computational complexity of these techniques is low, operating at the level of the syntax, but their effects on the time needed to solve the equation systems can be tremendous. Recently, abstract interpretation technology for equation systems was added, allowing one to reduce complex, potentially infinite data types to simpler, finite data types. A recent theoretical analysis of the underlying theory <ref type="bibr" target="#b14">[15]</ref> revealed that this technique is more powerful than model checking based on abstractions using modal transition systems, such as <ref type="bibr">[38]</ref> and their generalisations using hypertransitions, see e.g. <ref type="bibr" target="#b42">[42]</ref>.</p><p>Solving a PBES typically proceeds by transforming it into an equation system in which all data parameters and data expressions have been eliminated <ref type="bibr" target="#b35">[36]</ref>. Such equation systems, which are systems of fixpoint equations over propositions, are called boolean equation systems or BESs <ref type="bibr" target="#b30">[31]</ref>. Solving boolean equation systems is known to be a decidable problem. The transformation process bears many similarities to the computation of a state space from a specification. An essential step in transforming equation systems to boolean equation systems is the simplification of predicates. Quantifier elimination technology is essential to make such transformations efficient. The approach taken here is that of constructor induction, as outlined in <ref type="bibr" target="#b35">[36]</ref>, which works regardless of whether data types are finite or infinite. Special rules, such as the one-point rule, help speeding up the quantifier elimination, and are often necessary to ensure termination.</p><p>An intuitive method for solving boolean equation systems is through Gauss elimination <ref type="bibr" target="#b30">[31]</ref>. The algorithms for solving boolean equation systems that were first offered in the toolset are based on this algorithm. While, technically, Gauss elimination is independent of the alternation depth, in practice, this method scaled poorly on verification problems obtained from fairness problems, which require μ-calculus formulae of alternation depth 2 or more. We therefore exploit the tight connection between boolean equation systems and parity games <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b19">20]</ref>. To efficiently generate a parity game from a PBES, an alternative way of generating a PBES from an LPS and a μ-calculus formula was recently introduced. Several algorithms for solving parity games have been made available to users of the toolset. Most notably, implementations of the Small Progress Measures <ref type="bibr" target="#b26">[27]</ref> algorithm and the Recursive Algorithm <ref type="bibr" target="#b50">[50]</ref> are available. For most model checking problems, these are very competitive, even for μ-calculus formulae of alternation depth 2 and beyond. Moreover, bisimulation-inspired reductions for boolean equation systems <ref type="bibr" target="#b28">[29]</ref> and parity games <ref type="bibr" target="#b13">[14]</ref> have been instrumental in solving PBESs where more direct approaches failed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Interfacing with Other Languages</head><p>The state space exploration facilities and model checking capabilities of the mCRL2 toolset can be used in combination with various other specification languages.</p><p>So-called narration and annotation of security protocols can be expressed in the process algebra LySA, a variant of the π-calculus that uses pattern matching to deal with encrypted data, cf. <ref type="bibr" target="#b7">[8]</ref>. Static analysis of LySa processes has been applied to find authenticity and authentication issues. The conversion of a LySa specification into mCRL2, which in particular reflects the treatment of data, makes it possible to do complementary behaviour-oriented analysis.</p><p>Using the channel-based coordination language Reo, so-called connectors can be defined to orchestrate the interaction in a component-based system or a service-oriented application <ref type="bibr" target="#b0">[1]</ref>. A transformation of Reo connectors into mCRL2 adds model checking to the extensive tool suite for Reo. The synchronicity of ports that is typical for Reo fits well with the notion of multi-action incorporated in mCRL2 and lies at the heart of the efficiency of the transformation.</p><p>The mCRL2 toolkit accepts a number of other languages for input. These include the Petri net mark-up language PNML <ref type="bibr" target="#b48">[48]</ref>, the discretely timed part of the hybrid process algebra χ <ref type="bibr" target="#b2">[3]</ref>, a subset of executable UML <ref type="bibr" target="#b31">[32]</ref>, as well as a number of domain specific languages like SML, a control language based on finite state machines used at CERN <ref type="bibr" target="#b17">[18]</ref>, and TRECS, a language that manages resource availability <ref type="bibr" target="#b32">[33]</ref> in the wafer steppers manufactured by ASML.</p><p>Not only the many differences between these languages, but also the evolution of their syntax and their semantics makes it difficult to maintain the dedicated tools that implement the various transformations. In fact, some of the frontends mentioned have been marked deprecated in the latest releases of the mCRL2 toolset. To alleviate part of the burden, we are investigating a generic method to transform external specification formalisms into mCRL2 using Plotkin's structural operational semantics (SOS) as a common representation format.</p><p>Using this method, specifications in any language with a structural operational semantics can be transformed into a linear process. This is done by transforming the SOS into an mCRL2 data specification, and the specification under study into an mCRL2 data structure, which are then embedded in a process. This results in an mCRL2 process that encodes the semantics of the specification, and that can be analysed with all the means provided by the mCRL2 toolset. In <ref type="bibr" target="#b44">[44]</ref>, the underlying algorithm is explained for rules in the De Simone format <ref type="bibr" target="#b15">[16]</ref>, which is one of the most elementary rule formats for SOS. Extensions to the rule format, e.g. to include predicates, look-aheads and negative premises, can be handled in a similar manner <ref type="bibr" target="#b43">[43]</ref>.</p><p>While the approach is promising from a maintenance point of view, the encoding described above yields models that currently require too much time to verify in practice. Further research is therefore needed to make the technique usable on a larger scale.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Architecture and Implementation</head><p>The mCRL2 toolset is a collection of tools written in portable C++. Development started around eight years ago, and the code base has steadily grown since then. At present it has more than 200K lines of code, is open source, is supported on 32bit and 64-bit platforms and runs on most popular operating systems, including Linux, FreeBSD, Windows and Apple Mac OS X. Over the years development and testing of the mCRL2 toolset has matured. The code has been refactored and set up as a collection of libraries with well-defined interfaces. Code has been documented, and regression and performance tests are now run on a daily basis. Recently, commercial spin-off activities based on the mCRL2 toolset have started.</p><p>The toolset accommodates two kinds of users. End-users use the toolset for verification and validation of formal models, while the toolset also serves as a vehicle for experimental research. For end-users, correctness of the code and high-performance are the most important. Experimental researchers on the other hand require a high degree of flexibility, since they frequently want to test new ideas and algorithms. Many algorithms have been (re-)written to make the code correspond closely to pseudo-code specifications of the algorithms. This greatly improves the communication between experimental researchers and developers, which is often challenging in academic environments. The pseudo-code is also instrumental in establishing correctness of the algorithms, and in localising bugs.</p><p>A number of techniques are employed to support these different kinds of usage. Generic programming is applied to improve adaptability of the code. Notably, a universal framework for traversing the tree-like data structures in mCRL2 has been developed, which lies at the heart of many algorithms in the toolset. This framework uses static polymorphism, both for efficiency reasons and to support a modular design. Code generation from concise specifications makes it easier to incorporate changes, and increases code reuse, which in turn reduces errors.</p><p>Most of the traversal framework, and many classes and their operations consist of generated code. Currently about 17% of the code is generated, and this number is expected to increase further.</p><p>The mCRL2 toolset has a highly expressive input language. Therefore, test coverage has always been a problem. Recently, random testing has been applied to increase coverage. Randomly generated PBESs have proven to be successful in discovering otherwise hard to find bugs, like subtle cases where name clashes between quantifier variables in formulas were handled incorrectly. Currently the random generation of LPSs and state spaces is under development.</p><p>In the backend, mCRL2 provides interfaces to other tools. On the one hand, standardised file formats such as Aldebaran (.aut) and Binary Coded Graphs (.bcg) are used to export labelled transition systems to other tools such as CADP <ref type="bibr" target="#b18">[19]</ref>. In the mCRL2 toolset, stable interfaces are provided for state space exploration. These have been designed in such a way that compile and link dependencies of tools using an interface can be kept to a bare minimum, to prevent API breakage. In close collaboration with its developers a coupling has been established with LTSmin <ref type="bibr" target="#b5">[6]</ref>, that enables symbolic and parallel state space generation of LPSs. Recently, an interface has also been added that enables instantiation of equation systems into parity games using LTSmin. As a result, the parallel and symbolic exploration techniques from LTSmin can now also be used to solve PBESs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Applications and Case Studies</head><p>The purpose of the mCRL2 toolset is twofold. On the one hand, it aims to provide a set of state-of-the-art tools for the analysis of distributed systems. On the other hand, it serves as a platform to test research ideas in practice.</p><p>Below, we briefly report on three case studies conducted using the toolset, to offer a glimpse into the application domains of mCRL2. The first case study illustrates that the recent integration with LTSmin tool can help to reduce verification times substantially. The second case study illustrates that the mCRL2 multi-action can be essential for modelling systems and that parity game reduction techniques can be crucial for conducting the verification. The third case study demonstrates that case studies can be instrumental in improving the quality of the toolset. DIRAC: a distributed community grid solution. The high-energy experiments conducted at the large hadron collider of CERN generate a massive amount of raw data. A computing grid solution called DIRAC offers users uniform and reliable access to storage and computing resources. Despite a decade of continuous investment in developing and maintaining DIRAC, parts of the system occasionally enter inconsistent states, leading to a loss of efficiency and a potential loss of data. In an effort to tackle the problem at its root, the critical DIRAC subsystems have been modelled and analysed in mCRL2 <ref type="bibr" target="#b40">[40]</ref>. The models of the subsystems were verified using model checking. Modal μ-calculus formulae expressing liveness and safety requirements were formalised. Typical requirements stated, for example, that jobs are always processed once submitted, and that jobs never enter an inconsistent state. Violations of these requirements revealed livelocks and race conditions, explaining phenomena observed in the actual system.</p><p>The technology enabling the verification was the symbolic exploration (using the equation system interface with LTSmin, see <ref type="bibr" target="#b27">[28]</ref>) and solving of the equation systems encoding the model checking problems. This allowed for a full verification of the system in under 60 seconds on a 64 bit Intel Core Duo (1.6GHz) machine with 2 GB RAM. For comparison, the model checking problem for a single property required more than 50 hours when conducted using explicit state space generation approaches, exploring well over 1.5 ¤ 10 8 states. Attempts to employ compositional verification, relying on equivalence reductions to minimise state spaces, failed due to the fact that the individual processes that make up the subsystems have infinite state spaces.</p><p>FlexRay is a communication protocol that was developed by a consortium of automotive companies. Its final version was published in 2012. The protocol is designed to provide a reliable, high-bandwidth communication channel between nodes, with predictable timing properties. The protocol is time-triggered, that is, the protocol relies on nodes (senders and receivers of messages) to have synchronised clocks, and operates by allocating bandwidth to senders based on a global, cyclic schedule. Using mCRL2, the FlexRay startup procedure, which ensures that activated nodes will find each other and will correctly initialise their local view on the global schedule, was modelled and checked for correctness <ref type="bibr" target="#b10">[11]</ref>. The rich data language, and the modularity of the process language of mCRL2 allowed to specify the FlexRay protocol closely. In the protocol, there is a notion of macroticks, clock ticks that are generated by one process and communicated to the other processes using events. To model the synchronisation that these macroticks induce, multi-actions were used to create a form of barrier synchronisation.</p><p>To review the robustness of the protocol, faults that might occur in the system were modelled, which could mostly be done by making small, local changes to the fault-free model. The property language of mCRL2 showed itself conveniently expressive to define relatively complicated properties. For instance, the property that eventually all nodes in the network will keep sending messages according to their schedule was expressed as a μ-calculus formula that uses fixpoints parameterised with data variables representing sets, and user-defined functions to specify the schedule. The properties were verified by creating a PBES, expanding it and solving the resulting BES. Solving time for these (large) equation systems was reduced by interpreting the BES as a parity game, reducing that game using a notion of stuttering equivalence tailored to parity games, and then solving the reduced game <ref type="bibr" target="#b12">[13]</ref>. Domain Specific Languages. Domain specific languages, or DSLs, have become increasingly popular with high-tech industry to speed up their design and development cycles. Although DSLs provide an easy way to design software for a specific domain, they do not guarantee correctness of the designs. Through DSLs, however, techniques from the mCRL2 toolset can be made available to industry.</p><p>If an SOS-style operational semantics is available for a DSL, the transformation technique discussed in Section 4 can be used to analyse it using mCRL2. However, many domain specific languages are still defined informally. In <ref type="bibr" target="#b45">[45]</ref> we report on a case study of the formalisation of an industrial DSL, called TRECS. The execution semantics was implicitly defined by the implementation of the TRECS interpreter. By formalising the language, that is, by creating an SOS for its syntactic constructs and subsequent application of the semantic transformation, we were able to discoverand improve upon-sub-optimal design decisions using the mCRL2 toolset.</p><p>To further investigate the applicability of the approach, we took the formal definition of the mCRL2 language itself and encoded it into mCRL2 again by applying the same procedure <ref type="bibr" target="#b46">[46]</ref>. The SOS consisted of 43 deduction rules and resulted in an mCRL2 specification of slightly over 1000 lines of code. Our effort revealed a number of subtle differences between the specified, intended and the implemented semantics. In particular, the definition of the mCRL2 language allows for the use of existential quantifiers within a set comprehension scheme, but this possibility was overlooked in the actual implementation of the linear specification generator. The exercise led to improvements in the toolset and the documentation of the language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related Work</head><p>The mCRL2 toolset was originally based on the toolset associated with μCRL <ref type="bibr" target="#b6">[7]</ref>. As such, a lot of the functionality of the μCRL toolset can still be found in the mCRL2 toolset.</p><p>The toolset that-in terms of functionality-most resembles the mCRL2 toolset is CADP, developed in Grenoble <ref type="bibr" target="#b18">[19]</ref>. It uses the specification language Lotos NT, which, like the process language of mCRL2, has its roots in process algebra; it has a property language that is, like the mCRL2 property language, based on a variant of the propositional μ-calculus, and, like in the mCRL2 toolkit, verification is conducted using equation systems. Both toolsets offer the basic functionality of minimising explicit labelled transition systems and visualising these; CADP offers a slightly richer set of equivalences that can be used to reduce with, whereas mCRL2 offers more advanced interactive 2D and 3D visualisation tooling. There are a few key differences between the two toolsets. While the mCRL2 toolset is fully open source, CADP's license imposes more restrictions. Model checking in CADP is essentially limited to alternation-free μ-calculus formulae, with limited support for alternation depth 2 formulae, whereas potentially mCRL2 can verify μ-calculus formulae of arbitrary alternation depth. Unlike CADP, mCRL2 can be used to specify and analyse real-time systems. On the other hand, CADP provides features to support performance evaluation, which are lacking in mCRL2. Finally, there are differences in the philosophy between CADP and mCRL2: the latter provides full control over objects such as linear processes and equation systems, whereas in CADP objects fulfilling similar roles are hidden from the user.</p><p>Process algebras from the CSP family are less closely related to mCRL2. For example, the FDR2 toolset <ref type="bibr" target="#b41">[41]</ref> is based on checking refinement relations such as failure-divergence inclusion between specifications and implementations. It has support for static analysis and compositional reasoning; facilities for model checking are limited to a predefined set of properties such as (the absence of) livelock, deadlock and determinism. The PAT toolset <ref type="bibr" target="#b47">[47]</ref> provides similar features, but additionally supports specifying and analysing real-time systems and it is capable of LTL-based model checking. Furthermore, it comes with advanced techniques such as partial order reduction and symmetry reduction.</p><p>Prominent tools focussing on model checking include SPIN <ref type="bibr" target="#b24">[25]</ref> and nuSMV <ref type="bibr" target="#b9">[10]</ref>. The languages supported by these tools have more restricted data types (generally booleans or bits, limited range integers and finite arrays). SPIN uses a C-like process specification language Promela for the analysis of parallel programs. It primarily focusses on LTL model checking. Properties can be established by augmenting the specification with assertions and so-called 'never claims', which are either obtained from LTL formulae or constructed manually. The tool is most famous for its use of partial order reduction and bit hashing technology. The tool DiVinE is an LTL model checker built for grid and multi-core platforms <ref type="bibr" target="#b1">[2]</ref>. It is an automatonbased tool providing a high-performance parallel computing engine. The nuSMV toolset exploits clever data structures such as BDDs to compactly represent large state spaces. Model checking in nuSMV is currently limited to CTL and LTL properties. It also offers support for bounded model checking using SAT solving.</p><p>Several toolsets are optimised for verifying specifications with predominantly quantitative aspects. These include real-time and probabilistic model checking, with tools such as Uppaal <ref type="bibr" target="#b3">[4]</ref> and Prism <ref type="bibr" target="#b29">[30]</ref> The tool Uppaal is based on the notion of timed automata and uses graphs to draw behaviour which can be used to describe timed behaviour. Model checking of a restricted temporal logic is solved elegantly relying on efficient representations and manipulations of time regions. The tool Prism targets discrete and continuous-time Markov chains and decision processes. It supports simulation and model checking of PCTL and CSL.</p><p>In Section 5, we already mentioned the LTSmin toolset <ref type="bibr" target="#b5">[6]</ref> as one of the backends for mCRL2. Contrary to the toolsets listed above, LTSmin has no dedicated language. Instead, it provides highly optimised state space generation tools employing multi-core, parallel and symbolic reachability analysers and model checkers, and it is used as back-ends for, e.g., DiVinE, SPIN and mCRL2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Closing Remarks</head><p>The mCRL2 language and toolset provide end-users with state-of-the-art tools for analysing complex, distributed systems. In developing the mCRL2 toolset we aim to uphold a consistent and reliable user experience across the various supported operating systems, viz., Linux, Windows, Apple Mac OS X and FreeBSD. For instance, we recently ported all our graphical tools from wxWidgets to Qt for this reason. On the other hand, the toolset serves as a platform for testing research ideas in practice. This requires flexible code that is easy to adapt. Some of the older parts of the toolset have not been written with adaptability in mind, making it harder to experiment with these. Efforts are being made to change this. For example, the type checker of the language is scheduled for replacement by a much more generic and modularised version. While we consider such maintenance to be necessary for the progress of the toolset, it distracts from more fundamental research.</p><p>Several challenges lie ahead. Underlying many of the algorithms for manipulating linear processes and equation systems in the mCRL2 toolset is a rewrite engine. The rewriter enables automated reasoning about data expressions found in the linear processes and equation systems. Therefore, the efficiency of our tools depends, to a large extent, on the performance of the rewriter. Currently, we use just-in-time rewriting <ref type="bibr" target="#b36">[37]</ref>, which has been improved using strategy trees and matching trees <ref type="bibr">[49]</ref>. These are in essence techniques that reduce the number of checks that have to be done in the rewrite engine. Nonetheless, the current first-order rewriter sometimes causes performance problems when dealing with more advanced language constructs such as lambda expressions, which we expect to be able to solve using a generic higher-order rewriter. Such a rewrite engine is currently under development.</p><p>At the same time, a few of our algorithms rely on a theorem prover based on binary decision diagrams with equations. It may be beneficial to use dedicated provers like SMT solvers for some problems instead. Limited support for integrating SMT solvers is already present in several experimental tools. Integrating them more robustly in the toolset and using them in more places is part of our ongoing investigations. In particular, we are investigating possible ways to connect SMT solvers with the abstraction tooling for PBESs <ref type="bibr" target="#b14">[15]</ref>.</p></div>		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Reo: a channel-based coordination model for component composition</title>
		<author>
			<persName><forename type="first">F</forename><surname>Arbab</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Structures in Computer Science</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="329" to="366" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">DiVinE Multi-Core -A Parallel LTL Model-Checker</title>
		<author>
			<persName><forename type="first">J</forename><surname>Barnat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Brim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ročkai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ATVA 2008</title>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">S )</forename><surname>Cha</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J.-Y</forename><surname>Choi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Kim</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">I</forename><surname>Lee</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Viswanathan</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5311</biblScope>
			<biblScope unit="page" from="234" to="239" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Syntax and consistent equation semantics of hybrid Chi</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Van Beek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic and Algebraic Programming</title>
		<imprint>
			<biblScope unit="volume">68</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="129" to="210" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A Tutorial on Uppaal</title>
		<author>
			<persName><forename type="first">G</forename><surname>Behrmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SFM-RT 2004</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Bernardo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Corradini</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3185</biblScope>
			<biblScope unit="page" from="200" to="236" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Efficient model checking via the equational µ-calculus</title>
		<author>
			<persName><forename type="first">G</forename><surname>Bhat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cleaveland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="304" to="312" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">LTSmin: Distributed and Symbolic Reachability</title>
		<author>
			<persName><forename type="first">S</forename><surname>Blom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van De Pol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Weber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 2010</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Touili</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Cook</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Jackson</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6174</biblScope>
			<biblScope unit="page" from="354" to="359" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">µCRL: A Toolset for Analysing Algebraic Specifications</title>
		<author>
			<persName><forename type="first">S</forename><surname>Blom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Fokkink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Groote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Van Langevelde</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Lisser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van De Pol</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 2001</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Berry</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Comon</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Finkel</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2102</biblScope>
			<biblScope unit="page" from="250" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Automatic validation of protocol narration</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bodei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CSFW 2003</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="126" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Equivalence Checking for Infinite Systems Using Parameterized Boolean Equation Systems</title>
		<author>
			<persName><forename type="first">T</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ploeger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van De Pol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A C</forename><surname>Willemse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CONCUR 2007</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Caires</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">V</forename><forename type="middle">T</forename><surname>Vasconcelos</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4703</biblScope>
			<biblScope unit="page" from="120" to="135" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">NuSMV 2: An OpenSource Tool for Symbolic Model Checking</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Giunchiglia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Giunchiglia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pistore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Roveri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sebastiani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tacchella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 2002</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Brinksma</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2404</biblScope>
			<biblScope unit="page" from="359" to="364" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Model Checking the FlexRay Startup Phase</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cranen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FMICS 2012</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Stoelinga</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Pinger</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7437</biblScope>
			<biblScope unit="page" from="131" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A linear translation from CTL* to the first-order modal µ-calculus</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cranen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Groote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Reniers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">412</biblScope>
			<biblScope unit="page" from="3129" to="3139" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Stuttering Mostly Speeds Up Solving Parity Games</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cranen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J A</forename><surname>Keiren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A C</forename><surname>Willemse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NFM 2011</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Bobaru</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Holzmann</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Joshi</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6617</biblScope>
			<biblScope unit="page" from="207" to="221" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A Cure for Stuttering Parity Games</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cranen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J A</forename><surname>Keiren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A C</forename><surname>Willemse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICTAC 2012</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Roychoudhury</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>D'souza</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7521</biblScope>
			<biblScope unit="page" from="198" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Abstraction in parameterised boolean equation systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cranen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Gazda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Wesselink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A C</forename><surname>Willemse</surname></persName>
		</author>
		<idno>13-01</idno>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>Eindhoven University of Technology</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Higher-level synchronising devices in Meije-SCCS</title>
		<author>
			<persName><forename type="first">R</forename><surname>De Simone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="245" to="267" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Tree automata, mu-calculus and determinacy</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jutla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS 1991</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="368" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">SMI++ object-oriented framework for designing and implementing distributed control systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Franek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gaspar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Nuclear Science</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="891" to="895" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">CADP 2010: A Toolbox for the Construction and Analysis of Distributed Processes</title>
		<author>
			<persName><forename type="first">H</forename><surname>Garavel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mateescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Serwe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS 2011</title>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Abdulla</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6605</biblScope>
			<biblScope unit="page" from="372" to="387" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<author>
			<persName><forename type="first">E</forename><surname>Grädel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Thomas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automata, Logics, and Infinite Games</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Wilke</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2500</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Linearization in parallel pCRL</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Groote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ponse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">S</forename><surname>Usenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic and Algebraic Programming</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="39" to="70" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Model-checking processes with data</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Groote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A C</forename><surname>Willemse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="251" to="273" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Parameterised Boolean equation systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Groote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A C</forename><surname>Willemse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">343</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="332" to="369" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Visualization of state transition graphs</title>
		<author>
			<persName><forename type="first">F</forename><surname>Van Ham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Van De Wetering</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
		<editor>Andrews, K., et al.</editor>
		<imprint>
			<date type="published" when="2001">2001. 2001</date>
			<biblScope unit="page" from="59" to="63" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">The SPIN model checker: Primer and reference manual</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Holzmann</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Relating levels of the mu-calculus hierarchy and levels of the monadic hierarchy</title>
		<author>
			<persName><forename type="first">D</forename><surname>Janin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lenzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2001">2001. 2001</date>
			<biblScope unit="page" from="347" to="356" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Small Progress Measures for Solving Parity Games</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jurdziński</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STACS 2000</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Reichel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Tison</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1770</biblScope>
			<biblScope unit="page" from="290" to="301" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Efficient instantiation of parameterised boolean equation systems to parity games</title>
		<author>
			<persName><forename type="first">G</forename><surname>Kant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van De Pol</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. GRAPHITE 2012</title>
		<meeting>GRAPHITE 2012</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">99</biblScope>
			<biblScope unit="page" from="50" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Bisimulation Minimisations for Boolean Equation Systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J A</forename><surname>Keiren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A C</forename><surname>Willemse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HVC 2009</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Namjoshi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Zeller</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Ziv</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6405</biblScope>
			<biblScope unit="page" from="102" to="116" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Probabilistic Symbolic Model Checking with PRISM: A Hybrid Approach</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kwiatkowska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Norman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Parker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS 2002</title>
		<editor>
			<persName><forename type="first">J.-P</forename><surname>Katoen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Stevens</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2280</biblScope>
			<biblScope unit="page" from="52" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Verification of Modal Properties Using Boolean Equation Systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mader</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
		<respStmt>
			<orgName>Technische Universität München</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Executable UML: A Foundation for Model-Driven Architecture</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Mellor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Balcer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Addison-Wesly</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Supervisory Machine Control by Predictive-reactive Scheduling</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">J M</forename><surname>Van Den Nieuwelaar</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
		<respStmt>
			<orgName>Eindhoven University of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Static Analysis Techniques for Parameterised Boolean Equation Systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Orzan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wesselink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A C</forename><surname>Willemse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS 2009</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Kowalewski</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Philippou</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5505</biblScope>
			<biblScope unit="page" from="230" to="245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Invariants for parameterised Boolean equation systems</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Orzan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A C</forename><surname>Willemse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">411</biblScope>
			<biblScope unit="issue">11-13</biblScope>
			<biblScope unit="page" from="1338" to="1371" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Verification of reactive systems via instantiation of parameterised Boolean equation systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Ploeger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wesselink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A C</forename><surname>Willemse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">209</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="637" to="663" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">JITty: A Rewriter with Strategy Annotations</title>
		<author>
			<persName><forename type="first">J</forename><surname>Van De Pol</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RTA 2002</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Tison</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2378</biblScope>
			<biblScope unit="page">38</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Modal Abstractions in µCRL</title>
		<author>
			<persName><forename type="first">J</forename><surname>Van De Pol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">V</forename><surname>Espada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AMAST 2004</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Rattray</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Maharaj</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Shankland</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">3116</biblScope>
			<biblScope unit="page" from="409" to="425" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Bridging the semantic gap: Visualizing transition graphs with user-defined diagrams</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Pretorius</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="58" to="66" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Using model checking to analyze the system behavior of the LHC production grid</title>
		<author>
			<persName><forename type="first">D</forename><surname>Remenska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A C</forename><surname>Willemse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Verstoep</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Fokkink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Templon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Bal</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012. 2012</date>
			<publisher>IEEE</publisher>
			<biblScope unit="page" from="335" to="343" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">The Theory and Practice of Concurrency</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Roscoe</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">3-valued abstraction: more precision at less cost</title>
		<author>
			<persName><forename type="first">S</forename><surname>Shoham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">formation and Computation</title>
		<imprint>
			<biblScope unit="volume">206</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1313" to="1333" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">Bridging Formal Models: An Engineering Perspective. PhD thesis</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P M</forename><surname>Stappers</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
		<respStmt>
			<orgName>Eindhoven University of Technology</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Transforming SOS Specifications to Linear Processes</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P M</forename><surname>Stappers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Reniers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Weber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FMICS 2011</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Salaün</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Schätz</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6959</biblScope>
			<biblScope unit="page" from="196" to="211" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Formalizing a Domain Specific Language Using SOS: An Industrial Case Study</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P M</forename><surname>Stappers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Reniers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Andova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Nagy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SLE 2011</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Sloane</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">U</forename><surname>Aßmann</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">6940</biblScope>
			<biblScope unit="page" from="223" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Dogfooding the formal semantics of mCRL2</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P M</forename><surname>Stappers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Reniers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Groote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Weber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">35th SEW</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Bowen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Zhu</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">PAT: Towards Flexible Verification under Fairness</title>
		<author>
			<persName><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 2009</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Bouajjani</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">O</forename><surname>Maler</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5643</biblScope>
			<biblScope unit="page" from="709" to="714" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Petri Net Technology for Communication-Based Systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kindler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Ehrig</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Reisig</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Rozenberg</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Weber</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2472</biblScope>
			<biblScope unit="page">49</biblScope>
			<date type="published" when="2003">2003</date>
			<publisher>Springer</publisher>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
	<note>The Petri Net Markup Language</note>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title level="m" type="main">Efficient Rewriting Techniques</title>
		<author>
			<persName><forename type="first">M</forename><surname>Van De Weerdenburg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
		<respStmt>
			<orgName>Eindhoven University of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Infinite games on finitely coloured graphs with applications to automata on infinite trees</title>
		<author>
			<persName><forename type="first">W</forename><surname>Zielonka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">200</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="135" to="183" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
