<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Distributed Detection of Node Replication Attacks in Sensor Networks *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Bryan</forename><surname>Parno</surname></persName>
							<email>parno@cmu.edu</email>
						</author>
						<author>
							<persName><forename type="first">Adrian</forename><surname>Perrig</surname></persName>
							<email>perrig@cmu.edu</email>
						</author>
						<author>
							<persName><forename type="first">Virgil</forename><surname>Gligor</surname></persName>
							<email>gligor@eng.umd.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Carnegie Mellon University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University of Maryland</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Distributed Detection of Node Replication Attacks in Sensor Networks *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">0A3CE91D7FC49514B2364FE92D5F68B4</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T04:13+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The low-cost, off-the-shelf hardware components in unshielded sensor-network nodes leave them vulnerable to compromise. With little effort, an adversary may capture nodes, analyze and replicate them, and surreptitiously insert these replicas at strategic locations within the network. Such attacks may have severe consequences; they may allow the adversary to corrupt network data or even disconnect significant parts of the network. Previous node replication detection schemes depend primarily on centralized mechanisms with single points of failure, or on neighborhood voting protocols that fail to detect distributed replications. To address these fundamental limitations, we propose two new algorithms based on emergent properties <ref type="bibr" target="#b16">[17]</ref>, i.e., properties that arise only through the collective action of multiple nodes. Randomized Multicast distributes node location information to randomly-selected witnesses, exploiting the birthday paradox to detect replicated nodes, while Line-Selected Multicast uses the topology of the network to detect replication. Both algorithms provide globally-aware, distributed node-replica detection, and Line-Selected Multicast displays particularly strong performance characteristics. We show that emergent algorithms represent a promising new approach to sensor network security; moreover, our results naturally extend to other classes of networks in which nodes can be captured, replicated and re-inserted by an adversary.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The ease of deploying sensor networks contributes to their appeal. They can quickly scale to large configurations, since administrators can simply drop new sensors into the desired locations in the existing network. To join the network, new nodes require neither administrative intervention nor interaction with a base station; instead, they typically initiate simple neighbor discovery protocols <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b12">13]</ref> by broadcasting their prestored credentials (e.g., their unique ID and/or the unique ID of their keys).</p><p>Unfortunately, sensor nodes typically employ lowcost commodity hardware components unprotected by the type of physical shielding that could preclude access to a sensor's memory, processing, sensing and communication components. Cost considerations make it impractical to use shielding that could detect pressure, voltage, and temperature changes <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b35">36]</ref> that an adversary might use to access a sensor's internal state. Deploying unshielded sensor nodes in hostile environments enables an adversary to capture, replicate, and insert duplicated nodes at chosen network locations with little effort. Thus, if the adversary compromises even a single node, she can replicate it indefinitely, spreading her influence throughout the network. If left undetected, node replication leaves any network vulnerable to a large class of insidious attacks. Using replicated nodes, the adversary can subvert data aggregation protocols by injecting false data or suppressing legitimate data. Further, blame for abnormal behavior can now be spread across the replicas, reducing the likelihood that any one node exceeds the detection threshold. Even more insidiously, node replicas placed at judiciously chosen locations can revoke legitimate nodes and disconnect the network by triggering correct execution of node-revocation protocols that rely on threshold voting schemes <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b26">27]</ref>.</p><p>Previous approaches for detecting node replication typically rely on centralized monitoring, since localized voting systems <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b26">27]</ref> cannot detect distributed replication. Centralized schemes require all of the nodes in the network to transfer a list of their neighbors' claimed locations 1 to a central base station that can examine the lists for conflicting location claims. Like all centralized approaches, this creates a single-point of failure. If the adversary can compromise the base-station or interfere with its communications, then the centralized approach will fail. Also, the nodes surrounding the base station are subjected to an undue communication burden that may shorten the network's life expectancy.</p><p>In this paper, we use two different emergent algorithms to provide the first examples of globally-aware distributed node-replication detection systems. The emergent nature of our algorithms makes them extremely resilient to active attacks, and both protocols seek to minimize power consumption by limiting communication, while still operating within the extremely limited memory capacity of typical sensor nodes. An emergent algorithm leverages the features that no individual node can provide, but that emerge through the collaboration of many nodes. Our first protocol, Randomized Multicast, distributes location claims to a randomly selected set of witness nodes. The Birthday Paradox predicts that a collision will occur with high probability if the adversary attempts to replicate a node. Our second protocol, Line-Selected Multicast, exploits the routing topology of the network to select witnesses for a node's location and utilizes geometric probability to detect replicated nodes. This protocol has modest communication and memory requirements. Furthermore, our solutions apply equally well to any class of network in which the adversary can capture, replicate and insert additional nodes. Examples include wireless ad hoc networks and peer-to-peer networks. We argue that such networks require the resiliency of emergent security techniques to resist an adversary that can subvert an arbitrary number of nodes at unpredictable locations. We expect that distributed algorithms based on emergent properties will provide the best defenses for attacks against these systems.</p><p>In the following section, we provide a more detailed description of the node replication attack that we plan to thwart, and we supply a summary of notation used throughout the paper. Then, in Section 3 we summarize some of the earlier proposals and explain why they fail to prevent replication attacks. After discussing some preliminary approaches to distributed detection in Section 4, we present and analyze our two primary protocols, Randomized Multicast and Line-Selected Multicast, in Sections 5 and 6 respectively. We compare 1 To prevent the adversary from using the location information to find and disable nodes, we could instead broadcast a locator unique to the node's neighborhood that would reveal less information but still be verifiable by the neighbors. For example, the locator could consist of the node's list of neighbors. If the list becomes prohibitively long, each node can broadcast the list to its neighbors but sign a hash of the list. The neighbors verify that they are on the list, check the hash, and then only propagate the hash value, instead of the entire list. and contrast the protocols, discuss synchronization and authentication issues and generalize our algorithms in Section 8. Finally, we review related research in Section 9 and present our future work and conclusions in Sections 10 and 11.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Goals</head><p>For a given sensor network, we would like to detect a node replication attack, i.e., an attempt by the adversary to add one or more nodes to the network that use the same ID as another node in the network. Ideally, we would like to detect this behavior without centralized monitoring, since centralized solutions suffer from several inherent drawbacks (see Section 3.1). The scheme should also revoke the replicated nodes, so that nonfaulty nodes in the network cease to communicate with any nodes injected in this fashion.</p><p>We evaluate each protocol's security by examining the probability of detecting an attack given that the adversary inserts L replicas of a subverted node. The protocol must provide robust detection even if the adversary captures additional nodes. We also evaluate the efficiency of each protocol. In a sensor network, communication (both sending and receiving) requires at least an order of magnitude more power than any other operation <ref type="bibr" target="#b13">[14]</ref>, so our first priority must be minimizing communication, both for the network as a whole and for the individual nodes (since hotspots will quickly exhaust a node's power supply). Moreover, sensor nodes typically have a limited amount of memory, often on the order of a few kilobytes <ref type="bibr" target="#b13">[14]</ref>. Thus, any protocol requiring a large amount of memory will be impractical.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Sensor Network Environments</head><p>A sensor network typically consists of hundreds, or even thousands, of small, low-cost nodes distributed over a wide area. The nodes are expected to function in an unsupervised fashion even if new nodes are added, or old nodes disappear (e.g., due to power loss or accidental damage). While some networks include a central location for data collection, many operate in an entirely distributed manner, allowing the operators to retrieve aggregated data from any of the nodes in the network. Furthermore, data collection may only occur at irregular intervals. For example, many military applications strive to avoid any centralized and fixed points of failure. Instead, data is collected by mobile units (e.g., unmanned aerial units, foot soldiers, etc.) that access the sensor network at unpredictable locations and utilize the first sensor node they encounter as a conduit for the information accumulated by the network. Since these networks often operate in an unsupervised fashion for long periods of time, we would like to detect a node replication attack soon after it occurs. If we wait until the next data collection cycle, the adversary has time to use its presence in the network to corrupt data, decommission legitimate nodes, or otherwise subvert the network's intended purpose.</p><p>We also assume that the adversary cannot readily create new IDs for nodes. Newsome et al. describe several techniques to prevent the adversary from deploying nodes with arbitrary IDs <ref type="bibr" target="#b26">[27]</ref>. For example, we can tie each node's ID to the unique knowledge it possesses. If the network uses a key predistribution scheme <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b12">13]</ref>, then a node's ID could correspond to the set of secret keys it shares with its neighbors (e.g., a node's ID is given by the hash of its secret keys). In this system, an adversary gains little advantage by claiming to possess an ID without actually holding the appropriate keys. Assuming the sensor network implements this safeguard, an adversary cannot create a new ID without guessing the appropriate keys (for most systems, this is infeasible), so instead the adversary must capture and clone a legitimate node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Adversary Model</head><p>In examining the security of a sensor network, we take a conservative approach by assuming that the adversary has the ability to surreptitiously capture a limited number of legitimate sensor nodes. We limit the percentage of nodes captured, since an adversary that can capture most or all of the nodes in the network can obviously subvert any protocol running in the network. Having captured these nodes, the adversary can employ arbitrary attacks on the nodes to extract their private information. For example, the adversary might exploit the unshielded nature of the nodes to read their cryptographic information from memory. The adversary could then clone the node by loading the node's cryptographic information onto multiple generic sensor nodes. Since sensor networks are inherently designed to facilitate ad hoc deployment, these clones can then be easily inserted into arbitrary locations within the network, subject only to the constraint that each inserted node shares at least one key with some of its neighbors. We allow all of the nodes under the adversary's control to communicate and collaborate, but we make the simplifying assumption that any cloned node has at least one legitimate node as a neighbor. In Section 8.4, we show how we can remove this assumption while retaining security. We assume that the adversary operates in a stealthy manner, attempting to avoid detection, since detection could trigger an automated protocol to sweep the network, using a technique such as SWATT <ref type="bibr" target="#b31">[32]</ref> to remove compromised nodes, or draw human attention and/or intervention. In the following discussion, we will also assume that nodes under the adversary's control (both the subverted nodes and their clones) continue to follow the protocols described. This allows us to focus on the details of the protocols, but in Section 10, we will suggest methods for relaxing this assumption.</p><p>As described above, our adversary model differs from the Dolev-Yao adversary <ref type="bibr" target="#b8">[9]</ref> in several respects. Traditionally used to analyze cryptographic protocols, the Dolev-Yao model allows the adversary to read and write messages at any location within the network. However, in our discussion, we restrict the adversary to read and write messages using only the nodes under its control. On the other hand, our model also allows the adversary to subvert and replicate existing nodes in an adaptive manner, capabilities not available to the Dolev-Yao adversary. These capabilities allow the adversary to modify both the network topology and the "trust" topology, since the set of legitimate nodes changes as the adversary subverts nodes and inserts additional replicas.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Notation</head><p>For clarity, we list the symbols and notation used throughout the paper below: </p><formula xml:id="formula_0">n</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Previous Protocols</head><p>Thus far, protocols for detecting node replication have relied on a trusted base station to provide global detection. For the sake of completeness, we also discuss the use of localized voting mechanisms. We consider these protocols in the abstract; for specific examples of previous protocols, see <ref type="bibr">Section 9</ref>. Until now, it was generally believed that these two alternatives exhausted the space of possibilities. This paper expands the design space to offer new alternatives with strong security and efficiency characteristics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Centralized Detection</head><p>The most straightforward detection scheme requires each node to send a list of its neighbors and their claimed locations to the base station. The base station can then examine every neighbor list to look for replicated nodes. If it discovers one or more replicas, it can revoke the replicated nodes by flooding the network with an authenticated revocation message.</p><p>While conceptually simple, this approach suffers from several drawbacks inherent in a centralized system. First, the base station becomes a single point of failure. Any compromise of the base station or the communication channel around the base station will render this protocol useless. Furthermore, the nodes closest to the base station will receive the brunt of the routing load and will become attractive targets for the adversary. The protocol also delays revocation, since the base station must wait for all of the reports to come in, analyze them for conflicts and then flood revocations throughout the network. A distributed or local protocol could potentially revoke replicated nodes in a more timely fashion. Finally, many networks do not have the luxury of a powerful base station, making a distributed solution a necessity.</p><p>In terms of security, this protocol achieves 100% detection of all replicated nodes, assuming all messages successfully reach the base station. As far as efficiency, if we assume that the average path length<ref type="foot" target="#foot_1">2</ref> to the base station is O( √ n) and each node has an average degree d (for d n), then this protocol requires O(n √ n) communication for all of the reports from the nodes to reach the base station. The storage required at each node is O(d). At the base station, the protocol requires O(n • d), though storage is presumably less of a concern for the base station.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Local Detection</head><p>To avoid relying on a central base station, we could instead rely on a node's neighbors to perform replication detection. Using a voting mechanism, the neighbors can reach a consensus on the legitimacy of a given node. Unfortunately, while achieving detection in a distributed fashion, this method fails to detect distributed node replication in disjoint neighborhoods within the network. As long as the replicated nodes are at least two hops away from each other, a purely local approach cannot succeed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Preliminary Approaches</head><p>One might imagine addressing the shortcomings of previously proposed protocols by implementing distributed detection using a simple broadcast scheme, or by using deterministic replication of location claims. To the best of our knowledge, neither of these protocols have been discussed in the literature. Despite their drawbacks, we discuss them to provide background and intuition for our two primary protocols, Randomized Multicast and Line-Selected Multicast, presented in Sections 5 and 6 respectively. In all four protocols, we assume that nodes know their own geographic positions. Numerous researchers have proposed schemes for determining node location, using everything from highly abstract graph embeddings <ref type="bibr" target="#b27">[28]</ref>, to connectivity information <ref type="bibr" target="#b7">[8]</ref>, to powerful beacon nodes placed on the perimeter of the network <ref type="bibr" target="#b4">[5]</ref>. Some of these proposals require that some or all of the nodes have GPS receivers, but many do not. For our purposes, any of these protocols will suffice. We also assume that the nodes in the network remain relatively stationary, at least for the time it takes to perform one round of replication detection. If the network designers anticipate occasional mobility, they can schedule regular detection rounds. As long as a node successfully participates in a round, it can continue to communicate until the next round, even if its position changes in the interim. We discuss additional timing details in Section 8.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Node-To-Network Broadcasting</head><p>One approach to distributed detection utilizes a simple broadcast protocol. Essentially, each node in the network uses an authenticated broadcast message to flood the network with its location information. Each node stores the location information for its neighbors and if it receives a conflicting claim, revokes the offending node.</p><p>This protocol achieves 100% detection of all duplicate location claims under the assumption that the broadcasts reach every node. This assumption may not hold if the adversary can jam key areas or otherwise interfere with communication paths through the network. Nodes could employ redundant messages or authenticated acknowledgment techniques to try to thwart such an attack. In terms of efficiency, this protocol requires each node to store location information about its d neighbors. One node's location broadcast requires O(n) messages, assuming the nodes employ a duplicate suppression algorithm in which each node only broadcasts a given message once. Thus, the total communication cost for the protocol is O(n 2 ). Given the simplicity of the scheme and the level of security achieved, this cost may be justifiable for small networks. However, for large networks, the n 2 factor is too costly, so we investigate schemes with a lower cost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Deterministic Multicast</head><p>To improve on the communication cost of the previous protocol, we describe a detection protocol that only shares a node's location claim with a limited subset of deterministically chosen "witness" nodes. When a node broadcasts its location claim, its neighbors forward that claim to a subset of the nodes called witnesses. The witnesses are chosen as a function of the node's ID. If the adversary replicates a node, the witnesses will receive two different location claims for the same node ID. The conflicting location claims become evidence to trigger the revocation of the replicated node.</p><p>More formally, in this protocol, whenever node γ hears a location claim l α from node α, it computes F (α) = {ω 1 , ω 2 , . . . , ω g }, where F maps each node ID in the set of possible node IDs, S, to a set of g node IDs:</p><formula xml:id="formula_1">F : S → {σ : σ ∈ 2 S , |σ| = g}<label>(1)</label></formula><p>The nodes with IDs in the set {ω 1 , ω 2 , . . . , ω g } constitute the witnesses for node α. Node γ forwards l α to each of these witnesses. If α claims to be at more than one location, the witnesses will receive conflicting location claims, which they can flood through the network, discrediting α.</p><p>In this protocol, each node in the network stores g location claims on average. For communication, assuming α's neighbors do not collaborate, we will need each of α's neighbors to probabilistically decide which of the ω i to inform. If each node selects g ln g d random destinations from the set of possible ω i , then the coupon collector's problem <ref type="bibr" target="#b6">[7]</ref> assures us that each of the ω i 's will receive at least one of the location claims. Assuming an average network path length of O(</p><formula xml:id="formula_2">√ n) nodes, this results in O( g ln g √ n d</formula><p>) messages. Unfortunately, this cost does not provide much security. Since F is a deterministic function, an adversary can also determine the ω i s. Thus, they become targets for subversion. If the adversary can capture or jam all g of the messages destined to the ω i s, then she can create as many replicas of α as she desires (limited only by the requirement that no two replicas share a neighbor). Since the communication costs of this protocol grow as O(g ln g), we cannot afford a large value for g, and yet a small value for g allows the adversary almost unlimited replication abilities after compromising a fixed number of nodes; in other words, if the adversary controls the g witnesses for α, she can create unlimited replicas of α and suppress the conflicting reports arriving at the witness nodes. These disadvantages make this protocol unappealing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Randomized Multicast</head><p>To improve the resiliency of the deterministic multicast protocol discussed in Section 4.2, we propose a new protocol that randomizes the witnesses for a given node's location claim, so that the adversary cannot anticipate their identities. When a node announces its location, each of its neighbors sends a copy of the location claim to a set of randomly selected witness nodes. If the adversary replicates a node, then two sets of witnesses will be selected. In a network of n nodes, if each location produces √ n witnesses, then the birthday paradox predicts at least one collision with high probability, i.e., at least one witness will receive a pair of conflicting location claims. The two conflicting locations claims form sufficient evidence to revoke the node, so the witness can flood the pair of locations claims through the network, and each node can independently confirm the revocation decision.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Assumptions</head><p>As discussed in Section 4, our protocols assume that each node knows its own location. We also assume that the network utilizes an identity-based public key system such that each node α is deployed with a private key, K -1 α , and any other node can calculate α's public key using α's ID, i.e., K α = f (α). If necessary, we could replace this system with a more traditional PKI in which we assume the network authorities use a master public/private-key pair (K M , K -1 M ) to sign α's public key; however, transmitting this public-key certificate will have a substantial communication overhead.</p><p>Traditionally, researchers have assumed that public key systems exceed the memory and computational capacity of sensor nodes. However, public key cryptography on new sensor hardware may not be as prohibitive as traditionally assumed. In recent work, Malan et al. demonstrate that they can successfully generate 163 bit ECC keys on the MICA 2 in under 34 seconds <ref type="bibr" target="#b21">[22]</ref>. Furthermore, the latest generation of Telos sensors come with 10KB of RAM and can achieve 5x the data rate of the MICA 2, making public-key algorithms more practical. In Section 8.3.2, we discuss how we could instead use symmetric-key cryptography to lower the computational overhead, at the expense of additional communication.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Protocol Description</head><p>At a high level, the protocol has each node broadcast its location claim, along with a signature authenticating the claim. Each of the node's neighbors probabilistically forwards the claim to a randomly selected set of witness nodes. If any witness receives two different location claims for the same node ID, it can revoke the replicated node. The birthday paradox ensures that we detect replication with high probability using a relatively limited number of witnesses.</p><p>More formally, each node α broadcasts a location claim to its neighbors, β 1 , β 2 , . . . , β d . The location claim has the format ID α , l α , {H(ID α , l α )} K -1 α , where l α represents α's location (e.g., geographic coordinates (x, y)). Upon hearing this announcement, each neighbor, β i , verifies α's signature and the plausibility of l α (for example, if each node knows its own position and has some knowledge of the maximum propagation radius of the communication layer, then it can loosely bound α's set of potential locations). Then, with probability p, each neighbor selects g random locations within the network and uses geographic routing (e.g., GPSR <ref type="bibr" target="#b18">[19]</ref>) to forward α's claim to the nodes closest to the chosen locations (as in GHT <ref type="bibr" target="#b29">[30]</ref>). Since we have assumed the nodes are distributed randomly, this should produce a random selection from the nodes in the network. In Section 5.3, we show that the probability of selecting the same node more than once is generally negligible. Collectively, the nodes chosen by the neighbors constitute the witnesses for α.</p><p>Each witness that receives a location claim, first verifies the signature. Then, it checks the ID against all of the location claims it has received thus far. If it ever receives two different locations claims for the same node ID, then it has detected a node replication attack, and these two location claims serve as evidence to revoke the node. It blacklists α from further communication by immediately flooding the network with the pair of conflicting location claims, l α and l α . Each node receiving this pair can independently verify the signatures and agree with the revocation decision. Thus, the sensor network both detects and defeats the node replication attack in a fully distributed manner. Furthermore, the randomization prevents the adversary from predicting which node will detect the replication.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Security Analysis</head><p>Let malicious node α claim to be at L locations, l 1 , l 2 ,. . . , l L . We would like to determine the probability of a collision using the randomized multicast protocol outlined above, since a collision at a witness corresponds to detection of α's replication. At each location l i , p • d nodes randomly select g witnesses. If the neighbors coordinated perfectly, this would store α's location claim at exactly p • d • g locations. However, since we prefer to have each neighbor act independently, there may be some amount of overlap between the witnesses each neighbor selects. To determine the impact of this overlap, we would like to determine the number of nodes, N receive , that will receive the location claim assuming the neighbors choose witnesses independently. If P claim is the probability that a node hears at least one claim and P none is the probability that a node hears no location claims, then we have:</p><formula xml:id="formula_3">E[N receive ] = n • P claim (2) P claim = 1 -P none<label>(3)</label></formula><p>Since each neighbor is assumed to select g random, unique witness locations, the probability (P f ) that a node fails to hear any of the g announcements from one</p><p>neighbor is:</p><formula xml:id="formula_4">P f = 1 - g n<label>(4)</label></formula><p>Since each neighbor decides independently whether to send out location claims, the number of nodes that actually send out location claims is distributed binomially, with mean p • d and variance d • p(1p). For a network with d = 20 and p = 1 10 , the variance will be less than 0.005, so we will approximate the number of neighbors that send out locations claims as p • d. Since the neighbors choose their destinations independently, we have:</p><formula xml:id="formula_5">P none = 1 - g n p•d<label>(5)</label></formula><p>Combining equations 2, 3 and 5, the number of witness nodes that receive at least one location claim is:</p><formula xml:id="formula_6">E[N receive ] = n • 1 -1 - g n p•d<label>(6)</label></formula><p>The Binomial Theorem allows us to approximate (1x) y as (1xy) for small x, so as long as g n, we have N receive ≈ p•d•g, so overlapping witness locations should not impact the security of the protocol. As an example, in a network with n = 10, 000, g = 100, d = 20, and p = 0.1, perfect coordination would tell 200 nodes, while independent selection would tell 199. Thus, for the remainder of the analysis, we will assume that p • d • g nodes receive each location claim.</p><p>If the adversary inserts L replicas of α, we would like to determine the probability that two conflicting location reports collide at some witness node, since this corresponds to the probability that a witness detects the node replication. Note that even if there are more than two replicas of α, we still only need two location claims to collide in order to completely revoke all L of the replicas, since one collision will prompt a network-wide flood of the duplicate claims (l i and l j ) and any other node that has heard location claim l k for k = i, j will also revoke α.</p><p>Following the standard derivation of the birthday paradox <ref type="bibr" target="#b6">[7]</ref>, the probability P nc1 that the p • d • g recipients of claim l 1 do not receive any of the p • d • g copies of claim l 2 is given by:</p><formula xml:id="formula_7">P nc1 = 1 - p • d • g n p•d•g (7)</formula><p>Similarly, the probability P nc2 that the 2•p•d•g recipients of claims l 1 and l 2 do not receive any of the p•d•g copies of claim l 3 is given by:</p><formula xml:id="formula_8">P nc2 = 1 - 2 • p • d • g n p•d•g (8)</formula><p>Thus, the probability P nc of no collisions at all is given by:</p><formula xml:id="formula_9">P nc = L-1 i=1 1 - i • p • d • g n p•d•g<label>(9)</label></formula><p>Using the standard approximation that (1 + x) ≤ e x , we have:</p><formula xml:id="formula_10">P nc ≤ L-1 i=1 e -i•p 2 •d 2 •g 2 n (10) ≤ e -p 2 •d 2 •g 2 n P L-1 i=1 i (11) ≤ e -p 2 •d 2 •g 2 n L(L-1) 2<label>(12)</label></formula><p>Since the probability of a collision, P c , is simply 1-P nc , the probability of detecting L replicas is:</p><formula xml:id="formula_11">P c ≥ 1 -e -p 2 •d 2 •g 2 n L(L-1) 2<label>(13)</label></formula><p>Thus, if n = 10, 000, g = 100, d = 20, and p = 0.05, we will detect a single replication of α with probability greater than 63%, and if α is replicated twice, we will detect it with probability greater than 95%.</p><p>Unlike the deterministic proposal (Section 4.2), we no longer need to worry about the adversary using a limited number of captured nodes to enable an unlimited amount of replication. If the adversary captures neighboring nodes α and β, then the total number of claims about either node is reduced by 1  d , essentially reducing the neighbor count of each node by one. Since all of the protocol decisions are made locally by individual nodes, the adversary has only two options remaining: it can disrupt the routing of packets from the remaining legitimate neighbors or it can capture all of the legitimate neighbors. Routing disruptions create tell-tale signs of the adversary's presence in the network and will be avoided by a prudent adversary. Capturing all of the neighbors of a node targeted for replication leads to a practical attack which we address in Section 8.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Efficiency Analysis</head><p>This scheme still poses a relatively high storage cost. On average, each node will have to store p • d • g location claims. To ensure a collision with greater than 50% probability, p•d•g will have to be on the order of O( √ n). Even if we can reduce the size of each claim to the payload of a packet, 36B, our hypothetical network with n = 10, 000, g = 100, d = 20, and p = 0.05 will require, on average, that each node store 3,700 B, which is just under 91% of the Mica 2's total RAM. Similarly, the communication requirements of the protocol are nontrivial. For each node, we generate p • d • g messages that must be evenly spread throughout the network. In a network randomly deployed on the unit square, the average distance between any two randomly chosen nodes is approximately 0.521</p><formula xml:id="formula_12">√ n ≈ √ n</formula><p>2 , so the communication costs for the network are on the order of O(n</p><formula xml:id="formula_13">√ n•p•d•g). As mentioned before, p • d • g ≈ O(</formula><p>√ n), so our communication costs are O(n 2 ), equivalent to those of the naive broadcast scheme outlined in Section 4.1.</p><p>We can employ a number of enhancements to improve both the communication and space requirements of our protocol. First, we can trade resiliency for memory and communication savings. For example, in our hypothetical network <ref type="foot" target="#foot_3">3</ref> , if we are willing to allow the adversary to create up to four replicas of α, then we can reduce the number of messages sent out, g, by 75%. Since communication costs are O(g 2 ) we save on communication and require less than 1KB of space, but we would still detect the adversary's presence with probability greater than 50%. We can also save both communication and space by reducing the number of location claims sent out by 1 d , i.e. g = g d . Each recipient of one of these claims uses a broadcast message to query her neighbors as to whether they have a conflicting value. Even with these additional queries, the communication costs are now O( √ n • p • g) messages per node. Finally, we can reduce the storage burden by introducing a loose notion of synchronization into the process -see Section 8.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Line-Selected Multicast</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Overview</head><p>To reduce the communication costs of our randomized multicast protocol, we investigate a different scheme to detect conflicting location claims. Inspired by Braginsky and Estrin's work on Rumor Routing <ref type="bibr" target="#b3">[4]</ref>, we note that nodes in a sensor network function both as sensing units and as routers. For a location claim to travel from node α to node γ, it must pass through several intermediate nodes as well. If these intermediate nodes also store the location claim, then we have effectively drawn a line across the network. If a conflicting location claim ever crosses the line, then the node at the intersection will detect the conflict and initiate a revocation broadcast. Since the expected number of intersections, c, of x randomly drawn lines<ref type="foot" target="#foot_4">4</ref> intersecting within the bounds of the unit circle is given by:</p><formula xml:id="formula_14">E(c) = x(x -1) 1 6 + 245 144π 2<label>(14)</label></formula><p>we only need a few such lines to insure an intersection. For example, with only three lines, we expect two collisions (see Solomon's lecture notes <ref type="bibr" target="#b33">[34]</ref> for details of the derivation). With this insight in mind, we can craft an alternate detection protocol with improved performance.</p><formula xml:id="formula_15">X A B C 1 R C 2 R C 3 R R Figure 1</formula><p>. Line-Segment Intersection Given three randomly selected points, A, B and X, then if the fourth randomly-selected point Y falls in any of the Ci regions, the resulting quadrilateral will be convex. If Y falls in any of the R regions, the figure will be re-entrant. For XY to intersect AB, Y must fall in region C3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Protocol Outline</head><p>Our new protocol modifies the Randomized Multicast protocol, so that we fix p • d • g as a small constant r. When α's neighbors send out the evidence of α's location claim to the r witnesses, each of the nodes along the route stores a copy of the location claim as well. For example, let β i send a copy of α's location claim l α to γ j via σ 1 , σ 2 . . . σ m . Upon receiving l α , σ k verifies the signature on the claim, checks for a conflict with the claims already in its buffer, stores a copy of l α in its buffer, and then forwards l α to σ k+1 . If any of the nodes discovers a conflict, i.e., finds another location claim l for α such that l α = l α , then it floods the network with the unforgeable evidence (the conflicting set of signed location claims) of α's attempted replication, resulting in a distributed revocation of α. If the collision happens to occur at a replica, it still does not preclude another collision from occurring elsewhere in the network. Also, since all protocol decisions are made locally and probabilistically, the adversary cannot predict the location of the collision, so the probability of a collision occurring at a node under the adversary's control will be negligible, unless the adversary already has an overwhelming presence within the network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Analysis</head><p>As described above, our protocol actually "draws" line-segments, not lines, through the network. Unfortunately, the probability of two segments intersecting is considerably less than that of two lines intersecting (given above by Equation <ref type="formula" target="#formula_14">14</ref>). To find the probability that two line-segments intersect <ref type="foot" target="#foot_5">5</ref> , we can use the solution to Sylvester's Four-Point Problem. The Four-Point Problem asks for the probability that four randomly selected points in a convex domain will form a re-entrant quadrilateral, i.e., one in which one point falls within the triangle formed by the other three points. Solomon shows that if the points are selected from a circular domain, then the probability that the points form a reentrant quadrilateral is 35 12π 2 <ref type="bibr" target="#b33">[34]</ref>. If we select our first three points at random, then we can divide the region into seven sections: four re-entrant and three convex (see Figure <ref type="figure">1</ref>). The two line-segments will only intersect if the fourth point falls in the convex region C 3 . Thus, the probability of intersection is given by:</p><formula xml:id="formula_16">P intersect = 1 3 1 - 35 12π 2 ≈ 0.235<label>(15)</label></formula><p>To further complicate the analysis, our line segments are not drawn independently at random, but originate from a central point and radiate out in random directions (see Figure <ref type="figure" target="#fig_0">2</ref>). However, Monte-Carlo simulations indicate that even if we only draw two random segments originating from α and two from α , the probability of at least one intersection is greater than 56%, and with five line segments per point, we have a 95% probability of intersection. Since an intersection corresponds to detecting a node replication attack, we can detect an attack with  high probability, using only a constant number of linesegments. While this approach depends on the routing topology of the network, our simulations indicate that it reliably detects node replication in realistic scenarios (see <ref type="bibr">Section 7)</ref>.</p><p>Since we only use a constant number of linesegments per node, the Line-Selected Multicast protocol has very reasonable performance characteristics. Assuming each line-segment is of length O( √ n), then our protocol only requires O(n √ n) communication for the entire network and each node stores O( √ n) location claims. We can also reduce the storage requirement by using the time synchronization enhancements described in Section 8.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Simulations</head><p>To verify the accuracy of our theoretical predictions, we ran simulations to measure the communication requirements of our two primary protocols, Randomized Multicast and Line-Selected Multicast. Since Line-Selected Multicast relies on the topology of the network to detect node replications, we also evaluated its detection rate in a variety of network configurations. Examples of the network topologies tested appear in Appendix A.</p><p>In our simulations, we deploy n nodes uniformly at random within a 500 × 500 square, with n varying between 1,000 and 10,000. We assume the standard unitdisc bidirectional communication model and we adjust the communication range, so that each node will have approximately 40 neighbors on average<ref type="foot" target="#foot_6">6</ref> . We use an average of the total number of messages sent or received per node as a measure of the communication requirements, and we measure resiliency by counting the number of times we must run the protocol in order to detect a single node replication (i.e., we select a random node and insert one replica into the network). Thus, we calculate the probability of detection, P d as:</p><formula xml:id="formula_17">P d = 1 # repetitions<label>(16)</label></formula><p>For the Randomized Multicast protocol, we used</p><formula xml:id="formula_18">p • d • g = √ n</formula><p>which theoretically gives us a 63% probability to detect replication, and for Line-Selected Multicast we used r = 6 (i.e., each location claim creates six line segments). For each network configuration, we generated twenty random graphs and averaged the results of ten trials on each graph. As shown in Figure <ref type="figure" target="#fig_2">3</ref>(a), the simulations closely match our theoretical predictions. The communication for Randomized Multicast scales linearly with the number of nodes, while the Line-Selected Multicast only grows at O( √ n). Our simulations also indicate that the maximum amount of communication required of any one node as compared to the average case scales logarithmically with the number of nodes in the graph. Using Randomized Multicast in a network with 1,000 nodes requires a maximum of four times as much communication as the average case, and with 10,000 nodes, it requires seven times as much. With Line-Selected Multicast, the maximum amount of communication in a network with 1,000 nodes is twice as much as the average case and four times as much for 10,000 nodes. As Figure <ref type="figure" target="#fig_2">3</ref>(b) illustrates, Line-Selected Multicast reliably detects node replications in a variety of irregular network configurations. To improve the probability of detection, we can always repeat the protocol or add a few additional line segments per node.</p><formula xml:id="formula_19">Communication Memory Broadcast O(n 2 ) O(d) Deterministic Multicast O( g ln g √ n d ) O(g) Randomized Multicast O(n 2 ) O( √ n) Line-Selected Multicast O(n √ n) O( √ n)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Discussion</head><p>In this section, we compare the performance of the various protocols we have discussed, and we present several techniques based on loose-time synchronization that reduce the storage requirements of the protocols. We also discuss potential issues that may arise from our use of public-key cryptography, as well as symmetric alternatives that would require less computational overhead at the price of additional communication. In Section 8.4, we describe a sophisticated attack that applies to all of the protocols we have discussed, and we present a defense against it. Finally, based on the success of our Randomized Multicast and Line-Selected Multicast protocols, we argue that algorithms based on emergent properties offer the most promising techniques for providing security in sensor networks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Protocol Comparison</head><p>Table <ref type="table" target="#tab_1">1</ref> summarizes the costs for each of the distributed protocols previously discussed. The Broadcast protocol offers the simplest solution, but the communication overhead will only be tolerable for small networks. Deterministic Multicast improves on the communication requirements, but by selecting a fixed set of witnesses, it loses resiliency. An attacker can perform unlimited replications after only compromising a fixed number of nodes. Randomized Multicast provides excellent resiliency, since it prevents the adversary from anticipating the identity of the witnesses. Unfortunately, it imposes communication overhead equal to that of the Broadcast scheme. However, for networks in which the number of nodes is less than the square of the average degree, Randomized-Multicast will tend to be more space efficient. Finally, Line-Selected Multicast uses less communication than Broadcast or Randomized Multicast, but provides comparable or greater resiliency, making it a particularly attractive choice. Our simulations confirm that this resiliency remains in a variety of network configurations (see <ref type="bibr">Section 7)</ref>. We can also reduce the storage requirements for these protocols by using the time synchronization enhancements described in Section 8.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Synchronized Detection</head><p>We now consider the synchronization issues involved in detecting node replication. All of the protocols described above require a loose notion of synchronization to insure timely detection. Various protocols exist that can offer the coarse-grained level of synchronization that we require. For example, Reference-Broadcast Synchronization (RBS) enables pairwise synchronization with low overhead and high precision <ref type="bibr" target="#b11">[12]</ref>. Hu and Servetto describe a protocol that provides asymptotically optimal time synchronization in dense networks <ref type="bibr" target="#b17">[18]</ref>. Any of these protocols will suffice for our purposes.</p><p>Deciding how often to perform the detection protocol trades efficiency of detection against the communication and storage costs required by each iteration. However, as we describe below, we can leverage our assumption of loose synchronization to mitigate the cost of running the protocols.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2.1">High Noon</head><p>In one modification, detection happens during a fixed window of time (of length t) that occurs every T units of time (for T t). At the beginning of each time window, each node broadcasts its location claim to its neighbors, who then resend it to random locations in the network. Each node looks for conflicts in location claims arriving during the time window and revokes conflicting nodes. After time t has elapsed, the nodes forget all of the location claims (but continue to remember the list of revoked nodes). Using this modification, the nodes only devote significant memory resources to detection during the brief time window of length t. The rest of the time (Tt), they can utilize their entire memory for nondetection purposes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2.2">Time Slots</head><p>As an alternate approach, we assume the node IDs are randomly distributed on some fixed interval [0..N ]. For a given protocol parameter k, we can divide time into epochs of length T , with each epoch consisting of k time slots. During each epoch, in time slot s, all of the nodes with IDs located in the interval [s• N k ..(s+1)• N k ] broadcast their location claims to their neighbors, who then follow the standard protocol. Nodes receiving a location claim from a node with an ID in that interval store the claim for the duration of the time slot and check for conflicts. At the end of the time slot, they can forget all of the claims they have heard. Using this method reduces the storage requirements at each node to O( p•d•g k ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2.3">Security Requirements</head><p>Since both of these modifications operate deterministically, the adversary might attempt to launch her replication attack between time slots or refuse to follow the protocol (i.e., by not broadcasting her location at the specified time). However, we can thwart this behavior by having each node remember which neighbors it heard from during the previous epoch. Later, if a node hears from a neighbor that did not participate in the previous epoch, it will refuse to communicate with that node until the node successfully participates in a detection epoch. This effectively precludes the adversary from avoiding randomized detection. <ref type="foot" target="#foot_7">7</ref> Since the nodes in most sensor networks must already remember a list of their neighbors, this would only require an additional d bits. Of greater concern is the fact that this modification limits when new nodes can join the network. This can be mitigated by appropriate choices for t, T , and k, as well as decisions regarding deployment timing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Authentication</head><p>The use of public-key signatures requires several extensions to our protocols to prevent the signatures themselves from becoming a security threat. Also, while we argued in Section 5.1 that algorithmic and hardware improvements are beginning to make public-key cryptography practical for sensor networks, we also present a mechanism that utilizes symmetric one-time signatures as an alternative to the public-key authentication previously assumed. While the symmetric signatures reduce the computational overhead of generating and verifying signatures, they require additional communication, making them less appealing than the public-key approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3.1">Public Key Security Adjustments</head><p>To prevent the use of signatures from becoming a security liability, we need to ensure that the adversary cannot perform a Denial-of-Service attack by making nodes verify bogus signatures or by reporting its neighbors' position claims to every node in the network, rather than probabilistically reporting them to g nodes. In practice, these two attacks are unlikely to be a concern. Since the basic protocol currently requires each node that receives a location claim to verify the signatures contained within the claim, legitimate nodes will immediately detect any attempt to inject faulty signatures. If we add some form of neighbor-to-neighbor authentication, then a node identifying a faulty signature can also assign appropriate blame for the fault. It may then choose to blacklist or otherwise revoke the guilty party. If the adversary can flood a node with faulty signatures not originating from a node (via some other broadcast source), then the adversary could just as easily perform a jamming attack or otherwise interfere with legitimate communication. Neighbor-to-neighbor authentication also prevents the adversary from framing an innocent third party.</p><p>To address the second concern, we note that when a legitimate node, γ, forwards a location claim to its g randomly chosen locations, these location claims must be routed through its neighbors. If the neighbors listen promiscuously, they can all detect γ's attempts to forward the same location claim more than g times and refuse to forward additional claims. Unfortunately, this does require each node to keep a count associated with each neighbor, but it may be necessary to prevent the adversary from wasting the network's collective memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3.2">Symmetric Alternatives</head><p>As an alternative to computation-intensive public-key algorithms, researchers have proposed using more efficient symmetric cryptographic mechanisms for sensor networks -for example, broadcast authentication based on one-way chains and time synchronization <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b28">29]</ref>, or one-time signatures based on one-way functions <ref type="bibr" target="#b24">[25]</ref>.</p><p>For the purposes of this paper, if sensor nodes only need to sign a single location statement, a one-time signature will suffice. For example, we could use the Merkle-Winternitz signature <ref type="bibr" target="#b24">[25]</ref>, which has already been successfully used for stream signatures <ref type="bibr" target="#b30">[31]</ref>. To verify a Merkle-Winternitz signature, a verifier only needs to possess an authentic verification value, i.e., the public key, which in this case is a hash value over several one-way chain values. However, since storing all of the public values of all the nodes would have a high overhead, we could instead construct a Merkle hash tree <ref type="bibr" target="#b23">[24]</ref> over all public values, and the resulting root node could be used to authenticate any one-time signature in that tree. For signature verification, a node would include all the values in the hash tree that allow a verifier to recompute the root node of the hash tree; for n nodes, this approach would require ln n extra values. Using the parameters suggested by Rohatgi <ref type="bibr" target="#b30">[31]</ref> for the Merkle-Winternitz signature, a signature is 230 bytes large, and the additional verification values would require an additional 100 bytes. This is quite large for a sensor network, and thus we suggest using asymmetric cryptography to achieve smaller messages, despite the higher verification cost. Since message transmission accounts for the majority of energy consumption, we may conserve energy by sending smaller messages but requiring a higher computation overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4">Masked-Replication Attacks</head><p>In our discussion of the resiliency of the various protocols, we have assumed that each node has at least one legitimate neighbor. Without this assumptions, all of the protocols discussed thus far may fail to detect node replication. If the adversary compromises all of α's neighbors, then she can create one replica of α without fear of detection, since the compromised nodes will not send out location claims for the original α. To create a second replica of α, the adversary must also compromise the nodes surrounding the first replica. Thus, the adversary must compromise an additional d nodes for each replica of α she wishes to create. However, if the compromised nodes mask the replicated nodes, the adversary can improve her foothold in the network. For example, if the adversary compromises nodes µ 1 , µ 2 . . . µ k , then she can assign replicas of {µ 1 , µ 2 . . . µ i-1 , µ i+1 . . . µ k } as neighbors of µ i . This gives the adversary the influence of k 2 nodes after she compromises k nodes. As a concrete example, suppose the adversary compromises nodes µ 1 and µ 2 . Now, she can create replicas µ 1 and µ 2 . By assigning µ 1 as µ 2 's only neighbor, and µ 2 as µ 1 's only neighbor, the compromised nodes can mask the replicas. None of the protocols discussed will detect these replicas, since they rely on a replicated node's neighbors to propagate the replica's location claims.</p><p>Fortunately, we can thwart this attack with a straightforward defense. Each node β maintains a list of the m nodes from which it has seen the most traffic. For each node α on the list, β appoints itself a pseudo-neighbor of α with probability</p><formula xml:id="formula_20">P pseudo ∝ traffic α claims α (<label>17</label></formula><formula xml:id="formula_21">)</formula><p>where traffic α is the amount of traffic that β has seen from α, and claims α is the number of location claims β has seen concerning α. As a pseudo-neighbor, β requests a location claim directly from α. If α fails to respond, β ceases to forward traffic from α. If α does respond, β follows the same protocol-dependent behavior as the real neighbors of α (e.g., in the Randomized Multicast, β will forward the location claim to a randomly selected set of witness nodes). The use of pseudo-neighbors successfully defeats masked-replication attacks. If the masked nodes fail to send out location claims, then the closest legitimate nodes will have a higher probability of appointing themselves pseudo-neighbors. If the replicated nodes fail to respond to requests from the pseudo-nodes, the legitimate nodes will cut off communication. By forcing all nodes to provide location claims, we can rely on the resiliency of our detection algorithm to revoke replicated nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.5">Emergent Properties</head><p>Our two primary algorithms, Randomized Multicast and Line-Selected Multicast, achieve distributed detection of global events, while imposing low overheads and providing high resiliency. Their strong properties are a result of their emergent nature. Emergent algorithms utilize the collective efforts of multiple sensor nodes to provide capabilities beyond those of any individual node. For example, after a network's initial deployment, a topology emerges as nodes exchange neighbor information and establish a routing infrastructure. Since emergent algorithms operate in a distributed fashion, they tend to be highly robust in the face of individual node failures, and they avoid the problems inherent in centralized solutions. These properties make them ideal for security applications, particularly in a setting in which we cannot predict the number or identity of the sensors that will be subverted by an adversary. To the best of our knowledge, our protocols represent the first application of emergent algorithms to the problem of security in sensor networks, and we believe that additional research will only continue the trend towards distributed solutions. Furthermore, emergent algorithms apply more generally to security in other classes of networks in which individual nodes are vulnerable to compromise (e.g., peer-to-peer networks and ad-hoc wireless networks), allowing solutions in one class to extend naturally to the others.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Related Work</head><p>Eschenauer and Gligor <ref type="bibr" target="#b12">[13]</ref> propose centralized node revocation in sensor networks. When the base station detects a misbehaving node, it broadcasts a message to revoke that node. Chan, Perrig, and Song <ref type="bibr" target="#b5">[6]</ref> propose a localized mechanism for sensor network node revocation; in their approach, nodes can revoke their neighbors. Neither paper discusses a distributed approach for detecting distributed intrusions.</p><p>In broadcast encryption, key revocation has been an important mechanism to recover from compromised keys <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b25">26]</ref>; however, these approaches do not provide duplicate node detection in sensor networks. Similarly, the results of key revocation in the context of multicast content distribution <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b36">37]</ref> do not apply here.</p><p>The Sybil attack is related to the node replication attack-in the Sybil attack, a malicious node gains an unfair advantage by claiming multiple identities <ref type="bibr" target="#b9">[10]</ref>. Douceur presents countermeasures for peer-to-peer networks that involve resource verification (computation, communication, and memory) <ref type="bibr" target="#b9">[10]</ref>. Newsome et al. present techniques to defend against the Sybil attack in sensor networks <ref type="bibr" target="#b26">[27]</ref>. Their countermeasures include wireless network testing, key space verification, and central node registration. Only their centralized node registration technique (similar to the one we describe in Section 3.1) can detect a node replication attack, but it is brittle in the face of node compromise and has a high overhead, as we show in this paper.</p><p>Bawa et al. <ref type="bibr" target="#b0">[1]</ref> propose an algorithm for counting the number of members of a peer-to-peer network that is related in spirit to our approach; they propose a random sampling approach that provides an estimate of the network size after O( √ n) samples are drawn and a duplicate node is sampled (for a network of size n), by using the birthday paradox. Our Randomized Multicast also relys on the birthday paradox.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Future Work</head><p>In the preceding discussion, we have assumed that the nodes controlled by the adversary continue to follow the protocols described. In our future work, we would like to explore additional mechanisms to ensure that our protocols continue to function even in the face of misbehaving nodes. For example, McCune et al. describe a technique that uses secure implicit sampling to detect nodes that suppress or drop messages <ref type="bibr" target="#b22">[23]</ref>. We could also use some of the techniques described in Section 8.2 to periodically sweep the network for replicas, thus preventing the adversary from establishing a significant foothold in the network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11">Conclusion</head><p>We have discussed various approaches used to detect node replication. In Section 3, we show how centralized approaches place excessive trust in the base station and excessive load on those nodes near it. Local voting schemes are ill equipped to detect distributed node replication. In contrast, we present two schemes that enable distributed detection of distributed events. The final scheme, Line-Selected Multicast, provides excellent resiliency while achieving near optimal communication overhead with only modest memory requirements. Both of our primary schemes illustrate the power of emergent properties in sensor networks. Given the adversary model typically assumed in sensor networks, we argue that the security of such networks will increasingly depend on emergent algorithms. Cost considerations and unattended deployment will always leave individual sensors vulnerable to compromise. Since we cannot predict the exact nature or number of targets the adversary will select, the network must collectively resist, report and revoke compromised nodes in a manner that goes beyond traditional intrusion detection systems. We expect that emergent algorithms will ultimately provide the best defense against these insidious attacks.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Line-Selected MulticastIn this figure, the adversary has created a replica of α, α . Neighbors (βi and βi ) at these locations all report these claims to randomly selected witnesses γi and γi , which results in an intersection at σ.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Communication Overhead This figure indicates the average amount of communication per node. Note that Randomized Multicast scales linearly with the number of nodes, while Line-Selected Multicast scales as √ n. The error bars on the data from the two Multicast schemes represent the standard error. Probability of Detection This graph illustrates the average probability of detecting a single node replication using Line-Selected Multicast in a variety of topologies. See Appendix A for examples of the graphs tested.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Simulation Results</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 .</head><label>1</label><figDesc>Summary of Protocol Costs This tables il-</figDesc><table><row><cell>lustrates the memory and communication costs for each</cell></row><row><cell>protocol. The communication costs are for the entire</cell></row><row><cell>network and the memory costs are per node. The Line-</cell></row><row><cell>Selected Multicast protocol offers the most efficient so-</cell></row><row><cell>lution in terms of resiliency versus cost.</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&amp;P'05) 1081-6011/05 $ 20.00 IEEE</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>This will hold true if the sensor network deployment approximates any regular polygon.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&amp;P'05)</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3"><p>The network in which n = 10, 000, g = 100, d = 20, and p = 0.05.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_4"><p>Lines drawn by randomly selecting two points, p 1 and p 2 , from within the unit circle, and drawing the line extending through them. Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&amp;P'05) 1081-6011/05 $ 20.00 IEEE</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_5"><p>Segments drawn by randomly selecting two points, p 1 and p 2 , from within the unit circle, and drawing the line segment connecting them. Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&amp;P'05) 1081-6011/05 $ 20.00 IEEE</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_6"><p>Our simulations show little variance with values of d ranging from 10 to 50, though the communication required by the Randomized Multicast drops slightly for larger values of d. Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&amp;P'05) 1081-6011/05 $ 20.00 IEEE</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_7"><p>Technically, both of these modifications would require some additional configuration to account for propagation delays and uncertainty as to the size and width of the network, but the essential idea remains sound.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The authors would like to thank Haowen Chen and Dawn Song for their insightful comments and suggestions. Diana Seymour provided discerning observations and invaluable help editing the paper. We would also like to thank the anonymous reviewers for their helpful suggestions.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"> *   <p>The views and conclusions contained in this paper are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of Bosch, Carnegie Mellon University, NSF, the Army Research Office, the Army Research Laboratory, the U.S. Government or any of its agencies. † Bryan Parno is supported in part by an NDSEG Fellowship, which is sponsored by the Department of Defense. ‡ This research was supported in part by CyLab at Carnegie Mellon under grant DAAD19-02-1-0389 from the Army Research Office, and grant CAREER CNS-0347807 from NSF, and by a gift from Bosch. § Virgil Gligor was supported in part by the U.S. Army Research Office under Award No. DAAD19-01-1-0494, and by the U.S. Army Research Laboratory under Cooperative Agreement DAAD19-01-2-0011 for the Collaborative Technology Alliance for Communications and Networks.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Network Topologies</head></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Estimating aggregates on a peer-to-peer network</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Garcia-Molina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gionis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
		<respStmt>
			<orgName>Stanford University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Space requirements for broadcast encryption</title>
		<author>
			<persName><forename type="first">C</forename><surname>Blundo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cresti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology</title>
		<imprint>
			<publisher>EURO-CRYPT</publisher>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Trade-offs between communication and storage in unconditionally secure schemes for broadcast encryption and interactive key distribution</title>
		<author>
			<persName><forename type="first">C</forename><surname>Blundo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Mattos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Stinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology (CRYPTO)</title>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Rumor routing algorithm for sensor networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Braginsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Workshop on Wireless Sensor Networks and Applications</title>
		<meeting>ACM Workshop on Wireless Sensor Networks and Applications</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">GPS-less lowcost outdoor localization for very small devices</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bulusu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Heidemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000-10">October 2000</date>
			<publisher>IEEE Personal Communications Magazine</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Random key predistribution schemes for sensor networks</title>
		<author>
			<persName><forename type="first">H</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Symposium on Security and Privacy</title>
		<meeting>IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2003-05">May 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Introduction to Algorithms</title>
		<author>
			<persName><forename type="first">T</forename><surname>Cormen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Stein</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Convex position estimation in wireless sensor networks</title>
		<author>
			<persName><forename type="first">L</forename><surname>Doherty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S J</forename><surname>Pister</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">E</forename><surname>Ghaoui</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Infocom</title>
		<meeting>IEEE Infocom</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">On the security of public key protocols</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dolev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The Sybil attack</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Douceur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Workshop on Peer-to-Peer Systems (IPTPS)</title>
		<meeting>Workshop on Peer-to-Peer Systems (IPTPS)</meeting>
		<imprint>
			<date type="published" when="2002-03">Mar. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Building the IBM 4758 Secure Coprocessor</title>
		<author>
			<persName><forename type="first">J</forename><surname>Dyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lindemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Perez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sailer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Van Doorn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Weingart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Fine-grained network time synchronization using reference broadcasts</title>
		<author>
			<persName><forename type="first">J</forename><surname>Elson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Girod</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGOPS Oper. Syst. Rev</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A key-management scheme for distributed sensor networks</title>
		<author>
			<persName><forename type="first">L</forename><surname>Eschenauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Gligor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Conference on Computer and Communication Security (CCS)</title>
		<meeting>the ACM Conference on Computer and Communication Security (CCS)</meeting>
		<imprint>
			<date type="published" when="2002-11">Nov. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Next century challenges: Scalable coordination in sensor networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Govindan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Heidemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mobile Computing and Networking</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Broadcast encryption</title>
		<author>
			<persName><forename type="first">A</forename><surname>Fiat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology (CRYPTO)</title>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Long-lived broadcast encryption</title>
		<author>
			<persName><forename type="first">J</forename><surname>Garay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Staddon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wool</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology (CRYPTO)</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Security of emergent properties in ad-hoc networks</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">D</forename><surname>Gligor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Workshop on Security Protocols</title>
		<meeting>International Workshop on Security Protocols</meeting>
		<imprint>
			<date type="published" when="2004-04">Apr. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Asymptotically optimal time synchronization in dense sensor networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Servetto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM International Conference on Wireless Sensor Networks and Applications</title>
		<meeting>ACM International Conference on Wireless Sensor Networks and Applications</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">GPSR: Greedy perimeter stateless routing for wireless networks</title>
		<author>
			<persName><forename type="first">B</forename><surname>Karp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">T</forename><surname>Kung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Conference on Mobile Computing and Networking (Mo-biCom)</title>
		<meeting>Conference on Mobile Computing and Networking (Mo-biCom)</meeting>
		<imprint>
			<date type="published" when="2000-08">Aug. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Efficient distribution of key chain commitments for broadcast authentication in distributed sensor networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>Network and Distributed System Security Symposium (NDSS)</meeting>
		<imprint>
			<date type="published" when="2003-02">Feb. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Combinatorial bounds for broadcast encryption</title>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Staddon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology (EUROCRYPT)</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A public-key infrastructure for key distribution in TinyOS based on elliptic curve cryptography</title>
		<author>
			<persName><forename type="first">D</forename><surname>Malan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Welsh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Conference on Sensor and Ad hoc Communications and Networks (SECON)</title>
		<meeting>IEEE Conference on Sensor and Ad hoc Communications and Networks (SECON)</meeting>
		<imprint>
			<date type="published" when="2004-10">Oct. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Detection of denial-of-message attacks on sensor network broadcasts</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Mccune</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Symposium on Security and Privacy</title>
		<meeting>IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2005-05">May 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Protocols for public key cryptosystems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Merkle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Research in Security and Privacy</title>
		<meeting>the IEEE Symposium on Research in Security and Privacy</meeting>
		<imprint>
			<date type="published" when="1980-04">Apr. 1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A digital signature based on a conventional encryption function</title>
		<author>
			<persName><forename type="first">R</forename><surname>Merkle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology (CRYPTO)</title>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Revocation and tracing schemes for stateless receivers</title>
		<author>
			<persName><forename type="first">D</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lotspiech</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology (CRYPTO)</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The Sybil attack in sensor networks: Analysis and defenses</title>
		<author>
			<persName><forename type="first">J</forename><surname>Newsome</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Conference on Information Processing in Sensor Networks (IPSN)</title>
		<meeting>IEEE Conference on Information Processing in Sensor Networks (IPSN)</meeting>
		<imprint>
			<date type="published" when="2004-04">Apr. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">GEM: Graph embedding for routing and data-centric storage in sensor networks without geographic information</title>
		<author>
			<persName><forename type="first">J</forename><surname>Newsome</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Embedded Networked Sensor Systems (SenSys)</title>
		<imprint>
			<date type="published" when="2003-11">Nov. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">SPINS: Security protocols for sensor networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Szewczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Wen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Culler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Tygar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Mobile Computing and Networks (MobiCom)</title>
		<imprint>
			<date type="published" when="2001-07">July 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">GHT: A geographic hash table for data-centric storage</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ratnasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Karp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Govindan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM International Workshop on Wireless Sensor Networks and Applications (WSNA)</title>
		<meeting>ACM International Workshop on Wireless Sensor Networks and Applications (WSNA)</meeting>
		<imprint>
			<date type="published" when="2002-09">Sept. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">A compact and fast hybrid signature scheme for multicast packet</title>
		<author>
			<persName><forename type="first">P</forename><surname>Rohatgi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on Computer and Communications Security (CCS)</title>
		<meeting>ACM Conference on Computer and Communications Security (CCS)</meeting>
		<imprint>
			<date type="published" when="1999-11">Nov. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Swatt: Software-based attestation for embedded devices</title>
		<author>
			<persName><forename type="first">A</forename><surname>Seshadri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Van Doorn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Khosla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Symposium on Security and Privacy</title>
		<meeting>IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2004-05">May 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Building a highperformance, programmable secure coprocessor. Computer Networks</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Weingart</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999-04">Apr. 1999</date>
		</imprint>
		<respStmt>
			<orgName>Special Issue on Computer Network Security</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Solomon</surname></persName>
		</author>
		<title level="m">Geometric Probability. Society for Industrial and Applied Mathematics (SIAM)</title>
		<imprint>
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Key management for multicast: Issues and architectures. Internet Request for Comment RFC 2627, Internet Engineering Task Force</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wallner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Harder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Agee</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999-06">June 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Physical security devices for computer subsystems: A survey of attacks and defenses</title>
		<author>
			<persName><forename type="first">S</forename><surname>Weingart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Cryptographic Hardware and Embedded Systems (CHES)</title>
		<imprint>
			<date type="published" when="2000-08">Aug. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Secure group communications using key graphs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gouda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
