<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient Update Control of Bloom Filter Replicas in Distributed Systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yifeng</forename><surname>Zhu</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Maine</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Hong</forename><surname>Jiang</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">University of Nebraska -Lincoln</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Efficient Update Control of Bloom Filter Replicas in Distributed Systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.4018/978-1-60566-661-7.ch034</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2023-01-01T13:42+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">IntroductIon to Bloom FIlters</head><p>A standard Bloom filter (BF) <ref type="bibr">(Bloom, 1970)</ref> is a lossy but space-efficient data structure to support membership queries within a constant delay. As shown in Figure <ref type="figure">1</ref>, a BF includes k independent random hash functions and a vector B of a length of m bits. It is assumed that the BF represents a finite set S = {x 1 , x 2 ,…,x n } of n elements from a universe U . The hash functions h i (x), 1 ≤ i ≤ k, map the universe U to the bit address space <ref type="bibr">[1,m]</ref>, shown as follows,</p><formula xml:id="formula_0">H(x) = {h i (x) | 1 ≤ h i (x) ≤ m for 1 ≤ i ≤ k} (1)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ABstrAct</head><p>This chapter discusses the false rates of Bloom filters in a distributed environment. A Bloom filter (BF) is a space-efficient data structure to support probabilistic membership query. In distributed systems, a Bloom filter is often used to summarize local services or objects and this Bloom filter is replicated to remote hosts. This allows remote hosts to perform fast membership query without contacting the original host. However, when the services or objects are changed, the remote Bloom replica may become stale. This chapter analyzes the impact of staleness on the false positive and false negative for membership queries on a Bloom filter replica. An efficient update control mechanism is then proposed based on the analytical results to minimize the updating overhead. This chapter validates the analytical models and the update control mechanism through simulation experiments.</p><p>DOI: 10.4018/978-1-60566-661-7.ch034</p><p>Definition 1. For all</p><formula xml:id="formula_1">x ∈ U, B[H(x)] ≡ {B[h i (x)] | 1 ≤ i ≤ k}.</formula><p>This notation facilitates the description of operations on the subset of B addressed by the hash functions. For example, B[H(x)] = 1 represents the condition in which all the bits in B at the positions of h 1 (x),…, and h k (x) are 1. " <ref type="bibr">Setting B[H(x)</ref>]" means that the bits at these positions in B are set to 1.</p><p>Representing the set S using a BF B is fast and simple. Initially, all the bits in B are set to 0. Then for each x ∈ S, an operation of setting B[H(x)] is performed. Given an element x, to check whether x is in S , one only needs to test whether B[H(x)] = 1. If no, then x is not a member of S; If yes, x is conjectured to be in S. Figure <ref type="figure">1</ref> shows the results after the element x is inserted into the Bloom filter.</p><p>A standard BF has two well-known properties that are described by the following two theorems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>theorem 1.Zero false negative</head><p>For ∀x ∈ U, if ∃i, B[h i (x)] ≠ 1, then x S / Î .</p><p>For a static set S whose elements are not dynamically deleted, the bit vector indexed by those hash functions always never returns a false negative. The proof is easy and is not given in this chapter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>theorem 2.Possible false positive</head><p>For ∀x ∈ U, if B[H(x)] = 1, then there is a small probability f + that x S / Î . This probability is called the false positive rate and f + ≈ (1 − e −kn/m ) k . Given a specific ratio of m/n, f + is minimized when k = (m/n)ln2 and f min m n + / » . ( ) 0 6185</p><p>. Proof: The proof is based on the mathematical model proposed in <ref type="bibr" target="#b11">(James, 1983;</ref><ref type="bibr">McIlroy, 1982)</ref>. Detailed proof can be found in <ref type="bibr" target="#b16">(Li et al., 2000;</ref><ref type="bibr" target="#b20">Michael, 2002)</ref>. For the convenience of the reader, the proof is briefly presented here.</p><p>After inserting n elements into a BF, the probability that a bit is zero is given by: Figure <ref type="figure">1</ref>. A Bloom filter with a bit vector of m bits, and k independent hash functions. When an element x is added into the set represented, all bits indexed by those hash functions are set to 1.</p><formula xml:id="formula_2">P n m e kn kn m 0 1 1 ( ) . = - ae è ç ç ç ç ö ø ÷ ÷ ÷ ÷ » -/ (2)</formula><p>Thus the probability that k bits are set to 1 is</p><formula xml:id="formula_3">P k m e k kn kn ( ) ( bits set = -- ae è ç ç ç ç ö ø ÷ ÷ ÷ ÷ ae è ç ç ç ç ç ç ö ø ÷ ÷ ÷ ÷ ÷ ÷ » --/ 1 1 1 1 m m k</formula><p>) .</p><p>(3)</p><p>Assuming each element is equally likely to be accessed and |S||U|, then the false positive rate is</p><formula xml:id="formula_4">f S U P k e kn m k + -/ = - | | | | ae è ç ç ç ç ö ø ÷ ÷ ÷ ÷ » - 1 1 ( ) ( ). bits set (4)</formula><p>Given a specific ratio of m n , i.e., the number of bits per element, it can be proved that the false posi- tive rate f + is minimized when k ln m n = 2 and the minimal false positive rate is, as has been shown <ref type="bibr" target="#b20">(Michael, 2002</ref>)</p><formula xml:id="formula_5">f + ≈ 0.5 k = (0.6185) m/n (5)</formula><p>The key advantage of a Bloom filter is that its storage requirement falls several orders of magnitude below the lower bounds of error-free encoding structures. This space efficiency is achieved at the cost of allowing a certain (typically none-zero) probability of false positives, that is, it may incorrectly return an "yes" although x is actually not in S. Appropriately adjusting m and k can minimize this probability of false-positive to a sufficiently small value so that benefits from the space and time efficiency far outweigh the penalty incurred by false positives in many applications. For example, when the bit-element ratio is 8 and the number of hash functions is 6, the expected false positive rate is only 0.0216. Figure <ref type="figure" target="#fig_0">2</ref> shows the false positive rate under different configurations.</p><p>In order to represent a dynamic set that is changing over time, <ref type="bibr" target="#b16">(Li et al., 2000)</ref> proposes a variant named counting BF. A counting BF includes an array in which each entry is not a bit but rather a counter consisted of several bits. Counting Bloom filters can support element deletion operations. Let C = {c j | 1 ≤ j ≤ m} denote the counter vector and the counter c j represents the difference between the number of settings and the number of unsetting operations made to the bit B <ref type="bibr">[j]</ref>. All counters c j for 1 ≤ j ≤ m are initialized to zero. When an element x is inserted or deleted, the counters C[H(x)] are incremented or decreased by one, respectively. If c j changes its value from one to zero, B[j] is reset to zero. While this counter array consumes some memory space, <ref type="bibr" target="#b16">(Li et al., 2000)</ref> shows that 4 bits per counter will guarantee the probability of overflow minuscule even with several hundred million elements in a BF.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">ApplIcAtIons oF Bloom FIlters In dIstrIButed systems</head><p>Bloom filters have been extensively used in many distributed systems where information dispersed across the entire system needs to be shared. For example, to reduce the message traffic, <ref type="bibr" target="#b16">(Li et al, 2000)</ref> propose a web cache sharing protocol that employs a BF to represent the content of a web proxy cache and then periodically propagates that filter to other proxies. If a cache miss occurs on a proxy, that proxy checks the BFs replicated from other proxies to see whether they have the desired web objects in their caches. <ref type="bibr" target="#b8">(Hong &amp; Tao, 2003;</ref><ref type="bibr" target="#b10">Hua et al., 2008;</ref><ref type="bibr" target="#b14">Ledlie et al., 2002;</ref><ref type="bibr" target="#b19">Matei &amp; Ian, 2002;</ref><ref type="bibr" target="#b23">Zhu et al., 2004;</ref><ref type="bibr" target="#b24">Zhu et al., 2008)</ref> use BFs to implement the function of mapping logical data identities to their physical locations in distributed storage systems. In these schemes, each storage node constructs a Bloom filter that summarizes the identities of data stored locally and broadcasts the Bloom filter to other nodes. By checking all filters collected locally, a node can locate the requested data without sending massive query messages to other nodes. Similar deployments of BFs have been found in geographic routing in wireless mobile systems <ref type="bibr">(Pai-Hsiang, 2001)</ref>, peer-to-peer systems <ref type="bibr" target="#b7">(Hailong &amp; Jun, 2004;</ref><ref type="bibr" target="#b12">John et al., 2000;</ref><ref type="bibr" target="#b21">Mohan &amp; Kalogeraki, 2003;</ref><ref type="bibr">Rhea &amp; Kubiatowicz, 2002)</ref>, naming services <ref type="bibr" target="#b17">(Little et al., 2002)</ref>, and wireless sensor networks <ref type="bibr" target="#b5">(Ghose et al. 2003;</ref><ref type="bibr" target="#b18">Luk et al. 2007)</ref>.</p><p>A common characteristic of distributed applications of BFs, including all those described above, is that a BF at a local host is replicated to other remote hosts to efficiently support distributed queries. In such dynamical distributed applications, the information that a BF represents evolves over time. However, the updating processes are usually delayed due to the network latency or the delay necessary in aggregating small changes into single updating message in order to reduce the updating overhead. Accordingly the contents of the remote replicas may become partially outdated. This possible staleness in the remote replicas not only changes the probability of false positive answers to membership queries on the remote hosts, but also brings forth the possibility of false negatives. A false negative occurs when a BF replica answers "no" to the membership query for an element while that element actually exists in its host. It is generated when a new element is added to a host while the changes of the BF of this host, including the addition of this new element, have not been propagated to its replicas on other hosts. In addition, this staleness also changes the probability of false positives, an event in which an element is incorrectly identified as a member. Throughout the rest of this chapter, the probabilities of false negatives and false positives are referred to as the false negative rate and false positive rate, respectively. While the false negative and false positive rates for a BF at a local host have been well studied in the context of non-replicated BF <ref type="bibr">(Bloom, 1970;</ref><ref type="bibr" target="#b2">Broder &amp; Mitzenmacher, 2003;</ref><ref type="bibr" target="#b11">James, 1983;</ref><ref type="bibr" target="#b16">Li et al., 2000;</ref><ref type="bibr" target="#b20">Michael, 2002)</ref>, very little attention has been paid to the false rates in the Bloom filter replicas in a distributed environment. In the distributed systems considered in this chapter, the false rates of the replicas are more important since most membership queries are performed on these replicas. A good understanding of the impact of the false negatives and false positives can provide the system designers with important and useful insights into the development and deployment of distributed BFs in such important applications as distributed file, database, and web server management systems in super-scales. Therefore, the first objective of this chapter is to analyze the false rates by developing analytical models and considering the staleness.</p><p>Since different application may desire a different tradeoff between false rate (e.g, miss/fault penalty) and update overhead (e.g., network traffic and processing due to broadcasting of updates), it is very important and significant for the systems overall performance to be able to control such a tradeoff for a given application adaptively and efficiently. The second objective is to develop an adaptive control algorithm that can accurately and efficiently maintain a desirable level of false rate for any given application by dynamically and judiciously adjusting the update frequency.</p><p>The primary contribution of this chapter is its developments of accurate closed-form expressions for the false negative and false positive rates in BF replicas, and the development of an adaptive replica-update control, based on our analytical model, that accurately and efficiently maintains a desirable level of false rate for any given application. To the best of our knowledge, this study is the first of its kind that has considered the impact of staleness of replicated BF contents in a distributed environment, and developed a mechanism to adaptively minimize such an impact so as to optimize systems performance.</p><p>The rest of the chapter is organized as follows. Section 3 presents our analytical models that theoretically derive false negative and false positive rates of a BF replica, as well as the overall false rates in distributed systems. Section 4 validates our theoretical results by comparing them against results obtained from extensive experiments. The adaptive updating protocols based on our theoretical analysis models are presented in Section 5. Section 6 gives related work and Section 7 concludes the chapter. The chapter is extended from our previous publication <ref type="bibr" target="#b23">(Zhu &amp; Jiang, 2006)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">FAlse rAtes In theory</head><p>In many distributed systems, the information about what data objects can be accessed through a host or where data objects are located usually needs to be shared to facilitate the lookup. To provide high scalability, this information sharing usually takes a decentralized approach, to avoid potential performance bottleneck and vulnerability of a centralized architecture such as a dedicated server. While BFs were initially used in non-distributed systems to save the memory space in the 1980's when memory was considered a precious resource <ref type="bibr" target="#b15">(Lee, 1982;</ref><ref type="bibr">McIlroy, 1982)</ref>, they have recently been extensively used in many distributed systems as a scalable and efficient scheme for information sharing, due to their low network traffic overhead.</p><p>The inherent nature of such information sharing in almost all these distributed systems, if not all, can be abstracted as a location identification, or mapping problem, which is described next. Without loss of generality, the distributed system considered throughout this chapter is assumed to consist of a collection of γ autonomous data-storing host computers dispersed across a communication network. These hosts partition a universe U of data objects into γ subsets S 1 , S 2 ,…,S γ , with each subset stored on one of these hosts. Given an arbitrary object x in U, the problem is how to efficiently identify the host that stores x from any one of the hosts.</p><p>BFs are useful to solve this kind of problems. In a typical approach, each host constructs a BF representing the subset of objects stored in it, and then broadcasts that filter to all the other hosts. Thus each host keeps γ − 1 additional BFs, one for every other host. Figure <ref type="figure">3</ref> shows an example of a system with three hosts. Note that a filter i B ˆ is a replica of B i from Host i and i B ˆ may become outdated if the changes to B i are not propagated instantaneously. While the solution to the above information sharing problem can implemented somewhat differently giving rise to a number of solution variants <ref type="bibr" target="#b10">(Hua et al., 2008;</ref><ref type="bibr" target="#b14">Ledlie et al., 2002;</ref><ref type="bibr" target="#b23">Zhu et al., 2004)</ref>, the analysis of false rates presented in this chapter can be easily applied to these variants. The detailed procedures of the operations of insertion, deletion and query of data objects are shown in Figure <ref type="figure" target="#fig_1">4</ref>. When an object x is deleted from or inserted into Host i, the values of the counting filters C i [H(x)] and bits B i [H(x)] are adjusted accordingly. When the fraction of modified bits in B i exceeds Figure <ref type="figure">3</ref>. An example application of Bloom filters in a distributed system with 3 hosts. some threshold, B i is broadcast to all the other hosts to update i B ˆ. To look up x, Host i performs the membership tests on all the BFs kept locally. If a test on B i is positive, then x can potentially be accessed locally. If a test in the filter j B ˆ for any j ≠ i is positive, then x is conjectured to be on Host j with high probability. Finally, if none of the tests is positive, x is considered nonexistent in the system.</p><p>In the following, we begin the analysis by examining the false negative and false positive rate of a single BF replica and then present the analysis of the overall false rates of all BFs kept locally on a host. The experimental validations of the analytical models are presented in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">False rates of Bloom Filter replicas</head><p>Let B be a BF with m bits and B a replica of B. Let n and n be the number of objects in the set represented by B and by B , respectively. We denote ∆ 1 (∆ 0 ) as the set of all one (zero) bits in B that are </p><formula xml:id="formula_6">D 1 1 0 1 = = , = , " Î , { [ ] | [ ] ˆ[ ] [ ]} B i B i B i i m D 0 0 1 1 = = , = , " Î , . { [ ] | [ ] ˆ[ ] [ ]} B i B i B i i m</formula><p>Thus, ∆ 0 + ∆ 1 represent the set of changed bits in B that have not been propagated to B . The number of bits in this set is affected by the update threshold and update latency. Furthermore, if a nonempty ∆ 1 is hit by least one hash function of a membership test on B while all other hash functions of the same test hit bits in B --D D 1 0 with a value of one, then a false negative occurs in B . Similarly, a false positive occurs if the nonempty ∆ 1 is replaced by a nonempty ∆ 0 in the exact membership test scenario on a B described above.</p><p>Lemma 1. Suppose that the numbers of bits in ∆ 1 and in ∆ 0 are mδ 1 and mδ 0 , respectively. Then n is a random variable following a normal distribution with an extremely small variance (i.e., extremely highly concentrated around its mean), that is,</p><formula xml:id="formula_7">E n m k e kn m (ˆ) ln( ) = - + -. -/ d d 1 0<label>(6)</label></formula><p>Proof: In a given BF representing a set of n objects, each bit is zero with probability P 0 (n), given in Equation 2, or one with probability P 1 (n) = 1 − P 0 (n). Thus the average fractions of zero and one bits are P 0 (n) and P 1 (n), respectively. Ref. <ref type="bibr" target="#b20">(Michael, 2002)</ref> shows formally that the fractions of zero and one bits are random variables that are highly concentrated on P 0 (n) and P 1 (n) respectively. Figure <ref type="figure">5</ref>. An example of a BF B and its replica B where bits are reordered such that bits in ∆ 1 and ∆ 0 are placed together.</p><formula xml:id="formula_8">B --     1 0 1 0 1 0 1 1 0 0 1 1 0 1 1 1 1 1 0 0 0 1 0 B --     1 0 1 0 1 1 0 1 1 0 1 0 0 0 0 1 1 1 1</formula><p>Figure <ref type="figure">5</ref> shows an example of B and B where bits in ∆ 1 and ∆ 0 are extracted out and placed together.</p><p>The expected numbers of zero bits in B − ∆ 1 − ∆ 0 and in B --D D 1 0 should be equal since the bits in them are always identical for any given B and B . Thus for any given n, δ 1 and δ 0 , we have</p><formula xml:id="formula_9">P n E P n 0 0 0 1 ( ) ( (ˆ)) -= - d d (7)</formula><p>Substituting Equation 2 into the above equation, we have</p><formula xml:id="formula_10">e e kn m k E n m -/ - / -= - d d 0 1 ( ˆ)<label>(8)</label></formula><p>After solving Equation <ref type="formula" target="#formula_10">8</ref>, we obtain Equation <ref type="formula" target="#formula_7">6</ref>. Pragmatically, in any given BF with n objects, the values of δ 1 and δ 0 , which represent the probabilities of a bit falling in ∆ 1 and ∆ 0 respectively, are relatively small. Theoretically, the number of bits in ∆ 1 is less than the total number of one bits in B, thus we have δ 1 ≤ 1 − e −kn/m . In a similar way, we can conclude that δ 0 ≤ e −kn/m .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>theorem 3.False Negative Rate</head><p>The expected false negative rate</p><formula xml:id="formula_11">- f in the BF replica B is P 1 (n) k -(P 1 (n) − δ 1 ) k , where P 1 (n) = 1 − e −kn/m .</formula><p>Proof: As mentioned earlier, a false negative in B occurs when at least one hash function hits the bits in ∆ 1 in B while the others hit the bits in B --D D 1 0 with a value of one. Hence, the false negative rate is</p><formula xml:id="formula_12">- = ae è ç ç ç ç ç ç ç ç ö ø ÷ ÷ ÷ ÷ ÷ ÷ ÷ ÷ ÷ - ae è ç ç ç ç ö ø ÷ ÷ ÷ = - å ˆ(ˆ) f P n i k k i i k i 1 1 1 0 d d ÷ ÷ ae è ç ç ç ç ö ø ÷ ÷ ÷ ÷ ae è ç ç ç ç ö ø ÷ ÷ ÷ ÷ = -+ - - k k P n P n 1 0 1 1 0 (ˆ) ( ˆ) d d d</formula><p>Since P 0 (n) = 1 -P 1 (n) and</p><formula xml:id="formula_13">P n P n 0 1 1 (ˆ) (ˆ) = -</formula><p>, Equation 7 can be rewritten as: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E P n P n ( (ˆ))</head><p>( )</p><formula xml:id="formula_14">1 1 0 1 = + - d d (9) Hence E f E P n EP n k k ( ˆ) ( (ˆ)) ( (ˆ)) - ae è ç ç ç ç ö ø ÷ ÷ ÷ ÷ ae è ç ç ç ç ö ø ÷ = -+ - - 1 0 1 1 0 d d d ÷ ÷ ÷ ÷ = - - ae è ç ç ç ç ö ø ÷ ÷ ÷ ÷ P n P n k k 1 1 1 ( ) ( ) d (<label>10</label></formula><formula xml:id="formula_15">)</formula><p>Figure <ref type="figure" target="#fig_2">6</ref> shows the expected false negative rate when the false positive of the original BF is minimized. The minimal false positive rate is 0.0214, 0.0031 and 0.00046 when the bit-element ratio is 8, 12 and 16 respectively. Figure <ref type="figure" target="#fig_2">6</ref> shows that the false negative rates of a BF replica are more than 50% of the false positive rates of the original BF when δ 1 is 5%, and more than 75% when δ 1 is 10%. This proves that the false negative may be significant and should not be neglected in distributed applications. , all hit bits by hash functions of the membership test for x are ones in B --D D 1 0 , or for any x ∈ U, all hit bits are ones in B but at least one hit bit is in ∆ 0 . Thus, we find that</p><formula xml:id="formula_16">+ ae è ç ç ç ç ö ø ÷ ÷ ÷ ÷ = = - | | ae è ç ç ç ç ö ø ÷ ÷ ÷ ÷ - + ae è ç ç ç ç å ˆ(ˆ) f n U P n k i k i k 1 1 0 1 d ç ç ö ø ÷ ÷ ÷ ÷ ÷ - = - | | - - d d d 0 1 0 1 1 0 i k i k k P n P n n U P n ( (ˆ) ) (ˆ) ( (ˆ) )<label>(11)</label></formula><p>Considering n |U and Equation <ref type="formula">9</ref>, we have </p><formula xml:id="formula_17">E f E P n n U E P n k k ( ˆ) ( ( (ˆ))) ( ( (ˆ)) ) + = - | | - 1 1 0 d = + - - | | - ae è ç ç ç ç ö ø ÷ ÷ ÷ ÷ k k P n n U P n 1 0 1 1 1 ( ) ( ( ) ) d d d</formula><formula xml:id="formula_18">» + - ae è ç ç ç ç ö ø ÷ ÷ ÷ ÷ k P n 1 0 1 ( ) d d (12)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">overall False rates</head><p>In the distributed system considered in this study, there are a total of γ hosts and each host has γ BFs, with γ−1 of them replicated from the other hosts. To look up an object, a host performs the membership tests in all the BFs kept locally. This section analyzes the overall false rates on each BF replica and each host.</p><p>Give any BF replica B , the events of a false positive and a false negative are exclusive. Thus it is  easy to find that the overall false rate of B is</p><formula xml:id="formula_19">E f E f E f overall ( ) ( ) ( ) = + - +<label>(13)</label></formula><p>where E f ( )</p><p>and E(f + ) are given in Equation 10 and 12 respectively. On Host i, BF B i represents all the objects stored locally. While only false positives occur in B i , both false positives and false negatives can occur in the replicas j B ˆ for any j ≠ i. Since the failed membership test in any BF leads to a lookup failure, the overall false positive and false negative rates on Host i are therefore </p><formula xml:id="formula_20">E f f f host i j j i j ( ) ( ) ( ˆ) + + = , ¹ + = -- - Õ 1 1 1 1 g (14)</formula><p>and</p><formula xml:id="formula_21">E f f host j j i j ( ) ( ˆ) - = , ¹ - = - - Õ 1 1 1 g (<label>15</label></formula><formula xml:id="formula_22">)</formula><p>where</p><formula xml:id="formula_23">f i + , j f - ˆ and j f + ˆ</formula><p>are given in Theorem 2, 3 and 4 respectively. The probability that Host i fails a membership lookup can be expressed as follows:</p><formula xml:id="formula_24">E f E f f f f host host host host host ( ) ( ) = + - + - + -<label>(16)</label></formula><p>In practice, we can use the overall false rate of a BF replica to trigger updating process and use the overall false rate of all BFs on a host to evaluate the whole systems. In a typical distributed environment with many nodes, the updating of a Bloom filter replica i B ˆ stored on node j can be triggered by either the home node i or the node j. Since many nodes hold the replica of B i , it is more efficient to let the home node i to initiate the updating process of all replicas of B i . Otherwise, the procedure of checking whether an updating is needed would be performed by all other nodes, wasting both network and CPU resources. Accordingly, we can only use the overall false rate of a BF replica E(f overall ) as the updating criteria. On the other hand, E(f host ) can be used to evaluate the overall efficiency of all BFs stored on the same host.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">experImentAl VAlIdAtIon</head><p>This section validates our theoretical framework developed in this chapter by comparing the analytical results produced by our models with experimental results obtained through real experiments.</p><p>We begin by examining a single BF replica. Initially the Bloom filter replica B is exactly the same as B. Then we artificially change B by randomly inserting new objects into B or randomly deleting existing objects from B repeatedly. For each specific modification made to B, we calculate the corresponding δ 1 and δ 0 and use 100,000 randomly generated objects to test the memberships against B . Since the actual objects represented in B are known in the experiments, the false negative and positive rates can be easily measured.</p><p>Figure <ref type="figure" target="#fig_5">8</ref> compares analytical and real false negative rates, obtained from the theoretic models and from experiments respectively, by plotting the false negative rate in B as a function of δ 1 , a measure of update threshold, for different numbers of hashing functions (k = 6 and k = 8) when the initial number of objects in B are 25, 75, 150 and 300 respectively. Since the false negative rates are independent of δ 0 , only object deletions are performed in B.</p><p>Table <ref type="table" target="#tab_0">1</ref> compares the analytical and real false positive rates of B when k is 6 and 8 respectively. In Figure <ref type="figure">10</ref>. In an environment of two servers, the figures show the overall false rate on one server when the initial number of elements in one server are 25 and 150 respectively. The ratio of bits per element is 8 and 6 hash functions are used. The rate for element addition and deletion are respectively 5 and 2 per time unit on each server.</p><p>these experiments, both object deletions and additions are performed in B while B remains unaltered.</p><p>It is interesting that the false positive rates of B is kept around some constant for a specific n although the objects in B changes in the real experiments. It is true that if the number of objects in B increases or decreases, the false positive rate in B should decrease or increase accordingly before the changes of B is propagated to B . However, due to the fact that n is far less than the total object number in the universe U, the change of the false positive rate in B is too small to be perceptible. These tests are made accordant with the real scenarios of BF applications in distributed systems. In such real applications, the number of possible objects is usually very large and thus BFs are deployed to efficiently reduce the network and network communication requirements. Hence, in these experiments the number of objects used to test B is much larger than the number of objects in B or B (100,000 random objects are tested).</p><p>Under such large size of testing samples, the influence of the modification in B on the false positive rate of B is difficult to be observed. We also simulated the lookup problem in a distributed system with 5 hosts. Figure <ref type="figure" target="#fig_6">9</ref> shows the comparisons of the analytical and experimental average overall false rates on each host. In these experiments, we only added new objects without deleting any existing items so that δ 0 is kept zero. The experiments presented in Table <ref type="table" target="#tab_1">2</ref> considers both the deletion and addition of objects on each host when the initial state of BF on each host is optimized, this is, the number of hash functions is the optimal under the ratio between m and the initial number of objects n. This specific setting aims to emulate the real application where m/n and k are usually optimally or sub-optimally matched by dynamically adjusting the BF length m <ref type="bibr" target="#b8">(Hong &amp; Tao, 2003)</ref> or designing the BF length according to the average number of objects <ref type="bibr" target="#b14">(Ledlie et al., 2002;</ref><ref type="bibr" target="#b16">Li et al., 2000;</ref><ref type="bibr" target="#b17">Little et al., 2002;</ref><ref type="bibr" target="#b19">Matei &amp; Ian, 2002;</ref><ref type="bibr" target="#b23">Zhu et al., 2004)</ref>. All the analytical results have been very closely matched by their real (experimental) counterparts consistently, strongly validating our theoretical models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">replIcA updAte protocol</head><p>To reduce the false rate caused by staleness, the remote Bloom filter replica needs to be periodically updated. An update process is typically triggered if the percentage of dirty bits in a local BF exceeds some threshold. While a small threshold causes large network traffic and a large threshold increases the false rate, this tradeoff is usually reached by a trial-and-error approach that runs numerous (typically a large number of) trials in real experiments or simulations. For example, in the summery cache study <ref type="bibr" target="#b16">(Li et al., 2000)</ref>, it is recommended that if 10 percent of bits in a BF are dirty, then the BF propagates its changes to all replicas. However, this approach has the following disadvantages.</p><p>1. It cannot directly control the false rate. To keep the false rate under some target value, complicated simulations or experiments have to be conducted to adjust the threshold for dirty bits. If the target false rate changes, this tedious process has to be repeated to find a "golden" threshold. 2. It treats all dirty bits equally and does not distinguish the zero-dirty bits from the one-dirty bits. In fact, as shown in previous sections, the dirty one bits and the dirty zero bits exert different impacts on the false rates.</p><p>3. It does not allow flexible update control. In many applications, the penalty of a false positive and a false negative are significantly different. For example, in summery cache <ref type="bibr" target="#b16">(Li et al., 2000)</ref>, a false positive occurs if a request is not a cache hit on some web proxy when the corresponding Bloom filter replica confirms so. The penalty of a false positive is a waste of query message to this local web proxy. A false negative happens if a request can be hit in a local web proxy but the Bloom filter replica mistakenly indicates otherwise. The penalty of a false negative is a round-trip delay in retrieving information from a remote web server through the Internet. Thus, the penalty of a false negative is much larger than that of a false positive. The updating protocols based on the percentage of dirty bits do not allow one to place more weight on the false negative rate, thus limiting the flexibility and efficiency of the updating process.</p><p>Based on the theoretic models presented in the previous sections, an updating protocol that directly controls the false rate is designed in this chapter. In a distributed system with γ nodes where each node has a local BF to represent all local elements, each node is responsible for automatically updating its BF replicas. Each node estimates the false rate of its remote BF replica and if the false rate exceeds some desire false rate, as opposed to a predetermined threshold on the percentage of dirty bits in the conventional updating approaches, a updating process is triggered. To estimate the false rate of remote BF replica B , each node has to record the number of elements stored locally (n), in addition to a copy of remote BF replica B . This copy is essentially the local BF B when the last updating is made. It is used to calculate the percentage of dirty one bits (δ 1 ) and the dirty zero bits (δ 0 ). Compared with the conventional updating protocols based on the total percentage of dirty bits, this protocol only needs to record one more variable (n), thus it does not significantly increase the maintenance overhead.</p><p>This protocol allows more flexible updating protocols that consider the penalty difference between a false positive and a false negative. The overall false rate can be a weighted sum of the false positive rate and the false negative rate, shown as follows:</p><formula xml:id="formula_25">E f w E f w E f overall ( ) ( ) ( ) = + + + - -<label>(17)</label></formula><p>where w + and w − are the weights. The values of w + and w − depends on the applications and also the application environments.</p><p>We prove the effectiveness of this update protocol through event driven simulations. In this simulation, we made the following assumptions.</p><p>1. Each item is randomly accessed. This assumption may not be realistic in some real workloads, in which an item has a greater than equal chance of being accessed again once it has been accessed. Though all previous theoretic studies on Bloom filters assume a workload with uniform access spectrum, further studies are needed to investigate the impact of this assumption. 2. Each local node deletes or adds items at a constant rate. In fact, the deletion and addition rate changes dynamically throughout the lifetime of applications. This simplifying assumption is employed just to prove our concept while keeping our experiments manageable in the absence of a real trace or benchmark.</p><p>3. The values of w + and w − are 1. Their optimal values depend on the nature of the applications and environments.</p><p>We simulate a distributed system with two nodes where each node keeps a BF replica of the other. We assume the addition and deletion are 5 and 2 per time unit respectively and our desired false rate is 10%. Figure <ref type="figure">10</ref> shows the estimated false rate and the measured false rate of node 1 throughout the deletion, addition and updating processes. Due to the space limitation, the false rate on node 2, which is similar to node 1, is not shown in this chapter. In addition, we have changed the addition rate and deletion rates. Simulation results consistently indicate that our protocol is accurate and effective in control the false rate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">relAted Work</head><p>Standard Bloom filters <ref type="bibr">(Bloom, 1970)</ref> have inspired many extensions and variants, such as the Counting Bloom filters <ref type="bibr" target="#b16">(Li et al., 2000)</ref>, compressed Bloom filters <ref type="bibr" target="#b20">(Michael, 2002)</ref>, the space-code Bloom filters <ref type="bibr" target="#b13">(Kumar et al., 2005)</ref>, the spectral Bloom filters <ref type="bibr" target="#b22">(Saar &amp; Yossi, 2003)</ref>, time-decaying Bloom filters <ref type="bibr" target="#b3">(Cheng et al., 2005)</ref>, and the Bloom filter state machine <ref type="bibr" target="#b1">(Bonomi et al., 2006)</ref>. The counting Bloom filters are used to support the deletion operation and handle a set that is changing over time <ref type="bibr" target="#b16">(Li et al., 2000)</ref>. Time-decaying Bloom filters maintains the frequency count for each item stored in the Bloom filters and the values of these frequency count decay with time <ref type="bibr" target="#b3">(Cheng et al., 2005)</ref>. Multi-Dimension Dynamic Bloom Filters (MDDBF) supports representation and membership queries based on the multiattribute dimension <ref type="bibr" target="#b6">(Guo et al., 2006)</ref>. Its basic idea is to represent a dynamic set A with a dynamic s × m bit matrix, in which there are s standard Bloom filters and each Bloom filter has a length of m bits. A novel Parallel Bloom Filters (PBF) and an additional hash table has been developed to maintain multiple attributes of items and verify the dependency of multiple attributes, thereby significantly decreasing false positives <ref type="bibr" target="#b9">(Hua &amp; Xiao, 2006)</ref>.</p><p>Bloom filters have significant advantages in space saving and fast query operations and thus have been widely applied in many distributed computer applications, such as aiding longest prefix matching <ref type="bibr" target="#b4">(Dharmapurikar et al., 2006)</ref>, and packet classification <ref type="bibr" target="#b0">(Baboescu &amp; Varghese, 2005)</ref>. Extended Bloom filter provides better throughput performance for router applications based on hash tables by using a small amount of multi-port on-chip memory <ref type="bibr" target="#b23">(Song et al., 2005)</ref>. Whenever space is a concern, a Bloom filter can be an excellent alternative to storing a complete explicit list.</p><p>In many distributed applications, BFs are often replicated to multiple hosts to support membership query without contacting other hosts. However, these replicas might become stale since the changes of BFs usually cannot be propagated instantly to all replicas in order to reduce the update overhead. As a result, the BF replicas may return false negatives. This observation motivates the research presented in this chapter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">conclusIon</head><p>Although false negatives do not occur in standard BF, this chapter shows that the staleness in a BF replica can produce false negative. We presents the theoretical analysis of the impact of staleness existing in many distributed BF applications on the false negative and false positive rates, and developed an adaptive update control mechanism that accurately and efficiently maintains a desirable level of false rate for a given application. To the best of our knowledge, we are the first to derive accurate closed-form expressions that incorporate the staleness into the analysis of the false negative and positive rates of a single BF replica, to develop the analytical models of the overall false rates of BF arrays that have been widely used in many distributed systems, and to develop an adaptively controlled update process that accurately maintains a desirable level of false rate for a given application. We have validated our analysis by conducting extensive experiments. The theoretical analysis presented not only provides system designers with significant theoretical insights into the development and deployment of BFs in distributed systems, but also are useful in practice for accurately determining when to trigger the processes of updating BF replicas in order to keep the false rates under some desired values, or, equivalently, minimize the frequency of updates to reduce update overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">AcknoWledgment</head><p>This work was partially supported by a faculty startup grant of University of Maine, and National Science Foundation Research Grants (CCF #0621493, CCF #0754951, CNS #0723093, DRL #0737583, CNS #0619430).</p><p>Bloom Filter Replica: A Bloom filter replica is a replication of a Bloom filter. In a distributed environment, the original and replicated Bloom filters are typically stored on different servers for improved performance and fault tolerance. A Bloom filter replica will generate both false positives and false negatives.</p><p>Bloom Filter Update Protocol: When the set that a Bloom filter represents is changed over time, the corresponding Bloom filter replica becomes out-dated. In order to reduce the probability that the Bloom filter replica reports the membership incorrectly, the replica needs to be updated frequently. The Bloom filter update protocol determines when a Bloom filter replica needs to be updated.</p><p>Distributed Membership Query: Membership query is one fundamental function that reports where the target data, resource, or service is located. The membership query can be performed by a centralized server or by a group of distributed server. The latter approach has a stronger scalability and is referred as distributed memory query.</p><p>False Negative: A false negative happens when an element is a member of the set that a Bloom filter represents but the Bloom filter mistakenly reports it is not. A standard Bloom filter has no false negatives. However, in a distributed system, a Bloom filter replica can generate false negatives when the replica is not timely updated.</p><p>False Positive: A false positive happens when an element is not a member of the set that a Bloom filter represents but the Bloom filter mistakenly reports it is. The probability of false positives can be very slow when the Bloom filter is appropriately designed.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Expected false positive rate in a standard Bloom filter. A false positive is due to the collision of hash functions, where all indexed bits happen to be set by other elements.</figDesc><graphic url="image-2.png" coords="3,91.80,139.64,446.40,303.48" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Procedures of adding, deleting and querying object x at host i</figDesc><graphic url="image-4.png" coords="7,138.06,125.64,353.88,375.84" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Expected false negative rate of a Bloom filter replica when the configuration of its original Bloom filter is optimal.</figDesc><graphic url="image-6.png" coords="9,117.72,139.64,394.56,280.08" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Expected false positive rate of a Bloom filter replica when the configuration of its original Bloom filter is optimal.</figDesc><graphic url="image-7.png" coords="10,101.88,139.64,390.24,277.92" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>theorem 4 .</head><label>4</label><figDesc>False Positive RateThe expected false positive rate+ f for the Bloom filter replica B is (P 1 (n) + δ 0 − δ 1 ) k , where P 1 (n) = 1 − e −kn/m .Proof: If B confirms positively the membership of an object while this object actually does not belong to B, then a false positive occurs. More specifically, a false positive occurs in B if for any x B / Î</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. Comparisons of estimated and experimental</figDesc><graphic url="image-8.png" coords="12,172.83,162.00,248.33,558.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. Comparisons of estimated and experimental f overall in a distributed system with 5 hosts when k is 6, 8, and 11 respectively. The initial object number n on each host is 25, 75, 150 and 300 respectively. Then each host adds a set of new objects. The number of new objects on each host increases from 50 to 300 with a step size of 50. (m = 1200)</figDesc><graphic url="image-9.png" coords="14,177.52,167.64,238.96,558.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic url="image-1.png" coords="2,82.44,139.64,429.12,122.40" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic url="image-10.png" coords="17,154.26,226.44,321.48,493.56" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>False positive rates comparisons when k is 6 and 8 respectively (m = 1200).</figDesc><table><row><cell>f</cell><cell>+</cell><cell>(percentage)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 .</head><label>2</label><figDesc>Overall false rate comparisons under optimum initial operation state when k is 6 and 8 respectively. 100 new objects are added on each host and then a set of existing objects are deleted from each</figDesc><table><row><cell cols="5">host. The number of deleted objects increases from 10 to 100 with a step size of 10. (m = 1200) In the first</cell></row><row><cell cols="5">group, initially Initially n = 150 and m/n = 8; in the second group, n = 100 and m/n = 12 initially.</cell></row><row><cell></cell><cell></cell><cell></cell><cell>foverall (percentage)</cell><cell></cell></row><row><cell>k</cell><cell>δ 0</cell><cell>δ 1</cell><cell>Estimated</cell><cell>Experimental</cell></row><row><cell>6</cell><cell>0.0100</cell><cell>0.1705</cell><cell>46.2259</cell><cell>45.2200</cell></row><row><cell>6</cell><cell>0.0227</cell><cell>0.1657</cell><cell>42.4850</cell><cell>40.6880</cell></row><row><cell>6</cell><cell>0.0347</cell><cell>0.1627</cell><cell>38.7101</cell><cell>37.2420</cell></row><row><cell>6</cell><cell>0.0458</cell><cell>0.1582</cell><cell>34.9268</cell><cell>33.8460</cell></row><row><cell>6</cell><cell>0.0593</cell><cell>0.1545</cell><cell>31.3748</cell><cell>30.4540</cell></row><row><cell>6</cell><cell>0.0715</cell><cell>0.1497</cell><cell>27.8831</cell><cell>27.3700</cell></row><row><cell>6</cell><cell>0.0837</cell><cell>0.1445</cell><cell>24.5657</cell><cell>24.8000</cell></row><row><cell>6</cell><cell>0.0938</cell><cell>0.1392</cell><cell>21.2719</cell><cell>22.5560</cell></row><row><cell>6</cell><cell>0.1045</cell><cell>0.1340</cell><cell>18.2490</cell><cell>20.4520</cell></row><row><cell>6</cell><cell>0.1165</cell><cell>0.1300</cell><cell>15.5103</cell><cell>18.7540</cell></row><row><cell>8</cell><cell>0.0123</cell><cell>0.2375</cell><cell>30.9531</cell><cell>29.6280</cell></row><row><cell>8</cell><cell>0.0255</cell><cell>0.2275</cell><cell>25.7946</cell><cell>23.6280</cell></row><row><cell>8</cell><cell>0.0413</cell><cell>0.2180</cell><cell>21.0943</cell><cell>18.0000</cell></row><row><cell>8</cell><cell>0.0552</cell><cell>0.2123</cell><cell>16.7982</cell><cell>14.6720</cell></row><row><cell>8</cell><cell>0.0658</cell><cell>0.2043</cell><cell>12.9800</cell><cell>12.0040</cell></row><row><cell>8</cell><cell>0.0772</cell><cell>0.1965</cell><cell>9.7307</cell><cell>9.7320</cell></row><row><cell>8</cell><cell>0.0920</cell><cell>0.1900</cell><cell>7.1016</cell><cell>7.7520</cell></row><row><cell>8</cell><cell>0.1075</cell><cell>0.1848</cell><cell>4.9936</cell><cell>6.1280</cell></row><row><cell>8</cell><cell>0.1237</cell><cell>0.1788</cell><cell>3.4031</cell><cell>4.8400</cell></row><row><cell>8</cell><cell>0.1377</cell><cell>0.1732</cell><cell>2.2034</cell><cell>3.8160</cell></row></table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Space/time trade-offs in hash coding with allowable errors</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baboescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
		<idno type="DOI">10.1145/362686.362692</idno>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="422" to="426" />
			<date type="published" when="1970">2005. 1970</date>
		</imprint>
	</monogr>
	<note>IEEE/ACM Trans. Netw.</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Beyond bloom filters: from approximate membership checks to approximate state machines</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bonomi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Panigrah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
	<note>Paper presented at the Proceedings of the 2006 conference on Applications, technologies, architectures, and protocols for computer communications</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Network Applications of Bloom Filters: A Survey</title>
		<author>
			<persName><forename type="first">A</forename><surname>Broder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Internet Mathematics</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="485" to="509" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Time-Decaying Bloom Filters for Data Streams with Skewed Distributions</title>
		<author>
			<persName><forename type="first">K</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Xiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Iwaihara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Mohania</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th International Workshop on Research Issues in Data Engineering: Stream Data Mining and Applications</title>
				<meeting>the 15th International Workshop on Research Issues in Data Engineering: Stream Data Mining and Applications</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Longest prefix matching using bloom filters</title>
		<author>
			<persName><forename type="first">S</forename><surname>Dharmapurikar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Taylor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Netw</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="397" to="409" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Resilient Data-Centric Storage in Wireless Ad-Hoc Sensor Networks</title>
		<author>
			<persName><forename type="first">F</forename><surname>Ghose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Grossklags</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chuang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings the 4th International Conference on Mobile Data Management (MDM&apos;03)</title>
				<meeting>the 4th International Conference on Mobile Data Management (MDM&apos;03)</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="45" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Theory and Network Applications of Dynamic Bloom Filters</title>
		<author>
			<persName><forename type="first">D</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Luo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INFOCOM 2006. 25th IEEE International Conference on Computer Communications</title>
				<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Foreseer: a novel, locality-aware peer-to-peer system architecture for keyword searches</title>
		<author>
			<persName><forename type="first">C</forename><surname>Hailong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Jun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th ACM/IFIP/USENIX International Conference on Middleware</title>
				<meeting>the 5th ACM/IFIP/USENIX International Conference on Middleware</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An Efficient Data Location Protocol for Self.organizing Storage Clusters</title>
		<author>
			<persName><forename type="first">T</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Tao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2003 ACM/IEEE conference on Supercomputing</title>
				<meeting>the 2003 ACM/IEEE conference on Supercomputing</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A Multi-attribute Data Structure with Parallel Bloom Filters for Network Services</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Hua</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Xiao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 13th International Conference of High Performance Computing (HiPC)</title>
				<meeting>13th International Conference of High Performance Computing (HiPC)</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="277" to="288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Scalable and Adaptive Metadata Management in Ultra Large-Scale File Systems</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Hua</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Tian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th International Conference on Distributed Computing Systems</title>
				<meeting>the 28th International Conference on Distributed Computing Systems</meeting>
		<imprint>
			<date type="published" when="2008">2008. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A second look at bloom filters</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>James</surname></persName>
		</author>
		<idno type="DOI">10.1145/358161.358167</idno>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="570" to="571" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">OceanStore: an architecture for global-scale persistent storage</title>
		<author>
			<persName><forename type="first">K</forename><surname>John</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Steven</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Patrick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Dennis</surname></persName>
		</author>
		<idno type="DOI">10.1145/356989.357007</idno>
	</analytic>
	<monogr>
		<title level="j">SIGPLAN Not</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="190" to="201" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Efficient and scalable query routing for unstructured peerto-peer networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Zegura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings INFOCOM 2005, 24th Annual Joint Conference of the IEEE Computer and Communications Societies</title>
				<meeting>INFOCOM 2005, 24th Annual Joint Conference of the IEEE Computer and Communications Societies</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Scaling Filename Queries in a Large-Scale Distributed File System</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ledlie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Serban</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Toncheva</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Harvard University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Designing a Bloom filter for differential file access</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">G</forename><surname>Lee</surname></persName>
		</author>
		<idno type="DOI">10.1145/358628.358632</idno>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="600" to="604" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Summary cache: a scalable wide-area web cache sharing protocol</title>
		<author>
			<persName><forename type="first">F</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jussara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">B</forename><surname>Andrei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Netw</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="281" to="293" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Little</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Shrivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">A</forename><surname>Speirs</surname></persName>
		</author>
		<idno type="DOI">10.1093/comjnl/45.6.645</idno>
	</analytic>
	<monogr>
		<title level="j">The Computer Journal</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="645" to="652" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">MiniSec: A Secure Sensor Network Communication Architecture</title>
		<author>
			<persName><forename type="first">M</forename><surname>Luk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Mezzour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Gligor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Conference on Information Processing in Sensor Networks (IPSN)</title>
				<meeting>IEEE International Conference on Information Processing in Sensor Networks (IPSN)</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="479" to="488" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A Decentralized, Adaptive Replica Location Mechanism</title>
		<author>
			<persName><forename type="first">R</forename><surname>Matei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th IEEE International Symposium on High Performance Distributed Computing. McIlroy, M</title>
				<meeting>the 11th IEEE International Symposium on High Performance Distributed Computing. McIlroy, M</meeting>
		<imprint>
			<date type="published" when="1982">2002. 1982</date>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="91" to="99" />
		</imprint>
	</monogr>
	<note>Communications. legacy, pre -1988</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Compressed bloom filters</title>
		<author>
			<persName><forename type="first">M</forename><surname>Michael</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Netw</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="604" to="612" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Speculative routing and update propagation: a kundali centric approach</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mohan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kalogeraki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE INFOCOM 2002, Twenty-First Annual Joint Conference of the IEEE Computer and Communications Societies Proceedings</title>
				<editor>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Rhea</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Kubiatowicz</surname></persName>
		</editor>
		<imprint>
			<publisher>Pai-Hsiang, H</publisher>
			<date type="published" when="2001">2003. 2003. 2001. 2002</date>
		</imprint>
	</monogr>
	<note>Proceedings of the 2nd ACM international symposium on Mobile ad hoc networking and computing</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Spectral bloom filters</title>
		<author>
			<persName><forename type="first">C</forename><surname>Saar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yossi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2003 ACM SIGMOD international conference on Management of data</title>
				<meeting>the 2003 ACM SIGMOD international conference on Management of data</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Fast hash table lookup using extended bloom filter: an aid to network processing</title>
		<author>
			<persName><forename type="first">H</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dharmapurikar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Turner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lockwood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2005 conference on Applications, technologies, architectures, and protocols for computer communications</title>
				<meeting>the 2005 conference on Applications, technologies, architectures, and protocols for computer communications</meeting>
		<imprint>
			<date type="published" when="2004">2005. 2006. 2004</date>
		</imprint>
	</monogr>
	<note>Hierarchical Bloom filter arrays (HBA): a novel, scalable metadata management system for large cluster-based storage. Paper presented at the Proceedings of the 2004 IEEE</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">key terms And deFInItIons Bloom Filter: A Bloom filter is a space-efficient data structure that supports membership queries. It consists of a bit array and all bits are initially set to 0. It uses a fix number of predefined independent hash functions. For each element, all hashed bits are set to 1. To check whether an element belongs to the set represented by a Bloom filter, one simply checks all bits pointed by the hash functions are 1. If not, the element is not in the set. If yes, the element is consider as a member. Bloom Filter Array: A Bloom filter array, consisted of multiple Bloom filters, represents multiple sets</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Xian</surname></persName>
		</author>
		<idno type="DOI">10.1109/TPDS.2007.70788</idno>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Parallel and Distributed Systems</title>
				<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="750" to="763" />
		</imprint>
	</monogr>
	<note>HBA: Distributed Metadata Management for Large Cluster-Based Storage Systems. It is a space-efficient data structure to evaluate whether an element is within these sets and which set this element belongs to if yes</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
