<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An Approach to using XML and a Rule-based Content Language with an Agent Communication Language</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Benjamin</forename><forename type="middle">N</forename><surname>Grosof</surname></persName>
							<email>grosof@us.ibm.com</email>
						</author>
						<author>
							<persName><forename type="first">Ibm</forename><forename type="middle">T J</forename><surname>Watson</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Research Center</orgName>
								<address>
									<addrLine>30 Saw Mill River Road</addrLine>
									<postCode>10532</postCode>
									<settlement>Hawthorne</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution" key="instit1">University of Maryland</orgName>
								<orgName type="institution" key="instit2">Baltimore County</orgName>
								<address>
									<postCode>21250</postCode>
									<settlement>Baltimore</settlement>
									<region>MD</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">An Approach to using XML and a Rule-based Content Language with an Agent Communication Language</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">81BB2632FE1B2D149C7FDC9FE417865F</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:15+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We argue for an XML encoding of FIPA Agent Communication Language (ACL), and give an alpha version of it, called Agent Communication Markup Language (ACML), which we have implemented. The XML approach facilitates: (a) developing/maintaining parsers, integrating with WWW-world software engineering, and (b) the enriching capability to (hyper-)link to ontologies and other extra information. The XML approach applies similarly to KQML as well.</p><p>Motivated by the importance of the content language aspect of agent communication, we focus in particular on business rules as a form of content that is important in e-commerce applications such as bidding negotiations. A leading candidate content language for business rules is Knowledge Interchange Format (KIF), which is currently in the ANSI standards committee process. We observe several major practical shortcomings of KIF as a content language for business rules in e-commerce. We argue instead for a knowledge representation (KR) approach based on Courteous Logic Programs (CLP) that overcomes several of KIF's representational limitations, and argue for this CLP approach, e.g., for its logical nonmonotonicity and its computational practicality. CLP is a previous KR that expressively extends declarative ordinary logic programs cf. Prolog; it includes negation-asfailure plus prioritized conflict handling.</p><p>We argue for an XML encoding of business rules content, and give an alpha version of it, called Business Rules Markup Language (BRML), which we have implemented. BRML can express both CLP and a subset of KIF (i.e., of first-order logic) that overlaps with CLP. BRML expressively both extends and complements KIF.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The concept of an Agent Communication Language (ACL) has its origins in the work of the Knowledge Sharing Effort (KSE). The KSE work gave birth to Knowledge Query and Manipulation Language (KQML) in the early 1990's, out of which in turn infuenced the Foundation for Intelligent Physical Agents (FIPA standards body) ACL <ref type="foot" target="#foot_0">1</ref> . (Terminology: In this paper, by "ACL" we mean either KQML (which has now several variants) or FIPA ACL. Since then the problem of an adequate semantics of an ACL has dominated the debate on ACL's. Despite the substantial amount of work on this problem, the issue of an agent's conformance with the ACL semantics is as thorny as ever <ref type="bibr" target="#b18">[18]</ref> and moreover puts into question the degree of usefulness of semantic accounts. But even worse, the emphasis on ACL semantics has drawn attention away from other issues that are perhaps even more important to the success of ACL's: <ref type="bibr" target="#b0">(1)</ref> how do agents find one another and manage to establish a "conversation"; (2) having achieved that, what is the "content" about which they actually talk; <ref type="bibr">and (3)</ref> the relationship between ACL's and WWW tech-nologies. We are interested in the latter two issues. <ref type="foot" target="#foot_1">2</ref>KQML and FIPA ACL have evolved at a considerable distance from the mainstream of Internet technologies and standards. No Internet standardization organization has ACL's in their agenda. With the exception of the Artimis project (France Telecom), no major industry player has committed major resources to depend upon, or to develop, ACL's, although there are some plans for future work that will take advantage of FIPA technologies, as they become available. At the same time the WWW is a huge repository of information and agents are almost always referred to in conjuction with the WWW. ACL's are driving a great part of the agent work (FIPA ACL is the centerpiece of the FIPA effort); it is thus reasonable to suggest that ACL work ought to integrate easily with the WWW and to be able to leverage WWW tools and infrastructure. This motivates us to give (and to advocate) an Extensible Markup Language (XML) encoding of ACL messages, as a first step towards this kind of integration. Agents, while conversing, exchange their information content; specifically we focus on the language used to describe it, i.e., the content language in ACL terminology. An ACL message's content layer, which contains descriptions in the content language, is distinct from the propositional-attitude layer which contains the (speech act type of) primitive of the ACL message. (Terminology: In this paper, by an ACL communication "primitive", we mean what KQML calls a "performative" and what FIPA ACL calls a "communicative act".) The KSE developed the Knowledge Interchange Format (KIF) as a general-purpose content language. However, it is important for ACL's to support multiple, e.g., special-purpose, content languages. We are particularly interested in representing business rules for e-commerce applications of agent communications. For this purpose, we observe that KIF has significant shortcomings, notably, its inability to represent logical non-monotonicity. Accordingly, we give a new content language for business rules: an extended form of logic programs, with deep declarative semantics, encoded moreover in XML. This language, called Business Rules Markup Language (BRML), overcomes several limitations of KIF, yet broadly overlaps with KIF both syntactically and semantically; it thus extends and complements KIF.</p><p>Next, we give an outline of the remainder of this paper. In Section 2, we argue for the advantages of encoding ACL messages in XML and then present ACML, an XML language for that purpose. In Section 3 we review the content language concept and some existing content languages, then discuss our focus on business rules for ecommerce applications such as bidding negotiations. In Section 4, we review KIF and critique its shortcomings as a representation for business rules. In Section 5, we give a business rules content language, called Courteous Logic Programs (CLP), that extends and complements KIF, while addressing several of KIF's shortcomings. In Section 6 we present BRML, the XML encoding of CLP. In Section 7, we describe our implementation. Current and future work directions are discussed in appropriate spots throughout the paper but we summarize them in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">XML Embodiment of FIPA ACL</head><p>In this section, we give an encoding of FIPA ACL messages in XML, and observe that using XML has several advantages. This leads us to suggest that in future industry practice, the preferred encoding for ACL messages should be XML rather than pure ASCII. (We are focusing on FIPA ACL but the same arguments and approach would apply to KQML too.) Finin, Labrou, and Grosof together first advocated this idea to FIPA during the FIPA meeting in Dublin, in July 1998. Although other groups of researchers have been considering a XML encoding for FIPA ACL, this paper is (to the the best of our knowledge) the first published treatment of this issue. As we will detail in Section 6, we advocate using XML also for the content of the ACL message itself, for similar reasons. Keep in mind, however, that the content need not be in XML even if the ACL message is in XML, or vice versa.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Brief Review of XML</head><p>XML is a language for creating markup languages that describe data. XML is a machine-readable and applicationindependent encoding of a "document", e.g., of a FIPA ACL message including its content.</p><p>In contrast to HTML which describes document structure and visual presentation, XML describes data in a human-readable format with no indication of how the data is to be displayed. It is a database-neutral and device-neutral format; data marked up in XML can be targeted to different devices using, for example, eXtensible Style Language (XSL). The XML source by itself is not primarily intended directly for human viewing, though it is human-understandable. Rather, the XML is rendered using standard available XML-world tools, then browsed, e.g., using standard Web browsers or specialized other browsers/editors. (Netscape and Microsoft already are supporting XML in the latest versions of their Web browsers, for example.) One leading method for rendering is via XSL, in which one specifies a stylesheet.</p><p>XML is a meta-language used to define other domainor industry-specific languages. To construct a XML language (also called a "vocabulary"), one supplies a specific Document Type Definition (DTD), which is essentially a context-free grammar like the Extended BNF (Backus Naur Form) used to describe computer languages. In other words, a DTD provides the rules that define the elements and structure of the new language. For example, if we want to describe employee records, we would define a DTD which states that the NAME element consists of three other elements called FIRST , MIDDLE , and LAST , in that order. The DTD would also indicate if any of the nested elements is optional, can be repeated, and/or has a default value. Any browser (or application) having an XML parser could interpret the employee document instance by "learning" the rules defined by the DTD.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Review of ACL</head><p>The core semantics of an ACL is defined as the "deep" semantics (i.e., semantics in the sense of declarative knowledge-representation) of its (communication) primitives. This semantics are expressed in some knowledge representation language: SL in the case of FIPA ACL. This semantics only takes into account the speaker, the hearer (in speech act terminology) and the content of the communicative act. The speaker, the hearer and the content correspond to the :sender, the :receiver and the :content of the syntactic representation of the ACL. The previous canonical syntactic form of the ACL message (for both KQML and FIPA ACL) is a Lisp-like ASCII sequence.</p><p>The (previous) canonical ACL message syntax (both in FIPA ACL and KQML) further includes additional message parameters whose semantics go beyond that of the primitives. These parameters are unaccounted for in the deep semantics but are essential to the processing of an ACL message. In other words, the ACL includes several "pragmatic" (i.e., operational) aspects, in addition to the primitives aspect. One pragmatic aspect is parsing in and out of the ACL, i.e., digesting and composing wellformed ACL syntax (which is Lisp-like) to extract or insert message parameters. A second pragmatic aspect is queueing (and de-queueing) ACL messages for delivery through TCP or some other network protocol.</p><p>Further pragmatic issues being dealt with in the context of ACL efforts include the agent naming scheme, and the conventions for finding agents and initiating interaction; although, in our view, these issues are actually outside of the ACL's scope. Actually, the various APIs for KQML and FIPA ACL provide nothing (as expected) regarding the actual processing of ACL messages (depending on the primitive), since the respecting the deep semantics of the primitives is the responsibility of the application that makes use of those API's. Such API's today mainly take care of the parsing and queueing tasks mentioned above. Performing these tasks is what using KQML (or FIPA ACL, for that matter) has come to mean. For all intents and purposes, compliance with the ACL's specification means compliance with all these pragmatic conventions. Such conventions are not part of the standard (to the extent that the ACL semantics is standardized) and the subtle (or not so subtle) discrepancies amongst their implementations account in large part for the situation today in which there is often a lack of interoperability between systems using the same ACL. <ref type="foot" target="#foot_2">3</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Introducing ACML</head><p>Next, we give an alpha-version specification of FIPA ACL in XML, which we call Agent Communication Markup Language (ACML). To begin with, we need to define a DTD for ACML <ref type="foot" target="#foot_3">4</ref> . We have indeed defined an alphaversion DTD for ACML, and have a running prototype implementation of ACML that uses this DTD. We begin with an example of a XML encoding of a FIPA ACL message. Figure <ref type="figure" target="#fig_1">1</ref> shows an example FIPA ACL message, in the previous (ASCII, Lisp-like) syntax. Figure <ref type="figure" target="#fig_2">2</ref> shows the same FIPA ACL message encoded in XML, i.e., in ACML. The content is a KIF expression which is not encoded in XML in this example. The DTD for ACML is shown in Figure <ref type="figure">3</ref>. This is an alpha version.</p><p>The deep semantics of the communication primitives in ACML is simply taken to be the same as previously. This semantics is not affected by encoding in XML instead of the previous ASCII; it is defined independently of the choice of syntactic encoding.</p><p>By XML-ifying the syntactic representation we enhance (i.e., extend) the (previous) canonical (pure ASCII) syntactic representation by introducing markup for parsing (the "tags", in XML terminology). This markup significantly facilitates the development effort needed for parsing in and out.</p><p>The XML representation also facilitates introducing pragmatic/operational elements that go beyond what the pure ASCII previous syntax did: notably, via links (in a similar sense as does HTML compared to ASCII). And we indeed introduced such extras in our alpha DTD and example. For example, the ACL message of Figure <ref type="figure" target="#fig_1">1</ref> includes information beyond what is equivalent to that in Figure <ref type="figure" target="#fig_2">2</ref>. Here, the receiver is not just some symbolic name but is also a URL that points to a particular network location which could provide additional information about the receiver agent's identity (e.g., how to contact its owner, its network ports, etc.).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Advantages of XML Approach</head><p>Encoding ACL messages in XML offers some advantages that we believe are potentially quite significant.</p><p>The XML-encoding is easier to develop parsers for than the Lisp-like encoding. The XML markup provides parsing information more directly. One can use the off-the-shelf tools for parsing XML -of which there are several competent, easy-to-use ones already available -instead of writing customized parsers to parse the ACL messages. A change or an enhancement of the ACL syntax does not have to result to a re-writing of the parser. As long as such changes are reflected in the ACL DTD, the XML parser will still be able to handle the XML-encoded ACL message. In short, a significant advantage is that the process of developing or maintaining a parser is much simplified.</p><p>Indeed, we have first-hand experience that this parsing advantage is significant. In our own implementation efforts, we have developed parsers for FIPA ACL and for content languages (both KIF and logic programs), both for ASCII encoding and for XML encoding.</p><p>More generally, XML-ifying makes ACL more "WWW-friendly", which facilitates Software Engineering of agents. Agent development ought to take advantage and build on what the WWW has to offer as a software development environment. XML parsing technology is only one example. Using XML will facilitate the practical integration with a variety of Web technologies. For example, an issue that has been raised in the ACL community <ref type="foot" target="#foot_4">5</ref> is that of addressing security issues, e.g. authentication of agents' identities and encryption of ACL messages, at the ACL layer. The WWW solution is to use certificates and SSL. Using the same approach for agent security considerations seems much simpler and more intuitive than further overloading ACL messages and the ACL infrastructure to accommodate such a task.</p><p>As we mentioned earlier, the operational semantics of the pragmatic aspects of ACL can differ subtly between implementations or usages, and there is today a problem practically of interoperability. XML can help with these pragmatics, by riding on standard WWW-world technologies: to facilitate the engineering, and as a by-product to help standardize the operational semantics, thereby helping make interoperability really happen.</p><p>More generally, links may be useful for a variety of other purposes. For example, the receiver parameter might have a link to network location that provides information about the agent's identity: e.g., its owner, contact and administrative information, communication primitives that the agent understands, network protocols and ports at which it can receive messages, conversation protocols it understands, etc.. This type of information is necessary for a establishing an extended interaction with another agent and has to somehow be available to an agent's potential interlocutors. The same argument can be made about the other message parameters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">ACL Content Languages, e.g., for</head><p>Business Rules</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Layered Approach of Knowledge Sharing Effort</head><p>Our and many other current efforts in inter-agent communication approaches are influenced by the pioneering approach of the Knowledge Sharing Effort <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b14">14]</ref> (KSE) <ref type="foot" target="#foot_5">6</ref>The KSE was initiated as a research effort circa 1990 with encouragement and relatively modest funding from U.S. government agencies (DARPA especially). The KSE was highly active for roughly five years thereafter, and enjoyed the participation of dozens of researchers from both academia and industry. Its goal was to develop techniques, methodologies and software tools for knowledge sharing and knowledge reuse between knowledge-based (software) systems, at design, implementation, or execution time. Agents, especially intelligent agents, are an important kind of such knowledge-based systems (other kinds include expert systems or databases, for example).</p><p>The central concept of the KSE was that knowledge sharing requires communication, which in turn, requires a common language; the KSE focused on defining that common language.</p><p>In the KSE model, agents (or, more generally, knowledge-based systems) are viewed as (virtual) knowledge bases that exchange propositions using a language that expresses various propositional attitudes. Propositional attitudes are three-part relationships between: (1) an agent, (2) a content-bearing proposition (e.g., "it is raining"), and (3) a finite set of propositional attitudes an agent might have with respect to the proposition (e.g., believing, asserting, fearing, wondering, hoping, etc.). For example, a; f ear; rainingt now .</p><p>The KSE model includes three layers of representation: (1) specifying propositional attitudes; (2) specifying propositions (i.e., "knowledge") -this is often called the (propositional) content layer; and (3) specifying the ontology <ref type="bibr" target="#b10">[10]</ref> (i.e., vocabulary) of those propositions. The KSE accordingly includes a component (with associated language) for each of these: Knowledge Query and Manipulation Language (KQML) for propositional attitudes, Knowledge Interchange Format (KIF) <ref type="bibr" target="#b3">[4]</ref> 7 for propositions, and Ontolingua <ref type="bibr" target="#b2">[3]</ref> (which had supporting software tools) for ontology.</p><p>Within the KSE approach, the three representational layers are viewed as mainly independent of another. In particular, the language for propositional content (i.e., the content language) can be chosen independently from the language for propositional attitudes. In other words, in the KSE approach, the role of an ACL such as FIPA's is only to capture propositional attitudes, regardless of how propositions are expressed, even though propositions are what agents will be "talking" about.</p><p>In a similar spirit, the approach of the technical committee that worked on FIPA ACL is that the content language should be viewed as orthogonal to the rest of the ACL message type.</p><p>The KSE focused especially on developing one general-purpose content language: KIF. However, the KSE also recognized that it is important to support multiple special-purpose content languages, since some are more expressive or more convenient for a particular purpose. Indeed, the KSE also included a fourth component effort (abbreviated "KRSS") devoted to defining a specialpurpose content language for "description logics" (a.k.a. "terminological logics", descended from KL-ONE).</p><p>We agree with the view that it is important to support multiple content languages. Beyond the KSE, a number of important specialized content languages have been developed which are particularly good at describing certain fields. For example, STEP (Standard for the Exchange of Product Model Data) <ref type="bibr" target="#b12">[12]</ref> is an ISO standards project working towards developing mechanisms for the repre-7 http://logic.stanford.edu/kif/ and http://www.cs.umbc.edu/kif/ sentation and exchange of a computerized model of a product in a neutral form. SGML is an example of a language, which is designed to describe the logical structure of a document. There are special languages for describing workflow, processes, chemical reactions, etc. SQL and OQL are somewhat more general content languages: for relational and object databases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Business Rules in E-Commerce as focus</head><p>Motivated by the importance of the content language aspect of agent communication, we focus in particular on rules as a form of content that is important in e-commerce applications such as bidding negotiations, i.e., "business rules". We are particularly interested in this kind of application, and have been developing techniques for it <ref type="bibr" target="#b15">[15]</ref> (to describe these is beyond the scope of this paper, however).</p><p>In bidding negotations, agents exchange requests for bids, (i.e., proposals), make proposals, make counterproposals, until agreeing or giving up. Rules are useful to represent the contents of these proposals and requests for proposals: e.g., to describe the products/services, prices, quantities, delivery dates, customer service agreements, contractual terms &amp; conditions, and other surrounding agreements that together constitute the content of a bid. Rules are also useful to represent relevant aspects of business processes, e.g., how to place an order, respond to an RFQ, return an item or cancel a delivery.</p><p>The usefulness of rules for the overall area of agent communication, particularly for such e-commerce applications is based largely on their following advantages relative to other software specification approaches and programming languages. First, rules are at a relatively high level of abstraction, closer to human understandability, especially by business domain experts who are typically non-programmers. Second, rules are relatively easy to modify dynamically and by non-programmers.</p><p>Rules provide an expressive yet automatically executable form for the substance of these specifications. Rules with deep declarative semantics <ref type="foot" target="#foot_6">8</ref> are valuable because they help enable business rules to be specified dynamically, i.e., at run-time, and relatively easily by business domain experts who are non-programmers.</p><p>There are a number of different rule representations in wide deployment today.</p><p>A major challenge in communicating content between e-commerce agents is thus the heterogeneity of rule representations (within agents/applications) to be integrated, e.g., during negotation. In translating content via a common rule representation, deep semantics (in the sense of declarative KR) is desirable. However, one can only hope to obtain deep semantics for expressive cores, i.e., for the expressive cases that overlap between the source and target rule KR's. Beyond the cores, translation must be performed with superficial semantics.</p><p>To begin with, we are focusing on three broad families of rule representations that are currently commercially important for business rules in e-commerce. These are both executable and practically important in the software world at large. One family is logic programs (LP's): including, but not limited to, Prolog. Logic programs have a general, declarative sense; they can be forwardchaining as well as backward-chaining, and need not be a general-purpose programming language in the manner of Prolog. Baral &amp; Gelfond <ref type="bibr" target="#b0">[1]</ref> gives a useful review of declarative logic programs as a KR. Another family is production rules: descendants of OPS5 <ref type="bibr" target="#b1">[2]</ref>, e.g., the public domain system Jess 9 . A third (relatively loose) family is Event-Condition-Action (ECA) rules. Both logic programs and ECA rules are important in commercial databases <ref type="bibr" target="#b17">[17]</ref> [16] and related standards (including SQL). Rules in these three families are to be found, for example, in object-oriented applications and worfklows, as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">KIF and its Shortcomings for Business Rules Content</head><p>A leading candidate content language for rules is KIF. KIF is currently well along in the ANSI standards committee process. Supporting or endorsing KIF is also being considered informally in several other standards efforts relevant to agent communication, e.g., FIPA. KIF has pioneered the concept of a KR content language for agent communication. That said, there are some important differences between (1) the goals of the KIF effort and (2) our goals for a business rules content language (for practical e-commerce agents' communication). The KIF effort's goals were initially to facilitate exchange among research systems rather than commercial systems. Also, it aimed to help at least somewhat with exchange of many forms of knowledge beyond just rules. It was designed with an orientation towards knowledge as a nonexecutable specification as much or more than towards knowledge as executable. Finally, the KIF effort has focused more on a highly inclusively expressive representation than on ease of developing translators in and out of that representation.</p><p>KIF is a prefix 10 version of first-order predicate cal-9 http://herzberg.ca.sandia.gov/jess/ . Jess is written in Java and is an update of CLIPS (http://www.ghg.net/clips/CLIPS.html). 10 The current draft ANSI specification of KIF (http://logic.stanford.edu/kif/dpans.html) also includes an infix version of KIF intended for human consumption rather than automated culus (i.e., first-order classical logic) with extensions to support the "quote" operator (thus enabling additional expressiveness akin to that of classical higher-order logic) and definitions. The language description includes a specification not only for its syntax but also for its semantics. Its deep semantics is based on classical logic, which is logically monotonic. Its primary focus (in terms of deep semantics) is on first-order logic, which is highly expressive and computationally intractable for the general case (as well as logically monotonic). KIF can express a broad class of rules. However, it has several important shortcomings as a content language for business rules in e-commerce. In particular, it has two shortcomings of its fundamental knowledge representation.</p><p>(1) KIF is a logically monotonic KR. KIF cannot conveniently express rules that are logically non-monotonic, e.g., rules that employ negation-as-failure or default rules. Thus it cannot conveniently express conflict handling, e.g., where some rules are subject to override by higher-priority conflicting rules, e.g., by specialcase exceptions, by more-recent updates, or by higherauthority sources. Most commercially important rule systems employ non-monotonic reasoning as an essential, highly-used feature. Typically, they employ some form of negation-as-failure. Often they employ some form of prioritized override between rules, e.g., the static rule sequence in Prolog or the computed rule-activation sequence/"agenda" in OPS5-heritage production rule systems.</p><p>Early in the KIF effort, incorporating logical nonmonotonicity was considered seriously. However, no technical agreement could be reached on an approach, largely because of its ambitions for great expressive generality in the direction of full classical logic. The current ANSI draft proposal of KIF is logically monotonic.</p><p>(2) KIF is a pure-belief KR. KIF cannot conveniently express "procedural attachments": the association of procedure calls (e.g., a call to a Java method Procure-mentAuthorization.setApprovalLevel) with belief expressions (e.g., a logical predicate such as approvalAuthoriza-tionLevel). Procedural attachments are crucial in order for rules to have actual effect beyond pure-belief inferencing, i.e., for actions to be invoked/performed as a result after rule conclusions are inferred. While procedures can of course be invoked by an application based on KIF premises or conclusions, KIF provides no way to express this, and its semantics do not treat the connection to such invocations, i.e., to such procedural attachments. exchange.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">A Logic Program Based Business</head><p>Rule Content KR</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Overall Approach: Ordinary, Courteous, and Situated LP's</head><p>We identified two fundamental shortcomings of KIF as a KR for business rules content: logical non-monotonicity and procedural attachments. In this paper, we focus on selecting a business rules content KR to remedy the first shortcoming only. We select a business rules content KR to enable logical non-monotonicity, including two steps.</p><p>(1) Negation-as-failure, a basic form of non-monotonicity, is the first step. ( <ref type="formula">2</ref>) Prioritized override between conflicting rules (i.e., prioritized default rules and conflict handling) is the second step.</p><p>Our approach is to use ordinary Logic Programs to provide the first step. By Logic Program, we mean in the declarative sense, e.g., cf. <ref type="bibr" target="#b0">[1]</ref>  <ref type="foot" target="#foot_7">11</ref> . Inferencing for LP's can be run forward or backward, using a variety of control strategies and algorithms; Prolog, by contrast, does backward-only inferencing, using a particular control strategy. Ordinary LP's (OLP's) offer several other significant advantages beyond enabling nonmonotonicity, including: computational tractability, wide practical deployment, semantics shared with other practically important rule systems, relative algorithmic simplicity, yet considerable expressive power.</p><p>Our approach is then to use Courteous Logic Programs (CLP's), an expressive extension of ordinary Logic Programs, to provide the second step. Courteous Logic Programs <ref type="bibr" target="#b6">[6]</ref> [8] <ref type="bibr" target="#b7">[7]</ref> provide a computationally low-overhead, semantically-clean capability for prioritized handling of conflicts between rules. CLP's permit classical negation; syntactically they also permit optional rule labels which are used as handles for specifying prioritization.</p><p>In current work, we are also enabling procedural attachments as well -in a semantically clean manner (i.e., declaratively in a particular well-defined sense). Our approach to enabling procedural attachments is based on Situated Logic Programs, another expressive extension of ordinary logic programs. Situated Logic Programs <ref type="bibr" target="#b4">[5]</ref> [9] hook beliefs to drive procedural API's. Procedural attachments for testing conditions (sensing) and performing actions (effecting) are specified as part of the knowledge representation: via sensor and effector link statements. Each sensor or effector link associates a predicate with an attached procedure. <ref type="foot" target="#foot_8">12</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Ordinary LP's: Core &amp; Advantages</head><p>Our point of departure for the business rules content KR is pure-belief ordinary LP's. "Pure-belief" here means without procedural attachments.</p><p>OLP's include negation-as-failure and thus support basic non-monotonicity. Yet they are relatively simple, and are not overkill representationally. OLP's are also relatively fast computationally. Under commonly-met restrictions (e.g., no logical functions of non-zero arity, a bounded number of logical variables per rule), inferencing (i.e., rule-set execution) in LP's can be computed in (worst-case) polynomial-time. By contrast, under similar restrictions, first-order-logic (cf. KIF) inferencing is (co-)NP-hard.</p><p>To obtain deep semantics that is/will-be shared widely among heterogeneous rule systems, however, the core must be an expressively restricted case of OLP's. Our alpha-version choice of this expressive restricion is: "predicate-acyclic" (pure-belief) OLP's -below, we discuss this in more detail. This core has a deep semantics that is useful, well-understood theoretically and highly declarative. Moreover, this semantics reflects a consensus in the rules representation community beyond just the LP community: this semantics is widely shared among all three of the rule system families we mentioned in subsection 3.2.</p><p>This core is also relatively computationally efficient, in the sense we described above.</p><p>The unrestricted case of declarative OLP's, with unrestricted recursion/cyclicity (in a sense explained below) interacting with negation-as-failure, has problems semantically, is more complex computationally and, perhaps even more importantly, is more difficult in terms of software engineering. It requires more complicated algorithms and is not widely deployed.</p><p>OLP's have been widely deployed practically, in contrast to full first-order-logic which has not been. Moreover, there is a large population of software developers who are familiar with Prolog and OLP's, in contrast to general first-order-logic theorem-proving for which there is not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Ordinary LP's: Semantics &amp; Recursion</head><p>Ordinary LP's have been well-studied, and have a large literature (reviewed, for example, in <ref type="bibr" target="#b0">[1]</ref>). For several broad but restricted expressive cases, their (declarative) semantics is uncontroversial. <ref type="foot" target="#foot_9">13</ref> However, OLP's have problematic semantics for the unrestricted case, due essentially to the interaction of recursion with negation-as-failure. "Recursion" here means that there is a cyclic (path of syntactic) dependency among the predicates (or, more generally, among the ground atoms) through rules. <ref type="foot" target="#foot_10">14</ref>There is a lack of consensus in the research community about which semantics to adopt for the fully general case of OLP's: e.g., well-founded semantics versus stable semantics, etc.; these semantics coincide for the uncontroversial restricted cases but diverge beyond that. Under the well-founded semantics, probably the currently most popular semantics, the unrestricted case is tractable.</p><p>Our approach for an initial practically-oriented LPbased business rules content KR is to keep to expressively restricted cases that have uncontroversial (i.e., consensus) semantics; these have other virtues as well: e.g., they are algorithmically and computationally simpler. More precisely, our approach is to define/expect deep semantics (including for translation between agents) only for these restricted cases.</p><p>Our starting choice for such an expressive restriction is: predicate-acyclic, i.e., where there are no cycles of (syntactic) dependency among predicates. This expressive restriction can be checked syntactically with a relatively simple algorithm and with relatively low computational cost. Inferencing for the predicate-acyclic case is also simpler algorithmically and computationally than for the expressively unrestricted case.</p><p>In our XML embodiment (next section) of the LP-based content language, we define an alpha-version DTD that is syntactically inclusive: it permits unrestricted OLP's. It is thus useful there to have an optional tag to indicate which semantical variant of LP's is intended: the DTD accordingly defines an optional "documentation" link which can be used to specify the intended semantics (e.g., wellfounded versus stable). For the alpha-version, our approach is to choose the well-founded semantics to be the default semantics for the expressively unrestricted case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Courteous Logic Programs</head><p>Courteous LP's expressively generalize OLP's by adding the capability to conveniently express prioritized conflict handling, i.e., where some rules are subject to override by higher-priority conflicting rules. For example, some rules may be overridden by other rules that are special-case exceptions, more-recent updates, or from higher-authority sources. Courteous LP's facilitate specifying sets of rules by merging and updating and accumulation, in a style closer (than ordinary LP's) to natural language descriptions.</p><p>Courteous LP's also expressively generalize ordinary LP's permit classical-negation to appear in head (i.e., consequent) or body (i.e., antecedent) literals (negationas-failure must appear outside, not inside, the scope of classical-negation). They also permit rules to have optional labels, which are used as handles for specifying priorities. A syntactically-reserved (but otherwise ordinary) predicate overrides is used to specify prioritization. Priorities are represented via a fact comparing rule labels: overridesl a b 1; l a b 2 means semantically that a rule having label l a b 1 has higher priority than another rule having label l a b 2. If two such rules conflict, then the rule with the higher priority will win the conflict; the lower priority rule's head will not be concluded.</p><p>The prioritization specified is a partial ordering, rather than a total ordering. Classical negation is enforced: p and classical-negation-of-p are never both concluded, for any belief expression p.</p><p>In the alpha-version business rules content KR (BRML), the Courteous LP KR is also expressively restricted in two further regards cf. <ref type="bibr" target="#b6">[6]</ref>: (1) priority is specified via ground facts only, and (2) priority is specified to be a strict partial order. Elsewhere <ref type="bibr" target="#b7">[7]</ref>, we give an expressive generalized version of Courteous LP's that relaxes these restrictions and the predicate-acyclicity restriction. In current work, we are further expressively generalizing Courteous LP's <ref type="bibr" target="#b8">[8]</ref>.</p><p>Courteous LP's have several virtues semantically and computationally. A Courteous LP is guaranteed to have a consistent, as well as unique, set of conclusions. Priorities and merging behave in an intuitively natural fashion. Execution (inferencing) of courteous LP's is fast: only relatively low computational overhead is imposed by the conflict handling.</p><p>From a software engineering viewpoint as well, CLP's are a relatively straightforward extension of OLP's. A CLP can always be tractably compiled into a semantically equivalent OLP -indeed, we have implemented CLP's using such a "courteous compiler" <ref type="bibr" target="#b7">[7]</ref>  <ref type="bibr" target="#b8">[8]</ref>.</p><p>Detailed computational complexity analysis for courteous LP inferencing and the courteous compiler is given in <ref type="bibr" target="#b6">[6]</ref> and <ref type="bibr" target="#b7">[7]</ref>; next, we summarize that analysis. The complexity of courteous compilation is worst-case quadratic, both in time and in output size. Suppose the input LP, having size n, is either ground or Datalog (no logical functions of more than zero arity), and has an upper bound v on the number of logical variables appearing in any rule. As we mentioned earlier, the worst-case time complexity of inferencing in OLP's under these restrictions is tractable (i.e., polynomial). Courteous LP inferencing then has the same worst-case time and space complexity as: OLP inferencing where the bound v on the number of variables per rule has been increased to v + 1 .</p><p>There are several other formalisms for prioritized LP's that have similar syntax to Courteous LP's but different semantics in regard to conflict handling (see <ref type="bibr" target="#b6">[6]</ref> [7] for a review). A direction in our current work is to explore this dimension of heterogeneity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Relationship to KIF; Discussion</head><p>In this subsection, we discuss how the alpha-version business rules content KR, i.e., CLP cf. <ref type="bibr" target="#b6">[6]</ref> encoded in XML as BRML, relates to KIF. Syntactically, the alpha CLP adds two (optional) features to OLP: classical negation and rule labels. KIF permits classical negation but not negation-as-failure. Also KIF remarkably lacks rule labels (or rule names/id's), even though this is rather routine as a basic naming/scoping mechanism in rule specification systems and many programming languages. Syntactically, the alpha CLP thus adds two (optional) features to KIF: negationas-failure and rule labels.</p><p>Syntactically, OLP and first-order-logic/KIF overlap to a considerable degree: OLP without negation-asfailure is logically monotonic <ref type="foot" target="#foot_11">15</ref> . Syntactically and semantically, such monotonic OLP is simply Horn and is thus a restricted case of first-order logic/KIF. Semantically, OLP entailment/inferencing is sound but incomplete when compared to first-order-logic (FOL). The incompleteness can be described as: an OLP's entailed conclusions are equivalent to a set of ground atoms.</p><p>Syntactically, CLP and FOL/KIF overlap to an even more considerable degree: CLP without negation-asfailure is logically monotonic. Such monotonic CLP with its labels omitted or ignored is thus syntactically a restricted case of FOL/KIF. Semantically, a monotonic CLP may contain conflict; we say it is "classically consistent" or "conflict free" when it is consistent when viewed as FOL. Semantically, a consistent monotonic CLP is sound but incomplete when compared to FOL. The incompleteness is similar to that of OLP; it can be described as: a CLP's entailed conclusions are equivalent to a set of ground classical literals.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">XML Embodiment: Business Rules Markup Language</head><p>Just as we have defined an XML encoding for ACL messages in Section 2.3, we have defined an XML encoding for CLP rulesets. We refer to this language as Business Rules Markup Language (BRML). BRML inherits the deep semantics of CLP. Figure <ref type="figure" target="#fig_3">4</ref> gives an example of a single-rule CLP ruleset, in BRML. Figure <ref type="figure">5</ref> gives the (alpha) BRML DTD. The XML encoding extends the pure ASCII syntactic representation of CLP (not shown here for reasons of space and focus) with parsing information (and eventually with various optional links). The optional documentation attribute in the BRML DTD could point to a link which has information such as the semantical variant of the language.</p><p>In the draft DTD shown, we do not yet allow a predicate (or another token such as a logical constant or function, etc.) to have an associated link, because here we are focused on specifying the basic XML encoding of CLP. However, we plan to permit such links: e.g., the loy-alCustomer predicate, for example, could then point to a URL containing a document that provides an account in natural language of what the particular company considers a loyal customer. Or, in the case of the example of Figure <ref type="figure" target="#fig_2">2</ref>, the particular laptop for sale could include a linked picture and a URL with the full natural-language description of the laptop's technical specification.</p><p>The advantages of an XML encoding for business rules content are similar to those for ACL that we discussed in Section 2. As compared to plain ASCII text, XML is easier to automatically parse, generate, edit, and translate: because there are standard XML-world tools for these tasks. The hyper-text (i.e., links) aspects of XML are also useful. For example, a rule set may via XML have some associated URL's which point to documents describing that rule set's knowledge representation or authors or application context. Or it may have associated URL's which point to tools for processing that rule set, e.g., to execute it, edit it, analyze it, or validate it (syntactically or semantically). Particularly useful for our nearer-term purposes is that an associated URL may point to documents describing the semantics and algorithms for translator services or components, as well as to translator tools and examples. Representing business rules in XML has a further advantage: it will complement domain-specific ontologies (i.e., vocabularies) available in XML. Many such ontologies exist already, and many more are expected to be developed in the next few years, including in e-commerce domains.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Further discussion of our DTD</head><p>Actually, our BRML DTD permits a syntactic superset of our alpha expressive core, i.e. a superset of CLP cf. <ref type="bibr" target="#b6">[6]</ref>. Applications using the BRML need to perform additional "validation", i.e., checking of syntactic restrictions, beyond what is furnished by XML parsers that validate with respect to the DTD. However, such additional syntactic validation would be necessary even if the DTD was as "tight" as XML made possible; various other conditions such as predicate-acyclicity are impractically difficult (if not impossible) to capture in a DTD.</p><p>As a syntactic convenience, we permit the OR connective and nested sub-expressions to appear in the body, and we permit the AND connective to appear in the head. This does not change the essential expressiveness of OLP or CLP (see, e.g., <ref type="bibr" target="#b12">[12]</ref>) <ref type="foot" target="#foot_12">16</ref> .</p><p>It appears fairly straightforward to extend our DTD in stages so as to express full first-order logic and then full KIF. A direction for future work is to create a DTD, maximally compatibly with BRML, that expresses full KIF.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Implementation</head><p>We have a running prototype implementation of ACML, and of BRML and Courteous LP's as a Java library. Based on the DTD's we gave earlier, this includes encoding and parsing in/out in both XML and ASCII (including KIF for the content). It also includes translators to two other ASCII rule representations in the logic program family, used by previously existing OLP inferencing engines built by others and implemented in C. One is backward-direction: XSB, by David Warren et al, http://www.cs.sunysb.edu/sbprolog/ . The other is exhaustive forward-direction: Smodels (first version), by Ilkka Niemela and Patrik Simons, http://saturn.hut.fi/html/staff/ilkka.html . All the encoding, parsing, and translating preserves the deep semantics of the alpha core that we described in Section 5. The implementation further includes a courteous compiler, and a rule inferencing/execution engine.</p><p>The prototype implementation of BRML and Courteous LP's will made publicly available via the Web in spring 1999. An overview of it, with long example, is given in <ref type="bibr" target="#b8">[8]</ref>, and its courteous compiler algorithms are given in <ref type="bibr" target="#b7">[7]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Future Work: Summary</head><p>Future work includes extending this XML content language expressively in multiple directions. One such direction is to cover full KIF; another is to incorporate semantically-clean procedural attachments, cf. the existing Situated Logic Programs KR; a third is to expressively generalize the Courteous LP conflict handling aspects .    Let C 1 be a simple example CLP ruleset that contains the single rule giveDiscount(percent5 , ?Cust) &lt;-shopper(?Cust) and loyalCustomer(?Cust).</p><p>, shown here in ASCII encoding. This rule says to give a 5% discount to loyal customers. The CLP ruleset C 1 can be expressed in BRML as follows:</p><p>&lt;?xml version="1.0"?&gt; &lt;!DOCTYPE brml SYSTEM "brml.dtd"&gt; &lt;clp&gt; &lt;erule rulelabel="emptyLabel"&gt; &lt;head&gt; &lt;cliteral predicate="giveDiscount"&gt; &lt;function name="percent5"/&gt; &lt;variable name="?Cust"/&gt; &lt;/cliteral&gt; &lt;/head&gt; &lt;body&gt; &lt;and&gt; &lt;fcliteral predicate="shopper"&gt; &lt;variable name="?Cust"/&gt; &lt;/fcliteral&gt; &lt;fcliteral predicate="loyalCustomer"&gt; &lt;variable name="?Cust"/&gt; &lt;/fcliteral&gt; &lt;/and&gt; &lt;/body&gt; &lt;/erule&gt; &lt;/clp&gt; </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: A FIPA ACL message.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: An example of a FIPA ACL message encoded in XML, i.e., expressed in ACML. Notice that the XML encoding carries additional information as compared to the canonical ASCII encoding: in particular, links (as well as parsing information).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: An example of a single-rule CLP ruleset expressed in BRML.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>http://www.fipa.org</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>We do not deal with the first issue in this paper. See<ref type="bibr" target="#b11">[11]</ref> for such a discussion.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>The differences in sets of primitives used and their intended meaning constitute a second-in-order interoperability barrier that is not confronted due to these more mundane "lower-level"</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>obstacles.<ref type="bibr" target="#b3">4</ref> The same will be done for the content language (see Section 6).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>Private communication at FIPA meetingsBecause XML incorporates links into the ACL message, this takes a significant step toward addressing the problem (or representational layer) of specifying and sharing the ontologies used in an ACL message's content. The values of the ACL parameters are not tokens anymore, but links that can point to objects and/or definitions. Although the ontology slot has been present since the inception of ACLs, the ACL community has not been very clear on how this information is to be used by the agent. This vagueness, further compounded by the scarcity of published ontologies, can be addressed by "interfacing" the ACL message to the knowledge repository that is the WWW.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>http://www.cs.umbc.edu/kse/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_6"><p>in the sense of declarative knowledge representation, in which a set of premises entails a set of conclusions, independent of the inferencing procedure, e.g., whether it is forward or backward direction, what its control strategy is, etc..</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_7"><p>They call an ordinary LP: a "general" LP. This is also known in the literature as a "normal" LP, and also sometimes as (declarative) pure Prolog.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_8"><p>Note that "link" here does not mean in the sense of an XML or HTML hypertext link.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="13" xml:id="foot_9"><p>e.g., for the predicate-acyclic, stratified, locally stratified, and weakly stratified cases; these form a series of increasing expressive generality</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="14" xml:id="foot_10"><p>In each rule, the predicate(s) appearing in the consequent/head of the rule has a directed dependency arc to each of the predicates appearing in the antecedent/body of the rule. Accumulating such dependency arcs for a whole rule set, and taking their transitively closed paths, defines which predicates are dependent on which others for a given LP.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="15" xml:id="foot_11"><p>when one interprets lack of membership in the minimal/least model of the OLP as corresponding to classical non-entailment rather than to classical falsity</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="16" xml:id="foot_12"><p>though in the worst-case depending on inferencing engine implementation this may cost exponential time/space caused by converting to the representation without OR's</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>Hoi Y. Chan (IBM T.J. Watson Research Center), Michael Travers (IBM T.J. Watson Research Center), and Xiaocheng Luan (of UMBC, while at IBM T.J. Watson Research Center), contributed to the current implementation of the CLP KR, BRML, and the associated translators. Michael Travers' contribution was especially to the XML embodiment, and uses a tool he wrote, called Skij, which implements the Scheme programming language in Java. Hoi Y. Chan and Miao Jin (UMBC) contributed to the XML DTD's. Tim Finin at UMBC contributed to the formulation of our ideas for the XML embodiment of the FIPA ACL, which he first presented at the FIPA meeting in Dublin, in July 1998.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Logic programming and knowledge representation</title>
		<author>
			<persName><forename type="first">Chitta</forename><surname>Baral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Gelfond</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic Programming</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="73" to="148" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
	<note>Includes extensive review of literature</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Rule-based Programming with OPS5</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nancy</forename><surname>Wogrin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>Morgan Kaufmann Publishers</publisher>
			<pubPlace>San Francisco, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The ontolingua server: A tool for collaborative ontology construction</title>
		<author>
			<persName><forename type="first">Adam</forename><surname>Farquhar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Fikes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Rice</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KAW96</title>
		<imprint>
			<date type="published" when="1996-11">November 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Knowledge interchange format, version 3.0 reference manual</title>
		<author>
			<persName><forename type="first">M</forename><surname>Genesereth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fikes</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
		<respStmt>
			<orgName>Computer Science Department, Stanford University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Building Commercial Agents: An IBM Research Perspective (Invited Talk)</title>
		<author>
			<persName><forename type="first">N</forename><surname>Benjamin</surname></persName>
		</author>
		<author>
			<persName><surname>Grosof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second International Conference and Exhibition on Practical Applications of Intelligent Agents and Multi-Agent Technology</title>
		<meeting>the Second International Conference and Exhibition on Practical Applications of Intelligent Agents and Multi-Agent Technology<address><addrLine>Blackpool, Lancashire, FY2</addrLine></address></meeting>
		<imprint>
			<biblScope unit="volume">137</biblScope>
		</imprint>
	</monogr>
	<note>PAAM97</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Practical Application Company Ltd</title>
		<author>
			<persName><forename type="first">U</forename><forename type="middle">K</forename><surname>Un</surname></persName>
		</author>
		<ptr target="http://www.research.ibm.com" />
	</analytic>
	<monogr>
		<title level="m">Held London, UK. Also available as IBM Research Report RC 20835 at World Wide Web</title>
		<imprint>
			<date type="published" when="1997-04">April 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Prioritized Conflict Handling for Logic Programs</title>
		<author>
			<persName><forename type="first">N</forename><surname>Benjamin</surname></persName>
		</author>
		<author>
			<persName><surname>Grosof</surname></persName>
		</author>
		<ptr target="http://www.research.ibm.com" />
	</analytic>
	<monogr>
		<title level="m">Logic Programming: Proceedings of the International Symposium (ILPS-97)</title>
		<editor>
			<persName><forename type="first">Jan</forename><surname>Maluszynski</surname></persName>
		</editor>
		<meeting><address><addrLine>Cambridge, MA, USA; Held Port Jefferson, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1997-10-12">1997. Oct. 12-17, 1997</date>
			<biblScope unit="page" from="197" to="211" />
		</imprint>
	</monogr>
	<note>Extended version available as IBM Research Report RC 20836 at</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Compiling Prioritized Default Rules Into Ordinary Logic Programs</title>
		<author>
			<persName><forename type="first">N</forename><surname>Benjamin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">;</forename><surname>Grosof</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Ibm</surname></persName>
		</author>
		<author>
			<persName><surname>Watson Research</surname></persName>
		</author>
		<author>
			<persName><surname>Center</surname></persName>
		</author>
		<idno>RC 21472</idno>
		<ptr target="http://www.research.ibm.com" />
		<imprint>
			<date type="published" when="1999-05">May 1999</date>
			<biblScope unit="volume">704</biblScope>
			<pubPlace>Yorktown Heights, NY 10598, USA</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">IBM Research Report</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">DIPLOMAT: Compiling Prioritized Default Rules Into Ordinary Logic Programs, for E-Commerce Applications (extended abstract of Intelligent Systems Demonstration)</title>
		<author>
			<persName><forename type="first">N</forename><surname>Benjamin</surname></persName>
		</author>
		<author>
			<persName><surname>Grosof</surname></persName>
		</author>
		<ptr target="http://www.research.ibm.com" />
	</analytic>
	<monogr>
		<title level="m">Extended version available in May 1999 as an IBM Research Report RC21473</title>
		<meeting><address><addrLine>San Francisco, CA, USA; Yorktown Heights, NY 10598, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">704</biblScope>
		</imprint>
	</monogr>
	<note>Proceedings of AAAI-99</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Reusable Architecture for Embedding Rule-Based Intelligence in Information Agents</title>
		<author>
			<persName><forename type="first">Benjamin</forename><forename type="middle">N</forename><surname>Grosof</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">W</forename><surname>Levine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hoi</forename><forename type="middle">Y</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Colin</forename><forename type="middle">P</forename><surname>Parris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joshua</forename><forename type="middle">S</forename><surname>Auerbach</surname></persName>
		</author>
		<ptr target="http://www.research.ibm.com" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Conference on Information and Knowledge Management (CIKM-95) Workshop on Intelligent Information Agents</title>
		<meeting>the ACM Conference on Information and Knowledge Management (CIKM-95) Workshop on Intelligent Information Agents<address><addrLine>Baltimore, MD</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995-12">December 1995</date>
		</imprint>
	</monogr>
	<note>Published via the World Wide Web. Paper also available as IBM Research Report RC 20305</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A translation approach to portable ontology specifications</title>
		<author>
			<persName><forename type="first">R</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><surname>Gruber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Knowledge Acquisition</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="199" to="220" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Agent communication languages: the current landscape</title>
		<author>
			<persName><forename type="first">Yannis</forename><surname>Labrou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tim</forename><surname>Finin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yun</forename><surname>Peng</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999-05">May 1999</date>
			<publisher>IEEE Intelligent Systems</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Lloyd</surname></persName>
		</author>
		<title level="m">Foundations of Logic Programming</title>
		<meeting><address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
	<note>second edition</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Enabling technology for knowledge sharing</title>
		<author>
			<persName><forename type="first">R</forename><surname>Neches</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fikes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Finin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Gruber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Senator</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Swartout</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AI Magazine</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="36" to="56" />
			<date type="published" when="1991">1991</date>
			<publisher>Fall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The darpa knowledge sharing effort: Progress report</title>
		<author>
			<persName><forename type="first">Ramesh</forename><forename type="middle">S</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><forename type="middle">E</forename><surname>Fikes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Don</forename><surname>Patel-Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tim</forename><surname>Mckay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Finin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Gruber</surname></persName>
		</author>
		<author>
			<persName><surname>Neches</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Readings in Agents</title>
		<editor>
			<persName><forename type="first">Michael</forename><surname>Huhns</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Munindar</forename><surname>Singh</surname></persName>
		</editor>
		<imprint>
			<publisher>Morgan Kaufmann Publishers</publisher>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
	<note>reprint of KR-92 paper</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Toward a Declarative Language for Negotiating Executable Contracts</title>
		<author>
			<persName><forename type="first">M</forename><surname>Daniel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><forename type="middle">N</forename><surname>Reeves</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Grosof</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hoi</forename><forename type="middle">Y</forename><surname>Wellman</surname></persName>
		</author>
		<author>
			<persName><surname>Chan</surname></persName>
		</author>
		<ptr target="http://www.ibm.com/iac/" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the AAAI-99 Workshop on Artificial Intelligence in Electronic Commerce (AIEC-99)</title>
		<meeting>the AAAI-99 Workshop on Artificial Intelligence in Electronic Commerce (AIEC-99)<address><addrLine>Menlo Park, CA, USA; Yorktown Heights, NY 10598, USA</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">704</biblScope>
		</imprint>
		<respStmt>
			<orgName>IBM Institute for Advanced Commerce Workshop on Internet Negotation Technologies</orgName>
		</respStmt>
	</monogr>
	<note>Also available in May 1999 as IBM Research Report RC 21476</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Principles of Database and Knowledge-Base Systems</title>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Science Press</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<date type="published" when="1988">1988</date>
			<pubPlace>Rockville, Maryland</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">A First Course in Database Systems</title>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jennifer</forename><surname>Widom</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Verifiable semantics for agent communication languages</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Wooldridge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Multi-Agent Systems (ICMAS&apos;98)</title>
		<meeting><address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">&lt;?xml</forename><surname>Version=</surname></persName>
		</author>
		<idno>pre-1.0&quot; encoding=&quot;US-ASCII</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">accept-proposal | agree | cancel |cfp |confirm | disconfirm | failure | inform | inform-if | inform-ref | not-understood | propose | query-if | query-ref | refuse | reject-proposal | request | request-when | request-whenever | subscribe</title>
		<author>
			<persName><forename type="first">&lt;!entity %</forename><surname>Messagetp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">&lt;!ELEMENT message (messagetype, messageparameter* )&gt; &lt;!ELEMENT messagetype</title>
		<imprint/>
	</monogr>
	<note>%messagetp</note>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">ELEMENT messageparameter (sender | receiver | content | reply-with | reply-by| in-reply-to | envelope | language | ontology | protocol | conversation-id)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">&gt;</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m">&gt; Figure 3: A DTD for ACML. The DTD is in draft form. &lt;?xml version=&quot;1.0&quot; encoding=&quot;US-ASCII&quot;?&gt; &lt;!ENTITY % bool &quot;yes|no&quot;&gt; &lt;!ELEMENT clp</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName><forename type="first">&lt;!</forename><surname>Attlist</surname></persName>
		</author>
		<title level="m">documentation link CDATA #IMPLIED&gt; &lt;!ELEMENT erule (head, body?)&gt; &lt;!ATTLIST erule rulelabel CDATA #IMPLIED&gt; &lt;!ELEMENT mutex</title>
		<imprint/>
	</monogr>
	<note>cliteral, cliteral</note>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">&lt;!</forename><surname>Element</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m">&lt;!ELEMENT body (fcliteral | and | or</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">&lt;!element</forename><surname>Cliteral</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">&gt;</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">&lt;!element</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">&gt; &lt;!element</forename><surname>Or</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m">&gt; &lt;!ELEMENT function</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">&gt;</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">ELEMENT string EMPTY&gt; &lt;!ATTLIST string value CDATA #REQUIRED&gt; Figure 5: A DTD for BRML</title>
		<imprint/>
	</monogr>
	<note>The DTD is in draft form</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
