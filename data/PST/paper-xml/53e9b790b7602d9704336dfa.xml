<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Adaptive Design of Petri Net Controllers for Error Recovery in Automated Manufacturing Systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical, Computer, and Systems Engineering</orgName>
								<orgName type="institution">Rensselaer Polytechnic Institute</orgName>
								<address>
									<postCode>12180-3590</postCode>
									<settlement>Troy</settlement>
									<region>NY</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Adaptive Design of Petri Net Controllers for Error Recovery in Automated Manufacturing Systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">EDA28FA6C25787E598AE80026F0814C7</idno>
					<note type="submission">received November 25, 1988; revised March 3, 1989.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:04+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The concept of Petri net controllers is extended to include automatic error recovery and adaptive design. The Petri net controller provides control of an automated manufacturing system and the execution of error recovery. In our Petri net controller, a place that represents an operation or a state of a machine is attached to two functions and a constant so that it can represent a system working with both normal states and abnormal states. In addition it is possible to detect an error with the controller using watchdog timers. Four basic Petri net augmentation methods for error recovery are investigated: input conditioning, alternate path, feedback error recovery, and forward error recovery. We demonstrate that when these methods are used to augment the Petri net controller, some important properties of the controller are guaranteed to be preserved. This is shown by developing and proving four theorems. These properties include boundedness or safeness, liveness, reversibility, and the essentially decision-free property. An example of augmentations for error recovery for a piston insertion cell with two robots is given.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>HIS RESEARCH is motivated by the desire to im-T prove control coding for error handling in automated systems. In implemented automated manufacturing workstations or cells, an inordinate amount, up to 90 percent <ref type="bibr">[7]</ref>, <ref type="bibr">[8]</ref>, of the control coding effort is dedicated to exception handling or automatic error recovery. At present most of this coding effort occurs at the design stage. Engmeers attempt to anticipate common errors and write the control code to handle them and to allow the system to recover automatically, if feasible. Two undesirable outcomes are possible. First, in an effort to be thorough, routines are coded to handle errors that in fact do not occur during the lifetime of the program. Second, errors that have not been anticipated will inevitably occur when running the system and the code may have to be "patched" to handle future occurrences of the same errors. Changng the code after the design phase presents many potential software maintenance problems not the least of which is the possibility of the introduction of coding errors. The research presented here allows for augmenting, i.e., patching, the control code while minimizing the possibility of introducing new errors. This will provide for a coding strategy where only the most common errors are accounted for at the system design stage and the remainder are treated as they occur while the system is running. Many errors will occur during the initial system burn-in and can be treated at that time. This may alleviate the first undesirable property.</p><p>The methodology presented here assumes that the given control code has been specified as a Petri net. When the control code is specified in this way we call it a Petri net controller because the Petri net representation can be compiled and downloaded into a programmable logic controller (PLC) or a control processor. This paper presents a methodology that allows the augmentation of control code for error recovery whde preserving certain properties of the logic to avoid deadlock, buffer overflow and other characteristics discussed later in the paper. If the changes in the code are made as prescribed here, then the properties are guaranteed without further analysis. As later details will show, the magnitude of the analysis effort is such that it is worth avoiding, particularly for complex systems.</p><p>Thus the goal of t h s paper is to show how we can augment an existing Petri net for the purpose of error recovery and still preserve the desirable properties guaranteed in its initial design. Our objectives are as follows:</p><p>to propose the concept of a Petri net controller for automatic error recovery and investigate its design in the context of automated manufacturing; to study four basic augmentation methods for different types of error recovery; to prove that certain properties of the controller are guaranteed when the four basic Petri net augmentation methods are applied; and to use a robot assembly cell as an example to demonstrate the proposed approach.</p><p>architecture for an intelligent automatic error recovery system is shown in Fig. <ref type="figure">7</ref>, where both a Petri net by changing the control flow of tokens in the Petri net during the operation of the system. The controller includes the use of sensory data and machine intelligence for error diagnosis and recovery planning. This paper focuses on the Petri net controller.</p><p>Manufacturing system control using Petri nets was studied by various researchers. In those papers, emphasis was placed on how to model and control the system under normal operations. Little effort has been made to apply Petri net theory to the problem of automatic error recovery. Sahraoui et al. studied the similarities between a Petri net and a knowledge-based system and proposed a method that combined Petri nets and artificial intelligence techniques for error detection and diagnosis <ref type="bibr">[4]</ref>. Their research emphasis was on the effective monitoring of a flexible manufacturing system. Some other machine intelligence approaches to automatic error recovery have been made [5]-[8]. A review of this is given by Fielding et al. <ref type="bibr">[9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">DESIGN OF PETRI NET CONTROLLERS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A . Background</head><p>In recent years, Petri net theory has proven to be very valuable in the modeling, analysis, and control of manufacturing systems where concurrence, synchronization, and cooperation among subsystems may exist [3], [13], [22],</p><p>[25], <ref type="bibr">[28]</ref>. These types of manufacturing systems fall in the general class known as asynchronous discrete event dynamic systems. In particular, there are at least four major advantages in using Petri nets for designing manufacturing controllers:</p><p>1) the ease of modeling because of the relatively straightforward graphcal representation</p><formula xml:id="formula_0">[1]-[3],</formula><p>2) the ability to check the system for undesirable properties such as deadlock and boundedness [l8], I251 with available mathematical analysis tools (later in the paper these properties will be defined, and their relationship to manufacturing systems discussed); the ability to do system performance analysis with increasingly available software [ 281 -[ 301; the ability to generate supervisory control code directly from the Petri net definition [2], [3], <ref type="bibr">[lo]</ref>.</p><p>The token player in Petri nets is well adapted to executing the normal functions of a system <ref type="bibr">[lo]</ref>. Therefore our idea is to attach some information to places and/or transitions in a Petri net so that abnormal states of the system will be processed using a Petri net controller. When the [17l-t 191 ;</p><p>3)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4)</head><p>system works normally, the sequences represented in the original Petri net will be executed. Otherwise as an error occurs a special part of the Petri net will be started depending on the type of error that has occurred.</p><p>In our system there are two approaches to indicating the occurrence of an error. One is based on the information from the sensors of the manufacturing system. The other is to use watchdog timers in the Petri net controller. These indicate a possible error occurrence if a token stays in the place beyond a given time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Description of Petri Net Controllers</head><p>Our approach to constructing a Petri net model for a system is to use places rather than transitions to model system processes, as introduced by Sifakis [ l l ] and used by many researchers [l], [2], [ll], <ref type="bibr">[12]</ref>. The advantage is that it preserves the convention of transitions as instantaneous events, e.g., the start and completion of process execution. The presence of a token in a place indicates the activity of a process, e.g., pick or move, or a state of a device, e.g., the working state of a machine. This approach can easily lead to the stepwise refinement of a Petri net so that a hierarchcal Petri net controller is easily obtained <ref type="bibr">[17]</ref>.</p><p>For basic knowledge of Petri net theory the reader is referred to <ref type="bibr">[18], [19], [21]</ref>. We begin by describing a Petri net controller for normal operations, i.e., one unable to handle exceptions or errors, and then proceed to develop the theory for augmenting these nets to process errors.</p><p>A Petri net controller is defined as a control logic based on a marked Petri net for a discrete event dynamic system, or the rules of the flow of tokens in places by the firing of transitions in a marked Petri net. The Petri net is described as follows <ref type="bibr">[25]</ref>.</p><p>Assume a marked Petri net Z = ( P , T , I , 0, m ) modeled on the previous ideas, where 1) P = { p , , p 2 ; . ., p , , } , n &gt; 0, and is a finite set of places obtained by modeling a system when only normal functions are considered; T = { t,, t,; ., t , } , s &gt; 0, and is a finite set of transitions with P U T # 0 , P n T = 0 ; I : P x T-+ {0,1} and is an input function that defines the set of directed arcs from P to T ; 0: P X T -+ {0,1} and is an output function that defines the set of directed arcs from T to P ; m: P -, {0,1,2, . . . } and is a marking whose ith component represents the number of tokens in the i th place.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2)</head><p>3)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4)</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5)</head><p>The firing rules are</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1)</head><p>2) for i = 1,2; . . , n .</p><formula xml:id="formula_1">a</formula><p>The marking m is said to be reachable from m'. Given Z and its initial marking m,, the reachability set is the set of all markings reachable from m , with different sequences of transition firings and is denoted by R( Z , m,).</p><p>Z is bounded if and only if m( p ) d B for all m E R ( Z , m,). B is a positive integer. If B =1, Z is safe. The definition of boundedness means that the number of tokens marking a place at any time does not exceed a positive limit B. In a manufacturing environment, the boundedness or safeness of a Petri net indicates the absence of overflows in the modeled system. For example a buffer in a production facility will have a finite capacity, and its representation as a bounded place will guarantee that the resulting control code will not allow this capacity to be exceeded. Safeness means no more than one token will mark a place. This implies that there is no possibility to restart the ongoing process if the place represents the process. For instance, if a place represents a machine that can only process one part at a time, safeness would guarantee that no other parts are loaded until the current one is completed. If a place happens to represent the availability of a single resource, then this place must be safe.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Z is live if and only if for all transition t E T , and</head><p>V m E R ( 2 , m,), there exists a sequence of transition firings which enables t . The liveness of Z implies the absence of the possibility of deadlock. Deadlock occurs when a marking is reached such that the firing of one or more transitions is not possible from that point. This has considerable significance in manufacturing with concurrent processes and shared resources since deadlock can cause the factory or part of it to cease production.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Z is reuersible if and only if m, E R( Z , m ) , for all m E R( Z , m,).</head><p>Reversibility means reinitiahzability. It implies that the system will finally return to its initial state from any current states (including failure states). This has obvious implications for error recovery.</p><p>These properties assume considerable significance in the context of manufacturing [17], [25]. The initial Petri net controller Z should be designed to have these properties so that the controller compiled from Z can complete all required normal operations in a manufacturing system. One systematic approach to the synthesis of Petri net controllers with some desirable properties for manufacturing systems is referred to in [17].</p><p>The analysis to check these properties can be very expensive, particularly when the Petri net is large. Three methods are used, the reachability tree, invariant analysis, and reduction methods [26], a Petri net model for a two work-station manufacturing system was analyzed using the invariant method. The incidence matrix has 58 rows and 42 columns. 40 equations were obtained for the placeinvariants and 61 equations for the transition invariants. The liveness and boundedness were analyzed using these equations. The reachability method was not feasible be- cause of the reachable state explosion. These experiences serve to point out the value of design methods that avoid analysis and still preserve the properties of liveness, boundedness, and reversibility.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. E -Functions, r -Functions, and a Constant</head><p>In implementing a Petri net controller for a real-time system, time requirements need to be satisfied. Therefore it is necessary to introduce the time variable to the Petri net. In our controller, time is required only in operation places which represent the processes or operations. To process abnormal states that may appear during the execution of the system and detect errors using this Petri net, two functions and a constant are attached to each place in P (see Fig. 1) The Elapsed and Maximum T i m e s -r ( p ) and rm,(p), for all p E P: r m a x ( p ) is the maximum amount of time during which a token can stay in a place p . r ( p ) &gt; rmax ( p ) implies that an error may have occurred in the system so that the mechanism of fault diagnosis will be started.</p><p>2) The Error Information Functionc( p ) , for all p E P: </p><formula xml:id="formula_2">c( p ) = 0</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Adaptive Design of Petri Net Controllers</head><p>A Petri net controller can be easily extended for real-time purposes. In the following discussion, a Petri net controller is the controller based on Z = ( P , T , I , 0 , m,, c, r , rma) where c , r , T~~ are defined in the last subsection. The controller, denoted by Z , can be implemented for operation of the system. The initial value of c( p ) is set equal to one for every p in P . The adaptive design process for the Petri net controller can be described as follows.</p><p>1) If no error takes place or an old error is detected through the sensor data, then Z will be executed without augmentation of this Petri net controller.</p><p>2) If a new error occurs, the mechanism of fault diagnosis and error recovery planning will be started by using, for example, machine intelligence techniques or operator intervention. The result of this error recovery planning will be expressed as a part of a Petri net that will be added to this controller. This results in a new Petri net controller Z'. The system will recover from the error under the control of this new Petri net controller Z'.</p><p>The controller Z or later Z' changes when any new error takes place. The construction of new controller Z' from the old controller Z and the error-handling procedure S' is shown in Fig. <ref type="figure">3</ref>. S' consists of place set P,, transition set T,, input function I,, output function Os, and its initial marking m;. Mathematically, the new controller can be expressed as Z'= { P ' , T', 1', 0', m', e', r ' , .Aax} with two functions E' and 7' and a constant rkax in each p in P', where 1)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">)</head><p>3 ) 1': P ' X T ' -+ {O,l}; 4) 0': P ' X T ' + {O,l};</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">)</head><p>P' consists of P and all new places added to this Petri net controller or P' = P U P,; T' consists of T and all new transitions added to this controller or</p><formula xml:id="formula_3">T ' = T U T, U { t'} U { r ' } ; m': P ' + {0,1,2,. . -, M } .</formula><p>1', 0', m' are extensions from I , 0, m , respectively. In addition,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">)</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7)</head><p>E': P'-{0,1,2; . e,} and is extended to each new place;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>~' ( p )</head><p>and T&amp;, ( p ) : P ' + R . The I f , 0' can be easily determined by Z , S', and the relations between them. Also, the marking for the new controller Z' can be readily obtained.</p><p>The firing rules for the Petri net controller in a real-time system are as follows.</p><p>1) A transition is enabled if and only if m'( p ) &gt;l, c'( p ) &gt; 0, and 7'( p ) G p ) for each p that is any one of its input places in Z'.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2) If a transition t E T' fires, m"( p ) = m'( p ) + O ' ( p , t ) -I ' ( p , t ) , for each p E P'. c ' ( p ) = 0, ~' ( p )</head><p>= 0, for each output operation place of the transition t and time counting for ~' ( p ) starts. When the process is completed normally, e'( p ) = 1. When some error is detected, it will be set to a particular value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="111.">BASIC AUGMENTATION METHODS OF PETRI NET CONTROLLERS</head><p>We wish to incorporate the results of error recovery planning to augment the controller Z to form 2'. Motivated by research done by Fielding et al. <ref type="bibr">[8]</ref>, <ref type="bibr">[14]</ref>, four basic methods for augmentation to Z' from 2 by using the results of the error recovery planning mechanism are proposed. They are input conditioning, alternate path, backward error recovery, and forward error recovery, all of which are similar to the four methods discussed in [8] and <ref type="bibr">[14]</ref>. The last subsection will deal with the maintainability of t h s controller's properties through four theorems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Input Conditioning Method</head><p>The idea of the input conditioning method is that an abnormal state in a place that represents a process or a state of a manufacturing system can become a normal state after other actions are finished or some conditions are satisfied. An example [14] of this is the arrival at a workstation of a part that requires additional finishing prior to processing. Finishing that part prior to normal processing is an example of an input conditioning form of error recovery.</p><p>Fig. <ref type="figure">4</ref> depicts a general augmentation to 2' from Z using the input conditioning method. Here Z is the original Petri net with place set P and transition set T; S' is a Petri net block which represents the error recovery procedure; Ts is the set of transitions in S'; P, is the set of </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>LF&amp;----J P'</head><p>1' fires when E ( ~) = J . r' fires if process p' succeeds Fig. <ref type="figure">6</ref>. Restart place p after process represented in place p' (special case of input conditioning method).</p><p>places in S'. They satisfy the conditions: P, U T, # 0 , P s n T , # O , and ( P s u T , ) n ( P u T ) = O . The theorems of the last subsection show that such an augmentation will not change the liveness, boundedness (or safeness), or reversibility properties of Z given that S' satisfies certain conditions. Two special cases for the input conditioning method are as follows.</p><p>1) Retry the execution of the process that this place represents (Fig. <ref type="figure" target="#fig_6">5</ref>). For example only some parameters in the execution of the same operation in a system need minor changing. A specific example is that when a robot fails to insert a part in a workpiece, the robot can retry to insert the part.</p><p>2) Before restarting this place, another action will be executed first (Fig. <ref type="figure">6</ref>). For example suppose a tool is broken. After the tool is changed, the machine is in a normal state again. This constitutes error recovery using the input conditioning method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>%. Alternate Path Method</head><p>The philosophy of the alternate path method (also called error avoidance) states that another sub-petri net controller exists that can transform an abnormal state in place p directly into a normal state in a system. Fig. <ref type="figure">7</ref> depicts this type of construction of Z' from Z. It is assumed that the state in the place w will be aclueved after the state in the place p . S' and Z satisfy the same conditions described as in the last subsection. An example showing the alternate path method can be found in Section IV. Similarly the last subsection proves that the augmented net Z' will maintain the properties of Z gven that S' has certain properties. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Backward Error Recovery Method</head><p>Backward error recovery suggests that under the assumption that the state is normal, i.e., E( p ) = 1, Q in Z is executed and a new faulty state in place w results. However, this state can become a normal state in place p after the operation of a sub-petri net controller S'. This kind of construction of Z' from Z is shown in Fig. <ref type="figure">8</ref>. Also, the same conditions about Z and S' are assumed. A typical example is given by <ref type="bibr">Wiendahl et al. [15]</ref> as follows.</p><p>In the vibratory bowl feeder it is impossible to avoid the lack of order in parts. One cannot sense whether the screws in the bowl are correctly aligned so that they will not jam as they pass from the bowl to the feeder track. However, it is relatively easy to sense a jam in the feeder. If the jam takes place at a particular position, an air-driven plunger is employed to push the screws back into the bowl automatically, at which point the feed process is restarted. Again the properties are preserved, as shown by the theorems of the last subsection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Forward Error Recovery Method</head><p>The forward error recovery method is similar to the backward error recovery method; suppose that a faulty state results after the operation of Q in Z. However this state can be directly transformed into a normal state in Z after a Petri net controller S' operates. Such a construction of Z' from Z is depicted in Fig. <ref type="figure">9</ref>. Again the same conditions about Z and S' are assumed. A simple example is cited from <ref type="bibr">[16]</ref>.</p><p>Assume that gears are retrieved from a feed pallet and assembled in a way that requires the gears to mesh. It is impossible to sense in advance if the gears will mesh or not </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Let Z' be constructed from Z coupled with S', t', r ' ,</head><p>and two arcs (see <ref type="bibr">Figs. 4,</ref><ref type="bibr">[7]</ref><ref type="bibr">[8]</ref><ref type="bibr">[9]</ref>) by using the previous four basic augmentation methods when an error occurs. Then we have the following theorems.</p><p>Theorem 1: Z', with respect to (m,, mh), is bounded (or safe) if and only if both Z , with respect to the initial marking m,, and S*, with respect to its initial marlung m,*, are bounded (or safe). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>m ( p ) = W P L m2= ( M ( P , + l ) &gt; . . . , M ( P L ) ) &gt;</head><p>when placed at their assembly positions. However it is straightforward to determine that the gears have not m' = ( M P L + 1 &gt;,-. * &gt; M ( P " &gt; meshed after they are put at their assembly positions. By giving a twist until meshing occurs, the system can directly transform the situation into a normal state. The properties of this augmentation will also be preserved as shown in the next subsection. The results that unify these four methods into one structure are given by Fielding et al. <ref type="bibr">[13]</ref>, [14].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Maintainability of Qualitative Properties of the Controller</head><p>The qualitative analysis of a Petri net includes boundedness, safeness, liveness (absence of system deadlock), and reversibility (reinitializability or properness) as defined earlier. The following will focus on the maintainability of these properties of a Petri net controller when 2' is constructed from 2 using the four basic construction methods discussed earlier.</p><p>The four basic construction methods are input conditioning, alternate path, backward error recovery, and forward error recovery. For each method there are t', r', S' that do not belong to the controller 2. Let S' be a Petri net block which represents the error recovery procedure with its initial marking m&amp; An associated Petri net S* (Fig. <ref type="figure" target="#fig_0">10</ref>) is defined as a Petri net consisting of a place p , t', r', and S' where p is called an idle place</p><formula xml:id="formula_4">[23]. Its initial marlung is m$ = (1, m,*)</formula><p>where m,* is the initial marking of S' and 1 implies that the idle place is initially marked.</p><p>The idle place p in the associated Petri net S* that represents an operation in the Petri net controller in an automated manufacturing system. At that operation place, some errors may occur and be detected so that error recovery is needed. <ref type="figure"></ref>and<ref type="figure">m = (m,, m ( p ) , m</ref> 2 ) . For MJ E R(Z', MO), M, is also written as MJ = (m,,, m( p ) , mJ2, m;). If g is a sequence of transition firings, then g ( M ) shows that g is applied to marking M . The g t ( M ) means that a sequence of transitions t , followed by g , are applied to the marking M .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>The necessity is evident because any marlung vector of S* or Z is some part of a marking vector in R(Z', MO), and the latter is bounded or safe. The sufficiency is proved as follows. Assume that for all m E R ( Z , m,,), and for all m* E R ( S * , m,*), both m and m* are bounded.</p><p>Case 1: Given MO = ( m o , mb), for all M E R( Z', M O ) that is reached after both transitions t' and r' fire K times (K=0,1,2;..) (Fig. <ref type="figure" target="#fig_6">5</ref>). Then</p><formula xml:id="formula_5">M = ( m , m ' ) r n E R ( Z , m , ) , m* = (I, m') E R ( S * , m:).</formula><p>Therefore M is bounded.</p><p>Case 2: M is reached after the latest firing of t' without firing r' correspondingly, but before the firing of t', MJ = ( m J l , l , mJ2, rn;) has to be reached. Otherwise t' cannot be enabled. m = (m,,,l, m J 2 ) is bounded. Only the firing of t' yields the marking</p><formula xml:id="formula_6">M k = ( m ~l , O , m ~2 2 m i ) .</formula><p>However m,,, mJ2 may change into mkl, mk2, since some transitions in Z may fire; and mk may change into m;, since some transitions may fire in S' so that M = (mkl,O, m k 2 , m;). However</p><formula xml:id="formula_7">(mk1,1,mk2) E R ( Z , m O ) , ( o , m ; ) E R ( S * , m , * ) .</formula><p>Since mkl, m k 2 , mh are bounded, M is also bounded. Therefore for all M E R(Z', M O ) is bounded.</p><p>Similarly, it can easily be shown that the same conclusion holds for the other three basic methods. The safeness is a special case of boundedness, i.e., 1-boundedness. Therefore the theorem is proved.</p><p>Theorem 2: 2' with respect to ( m o , mb) is live if and only if both Z , with respect to m,, and S*, with respect to m,*, are live.</p><p>Proof: The necessity is evident because 2 ' would not be live if either S* or Z is not live. The sufficiency is proved as follows. Consider that the first method, input conditioning, is used. For any transition t in Z', for all M E R(Z', MO), there are two cases.</p><p>Case</p><formula xml:id="formula_8">A : t is a transition in Z but not one in S*. Let M = ( m , m'). I ) m E R(Z, mo): Since Z is live, there exists a se- quence of transition firings h in Z such that at marking h( m), t is enabled. Apply h to M in Z', h( M ) = ( h ( m ) , m') will enable t .</formula><p>R(Z,m,): Due to the construction of Z', this situation results only if a token in p leads t' to firing and p is no longer marked (Fig. <ref type="figure" target="#fig_6">5</ref>). Therefore</p><formula xml:id="formula_9">M = ( m l , ~( p ) , m 2 , m'),</formula><p>2) m</p><formula xml:id="formula_10">M ( p ) = 0, (0, m') E R ( S * , m ; ) . but (m1,1, m 2 ) E R ( Z , m o l ,</formula><p>Since S* is live, there exists a sequence of transition firings g such that r' is enabled. The result is</p><formula xml:id="formula_11">gr'((O, m')) = (1, m").</formula><p>Applying gr' to Z' at marking M , g r ' ( M ) = ( m l , l , m 2 , m").</p><p>Since (m,, 1, m 2 ) E R( Z , m,), thn is just case A-1.</p><p>Case B: t is a transition in S* but not one in 2. Let</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I ) (m(p), m') E R(S*, m;):</head><p>Since S* is live, there exists a sequence of transition firings h such that at marking</p><formula xml:id="formula_12">h ( m ( p ) , m') = ( i , m"), t is enabled ( z &gt; 0). Apply h to M in Z', h ( M ) = (ml, i, m2, m") will enable t.</formula><p>2) (m(p), m') 4 R(S*, m;): Due to the construction of Z' and S* (Figs. <ref type="figure" target="#fig_6">5</ref> and<ref type="figure">9</ref>), m ( p ) = 0, (1, m') E R(S*, rn;), Since Z is live, there exists a sequence of transition</p><formula xml:id="formula_13">M = (m1, m ( p ) , m23 m'). and (ml,O, m 2 ) E R ( Z , mol. firings h such that h ( m l , O , m 2 ) = ( ~~~1 , m,). h ( M ) = ( m a , l , mh, m') Applying h to Z', but (I, m') E R ( S * , m;).</formula><p>This is just case B-1. Therefore, Z' is live with respect to MO= (m,, m;). Similarly, we can easily prove that the conclusion holds true for the other three basic augmentation methods.</p><p>Theorem 3: If S* is reversible with respect to rn; such that when the place p has a token, m$ is reached, then 2' is reversible with respect to MO = (m,, mb) if and only if Z is reversible with respect to m,.</p><p>Proof: The necessity is obvious. The sufficiency is proved as follows. Consider that the first method, input conditioning, is used. There exists M E R(Z', MO), there are two cases.</p><p>Case I : M = ( m , mb), m E R(Z,m,): Since Z is reversible, there exists a sequence of transition firings h such that <ref type="bibr">*, m;)</ref>. Since S* is reversible, there exists a sequence of transition firings g such that g((O, m')) = rn; = (1, mb).</p><formula xml:id="formula_14">h ( m ) = m o . Apply h to M in Z', h ( M ) = (m,, m &amp; ) = M, is obtained. Case 2: M = (ml, M(p), m 2 , m'), M(p) = 0: If M ( p ) = 1, then this is Case 1 because m'= m;. The m* = (0, m') E R(S</formula><formula xml:id="formula_15">Apply g to M in Z', g ( M ) = ( m l , l , m 2 , mb) = ( m , mb)</formula><p>is obtained. However this is just case 1. So there exists h' such that h'( g( M ) ) = MO. From the given conditions, only the two above cases exist for any M E R( Z', MO). Therefore 2' is reversible with respect to MO = (m,, mb). Similarly it can be proved that the conclusion holds true for the other three basic augmentation methods.</p><p>While these straightforward theorem proofs are given, we wish to acknowledge that these could be just as easily shown using earlier theory, such as reduction methods as found in <ref type="bibr">Silva [21]</ref> or <ref type="bibr">Lee et al. [31]</ref>.</p><p>Before the next theorem is stated, the essentially decision-free (EDF) place proposed by <ref type="bibr">Krogh and Sreenivas [20]</ref> will be introduced.</p><p>Definition: A place p E P is said to be essentially decision-free with respect to an initial marking rn, if for all m E R(m,) (reachability set), at most one output transition of p is enabled.</p><p>This concept generalizes the notion of decision-free Petri nets where each place has exactly one output transition. The EDF property states that no more than one of these transitions is enabled. In other words when a place is EDF, the Petri net firing logic is such that there is never an ambiguity about whch of its output transitions will fire.</p><p>Theorem 4: The attachment of S' to any place p in Z does not change this place's EDF property.</p><p>The proof of Theorem 4 is evident. This is because the error information function ~( p )</p><p>attached to p has its unique corresponding firing path when C ( p ) is determined. The previous four theorems imply that the properties of a controller remain if the four basic construction methods, input conditioning, alternate path, backward error recovery, and forward error recovery are employed. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. AN APPLICATION EXAMPLE</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A . Description</head><p>This example uses a piston stuffing work station developed at the General Motors Technical Center [24]. The work station uses two robots to place and pull the pistons into the cylinders of an engine block and attaches the piston rods to the crank shaft. This system's layout is depicted in Fig. <ref type="figure" target="#fig_10">11</ref> and comprises the following components:</p><p>an indexing table with piston rods and caps; a table with nut dispensers and piston pulling tools; a workstation with an engine block; a GMF S-380R robot; a V-220 vision system; a GMF M-1 robot; and some sensors installed in the robots.</p><p>The basic steps involved in the system are as follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1)</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2)</head><p>3)</p><p>The S-380 robot moves the crank shaft to align the crank shaft position for piston insertion. The vision system checks and verifies the crank shaft position in the engine block. The S-380 robot picks up a piston, with its rod attached, from the indexing table and brings it to an engine block cylinder. 4) The M-1 robot picks up the piston pulling tool, two nuts, and a cap and moves to the workstation, Repeat steps 1)-4) for the remaining pistons.</p><p>Using the synthesis approach in [17], the initial Petri net controller for accomplishmg the previous tasks can be obtained as shown in Fig. <ref type="figure" target="#fig_11">12</ref>. This net has the desirable properties, safeness, liveness, and reversibility. It is also essentially decision-free; in fact, it is choice-free with respect to its initial marking (1,1,1,0,1,1,1,0,0,0,0,1,0, O,l,O,O). There are 17 safe places that represent the availability of resources or the operations and nine transitions which represent the start and/or completion of operations as listed below. All places are described in Fig. <ref type="figure" target="#fig_11">12</ref>.</p><p>Transitions:</p><formula xml:id="formula_16">t l</formula><p>Start. t2-t8 Firing on the completion of some appropriate action(s) and when the corresponding resources for the next action(s) are available. completion of the action in p17. t9</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Error Recovery</head><p>As an example of an input conditioning error recovery, suppose that the piston puller tool is broken and the error is detected in the place p10, then a recovery Petri net block is added to the controller (Fig. <ref type="figure" target="#fig_0">13</ref>). The error processing procedure includes p18 M-1 discards the old tool; p19 new tool available; and p20 M-1 picks up the tool.</p><p>There are three new transitions t10, t l l , and t12. The error information function E( p10) = 3. It is evident that the new controller (including the recovery block) is safe, live, reversible, and essentially decision-free. Given that this is true and the initial net is safe, live, reversible, and EDF, then our theorems guarantee that the augmented net has the same properties, i.e., safeness, liveness, reversibility, and is EDF.</p><p>As an example of alternate path error recovery, assume that an out-of-tolerance condition for a nut is built up and detected in the place p16. The error procedure has been represented in Fig. <ref type="figure" target="#fig_0">14</ref> which consisting of places: p21 M-1 discards the nuts; p22 two nuts available; and p23 M-1 picks up the nuts; and transitions t13, t14, and t15. The error information function E( p16) = 3 when this error first occurs in this place. Again, the liveness, safeness, reversibility, and EDF properties remain invariable for the controller.</p><p>Finally an incorrect part orientation error for a cap is detected in place p13, the error processing procedure can be developed using the forward error recovery method as shown in Fig. <ref type="figure" target="#fig_13">15</ref>. First the normal state is assumed at the place p13, then the faulty state will be detected in the place p14. The Petri net block which consists of a place p24, the robot M-1's adjusting the orientation of the cap, and two transitions, t16 and t17 are added to the original Petri net controller. We have the error information function E( p13) = 3 and E ( p14) = 3. Such an augmentation preserves also the properties of safeness, liveness, reversibility, and EDF of the controller. It is also noted that according to the definition of the error information function, c ( q ) = 2 means that emergency processing is needed for any place q and c ( q ) = 1 represents that the normal operations are executed.</p><p>T h s section has shown that the errors can be recovered using a Petri net controller. This controller can be adaptively designed using basic augmentation methods; input conditioning method, alternate path method, feedback error recovery method, and forward error recovery method. The desirable properties of the controller in its initial design are preserved as guaranteed by the theorems developed in Section III-E.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. CONCLUSION</head><p>This paper has presented the concept of augmenting Petri net controllers for error recovery in automated manufacturing systems. It has also shown that the liveness, boundedness, reversibility and essentially decision-free properties of the nets are preserved using particular program augmentation approaches described by Fielding et al. [SI. They are the input conditioning method, the alternate path method, the backward error recovery method, and the forward error recovery method.</p><p>Furthermore, the paper presented an example describing a piston stuffing workstation consisting of two robots and several parts developed at the General Motors Technical Center [24]. The common errors of broken or missing tools, parts out-of-tolerance, and incorrect part orientation have been discussed.</p><p>The greatest implication of the research is that the properties of a controller can be maintained when the control code is changed to accommodate new errors. This precludes the need for analysis each time the code is augmented.</p><p>Our future research includes studying the integration of a manufacturing system with its Petri net controller, mechanism for error diagnosis and recovery planning, and its sensors. Implementation issues are an important aspect of this research. We also hope to extend the concept of a Petri net controller using high-level Petri nets for more complicated manufacturing systems.</p><p>A methodology for synthesis of Petri net models for manufacturing systems is ready to be reported [17], [27],</p><p>[34]. The approach is based on a number of basic design Petri net modules and adopts three design philosophiestop-down, modular, and decomposition-that make it possible to build up a Petri net by stepwise refinement.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Architecture of intelligent automatic error recovery system.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>[19], [21], [31]-[33]. For example a Petri net modeling a factory producing corrugated fiberboard has 92 places, 59 transitions, and 174 arcs [31]. Lee et al. state, "We can imagine the reachable state explosion problem and the complexity of analysis of this model." In another example [l],</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Place with c( p ) , T ( p ) , T , , , ~~ ( p ) in Petri net</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>r</head><label></label><figDesc>2): P + N = {0,1, . . . } and is called the error information function (also called the â‚¬-function); P -+ R = { x , x is a nonnegative real number} and r ( p ) (called the r-function) is the elapsed time in a place p in P; and rmm P -+ R , and rmax ( p ) is the maximum elapsed time in a place p . c These are explained as follows.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>/ 2 :Fig. 3 .</head><label>23</label><figDesc>Fig. 3. Cons..--tion of new Petri net controller Z from old controller Z and error-handling procedure S'.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>1'</head><label></label><figDesc>Fig. 4. Input conditioning (restart p after running Petri net S')</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Restart place p (special case of input conditioning method).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 7 .Fig. 8 .</head><label>78</label><figDesc>Fig. 7. Alternate path method (substituting Q with S ' )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>such that t fires.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig 9 Fig. 10 .</head><label>910</label><figDesc>Fig 9 Forward error recovery method (startmg Q as if it were norm&amp;) Note: In the R ( Z , is the reachability set of 2 with respect to m,; R(S*, m:) is the reachability set of S* with respect to m$ = (1, mh); and R(Z', M O ) is the reachability set of Z' with respect to MO = (m,, mh). Assume that the place p is in the ith position in the N places of Z', where the first L places are from Z and the other ( N -L ) places from S', L 2 i, and</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Overall layout of robotic cell for piston insertion.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. Safe live reversible Petri net controller</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 13 .Fig. 14 .</head><label>1314</label><figDesc>Fig. 13. Petri net controller after piston-puller-tool-down error pro cessed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 15 .</head><label>15</label><figDesc>Fig. 15. Petri net controller after incorrect part orientation processed</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>transition t E T is enabled if and only if m( p ) &gt; 0 when I( p , t ) = 1, for all p E P ; an enabled transition t fires at marking m', yielding the new marking, m ( P I ) = m'( PI 1 + o( Pi. t ) -I( PI 9 t ) ?</head><label></label><figDesc></figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>The authors wish to acknowledge the General Motors Technical Center for its piston insertion example and Mr. Ronak Shodhan who provided the information about the example. They are grateful to P. J. Fielding for the helpful discussion and sharing his findings in the literature. They also acknowledge the assistance of S. J. Chang. Y. Chen, R. Y. Al-Jaar, J. Joshi, and Dr. G. Goldbogen and Prof.</p><p>A. A. Desrochers of RPI.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>T h s work was supported by the industrial members of the Computer Integrated Manufacturing Program and the Artificial Intelligence in Manufacturing Program of the Center for Manufacturing Productivity and Technology Transfer at Rensselaer Polytechnic Institute. The material in this paper was partially presented at the third IEEE International Conference on Intelligent Control, Arlington, VA, August 24-26, 1988.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Meng Chu Zhou (S'88) was born at Dongyang, <ref type="bibr">Zhejiang, China, on October 31, 1963</ref> </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Real-time control of multilevel of manufacturing systems using colored Petri nets</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kasturia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dicesare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Desrochers ; Philadelphia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Crockett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Desrochers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dicesare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ward</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1988 IEEE Int. Conf. Robotics and Automat</title>
		<meeting>1988 IEEE Int. Conf. Robotics and Automat<address><addrLine>Raleigh, NC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="1861" to="1867" />
		</imprint>
	</monogr>
	<note>Proc. 1987 IEEE Int. Conf. Robotics and Automat</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A Petri-net based factory automation for flexible and maintainable control specifications</title>
		<author>
			<persName><forename type="first">T</forename><surname>Murata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Komoda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Matsumoto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IECON</title>
		<meeting>IECON</meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Joining Petri nets and knowledge based systems for monitoring purposes</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sahraoui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Atabakhche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Courvoisier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Valette ; Raleigh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Barnes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">W</forename><surname>Hardy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 6th British Robot Assoc. Conf</title>
		<meeting>6th British Robot Assoc. Conf</meeting>
		<imprint>
			<date type="published" when="1983-05">May 1983</date>
			<biblScope unit="page" from="217" to="222" />
		</imprint>
	</monogr>
	<note>Proc. IEEE Robotics and Automat</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Error recovery in robots through failure reason analysis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Srinivas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AFIPS Conf. Proc</title>
		<meeting><address><addrLine>Anaheim, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1978-06">1978. June 1978</date>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="275" to="282" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Towards automatic error recovery in robot programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 8th Int. Joint Conf. Artificial Intell., Karlsruhe</title>
		<meeting>8th Int. Joint Conf. Artificial Intell., Karlsruhe<address><addrLine>Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1983-08">Aug. 1983</date>
			<biblScope unit="page" from="821" to="823" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Program augmentation for error recovery in automated manufacturing: A formulation</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Fielding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dicesare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Goldbogen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1988 IEEE Int. Conf. System Man and Cybern</title>
		<meeting>1988 IEEE Int. Conf. System Man and Cybern<address><addrLine>Beijing, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988-08">Aug. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Intelligent automated error recovery in manufacturing workstations</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Fielding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dicesare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Goldbogen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Desrochers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Atabakhche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Barbalho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Valette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Courvoisier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1987 IEEE Int. Symp. Intelligent Contr</title>
		<meeting>1987 IEEE Int. Symp. Intelligent Contr</meeting>
		<imprint>
			<date type="published" when="1987-01">Jan. 1987. 1988</date>
			<biblScope unit="page" from="1114" to="1119" />
		</imprint>
	</monogr>
	<note>Proc. PA</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName><surname>Nc</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="280" to="285" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName><surname>Iecon</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="812" to="817" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Use of Petri nets for performance evaluation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Sifakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Measuring, Modelling, and Evaluating Computer Systems. Amsterdam</title>
		<imprint>
			<publisher>North-Holland</publisher>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="75" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A timed Petri net methodology for specifying real-time system timing requirements</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Coolahan</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Roussopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 1985 Int. Workshop Timed Petri Nets</title>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="24" to="31" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Error recovery in automated manufacturing through the augmentation of programmed processes</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dicesare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Fielding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dicesare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Goldbogen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1988 IEEE lnt. Symp. Intelligent Contr</title>
		<meeting>1988 IEEE lnt. Symp. Intelligent Contr<address><addrLine>Arlington, VA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988-08-26">Aug. 24-26, 1988. Aug. 1988</date>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="337" to="362" />
		</imprint>
	</monogr>
	<note>Adaptive design of Petri net controllers for automatic error recovery</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A formal methodology for synthesis of Petri net models and controllers for manufacturing systems</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">P</forename><surname>Wiendahl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Ziersch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Feicht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dicesare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Goldbogen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dicesare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Desrochers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Tenth IASTED Symp.: Robotics and Automation</title>
		<meeting>Tenth IASTED Symp.: Robotics and Automation<address><addrLine>Lugano, Switzerland; Troy, NY</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985">1985. 1987. June. Nov. 1988</date>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="217" to="224" />
		</imprint>
	</monogr>
	<note type="report_type">Working Paper</note>
	<note>Assembly Automat.</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Petri nets in automation and manufacturing</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">Y</forename><surname>Ai-Jaar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Desrochers</surname></persName>
		</author>
		<editor>N. Saridis</editor>
		<imprint>
			<date type="published" when="1989">1989</date>
			<publisher>JAI Press Inc</publisher>
			<biblScope unit="volume">2</biblScope>
			<pubPlace>CT</pubPlace>
		</imprint>
	</monogr>
	<note>to appear in Advances in Automation and Robotics</note>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Petri Net Theory and ModeHing of Systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Peterson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981">1981</date>
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Englewood Cliffs, NJ</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Essentially decision free Petri nets for real-time resource allocation</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">K</forename><surname>Krogh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Sreenivas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. Robotics and Automat</title>
		<meeting>IEEE Int. Conf. Robotics and Automat<address><addrLine>Raleigh, NC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987-03">Mar. 1987</date>
			<biblScope unit="page" from="1005" to="1011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Tutorial: Petri nets and computer integrated manufacturing</title>
		<author>
			<persName><forename type="first">M</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. Robotics and Automat</title>
		<meeting>IEEE Int. Conf. Robotics and Automat<address><addrLine>Raleigh, NC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987-03">Mar. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">N</forename><surname>Saridis</surname></persName>
		</author>
		<title level="m">Petri Nets in Automation and Computer Engineering</title>
		<meeting><address><addrLine>Madrid, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
	<note>in Spanish. English translation to appear</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Analysis of Petri nets by stepwise refinements</title>
		<author>
			<persName><forename type="first">R</forename><surname>Valette</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J . Comput. Syst. Sei</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="35" to="46" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A Petri net approach to the modeling and analysis of flexible manufacturing systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Shodhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Tech</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Center</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Narahari</surname></persName>
		</author>
		<author>
			<persName><surname>Viswanadham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ann. Oper. Res</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="449" to="472" />
			<date type="published" when="1985">May 1988. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Real-time control of multilevel of manufacturing systems using colored Petri nets</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kasturia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Rensselaer Polytech. Inst</title>
		<imprint>
			<date type="published" when="1988-05">May 1988</date>
			<pubPlace>Troy, NY</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">M.S. thesis</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Performance evaluation and validation of tool handling in flexible manufacturing systems using Petri nets</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dicesare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Desrochers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Bruno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Biglia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">ECSE Dep., Rensselaer Polytechnic Inst., Working Paper</title>
		<imprint>
			<biblScope unit="page" from="64" to="71" />
			<date type="published" when="1985">Feb. 1989. 1985. 1985</date>
		</imprint>
	</monogr>
	<note>Further study of Petri net synthesis methodology for manufacturing systems</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Modeling and analysis of transfer lines and production networks using generalized stochastic Petri nets</title>
		<author>
			<persName><forename type="first">G</forename><surname>Balbo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Chiola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Franceschinis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Roet ; Raleigh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">C</forename></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">Y</forename><surname>Ai-Jaar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Desrochers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conf. Univ. Programs in Computer-Aided Eng., Design and Manufacturing</title>
		<meeting>Conf. Univ. Programs in Computer-Aided Eng., Design and Manufacturing<address><addrLine>Atlanta, GA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988">June 27-29, 1988</date>
			<biblScope unit="page" from="12" to="21" />
		</imprint>
	</monogr>
	<note>Proc. IEEE Int. Conf. Robotics and Automat</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Generalized Petri net reduction method</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Favrel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Baptiste</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Syst. Man Cybern</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="297" to="303" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Modeling and analysis of concurrent systems</title>
		<author>
			<persName><forename type="first">T</forename><surname>Murata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Systems Engineering</title>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Vick</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">V</forename><surname>Ramamoorthy</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Van Nostrand Reinhold</publisher>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
	<note>ch. 3</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Linear algebraic techniques for place/transition nets</title>
		<author>
			<persName><forename type="first">K</forename><surname>Lautenbach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Petri Net</title>
		<editor>
			<persName><forename type="first">W</forename><surname>Brauer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Reisig</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Rozenberg</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A top-down modular approach to synthesis of Petri net models for manufacturing systems</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dicesare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Desrochers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1989 IEEE Robotics and Automat</title>
		<meeting>1989 IEEE Robotics and Automat<address><addrLine>Scottsdale, AZ</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987-03">May 1989. 24-J~ly 2. Mar. 1987</date>
			<biblScope unit="page" from="1013" to="1018" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
