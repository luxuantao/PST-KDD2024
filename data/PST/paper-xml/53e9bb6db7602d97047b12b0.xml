<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Enhancing Model Checking in Verification by AI Techniques</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Francesco</forename><surname>Buccafurri</surname></persName>
						</author>
						<author role="corresp">
							<persName><forename type="first">Thomas</forename><surname>Eiter</surname></persName>
							<email>eiter@kr.tuwien.ac.at</email>
							<affiliation key="aff1">
								<orgName type="department">Institut and Ludwig Wittgenstein Labor für Informationssysteme</orgName>
								<orgName type="institution">Technische Universität Wien</orgName>
								<address>
									<addrLine>Treitlstraße 3</addrLine>
									<postCode>A-1040</postCode>
									<settlement>Wien</settlement>
									<country key="AT">Austria</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Institut and Ludwig Wittgenstein Labor für Informationssysteme</orgName>
								<orgName type="institution">Technische Universität Wien</orgName>
								<address>
									<addrLine>Paniglgasse 16</addrLine>
									<postCode>A-1040</postCode>
									<settlement>Wien</settlement>
									<country key="AT">Austria</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Nicola</forename><surname>Leone</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Institut and Ludwig Wittgenstein Labor für Informationssysteme</orgName>
								<orgName type="institution">Technische Universität Wien</orgName>
								<address>
									<addrLine>Paniglgasse 16</addrLine>
									<postCode>A-1040</postCode>
									<settlement>Wien</settlement>
									<country key="AT">Austria</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">DIMET</orgName>
								<orgName type="institution">Universitá di Reggio Calabria</orgName>
								<address>
									<addrLine>loc. Feo di Vito</addrLine>
									<postCode>I-89100</postCode>
									<settlement>Reggio Calabria</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Enhancing Model Checking in Verification by AI Techniques</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">65AEE6B21E43D36E05900859E6AFB3F0</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T02:21+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>abductive theory revision</term>
					<term>model checking</term>
					<term>diagnosis and repair</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Model checking is a fruitful application of computational logic with high relevance to the verification of concurrent systems. While model checking is capable of automatically testing that a concurrent system satisfies its formal specification, it can not precisely locate an error and suggest a repair, i.e., a suitable correction, to the system. In this paper, we tackle this problem by using principles from AI. In particular, we introduce the abstract concept of a system repair problem, and exemplify this concept on repair of concurrent programs and protocols. For the development of our framework, we formally extend the concept of counterexample, which has been proposed in model checking previously, and provide examples which demonstrate the need for such an extension. Moreover, we investigate into optimization issues for the problem of finding a repair, and present techniques which gain in some cases a considerable reduction of the search space for a repair.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Model checking, which has been first proposed by Clarke and Emerson <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10]</ref>, is an approach to automated verification of finite-state concurrent systems such as circuit designs and communication protocols. In this approach, specifications are expressed in a propositional temporal logic, and the concurrent system is modeled as a state transition graph, which amounts to a Kripke structure for this logic. Checking whether the system satisfies its specification, given by a logical formula, reduces then to test whether the Kripke structure is a model of the formula.</p><p>Model checking has several important advantages over other methods for verification of circuits and protocols, like mechanical theorem provers or proof checkers. The most relevant one is that it is efficient and highly automatic. Recent advances in model checking by using special data structures and algorithms, known as symbolic model checking, some of which have more than 10 120 states <ref type="bibr" target="#b7">[8]</ref>. A number of major companies including Intel, Motorola, Fujitsu, and AT&amp;T have started using symbolic model checkers to verify actual circuits and protocols. Thus, (symbolic) model checking is nowadays considered to be one of the most fruitful and promising applications of computational logic.</p><p>On the other hand, various techniques for diagnostic reasoning on systems have been developed in the field of AI, including logic-based approaches like model-based diagnosis and repair <ref type="bibr" target="#b26">[27]</ref>. These approaches utilize general AI principles and are successfully used in different application domains. Our work approaches a new and promising field for application of AI techniques, which is in particular attractive for knowledge representation and reasoning methods, and thus adds to the application perspective of this field <ref type="bibr" target="#b0">[1]</ref>.</p><p>In this paper, we study the enhancement of model checking by abductive reasoning, which is a major technique in AI and knowledge representation, cf. <ref type="bibr" target="#b39">[40,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b42">43,</ref><ref type="bibr" target="#b3">4]</ref>. The work presented does not exhaustively treat this issue, and further work is necessary; however, it is a first step towards an integration of model checking with AI techniques, and may stimulate other work in this direction.</p><p>The main contributions of the present paper can be summarized as follows.</p><p>We study the integration of model checking and AI principles. In particular, we introduce the system repair problem in the context of Computational Tree Logic (CTL) (a temporal logic used to express the specifications of concurrent systems to be checked), which is formal framework for repairing a concurrent system, described by a Kripke model, at the semantical level. Notice that in a different context, repair was introduced in <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b40">41]</ref>.</p><p>The system repair problem amounts to an interesting abductive model revision problem: Determine by abductive reasoning a suitable change of the system (i.e., of its Kripke model) such that the specification is satisfied upon this change. Interestingly, this problem is an intermingled abductive reasoning and theory revision problem, which is best understood as an abductive theory revision problem. In fact, the system repair problem can be modeled as an abductive theory revision problem in the frameworks of <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b28">29]</ref>. Note that the close relationship between abduction and revision is well-recognized, and its investigation received increasing interest more recently, e.g., <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b33">34]</ref>.</p><p>We show that the proposed framework for system repair can be profitably used, by providing an application to the repair of concurrent programs and protocols. In particular, we describe a program repair problem, in which repair of a concurrent pro gram in terms of changes at the syntactical level (i.e., modifications of the program code) is mapped to changes at the semantical level. As dealing with all possible modifications is clearly infeasible, we restrict in our approach to some types modifications which seem to be relevant in practice. A repair is then a sequence = 1 q of basic corrections i on the program, such that the modified program satisfies the specification '. Applying AI principles and, in particular, Occam's principle of parsimony, we provide also a notion of minimal solution, that prunes solutions which are not free of redundancy.</p><p>We face the problem of searching for a program repair. In general, the search space for this problem is large, and might still contain a number of candidates, even if only elementary corrections such as inverting the value of an expression or exchanging the name of a variable in a Boolean assignment statement are adopted as repairs.</p><p>In order to alleviate this problem, we develop optimization techniques which sensibly reduce the search space for a repair by exploiting structural information about the failure of the system provided by a counterexample. In particular, we formulate two pruning criteria referred to as correction execution and correction exploitation, which can be evaluated efficiently. In fact, given the program, a collection of candidate repairs, and a counterexample, the candidates violating these principles can be discarded in linear time. As we demonstrate, this may yield considerable savings, and thus applying correction execution and exploitation is an effective pruning method which comes at low computational cost.</p><p>We formally extend the notion of counterexample from <ref type="bibr" target="#b10">[11]</ref>, which is a heuristically selected computation path from a conceptual counterexample tree (i.e., an evolving branching computation) that gives a hint at the failure of the system. As shown by examples, there are cases in which no single path is a counterexample. We therefore introduce the concept of a multi-path, which enables representation of nested paths. Multi-paths turn out to be a suitable tool for expressing full counterexample trees, which is needed for our purposes.</p><p>To give the flavor of theory and application developed in this paper, we discuss a motivating example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Process P A</head><p>Process P B</p><p>1: ag1A := true;</p><p>1:</p><p>ag1B := true; 2: turn1B := false; 2: turn1B := false; 3: if ag1B and turn1B then 3: if ag1A and not turn1B then end ; 14: goto 1; 14: goto 1; Figure <ref type="figure">1</ref>: A concurrent program P Consider the concurrent program P in Figure <ref type="figure">1</ref>. It consists of processes P A and P B , which share two common boolean variables x and y. To ensure mutual exclusion of the assignments to x and y, some control variables, flags and turns, are introduced, following the classical Peterson scheme <ref type="bibr" target="#b37">[38]</ref>, in which each critical section is executed obeying an entry and exit protocol. There are then two critical sections in each process, one for the assignments to x (statements 5 in P A and statements 5-11 in P B ), and another one for the assignments to y (statements 12 in P A and 10 in P B , respectively); notice that in P B , the critical section for y is nested into the critical section for y. Each variable agiV indicates the request of process V to enter critical section i, and turniB tells whether such a request by process B in case of simultaneous requests should be granted. The six control variables agiA and agiB, and turniB, for i = 1; 2 are shared among the two processes.</p><p>The critical sections have been set up for the purpose of fulfilling some part of the system specification. The complete specification prescribes that P satisfies mutual exclusion for assignments to x and y, respectively, and absence of starvation. For example, P A must not execute instruction 5, if P B executes instruction 5 or 11 at the same time. Absence of starvation requires that a request of a process for a resource (by setting a flag) must eventually be granted. Clearly, this makes sense only under the hypothesis that the underlying scheduler is fair; absence of starvation cannot be ensured if the scheduler always dispatches the same process.</p><p>Careful inspection of P shows that the program is not correct, even under fair schedules; instruction 2 of P A should be turn1B := true. Even in this small example, however, detecting the error is not immediate for the non-expert. Model checking allows for checking the correctness of P (and of much larger programs) in a fully automatic way. The specification of the system, mutual exclusion and absence of starvation, can be expressed in the temporal logic ACTL <ref type="bibr" target="#b25">[26]</ref>; fair schedules are specified my means of fairness constraints <ref type="bibr" target="#b10">[11]</ref>. Then, an automatic procedure verifies whether the program meets the specifications or not. If the program is incorrect, however, model checkers usually can not single out the error precisely, and are far from fixing a bug.</p><p>By using abductive reasoning, our method goes beyond error checking: it tries to locate a bug and proposes a repair for the program, such that the modified program meets the specification. Our approach considers possible errors both in the left and right hand side of an assignment as well as the interchange of two successive assignments.</p><p>Like abduction, program repair comes at computational cost. Even if we assume the case of a single error in the program and we plausibly restrict in Figure <ref type="figure">1</ref> attention to the assignments of control variables, we must consider 12 assignments (1; 2; 6; 8; 9; 13 in P A and 1; 2; 6; 7; 12; 13 in P B ) and 6 control variables. Thus, (5 + 1) 12 + 5 = 77 attempts of repair should be done, namely 5 corrections of the control variable on the left hand side and one correction of the right hand side of each statement, and 5 interchanges of neighbored assignments to control variables (1,2 and 8,9 in P A and 1; 2; 6,7; 12,13 in P B ). Each of these corrections requires a call of the model checker to see if it works.</p><p>Towards more efficient program repair, we have designed optimization techniques, based on counterexamples <ref type="bibr" target="#b10">[11]</ref>, for the case of a single error in the program, which is often considered in practice. By applying these techniques, our procedure makes only 17 (instead of 77) attempts in the worst case.</p><p>The remainder of this paper is structured as follows. In Section 2, we recall the syntax and the semantics of the logic CTL. In Section 3, we address the problem of modifying a system, given in terms of a Kripke structure, such that a given formula holds on it. In the course of this, we introduce the notion of system repair problem, which provides a general framework for the problem of properly changing a system at the semantical level in order to meet a formal specification, given in CTL.</p><p>A system repair problem constitutes a kind of abductive model revision problem, and we outline how such a problem can be represented in the frameworks for abductive theory change proposed in <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b28">29]</ref>. After that, we consider in Section 4 the corresponding problem at the syntactical level, in particular the one of correcting concurrent programs and protocols. The program repair problem, which is addressed there, resorts at the semantical level to a system repair problem. In Section 5, we then address the problem of finding repairs. For this purpose, we suitably generalize the notion of counterexample described in <ref type="bibr" target="#b10">[11]</ref>, and show that counterexamples characterize errors. In the subsequent Section 6, we address optimization techniques which, by use of counterexamples, may allow to considerably reduce the number of possible repairs that have to be considered. In particular, we formulate correction execution and correction exploitation, investigate their computational feasibility and show the effectiveness of the techniques on an example. The final Section 7 concludes the paper and states some issues for further work.</p><p>In order to increase readability, proofs of technical results except a few short ones have been moved into the appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Computational Tree Logic</head><p>Computational Tree Logic (CTL) is a propositional branching-time temporal logic <ref type="bibr" target="#b8">[9]</ref>; see <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b11">12]</ref> for a rich background on this and further such logics. The semantics of CTL is given by Kripke Structures which model finite-state systems. CTL is used to represent specification in reactive systems. Linear-time features of CTL are useful to capture ordering of events in time. Branching time operators allow to take into account the existence of multiple possible future scenarios, starting from a given point of a computation. Indeed, in a branching frame the temporal order defines a tree which branches toward the future. Thus, every point of time has a unique past, but, in general, more than one future. Branching time operators allow us to deal with this form of non-determinism. Using these operators, we will express the truth or falsehood of a certain property as being relative to a given branch of the computation tree, such that we can express both possible properties (true in a possible evolution of time in the future) and necessary ones (true in all possible computation branches).</p><p>CTL is a fragment of the more general logic CTL <ref type="bibr" target="#b20">[21]</ref>, which combines both branching-time and linear-time operators. The branching time operators are A and E, which intuitively say "for every resp. some computation path", and the basic linear-time operators are X (next time), U (until), and V (unless, releases); further operators are derived from them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.1</head><p>Let A be a set of atomic propositions. CTL is the set of state formulas on A inductively defined as follows:</p><p>(1) any atomic proposition a 2 A is a state formula.</p><p>(2) if ' and are state formulas, then :', ' _ , and ' ^ are state formulas;</p><p>(3) if ' and are state formulas, then X', 'U and 'V are path formulas; (4) if ' is a path formula, then E(') and A(') are state formulas.</p><p>Any formula ' which is formed only by ( <ref type="formula">1</ref>)-( <ref type="formula" target="#formula_7">2</ref>) is called pure state formula. 2</p><p>Intuitively, path formulas describe properties of paths because they use temporal operators next time, until and unless, looking forward in a computation path.</p><p>For a formal definition of the semantics of CTL, special Kripke structures are used. Informally, a Kripke structure consists of a labeled finite transition graph. Definition 2.2 A Kripke structure is a quintuple M = (A; S 0 ; S; R; L) such that:</p><p>A is a finite set of atomic propositions; S is a finite set of states; S 0 S is a finite set of initial states; R S S is a transition relation;</p><p>L : S ! 2 A is a mapping assigning each state of S the set of atomic proposition true in that state; L is called label function.</p><p>Given a Kripke structure M, we denote by A(M) its set of atomic propositions, by S 0 (M) the set of initial states, by S(M) the set of states, by R(M) the transition relation, and, finally, by L(M) the label function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>Starting from initial states, R generates the (infinite) computation paths.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.3</head><p>A path of a Kripke structure M is an infinite sequence s 0 ; s 1 ; ; s i ; ] such that for each i 0 (s i ; s i+1 ) 2 R. Given an integer i 0 and a path , we denote by (i) the i-th state of . Given an integer j 0 and a path , the j-suffix j of is the path (j); (j + 1); ]</p><p>(clearly, = 0 and (i) = i (0)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>The semantics of CTL is defined through an entailment relation j =, which can be applied on states s and paths for evaluating state or path formulas, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.4</head><p>The entailment relation j = for state and path formulas on a Kripke structure M is as follows (s and are a generic state and path in M, respectively):</p><p>1. M; s j = p, if p 2 L(M)(s), for any atomic proposition p 2 A(M) 2. M; s j = :', if M; s 6 j = ' (' is a state formula) 3. M; s j = ' 1 _ ' 2 , if M; s j = ' 1 or M; s j = ' 2 (' 1 , ' 2 are state formulas) 4. M; s j = ' 1 ^'2 , if M; s j = ' 1 and M; s j = ' 2 (' 1 , ' 2 are state formulas) 5. M; s j = E( ), if there exists a path with (0) = s such that M; j = 6. M; s j = A( ), if M; j = for all paths with (0) = s 7. M; j = ', if M; (0) j = ' where ' is a state formula 8. M; j = X', if M; 1 j = ' 9. M; j = ' 1 U' 2 , if there exists an integer k 0 such that M; k j = ' 2 and M; j j = ' 1 , for all 0 j &lt; k 10. M; j = ' 1 V' 2 , if for every k 0, M; j 6 j = ' 1 for all 0 j &lt; k implies M; k j = ' 2</p><p>We write M j = ' if M; s 0 j = ', for every initial state s 0 2 S 0 (M), 2</p><p>Intuitively, a state formula holds along a path, if it is true at its first state; ' 1 U' 2 is true, if ' 1 is true along the path until some stage is reached at which ' 2 is true; and ' 1 V' 2 is true, if there is no stage such that ' 2 is false and ' 1 is false at all previous stages. Note that U and V are dual operators: ' 1 U' 2 is true precisely if :' 1 V:' 2 is false.</p><p>Two important additional operators, F (finally) and G (globally) are expressed through U and V. Definition 2.5 Given a state formula ', the operators F and G are defined as follows:</p><formula xml:id="formula_0">F' = trueU' G' = falseV' (= :F:')</formula><p>where true is a boolean tautology and false is a boolean contradiction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>Thus, coherent with the intuition, M; j = F' means that there exists an integer k 0 such that M; k j = ', while M; j = G' means that for every k 0, M; k j = '.</p><p>EX, EG and EU (or, dually, AX, AF, and AV) can be seen as basic time operators of CTL.</p><p>The following equivalences are well-known (see e.g. <ref type="bibr" target="#b11">[12]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 2.1</head><p>AX' = :EX(:') A('U ) = :E(: U(:' ^: )) ^:EG: AG' = :EF(:') A('V ) = :E(:'U: ) AF' = :EG(:') :A(:'U: ) = E('V )</p><p>For modeling fair computations, Kripke structure with fairness constraints (FC-Kripke structure, for short) have been proposed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.6</head><p>An FC-Kripke structure M is an expansion of a Kripke Structure K = (A; S 0 ; S; R; L) by a finite set F of CTL formulas, called fairness constraints, i.e, M = (A; S 0 ; S; R; L; F). 2</p><p>For any FC-Kripke structure M, we denote by F(M) its set of fairness constraints; the others components of M are denoted as for ordinary Kripke structures.</p><p>The semantics of CTL formulas is adapted to fairness constraints by restricting the path quantifiers to those paths along which every fairness constraint holds infinitely often, which are called fair paths. More formally, Definition 2.7 A path in a FC-Kripke structure M is fair, if for every ' 2 F(M) and i 0 there exists an integer j i such that M; (j) j = '. 2</p><p>Entailment of state and path formulas from an FC-Kripke structure M is defined analogous to entailment from a Kripke structure, with the only difference that path quantifiers A and E evaluate to "for all fair paths in M" and "there exists a fair path in M," respectively. Since the notion of entailment will be clear from the context, we will use for both entailment from a Kripke and a FC-Kripke structure the same symbol "j=."</p><p>Notation. Throughout this paper, we use kOk to denote the size of an object O represented as a string in the standard way, i.e., the numbers of symbols in this string.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Abductive Model Revision</head><p>In this section, we present an approach for changing a Kripke structure such that it satisfies a given formula '. Our approach is in spirit of methods in the field of theory revision and abductive reasoning, and can be viewed as a semantical approach to changing a system which is represented by some Kripke model; typical such systems are concurrent programs and protocols. This semantical approach can be utilized as the underlying basis of an approach for change at the syntactical level of a system, i.e., its description in some formal specification language. This will be exemplified with the problem of repairing concurrent programs and protocols in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">System Repair Problem</head><p>Given a CTL formula ' and an FC-Kripke structure M, a model checking technique can be applied for verifying whether ' is satisfied by M or not. Actually, symbolic model checking <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b35">36]</ref> gives as the result a description of the set of states where ' holds or provides a counterexample, which outlines a case in which ' does not hold. This is, in general, very useful to the protocol or circuit designer, because it aids him or her in understanding which part of the system fails, and is a clue for finding a modification of the system such that the specification, given by formula ', holds. However, model checking does not provide any methods for repairing the system. That is, there is no component which suggests, given that the system does not satisfy the specification ', a possible modification to the system upon which it satisfies '. Clearly, such a component would be desirable in practice. Notice that the notion of repair (or therapy) in the context of model-based diagnosis was introduced in <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b23">24]</ref> and independently in <ref type="bibr" target="#b40">[41]</ref>.</p><p>For this purpose, we formalize the system repair problem as a problem, given by an FC-Kripke structure M and a formula ', whose solution consists of a set of modifications to the transition relation R (additions or deletions of tuples in R), such that ' is true in the modified system. As</p><p>shown by examples later on, a solution of a system repair problem may give a useful clue of how to properly modify the system.</p><p>In what follows, we assume that M = (A; S 0 ; S; R; L; F) is an FC-Kripke structure and ' is a CTL formula.</p><p>We start with the elementary concept of a simple modification of the transition relation, which is addition or a deletion of a state transition. Definition 3.1 Let R S S. Every pair = h(s 1 ; s 2 ); i, where s 1 2 S, s 2 2 S, and 2 f?; +g, is a simple modification. The application of on R, denoted (R), is R f(s 1 ; s 2 )g, if = +, and R n f(s 1 ; s 2 )g otherwise. 2</p><p>A modification of the system M is a consistent set of simple modifications of its transition relation R, where consistent means that no simultaneous addition and deletion of a given pair of states is allowed. More precisely, Definition 3.2 A modification for M is a set ? of simple modifications for R such that ? contains no tuples h(s 0 1 ; s 0 2 ); +i, h(s 0 1 ; s 0 2 ); ?i. Let ? + = f(s 1 ; s 2 ) j hs 1 ; s 2 ; +i 2 ?g and ? ? = f(s 1 ; s 2 ) j hs 1 ; s 2 ; ?i 2 ?g. The set of all modifications for M is denoted by mod(M). The result ?(M) of ?</p><p>is the FC-Kripke structure (A; S 0 ; S; R ? ; L; F) where R ? = T 2? ? (R) ( S 2? + (R) n R), if ? 6 = ;, and R ? = R otherwise.</p><p>2</p><p>Now we introduce the system repair problem. Intuitively, it represents the problem of finding a system modification ? for M, such that ?(M) satisfies '. In general, ? must be implemented on a formal description of the system (i.e., the code of concurrent programs and protocols), and not every ? might be actually feasible; therefore, we add a function Y, which tells whether a particular modification ? is admissible. Definition 3.3 A system repair problem (SRP) is a triple S = hM; '; Yi where M is an FCstructure, ' is a formula on A(M), and Y is a computable boolean function on mod(M). Any modification ? such that Y(?) = true is called admissible. 2</p><p>Observe that Def. 3.3 does not request that M 6 j = ' holds. In fact, if M j = ', there will be a trivial solution to the SRP given by the empty modification ? = ;, which is always assumed to be admissible. This is similar to e.g. Reiter's definition of diagnosis <ref type="bibr" target="#b41">[42]</ref>, where the diagnosis in case of a correct system is an empty set of faulty components.</p><p>A SRP hM; '; Yi is also called the repair problem of M w.r.t. ' under Y. The admissibility function Y is domain-dependent; e.g., in case of a concurrent program, Y is derived from possible changes to the code of the processes.</p><p>A solution of a SRP states how the original system, which does presumably not satisfy ', has to be modified by means of a set ? of admissible modifications of its transition relation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.4</head><p>Given an SRP S = hM; '; Yi, a solution for S is an admissible modification ? for M such that ?(M) j = '. A solution ? for S is minimal, if there exists no solution ? 0 for S such that ? 0 is properly contained in ?.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>The restriction of arbitrary solutions to minimal ones is natural and implements Occam's principle of parsimony. In general, a solution preference could be used to select preferred solutions as customary e.g. in abductive reasoning, cf. <ref type="bibr" target="#b17">[18]</ref>. Observe that if M j = ', then ? = ; is the unique minimal solution to S.</p><p>Example 3.1 Consider the SRP S = hM; '; Yi, where M is the FC-Kripke structure as obvious from Figure <ref type="figure" target="#fig_1">2</ref> with unique initial state s 0 and no fairness constraints, ' = AGAFa, and Y true, i.e., each modification ? is admissible. (Note that R(M) = f(s 0 ; s 0 ); (s 0 ; s 1 ); (s 1 ; s 1 )g.) It holds s0 s1 that M 6 j = ': For the path = s 0 ; s 1 ; s 1 ; : : :], we have M; 6 j = GAFa, as it can be easily seen that M; 1 j = EG:a. A solution of S is the modification ? 1 = fhs 0 ; s 1 ; ?ig, i.e., delete the transition from s 0 to s 1 . Indeed, then = s 0 ; s 0 ; : : :] is the unique infinite path starting at an initial state, and a is true at each stage of . Further solutions are e.g. ? 2 = fhs 1 ; s 1 ; ?i; hs 1 ; s 0 ; +ig and ? 3 = fhs 0 ; s 1 ; ?i; hs 0 ; s 0 ; ?ig. Notice that ? 1 is minimal, while ? 2 and ? 3 are not. In fact, ? 1 and ? 4 = fhs 1 ; s 1 ; ?ig are all minimal solutions of S.</p><formula xml:id="formula_1">L(s1) = fbg L(s0) = fag</formula><p>2</p><p>Comparing system repair to problems in AI, it appears that an SRP is an interesting kind of abductive model revision problem, which involves both theory revision and abductive reasoning. From the definition, an SRP can neither be viewed as a pure theory revision problem (cf. <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b24">25]</ref>), nor as a pure abductive reasoning task as e.g. in <ref type="bibr" target="#b39">[40,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b42">43,</ref><ref type="bibr" target="#b3">4]</ref>; rather, it is a combined problem and can be best understood (and modeled) as an abductive theory revision problem <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b28">29]</ref>.</p><p>On the one hand, an SRP is similar to a theory revision problem. Indeed, the FC-Kripke structure M can be viewed as the set Th(M) of all formulas true on it, and we have to revise this knowledge base by incorporating the formula ' (the specification) into it. Here, the revised knowledge base M ' must amount to a modified FC-Kripke structure M 0 such that M 0 entails '.</p><p>On the other hand, an SRP involves abductive reasoning: given M and ', we want to find a particular modification ? 2 mod(M) such that applying ? to M yields a structure M 0 = ?(M) in which ' is true; thus, we abduce a solution ? for the SRP in terms of changes to the transition relation. This can be formalized in a proper logical language. However, this does not mean an SRP is a genuine abductive reasoning task; in fact, abduction is applied in case of incomplete knowledge, which is in this view about the suitable changes for transforming M into M 0 . This is a somewhat unnatural state-oriented view, though, since like in planning, we proceed from one state (M ) to another (M 0 ), and the transition is specified in the domain theory using frame axioms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">System repair and abductive theory revision</head><p>More naturally, a SRP can be viewed as an abductive theory revision problem. We outline in the following how this is possible in the frameworks of <ref type="bibr" target="#b32">[33]</ref> and <ref type="bibr" target="#b28">[29]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SRP in Lobo and</head><p>Uzcátegui's framework. In <ref type="bibr" target="#b32">[33]</ref>, the following scenario is considered. Given an abductive domain theory , a knowledge base K, a formula ! (all in a finite language), and a revision operator , a suitable formula is an explanation for ! (w.r.t. K, and ), if the knowledge base K ( ^ ) entails !. Suitability of means that is formed over a specified set Ab of abducible atoms. An explanation can be seen as a proper abductively inferred revision for incorporating ! into the knowledge base.</p><p>An SRP S = hM; '; Yi can be modeled in this framework as follows. It is possible to express the entailment problem M j = ' as an inference problem K M j = f(') of a formula f(') from a knowledge base K M in a suitable logic L, where K M describes M and f(') is a translation of ' into L; e.g., L could be transitive closure logic if M is serial (i.e., each state has a successor) and no fairness constraints are present <ref type="bibr" target="#b27">[28]</ref>, or a similar extension of first-order logic with generalized quantifiers in the general case. Following <ref type="bibr" target="#b27">[28]</ref> and similar translations of propositional modal logic into first-order logic, K M can be constructed as a set of literals describing the components of M; the states are constants, ground literals R(s; s 0 ) describe the transition relation, and ground literals P a (s) represent the label function, where P a (s) means that a 2 L(s), for each atom a 2 A(M).</p><p>Now choose Ab to be the set of all ground atoms on R, and let the domain theory be empty.</p><p>Furthermore, let us restrict acceptable abductive explanations to formulas which are conjunctions of literals.</p><p>Then, an acceptable abductive explanation for the formula f(') according to K M and any reasonable revision operator (see <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b24">25]</ref>), is a conjunction of ground literals on R. Any such corresponds to a set ? 2 mod(M) as follows: For each positive literal R(s; s 0 ) in , the tuple hs; s 0 ; +i is in ?, and for each negative literal :R(s; s 0 ) in , the tuple hs; s 0 ; ?i is in ?. If ? is admissible, then it is a solution of S; call admissible in this case. Vice versa, each solution ? of the SRP S corresponds to an admissible explanation in the same way. Thus, there is a one-to-one logical correspondence between admissible explanations of f(') and solutions ? of S. In particular, modulo Y the minimal solutions of S correspond to the most general admissible explanations , i.e. any admissible explanation 0 with j = 0 satisfies 0 j = . The disjunction of all these is an abductive explanation, provided satisfies some property <ref type="bibr" target="#b32">[33]</ref>, and amounts to the collection of all minimal solutions of S.</p><p>Thus, an SRP can be modeled as (slightly constrained) abductive revision problem as described in <ref type="bibr" target="#b32">[33]</ref>. <ref type="foot" target="#foot_0">1</ref> We remark that in the above modeling, the domain theory is empty. Of course, we could have set to the part of K M not involving R, but this would not make a difference. Moreover, in some cases the admissibility function Y can be easily expressed in the domain theory. SRP in Inoue and Sakama's framework. In <ref type="bibr" target="#b28">[29]</ref>, an extended form of abduction is proposed, which is employed for an abductive framework of nonmonotonic theory change. The framework is detailed for autoepistemic logic, but it can be analogously based on other logics as well. In this approach, an abductive framework is a pair hT; Hi of theories T and H, where T is the background theory (containing domain and factual knowledge) and H is a set of generic hypotheses; an explanation for a formula given hT; Hi is a pair (I; O) such that I and O are instances of formulas in H, (T I) n O logically entails , and (T I) n O is consistent. An explanation (I; O) is minimal, if every explanation (I 0 ; O 0 ) with I 0 I and O 0 O is identical to (I; O).</p><p>The salient point in Inoue and Sakama's concept of abductive explanation is that formulas may also be removed from the background theory T, rather than only added. This is motivated by their observation that in a nonmonotonic context, it may be necessary to remove formulas from T in order to find an explanation for a formula . Observe that removal of formulas from T is accomplished in the framework of <ref type="bibr" target="#b32">[33]</ref> implicitly through the revision operator .</p><p>An SRP S = hM; '; Yi can be modeled in Inoue and Sakama's framework as follows. As described above, the entailment problem M j = ' can be expressed as an inference problem K M j = f(') in a suitable logic L (e.g., transitive closure logic). If we take K M as background theory T and the set fR(x; y); :R(x; y)g as generic hypotheses H, then the solutions of S naturally correspond to the explanations of = f(') obtained from hT; Hi as follows.</p><p>If ? is a solution of S, then the pair (I S ; O S ) is an explanation of , where I S = fR(s; s 0 ) j (s; s 0 ) 2 ? + g f:R(s; s 0 ) j (s; s 0 ) 2 ? ? g; O S = f:R(s; s 0 ) j (s; s 0 ) 2 ? + g fR(s; s 0 ) j (s; s 0 ) 2 ? ? g:</p><p>On the other hand, if (I; O) is an explanation of , then the set ? (I;O) = fhs; s 0 ; +i j R(s; s 0 ) 2 I n Og fhs; s 0 ; ?i j :R(s; s 0 ) 2 I n Og is a solution of S, provided ? (I;O) is admissible in terms of Y. Notice that this establishes a natural one-to-one logical correspondence between minimal solutions and minimal admissible explanations, where the admissible explanations (I; O) are those such that ? (I;O) is admissible. As in the previous case, the admissibility function Y may be expressed in some cases in the background theory T.</p><p>Some further remarks are in order. Firstly, the above translation includes negative literals :R(s; s);</p><p>for each pair of states s; s 0 such that there is no transition from s to s 0 . Of course, one could use the closed world assumption (CWA) on the set of positive literals R(s; s 0 ) and obtain the same effect. However, this would blur the fact that the transition relation R in a Kripke structure M is completely specified, i.e., it is known whether a transition from s to s 0 exists or not. Secondly, for minimal explanations (I; O), it holds that I n O = I, and I = f L j L 2 Og, where L denotes the opposite of the literal L. In general, solutions can also be expressed in terms of O nI as follows.</p><p>For an explanation (I; O) of , define ? (O;I) = fhs; s 0 ; +i j :R(s; s 0 ) 2 O n Ig fhs; s 0 ; ?i j R(s; s 0 ) 2 O n Ig:</p><p>Then ? (O;I) is a solution, provided it is admissible in terms of Y. In particular, we get again a oneto-one logical correspondence between minimal solutions and minimal admissible explanations as above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Repair of Concurrent Programs</head><p>In this section, we apply the model from above to concurrent programs and protocols. A concurrent program consists of a number of processes running in parallel. In <ref type="bibr" target="#b38">[39]</ref>, propositional temporal logic is used for representing specifications for concurrent programs and for defining a technique to verify such a specification. We adopt Pnueli's model <ref type="bibr" target="#b38">[39]</ref> for representing concurrent programs, in order to have a clear and synthetic way of representing the semantics of concurrent programs. We then define the FC-Kripke structure of a concurrent program under the assumption that shared variables have a boolean domain. The transition relation is defined referring to an asynchronous model with interleaving <ref type="bibr" target="#b35">[36]</ref>. Specifications for the program are described by using both CTL formulas and fairness constraints. Fairness constraints allow to express properties that must be verified infinitely often along paths (which are not expressible in CTL). Such properties are frequently required in the context of concurrency, e.g., for the fair scheduling of processes.</p><p>Consider then the FC-Kripke structure of a concurrent program P; denote this structure by M F (P). Let ' be a CTL formula comprising all specifications required for P. Suppose that ' is not satisfied, that is M F (P) 6 j = '. The problem of modifying the original program in order to make ' true is nontrivial.</p><p>In this section, we deal with this issue under particular assumptions about error types. In particular, we address the cases in which errors are faulty assignments and disordered successive assignments. We show that this problem has a direct mapping into the system repair problem from the previous section. Determining a program repair and optimization issues will be dealt with in subsequent sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Concurrent programs and FC-Kripke structures</head><p>A concurrent program P is composed of a finite collection P 1 ; : : : ; P n of processes running in parallel. We refer to a model with shared memory; hence, all variables x 1 ; x 2 ; : : : ; x l in P, which we denote by x, are accessible to all processes.</p><p>According to Pnueli's model <ref type="bibr" target="#b38">[39]</ref>, each process P i can be represented by a directed labeled graph G(P i ) = hN i ; E i i, the graph of P i , where N i is the set of nodes and E i is the set of labeled directed edges.</p><p>The nodes N i are an initial segment 1; 2; : : : ; m i of the integers. They represent the break points in the code of P i , which are the points before the code and between successive statements in ascending order. We denote by stmnt P (i; b) the statement immediately after break point b in the code of P i ; if clear from the context, P and i are omitted. The code between two subsequent break points is considered atomic in the parallel execution.</p><p>We suppose that the following types of statements are available:</p><p>(1) empty statement, denoted by ;</p><p>(2) assignment statement: x i := g(x), where g(x) is an expression over variables in x compatible with the type of x i ;</p><p>(3) jump statement: gotobreak point;</p><p>(4) conditional statement: if c(x) thenstmnt, where c(x) is a boolean expression over variables in x; and, (5) compound statement: begin stmnt-1; . . . stmnt-n end .</p><p>In order to assure that each process P i is nonterminating (that is usual in this framework), we assume that the last statement of P i is an unconditional jump. An infinite loop b : goto b can easily be added at the end of a process.</p><p>The arcs E i correspond to the possible execution flow of the program. From every break point b, there is at least one arc leading to another break point, depending on the type of stmnt(b). Moreover, each arc a is labeled with a command l(a), which is a pair (c(x); stmnt) of a boolean condition c(x) (the guard) and a statement stmnt, which is either or an assignment. Thus, more than one arc may leave from a node in the graph, reflecting the different execution paths of a process. For convenience, we sometimes omit true and in commands; in particular, () is (true; ). An example of a process graph is shown in Figure <ref type="figure">3</ref>. Figure <ref type="figure">3</ref>: Graph G(P A ) for the process P A from Figure <ref type="figure">1</ref> Remark. The above language for programs is elementary, but can be easily enriched by further types of statements. E.g., conditional statements with else-branches of the form "if c(x) thenstmnt-1 else stmnt-2" or while-loops "while c(x) dostmnt" may be added. Such statements are straightforwardly translated into equivalent sequences of elementary statements using jump-statements as usual. The graph of a process in such a syntactically enriched language is then given by the graph of the transformed program. Alternatively, the process graph could be defined directly, without resorting to a low level transformation; however, the definition becomes more involved. In order to keep the treatment simple, we refrain from explicitly considering an enriched syntax.</p><p>If the program contains also synchronization primitives such as semaphores, the synchronization statement can be easily represented by using guards. For instance, if s is a semaphore, the wait primitive P(s) corresponds to the command (s &gt; 0; s := s ? 1), and the signal primitive V (s) corresponds to (true; s := s + 1).</p><p>Note that for this kind of statement, the disjunction between guards of all arcs leaving a node, i.e., the exit condition from this node, is not necessarily true (different from the previous statements); because of synchronization statements, a process can remain trapped in a node until some condition is verified.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>Now we provide a formal representation of the execution of a concurrent program. Intuitively, the execution of a single process corresponds to a traversal of the process graph driven by the result of the evaluation of the guards and involving all the actions (assignments) defined in the commands labeling arcs. The concurrent execution can be represented as the interleaved execution of all processes under the assumption that any single command is atomic. If we want to faithfully model a possible interference between the fetching and storing of operands, we may have to replace an assignment statement by a chain of assignments <ref type="bibr" target="#b38">[39]</ref>. For example, an assignment x := x 1 or x 2 , where the evaluation of x 1 or x 2 should be not atomic, can be modeled by z 1 := x 1 , z 2 := x 2 ;</p><p>x := z 1 orz 2 , where z 1 and z 2 are temporary variables and evaluating z 1 orz 2 is atomic (see <ref type="bibr" target="#b38">[39]</ref> for a detailed discussion of this topic).</p><p>Formally, a concurrent program P = P 1 ; : : : ; P n can be modeled using FC-Kripke structures as follows. Let x = x 1 ; : : : ; x p be the variables of P, which range over the domains D 1 ; : : : ; D p , resp.</p><p>For each process P i , let N i = f1; 2; : : : ; m i g be the set of its break points.</p><p>Note that specifications for the program are expressed both by CTL formulas and by fairness constraints.</p><p>In what follows, we assume that all variables x i are Boolean. Clearly, the general case of finite domains D i can be modeled with Boolean variables. For each x i , an atomic proposition x d i for each value d 2 D i can be used, corresponding to "x i = d;" alternatively, dlog jD i je many Boolean variables x i;j allow for a binary representation of the value of x i . As observed in <ref type="bibr" target="#b10">[11]</ref>, automatic techniques of model checking can be applied only in the case of small finite domains, due to the resulting size of the state space. E.g., in programs which encode concurrent protocols, variables usually represent control flags, switches, and similar objects whose values are from small discrete domains. Hence, such programs are suitable candidates for verification and repair as developed in the sequel. Definition 4.1 Let P be a program. The FC-Kripke structure M F (P) = (A; S; S 0 ; R; L; F), (the Kripke structure of P, if F is understood), is as follows:</p><p>-set of atomic propositions A. A = Vars B E; where Vars = fx 1 ; : : : ; x p g is the set of all variables in P. B = fb k i j 1 i n; 1 k m i g. For each process P i and possible break point k 2 f1; : : : ; m i g of P i , an atomic proposition b k i exists, which is intuitively true if P i is currently at break point k. E = fe 1 ; : : : ; e n g. The atomic proposition e i tells whether process i was executed in the latest execution step in the system.</p><p>-set of states S. S = N 1 N n D 1 D p f1; : : : ; ng. Hence, a state is a tuple of break points (one for each process, i.e., a state of its execution flow), an assignment to the program variables, and process number. As defined later, the process number tells which process was executed in the last step before reaching this state. Given a state s<ref type="foot" target="#foot_1">2</ref> S, we denote by b(s) the n-tuple of break points appearing in s, by v(s) the p-tuple of values of variables appearing in s, and by ex(s) the last component of s. Given a tuple t, we denote by t i the i-th element of t. Hence, b(s) i is the break point of P i at s, and v(s) i is the value of variable x i at s.</p><p>-set of initial states S 0 . The set S 0 contains only states s such that v(s) i = 1, for all i, i.e., all processes are at their entry break points, and ex(s) = 1. (We arbitrarily choose process number 1, since it is, by the meaning of ex(s), not relevant.) We assume that the states in S 0 are chosen according to a fixed policy which assigns the variables initial values (e.g., value false, or a random value).</p><p>-transition relation R. Intuitively, at state s 1 , one of the processes P k is enabled for traversing the next arc in G(P k ) in the computation.</p><p>A pair (s 1 ; s 2 ) 2 S S belongs to R iff:</p><p>there exists an arc a in G(P ex(s 2 ) ) directed from break point b(s 1 ) ex(s 2 ) to break point b(s 2 ) ex(s 2 ) ; b(s 1 ) i = b(s 2 ) i , for each 1 i n, i 6 = ex(s 2 );</p><p>for the label l(a) = (c(x); stmnt) of arc a, c(v(s 1 )) is true and (i) if stmnt = , then v(s 1 ) = v(s 2 ); (ii) if stmnt is an assignment x i := g(x), then v(s 2 ) j = v(s 1 ) j , for all j 6 = i, and v(s 2 ) i = g(v(s 1 )); denote this by v(s 2 ) = g(v(s 1 )).</p><p>We say that (s 1 ; s 2 ) executes the command (c(x); stmnt), and that s 2 is reached from s 1 by executing stmnt(ex(s 2 ); b(s 1 ) ex(s 2 ) ); notice that for each P k , a unique s 2 is reached from s 1 by executing stmnt(k; b(s 1 ) k ). 2</p><p>-label function L. The label function associates with every state s the set of atomic propositions L(s) = L x (s) L b (s) L ex (s);</p><p>where L x (s) = fx i 2 x;j v(s The transition relation R and the label function L can be readily defined from this and the process graphs for P A (cf. Figure <ref type="figure">3</ref>) and P B . For example, the pair (s 1 ; s 2 ) is in R, where s 1 is such that v(s 1 ) = (7; 8), all variables are false, and ex(s 1 ) = B, and s 2 is such that v(s 2 ) = (8; 8), all variables except turn2B are false, and ex(s 2 ) = A. The labels of the states s 1 and s 2 are L(s 1 ) = fb 7 1 ; b 8 2 ; e B g and L(s 2 ) = fb 8 1 ; b 8 2 ; turn2B, e A g, respectively.</p><formula xml:id="formula_2">) i = trueg, L b (s) = fb v(s) i i 2 B j</formula><p>Plausible fairness constraints for P are F = fe A ; e B g, which guarantee fair scheduling. (Recall that a path satisfies a fairness constraint ' iff ' is true infinitely often on that path. For instance, because of e A process A will be scheduled infinitely often.)</p><p>In the rest of our running example, we adopt this set of constraints for P. 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">The repair problem</head><p>In this section, we consider the problem of repairing a concurrent program P = P 1 ; : : : ; P n . We assume that P with its variables x, a set of fairness constraints F (pure state formulas), the Kripke structure M F (P), and a CTL formula ' on A(M F (P)) are given.</p><p>The correctness of program P refers to M F (P), where the formulas in F encode assumptions on the program execution; "unfair" computation paths are excluded.</p><p>Suppose a formula ' is a formal specification for P, and we have fairness constraints F for P. Then, P fulfills ' iff M F (P) j = '. If P does not fulfill ', we are interested in a change to the code of P such that the modified program P 0 fulfills '. This amounts to a (mostly nontrivial) SRP. Example 4.2 (continued) For P in Figure <ref type="figure">1</ref>, define ' = ' flags ^'crit ;</p><p>where ' flags = î=1;2;V =A;B AG( agiV ! AF: agiV );</p><p>' crit = AG(:(b 12 1 ^b10 2 )) ^AG(:</p><formula xml:id="formula_3">(b 5 1 ^(b 5 2 _ b 11 2 ))):</formula><p>Informally, ' says that in every computation, P V must eventually exit the critical section i after entering it, and that the two processes cannot be simultaneously in a critical section. (E.g., AG(:(b 12 1 ^b10 2 )) in ' crit requires that the processes A and B do not execute the assignments to the variable y, namely instruction 12 of A and instruction 10 of B, at the same time.)</p><p>For F = fe A ; e B g (fair scheduling), M F (P) 6 j = '; this is not immediate. 2</p><p>Since we assumed that errors are present in terms of incorrect assignments or assignments in wrong order, a solution of the program repair problem will be a sequence of assignment modifications and assignment interchanges. An assignment modification may affect each side of an assignment. In particular, it will either Furthermore, a disordering of two statements which are not assignments seems to be a programming error which is less frequent in practice; moreover, considering respective corrections is more involved and restricts the use of optimization techniques we develop later. Therefore, we do not consider the interchange of arbitrary statements.</p><p>Example 4. <ref type="bibr" target="#b2">3</ref> The modification of the program P of Figure <ref type="figure">1</ref>, with the single program correction 1 = h2; 12; l-change( ag1A)i is the program obtained from P by replacing the statement 12 of Process B by the assignment ag1A := false. The 3-tuple h1; 2; swapi is not a correction for P, since the statement 3 of P A is not an assignment. 2</p><p>A complex correction for P is a sequence of single corrections. The modification of P by a complex correction is obtained by applying the single corrections in order.</p><formula xml:id="formula_4">Definition 4.4 Let = 1</formula><p>q be a sequence of single corrections for P. Then, the modification P of P by the complex correction is recursively defined as the program P 1 q = (P 1 q?1 ) q , if q 1, and as P ; = P if q = 0. The length of the correction , denoted length( ), is the number q of single corrections in it.</p><p>2</p><p>Note that a modification of P by a single correction hk; b; i affects the code of process P k . It induces a change of the graph G(P k ) and, as a consequence, of the FC-Kripke structure associated with P. In case of an assignment correction, the only change in G(P k ) is the label corresponding to the assignment stmnt(b). In case of an assignment interchange, both labels corresponding to stmnt(b) and stmnt(b + 1) are changed. This merely affects the transition relation R of M F (P).</p><p>The following proposition is therefore easily derived by an inductive argument.</p><p>Proposition 4.1 For any correction , the FC-Kripke structures M F (P) and M F (P ) coincide on A, S 0 , S, L, and F.</p><p>(Recall that fairness constraints are fixed.) Since a correction on P only affects R, can be viewed, according to Definition 3.2, as a modification of the system M F (P); there exists a modification ? for M F (P) such that R = R ? . On the other hand, given a modification ? of M F (P), in some cases R ? can be obtained by a correction and considering the new transition relation R .</p><p>Definition 4.5 A correction for P induces a modification ? 2 mod(M F (P)), if R = R ? . Let Y P : mod(M F (P)) ?! ftrue; falseg be the boolean function such that for every ? 2 mod(M F (P)), we have Y P (?) = true if there exists a correction for P such that induces ?, and Y P (?) = false otherwise.</p><p>2</p><p>Note that, by our assumptions, the function Y P is clearly computable.</p><p>Next we define a repair problem P and show how it can be solved in terms of the abductive solution of a SRP from the previous section. Observe that in case P meets the specification, i.e., M F (P) j = ' holds, the empty correction (q = 0 in Def. 4.4), which leaves P untouched, is a repair for R.</p><p>The process of finding an abductive solution is commonly guided by some rationality principle which aims at pruning solutions that are less plausible. In particular, following Occam's principle of parsimony, solutions are pruned which are not free of redundancy, i.e., if it is possible to remove hypotheses while preserving the solution property.</p><p>This criterion is often strengthened by further restricting the preferred solutions to those which have a minimal cost (or, dually, a highest probability); if no cost information is available, solutions containing a smallest number of hypotheses are often selected.</p><p>Following this lead, we adopt as rationality criterion the length of a complex correction.</p><p>Definition 4.8 Given a PRP R = hP; F; 'i, a repair for R is minimal, if there is no repair for R such that length( ) &lt; length( ). 2</p><p>In particular, if P satisfies the specification ', then the empty correction is the unique minimal repair for R.</p><p>Of course, alternative notions of minimal repair could be acceptable. For example, if we view the PRP as the underlying system repair problem, we could have accepted those corrections as minimal repairs such that the system modification ? induced by is minimal in the sense of Definition 3.4. This would require, however, that the user is aware of the formal representation of programs by means of FC-Kripke structures, in order to interpret minimality of repairs in the right terms; moreover, statements in a program are the atomic units of the user language, which suggests that repairs should be understood on the basis of this language. And, finally, notice that at the semantical level, some complex repair might be minimal, while it is not at the syntactical level (e.g., if it contains a sequence of operations which cancel in their effects). Therefore, adopting the notion of minimal repair as in Definition 4.8 is preferable in this particular application.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 4.4</head><p>Consider the PRP R = hP; F; 'i, where P is the program of the running example (Figure <ref type="figure">1</ref>) and ', F are as in Example 4.2. As pointed out in Example 4.2, M F (P) 6 j = '. It is possible to verify that, in this case, there is an error occurring in the second statement of process P A . Indeed, it should read turn1B := true. Hence, the single correction = h1; 2; r-changei is a repair for D. Clearly, since length( ) = 1, it is also minimal.</p><p>2</p><p>Regarding complex corrections, we note that the case of a single error in a program is very relevant in practice. It is frequent and is usually examined first by human trouble shooters as well as many diagnostic systems. And, many such systems are not capable of handling complex errors at all. In the case of a single error, a minimal repair will be a sequence = 1 of length 1, since a single program correction will be sufficient to fix the single error in the program. Hence, we focus with respect to practice on such minimal repairs. Our results for optimization in finding a repair are tailored for this case; they hold, suitably generalized, in the context of complex repairs, but are naturally weaker in effect.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Repairs and Counterexamples</head><p>After having defined the concepts of repair problem and solution, the upcoming issue is how to find a solution for a given problem; a suitable algorithm for this task is desired.</p><p>There is a simple brute force algorithm for solving the repair problem: check for each possible correction whether it is a repair, i.e., whether M F (P ) j = ', in a systematic enumeration of all possible corrections until such a is found; by respecting cancellation effects of single corrections in complex corrections, the search space is finite. Clearly, this algorithm is inefficient in general. Even if we restrict to single correction solution candidates = 1 , quite a number of different tests may have to be made until the desired answer is obtained.</p><p>In order to reduce the number of cases that have to be considered, we develop techniques which restrict the search space by exploiting counterexamples. Informally, a counterexample for a PRP R = hP; F; 'i is a portion of a branching computation tree which witnesses that ' fails. Given a counterexample, our technique identifies corrections under which the counterexample is invariant, i.e., still apply if is implemented. Such 's are useless as corrections and can be discarded. It happens that this way, the space of candidate repairs may be drastically reduced.</p><p>Our concept of counterexample extends the one presented in <ref type="bibr" target="#b10">[11]</ref> for the purpose of (symbolic) model checking in the logic ACTL, which is a fragment of CTL. There, a procedure for counterexample construction is outlined (see also <ref type="bibr" target="#b13">[14]</ref>), which returns as a result a single path in M. This path is in general not a counterexample per se, but rather a heuristically selected path from a counterexample tree which gives some intuition why the formula fails. The main reason for restricting the return value to a single path is that understanding counterexample trees (and to represent them graphically) seems to be difficult. <ref type="foot" target="#foot_2">3</ref>As shown below, there are simple formulas in ACTL for which no single path is a counterexample. This is due to the possible presence of nested path quantifiers and disjunction in a formula '. A single path from the counterexample tree, as returned by a model checking or symbolic model checking procedure, or even the full counterexample tree represented in the customary way might not be much instructive why a formula fails. The reason is that important structural information about the paths in a simple tree representation is missing, namely how they are nested.</p><p>For our purposes, a full counterexample tree is needed, because otherwise a repair of the program may not be found. In order to overcome the representational problem with counterexample trees, we introduce the concept of a multi-path, which allows for a structured representation of paths. Counterexamples are then particular multi-paths. Our formalization of counterexamples seems to be an appropriate extension of path counterexamples as described in <ref type="bibr" target="#b10">[11]</ref>. In fact, while an ACTL formula may lack a path counterexample, there always exists a multi-path counterexample if it fails on a Kripke structure.</p><p>In the remainder of this paper, we restrict our attention to the fragment ACTL of CTL. In this fragment, only universal path quantifiers are allowed, and negation is restricted to pure state formulas. <ref type="foot" target="#foot_3">4</ref>For instance, the specification ' in our running example (see Example 4.2) is an ACTL formula; however, the formula = EF(turn1B ^:turn2B), which states that there is some computation such that turn1B is true and turn2B false at some point, is not an ACTL formula. Notice that ACTL is considered to be an important and highly relevant fragment of CTL, as it allows for abstraction and compositional reasoning <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b25">26]</ref>. Moreover, we assume in the following that fairness constraints in FC-Kripke structures are pure state formulas.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Counterexamples</head><p>Informally, a multi-path represents an infinite tree T, by using a vertical axis rather than the usual recursion from a node to its descendants. The branches of T are infinite paths; the axis is a distinguished main path of the tree, from which other paths spring off. These paths are main paths of subtrees of T. This view gives rise to an inductive definition of multi-paths. The main advantage of this concept is preservation of the nesting of paths, which is lost in the usual tree definition. Moreover, for a class of multi-paths which is sufficient for our purposes, effective finite representations exist.</p><p>Preliminary to the formal definition of multi-paths, we introduce multi-sequences.</p><p>Definition 5.1 Let S be the set of states. Then, for every state s 2 S, = s is a finite multi-sequence in S;</p><p>if 0 ; 1 ; : : : are countably infinite many multi-sequences in S, then = 0 ; 1 ; : : :] is a multi-sequence in S. For any multi-sequence , its i-th element is denoted by (i), for all i 0; moreover,</p><formula xml:id="formula_5">its depth is d( ) = ( 0, if = s, sup i 0 d( (i)) + 1; otherwise;</formula><p>and its origin is or( ) = ( (0); if = s, or( (0)); otherwise.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>Next we introduce the notion of main sequence of a multi-sequence. Informally, it is the sequence formed by the origins of all elements in a multi-sequence. Definition 5.2 Given a multi-sequence , the main sequence of , denoted by ( ), is s, if = s is finite; the sequence or( (0)); or( (1)); or( (2)); : : :], otherwise.</p><p>2</p><p>Multi-paths are multi-sequences which model nested paths in M.</p><p>Definition 5.3 A multi-sequence is a multi-path in M, if either is finite, or ( ) is a path in M and for every i 0, (i) is a multi-path in M. A multi-path is fair, if is finite or if is infinite and ( ) is a fair path and every (i) i 0, is a fair multi-path.</p><p>The main sequence of a multi-path is called the main path of .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>Here, a single state is considered as a fair multi-path, which turns out to be technically convenient later.</p><p>Note that multi-paths generalize paths. Indeed, a path can be seen as an infinite multi-path such that each element (i) is a state. Fairness of paths is generalized accordingly.</p><p>An infinite multi-path represents intuitively an evolving computing tree, whose branches are the main path ( ) and all paths of form 0 1 where 0 = ( )(0); : : : ; ( )(i ? 1) is a finite prefix of ( ) and 1 is a branch of the multi-path (i), where (i) must be infinite.</p><p>Example 5.1 Assuming proper M, the multi-sequence = s 0 ; s 1 ; s 1 ; : : :]; s 2 ; s 2 ; : : :] is a multipath, which represents two paths 1 = s 0 ; s 1 ; s 1 ; : : :] and 2 = s 0 ; s 2 ; s 2 ; : : :] starting at s 0 (Figure <ref type="figure" target="#fig_4">4</ref>). 2 is the main path ( ) of . The multi-path = s 0 ; s 1 ; s 1 ; : : :]; s 2 ; s 0 ; s 1 ; s 1 ; : : :]; s 2 ; s 0 ; s 1 ; s 1 ; : : :]; : : :] has main path ( ) = s 0 ; s 2 ; s 0 ; s 2 ; : : :] and represents the computation tree in which from ( ) at every even state number a path s 0 ; s 1 ; s 1 ; : : :] branches off; hence, contains besides ( ) all paths of form (s 0 ; s 2 ) i ; s 0 ; s  An important note is that in general, a multi-path may not directly reflect in its structure a truly branching computation tree. In fact, the definition allows fake branching, in the sense that two nested branching paths may amount to the same path in the structure. For example, in the multi-path = s 0 ; s 1 ; s 2 ; s 3 ; s 4 ; : : :]s 3 ; s 4 ; : : :], the branch s 2 ; s 3 ; s 4 ; : : : is identical to the remainder of the main path s 2 ; s 3 ; s 4 ; : : :. This is not a shortcoming of our definition, but an important feature; it allows to express that a particular path is a subpath of another one. In an extended vocabulary for multi-paths, this could be expressed more elegantly; however, we disregard such an extension here.</p><p>We are now prepared to formalize the notion of counterexample. Intuitively, a counterexample for a formula ' is a multi-path originating at an initial state such that ' is not true along . Since counterexamples are defined inductively, we need the concept of a local counterexample, which may origin at an arbitrary state rather than only at an initial state. For the technical definition of local counterexamples, we use an operation for merging two multi-paths into a single one.</p><p>Definition 5.4 Let 1 and 2 be two multi-paths such that or( 1 ) = or( 2 ). The merge of 1 and 2 , denoted by 1 2 , is the multi-path recursively defined as follows: </p><formula xml:id="formula_6">1 2 = 8 &gt; &lt; &gt; : 1 ; if 2 is finite; 1 ; 2 (</formula><p>Intuitively, the trees represented by 1 and 2 are merged at their common root.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 5.2 Merging</head><p>= s 0 ; s 1 1 ; s 1 2 ; : : :]; s 2 1 ; s 2 3 ; : : :] and 0 = s 0 ; s 3 1 ; s 3 2 ; : : :] yields 0 = ; s 3 1 ; s 3 2 ; : : :] = s 0 ; s 1 1 ; s 1 2 ; : : :]; s 2 1 ; s 2 2 ; : : :]; s 3 1 ; s 3 2 ; : : :]; while 0 = 0 s 0 ; s 1 1 ; s 1 2 ; : : :]; s 2 1 ; s 2 2 ; : : :] = 0 ; s 1 1 ; s 1 2 ; : : :]; s 2 1 ; s 2 2 ; : : :] = s 0 ; s 3 1 ; s 3 2 ; : : :]; s 1 1 ; s 1 2 ; : : :]; s 2 1 ; s 2 2 ; : : :]:</p><p>These merges essentially represent the same branching of three paths i = s 0 ; s i 1 ; s i 2 ; : : :] for i = 1; 2; 3, starting from s 0 . 2</p><p>Note that merging 1 and 2 by adding 1 as first element to 2 does not work, since in general, this leads to a set of paths different from those in 1 and 2 ; the result may even not be a multi-path.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 5.5</head><p>Let M be a FC-Kripke structure and ' be an ACTL formula on A(M). A multi-path in M is a local (l-) counterexample for ' if, depending on the structure of ', the following holds:</p><p>if ' is a pure state formula: = s is a state and M; s 6 j = ';</p><p>otherwise, if 1. ' = A(' 1 U' 2 ): is an infinite fair multi-path and either 1.1 there exists k 0 such that (k) is an l-counterexample for ' 1 _ ' 2 , (i) is an l-counterexample for ' 2 , for each 0 i k, and (j) is a state, for j &gt; k; or 1.2 (i) is a l-counterexample for ' 2 , for each i 0;</p><p>2. ' = A(' 1 V' 2 ): is an infinite fair multi-path and there exists a k such that every (j), 0 j &lt; k, is an l-counterexample for ' 1 , (k) is an l-counterexample for ' 2 , and every (`) is a state, for `&gt; k;</p><p>3. ' = AX' 1 : is an infinite fair multi-path, (1) is an l-counterexample for ' 1 , and (i) is a state, for each i 6 = 1; 4. ' = ' 1 _ ' 2 : = 1 2 , where i , i = 1; 2, is an l-counterexample for ' i ; 5. ' = ' 1 ^'2 : is an l-counterexample for either ' 1 or ' 2 .</p><p>2</p><p>Recall that M 6 j = ' if there exists an initial state s 0 at which ' is false. Hence, we introduce a notion of "global" counterexample.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 5.6</head><p>Let M be a FC-Kripke structure and ' be a formula on A(M). Any l-counterexample for ' in M such that or( ) 2 S 0 (M) is called a counterexample for ' in M. 2</p><p>Let us consider some examples. (A more involved example appears in Section 6.4.)</p><p>Example 5.3 Let M be the FC-Kripke structure that amounts to the labeled transition graph in Figure <ref type="figure" target="#fig_5">5</ref>, where s 0 is the unique initial state, A = fa 1 ; a 2 g, and F = ;, and consider the formula It holds that M 6 j = ': Along the path = s 0 ; s 1 ; s 1 ; : : :], the atom a 1 is false at each state, which means M; i j = :a 1 , for every i 0, i.e., M; j = G:a 1 . Thus, witnesses the failure of ' in M.</p><formula xml:id="formula_8">' = AFa 1 . s2 s1 L(s1) = fa2g L(s2) = fa1g s0 L(s0) = ;</formula><p>As easily checked, is a counterexample of '.</p><p>Consider next the formula = AGAFa 1 . Also this formula is false on M. Intuitively, this is witnessed by path again. However, from the formal definition, is not a counterexample of , as it does not respect witness paths for the subformula AFa 1 of . The multi-path = s 0 ; s 1 ; : : :]; s 1 ; s 1 ; : : :] is a proper counterexample for according to the definition, as well as any multi-path s 0 ; (s 1 ; ) i ; : : : ; s 1 ; s 1 ; : : :]; s 1 ; s 1 ; : : :], where i 0.</p><p>Finally, also the formula = AFAGa 1 is false in M, and again the path = s 0 ; s 1 ; s 1 ; : : :] shows this. Formally, the multi-path s 0 ; s 1 ; s 1 ; : : :], s 1 ; s 1 ; : : :]; s 1 ; s 1 ; : : :]; : : :] is a counterexample for ; in fact, it is the unique counterexample.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>As mentioned above, in many cases a counterexample for a formula is (essentially) a single path. However, there are cases in which a true computation tree is required. Clearly, M 6 j = ': For every a i , i = 1; 2, there is an infinite path i = s 0 ; s i ; s i ; : : : which never reaches a state at which a i is true; hence, every disjunct AFa i in ' is false. A counterexample for ' is the multi-path = s 0 ; s 1 ; s 1 ; : : :]; s 2 ; s 2 ; : : :], which results by merging the i 's into = ( 1 2 ). Notice that no counterexample for ' exists that is an ordinary path, and that  Figure <ref type="figure">6</ref>, where s 0 is the unique initial state and F = ;. Consider the formula ' = AFAGa. It is easy to verify that M 6 j = '. Indeed, there is a path = s 0 ; s 0 ; : : :] starting from the initial state where always the nested formula AGa does not hold, as, for each i 0, there exists a path starting at (i) where sometimes a is not true (e.g., on the path s 0 ; s 1 ; s 2 ; s 2 ; : : :] a is never true).</p><p>The multi-path = s 0 ; s 1 ; s 2 ; s 2 ; : : :]; s 0 ; s 1 ; s 2 ; s 2 ; : : :]; : : :] is a counterexample for '.</p><p>Note that no single path is a counterexample for '. Indeed, for each i 0, the suffix i of a counterexample path for ' must be a witness of :AGa = EF:a. Thus, s 1 must occur in i . Now, every (single) path in M has a suffix cycle which involves either s 0 or s 2 . Therefore, for each path there exists k 0 such that either (i) = s 0 for each i k, or (i) = s 2 for each i k.</p><p>Because a is true in both s 0 and s 2 , no path can witness the falsity of AGa.</p><note type="other">2</note><p>Besides the above very simple examples, many other cases can be found in which any counterexample is a truly branching computation tree. They include formulas of form AF(AG' _ AG:'), which informally state that any computation must commit at some point about a condition ', and AF(' _ AG ), which state that at some stage ' is true or, regardless of how the computation proceeds, holds.</p><p>Our next result states that the existence of an l-counterexample for a formula ' at a state s in a FC-Kripke structure M implies that ' is not true at s in M and vice versa. As a consequence, ' is not true in M if and only if there exists a counterexample for '. In fact, a counterexample has as its origin an initial state of the FC-Kripke structure.</p><p>Theorem 5.1 Let M be a FC-Kripke structure, ' a formula on A(M), and s 2 S(M). Then, M; s 6 j = ' if and only if there exists an l-counterexample for ' such that or( ) = s.</p><p>An immediate consequence of the previous proposition is the following. Corollary 5.2 For any FC-Kripke structure M and formula ' on A(M), M 6 j = ' if and only if there exists at least one counterexample for ' in M.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Representation and computation of counterexamples</head><p>Counterexamples are infinite objects, and therefore it is not a priori clear that there is a finite representation for them. Fortunately, it is possible to finitely represent a relevant class of multi-path counterexamples that is sufficient for our purposes, in a similar way as a relevant class of path counterexamples.</p><p>If a path counterexample exists for an ACTL formula ', then a path counterexample exists for ' which is finitely representable <ref type="bibr" target="#b13">[14]</ref>. In particular, it is easy to see that if a path counterexample exists for an ACTL formula ', then a path counterexample exists for ' which consists of a finite prefix (0); : : : ; (k?1) and a finite cycle (k); : : : ; (k+m), such that (`) = (k+f k;m (`)) for all ` k, where f k;m (`) = (`? k) mod m <ref type="bibr" target="#b13">[14]</ref>. Each fairness constraint must be satisfied at least once on this cycle. Thus, such a path counterexample can be represented as a simple expression of the form Pre x(Cycle) 1 over the alphabet of all states.</p><p>For example, the path = s 0 ; s 2 ; s 2 ; s 2 ; ], which loops at state s 2 , can be represented by the expression s 0 ; (s 2 ; ) 1 ], and the path = s 0 ; s 1 ; s 0 ; s 1 ; s 3 ; s 2 ; s 0 ; s 1 ; s 2 ; s 0 ; s 1 ; ], which loops between s 2 ; s 0 , and s 1 , can be represented by s 0 ; s 1 ; s 0 ; s 1 ; s 3 ; (s 2 ; s 0 ; s 1 ; ) 1 ] (if we omit the redundant square brackets and commas, simply by s 0 s 1 s 0 s 1 s 3 (s 2 s 0 s 1 ) 1 ).</p><p>Similarly, if a multi-path counterexample exists for an ACTL formula ', then a multi-path counterexample exists for ' which is finitely representable. To see this, first note that each counterexample is, from its definition, a multi-path whose depth is finite. Using an inductive argument, it can be seen that if a counterexample of certain depth d exists, then a counterexample of depth less or equal d exists which consists of a finite prefix (0); ; (k ? 1) and a (finite) cycle (k); : : : ; (k + m) = (k) such that (`) = (k + f k;m (`)) for all ` k, where again f k;m (`) = (`? k) mod m. This counterexample can be represented as an expression of form Pre x(Cycle) 1 over the alphabet of states and counterexamples of depth smaller d; thus, if we bottom out the representation, it can be represented as a nested expression built over an alphabet of states and paths (or even states alone, if we wish).</p><p>For example, the counterexample = s 0 ; s 1 ; s 1 ; : : :]; s 2 ; s 2 ; : : :] in Example 5.4 can be represented by s 0 (s 1 ) 1 ; (s 2 ; ) 1 ], and the counterexample = s 0 ; s 1 ; s 2 ; s 2 ; : : :]; s 0 ; s 1 ; s 2 ; s 2 ; : : :]; : : :] in Example 5.5 by (s 0 s 1 (s 2 ) 1 ; ) 1 ] (here s 0 (s 1 ) 1 and s 0 s 1 (s 2 ) 1 are the simplified path expressions s 0 ; (s 1 ; ) 1 ] and s 0 ; s 1 ; (s 2 ; ) 1 ], respectively).</p><p>We face now the problem of computing counterexamples and provide a method, based on a procedure of <ref type="bibr" target="#b13">[14]</ref>, for constructing a counterexample. Briefly, given an ACTL formula ' and a state s (which is usually an initial state of the FC-Kripke structure), the procedure described in <ref type="bibr" target="#b13">[14]</ref> produces a single path, starting from s, which demonstrates or hints at the failure of '. In our framework, for most ACTL formulas this single path corresponds to the main path of a counterexample; the structure of a counterexample itself depends on nestings of A in '. For instance, if ' is a pure state formula, then a counterexample for ' in M is simply an initial state; a counterexample for a formula AG' is a path; and, a counterexample for a formula AG(' 1 _ AG' 2 ) consists of two nested paths: the first starts from an initial state, and the second branches off at a certain point of the first. Therefore, if the ACTL formula ' has only one (universal) quantifier, then it admits path counterexamples that can be correctly (and efficiently) computed by using the procedure designed in <ref type="bibr" target="#b13">[14]</ref>. <ref type="foot" target="#foot_4">5</ref>Formulas with more than one universal quantifier do not admit, in general, path counterexamples (see Examples 5.4 and 5.5) and the procedure of <ref type="bibr" target="#b13">[14]</ref> cannot be employed to compute counterexamples of such formulas (as it computes simple paths; while branching multi-paths are required). A suitable extension of the algorithm of <ref type="bibr" target="#b13">[14]</ref> is needed for computing multi-path counterexamples in the general case.</p><p>Examples 5.4 and 5.5 show the two basic sources that imply the need of multi-paths in counterexamples: disjunction and nested quantifiers. Multi-path counterexamples of a formula consisting of the disjunction of atomic (i.e., with one quantifier) ACTL formulas, say ' = AFa 1 _ AFa 2 , can be computed very easily: (i) compute an initial state, say s 0 , on which ' = AFa 1 _ AFa 2 is false (e.g., by computing the suitable fixpoint for the negation of ', i.e., EG:a 1 ^EG:a 2 ); (ii) call the procedure of <ref type="bibr" target="#b13">[14]</ref> on AFa 1 and on AFa 2 with s 0 as the initial state; (iii) create the multi-path counterexample for ' by merging the two path counterexamples for AFa 1 and AFa 2 , respectively, returned by the procedure. The computation of multi-path counterexamples of ACTL formulas with nested quantifiers is harder and requires a recursive extension of the procedure of <ref type="bibr" target="#b13">[14]</ref>. A naive way to make this extension is to recursively call (top-down on the structure of the formula) the procedure of <ref type="bibr" target="#b13">[14]</ref> to build the counterexamples of the nested ACTL subformulas. For instance, a (multi-path) counterexample of the formula ' = AFAGa of Example 5.5 can be computed as follows. Call first the procedure of <ref type="bibr" target="#b13">[14]</ref> on '; this procedure returns a fair path such that, for each integer i, (i) is a state where EF:a is true (i.e., AGa is false). Then, for each integer i, call the procedure again to compute a path counterexample, for AGa starting from (i) (i.e., with (i) as the initial state), say i . The multi-path such that (i) = i is a multi-path counterexample for ' = AFAGa. <ref type="foot" target="#foot_5">6</ref>Other nested ACTL formulas can be treated in a similar way.</p><p>It is worth noting that several optimizations are possible in the computation of counterexamples. Relevant optimizations can be designed by singling out cases of nested ACTL formulas where paths are sufficient to witness the falsity. For instance, AFAF , AGAF , AXAG , AGAG (which is equivalent to AG ), where is a propositional formula, admit path counterexamples. A detailed analysis of the (nested) formulas that admit path counterexamples leads beyond this paper, and is carried out elsewhere <ref type="bibr" target="#b6">[7]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Optimization Techniques for Repair</head><p>In the previous sections, we have introduced the problem of program repair and the concept of counterexample. In this section, we present some optimization techniques which allow to cut the search space for a repair. The techniques utilize counterexamples from above, and are most effective in the case of single correction repairs. An important aspect is that they are efficiently applicable; namely, given a PRP, a counterexample , and a single correction , a sound test whether whether can be discarded as a repair can done in linear time in the size of the input. The basic observation underlying our techniques is that a counterexample must contain certain transitions which prove the failure of a formula '. Any repair must remove these transitions, i.e., avoid that such transitions take place. Thus, if a correction leaves these transitions unchanged, then it can not amount to a repair. By determining such corrections from a counterexample at hand, a number of useless corrections might be excluded. Before we present the particular techniques that we have developed in this spirit, we have to introduce a suitable notion of equivalence between multi-paths. In the rest of this section, P = P 1 ; : : : ; P n is a concurrent program on variables x having a set F of pure state formulas as fairness constraints, and ' is an ACTL formula.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Equivalent multi-paths and weak corrections</head><p>Definition 6.1 For any formula ', we denote by ap(') the set of atomic propositions in '. For any set F of formulas, we denote ap(F) = S '2F ap('). 2 Definition 6.2 Let M and M 0 be two FC-Kripke structures such that F(M) = F(M 0 ), and let</p><formula xml:id="formula_9">A 0 A(M) \ A(M 0 ). Then, (i) states s 2 S(M) and s 0 2 s(M 0 ) are equivalent on A 0 , denoted s A 0 s 0 , if L(M)(s) \ A 0 = L(M 0 )(s 0 ) \ A 0 ;</formula><p>(ii) multi-paths in M and 0 in M 0 , are equivalent on A 0 , denoted A 0 0 , if either (ii.1) both = s and 0 = s 0 are states and s A 0 s 0 , or (ii.2) both and 0 are infinite and (i) A 0 0 (i), for every i 0. 2</p><p>Intuitively, if and 0 are equivalent on A 0 then, for every formula ' with ap(') A 0 , we have that ' is true on if and only if ' is true on 0 . The next proposition is the basis of later results. It states a transfer results for counterexamples between structures: Given a counterexample for a formula ' in M, any multi-path in a structure M 0 that is equivalent to on the variables of ' is a counterexample for ' in M 0 . As a consequence, if M 0 is the result of a repair to the FC-Kripke structure of a program M w.r.t. ', it is impossible to find in M 0 a "pattern of behavior" equivalent on ap(') to any counterexample in M. This is captured formally by the next propositions. Proposition 6.1 Let M and M 0 be two FC-Kripke structures which coincide on S; S 0 ; L; and F. Let be an l-counterexample in M for a formula ' on ap(') A(M). If 0 is a fair multi-path in M 0 such that ap(') 0 , then 0 is an l-counterexample for ' in M 0 .</p><p>We next introduce the concept of a weak correction for a counterexample, that singles out corrections that are certainly useless to fix the error (i.e., modifying the concurrent program by any set of weak corrections would not allow to entail the CTL formula at hand). Prior to this, we fix a notation for the variables which are touched by a single correction. For any complex correction = 1 q , let V ( ) = S q i=1 V ( i ). 2 Definition 6.4 Let be a fair multi-path in M F (P) such that or( ) 2 S 0 . A correction for P is called weak w.r.t. , if there exists a fair multi-path 0 in M 0 = M F (P ) such that or( 0 ) 2 S 0 and A 0 0 for A 0 = A(M) ? V ( ). 2</p><p>Intuitively, a weak correction for does not modify the set of formulas holding on (if we see 0 as the "image" of under the correction ), apart from formulas involving propositions in V ( ) (i.e., that are explicitly modified by ).</p><p>The next proposition states that a program repair not involving variables from ' cannot be a weak correction w.r.t any counterexample of '. In fact, if a repair is a weak correction for some counterexample, the modified program will produce the same counterexample for the formula in the modified system. Roughly speaking, counterexamples have to be modified by a correction if we hope to repair the system through it. This result will be utilized later. Proposition 6.2 Let be a repair for the PRP R = hP; F; 'i, such that V ( ) \ ap(') = ;. Then, for every counterexample for ' in M F (P), is not weak w.r.t. . Proof. Towards a contradiction, suppose is a weak correction w.r.t. . Hence, there exists a fair multi-path 0 in M 0 = M F (P ) such that A 0 0 where A 0 = A n V ( ). By hypothesis on ', ap(') A 0 , and thus Proposition 6.1 implies that 0 is a counterexample for ' in M 0 . Hence, by Corollary 5.2, is not a repair for R, which is a contradiction.</p><p>2</p><p>The consequences of this proposition will be exploited in Section 6.3 for optimization issues (where the result is used to prove the main theorem). Intuitively, if we know that a correction is weak w.r.t. a counterexample, then we can discard it from the "candidates" repair, unless it touches explicitly the atomic propositions in ap(').</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Correction execution</head><p>The first optimization method respects whether the counterexample passes through a statement that has been modified; if not, then it is still valid, and the respective correction is ruled out as a repair.</p><p>Informally, given a counterexample and a single correction = hk; m; i, we say that executes if there exists some path in along which process P k passes through the break points affected by . Here, we must take into account that a computation path may pass only through part of them, due to jumps; it could pass break point m but not m + 1.</p><p>We next prove formally that if a correction is a repair, then it must be executed by any counterexample. For that, we must formalize correction execution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Correction exploitation</head><p>We can identify another important property that repairs must verify, and exploit it for further optimization.</p><p>Recall that a correction involves a set of variables, denoted by V ( ). Then, only computations that evaluate some variable in V ( ) can be influenced by the correction . Indeed, the values of variables not in V ( ) and guards of labels in the process graphs can change only if variables whose values are affected by the correction are referenced. A path that does not evaluate variables of V ( ) will be transformed by the correction into an equivalent path on A n V ( ); the same happens to a multi-path. Hence, a further property that a repair must satisfy is that all counterexamples have to evaluate some variable in V ( ). We formalize this intuition next. Definition 6.6 A path exploits a correction = hk; m; i, if there exists an integer i 0 such that the command executed in ( (i); (i + 1)) evaluates<ref type="foot" target="#foot_6">7</ref> some variable in V ( ).</p><p>A multi-path exploits a correction = hk; m; i, if is infinite and, furthermore, either ( ) exploits or there exists an integer i 0 such that (i) exploits .</p><p>A path (resp. multi-path ) exploits a correction = 1 q , if it exploits i for some i = 1; : : : ; q. 2</p><p>The next result states that under certain conditions, any counterexample must exploit a given repair. It is based on the fact that if a path does not exploit a single correction , then we can find a path 0 in the modified structure which is modulo V ( ) equivalent to and starts from any given state equivalent to the initial state of (see Lemma A.1 in the appendix). Theorem 6.8 Let be a repair for the PRP R = hP; F; 'i such that V ( )\(ap(') ap(F)) = ;.</p><p>Then, every counterexample for ' in M F (P) exploits .</p><p>Notice that the condition V ( )\ap(F ) = ; is not much restrictive, since F should be concerned about fair executions (and speak about processes and break points) rather than the value of program variables, which should be done in the specification '. On the other hand, the condition V ( ) \ ap(') = ; is more restrictive, but cannot be removed in general. For example, if ' says that some variable ok must always be committed to true in a computation (AFAGok), a correction of ok := false to ok := true might eliminate all counterexamples, even if no computation references the value of ok.</p><p>An important point is that like correction execution, correction exploitation is a pruning principle which can be applied efficiently. In fact, in the setting of Section 6.2, it is possible to implement correction exploitation in linear time. Proposition 6.9 Given a PRP R = hP; F; 'i, a collection C of complex corrections = 1 q such that V ( ) \ (ap(') ap(F)) = ;, and a counterexample for ', the corrections in C which are not exploited by can be discarded in time O(kPk + kCk + k k), i.e., in linear time.</p><p>where ag1B is always true. The computation goes on such that P B loops between break points 3 and 4, and P A loops between break points 1-3, 5-7, and 14.</p><p>Notice that starting from s 1 , not all computation paths are wrong. Indeed, for each state in which ag1A is false, P B could go beyond break point 3 into the critical section.</p><p>Suppose then an oracle for a counterexample (e.g., a call to a procedure) returns the following multi-path , which formally represents the intuitive computation from above: s 0 ; s 1 ; s 2 ; s 3 ; s 4 ; s 5 : : : ; s 14 ; s 15 ; s 5 ; : : : ; s 14 ; : : :]; s 5 ; : : : ; s 14 ; s 15 ; s 5 ; : : : ; s 14 ; : : :] here, the branching path and the remaining main path are identical; i.e., the branching path is a subpath of the main path, and thus intuitively amounts to a single path. Note that can be represented, using the scheme in Section 5.2, by the expression s 0 ; s 1 ; s 2 ; s 3 ; s 4 (s 5 s 15 ) 1 ; (s 5 ; : : : ; s 15 ; ) 1 ]. Now let us look for a repair for this program, where we assume that a single error is present and thus focus on single correction repairs, with possible further restriction to particular correction types.</p><p>Then, the naive repair approach considers in P A the assignments after break point i 2 f1; 2; 6; 8; 9; 13g and in P B after break point j 2 f1; 2; 6; 7; 12; 13g.</p><p>For simplicity, let us first consider single statement repairs which change right hand sides of assignments. Then, our optimization technique allows us to restrict by Theorem 6.6 attention in P A to i 2 f1; 2; 6g and in P B to j 2 f1; 2g; the other assignments (8,9,13 in P A and 6,7,12,13 in P B ) are not executed by . Thus, only 5 out of 12 candidate repairs remain to be considered. In case of arbitrary single assignment repairs, also the left hand side of some of these five candidate statements may be changed; in principle, there are 5 possibilities for each change since there are six control variables agiA, agiB and turniB, i = 1; 2. However, only ag1A, ag1B, and turn1B are referenced along . Applying Theorem 6.8, we thus can exclude any correction which changes a left hand side to turn2B, leaving 4 possibilities for each change. However, knowing that the conjunct AG( ag1B ! AF: ag1B) of ' fails, applying Theorem 6.8 again this number can be cut down to two possibilities for each change. Thus, taking also right hand changes into account, in total (2 + 1) 5 = 15 out of 6 12 = 72 candidate repairs remain. Finally, if also assignment interchange is considered, then applying Theorem 6.6 we obtain that 15+2 = 17 out of 72+5 = 77 candidate repairs remain (only the interchange of 1,2 in P A and 1,2 in P B , respectively, is executed by ).</p><p>Apparently, a single correction repair for P is = hA; 2; i where = r-change, i.e., statement 2 in P A is changed to turn1B := true. Indeed, the modified program P does not enable P B to loop forever between 3 and 4. 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Further optimization</head><p>The utilization of correction execution and correction exploitation in an algorithm for computing a program repair is shown in Figure <ref type="figure" target="#fig_9">7</ref>. The call counterexample(M F (P); ') in line 4 returns a counterexample for ' and assigns the conjunct of ' which is falsified by (in case ' is not a conjunction, is assigned '.) Algorithm S-REPAIR Input: PRP R = hP; F; 'i and FC-Kripke structure M F (P).</p><p>Output: Repair of length 1 for R, if one exists; "no", otherwise.</p><p>1: if M F (P) j = ' then  Of course, further and stronger optimization techniques are imaginable, which may give rise to other elseif clauses before line 10, but they may come at a higher computational price which must be paid for analyzing the structure of P, ', and the counterexample .</p><p>For example, the exploitation technique from Section 6.3 can be sharpened by incorporating that the counterexample must actually "see" the effect of a single correction , rather than only referencing a variable x i in V ( ); it might well happen that the value of x i is overwritten before it is referenced, and thus the correction is not useful, provided that it does not directly affect the program specification or fairness constraints.</p><p>For an illustrating, simple example, consider the following (part of a) process:</p><p>1 : x := true; 2 : y := false; 3 : x := y;</p><p>4 : z := notx;</p><p>. . .</p><p>Here, a correction of stmnt(1) to x := false is not "seen" by the program; likewise, a correction of stmnt(1) to y := true is not seen by the program. Thus, these corrections of the program are useless and can be discarded (provided that they do not directly affect the specification or fairness constraints). For a single right side modification, we can say that a computation path sees this correction, if</p><p>1. it evaluates at some point k the variable, say x, of the left hand side of the corrected statement, 2. at some point j k the corrected statement was executed, and, 3. between j and k no assignment to x was made.</p><p>Thus, it is guaranteed that at point k after the execution of the corrected statement, the computation path experiences the effect of the correction (either by evaluating x in an if condition or by using it in the right hand side of an assignment). If no path of a counterexample sees the correction, than it is useless (if it does not interfere with the specification or the fairness constraints). Importantly, the test whether a counterexample sees a correction is efficiently possible, given the counterexample representation that we have outlined in Section 5.2. For assignment swaps and complex corrections, the formalization of strong exploitation is similar, but it is more involved and also may have higher evaluation cost.</p><p>Another important optimization issue is the investigation of more sophisticated techniques for pruning the search space by using counterexamples. Connected with this is an optimized procedure for counterexample construction. So far, we were satisfied by having any counterexample which proves that a formula fails on a structure. However, in order to locate an error and to find a suitable repair, some counterexamples are obviously more useful than others. For example, if a counterexample references a single variable during its execution and another counterexample 0 references all variables, then might be preferable since it allows to attribute the error to fewer statements than 0 . Thus, a formal, comparative notion of quality of counterexamples has to be developed, and an optimized counterexample procedure which finds as good counterexamples as possible. This may turn out to be difficult and computationally complex, which calls for appropriate heuristics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6">Complexity issues</head><p>We close this section with some brief comments on the computational complexity of the problems that we have considered, namely deciding whether a program is correct, finding a counterexample, and finding a minimal correction.</p><p>As for checking the correctness of a program P w.r.t. a specification ' under fairness constraints F (i.e., deciding whether the empty correction () is a repair of the PRP R = hP; F; 'i), as shown below this problem is intractable if the input is R but is solvable in polynomial time if R and M F (P) are given for input, since model checking M F (P) j = ' for any CTL formula ' is polynomial in the size of M F (P) and ' [9, 10]. Note that since the FC-Kripke structure M F (P) associated with P and F can have exponentially many states in the size of P and F, a simple reduction of deciding program correctness given hP; F; 'i to model checking M F (P) j = ' does not yield a polynomial time algorithm in general. However, in special cases, e.g. if the number of processes in P and the number of variables in P are bounded by constants, M F (P) is constructible from P and F in polynomial time (recall that all variables are Boolean and thus have a fixed domain size), which means that deciding program correctness given hP; F; 'i is feasible in polynomial time.</p><p>Constructing a counterexample, represented as in Section 5.2, for a given formula ' in a given FC-Kripke Structure may take exponential time in general, but is possible in polynomial time if the nesting depth of the path quantifier A in ' is bounded by a constant; this is a restriction which is met in practice. On the other hand, constructing a counterexample for a formula ' in M F (P) given hP; F; 'i is clearly exponential, even if the nesting depth of A is one: imagine a single process P which increases a counter having n bits from 0 to 2 n ? 1 and then loops forever. The specification ' = AFa, where a is assigned false in the first step and is not modified subsequently by P is violated by the process; any counterexample for ' must involve at least 2 n different states.</p><p>Finally, the problem of finding a repair, given a PRP R = hP; F; 'i for input, is also intractable. This is no surprise, and can be shown by the following simple reduction from the well-known NPcomplete satisfiability problem. Suppose is a pure state formula on atoms a 1 ; : : : ; a n . Let P be the following process: n + 1: goton + 1 Let the specification be ' = AF ; informally, it says that at some point, the formula is satisfied.</p><formula xml:id="formula_10">Process P 1:</formula><p>To achieve this, a correction may change the right hand sides of some assignments from true to false; left side modifications and assignment interchanges are clearly not needed. It holds that the PRP R = hP; F; 'i where P = P and F = ; has a repair-regardless of the underlying initialization policy for program variables-just if the formula is satisfiable. As a consequence, deciding the existence of a repair is NP-hard. Using a second process P 0 which is similar to P but assigns false to all variables a 1 ; : : : ; a n , we obtain that the program P = P; P 0 is correct w.r.t. ' = AG under fairness constraints F = ; (i.e., the empty correction () is a repair for hP; F; 'i), just if is a tautology; this proves intractability of deciding program correctness given hP; F; 'i for input.</p><p>Observe that the FC-Kripke structure M F (P) associated with the program P = P and F from above has exponentially many states in n. Hence, the previous intractability result does not immediately carry over to deciding the existence of a repair if R = hP; F; 'i and M F (P) are given for input. However, it can be shown that deciding the existence of a repair for a given PRP R = hP; F; 'i is NP-hard even if P contains a single process and the number of variables in P is bounded by a constant. Since in this case, M F (P) is constructible from R in polynomial time, it follows that deciding the existence of a repair is also intractable if the input is R and M F (P). Clearly, this implies that also computing a minimal repair is intractable in both settings.</p><p>We leave a detailed exploration of all these complexity issues for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>Model checking, which is successfully used in verifying concurrent systems, appears to be an area which has high potential for applying AI principles. In this direction, we have presented an approach to combine model checking with repair, which has been considered in the area of automated diagnosis. In the course of the formalization of this approach, theory revision and abductive reasoning play an important role.</p><p>To our knowledge, our approach to integrate repair into model checking is novel. Notice that automated diagnosis and repair of programs was investigated e.g. in <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b44">45,</ref><ref type="bibr" target="#b45">46]</ref>. The framework and setting in <ref type="bibr" target="#b14">[15]</ref> (logic programs) is quite different; the approach of <ref type="bibr" target="#b44">[45,</ref><ref type="bibr" target="#b45">46]</ref> is developed for functional programming languages and generates out of a (faulty) program an instance of a modelbased diagnosis problem. This is quite different from our approach, which aims at using techniques and concepts from model checking and combining them with AI principles.</p><p>For a successful integration of repair into the model checking paradigm, we had to extend the notion of a counterexample as described in <ref type="bibr" target="#b10">[11]</ref> formally such that it is technically available on the whole language of ACTL formulas. For this purpose, we have introduced the concept of multi-paths as a suitable formalization of counterexample trees.</p><p>We then have presented optimization techniques which, as demonstrated on an example, may allow for a considerable reduction of the search space for a program repair. These optimization techniques, correction execution and correction exploitation, can be implemented to run efficiently.</p><p>Naturally, not all interesting and relevant issues can be addressed in this paper which introduces our approach, and a number of them must be left for further work.</p><p>We have already discussed some interesting optimization issues in Section 6.5. Another important direction of research concerns the extension of the framework by further types of corrections. The current framework allows for right modifications and left modifications of assignments, as well as the interchange of assignments. A prototype implementation of this and further optimization techniques is planned for the future. Further corrections, e.g. more complex right hand side modifications, could be desirable. Connected with this, an analysis of common errors in concurrent programming or protocol specification would be acknowledged in order to identify relevant errors which our framework should be able to handle.</p><p>Furthermore, it remains to be analyzed how abstract principles for abductive reasoning <ref type="bibr" target="#b33">[34]</ref> can be exploited in this specific application domain, as well as whether abductive algorithms and computational devices developed in AI (e.g., truth maintenance systems) are fruitfully applicable.</p><p>A Appendix: Proofs Theorem 5.1 Let M be a FC-Kripke structure, ' a formula on A(M), and s 2 S(M). Then, M; s 6 j = ' if and only if there exists an l-counterexample for ' such that or( ) = s.</p><p>Proof. The statement clearly holds for pure state formulas, as = s is the desired counterexample. We prove that it holds also for non-pure state formulas ' by structural induction, starting from a pure state formula.</p><p>((=) Suppose then ' is a non-pure state formula, and that is an l-counterexample for ' such that or( ) = s. We have to show that M; s 6 j = '. Consider the following possible cases:</p><p>1. ' = A(' 1 U' 2 ). It holds that M; s 6 j = A(' 1 U' 2 ) if and only if either M; s j = EG(:' 2 )</p><p>or M; s j = E(:' 2 U(:' 1 ^:' 2 )) (cf. Proposition 2.1). is an infinite multi-path and either 1.1 there exists an integer k 0 such that (k) is an l-counterexample for ' 1 _ ' 2 , (i) is an l-counterexample for ' 2 , for each 0 i k, and (j) is a state, for j &gt; k, or 1.2 (i) is an l-counterexample for ' 2 , for each i 0; Let = ( ) be the main path of ; is a fair path. In the case 1:1, M; j = :' 2 U(:' 1 :' 2 ). Indeed, for the state (k) = or( (k)) in , we have M; (k) 6 j = ' 1 _' 2 : either ' 1 _' 2 is a pure state formula, which means (k) = (k), or ' 1 _ ' 2 is not a pure state formula and (k) = 0 00 is the merge of two counterexamples for ' 1 and ' 2 , respectively. By the induction hypothesis, M; (k) 6 j = ' i , for i = 1; 2; it follows M; (k) j = :' 1 ^:' 2 . Moreover, for every i such that 0 i k, the induction hypothesis implies M; (i) j = :' 2 . This implies the claim M; j = :' 2 U(:' 1 ^:' 2 ). As a consequence, M j = E(:' 2 U(:' 1 ^:' 2 ), which means M; s 6 j = A(' 1 U' 2 ). In the case 1:2, we have M; j = G:' 2 . Indeed, the induction hypothesis implies M; (i) j = :' 2 , for every i 0, since (i) is the origin of an l-counterexample for ' 2 .</p><p>2. ' = A(' 1 V' 2 ). Then, is infinite and there exists a k 0 such that (j) is a counterexample for ' 1 , for every 0 j &lt; k, and (k) is a counterexample for ' 2 . Hence, by the induction hypothesis, M; or( (j)) 6 j = ' 1 , for 0 j &lt; k and M; or( (k)) 6 j = ' 2 . Let = ( ) be the main path of . Since or( (i)) = (i), for every 0 i k, and :' 1 , :' 2 are state formulas, it follows that M; j j = :' 1 , for 0 j &lt; k and M; k j = :' 2 . Consequently, M; j = :' 1 U:' 2 , which implies M; (0) j = E(:' 1 U:' 2 ). Since (0) = s and E(:' 1 U:' 2 ) is equivalent to :', it follows M; s 6 j = '.</p><p>3. ' = AX' 1 . is an infinite multi-path, such that (1) is an l-counterexample for ' 1 . Let = ( ) be the main path of . is a fair path. By the induction hypothesis, M; (1) 6 j = ' 1 . Hence, M; s 6 j = '. 4. ' = ' 1 _ ' 2 . There exist two multi-paths 1 and 2 such that = 1 2 , 1 is an lcounterexample for ' 1 , 2 is an l-counterexample for ' 2 , and or( 1 ) = or( 2 ) = s. Hence, by the induction hypothesis, M; s 6 j = ' 1 and M; s 6 j = ' 2 . Therefore, M; s 6 j = '.</p><p>5. ' = ' 1 ^'2 . W.l.o.g, is a counterexample for ' 1 with or( ) = s. By the induction hypothesis, M; s 6 j = ' 1 , hence M; s 6 j = '. (=)) Consider a non-pure state formula ', and suppose that M; s 6 j = '. We have to show that an l-counterexample for ' exists such that or( ) = s.</p><p>1. ' = A(' 1 U' 2 ). It holds that M; s 6 j = ' if and only if either (i) M; s j = E(:' 2 U(:' 1 :'</p><p>2 )) or (ii) M; s j = EG(:' 2 ) (cf. Proposition 2.1).</p><p>In the case (i), there exist a fair path and an integer k 0, such that (0) = s, M; (i) 6 j = ' 2 (i.e., M; (i) j = :' 2 ), for each 0 i &lt; k, and M; (k) 6 j = ' 1 _ ' 2 (i.e., M; (k) j = :' 1 ^:' 2 ). Thus, by the induction hypothesis, for each 0 i k, there exists an l- counterexample i for ' 2 such that or( i ) = (i), and by the induction hypothesis and an argument as in case 4., there exists an l-counterexample k for ' 1 _ ' 2 such that or( k ) = (k). Consider now the multi-sequence = 0 ; 1 ; ; k ; (k + 1); (k + 2); ].</p><p>Clearly, 1 is a fair multi-path and or( 1 ) = s. Indeed, ( ) = , and each element (i) is a multi-path. It is easily seen that is a l-counterexample for ' such that or( ) = s.</p><p>In the case (ii), there exists a path such that (0) = s and M; j = G(:' 2 ); since ' 2 is a state formula, this means M; (i) 6 j = ' 2 , for every i 0. Hence, by the induction hypothesis, there exists an l-counterexample i for ' 2 such that or( i ) = (i), for every i 0. Consider the multi-sequence = 0 ; 1 ; 2 ; ]. Clearly, is a fair multi-path with or( ) = s, and is a l-counterexample for '.</p><p>2. ' = A(' 1 V' 2 ). We have M; s j = E(:' 1 U:' 2 ) by duality of V and U. Hence, there exists a fair infinite path such that (0) = s and M; j = :' 1 U:' 2 . The latter means that there exists a k such that M; j j = :' 1 , for every 0 j &lt; k and M; k j = :' 2 .</p><p>Since ' 1 and ' 2 are state formulas, it follows that M; (j) 6 j = ' 1 for every 0 j &lt; k and M; (k) 6 j = ' 2 . By the induction hypothesis, there exist an l-counterexample j for ' 1 at (j), 0 j &lt; k and a l-counterexample k for ' 2 at (k). Let then be the multi-sequence = 0 ; 1 ; : : : ; k ; (k + 1); (k + 2); : : :]. Clearly, is an infinite fair multi-path and or( ) = s. Hence, is an l-counterexample for ' at s. 3. ' = AX' 1 . If M; s 6 j = AX', then there exists a fair path such that (0) = s and M; (1) 6 j = ' 1 . By the induction hypothesis, there exists an l-counterexample 0 for ' 1 such that or( 0 ) = (1). Hence, the multi-path = (0); 0 ; (2); (3); ] is an lcounterexample for ' such that or( ) = s.</p><p>4. ' = ' 1 _ ' 2 . M; s 6 j = ' implies that M; s 6 j = ' i , for i = 1; 2; therefore, by the induction hypothesis, there exists an l-counterexample i for ' i such that or( i ) = s, i = 1; 2. Consequently, = 1 2 is an l-counterexample for ' such that or( ) = s.</p><p>5. ' = ' 1 ^'2 . W.l.o.g., M; s 6 j = ' 1 ; by the induction hypothesis, ' 1 has a l-counterexample such that or( ) = s, which is a l-counterexample for ' such that or( ) = s. 2 Proposition 6.1 Let M and M 0 be two FC-Kripke structures which coincide on S; S 0 ; L; and F. Let be an l-counterexample in M for a formula ' on ap(') A(M). If 0 is a fair multi-path in M 0 such that ap(') 0 , then 0 is an l-counterexample for ' in M 0 .</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>5 : 13 :</head><label>513</label><figDesc>x := x and y; 5: x := x and y; 6: ag1A := false; 6: ag2B := true; 7: if turn1B then 7: turn2B := false; 8: begin ag2A := true; 8: if ag2A and not turn2B then ag1B := false;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Labeled transition graph</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>if stmnt(b) is or an assignment, an arc b ! b + 1 is present, labeled with (true; stmnt(b)); If stmnt(b) is a jump statement goto p, then an arc b ! p is present, labeled with (true; ); If stmnt(b) is a conditional statement if c(x) thenp: stmnt, where p is a break point, then arcs b ! p and b ! q are present, where q is the first break point after stmnt (note that p = b + 1). The labels of the arcs are l(b; p) = (c(x); ) and l(b; q) = (:c(x)); ), respectively; If stmnt(b) is a compound statement beginstmnt-1; b 2 : stmnt-2; . . . b n : stmnt-n end, then consider b 1 : stmnt-1; . . . b n : stmnt-n, where stmnt-1 inherits its break point b 1 = b from stmnt(b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>g1 B an d tu rn 1B ) (n ot (f la g1 B an d tu rn 1B )) (f la g1 A := fa ls e) (f la g1 A := tr ue ) g2 A := fa ls e) (y := fa ls e) (f la g2 B an d tu rn 2B )) (x := x an d y) (t ur n1 B := fa ls e) (not turn1B) (f la g2 A := tr ue ) (t ur n2 B := tr ue ) (f la g2 B an d tu rn 2B ) (t ur n1 B )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Branching paths</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Labeled transition graph</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Example 5 . 4</head><label>54</label><figDesc>Consider the FC-structure M from Example 5.3, but now the formula ' = AFa 1 _ AFa 2 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 :Example 5 . 5</head><label>655</label><figDesc>Figure 6: Another labeled transition graph</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Definition 6 . 3</head><label>63</label><figDesc>For any single correction = hk; b; i for P, V ( ) is the following set of variables: var(stmnt(k; b))g; if = l-change(x j ); fvar(stmnt(k; b))g; if = r-change; fvar(stmnt(k; b)); var(stmnt(k; b + 1))g; if = swap.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Procedure for finding a single correction repair</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>1 ng, and L ex (s) = fe ex(s 2 ) g E.-fairness constraints F. F is a set of fairness constraints.2 Let us reconsider program P in Figure1and see how an FC-Kripke structure M F (P)for it looks like.The set of states is S = f1; : : : ; 14g f1; : : : ; 14g ftrue; falseg 8 f1; 2g, since both P A and P B have 14 break points, there are eight variables x i in x (x; y, agiV and turniB, where i = 1; 2 and V = A; B), and two process numbers (A = 1 and B = 2, say). Thus, jSj = 14 2 2 8 2 = 100; 352, i.e., there are roughly 10 5 states; among these, there are 2 8 = 256 potential initial states. If we assume that all program variables are false at the beginning of a computation, there is a unique initial state. The set A contains 8 + 2 14 + 2 = 38 atomic propositions: the eight variables of x, the 28 variables b k i , and two variables e A and e B .</figDesc><table><row><cell>Example 4.1</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>A PRP R = hP; F; 'i is also called the program repair problem for P w.r.t. ' under F. The solution of a PRP can be given in terms of a solution to a SRP as follows. Given a PRP R = hP; F; 'i, a solution for R is a solution ? for the SRP S = hM F (P); '; Y P i. A repair for R is any correction for P that induces a solution ? for R.2The following proposition is immediate from Definitions 3.4 and 4.7. For any PRP problem R = hP; F; 'i, a program correction is a repair for R if and only if M F (P ) j = '.</figDesc><table><row><cell>Definition 4.7 Proposition 4.2</cell></row></table><note><p><p><p><p>Definition 4.</p><ref type="bibr" target="#b5">6</ref> </p>A program repair problem (PRP) is a triple R = hP; F; 'i, where P is a concurrent program, F is a set of fairness constraints on A(M(P)), and ' is a formula on A(M(P)).</p>2</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>In fact, Lobo and Uzcátegui work in a finite propositional language; their framework can be extended for the slightly more general setting here.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>If semaphores would be allowed, no such s2 might exist for P k , which means that stmnt(m; k) is not executable at s1.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>K. McMillan, personal communication.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Some authors restrict negation to atoms, which yields formulas in negation normal form (NNF)<ref type="bibr" target="#b25">[26]</ref>. While semantically equivalent, the syntactically larger class is more convenient. Moreover, conversion into NNF is simple.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>Note that this procedure is applicable here, as the Kripke structure of a program has always a total transition relation by construction.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>Note that the path returned by<ref type="bibr" target="#b13">[14]</ref> is finitely represented as a prefix and cycle (see above). Consequently, a finite number of calls to the procedure is sufficient, and the multi-path is finitely represented.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>Note that an assignment statement evaluates the variables appearing in its right hand side; a conditional statement evaluates the variables appearing in its if condition.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_7"><p>Note that also if semaphores would be allowed, stmnt 0 would be executable at 0 (i) as 0 (i) A 0 (i).</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. We would like to thank O. Grumberg, K. McMillan, and S. Campos for their clarifying comments on counterexamples, in particular on how counterexample paths are computed and used in the SMV procedure. Moreover, we are grateful to K. Inoue for his comments on connections between the the system repair problem and the framework presented in <ref type="bibr" target="#b28">[29]</ref>, and to M. Stumptner and F. Wotawa for bibliographic hints on diagnosis of programs. Finally, the authors appreciate the review comments which helped to improve the presentation of this paper. This work was partially supported by the Austrian Science Fund Project N Z29-INF.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>replace the right hand side of an assignment by a constant (true or false), or replace the variable on the left hand side of an assignment by another one.</p><p>Next, we will formally define the notion of program correction. To this end, we introduce some preliminary notation. Definition 4.2 For any assignment statement , we denote by var( ) the variable of the left hand side of and by expr( ) the expression of the right hand side of .</p><p>An assignment is called simple if either expr( ) = true or expr( ) = false. 2</p><p>The next definition formalizes the notion of single program correction, which is an atomic change to the program. A (general) program correction will be then obtained as a sequence of single corrections (which are applied one by one in the specified order). Definition 4. <ref type="bibr" target="#b2">3</ref> A single (program) correction for P is a 3-tuple hk; b; i, where k 2 f1; : : : ; ng is a process number, b 2 N k is a break point of the process P k , and 2 fswap; r-changeg fl-change(x j ) j x j 2 xg, is a modification such that the following holds: if = r-change, i.e., it is a right side modification, then stmnt(k; b) is a simple assignment; if = l-change(x j ), for some variable x j 2 x, i.e., a left side modification, then stmnt(k; b) is an assignment with var(stmnt(k; b)) 6 = x j ; and if = swap, i.e., an assignment interchange, then both stmnt(k; b) and stmnt(k; b + 1) are assignments.</p><p>The modification of P by a single correction = hk; b; i, denoted by P , is the concurrent program obtained from P by changing the code of process P k in the following way: if = r-change (i.e., it is a right side modification), the assignment stmnt P (k; b) is replaced by the assignment var(stmnt P (k; b)) := not(expr(stmnt P (k; b))); if = l-change(x j ) (i.e., it is a left side modification with variable x j ), the assignment stmnt P (k; b) is replaced by the assignment x j := expr(stmnt P (k; b)); if = swap (i.e., it is an interchange modification), the assignment stmnt P (k; b) is replaced by the assignment stmnt P (k; b + 1) and the assignment stmnt P (k; b + 1) is replaced by the assignment stmnt P (k; b).</p><p>2</p><p>Some remarks about the kinds of corrections we consider here are in order. In general, a change on the right hand side of an assignment may involve a new variable or any expression; in lack of any information about which of those changes are meaningful in a particular context, and considering the in general tremendously large number of functionally different expressions, we do not consider such changes here. However, our framework could be extended to handle such modifications as well. Definition 6.5 Let = hk; m; i be a correction. A path executes , if there exists i 0 such that ex( (i + 1)) = k (i.e., the transition from i to i + 1 executes P k ) and, further 2 fr-change; l-change(x j )g and b( (i)) k = m, or = swap and b( (i)) k 2 fm; m + 1g.</p><p>A multi-path executes , if is infinite and, further, either the main path ( ) of executes , or there exists an integer i 0 such that (i) executes .</p><p>A path (resp. multi-path ) executes a correction = 1 q , if it executes i , for some i = 1; : : : ; q. 2</p><p>We note a couple of simple lemmas, which are useful in the proof of the next result. Then is also a path in M F (P ).</p><p>Proof. If does not execute = 1 q , then does not execute any of 1 ; : : : ; q . Thus, by Lemma 6.3, we obtain that is a path in P 1 . By a repeated argument, we obtain that is a path in P 1 i , for every i = 1; : : : ; q. 2 Lemma 6.5 Let R = hP; F; 'i be a PRP for which some repair exists. Then, every counterexample for ' in M F (P) is infinite.</p><p>The next theorem states that, given a PRP R and a repair for it, every counterexample executes . Theorem 6.6 Let be a repair for the PRP R = hP; F; 'i. Then, every counterexample for ' in M F (P) is infinite and executes .</p><p>This result is intuitive; if a counterexample does not touch the statements which have been corrected, the same multi-path will be present in the Kripke structure of the corrected program. As a consequence of Theorem 6.6, while looking for possible repairs, we can rule out a priori any correction that is not executed on a counterexample.</p><p>An important observation is that correction execution can be tested efficiently. In fact, this is possible in linear time if counterexamples are properly represented, e.g. in the scheme of Section 5.2. Proposition 6.7 Given a PRP R = hP; F; 'i, a collection C of complex corrections = 1 q , and a counterexample for ', the corrections in C which are not executed by can be discarded in time O(kPk + kCk + k k), i.e., in linear time.</p><p>Thus, checking for correction execution is a low cost pruning principle which can benefit in reduction of the search space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Example for optimization</head><p>Let us consider an example which demonstrates that by the optimization techniques in Sections 6.2 and 6.3, quite some savings can be gained in finding a repair. Example 6.1 Reconsider the concurrent program P in Figure <ref type="figure">1</ref>, and let ' and F be as in Example 4.2, viz. ' = ' flags ^'crit , where ' flags = V i=1;2; V =A;B AG( agiV ! AF: agiV ) and ' crit = AG(:(b 12 1 ^b10 2 )) ^AG(:(b 5 1 ^(b 5 2 _ b 11 2 ))), and F = fe A ; e B g. As already mentioned, the program is not correct. Therefore, M F (P) 6 j = ' must hold and a counterexample for ' must exist.</p><p>It can be verified that indeed M F (P) 6 j = ': there is a path from an initial state, leading to a state at which ag1B = true, and where another path 0 starts along which ag1B is always true. Thus, the formula EF( ag1B ^EG ag1B) is true, which means that the formula AG( ag1B ! AF: ag1B) is false; since the latter is a conjunct of ', also ' is false. This should give rise to a counterexample. Indeed, consider the following path (we show of each state s i , left to right, the break points for P A and P B , the program variables that are true, and the process lastly executed; in the initial state s 0 , all variables are false): Proof. We proceed by structural induction on ', where at the basis are pure state formulas.</p><p>Basis. ' is a pure state formula. Then = s for some state s and M; s 6 j = '. Since 0 A 0 , by Definition 6.2, 0 = s 0 such that s A 0 s 0 . Hence, L(s) \ A 0 = L 0 (s 0 ) \ A 0 . Thus, M; s 6 j = ' implies M 0 ; s 0 6 j = ' since ' is on A. Consequently, 0 is an l-counterexample for ' in M 0 . Induction. Let ' be a non-pure state formula, let be a l-counterexample for ', and let 0 be a fair multi-path such that A 0 0 . We consider all possible cases for ': <ref type="formula">1</ref>) or (2) must hold:</p><p>1. there exists an integer k 0 such that: a) 0 (k) A 0 (k), where (k) is a l-counterexample for ' 1 _ ' 2 in M. Hence, by Definition 5.5 (k) is both an l-counterexample for ' 1 and for ' 2 in M. Thus, by the induction hypothesis, 0 (k) is both an l-counterexample for ' 1 and for ' 2 in M 0 , and hence also for ' 1 _ ' 2 in M 0 . b) 0 (i) is fair and 0 (i) A 0 (i), where (i) is an l-counterexample for ' 2 in M, for each 0 i k. By the induction hypothesis, 0 (i) is an l-counterexample for ' 2 in M 0 . c) 0 (j), for each j &gt; k, is a state in M 0 as 0 (j) A 0 (j). 2. 0 (i) A 0 (i), where (i) is an l-counterexample for ' 2 , for each i 0. By induction hypothesis, 0 (i) is an l-counterexample for ' 2 in M 0 . Hence, by Definition 5.5, 0 is an l-counterexample for ' in M 0 . 2. ' = A(' 1 V' 2 ). 0 is infinite, and there exists a k 0 such that every (j), 0 j &lt; k, is an l-counterexample for ' 1 , (k) is an l-counterexample for ' 2 , and every (`) is a state, for `&gt; k. Since A 0 0 and ' is on A, by the induction hypothesis 0 (j) is a l-counterexample for ' 1 in M 0 , for every 0 j &lt; k, and 0 (k) is a l-counterexample for ' 2 in M 0 . Moreover, 0 (`) must be a state in M 0 for every `&gt; k. Hence, 0 is a l-counterexample for ' in M 0 .</p><p>3. ' = AX' 1 . Hence, 0 (1) is an l-counterexample for ' 1 . By the induction hypothesis, 0 (1) is an l-counterexample for ' 1 in M 0 . Moreover, due to (i) A 0 0 (i), 0 is infinite and 0 (i) is a state, for i 6 = 1. Therefore, by Definition 5.5, 0 is an l-counterexample for ' in M 0 .</p><p>4. ' = ' 1 _ ' 2 . Suppose w.l.o.g. that ' 1 is a non-pure state formula. Since is an lcounterexample for ' in M, = 1 2 where i is an l-counterexample for ' i in M, i = 1; 2. A 0 0 implies that 0 = 0 1 0 2 such that 0 i A 0 i ; hence, by the induction hypothesis, 0</p><p>i is an l-counterexample for ' i in M 0 , for i = 1; 2. Consequently, 0 is an l-counterexample for ' in M 0 . 5. ' = ' 1 ^'2 . is an l-counterexample in M for either ' 1 or ' 2 . Hence, by the induction hypothesis, 0 is an l-counterexample in M 0 for either ' 1 or ' 2 . Thus, by Definition 5.5, 0 is an l-counterexample for ' in M 0 . 2 Lemma 6.5 Let R = hP; F; 'i be a PRP for which some repair exists. Then, every counterexample for ' in M F (P) is infinite.</p><p>Proof. Towards a contradiction, suppose there exists a single state counterexample = s for ' in M F (P). By Definition 5.6, or( ) = s, and or( ) 2 S 0 (M F (P)). Since M F (P) and M F (P ) for a repair coincide on S 0 and L, clearly is also a counterexample for ' in M F (P ). Corollary 5.2 and Proposition 4.2 imply that is not a repair for R, which is a contradiction. 2 Theorem 6.6 Let be a repair for the PRP R = hP; F; 'i. Then, every counterexample for ' in M F (P) is infinite and executes .</p><p>Proof. Let be a counterexample for ' in M = M F (P). By Lemma 6.5, is an infinite fair multi-path. Towards a contradiction, suppose does not execute . We prove that is also a fair infinite multi-path in M 0 . Hence, is a counterexample for ' in M 0 , which contradicts that is a repair.</p><p>In order to establish this, it suffices to show by induction on k 0 that every fair multi-path of M of depth d( ) k which does not execute is a fair multi-path in M. (Notice that from the definition, counterexample multi-paths have finite depth.)</p><p>Basis. k = 0. In this case, = s is a single state, and is by Definition 5.3 a fair multi-path in M 0 .</p><p>Induction. k &gt; 0. Let be such that d( ) = k. We have to show that (i) the main path ( ) is also a fair path in M 0 , and (ii) (i) is a fair multi-path in M 0 , for every i 0. For (i), we note that ( ) is a fair path in M which does not execute . Therefore, by Lemma 6.4, ( ) is also a path in M 0 . As F(M) = F(M 0 ), clearly ( ) is also fair in M 0 . For (ii), we note that each (i) is a fair multi-path in M which does not execute such that d( (i)) &lt; k, and apply the induction hypothesis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>Lemma A.1 Let = hk; m; i be a correction for P such that V ( ) \ ap(F) = ;. Let be a fair path in M F (P) which does not exploit . Let s 0 be a state such that s 0 A 0 (0), where A 0 = A n V ( ). Let the sequence 0 in M F (P ) be defined by 0 (0) = s 0 , and 0 (i + 1) = s i+1 , for all i 0, where s i+1 is the state reached from 0 (i) by executing stmnt(k i ; `i) in P , k i = ex( (i + 1))), `i = b( (i + 1) k i ). Then, 0 is a fair path and 0 A 0 . Proof. By induction on i, we establish that (i) A 0 0 (i), for all i 0, and ( 0 (i ? 1); 0 (i)) 2 R , i 1; this and the fact that ap(F) A 0 (as ap(F) \ V ( ) = ;) implies 0 (i) j = F iff (i) j = F, i 0. This proves the lemma.</p><p>Basis. For i = 0, this holds by hypothesis on s 0 = 0 (0). Induction. Assume the statement holds for i, and consider i + 1. Since by the induction hypothesis (i) A 0 0 (i), we have b( (i)) = b( 0 (i)), i.e., the executions corresponding to 0 and up to 0 (i) resp. (i) have reached the same break points in all processes. By definition of R, (i + 1) is reached from (i) by executing stmnt(k i ; `i) (for short, stmnt) in process P k , where k i = ex( (i + 1)) and `i = b( (i)) k i . Consider the corresponding statement stmnt(k i ; `i) in P , denoted by stmnt 0 , and let s i+1 be the state reached from 0 (i) by its execution. 8 There are two cases.</p><p>(I) stmnt 0 = stmnt. If stmnt is an assignment, then, since 0 (i) A 0 (i) and stmnt may only evaluate variables in A 0 , the transitions ( (i); (i + 1)) and ( 0 (i); 0 (i + 1)) amount to assigning the same value to the same variable x i ; hence, clearly s i+1 A 0 (i + 1); otherwise, if stmnt is a conditional statement, for the same reason the expression c(x) evaluates to the same at (i) and 0 (i), and hence ( (i); (i + 1)) and ( 0 (i); 0 (i + 1)) amount to executing the branching to the same break point; again, s i+1 A 0 (i + 1).</p><p>(II) stmnt 6 = stmnt 0 . Then, stmnt 0 is a changed statement, which is either due to an assignment modification or an assignment swap. In any case, stmnt and stmnt 0 are assignments x i := g 0 (x) and x j := g(x), respectively, where x i ; x j 2 V ( ), and their executions in P k i and P k , respectively, lead to the same break points. Hence, clearly s i+1 A 0 (i + 1). 2 Proposition 6.7 Given a PRP R = hP; F; 'i, a collection C of complex corrections = 1 q , and a counterexample for ', the corrections in C which are not executed by can be discarded in time O(kPk + kCk + k k), i.e., in linear time.</p><p>Proof. We sketch a possible algorithm with this property. In the first step, all distinct pairs (i); (i+1) are determined such that (i) and (i+1) are successive states in the computation tree represented by . For each such pair, the statement stmnt(k; b) which is executed by the transition from (i) to (i + 1) can be determined easily. In step two, all these statements stmnt(k; b) from step one are marked in P. From the marked program, it is for a single correction = hk; m; i easy to tell by looking up at most two statements in P whether is executed by or not; for a complex correction = 1 q , this is possible by a sequence of lookups for the single i 's. This way, in step three all corrections in C are examined.</p><p>It is not hard to see that computing all pairs (i); (i + 1) is possible by a recursive procedure in linear time. Moreover, the lookup and marking of a statement stmnt(b; k) in P can be done in constant time, provided the representation of P allows for random access to its statements. (A random access structure can be built in linear time; alternatively, a two-dimensional Boolean array</p><p>T can be used where T(k; b) tells whether statement stmnt(k; b) was executed by some transition in .) Thus, also step two can be done in linear time. Since determining whether = 1 q is executed by takes at most 2 q lookups in P, it follows that all complex corrections not executed by can be discarded from C in linear time.</p><p>Note that in the case where C has few and small corrections, i.e., the total number of simple component corrections i occurring in C is bounded by a constant, a natural variant of the algorithm is the following. Steps two and three are replaced by a test for each stmnt(k; b) from step one and correction in CTL whether is executed by by virtue of stmnt(k; b). Each such test is possible in constant time. Observe that the resulting algorithm does not access P at all.</p><p>We finally remark that for inputs where P is not available, O(n log n) algorithms for correction execution are possible by using sorting techniques.</p><p>2 Theorem 6.8 Let be a repair for the PRP R = hP; F; 'i such that V ( )\(ap(') ap(F)) = ;.</p><p>Then, every counterexample for ' in M F (P) exploits .</p><p>Proof. Let be a counterexample for ' in M = M F (P). By way of contradiction, suppose that does not exploit . We prove that is a weak correction w.r.t. , i.e., there exists a fair multi-path 0 in M 0 = M F (P ) such that and 0 are equivalent on A 0 = A n V ( ). Thus, a contradiction arises by Proposition 6.2.</p><p>We show by induction on the depth d( ) of that if is a fair multi-path in M which does not exploit and s 0 is a state such that s 0 A 0 or( ), then there exists a fair multi-path 0 in M 0 such that A 0 0 and or( 0 ) = s 0 . (Notice that, from the definition, every counterexample has finite depth.) In case of the counterexample, choose s 0 = or( ). Basis. d( ) = 0. Then, = s is a state. Clearly, 0 = s 0 is the desired fair multi-path in M 0 . Induction. Consider d( ) &gt; 0. Then, = 0 ; 1 ; : : :] is an infinite multi-path such that ( ) is a fair path which does not exploit and every i is a fair multi-path in M which does not exploit . By Lemma A.1, there exists a path (1) for = 1 such that (1) A 0 1 (0) = ( ),</p><p>where A 0 1 = A n V ( 1 ), (1) (0) = s 0 , and (1) is fair in M F (P 1 ). By repeated application of Lemma A.1, we obtain that for every i = 1; : : : ; q there exists a fair path (i) in M F (P 1 i ) such that (i) A 0 i (i?1) , where A 0 i = A n V ( i ) and (i) (0) = s 0 . It follows that (q) B (0) for B = A n S i V ( i ). Since B = A 0 and (0) = ( ), it follows that the states (q) (i) and ( )(i) satisfy (q) (i) A 0 ( )(i), for every i 0. Hence, by the induction hypothesis, for every i 0 there exists a fair multi-path 0 i in M 0 such that or( 0 i ) = (q) (i) and i A 0 0 i . Let 0 = 0 0 ; 0 1 ; : : :]. It is easily verified that 0 is a fair multi-path in M 0 such that A 0 0 and or( 0 ) = (q) (0) = s 0 . This concludes the induction and the proof of the theorem. 2 Proposition 6.9 Given a PRP R = hP; F; 'i, a collection C of complex corrections = 1 q such that V ( ) \ (ap(') ap(F)) = ;, and a counterexample for ', the corrections in C which are not exploited by can be discarded in time O(kPk + kCk + k k), i.e., in linear time.</p><p>Proof. The algorithm is similar to the one sketched in the proof of Proposition 6.7.</p><p>As there, in the first step all distinct pairs (i); (i+1) are determined such that (i) and (i+1)</p><p>are successive states in the computation tree represented by . In the second step, by a scan through these pairs, the set of variables EV ( ) which are evaluated in at least one transition (i); (i + 1) can be easily determined by referring to the program P. From EV ( ), it is easy to verify whether exploits a single correction by checking whether some x i 2 V ( ) occurs in EV ( ). For a complex correction = 1 q , this can be done analogously by taking V ( ) in place of V ( ).</p><p>Step one is possible in linear time, and also step two can be done in linear time if P is suitably represented, such that random access to its statements stmnt(k; b) is possible; here, multiple examination of a stmnt(k; b) in constructing EV ( ) can be avoided by marking stmnt(k; b) in P after the first access to it.</p><p>Step three is also possible in linear time, by considering the corrections in C one by one. The result follows.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Perspectives in Knowledge Representation</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Aiello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Applied Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="29" to="44" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The Temporal Logic of Branching Time</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ben-Ari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="207" to="226" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">An Abductive Framework for Generalized Logic Programs and Other Nonmonotonic Systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Brewka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Konolige</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IJCAI &apos;93</title>
		<meeting>IJCAI &apos;93</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="9" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Nonmonotonic Reasoning -An Overview</title>
		<author>
			<persName><forename type="first">G</forename><surname>Brewka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dix</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Konolige</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">CSLI Lecture Notes</title>
		<imprint>
			<biblScope unit="volume">73</biblScope>
			<biblScope unit="page" from="65" to="86" />
			<date type="published" when="1997">1997</date>
		</imprint>
		<respStmt>
			<orgName>CSLI Publications, Stanford University</orgName>
		</respStmt>
	</monogr>
	<note>chapter 5: Abduction</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Abduction as Belief Revision</title>
		<author>
			<persName><forename type="first">C</forename><surname>Boutilier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Becher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">77</biblScope>
			<biblScope unit="page" from="43" to="94" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Checking the Correctness of Sequential Circuits</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Browne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1985 International Conference on Computer Design</title>
		<meeting>1985 International Conference on Computer Design<address><addrLine>Port Chester, New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1985-10">October 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">On ACTL Formulas Having Deterministic Counterexamples</title>
		<author>
			<persName><forename type="first">F</forename><surname>Buccafurri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Leone</surname></persName>
		</author>
		<idno>INFSYS RR-1843-99-01</idno>
		<imprint>
			<date type="published" when="1999-01">January 1999</date>
		</imprint>
		<respStmt>
			<orgName>Institut für Informationssysteme ; TU Wien</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Burch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hwang</surname></persName>
		</author>
		<title level="m">Symbolic Model Checking: 10 120 States and Beyond, Information and Computation</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">98</biblScope>
			<biblScope unit="page" from="142" to="170" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Synthesis of Synchronization Skeletons for Branching Time Temporal Logic</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic of Programs: Workshop</title>
		<meeting><address><addrLine>Yorktown Heights, NY</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1981-05">May 1981. 1981</date>
			<biblScope unit="volume">131</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Sistla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="244" to="263" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Verification Tools for Finite-State Concurrent Systems</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Long</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">A Decade of Concurrency -Reflections and Perspectives</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Bakker</surname></persName>
		</editor>
		<editor>
			<persName><surname>De</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">P</forename><surname>Roever</surname></persName>
		</editor>
		<editor>
			<persName><surname>De</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Rozenberg</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">803</biblScope>
			<biblScope unit="page" from="124" to="175" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Model Checking</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Long</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NATO ASI Series F</title>
		<editor>
			<persName><forename type="first">Deductive</forename><surname>Program Design</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Broy</surname></persName>
		</editor>
		<meeting>NATO ASI Series F</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">152</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Model Checking and Abstraction</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Long</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transaction on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1512" to="1542" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Efficient Generation of Counterexamples and Witnesses in Symbolic Model Checking</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhao</surname></persName>
		</author>
		<idno>CMU-CS-94-204</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. 32nd ACM/SIGDA Design Automation Conference 1995 (DAC &apos;95)</title>
		<meeting>32nd ACM/SIGDA Design Automation Conference 1995 (DAC &apos;95)<address><addrLine>Pittsburgh, PA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1994">1994</date>
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Also Technical Report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Model-Based Diagnosis Meets Error Diagnosis in Logic Programs</title>
		<author>
			<persName><forename type="first">L</forename><surname>Console</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Theseider Dupré</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Friedrich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IJCAI &apos;93</title>
		<meeting>IJCAI &apos;93</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="1494" to="1499" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">On the Relationship Between Abduction and Deduction</title>
		<author>
			<persName><forename type="first">L</forename><surname>Console</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Theseider Dupré</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Torasso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic &amp; Computation</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="661" to="690" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Verification of Synchronous Sequential Machines, Based on Symbolic Execution</title>
		<author>
			<persName><forename type="first">O</forename><surname>Coudert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Berthet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Madre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1989 International Workshop on Automatic Verification Methods for Finite State Systems</title>
		<meeting>1989 International Workshop on Automatic Verification Methods for Finite State Systems<address><addrLine>Grenoble, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">407</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The Complexity of Logic-Based Abduction</title>
		<author>
			<persName><forename type="first">T</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="42" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Semantics and Complexity for Abduction from Default Theories</title>
		<author>
			<persName><forename type="first">T</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Leone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">90</biblScope>
			<biblScope unit="page" from="177" to="222" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Temporal and Modal Logics</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Handbook of Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Van Leeuwen</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="995" to="1072" />
			<date type="published" when="1990">1990</date>
			<publisher>Elsevier Science Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Revisited: On Branching versus Linear Time Temporal Logic</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Y</forename><surname>Halpern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="151" to="178" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
	<note>Sometimes&quot; and &quot;Not Never</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Using Branching-Time Logic to Synthesize Synchronization Skeletons</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="241" to="266" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Hypothesis Classification, Abductive Diagnosis, and Therapy</title>
		<author>
			<persName><forename type="first">G</forename><surname>Friedrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Nejdl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. International Workshop on Expert Systems in Engineering</title>
		<title level="s">LNCS/LNAI</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Nejdl</surname></persName>
		</editor>
		<meeting>International Workshop on Expert Systems in Engineering</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">462</biblScope>
			<biblScope unit="page" from="69" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<author>
			<persName><forename type="first">G</forename><surname>Friedrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Nejdl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formalizing the Repair Process -Extended Report</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="187" to="201" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Knowledge in Flux</title>
		<author>
			<persName><forename type="first">P</forename><surname>Gärdenfors</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>Bradford Books, MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Model Checking and Modular Verification</title>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Long</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transaction on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="843" to="871" />
			<date type="published" when="1994-05">May 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName><forename type="first">W</forename><surname>Hamscher</surname></persName>
		</author>
		<title level="m">Readings in Model-Based Diagnosis</title>
		<imprint>
			<publisher>Morgan Kaufman Publ</publisher>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Model Checking and Transitive-Closure Logic</title>
		<author>
			<persName><forename type="first">N</forename><surname>Immerman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Computer Aided Verification (CAV &apos;97)</title>
		<meeting>Computer Aided Verification (CAV &apos;97)</meeting>
		<imprint>
			<date type="published" when="1997">1997. 1997</date>
			<biblScope unit="page" from="291" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Abductive Framework for Nonmonotonic Theory Change</title>
		<author>
			<persName><forename type="first">K</forename><surname>Inoue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ch</forename><surname>Sakama</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IJCAI &apos;95</title>
		<meeting>IJCAI &apos;95</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="204" to="210" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Propositional Knowledge Base Revision and Minimal Change, Artificial Intelligence</title>
		<author>
			<persName><forename type="first">H</forename><surname>Katsuno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">O</forename><surname>Mendelzon</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="page" from="253" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Abduction versus Closure in Causal Theories</title>
		<author>
			<persName><forename type="first">K</forename><surname>Konolige</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="255" to="272" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">O</forename><surname>Kupferman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><surname>Buy One</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Get One Free!! Journal of Logic and Computation</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="523" to="539" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Abductive Change Operators</title>
		<author>
			<persName><forename type="first">J</forename><surname>Lobo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Uzcátegui</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fundamenta Informaticae</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="385" to="412" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Abductive Consequence Relations</title>
		<author>
			<persName><forename type="first">J</forename><surname>Lobo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Uzcátegui</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">89</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="149" to="171" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Model Checking, Abstraction and Compositional Reasoning PhD thesis</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Long</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Symbolic Model Checking: An Approach to the State Explosion Problem PhD thesis</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Hierarchical Verification of Asynchronous Circuits Using Temporal Logic</title>
		<author>
			<persName><forename type="first">B</forename><surname>Mishra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="269" to="291" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Myths About the Mutual Exclusion Problem</title>
		<author>
			<persName><forename type="first">G</forename><surname>Peterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="115" to="116" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">The Temporal Semantics of Concurrent Programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="45" to="60" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">A Logical Framework for Default Reasoning</title>
		<author>
			<persName><forename type="first">D</forename><surname>Poole</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="27" to="47" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">The Utility of Consistency-Based Diagnostic Techniques</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Provan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Poole</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. KR &apos;91</title>
		<meeting>KR &apos;91</meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="461" to="472" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">A Theory of Diagnosis From First Principles</title>
		<author>
			<persName><forename type="first">R</forename><surname>Reiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="57" to="95" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Support Set Selection for Abductive and Default Reasoning</title>
		<author>
			<persName><forename type="first">B</forename><surname>Selman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Levesque</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">82</biblScope>
			<biblScope unit="page" from="259" to="272" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">The Complexity of Propositional Linear Temporal Logics</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sistla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="733" to="749" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Model-Based Program Debugging and Repair</title>
		<author>
			<persName><forename type="first">M</forename><surname>Stumptner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Wotawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Ninth International Conference on Industrial and Engineering Applications of Artificial Intelligence and Expert Systems (IEA/AIE &apos;96)</title>
		<meeting>Ninth International Conference on Industrial and Engineering Applications of Artificial Intelligence and Expert Systems (IEA/AIE &apos;96)<address><addrLine>Fukuoka, Japan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="155" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">A Model-Based Approach to Software Debugging</title>
		<author>
			<persName><forename type="first">M</forename><surname>Stumptner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Wotawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Seventh International Workshop on Diagnosis (DX &apos;96)</title>
		<editor>
			<persName><forename type="first">Val</forename><surname>Morin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Suhayya</forename><surname>Canada</surname></persName>
		</editor>
		<editor>
			<persName><surname>Abu-Hakima</surname></persName>
		</editor>
		<meeting>Seventh International Workshop on Diagnosis (DX &apos;96)</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="214" to="223" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">An Automata-Theoretic Approach to Automatic Program Verification</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wolper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First Annual Symposium on Logic in Computer Science (LICS &apos;86)</title>
		<meeting>the First Annual Symposium on Logic in Computer Science (LICS &apos;86)</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="332" to="344" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
