<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Ur: Statically-Typed Metaprogramming with Type-Level Record Computation</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Adam</forename><surname>Chlipala</surname></persName>
							<email>adamc@impredicative.com</email>
							<affiliation key="aff0">
								<orgName type="institution">Impredicative LLC</orgName>
								<address>
									<settlement>Cambridge</settlement>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Ur: Statically-Typed Metaprogramming with Type-Level Record Computation</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">22BFF14C0CBFDD005B49C0D56FEC86F0</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:19+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.3.2 [Programming Languages]: Applicative (Functional) Programming; F.3.3 [Logics and Meanings of Programs]: Type Structure General Terms Languages</term>
					<term>Reliability</term>
					<term>Security dependent types</term>
					<term>metaprogramming</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Dependent types provide a strong foundation for specifying and verifying rich properties of programs through type-checking. The earliest implementations combined dependency, which allows types to mention program variables; with type-level computation, which facilitates expressive specifications that compute with recursive functions over types. While many recent applications of dependent types omit the latter facility, we argue in this paper that it deserves more attention, even when implemented without dependency.</p><p>In particular, the ability to use functional programs as specifications enables statically-typed metaprogramming: programs write programs, and static type-checking guarantees that the generating process never produces invalid code. Since our focus is on generic validity properties rather than full correctness verification, it is possible to engineer type inference systems that are very effective in narrow domains. As a demonstration, we present Ur, a programming language designed to facilitate metaprogramming with firstclass records and names. On top of Ur, we implement Ur/Web, a special standard library that enables the development of modern Web applications. Ad-hoc code generation is already in wide use in the popular Web application frameworks, and we show how that generation may be tamed using types, without forcing metaprogram authors to write proofs or forcing metaprogram users to write any fancy types.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Dependent types are a technique that is picking up momentum in practical language design. A dependent type system allows types to refer to program variables whose values are not determined until runtime. The classical approach, exemplified by Coq <ref type="bibr" target="#b2">[3]</ref> and Agda <ref type="bibr" target="#b16">[17]</ref>, is based on dependent type theory. These languages combine dependent typing with rich facilities for type-level com-Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. PLDI'10, June 5-10, 2010, Toronto, Ontario, Canada. Copyright c 2010 ACM 978-1-4503-0019-3/10/06. . . $10.00 putation. Types may be computed via calls to recursive functions. This paper is about a very practical application of type-level computation, without dependency, in a system that is still very much inspired by Coq and Agda.</p><p>Until recently, languages with dependent type systems were invariably designed to be usable for full correctness verification. A type system must be quite complex to support that goal. It will almost certainly have undecidable type inference, as well as intractable type inference in practice. Thus, to use such a system to verify serious applications, a programmer must inevitably spend significant effort writing annotations and proofs that exist only to appease the type checker. At the same time, the same language features can be very useful in checking general program validity properties, in a sense more in line with mainstream usage of type systems. By identifying a narrow domain of properties, we can hope to build an effective type inference procedure, without compromising the programmer's ability to employ clever abstractions.</p><p>We suggest metaprogramming in Web applications as one such "killer application." The term "metaprogramming" is used to describe programs that perform code generation, code introspection, or both. In this paper, we restrict our attention to code generation. This will include both heterogeneous metaprogramming, where programs in our Turing-complete language build SQL queries and HTML pages; and homogeneous metaprogramming, where programs in our Turing-complete language generate other such programs. In the latter category, we follow standard ideas from the world of dependent typing, using type-level computation to avoid explicit syntax manipulation. Nonetheless, we achieve the same functionality that is traditionally implemented with code generation.</p><p>The most popular approach to Web application programming today involves usage of frameworks implemented in dynamic languages, including Ruby on Rails<ref type="foot" target="#foot_0">1</ref> and Django<ref type="foot" target="#foot_1">2</ref> . These systems include metaprogramming components to help coders get new Web applications up and running quickly. In some cases, this is ad-hoc generation of source code as strings; in other cases, it is reflectionbased runtime code generation. No matter the details, there is no static checking of code generators. It is easy to have bugs that go uncaught even by systematic testing.</p><p>Lurking bugs in Web code generators are a serious business. One study <ref type="bibr" target="#b6">[7]</ref> found that over 30% of Web applications are susceptible to some kind of code injection attack, where code from an untrusted source is relayed to browsers or database servers through a Web application that does insufficient input sanitization. It is hard enough to treat input securely in a standalone application; it is even harder to write a code generator that never outputs a vulnerable pro-gram. A rich enough static type system can guarantee that metaprograms are valid in this sense.</p><p>For instance, we can model HTML pages and SQL queries with rich abstract syntax tree types. When treating these types as simple strings, it is easy to splice in unsanitized user input in a way that has surprising parsing consequences. By working instead with syntax trees, we avoid such complexities. We can go even further and use advanced type system features to guarantee that, for instance, every constructible SQL query makes correct assumptions about a database schema. Finally, with further type system sophistication, we can assign static types to programs that generate code; for instance, we can assign a static type to a function that is generic in a database schema, producing different queries for different schemas. Any type-correct metaprogram of this kind is guaranteed to output query code that is immune to code injection attacks.</p><p>Statically-typed code generation is attractive for reasons beside security. A serious barrier in the way of wider use of metaprogramming is the difficulty in building abstractions that programmers can figure out how to use. A good static type system can provide a structuring principle and a source of machine-checked documentation about the interfaces of generic components.</p><p>How can we arrive at a language environment that can support our vision? One strategy is to start with a less esoteric programming language and gradually add expressivity. In particular, features once associated only with dependently-typed languages have recently been added to Haskell, in the form of extensions like multiparameter type classes with functional dependencies <ref type="bibr" target="#b11">[12]</ref>, generalized algebraic datatypes <ref type="bibr" target="#b26">[27]</ref>, and open type functions <ref type="bibr" target="#b25">[26]</ref>.</p><p>An alternative strategy is to design a new programming language, picking and choosing features inspired by traditional dependentlytyped languages. Languages like Cayenne <ref type="bibr" target="#b1">[2]</ref> and Sage <ref type="bibr" target="#b13">[14]</ref> sacrifice decidable type-checking but keep all three of dependent types, type-level computation, and broad applicability. Another popular approach is to introduce some form of dependent types without type-level computation, as in ATS <ref type="bibr" target="#b4">[5]</ref>, Deputy <ref type="bibr" target="#b5">[6]</ref>, and liquid types <ref type="bibr" target="#b24">[25]</ref>. Finally, a language can support rich type-level computation without dependent typing, as in Ωmega <ref type="bibr" target="#b28">[29]</ref>.</p><p>Considering classical tools like Coq and Agda, Haskell extensions, and the previous paragraph's new languages, there is a serious common weakness. They do not provide very good support for the construction of new abstractions that manipulate richly-typed values. In each case, either the type system is too weak to support interesting metaprogramming applications, or the annotation and/or proof burden needed to support metaprogramming is very high. In the latter category, type checkers are usually very good at checking normal programs, where all relevant pieces of type-level data are fully determined. However, when some of these pieces of data are unknown, the undecidability of type inference becomes a serious problem. Serious metaprograms generally need to include some kind of explicit proof terms to convince the type-checker.</p><p>We illustrate the problem with some example code in Coq, a system that can be considered as maximally expressive within this design space. Consider code that manipulates heterogeneous lists, where the type of a list conveys exactly how many elements it has, as well as what type each element should have. These types may be different for different list positions. It is natural to define a concatenation operator +++ for heterogeneous lists, whose type is defined in terms of normal list concatenation ++. Richer versions of all of these constructions are very useful in our metaprogramming domain, for such tasks as modeling database schemas. This particular contrived example is chosen for its simplicity, but the problem of "satisfying the type-checker" is a pervasive one that underlies the practical differences between Ur and related languages. The li variables are lists of types, written in usual ML-like notation. In the definitions of the hi variables, each type list is used to describe the shape of a heterogeneous list. The final definition of h123 concatenates our three lists into a single list. Notice that, in the type of h123, we apply normal list concatenation as if it were right-associative, while, in the body of the definition, we apply heterogeneous list concatenation left-associatively. In Coq (and in the other languages we surveyed above with type-level computation), it is easy to see that this implicit use of associativity is legal. The lists li are constants, so we simply evaluate the two type lists l1 ++ (l2 ++ l3) and (l1 ++ l2) ++ l3, verifying that the resulting constant lists are equal.</p><p>Things get more complicated if we want to write a generic associative-concatenation function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition acat l1 l2 l3</head><p>(h1 : hlist l1) (h2 : hlist l2) (h3 : hlist l3) : hlist (l1 ++ (l2 ++ l3)) = cast (assoc l1 l2 l3) ((h1 +++ h2) +++ h3).</p><p>Here, the variables li are type parameters, as in parametric polymorphism. Since we do not know their values, we cannot check type equivalences via the simple evaluate-and-compare method. Instead, to get our function to type-check, we had to include an explicit cast expression. The sub-expression assoc l1 l2 l3 is a proof term, establishing the fact (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3). The theorem assoc was proved separately in a library, using techniques more mathematical than programmingoriented.</p><p>In all of the systems we mentioned earlier, this kind of explicit casting is the best that can be done to support the combination of rich typing and genericity. The burden may not seem too great from the classical perspective of dependent-types-for-full-verification. However, when writing a code generator for a Web application, such typing details are far from the main point of the code. Facts like concatenation associativity should be applied automatically. Today's type system state of the art fails to provide this facility.</p><p>In this paper, we argue for use of a language with type-level computation but no dependency. Moreover, we are not interested in supporting full correctness verification. We only care to handle the sorts of typing issues that come up in metaprogramming. This is an opportunity to avoid any need for explicit proof terms by building a customized type inference engine. Our approach is by no means a deep theoretical advancement. The key structuring ideas are already there in Coq and Agda, and our system could be implemented as a library in one of those languages. However, using such a library would require heroic efforts in type annotation and theorem-proving. Dependent types are popularly viewed as more theory than practice; in this work, we show that, with just a small injection of domain-specific smarts, this old piece of theory leads to a practical tool that is highly competitive in a popular real-world application domain.</p><p>We present the Ur programming language, whose novel features center on first-class, type-level names and records. Ur includes specialized heuristic type inference that makes it possible to write record-manipulating metaprograms that are free of explicit proof terms. On top of Ur, we have built Ur/Web, a domain-specific language for constructing modern Web applications. Ur/Web adds a special standard library, some parsing extensions, and a specialized compiler, but it relies only on the generic Ur type inference engine. The signature of the Ur/Web library describes the syntax and typing constraints of HTML documents and SQL queries, and the inference engine is sufficient to type-check metaprograms that build programs that build documents and queries.</p><p>Type inference for Ur is undecidable, and we have no theorems that support our choice of inference procedure. Instead, we point to empirical evidence of Ur/Web's effectiveness. We have built the tool set to be a real, practical Web application framework that is highly competitive with mainstream frameworks. We claim that, in the hands of an experienced functional programmer, Ur/Web is far ahead of the competition in each of the critical areas of programmer productivity, security, and performance. In this paper, we focus on productivity, measured in terms of case studies in using Ur/Web to build practically-useful metaprograms.</p><p>In particular, we have based our design on two firm principles.</p><p>1. The author of a metaprogram should never need to write a proof term. He may write more involved types than usual, and he may need to add new type parameters to some functions, but he should never need to do any work to show that his program really has the type he wrote.</p><p>2. The users of a metaprogram should need to write neither proofs nor types more complex than those found in mainstream programming languages.</p><p>In the next section, we introduce the key features of Ur by example. In Section 3, we formalize a core calculus based on these features. The following section discusses effective type inference for the full language. After that, we describe our implementation and provide evidence for its practicality, in the form of case studies building statically-typed versions of common metaprogramming functionality. We conclude by discussing related and future work.</p><p>The open source distribution of the Ur/Web compiler, along with the source code for our case studies, is available at http://www.impredicative.com/ur/</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Ur By Example</head><p>Ur is an extension of System Fω <ref type="bibr" target="#b21">[22]</ref>, the higher-order polymorphic lambda calculus, presented with ML-style syntax. The foundation of the key extensions to Fω is support for type-level names and records. As a simple introduction to these features and their usefulness, we will write a generic record field projection function. For example, the function call proj [#A] {A = 1, B = 2.3} will evaluate to 1, while the call proj [#D] {C = True, D = "xyz", E = 8} will evaluate to "xyz". This proj function will be usable on any record, with arbitrary fields of arbitrary types. Further, proj will have a static type that expresses its requirements exactly, and the Ur type-checker will verify that proj will work correctly on any input compatible with its type.</p><p>The definition of proj is not very long, but it depends on a few unusual constructs, which we will introduce below. Type-level formal arguments to functions are declared inside square brackets. Our proj function binds three type-level variables nm, t, and r. Unlike in usual ML code, the type variables appear explicitly in the function definition. Each type variable is assigned a kind. Kinds are to types as types are to values; kinds classify different varieties of types. The kind annotations above indicate that nm is a field name, t is a normal type, and r is a record of types, otherwise known in the literature as a row type.</p><p>The next piece of the function definition is [[nm] ~r], which declares a disjointness constraint. This particular constraint asserts that the name nm is not used by the type-level record r.</p><p>The final formal argument is x, which is a normal, value-level argument. We write x's type using the $ operator, which converts a type-level record r (of kind {Type}) to a record type (of kind Type) with field names and types as indicated by r. The code [nm = t] is an example of a type-level record literal, denoting the singleton record associating the name nm with the type t. We use record concatenation ++ to add this singleton to the other fields r. This concatenation would be invalid if we had not included the disjointness constraint; Ur enforces lack of field name duplication in any concatenation.</p><p>The function body just uses the primitive record field projection operator. By encapsulating that operator in this way, we arrive at a function with the following Ur type. nm :: Name -&gt; t :: Type -&gt; r :: {Type}</p><formula xml:id="formula_0">-&gt; [[nm] ~r] =&gt; $([nm = t] ++ r) -&gt; t</formula><p>Here code like x :: K -&gt; T indicates a polymorphic function, whose argument is of kind K. The function's argument is given name x, which may appear free in the function result type T. For instance, the normal polymorphic identity function has type a :: Type -&gt; a -&gt; a. The parsing precedence of the :: operator is such that it binds more tightly than any other, in any situation where ambiguity would arise otherwise.</p><p>Our proj function is straightforward to apply. For instance,</p><formula xml:id="formula_1">proj [#A] [int] [[B = float]] ! {A = 1, B = 2.</formula><p>3} has type int and reduces to 1. We write type-level arguments to valuelevel functions inside square brackets, and a first-class name literal is written by prefixing the name with a # character. The ! stands for a disjointness proof to be inferred. The Ur type inference engine contains a special prover for this purpose. There is no syntax for writing manual proofs; disjointness proofs are always inferred.</p><p>The Ur implementation contains a facility for marking some type-level function arguments as implicit. We will not go into detail here on that facility, but we can use it so that our function can be called as simply as proj [#A] {A = 1, B = 2.3}. If the remaining arguments are marked as implicit at proj's definition site, the Ur compiler knows to expand this call to proj [#A] [ ] [ ] ! {A = 1, B = 2.3}. Each underscore is treated as a distinct unification variable. A specialized unification procedure for type-level records infers values for these variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">A Generic Table Formatter</head><p>One very common source of repetitive coding in Web applications is formatting application-specific records for display as tables. In this subsection, we show how a particular "copy-and-paste recipe" can be reified as a well-typed Ur function. The example will demonstrate how code generators may work by iteration over all fields of records of metadata.</p><p>Our end product is a function mkTable that we will be able to call like this, assuming that we have available functions showInt : int -&gt; string and showFloat : float -&gt; string.</p><formula xml:id="formula_2">val f = mkTable {A = {Label = "A", Show = showInt}, B = {Label = "B", Show = showFloat}}</formula><p>This defines a function f of type {A : int, B : float} -&gt; string. When called with a record of the right type, f will format it as an HTML table, using the labels "A" and "B" as headings, and using the functions showInt and showFloat to render columns of the table. For example, the call f {A = 2, B = 3.4} would evaluate to the HTML &lt;tr&gt; &lt;th&gt;A&lt;/th&gt; &lt;td&gt;2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;B&lt;/th&gt; &lt;td&gt;3.4&lt;/td&gt; &lt;/tr&gt; To write mkTable in a completely generic way, such that it works with arbitrary sets of fields of arbitrary types, we must develop some type system machinery. This machinery is involved, but the final product is a function that may be called as simply as above.</p><p>The first ingredient is a way of folding over the fields of a typelevel record. We define a type family folder, such that folder r is the type of permutations of the fields of record r. To avoid introducing too much detail at once, we will give some definitions specialized to records of normal types, though our implementation uses kind polymorphism to generalize the definitions to other varieties of type-level data. This is the definition of folder in terms of simpler constructs. We present it in full first and then consider it a piece at a time, introducing syntactic and semantic elements as they appear.</p><p>type folder (r :: {Type}) = tf :: ({Type} -&gt; Type)</p><p>-&gt; (nm :: Name -&gt; t :: Type -&gt; r :: {Type}</p><formula xml:id="formula_3">-&gt; [[nm] ~r] =&gt; tf r -&gt; tf ([nm = t] ++ r)) -&gt; tf [] -&gt; tf r</formula><p>This is a type-level function definition. In general, code like type f (x :: K) = T introduces a function f of kind K -&gt; K', when T has kind K' in an environment where variable x has kind K.</p><p>The body of folder's definition has the form tf :: ({Type} -&gt; Type) -&gt; STEP -&gt; INIT -&gt; RESULT. A folder is simply a first-class polymorphic function that may be called to iterate over the fields of r. The type-level argument tf is the counterpart of the accumulator type, in analogy to the standard list fold functions of functional programming. The component STEP gives the type of a suitable function for computing one iteration of the fold, INIT the type of the initial value for the fold, and RESULT the final result type of the fold.</p><p>Following this analogy with traditional list fold functions, one notable difference is that INIT and RESULT are not the same type. This is because we want to allow the accumulator type to depend on which prefix of the record's fields we have already stepped through. That is, when folding over record r, the initial accumulator should have type tf [] (where [] is the empty record), and the final accumulator should have type tf r. We see this progression reflected in the last line of folder's definition, in the concrete choices of INIT and RESULT.</p><p>The most interesting part of the definition comes in the second and third lines, where we have the type STEP of the function to fold over r: nm :: Name -&gt; t :: Type -&gt; r :: {Type}</p><formula xml:id="formula_4">-&gt; [[nm] ~r] =&gt; tf r -&gt; tf ([nm = t] ++ r)</formula><p>This function takes three type-level arguments: nm, the name of the field we are processing; t, the type associated with nm; and r, a record of all of the fields that we already processed. A disjointness constraint asserts that r does not use the name nm. Finally, we have a normal function type, with different versions of the accumulator type tf as the domain and range. In the domain, we have an accumulator type appropriate for the point just after processing every field in r. In the range, we extend r to indicate that we have now also processed nm.</p><p>Building on the generic concept of a folder, we can implement our table generator. We define a type-level function that expresses which metadata we will need for each record field. In particular, for each field of type t, we need a display label and a function for rendering t values as strings.</p><p>type meta (t :: Type) = {Label : string, Show : t -&gt; string}</p><p>We use meta to express the type of our table generator, which we call mkTable. To render a record with fields r, we require a folder r. We also need a metadata record, whose type is $(map meta r). When r is [f1 = t1, ..., fn = tn], the type of this metadata record is {f1 : meta t1, ..., fn : meta tn}, which is syntactic sugar for $[f1 = meta t1, ..., fn = meta tn]. Here is the definition of mkTable.</p><p>fun mkTable [r :: {Type}] (fl : folder r) (mr : $(map meta r))</p><formula xml:id="formula_5">(x : $r) = fl [fn r =&gt; $(map meta r) -&gt; $r -&gt; string] (fn [nm] [t] [r] [[nm]</formula><p>~r] acc mr x =&gt; "&lt;tr&gt; &lt;th&gt;" ^mr.nm.Label ^"&lt;/th&gt; &lt;td&gt;" ^mr.nm.Show x.nm ^"&lt;/td&gt; &lt;/tr&gt;" ^acc (mr --nm) (x --nm)) (fn _ _ =&gt; "") mr x</p><p>The function body is a call to the input folder fl. In passing the first argument of fl, we choose our accumulator type so that each accumulated value is a function to a string from a metadata record and a record of field values. These record types have an explicit dependency on the set of record fields considered so far.</p><p>In the step function, the value-level variables are acc, the string rendering of the fields already processed; mr, a version of the input metadata record where already-processed fields have been removed; and x, a similarly abbreviated version of the original argument x. We build a string with the concatenation operator ^. We use the name variable nm to project individual entries out of the local versions of the records mr and x. Additionally, we use the operator x --nm, which removes the field nm from value-level record x. This field removal is necessary to produce arguments of the proper types to pass to the accumulator acc.</p><p>The type of mkTable is easily read off from the function definition:</p><p>val mkTable : r :: {Type} -&gt; folder r -&gt; $(map meta r) -&gt; $r -&gt; string Ur's implicit argument facility does more than just infer types; it can also generate folders automatically, using the order of field names in code as a hint to the permutation the programmer wants. Taking advantage of this possibility, it is easy to bind a version of mkTable specialized to a particular record type, with the code we used to introduce this example.</p><formula xml:id="formula_6">val f = mkTable {A = {Label = "A", Show = showInt}, B = {Label = "B", Show = showFloat}}</formula><p>The type of f is inferred to be {A : int, B : float} -&gt; string. Notice that we did not need to write the type-level record [A = int, B = float] explicitly. Rather, the compiler infers that type from the type of the record we pass to mkTable. The inference engine is able to solve unification problems like this one to find the value of r: $(map meta r) = {A : {Label : string, Show : int -&gt; string}, B : {Label : string, Show : float -&gt; string}}</p><p>We call this kind of inference reverse-engineering unification, because a record is inferred by looking at the output of some operation performed on it. This is the key feature behind making Ur/Web metaprograms no harder to use than the ad-hoc code generators that are popular today.</p><p>While mkTable is easy to use, its definition is somewhat involved. Our vision for the real-world use of these techniques follows the trajectory of today's mainstream metaprogramming. We find relatively expert developers building metaprogramming tools and dealing with the difficulty of debugging them. Many novice programmers rely on the libraries that the experts build. The novices need simple interfaces. Our experience with Ur leads us to believe that a similar decomposition is plausible with staticallytyped metaprogramming. The novice's experience is almost unchanged, and the expert trades off between dynamic debugging and static checking with extra typing-induced overhead. The expert must learn type system idioms that are outside even today's functional programming mainstream, but we hope our examples here provide evidence that this extra training can pay off.</p><p>When high security is critical, as is the case with many Web applications, we believe that the static typing approach reduces the overall cost of development. We simplified our definition of mkTable by outputting HTML in the string type. The real Ur/Web implementation uses a special XML tree type whose type indices track which tags are allowed. Thus, a real Ur/Web definition of mkTable would look more like this: fun mkTable [r :: {Type}] (fl : folder r) (mr : $(map meta r))</p><formula xml:id="formula_7">(x : $r) = fl [fn r =&gt; $(map meta r) -&gt; $r -&gt; xml table] (fn [nm] [t] [r] [[nm]</formula><p>~r] acc mr x =&gt; concat (tr (th (cdata mr.nm.Label) :: td (cdata (mr.nm.Show x.nm)) :: nil)) (acc (mr --nm) (x --nm))) (fn _ _ =&gt; empty) mr x Compared to the string-based version, we get a stronger guarantee: no matter which record we pass to mkTable, the resulting program is free of code injection vulnerabilities. Strings can only be included in XML trees via the explicit cdata constructor, which forces appropriate quoting. In general, Ur/Web uses similar strongly-typed syntax trees for any kind of code that Web browsers or database servers might run, providing a global guarantee of freedom from code injection attacks, even in the presence of an expressive metaprogramming facility, and without the need to evaluate specific metaprogram applications to determine if they are safe.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Generic Database Modification</head><p>It is common for Web applications to work with "native" representations of data when possible but then convert such representations into alternate formats for database access. In this section, we develop a toy example inspired by that kind of usage. In particular, we want to write a function that adds a row to a database table, where doing so requires first applying a conversion operation to each element of a record.</p><p>The larger lesson from this example has to do with how we may write generic functions that output SQL-like queries. We want these queries to be expressed using rich types that guarantee validity, including type compatibility with a fixed database schema. Therefore, few type systems outside of the dependent types world are equipped to capture the essential well-formedness invariants. Ur supports this kind of programming using the same relatively lightweight features that we have been introducing, with effective inference to minimize the cost of applying generic functions.</p><p>Assume we have two abstract type families, corresponding to database tables and to expressions that the database engine understands.</p><p>type table :: {Type} -&gt; Type type exp :: {Type} -&gt; Type -&gt; Type A table type is parameterized by a record assigning types to the table's columns. An expression type is parameterized first, by a record expressing which free variables may be mentioned and what their types are; and second, by the type of the expression, according to the database's expression typing rules.</p><p>These type families are abstract in the sense that the programmer may not rely on any details of their implementation. In our concrete implementation, both table and exp are aliases for string, but programmers should think of them as abstract syntax tree types. While there are varieties of metaprogramming that deal with both code generation and code introspection, we only deal with the former in Ur/Web and in this paper. No method is provided to, for example, pattern-match on the syntax of an exp, as that turns out not to be needed in our domain.</p><p>In this example, we do not need to work with expressions that mention table columns. We only need to rely on a single function for constructing expressions: const, which converts a constant value into an expression. This function's polymorphic type expresses the fact that the output expression mentions no free variables; since we abstract over an arbitrary environment r and assert that the output expression is valid in r, it must be the case that there is no particular variable that const depends on being able to mention. val const : r :: {Type} -&gt; t :: Type -&gt; t -&gt; exp r t Assume that there is a primitive function for adding a row to a table. The column values for a new row are expressed as a record of expressions with no free column variables.</p><formula xml:id="formula_8">val insert : r :: {Type} -&gt; table r -&gt; $(map (exp []) r) -&gt; unit</formula><p>Our final function toDb will be expressed in terms of a type parameter of kind {Type * Type}, the kind of records of pairs of types. The convention is that each pair (native, db) describes a column represented natively in type native but converted to type db for database insertion. Each column must have an associated function for translating from native to db, and we use a type function arrow to express that. The type-level functions fst and snd from the standard library project the first and second elements of type-level pairs, respectively. type arrow (dom :: Type, ran :: Type) = dom -&gt; ran val toDb : r :: {Type * Type} -&gt; folder r -&gt; $(map arrow r) -&gt; table (map snd r) -&gt; $(map fst r) -&gt; unit</p><p>We can implement toDb using mostly the same techniques as from our last example. We fold over the record of type pairs, building a value-level record that is a suitable parameter to insert. We use the value-level operator ++, which implements record concatenation. There is a subtlety in type-checking the definition of toDb. The result type of the fold over r is not in the right form to be a valid argument to insert. The Ur type inference engine applies this type equality implicitly:</p><formula xml:id="formula_9">$(map (fn p =&gt; exp [] (snd p)) r) = $(map (exp []) (map snd r))</formula><p>This is a corollary of a more general fusion law:</p><formula xml:id="formula_10">map f (map g r) = map (fn x =&gt; f (g x)) r</formula><p>In all related systems that we are aware of, the programmer would need to apply an explicit coercion to make use of this law. The coercion would most likely appeal to an explicit inductive proof of the fusion law. For a general-purpose language intended to be used in correctness verification, it is not clear how to do any better. However, since Ur is only intended to handle reasoning about records and names, we can streamline the programming process.</p><p>The fusion law and a handful of other algebraic identities are built into our inference engine, and they are applied automatically during unification whenever possible. The formal presentation of Ur in Section 3 gives the complete list of laws that we have added. Our present implementation only includes five laws that would be proved by induction in traditional dependently-typed programming. These laws have been sufficient to avoid any proofs about type equality in all of the Ur/Web case studies we have undertaken.</p><p>Our toDb function has a type even more involved than that of last subsection's mkTable function. It is unlikely that many non-expert programmers are prepared to deal with types of this complexity. Luckily, implicit arguments and reverse-engineering unification do not fail us. The following example code is sufficient to instantiate toDb at a specific record type. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Building Typed Expressions</head><p>Many database operations accept predicates over the columns of a table. For instance, the SQL delete command removes all rows of a table that satisfy a particular user-specified predicate. To interface with a database, it can be useful to convert a record of values into a database expression that characterizes those table rows whose columns match the record. A function to do this generically will be our final worked example, and the implementation will demonstrate how more complicated richly-typed abstract syntax trees may be built generically.</p><p>We will need a few more of the constructors for the exp type. The following functions reference a database column, compare two expressions for equality, and form the conjunction of two boolean expressions, respectively. val column : nm :: Name -&gt; t :: Type -&gt; r :: {Type} -&gt; [[nm] ~r] =&gt; exp ([nm = t] ++ r) t val eq : r :: {Type} -&gt; t :: Type -&gt; exp r t -&gt; exp r t -&gt; exp r bool val and : r :: {Type} -&gt; exp r bool -&gt; exp r bool -&gt; exp r bool</p><p>We are able to give our generic function, selector, a type that is simple in comparison to those from the earlier examples. The implementation of the function is interesting because it performs a fold with an accumulator type that involves an explicit record disjointness assertion. </p><formula xml:id="formula_11">(const x.nm)) (acc (x --nm) [[nm = t] ++ rest] !)) (fn _ [rest] [rest ~[]] =&gt; const True) x [[]] !</formula><p>At each stage of folding through the record r, our accumulator is a function. Its first argument is a record containing one field for every field of r that we have already folded over. The next argument, rest, is a type-level argument, which is meant to be instantiated to those fields that we have not yet folded over. In the course of the fold, we gradually shift fields "from rest to r," until at the end rest may be the empty record. After binding rest, the accumulator type includes an explicit assertion that rest and r share no field names, which is a prerequisite of being able to concatenate these records. We include just such a concatenation in the result type of accumulator functions, which is the type of boolean expressions that may mention columns included in either of r or rest.</p><p>The step function used in the fold takes many arguments, but it mostly uses features that we have already seen. The interesting part is in the application of the accumulator acc. We need to choose the right rest record to pass to it. This turns out to be the current rest value, extended with the current field mapping from nm to t. We write ! to denote a "proof" of the disjointness assertion in acc's type. As always in Ur, there are no proof terms; rather, the ! is just a signal that the inference engine should prove the assertion automatically. This proof is assembled from the disjointness assertions [nm] ~r and rest ~r that are available in the typing context. Last subsection's example demonstrated the Ur inference engine's smarts in reasoning about equality of records, through the automatic application of algebraic equivalences. Our new example showcases the other kind of domain-specific reasoning in inference, which is automatic proof of record disjointness facts. The disjointness prover is able to prove a wide range of implications involving record concatenation and mapping, without burdening the programmer with any of the details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Syntax and Semantics of Featherweight Ur</head><p>We hope that the previous section's examples have motivated why Ur has the features that it does. In this section, we refine that design down to its core elements, presenting a formal definition of the idealized language Featherweight Ur.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Syntax</head><p>Figure <ref type="figure" target="#fig_5">1</ref> presents the syntax of Featherweight Ur, which is influenced heavily by System Fω <ref type="bibr" target="#b21">[22]</ref>, the higher-order polymorphic lambda calculus. This syntax closely follows what we have seen in ASCII format in the examples; we hope that the correspondence is plain. One change that we make is referring to the general class of compile-time values as constructors rather than types. Types are the subset of constructors that have kind Type. We try to use metavariables τ for types and c for constructors that may not be types. Guarded types, which we have also referred to as disjoint-Kinds In a general-purpose dependently-typed language like Agda, we would build a type of records and its associated operations from first principles. In contrast, Ur omits the traditional facilities for inductive and recursive definitions, instead building the key kinds and type-level operators into the language. Type-level concatenation and mapping are the sole type-level computation facilities that would be implemented as recursive definitions in Agda. This approach is entirely compatible with viewing Ur as a convenient surface language for Coq or Agda, such that it is possible to fall back on the more expressive language when Ur's feature set is insufficient. However, it seems desirable to stick to this restricted fragment because we have been able to implement an effective type inference procedure for it, as described in the next section.</p><formula xml:id="formula_12">k ::= Type | Name | k → k | {k} Constructors c, τ ::= τ1 → τ2 | α | ∀α :: k. τ | c c | λα :: k. c | #n | $c | [] k | [c = c] | c + + c | map k,k | [c ∼ c] ⇒ τ</formula><p>Our experience writing programs in Ur/Web suggests that the feature set we have chosen is more than sufficient for our application domain. It is also true that a few apparent omissions have solid theoretical justification. For instance, it may seem more natural to choose "fold" over "map" as a primitive traversal. However, in combination with considering records as unordered sets of keys and values, this would lead to an unsound semantics, unless we increased the language complexity to the point where it could be proved that any function used with "fold" is insensitive to the order in which record fields are visited. The choice of record field disjointness as the sole variety of constraint may also seem arbitrary. However, from this base, it is easy to define other constraints, including record equality and inclusion. In fact, the Ur/Web standard library relies critically on such constraints to encode the typing rules of SQL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Static Semantics</head><p>Figure <ref type="figure">2</ref> gives selected rules of the kinding judgment, which assigns kinds to constructors. We omit those rules already used by Fω. To simplify the presentation, we assume side conditions for each rule asserting the well-typedness of all expressions and well-kindedness of all constructors that appear. We define all of our judgments in terms of a single variety of context Γ. Entries in such contexts are kinding assertions α :: k, typing assertions x : τ , or row disjointness assertions c1 ∼ c2. The kinding judgment only uses the first and last of these assertion sorts. We hope that the rules are intuitive, following our examples.</p><p>The two interesting cases are for row concatenation and guarded constructors. To concatenate rows c1 and c2, it must be proved that c1 and c2 share no field names. This is captured by the judgment Γ c1 ∼ c2. In the rule for guarded types [c1 ∼ c2] ⇒ τ , within the body τ , the context is extended with the fact that c1 is disjoint from c2. We omit here the details of the disjointness judgment; it simply captures decomposition of each side of the constraint into irreducible pieces and checking of disjointness between all pairs of pieces.</p><p>This decomposition is phrased via a definitional equality judgment c ≡ c , which encodes the computational semantics of constructors. In checking disjointness, we may replace any constructor with another that is computationally equivalent. Figure <ref type="figure">3</ref> presents the definitional equality. On the first line of the figure, we include the standard rules from Fω.</p><p>The next set of rules defines the semantics of the basic row operations. We have that the empty record is an identity element for concatenation, and that concatenation is commutative and associative. After this, we have the semantics of map. The rules for map mostly mirror a list map definition in Haskell.</p><p>Perhaps the most surprising set of rules comes in the last two lines of the figure. Within the definitional equality, we have row equivalents of standard theorems about higher-order list functions. In order, the last three rules of Figure <ref type="figure">3</ref> express the fact that map applied to an identity function is itself an identity function, the distributivity of map over concatenation, and a fusion law for one map over another. One of our (perhaps surprising) empirical results is that these are the only laws we have needed to implement a variety of practical metaprograms.</p><p>Finally, we come to the typing rules, with selected rules shown in Figure <ref type="figure" target="#fig_6">4</ref>. Most of the novelties of Featherweight Ur have already come up in relation to the previous judgments. One rule makes the typing judgment a congruence over the definitional equality; when e has type τ , it also automatically has type τ , for any τ ≡ τ . The typing rule for guarded expressions [c1 ∼ c2] ⇒ e shows that they have types like [c1 ∼ c2] ⇒ τ ; we apply the rule for the ! operator to reduce this type to simply τ , when the constraint is provable.</p><p>Like other languages with symmetric concatenation of records, Ur lacks subtyping, since this could lead to ambiguous situations where it is not clear which of two records being concatenated to drop a field from. However, many of subtyping's common usage patterns can be encoded with polymorphism over type-level records.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Dynamic Semantics</head><p>Rather than defining an operational semantics for Featherweight Ur, we give an elaborative semantics, translating Featherweight Ur programs into terms of the Calculus of Inductive Constructions, the logic behind the Coq proof assistant <ref type="bibr" target="#b2">[3]</ref>. We do not have space to go into the details here. The exact translation is available in the src/coq directory of the Ur/Web distribution, as part of a Coq formalization of Featherweight Ur syntax and semantics.</p><p>The basic idea is that we translate kinds to CIC types, constructors to terms of those types, and typing derivations to terms of those further types. A derivation c ≡ c is compiled to a proof that c and c have equal denotations. Our implementation of records is a standard exercise in programming with heterogeneous list types, a common tool in dependently-typed languages.</p><p>It is worth stating explicitly that, since we give our semantics elaboratively, there is no need to prove a separate type soundness theorem. The translation is implemented in Coq and outputs native Coq terms directly, so we get type preservation by construction. Since CIC has been proved type-sound, Featherweight Ur is typesound, too, almost by definition. This formalization also inherits other properties of CIC, like strong normalization <ref type="bibr" target="#b19">[20]</ref>, that do not hold of the full Ur language.</p><p>This elaboration is meant only to specify the semantics of Ur, rather than an implementation technique. The actual Ur/Web compiler works more traditionally, as sketched in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Γ #n :: Name</head><formula xml:id="formula_13">Γ c :: {Type} Γ $c :: Type Γ [] k :: {k} Γ c1 :: Name Γ c2 :: k Γ [c1 = c2] :: {k} Γ c1 :: {k} Γ c2 :: {k} Γ c1 ∼ c2 Γ c1 + + c2 :: {k} Γ map k 1 ,k 2 :: (k1 → k2) → {k1} → {k2} Γ c1 :: {k1} Γ c2 :: {k2} Γ, c1 ∼ c2 τ :: Type Γ [c1 ∼ c2] ⇒ τ :: Type Figure 2.</formula><p>Selected kinding rules of Featherweight Ur cidable, seen via fairly straightforward arguments: general mathematical proof search can be reduced to type inference in such rich type systems, with unification variables standing for mathematical proofs encoded syntactically. Even type inference for System F has been proved undecidable <ref type="bibr" target="#b31">[32]</ref>, and impredicative (or "firstclass") polymorphism is crucial to Ur's usefulness, as the example of folder functions demonstrates. To this already undecidable base, Ur adds the type-level computation features of Fω and typelevel map. There may very well be worthwhile theoretical completeness results for Ur that fall short of providing full inference, but we leave such results for future work. In this section, we present the type inference heuristics that we have had success with. Like in some proposed solutions to the type inference problem for System F, we require that all polymorphism be annotated explicitly at the definitions of functions. In practice, most type arguments may be inferred, making uses of polymorphic functions look similar to uses in ML, while definitions may be considerably more verbose.</p><formula xml:id="formula_14">(λα :: k. c1) c2 ≡ c1[α → c2] c ≡ c c2 ≡ c1 c1 ≡ c2 c1 ≡ c2 c2 ≡ c3 c1 ≡ c3 c ≡ c C[c] ≡ C[c ] [] k + + c ≡ c c1 + + c2 ≡ c2 + + c1 Γ c1 :: {k1} Γ c2 :: {k2} Γ, c1 ∼ c2 e : τ Γ [c1 ∼ c2] ⇒ e : [c1 ∼ c2] ⇒ τ Γ e : [c1 ∼ c2] ⇒ τ Γ c1 ∼ c2 Γ e ! : τ</formula><p>We follow the usual approach of type-checking expressions by introducing unification variables, whose values are determined later during unification of constructors. Since our type system is more complex than those handled by classic Hindley-Milner inference, we must do more than just solve type equality constraints as they appear. We follow more recent formulations based on systems of constraints. Type-checking generates a set of constructor equality and record disjointness constraints. As an optimization, we try to solve constraints when they are first generated, but the general case involves building a global set of constraints and then iterating through finding an immediately-solvable constraint, until no constraints remain.</p><p>Most of Ur constructor unification could be implemented by normalizing constructors and then comparing normal forms for simple syntactic equality. We can refactor the definitional equality rules of Figure <ref type="figure">3</ref> so that, when applied only left-to-right, they form a rewrite system that we conjecture is terminating and confluent. This requires removing at least the concatenation commutativity rule, so we handle row unification in a special way that we will describe shortly. For the other constructor language elements, rather than following the naive normalize-and-compare unification strategy, we apply a standard optimization. We use a loop of reducing constructors to head normal form, where we reduce only as much as is needed to expose top-level structure. Head normal forms are compared syntactically, where unification of subterms appeals to the original algorithm, which will head-normalize and compare those subterms, and so on. There is no doubt further opportunity for optimizing type inference performance by applying techniques from the type-preserving compilation literature <ref type="bibr" target="#b27">[28]</ref>.</p><p>Higher-order unification is a well-studied subject with some standard heuristic approaches <ref type="bibr" target="#b20">[21]</ref>. There, the key problem is inferring type-level functions. In contrast, the Ur/Web implementation has more in common with the GHC Haskell compiler, in that only first-order unification techniques are used to make a best effort at guessing functions. This is because we have not found the classical higher-order unification techniques to be critical in our setting of metaprogramming. Instead, our inference engine focuses on understanding type-level records and computations over them. Since Ur does support general type-level λ, the result is easy-to-observe inference incompleteness that still tends not to cause trouble in practice. For instance, our inference engine is unable to type the following code.</p><p>fun id [f :: Type -&gt; Type] [t] (x : f t) : f t = x val x = id 0</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Proving Disjointness</head><p>All proofs of row disjointness happen automatically. Whenever a new known constraint is introduced via an expression like fn [r1 ~r2] =&gt; e, our type-checker calculates all atomic disjointness facts implied by r1 ~r2. Each of r1 and r2 is decomposed using a function D defined as follows, where hnf is the constructor head normalization function.</p><formula xml:id="formula_15">D(c) = D (hnf(c)) D ([c1 = c2]) = {[c1]} D (c1 + + c2) = D(c1) ∪ D(c2) D (x) = {x} D (map f c) = D(c) D ( ) = ∅</formula><p>The calls to D yield two finite sets, and we calculate the symmetric closure of their Cartesian product to add to the typing context. When we encounter a disjointness goal r1 ~r2, we decompose these rows with the same function and again take the Cartesian product of the results. This time, we check that every resulting pair is either in our database of facts or consists of two singleton rows with constant, distinct field names. In checking constraints, the last, "wildcard" case of the definition of D must be changed to instead signal that the constraint is not provable yet. In such cases, we hope that when we revisit this constraint after solving other constraints first, some unification variables will have been determined, so that the proof can finish successfully.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Reverse-Engineering Rows</head><p>Another key element of our type inference process is the reverseengineering unification that we have mentioned several times. Sometimes we want to infer implicit arguments to polymorphic functions whose types contain maps. This often leads to inference queries of the form map k 1 ,k 2 f α ≡ c, for some unification variable α and (usually ground) constructor c. If c is empty, then we can set α to be empty, too. When c = [c1 = c2] + + c3, to choose a value for α, we can generate fresh unification variable α and then unify f α with c2. Afterward, we can replace α by [c1 = α ]+ + α for some new α . We can repeat this process to reverse-engineer the value of α in a wide variety of cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Unifying Rows</head><p>During unification, when the standard algorithm finds a row operator like concatenation at the top level of one of the constructors that it is comparing, it switches to using a special row unification algorithm. First, each constructor is summarized using a summary function S from constructors to triples of sets. S works like the D function in decomposing a record, and the triples it outputs break a record's components into singleton field mappings, unification variables, and other miscellaneous components.</p><p>To unify two records, we first consider each component of their summarizing triples separately, looking for unifiable pieces between the ith component of the first summary and the ith component of the second summary. Any such unifications trigger "crossing off" of components on both sides. If both sides are now empty, we are done. If either side is reduced to a single unification variable, then we finish by replacing it everywhere with the other side's contents. If each side is reduced to a single unification variable plus zero or more singleton fields, and if the singleton fields on one side do not overlap with those on the other, then each of the two unification variables may be rewritten in terms of a single new variable. When none of these rules apply, we make a last attempt to apply reverse-engineering unification. If iterating these rules leaves any contents on either side of the equation, we remember the new unification variable values that we learned, but we leave this equality in the set of unsolved constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Generating Folders</head><p>Instances of the folder type family from Section 2 may be omitted, in which case the compiler waits to generate concrete instances until after type inference is complete and the type of every subterm of the program is known. Since the type inference process never commutes the order of fields in a record type unnecessarily, the order of record fields in the elaborated program is easy to predict, based on the order in which fields were written in the source code. Because of this, it works well for the compiler to generate any unknown folder using the permutation implied by the order in which fields appear in the folder's inferred type.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">The Ur/Web Compiler</head><p>We have used the generic Ur type inference engine to implement Ur/Web, a domain-specific language for Web application development. To the programmer, Ur/Web appears as a special standard library for Ur, plus helpful parsing extensions supporting features like inline XML and SQL code. Under the hood, the Ur/Web compiler is specialized to deal with this library and with the requirements of real Web browsers and database servers.</p><p>Even setting metaprogramming aside, we found many uses for Ur's facility for building type-level records with mapping. To support richly-typed versions of the standard structures that Web applications manipulate, we did not need to write any custom type inference code. Instead, we encoded those structures in the signature of the main module of the standard library. In particular, Ur records show up throughout the encodings of the syntax and typing rules of SQL queries and commands and HTML documents.</p><p>Our experience applying Ur/Web suggests that any application using these features, written without polymorphism, can be typechecked with no more type annotation than is needed when representing these structures as strings. Moreover, the inference engine is quite effective at dealing with polymorphic and metaprogramming uses of these library types.</p><p>As we use rich tree types to classify any structure that browsers will interpret, Ur/Web applications are automatically immune to cross-site scripting, code injection, and several other of the most common security vulnerabilities. One might worry that we need to trade performance for this benefit, due to the use of an advanced type system. However, we compile Ur/Web programs with a wholeprogram optimizing compiler. In the tradition of MLton<ref type="foot" target="#foot_4">3</ref> , we eliminate all polymorphism at compile time, which, given the complexity of our type system, requires simple partial evaluation by reduction. This produces an intermediate form that is much like ML.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Case Studies</head><p>In this section, we discuss some case studies centered on Ur/Web versions of common metaprogramming components from the world of Web application frameworks. We highlight interesting uses of type-level map, the most distinguishing feature of Ur compared to other systems that require little annotation. The message of this section is that, despite the relatively minimalistic set of typelevel features we chose for Ur, each of these case studies meets our two main design criteria of "no proofs for library writers" and "no fancy types for rank-and-file programmers."</p><p>Object-Relational Mapping Many applications maintain a dual view of SQL database tables. There is a view where table rows are represented with the programming language's native records or objects; and there is the database view, which can only be manipulated via queries and commands sent to the database server. The popular Web frameworks provide their own, untyped implementations of such object-relational mapping, or ORM. We implemented ORM as a richly-typed generic component in Ur/Web. Here are two example invocations of our component. These examples use the Ur module system, which is inspired by the ML module systems <ref type="bibr" target="#b15">[16]</ref>, with few surprises encountered in adapting that idea to Ur's base language. We build ORM modules customized to two specific tables. The identifier Table names a functor, i.e., a function from modules to modules. The Table functor is a function from a module describing a table to a module implementing the classic ORM operations: listing all rows and adding, deleting, modifying, or looking up a row. All operations work directly on native Ur records. The argument used to build module T says that we want a table with a column A of type int and a column B of type string. The argument used for S dictates that there be a column D of type float and a column C that is a foreign key reference to rows of T. Module S thus contains a function for retrieving the T record associated with an S record.</p><p>Input modules to Table must contain more type-level information than is included explicitly here. Ur includes an extension to the ML module system paradigm, where type-level module components may be omitted to ask that they be inferred. In this way, the client of a metaprogram can be shielded from the complexity of its type. To support foreign keys, we require that a table be described in a terms of a record of kind {Type * Type}, where each field is associated both with its own type and with the type of the table it references, if it is a foreign key. The foreign key link-following function is typed in terms of a map over this record. We also use map to support an abstract type of columns specific to a table. These columns may be combined to form predicates in a table-specific abstract type of filters, and filters may be passed to lookup and search functions.</p><p>Versioned Database Access In some applications, it is important not only to be able to query the current state of a database, but also to "roll back" to a past view of the database at a particular time. We implemented a versioned database access component that provides this functionality generically, for any set of table columns. Normal database access is just as easy as with the ORM component, but a table-specific abstract type of versions may be used to look up old values. Output modules of our versioning functor provide functions for listing all versions that exist and for looking up an old row by version and key.</p><p>The versioning functor takes two type-level records as input. The first describes which rows should collectively be considered the primary key of the table, such that they are enforced to be unique across rows. The second type-level record describes the remaining columns. Our concrete SQL implementation of the versioning abstraction involves a table whose columns consist of a version ID, the key columns, and a nullable version of each non-key column. The idea is that each update to a virtual row adds a new concrete row where every non-key column that has not changed is represented as NULL, while those columns that have changed have their new values recorded. We represent the type of the concrete database table with a type-level map over the non-key record, replacing each type t with option t. This example also tests the versatility of our domain-specific proving by including types based on the concatenation of the key and non-key records, which are asserted to be disjoint in an explicit constraint.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Database Admin Interface</head><p>The most popular Ruby on Rails metaprogram builds a standard interface for administering an arbitrary database table, including viewing and modifying its contents in a Web browser via HTML tables and forms. We implemented comparable functionality as an Ur/Web functor. The functor may be used by providing just an SQL table reference, a string to display as the page title, and a record of metadata for each table column. Metadata values for common types can be built with expressions like int "A" and float "B" (passing a display name for the column), and support is provided for building custom metadata for domain-specific column handling.</p><p>Each column is associated with a pair of types, giving its SQL and client-side representations. Maps over this record of pairs are used to calculate types for the database table and for the widget environments that occur in HTML forms.</p><p>Web 2.0 Admin Interface We also implemented a batched counterpart to the last component. This modernized version takes advantage of the possibility to run some code in Web browsers as JavaScript. In particular, when the user submits a form asking to add a new row, the remote Web server is not contacted. Instead, local code adds the new row data to an HTML table. The user can click a button to submit his batched changes en masse. This functor may be used in the same way as its Web 1.0 ancestor, despite the fact that we are checking a more complicated piece of code. Every implementation that our functor outputs includes new URLaddressed remote procedure calls (RPCs) for client-server communication, and types guarantee that any functor output uses RPCs correctly.</p><p>This functor is similar to the previous example in involving a record assigning each table column an SQL version and a clientside version. To come up with the proper type for the RPC that adds a list of rows, we need to map over this record, forming a table-specific type of records that must be passed to the RPC in serialized form.</p><p>In-Browser Spreadsheet Another Ur/Web component implements common spreadsheet functionality, such that most code is run in browsers, but the remote Web server is contacted to query and modify a database table storing the persistent version of a spreadsheet. The functor supports foreign keys represented as automatically-populated dropdown listboxes, and each spreadsheet application provides input validation, summary rows displaying aggregate information, paging, sorting, per-column filtering, and an access point that other program modules can use to check which rows of the spreadsheet the user has selected. Here is a simple example of constructing a spreadsheet implementation.  The key component identifies which table columns make up the table key. The raw record explains how to generate the initial value of each column of a fresh row. The cols record contains metadata values for the four columns to be displayed in our spreadsheet: a read-only rendering of the key Id, widgets for editing the values of the A and B columns, and a computed column that always shows twice the current value of A. The final record, aggregates, requests to include a summary row at the bottom of the spreadsheet, where we are told the sum of all A values and the iterated boolean "and" of all B values.</p><p>The main type-level record behind this component has kind {Type * Type * Type}. Each displayed column is associated with a type of global state, a type returned by its main input widget, and a type returned by its filtering widget. Many applications of map are used throughout the functor to express the typing relationship among these different elements. We reduce the complexity of our code by first building a functor for constructing spreadsheets backed by arbitrary data sources, and we then derive a functor for spreadsheets backed by SQL databases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Evaluation</head><p>As far as we know, ours is the first investigation into staticallytyped instances of this variety of practical metaprogramming. It was not obvious at first that it would be possible to write such programs without violating one or both of our two central design principles:</p><p>1. Metaprograms should contain no proofs or other type-cast expressions with no computational effects.</p><p>2. Client code should contain no proofs or types more complicated than types found in mainstream programming languages.</p><p>Nonetheless, all of our case studies fit this description, as do all of the other Ur/Web metaprograms we have written.</p><p>Figure <ref type="figure" target="#fig_8">5</ref> summarizes the amount of code needed to implement our components, measured in lines with content besides whitespace and comments. We also gathered some statistics that give a sense of how much annotation effort Ur/Web saves the programmer over similar coding in related statically-typed systems, which all require proof terms to apply algebraic identities that Ur inference applies automatically. For each component in the Figure <ref type="figure" target="#fig_8">5</ref>, we note how many times the main type inference procedure invoked the disjointness prover, along with how many times inference applied the mapover-identity-function, map distributivity, and map fusion laws, respectively. These numbers consider only the generic components; client code usually triggers additional uses of the laws.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Related Work</head><p>The design of Ur was influenced heavily by our experience with programming in Coq <ref type="bibr" target="#b2">[3]</ref>. The possibilities for generic programming in dependently-typed languages have been recognized and implemented for several years now, at least <ref type="bibr" target="#b0">[1]</ref>. This body of work has tended to focus on more involved examples like generation of parsers and pretty-printers for arbitrary algebraic datatypes. We mean to argue that Ur, by focusing on a specific domain, provides a much more user-friendly experience to programmers, both attracting a broader range of developers and enhancing productivity of those who are attracted. Dependent ML <ref type="bibr" target="#b32">[33]</ref> follows a similar path, with convenient automated reasoning that is mostly restricted to formulas of linear arithmetic.</p><p>There have been many investigations into the inclusion of extensible records in statically-typed languages. Wand's initial work on row types <ref type="bibr" target="#b30">[31]</ref> has inspired many follow-ups. The work of Rémy <ref type="bibr" target="#b23">[24]</ref> is also well-known, as it has directly influenced the object system and polymorphic variant facilities of Objective Caml. Ohori <ref type="bibr" target="#b17">[18]</ref> developed a compiler for a language with extensible records, demonstrating an index-passing encoding that facilitates separate compilation. Harper and Pierce <ref type="bibr" target="#b9">[10]</ref> defined a calculus supporting general record concatenation, via row-quantified types that include general disjointness constraints like those in Ur, but without discussion of type inference. Gaster and Jones <ref type="bibr" target="#b8">[9]</ref> define a system for extensible records and variants, achieving a complete type inference algorithm by restricting constraints to the form "label l is not present in row r." Pottier <ref type="bibr" target="#b22">[23]</ref> demonstrated a general type inference system equipped to deal with general record concatenation and first-class names. Blume et al. implemented the MLPolyR language <ref type="bibr" target="#b3">[4]</ref>, which, using type-level records, exploits the duality of records and variants to support an extensible case construct. The idea of extensible records is a natural one, and it has appeared in many other cases that we do not have space to cite. As far as we are aware, every construction with records that can be coded in these past languages can also be coded in Ur, with no additional type annotation needed at uses of polymorphic functions, though polymorphism must be annotated explicitly in function definitions. The crucial facility distinguishing Ur from this past work is type-level computation, in the form of Fω features and type-level map.</p><p>Embedding SQL syntax in general-purpose languages has been studied before, with various levels of static assurance. Ohori and Buneman <ref type="bibr" target="#b18">[19]</ref> added explicit support for typing associated with database operations to an ML-like language while maintaining principal typing. Leijen and Meijer <ref type="bibr" target="#b14">[15]</ref> embedded a subset of SQL in an extension of Haskell, with static validation of a subset of the properties enforced by Ur/Web. Silva and Visser <ref type="bibr" target="#b29">[30]</ref> later completed a similar project with broader static validation, using more of the harnessing of type classes with functional dependencies that has become very popular in the Haskell community. The HList library <ref type="bibr" target="#b12">[13]</ref> for GHC Haskell is a prominent example of this trend; it provides extensible records, using a notion of type-level compu-tation driven by Haskell's type class resolution mechanisms. We (somewhat subjectively) feel that this style leads to code that is needlessly more complicated and verbose than what is possible in Ur. It is also unclear how to handle in Haskell applications of the kinds of algebraic laws that are at the heart of Ur's type inference; at best, it seems that explicit proof terms must be written.</p><p>There is a long history of code generation in the worlds of object-oriented and procedural programming, and the standard techniques in this area suffer from lack of static validation of metaprograms. Recent language extensions like Compile-Time Reflection (CTR) <ref type="bibr" target="#b7">[8]</ref> for C# and MorphJ <ref type="bibr" target="#b10">[11]</ref> for Java address this shortcoming for programs that inspect and generate classes in stylized ways. Similar issues of name disjointness checking arise in these tools. One significant advantage of Ur's approach is that metaprograms are not only checked statically, but they are also assigned self-contained types, which makes it possible for functions to abstract over metaprograms in a statically-safe way. Another difference is that Ur is built from simple, orthogonal constructs of type theory, which can make it easier to see the essence of metaprogramming with names.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusion</head><p>While novice programmers can use Ur metaprograms without writing fancy types, erroneous metaprogram applications can trigger hard-to-understand error messages that do use advanced concepts explicitly. Improved heuristics for phrasing these messages would be a useful subject for future work. We are also still investigating the limitations that arise from use of a compiler that must resolve all polymorphism statically. This policy limits opportunities for constructing syntax of dynamically-varying type; for instance, to access different database tables based on values read from a configuration file. Perhaps genuine dependent types will even prove crucial in supporting such use cases.</p><p>Ur/Web is already a practical system for implementing modern Web applications with metaprogramming. Programs that write programs are notoriously hard to debug, and Ur helps reduce development cost by using static types to guarantee validity of metaprograms. We built on the rich body of work on dependent type theory and added just a few domain-specific conveniences, in the form of a specialized type inference engine. This "last mile" effort makes a crucial difference in building a tool to be competitive with the tools used in the Web application domain today, where few programmers are willing to write formal proofs just to get programs to type-check.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Definition l1 := [int, string]. Definition l2 := [bool]. Definition l3 := [int]. Definition h1 : hlist l1 = [&lt; 1, "ABC" &gt;]. Definition h2 : hlist l2 = [&lt; true &gt;]. Definition h3 : hlist l3 = [&lt; 4 &gt;]. Definition h123 : hlist (l1 ++ (l2 ++ l3)) = (h1 +++ h2) +++ h3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>fun proj [nm :: Name] [t :: Type] [r :: {Type}] [[nm] ~r] (x : $([nm = t] ++ r)) = x.nm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>fun toDb [r :: {Type * Type}] (fl : folder r) (mr : $(map arrow r)) (tab : table (map snd r)) (x : $(map fst r)) = insert tab (fl [fn r =&gt; $(map arrow r) -&gt; $(map fst r) -&gt; $(map (fn p =&gt; exp [] (snd p)) r)] (fn [nm] [p] [r] [[nm] ~r] acc mr x =&gt; {nm = const (mr.nm x.nm)} ++ acc (mr --nm) (x --nm)) (fn _ _ =&gt; {}) mr x)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>fun addInts (n : int, m : int) = n + m val inserter = toDb {A = addInts, B = fn x : float =&gt; x} Ur infers that the type of inserter is table [A = int, B = float] -&gt; {A : int * int, B : float} -&gt; unit Reverse-engineering unification found that the proper value for r is [A = (int * int, int), B = (float, float)].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>fun selector [r :: {Type}] (fl : folder r) (x : $r) : exp r bool = fl [fn r =&gt; $r -&gt; rest :: {Type} -&gt; [rest ~r] =&gt; exp (r ++ rest) bool] (fn [nm] [t] [r] [[nm] ~r] acc x [rest] [rest ~r] =&gt; and (eq (column [nm])</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Syntax of Featherweight Ur</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Selected typing rules of Featherweight Ur</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>val cols = {A = local [int], B = local [string]} end) structure S = Table(struct val cols = {C = T.id, D = local [float]} end)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Code sizes (in lines of code) of case study components' interfaces and implementations, along with invocation counts for critical pieces of type inference</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>table t :</head><label>t</label><figDesc></figDesc><table><row><cell cols="7">Component Int. Imp. Disj. Id. Dist. Fuse</cell></row><row><cell>ORM</cell><cell>40</cell><cell>77</cell><cell>580</cell><cell>-</cell><cell>13</cell><cell>5</cell></row><row><cell>Versioned</cell><cell>20</cell><cell>122</cell><cell>616</cell><cell>6</cell><cell>4</cell><cell>2</cell></row><row><cell>Table Admin</cell><cell>22</cell><cell cols="2">158 1412</cell><cell>-</cell><cell>1</cell><cell>2</cell></row><row><cell>Web 2.0 Admin</cell><cell>21</cell><cell cols="2">134 1105</cell><cell>-</cell><cell>1</cell><cell>1</cell></row><row><cell>Spreadsh. (base)</cell><cell>46</cell><cell cols="2">291 1667</cell><cell>6</cell><cell>-</cell><cell>1</cell></row><row><cell cols="2">Spreadsh. (SQL) 110</cell><cell cols="2">391 1257</cell><cell>3</cell><cell>11</cell><cell>-</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>{Id : int, A : int, B : bool}</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>sequence s</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>http://www.rubyonrails.org/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>http://www.djangoproject.com/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>Effective Type InferenceUr, or even plain Fω, includes type system features that are rarely found outside of programming languages based on dependent type theory. Type inference for CIC and other such systems is unde-</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_3"><p>c1 + + (c2 + + c3) ≡ (c1 + + c2) + + c3 map k 1 ,k 2 f [] k 1 ≡ [] k 2 map k 1 ,k 2 f ([c1 = c2] + + c3) ≡ [c1 = f c2] + + map k 1 ,k 2 f c3 map k,k (λα : k. α) c ≡ c map k 1 ,k 2 f (c1 + + c2) ≡ map k 1 ,k 2 f c1 + + map k 1 ,k 2 f c2 map k 2 ,k 3 f (map k 1 ,k 2 f c) ≡ map k 1 ,k 3 (λα :: k1. f (f α)) cFigure 3. Definitional equality rules of Featherweight Ur τ ≡ τ Γ e : τ Γ e : τ Γ {} : $[] Type Γ c :: Name Γ e : τ Γ {c = e} : $[c = τ ] Γ e : $([c = τ ] + + c ) Γ e.c : τ Γ e : $([c = τ ] + + c ) Γ e -c : $c Γ e1 : $c1 Γ e2 : $c2 Γ c1 ∼ c2 Γ e1 + + e2 : $(c1 + + c2)</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_4"><p>http://mlton.org/</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank Manu Sridharan, Ryan Wisnesky, and the anonymous referees for helpful feedback on drafts of this paper.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Generic programming within dependently typed programming</title>
		<author>
			<persName><forename type="first">Thorsten</forename><surname>Altenkirch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Conor</forename><surname>Mcbride</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IFIP TC2/WG2.1 Working Conference on Generic Programming</title>
		<meeting>IFIP TC2/WG2.1 Working Conference on Generic Programming</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Cayenne -a language with dependent types</title>
		<author>
			<persName><forename type="first">Lennart</forename><surname>Augustsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICFP</title>
		<meeting>ICFP</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Interactive Theorem Proving and Program Development. Coq&apos;Art: The Calculus of Inductive Constructions</title>
		<author>
			<persName><forename type="first">Yves</forename><surname>Bertot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Castéran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Texts in Theoretical Computer Science</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>Springer Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Extensible programming with first-class cases</title>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Blume</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Umut</forename><forename type="middle">A</forename><surname>Acar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wonseok</forename><surname>Chae</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICFP</title>
		<meeting>ICFP</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Combining programming with theorem proving</title>
		<author>
			<persName><forename type="first">Chiyan</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hongwei</forename><surname>Xi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICFP</title>
		<meeting>ICFP</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Dependent types for low-level programming</title>
		<author>
			<persName><forename type="first">Jeremy</forename><surname>Condit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Harren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zachary</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Gay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Necula</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ESOP</title>
		<meeting>ESOP</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Web Application Security Consortium</title>
		<ptr target="http://projects.webappsec.org/Web-Application-Security-Statistics" />
	</analytic>
	<monogr>
		<title level="m">Web application security statistics</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Reflective program generation with patterns</title>
		<author>
			<persName><forename type="first">Manuel</forename><surname>Fähndrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Carbin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">R</forename><surname>Larus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. GPCE</title>
		<meeting>GPCE</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">A polymorphic type system for extensible records and variants</title>
		<author>
			<persName><forename type="first">Benedict</forename><forename type="middle">R</forename><surname>Gaster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><forename type="middle">P</forename><surname>Jones</surname></persName>
		</author>
		<idno>NOTTCS-TR-96-3</idno>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
		<respStmt>
			<orgName>University of Nottingham</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A record calculus based on symmetric concatenation</title>
		<author>
			<persName><forename type="first">Robert</forename><surname>Harper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Pierce</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. POPL</title>
		<meeting>POPL</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Expressive and safe static reflection with MorphJ</title>
		<author>
			<persName><forename type="first">Shan</forename><surname>Shan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Huang</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Yannis</forename><surname>Smaragdakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. PLDI</title>
		<meeting>PLDI</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Type classes with functional dependencies</title>
		<author>
			<persName><forename type="first">P</forename><surname>Mark</surname></persName>
		</author>
		<author>
			<persName><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ESOP</title>
		<meeting>ESOP</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Strongly typed heterogeneous collections</title>
		<author>
			<persName><forename type="first">Oleg</forename><surname>Kiselyov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ralf</forename><surname>Lämmel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keean</forename><surname>Schupke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Haskell Workshop</title>
		<meeting>Haskell Workshop</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Sage: Unified hybrid checking for first-class types, general refinement types, and Dynamic</title>
		<author>
			<persName><forename type="first">Kenneth</forename><surname>Knowles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aaron</forename><surname>Tomb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jessica</forename><surname>Gronski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephen</forename><forename type="middle">N</forename><surname>Freund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cormac</forename><surname>Flanagan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Scheme Workshop</title>
		<meeting>Scheme Workshop</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Domain specific embedded compilers</title>
		<author>
			<persName><forename type="first">Daan</forename><surname>Leijen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Erik</forename><surname>Meijer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DSL</title>
		<meeting>DSL</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Modules for Standard ML</title>
		<author>
			<persName><forename type="first">David</forename><surname>Macqueen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. LFP</title>
		<meeting>LFP</meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Towards a practical programming language based on dependent type theory</title>
		<author>
			<persName><forename type="first">Ulf</forename><surname>Norell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
		<respStmt>
			<orgName>Chalmers University of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A polymorphic record calculus and its compilation</title>
		<author>
			<persName><forename type="first">Atsushi</forename><surname>Ohori</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TOPLAS</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">6</biblScope>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Type inference in a database programming language</title>
		<author>
			<persName><forename type="first">Atsushi</forename><surname>Ohori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Buneman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. LFP</title>
		<meeting>LFP</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Inductive definitions in the system Coqrules and properties</title>
		<author>
			<persName><forename type="first">Christine</forename><surname>Paulin-Mohring</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. TLCA</title>
		<meeting>TLCA</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Partial polymorphic type inference and higher-order unification</title>
		<author>
			<persName><forename type="first">Frank</forename><surname>Pfenning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. LFP</title>
		<meeting>LFP</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Higher-order polymorphism</title>
		<author>
			<persName><forename type="first">Benjamin</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Types and Programming Languages</title>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>chapter 30</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Franc ¸ois Pottier. A 3-part type inference engine</title>
	</analytic>
	<monogr>
		<title level="m">Proc. ESOP</title>
		<meeting>ESOP</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Type inference for records in a natural extension of ML. Theoretical Aspects of Object-Oriented Programming</title>
		<author>
			<persName><forename type="first">Didier</forename><surname>Rémy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Liquid types</title>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Rondon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ming</forename><surname>Kawaguchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ranjit</forename><surname>Jhala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. PLDI</title>
		<meeting>PLDI</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Type checking with open type functions</title>
		<author>
			<persName><forename type="first">Tom</forename><surname>Schrijvers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simon</forename><forename type="middle">Peyton</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manuel</forename><surname>Chakravarty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Sulzmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICFP</title>
		<meeting>ICFP</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Complete and decidable type inference for GADTs</title>
		<author>
			<persName><forename type="first">Tom</forename><surname>Schrijvers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simon</forename><forename type="middle">Peyton</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Sulzmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dimitrios</forename><surname>Vytiniotis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICFP</title>
		<meeting>ICFP</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Implementing typed intermediate languages</title>
		<author>
			<persName><forename type="first">Zhong</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>League</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Monnier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICFP</title>
		<meeting>ICFP</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Languages of the future</title>
		<author>
			<persName><forename type="first">Tim</forename><surname>Sheard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OOPSLA</title>
		<meeting>OOPSLA</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Strong types for relational databases</title>
		<author>
			<persName><forename type="first">Alexandra</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joost</forename><surname>Visser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Haskell Workshop</title>
		<meeting>Haskell Workshop</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Type inference for record concatenation and multiple inheritance</title>
		<author>
			<persName><forename type="first">Mitchell</forename><surname>Wand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">93</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Typability and type checking in System F are equivalent and undecidable</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Wells</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Pure and Applied Logic</title>
		<imprint>
			<biblScope unit="volume">98</biblScope>
			<biblScope unit="page" from="111" to="156" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Dependent ML: an approach to practical programming with dependent types</title>
		<author>
			<persName><forename type="first">Hongwei</forename><surname>Xi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Functional Programming</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="215" to="286" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
