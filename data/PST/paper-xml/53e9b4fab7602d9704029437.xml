<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Scalable Analysis of Variable Software</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jörg</forename><surname>Liebig</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Passau</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alexander</forename><surname>Von Rhein</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Passau</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Christian</forename><surname>Kästner</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sven</forename><surname>Apel</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">Christian Lengauer University of Passau</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jens</forename><surname>Dörre</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">Christian Lengauer University of Passau</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Scalable Analysis of Variable Software</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">ADEFA8E0FAC5B6EB5104E11D11B72D74</idno>
					<idno type="DOI">10.1145/2491411.2491437</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:05+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.2.3 [Software Engineering]: Coding Tools and Techniques</term>
					<term>D.2.13 [Software Engineering]: Reusable Software</term>
					<term>D.3.4 [Programming Languages]: Processors-Preprocessors Software Product Lines, C Preprocessor, Type Checking, Liveness Analysis, Variability-aware Analysis</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The advent of variability management and generator technology enables users to derive individual variants from a variable code base based on a selection of desired configuration options. This approach gives rise to the generation of possibly billions of variants that, however, cannot be efficiently analyzed for errors with classic analysis techniques. To address this issue, researchers and practitioners usually apply sampling heuristics. While sampling reduces the analysis effort significantly, the information obtained is necessarily incomplete and it is unknown whether sampling heuristics scale to billions of variants. Recently, researchers have begun to develop variability-aware analyses that analyze the variable code base directly exploiting the similarities among individual variants to reduce analysis effort. However, while being promising, so far, variability-aware analyses have been applied mostly only to small academic systems. To learn about the mutual strengths and weaknesses of variability-aware and sampling-based analyses of software systems, we compared the two strategies by means of two concrete analysis implementations (type checking and liveness analysis), applied them to three subject systems: Busybox, the x86 Linux kernel, and OpenSSL. Our key finding is that variability-aware analysis outperforms most sampling heuristics with respect to analysis time while preserving completeness.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Generator-based approaches have proved successful for the implementation of variable software systems <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b15">15]</ref>. For example, the Linux kernel can be configured by means of about 10 000 compile-time configuration options <ref type="bibr" target="#b39">[39]</ref>, giving rise to possibly billions of variants that can be generated and compiled on demand. While advances in variability management and generator technology facilitate the development of variable software systems with myriads of variants, this high degree of variability is not without cost. How could we analyze all possible variants for errors? Unfortunately, classic analyses look at individual variants and do not scale in the presence of the exponential number of variants that can be typically generated from a variable system. For systems such as the Linux kernel, it is not even possible to generate all variants to analyze them separately, because they are so many-more than the estimated number of atoms in the universe <ref type="bibr" target="#b40">[40]</ref>.</p><p>The idea of sampling is to select a reasonable set of variants to be analyzed using traditional analysis techniques. Many different sampling techniques have been proposed <ref type="bibr" target="#b22">[22,</ref><ref type="bibr" target="#b41">41]</ref>, and their application has proved useful in various scenarios <ref type="bibr" target="#b36">[36,</ref><ref type="bibr" target="#b38">38]</ref>. Although analysis time can be reduced significantly, the information obtained is necessarily incomplete, since only a subset of all variants is checked.</p><p>Recently, researchers have begun to develop a new class of analyses that are variability-aware <ref type="bibr" target="#b43">[43]</ref>. The key idea is to not generate and analyze individual variants separately, but to directly analyze the variable code base before variant generation, with the help of configuration knowledge. In the case of the Linux kernel, variable code is implemented by means of conditional-inclusion directives (a.k.a. #ifdefs), and variability-aware analyses analyze the variable code directly, instead of applying the generator (the C preprocessor) to generate the plain C code of individual kernel variants. Variability-aware analysis requires more effort than traditional analysis of a single system, because all local variations need to be considered; however, and this is the key success factor, variability-aware analysis takes advantage of the similarities among variants and avoids analyzing common code over and over again.</p><p>There are several proposals for variability-aware analyses in the literature, including parsing <ref type="bibr" target="#b25">[25]</ref>, type checking <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b24">24,</ref><ref type="bibr" target="#b26">26,</ref><ref type="bibr" target="#b42">42]</ref>, data-flow analysis <ref type="bibr" target="#b8">[8,</ref><ref type="bibr">9]</ref>, model checking <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b4">4,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b30">30]</ref>, and deductive verification <ref type="bibr" target="#b44">[44]</ref>. However, while this work is promising, variability-aware analyses (beyond parsing) have not been applied to large-scale, real-world systems so far; previous work concentrated mostly either on formal foun-Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from Permissions@acm.org.</p><p>dations or is limited with respect to practicality (evaluated with academic case studies only), as we discuss in Section 6.</p><p>Despite the foundational previous work, it is unclear whether variability-aware analysis scales to large systems, as it considers all code and all variations of a system simultaneously. Since sampling is still a de-facto standard for analyzing variable software systems in practice, we explore the feasibility and scalability of both sample-based and variability-aware analysis in practice empirically. To this end, we have developed two fully-fledged variability-aware analyses for C: type checking and liveness analysis (a data-flow analysis). We applied each of them to three real-world, large-scale variable systems: the Busybox tool suite, the Linux kernel, and the cryptographic library OpenSSL. In terms of scalability, we compare the variability-aware analyses to state-of-the-art sampling strategies used in practice (generating all variants is not even possible in reasonable time in our case studies). We found that variability-aware analyses scale well-even outperform some of the sampling strategies-while still providing complete information on all system variants.</p><p>Beside quantitative results, we report on our experience with making variability-aware analyses ready for the real world, and we discuss insights into the development of variability-aware analyses in general. These insights subsume existing studies on variability-aware analysis techniques and they can guide the development of further analyses.</p><p>Overall, we make the following contributions:</p><p>• An introduction to the problem of analyzing variable software, including possible solutions such as sampling and variability-aware analysis. • An experience report of how to implement scalable variability-aware analysis for preprocessor-based systems, based on an existing variability-aware parsing framework <ref type="bibr" target="#b25">[25]</ref>. • A discussion of general patterns of variability-aware analyses that can guide the development of further analyses. • A series of experiments that compare the performance of variability-aware analysis with the performance of state-of-the-art sampling strategies based on three realworld, large-scale subject systems. • A reflection of our experience with applying variabilityaware and sampling-based analyses in practice, and of challenges we encountered in our investigation. The subject systems and all experimental data are available on a supplementary website: http://fosd.net/vaa; the analysis implementations are part of the TypeChef project: http://ckaestne.github.com/TypeChef .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PREPROCESSOR-BASED VARIABILITY</head><p>Before we get to sampled-based and variability-aware analyses and their comparison, we introduce the development of variable software using the C preprocessor cpp. cpp is a frequently applied tool for the development of variable software <ref type="bibr" target="#b31">[31]</ref>. It provides several features to implement variable code fragments using conditional-inclusion macros (a.k.a. #ifdefs). For instance, our running example in Figure <ref type="figure" target="#fig_0">1</ref> contains three variable pieces of code: an alternative macro expression (Line 1-3), an optional function parameter (Line 6), and an optional statement (Line 13). The in-/exclusion of such annotated code is controlled by the values of configuration options (here: A and B) that can be combined using logical operators.  In most cases not all combinations of configuration options of a system are valid, so developers use variability models to express relations between configuration options and define which combinations of configurations options are valid. One widely used tool in practice to express variability models is Kconfig,<ref type="foot" target="#foot_0">1</ref> which is used for example in the development of Linux and Busybox. Variability models can be transformed into boolean formulas, which enables efficient reasoning about them using current SAT-solver technology <ref type="bibr" target="#b34">[34]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">SAMPLE-BASED ANALYSIS</head><p>Sample-based analysis has its origin in early approaches of testing software <ref type="bibr" target="#b35">[35]</ref>. Due to the sheer size and complexity of real-world systems (the number of variants can grow exponentially with the number of configuration options), a brute-force approach of analyzing all variants in isolation is not feasible. Hence, developers typically analyze only a subset of variants, called the sample set, using off-the-shelf analysis tools. The idea is that, even though we cannot analyze all variants individually, we can still strive for analyzing a representative sample set to be able to draw informed conclusions about the entire set of variants (e.g., in terms of defect probability).</p><p>The sample set is selected by a sampling heuristic, either by a domain expert or by an algorithm. Researchers and practitioners have proposed different sampling heuristics, some of which require sophisticated upfront analyses. We selected four that are common in practice: single configuration, random, code coverage, and pair-wise coverage, as described below. For an overview of other sampling strategies, see a recent survey <ref type="bibr" target="#b35">[35]</ref>.</p><p>Single-conf heuristic. The simplest sampling heuristic (single conf ) is to analyze only a single representative variant that enables most, if not all, of the configuration options of the variable system. Typically, the variant is selected manually by a domain expert. The strength of this heuristic is that one needs to analyze only a single variant, hence it is fast. By selecting many configuration options, the heuristic tries to cover a large part of the system's code, however, it cannot cover mutually exclusive code pieces or intricate interactions specific to individual combinations of configuration options <ref type="bibr" target="#b19">[19]</ref>. For the code snippet in Figure <ref type="figure" target="#fig_1">2</ref>, we can create a configuration that enables all configuration options:  {A, B , C }. Since code fragments in Lines 2 and 4 are mutually exclusive, a single configuration will cover only one of them, leaving Line 4 uncovered, in our case.</p><p>According to Dietrich et al. <ref type="bibr" target="#b17">[17]</ref>, in the Linux development community, it is common to analyze only one predefined variant with most configuration options selected, called allyesconfig. Similarly, many software systems come with a default configuration that satisfies most users and that usually includes many configuration options.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Random heuristic.</head><p>A simple approach to select samples is to generate them randomly. For example, in a project with n features, we could make n random, independent decisions whether to enable the corresponding configuration option. In projects with constraints between options, we would discard variants with invalid configurations and would keep the remaining variants as our sample. Random sampling is simple and scales to an arbitrary sample size. Alternatively testing can continue until time or money runs out. Random sampling does not adhere to any specific coverage criterion, though.</p><p>Code-coverage heuristic. The code-coverage heuristic is inspired by the statement-coverage criterion used in software testing <ref type="bibr" target="#b47">[47]</ref>. In contrast to software testing, the code-coverage heuristic aims at variant generation not code execution <ref type="bibr" target="#b41">[41]</ref>. The goal of this heuristic is to select a minimal sample set of variants, such that every lexical code fragment of the systems' code base is included in, at least, one variant. In contrast to the single-conf heuristic, the code-coverage heuristic covers mutually exclusive code fragments. However, note that including each code fragment at least once, does not guarantee that all possible combinations of individual code fragments are considered. For the code snippet in Figure <ref type="figure" target="#fig_1">2</ref>, two configurations {A, B , C } and {}-the first selecting all options and the second deselecting them all-would be sufficient to include every code fragment in at least one variant. However, it would not help to detect the compilation error, i.e., calling bar when A is selected but B is not.</p><p>Although there is an algorithm to compute an optimal solution (a minimal set of variants) by reducing the problem to calculating the chromatic number of a graph, this algorithm is NP-complete and by far too slow for our case studies. <ref type="foot" target="#foot_1">2</ref> Instead, we resort to the conservatively approximated solution of Tartler et al. <ref type="bibr" target="#b41">[41]</ref>, which speeds up the computation of the sample set significantly at the cost of producing a sample set that is possibly larger than necessary.</p><p>A subtle problem of this heuristic arises from the issue of how to treat header files. When computing the sample set of two variants in our example, we have implicitly assumed that we analyze coverage in the main file and the included header file together. Due to the common practice of including files that themselves include other files, a single #include statement in the source code can bloat the code base of a single file easily by an order of magnitude, something we frequently observed in Linux, in which on average 300 header files are included in each C file <ref type="bibr" target="#b25">[25]</ref>. In addition, header files often exhibit their own variability, not visible in the C file without expanding macros. Furthermore, some header files may be included only conditionally, depending on other #ifdef directives, such that, for a precise analysis of all header code, sophisticated analysis mechanisms become necessary (e.g., using symbolic execution of the preprocessor code) <ref type="bibr" target="#b20">[20,</ref><ref type="bibr" target="#b25">25,</ref><ref type="bibr" target="#b29">29]</ref>. This explosion and cost can make precise analyses that include header files unpractical or infeasible, even with Tartler's approximate solution. Therefore, we distinguish two strategies for code coverage: (1) covering variability only in C files and (2) covering variability in C files and their header files. Analyzing only the main file above, a single configuration {A, C } would be sufficient to cover all code fragments of the main file.</p><p>Pair-wise heuristic. The pair-wise heuristic is motivated by the hypothesis that many faults in software systems are caused by interactions of, at most, two configuration options <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b28">28,</ref><ref type="bibr" target="#b37">37,</ref><ref type="bibr" target="#b38">38]</ref>. Using the pair-wise heuristic, the sample set contains a minimal number of samples that cover all pairs of configuration options, whereby each sample is likely to cover multiple pairs. For the code in Figure <ref type="figure" target="#fig_1">2</ref>, with three optional and independent features, a pair-wise sample set consist of 4 configurations: {A, B }, {A, C }, {B , C }, and {}.</p><p>The computation of pair-wise sample sets is not trivial if constraints, such as A implies B or C, exist in a variability model; in fact it is NP-complete (similar to the minimum set cover problem) <ref type="bibr" target="#b21">[21]</ref>. Hence, existing tools apply different conservative approximations to make the computation possible for large systems with many configuration options. For our experiments, we use SPLCATool<ref type="foot" target="#foot_2">3</ref> by Johansen et al., which computes pair-wise samples using covering arrays <ref type="bibr" target="#b21">[21]</ref>. The computed sample covers all pair-wise interactions that occur in a given system, but is not guaranteed to be minimal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">VARIABILITY-AWARE ANALYSIS</head><p>Variability-aware analysis (also known as family-based analysis <ref type="bibr" target="#b43">[43]</ref>) takes advantage of the similarities between the variants of a system in order to speed up the analysis process. Although individual variability-aware analyses differ in many details <ref type="bibr" target="#b43">[43]</ref>, an idea that underlies all of them is to analyze code that is shared by multiple variants only once. To this end, variability-aware analyses do not operate on generated variants, but on the raw code artifacts that still contain variability and available configuration knowledge, prior to the variant-generation step.</p><p>In our context, variability-aware analyses work directly on C code that still contains preprocessor directives. As code artifacts with preprocessor directives cannot be processed directly by standard analyses, an analysis has to be preparedit has to be made variability-aware (plain preprocessing does not help, as it removes variability). Technically, one has to adapt existing analyses to empower them to work with variable code fragments. This approach has been pursued for adapting existing type-checking, model-checking, and testing techniques to variable systems <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b24">24,</ref><ref type="bibr" target="#b26">26,</ref><ref type="bibr" target="#b27">27,</ref><ref type="bibr" target="#b30">30]</ref>.</p><p>Although variability-aware analysis has been applied in academic projects, showing promising performance improvements by orders of magnitude, apart from parsing <ref type="bibr" target="#b25">[25,</ref><ref type="bibr" target="#b26">26]</ref>, it has never been applied to real-world software systems at the scale of Linux. Since many industrial software systems are implemented in C and use #define and #ifdef directives (and a build system) to implement compile-time variability, we set the goal of implementing two variability-aware analyses for C and of applying them to large-scale projects.</p><p>For the purpose of presenting and discussing the results of our empirical study, we explain in the remaining section our design decisions in implementing variability-aware type checking and liveness analysis. Note that we implemented the liveness analysis for the purpose of our study. It is the first variability-aware data-flow analysis for C. It scales to real-world, large-scale systems such as Linux.</p><p>Variable abstract syntax trees. Many static analyses are performed on abstract syntax trees (ASTs). Since we want to analyze an entire variable software system, we have to construct an abstract syntax tree that covers all variants of a system and the corresponding configuration knowledge.</p><p>The desired variable AST is like a standard AST, but it contains additional nodes to express compile-time variation. A Choice node expresses the choice between two or more alternative subtrees (similar to ambiguity nodes in GLR parse forests <ref type="bibr" target="#b45">[45]</ref>; explored formally in the choice calculus <ref type="bibr" target="#b18">[18]</ref>). For example, Choice(A,a&lt;0,0) (Figure <ref type="figure" target="#fig_2">3</ref>, left) expresses the alternative of two expressions a&lt;0 and 0 that is controlled by configuration option A. The choice node is a direct representation of the variable expression in our running example (Figure <ref type="figure" target="#fig_0">1</ref>; #ifdefs on Line 1 to 3 and their usage on Line 7). One alternative of a choice may be empty (ε; see Figure <ref type="figure" target="#fig_2">3</ref>), which makes the other, in fact, optional. In principle, we could use a single Choice node on top of the AST with one large branch per variant; but a variable AST is more compact, because it shares parts that are common across multiple variants (e.g., in Figure <ref type="figure" target="#fig_2">3</ref>, we store only a single node for the declaration of r, and a single node for the function name foo, which are shared by all variants). It is this sharing and keeping variability local, which makes variability-aware analysis faster than a bruteforce approach (see the discussion at the end of this section).</p><p>To reason about variability, we need to represent configuration knowledge. To this end, we annotate subtrees with presence conditions. Propositional formulas are suffi-cient to describe presence conditions and can be efficiently processed by SAT solvers and BDDs <ref type="bibr" target="#b34">[34]</ref>. As an example, in Figure <ref type="figure" target="#fig_0">1</ref>, parameter b is included only if B is selected, whereas the condition of the if statement has two alternative subtrees depending on whether A is selected. In our example, presence conditions are atomic and refer only to a single configuration option, but more complex presence conditions, such as A ∧ ¬(B ∨ C), are possible. By storing presence conditions in Choice nodes, we can derive the code of every variant of the variable system, given the configuration for that variant. Compact representations of variable ASTs in this or similar forms are commonly used in variability-aware analyses <ref type="bibr">[9,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b24">24,</ref><ref type="bibr" target="#b25">25,</ref><ref type="bibr" target="#b46">46]</ref>.</p><p>The construction of a variable AST from a real-world software system such as Linux is not trivial. Whereas parsing preprocessed C code of an individual variant is well established, parsing a variable system with #ifdefs is challenging. To make matters worse, in the C preprocessor, conditional-compilation directives (#ifdef) interact with the build system, with macros (#define), and with file-inclusion facilities (#include), across file boundaries, in intricate ways. In previous work, we solved the parsing challenge and implemented a sound and complete parser as part of the TypeChef project <ref type="bibr" target="#b25">[25]</ref>, incorporating prior work on variability-model extraction and build-system analysis <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b7">7]</ref>. Variability-aware parsing always considers a C file with all its header files. It is this recent breakthrough in parsing that now finally enables the analysis of real-world C code with #ifdef variability. For details on the parser, see the corresponding publication <ref type="bibr" target="#b25">[25]</ref>.</p><p>In the remainder of this paper, we use this parser framework as a black box and work on the resulting variable ASTs.</p><p>Variability-aware type checking. A standard type-checking algorithm for C traverses the AST, collects declarations in a symbol table, and attempts to assign proper types to all expressions (getType: Map[Name,Type]→Expr→Type). In principle, a variability-aware type checker works similar, but covers all variants; hence it must be aware of variability in each of the following three steps.</p><p>First, a symbol (variable, function, etc.) may only be declared in some variants, or it may even have alternative types in different variants. Therefore, we extend the symbol table (similar to the proposal of Aversano et al. <ref type="bibr" target="#b5">[5]</ref>), such that a symbol is no longer mapped to a single type, but to a conditional type (a choice of types or ε; VST = Map[Name,Choice[Type]]). We illustrate a possible encoding of a conditional symbol table for our example in Table <ref type="table" target="#tab_2">1</ref>. If a symbol is declared in all variants, we do not need Choice nodes; however, if a symbol is declared in a subtree of the AST that is only reachable given a certain presence condition, we include the symbol and type in the symbol table only under that condition. Similarly, we may declare a symbol with different types in different variants. In our running example, function foo has two alternative types, depending on whether B is selected. Similarly, we made the table for structures and enumerations in C variability-aware.</p><p>Second, during expression typing, we assign a variable type (choices of types) to each expression (getType: VST→Expr→ Choice[Type]), where already looking up a name in a symbol table may return a variable type. For example, when checking that the condition of an if statement has a scalar type, we need to check that all alternative choices of the variable type are scalar. If the check fails only for some alternative results,  <ref type="table" target="#tab_2">1</ref>). Third, we can use the variability model of a system (if available) to filter all type errors that occur only in invalid variants. To this end, we simply check whether the presence condition of the type error is satisfiable when conjoined with the variability model (checked with a standard SAT solver).</p><p>Variable control-flow graphs. For most data-flow analy- ses, we need to construct a control-flow graph (CFG), which represents all possible execution paths of a program. Nodes of the CFG correspond to instructions in the AST, such as assignments and function calls; edges correspond to possible successor instructions according to the execution semantics of the programming language. A CFG is a conservative static approximation of the actual behavior of the program.</p><p>As with type checking, we need to make CFGs variable to cover all variants of systems. To create a CFG for a single program, we need to compute the successors of each node (succ: Node→List[Node]). In the presence of variability, the successors of a node may differ in different variants, so we need a variability-aware successor function that may return different successor sets for different variants (succ: Node→Choice[List[Node]], or, equivalently, but with more sharing, succ: Node→List[Choice[Node]]). Using the result of this successor function, we can determine for every possible successor, a corresponding presence condition, which we store as annotation of the edge in the variable CFG.</p><p>Let us illustrate variable CFGs by means of the optional statement in Line 12 of our running example of Figure <ref type="figure" target="#fig_0">1</ref>. In Figure <ref type="figure" target="#fig_2">3</ref> (right), we show an excerpt of the corresponding variability-aware CFG (node numbers refer to line numbers of Figure <ref type="figure" target="#fig_0">1</ref>). The successor of the instruction c += a in Line 12 depends on the configuration: if B is selected, statement c += b in Line 13 is the direct successor; if B is not selected, return c in Line 15 is the (only) successor. Technically, we add further nodes to the result set of the successor function, until the conditions of the outgoing edges cover all possible variants, in which the source node is present (checked with a SAT solver or BDDs). By evaluating the presence conditions on edges, we can reproduce the CFG of each variant. 4   4 Alternatively, we could have dropped the presence conditions on edges and express variations of the control flow with if statements. On an if statement, a normal CFG does not evaluate the expression, but conservatively approximates the control flow by reporting Variability-aware liveness analysis. Liveness analysis is a classic data-flow analysis for the computation of variables that are live (that may be read before being written again) for a given statement. Its result can be used, for example, to conservatively detect dead code. In real-world systems, warnings about dead code that occurs only in specific variants are interesting for maintainers; corresponding problems are regularly reported as bugs. 5 So, again, our goal is to make liveness analysis variability-aware. Liveness analysis is based on two functions: uses computes all variables read, and defines computes all variables written to. While, in traditional liveness analysis, both functions return sets of variables, in variability-aware liveness analysis, both return sets that may vary depending on the configuration (a choice of sets or a set with optional entries). The computation of liveness is a fixpoint algorithm that uses two functions, in and out, which compute variables that are live at respectively after the current statement. The result of in and out is variable again, and the signatures of both change from Node→Set <ref type="bibr">[ID]</ref> to Node→Set[Choice <ref type="bibr">[ID]</ref>], where ID represents the identifier of a live variable.</p><p>In Table <ref type="table" target="#tab_3">2</ref>, we show the results of variability-aware liveness analysis for our running example. We show the result of each equation as a set of variables together with their presence condition as subscript. For example, only c is live in the return statement on Line 15. Considering the control flow from Line 10 to 13 (10 → 11 → 12 →B 13), in the declaration statement on Line 10, variable a is live, whereas b is only live if B is selected.</p><p>Principle: Keeping variability local. Although we have introduced how variability-aware analyses work, we have not explained why we expect that they can be executed efficiently even for real-world systems with myriads of possible variants. The key is keeping variability local. Parsing already preserves sharing in the AST and keeps variability local (code without #ifdef directives is represented only once, since it is common to all variants; choices are introduced only locally where code differs between variants). We preserve this sharing and locality throughout our analyses, as far as possible. Specifically, three patterns emerged that maximize sharing: late splitting, local variability representation, and early joining.</p><p>First, late splitting means that we perform the analysis without variability until we encounter it. For example, type both alternative branches as possible successor statements (e.g., in Figure <ref type="figure" target="#fig_2">3</ref>, both nodes 12 and 15 may follow node 11). Such sound but incomplete approximation is standard practice to make static analysis tractable or decidable. However, we do not want to lose precision for static variability. Furthermore, we have only propositional formulas to decide between execution branches, which makes computations decidable and comparably cheap, so we decided in favor of presence conditions on edges, which is in line with prior work on CFG in variable Java programs <ref type="bibr" target="#b8">[8,</ref><ref type="bibr">9]</ref>. 5 e.g., https://bugzilla.kernel.org/show_bug.cgi?id=1664.</p><p>checking processes the declaration of symbol r in Line 5 only once, and adds it to the symbol table only once, whereas a brute-force strategy or a sampling-strategy would process this declaration multiple times. Also, when we use symbol r later, it has only one type. Variability-aware analyses only split and consider smaller parts of the variant space when they actually encounter variability, for example, in the declaration of parameter b. Late splitting is similar to path splitting in on-the-fly model checking, where splitting is also performed only on demand <ref type="bibr" target="#b13">[13]</ref>.</p><p>Second to achieve this locality). Therefore, even after the conditional declaration of parameter b, we only store a single type for a or r, independently of B.</p><p>Third, early joining attempts to join intermediate results as early as possible. For example, if we have a choice of two identical types Choice(A,int,int), we can simply join them to int for further processing. So, even if we need to compute the Cartesian product on some operations with two variable types, the result can often be joined again to a more compact representation. This way, variability from parts of the AST leaks into other parts, if and only if variability actually makes a difference in the internal representations of types, names, or other structures. Also, we need to consider only combinations of configuration options that occur in different parts of the AST if they actually produce different (intermediate) results when combined, otherwise the results remain orthogonal.</p><p>Note that the three patterns of late splitting, local variability representation, and early joining apply to any kind of variability-aware analysis; although not always made explicit, these patterns can also be observed in other variability-aware analyses <ref type="bibr" target="#b4">[4,</ref><ref type="bibr">9,</ref><ref type="bibr" target="#b25">25,</ref><ref type="bibr" target="#b27">27]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EMPIRICAL STUDY</head><p>To evaluate feasibility and scalability of different analysis strategies, we attempt to analyze three real-world, and large-scale systems-a fact that substantially increases external validity, compared to previous work, which concentrated mostly on formal foundations, made limiting assumptions, or relied on comparatively small and academic case studies (see Section 6). We use both state-of-the-art sampling heuristics (single conf, code coverage with and without headers, and pair-wise), as introduced in Section 3. We apply both type checking and liveness analysis. We report our experience and perform rigorous performance measurements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Hypotheses and Research Questions</head><p>Based on the goals and properties of variability-aware and sampling-based analyses, we formulate two hypotheses and two research questions.</p><p>1. Variability-aware vs. single conf: Analyzing all variants simultaneously using variability-aware analysis is likely slower than analyzing a single variant that covers most configuration options. The reason is that the variable program representation covering all variants is larger than the program representation of any single variant, including the largest possible variant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>H1</head><p>The execution times of variability-aware type checking and liveness analysis are larger than the corresponding times of analyzing the variants derived by single-conf sampling.</p><p>2. Variability-aware vs. pair-wise: While previous work has shown that pair-wise sampling is a reasonable approximation of the analysis of all variants <ref type="bibr" target="#b33">[33]</ref>, our previous experience is that it can still generate quite large sample sets. Hence, we expect a variability-aware analysis to outperform pair-wise sampling:</p><p>H2 The execution times of the variability-aware type checking and liveness analysis are smaller than the corresponding times of analyzing the variants derived by pair-wise sampling.</p><p>3. Variability-aware vs. code coverage: With respect to the comparison of variability-aware analysis and codecoverage sampling, we cannot make any informed guesses with respect to analysis time. Code-coverage sampling generates sample sets depending on the usage of configuration options in the analyzed C files. Since we do not know details about the code, we cannot predict how many variants will be generated and how large these will be. Therefore, we pose a research question instead. Specifically, the influence of variability that occurs in header files is unknown and therefore we look at two different variants of code coverage: one including header files and one without.</p><p>RQ1 How do the execution times of variability-aware type checking and liveness analysis compare to the times for analysis of the variants derived by codecoverage sampling (with and without header files)?</p><p>4. Scalability: Finally, we pose the general question of the scalability of variability-aware analysis.</p><p>RQ2 Does variability-aware analysis scale to systems with thousands of configuration options?</p><p>The background for questioning scalability is that variability-aware analysis reasons about variability by solving SAT problems or by using BDDs during analysis, and so depends on the degree of sharing that is possible in practice (see <ref type="bibr">Section 4)</ref>. Generally, SAT is NP-complete, but previous work suggests that the problems that arise in variability-aware analysis are typically tractable for state-of-the-art SAT solvers <ref type="bibr" target="#b34">[34]</ref> and BDDs, and that caching can be an effective optimization <ref type="bibr" target="#b2">[2]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Subject Systems</head><p>To test our hypotheses and to answer our research questions, we selected three subject systems. We looked for publicly available systems (for replicability), that are of substantial size, actively maintained by a community of developers, used in real-world scenarios, and that implement substantial compile-time variability with the C preprocessor. The systems must provide at least an informal variability model that describes configuration options and their valid combinations <ref type="bibr" target="#b31">[31]</ref>. In this context, we would like to acknowledge the pioneering work on variability-model extraction <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b40">40]</ref> and build-system analysis <ref type="bibr" target="#b6">[6]</ref>, which enabled us, for the first time, to conduct variability-aware analysis on substantial, real-world systems that are an order of magnitude larger then previous work on Java-based subjects <ref type="bibr" target="#b4">[4,</ref><ref type="bibr">9,</ref><ref type="bibr" target="#b24">24]</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Experience with Sampling</head><p>Before we discuss the performance measurements, we would like to share our experience with sampling approaches, which were surprising to us. We expected that contemporary sampling tools can quickly compute representative sample sets. However, we found that deriving samples at this scale is far from trivial, and that we even failed to compute sample sets for some sampling heuristics (code coverage with headers for Linux), and that the computation time already takes up to several hours (e.g., pair-wise: &gt;20 h for Linux).</p><p>The single-conf heuristic worked well. Linux has a commonly used configuration allyesconfig, which is maintained by the community and frequently used for analysis purposes. 6  For Busybox and OpenSSL, we created large configurations by selecting as many configuration options as possible.</p><p>Random sampling already proved problematic. Both Busybox and Linux have variability models with many constraints. In 1 000 000 random configurations, there was not even a single configuration that fulfilled all variability-model constraints. Random sampling was only a possibility for OpenSSL, which has a comparably sparse variability model (∼ 3 % of randomly generated configurations were valid). Busybox developers actually uses a skewed form of random sampling, in which, one by one, a random value is selected for every configuration option that is not yet decided by constraints of other options. This approach depends strongly on variable ordering and violates the developer intuition about random selection. Due to these sampling problems in the presence of constraints, we did not consider random sampling any further.</p><p>For the coverage-based and the pair-wise heuristics, we observed that the generation of samples took considerable time (times for sample generation are not part of our reported 6 http://kernel.org/doc/Documentation/kbuild/kconfig.txt analysis times below) and was not possible in all cases (in particular for Linux).</p><p>In contrast to all other heuristics, heuristics based on code coverage need to investigate every file separately (and optionally all their header files). We reimplemented the conservative algorithm of Tartler et al. for this task <ref type="bibr" target="#b41">[41]</ref> in two variants: one including header files (code coverage) and one without (code coverage NH). When headers are included and macros are considered, the coverage analysis easily needs to process several megabytes of source code per C file <ref type="bibr" target="#b25">[25]</ref>. Surprisingly, already the times needed for code-coverage sample computation exceeded the times for performing variability-aware type checking and liveness analysis.</p><p>To compute the pair-wise sample set we only found one research tool (SPLCATool), which is able to compute a complete set of pair-wise configurations for a given feature model (see Section 3). SPLCATool did reasonably well for Busybox and OpenSSL, but the larger configuration space of Linux made the computation of the sample set very expensive. Also in this case, the computation time exceeded the times for performing variability-aware liveness analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Experimental Setup</head><p>We use TypeChef as underlying parsing framework. As explained in Section 4, TypeChef generates a variable AST per file, in which Choice nodes represent optional and alternative code. Our implementations of variability-aware type checking and liveness analysis are based on these variable ASTs, and they are integrated into and deployed as part of the TypeChef project.</p><p>To avoid bias due to different analysis implementations, we use our infrastructure for variability-aware analysis also for the sample-based analyses. To this end, we generate individual variants (ASTs without variability) based on the sampling heuristics. We create an AST for a given configuration by pruning all irrelevant branches of the variable AST, so that no Choice nodes remain. As there is no variability in the remaining AST, the analysis never splits and there is no overhead due to SAT solving, because the only possible presence condition is true.</p><p>As liveness analysis is intraprocedural, it would have been possible and more efficient to apply sampling to individual functions and not to files, as done by Brabrand et al. for Java product lines <ref type="bibr">[9]</ref>. Unfortunately, preprocessor macros in C rule out this strategy, as we cannot even parse functions individually without running the preprocessor first or without performing full variability-aware parsing. In our running example of Figure <ref type="figure" target="#fig_0">1</ref>, we would not even have noticed that function foo is affected by A, because variability comes from variable macros defined outside the function. Variable macros defined in header files are very common in C code <ref type="bibr" target="#b25">[25]</ref>. Furthermore, we implemented only an imprecise liveness analysis, since the analysis is performed without a real analysis question (e.g., which code is dead). The strategy of abstraction is a common approach in model checking <ref type="bibr" target="#b12">[12]</ref>, to handle the complexity of a system and to make the analysis feasible in the first place. In particular, during liveness computation, our algorithms perform SAT checks without taking the variability model of the analyzed system into account. This way, the computation is faster and still complete, though, false positives may occur. False positives can be eliminated easily after a refinement step (i.e., using the variability model in SAT checks), so that only valid execution paths are taken into account <ref type="bibr" target="#b12">[12]</ref>.</p><p>In Figure <ref type="figure" target="#fig_3">4</ref>, we illustrate the experimental setup. Depending on the sampling heuristics, one or multiple configurations are checked. For each file of the three subject systems, we measured the time spent in type checking and liveness analysis, each using the variability-aware approach and the three sampling heuristics (the latter consisting of multiple internal runs)-in total, four analyses per subject system: one variability-aware + three respectively four sampling (with and without header files for code coverage).</p><p>We ran all measurements on Linux machines (Ubuntu 12.04) with Intel Core i7-2600, 3.4 GHz, and 16/32 GB RAM. We configured the Java JVM with upto 8 GB RAM for memory allocation. To reduce measurement bias, we minimized disk access by using a ramdisk and warmed up the JVM by running an example task before the actual measurement run. However, due to just-in-time compilation and automatic garbage collection inside the Java JVM, measurements of analysis times might slightly differ for similar inputs. We could not mitigate this problem with repetitive analysis runs, since the setup already takes weeks to finish, but we believe that the large number of files produces still a reliable result.</p><p>Analysis procedure and reporting. We report performance measurements as total times for the entire analysis and additionally graphically as the distribution of analysis times for individual files in the project, using notched boxplots on a logarithmic scale. We highlight the median (over all files) of the variability-aware analyses with a vertical line, to simplify comparison with the medians of the sample-based analyses.</p><p>Furthermore, we provide the number of analyzed configurations for each of the sample-based analyses (below the name of the analysis, 'configs per file' or short 'c.p.f.'). Single conf requires the same number of variants for each file (because they are based on global knowledge of the variability model only), whereas code coverage and pair-wise<ref type="foot" target="#foot_3">7</ref> require different numbers of variants in different files, which we provide in terms of mean±standard deviation. We evaluate all research hypotheses with paired t-tests at a confidence level of 95 %.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Results</head><p>In Table <ref type="table" target="#tab_6">3</ref>, we show the measurement results for each analysis and subject system. We report sequential times, though parallelization would be possible in all cases, because all files are analyzed in isolation. In Figures <ref type="figure" target="#fig_4">5,</ref><ref type="figure">6</ref>, and 7, we  plot the distributions of analysis times for Busybox, Linux, and OpenSSL, as described in Section 5. <ref type="bibr" target="#b4">4</ref>. In all subject systems and for both type checking and liveness analysis, the variability-aware approach is slower than single-conf sampling (H1; statistically significant), and it is faster than pair-wise sampling (H2; statistically significant). The results regarding code-coverage sampling (H3) are mixed: variability-aware analysis is faster for liveness analysis in Linux, slower for liveness analysis in Busybox and OpenSSL and for type checking of Linux and OpenSSL (statistically significant). We observe that code coverage without header files (NH) is often faster than with header files and sometimes it even outperforms single-conf sampling. The reason for this is that many #ifdefs occur in header files, something that is neglected in code-coverage sampling NH. Single-conf sampling considers variability in header files such that it may select a larger configuration with additional header code, which is potentially unnecessary, and is, therefore, slower than code-coverage sampling NH. Table <ref type="table" target="#tab_8">4</ref> summarizes the actual speedups of all comparisons.</p><p>It is worth noting that we did not find any confirmed defects during our experiments. For Linux, we found a defect already fixed in subsequent releases; for Busybox, we found and reported several defects in earlier versions that have been fixed in the current version, which we used for our experiments.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Discussion</head><p>Our experiments confirm hypotheses H1 and H2: in all three subject systems, variability-aware analysis is faster than sampling-based analysis using the pair-wise heuristics, but slower than using the single-conf heuristics. With respect to research question RQ1, there is no clear picture. The performance of code-coverage sampling depends on the variability implementations in the respective files; the number of sampled variants and performance results differ considerably between files inside each subject system (see Figure <ref type="figure" target="#fig_4">5, 6,</ref> and<ref type="figure" target="#fig_5">7</ref>). So, performance of the code-coverage heuristic is hard to predict and depends strongly on implementation patterns.</p><p>A further observation is that the speedup of variabilityaware liveness analysis in relation to sampling is higher than the speedup of variability-aware type checking. This can be explained by the fact that liveness analysis is intra-procedural, whereas type checking considers entire compilation units. Exploring the performance of variability-aware inter-procedural analyses of large scale systems is an interesting avenue of further work.</p><p>The experimental results for Busybox, Linux, and OpenSSL demonstrate that variability-aware analysis is in the range of the execution times of sampling with multiple samples (code coverage and pair-wise). So, with regard to question RQ2, we conclude that variability-aware analysis is practical for large-scale systems. An important finding is that the overhead induced by solving SAT problems during analy- showing that a complete analysis is already possible at the costs of an incomplete sampling heuristic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Threats to validity.</head><p>A threat to internal validity is that our implementations of variability-aware type checking and liveness analysis support ISO/IEC C, but not all GNU C extensions used in the subject systems (especially Linux).</p><p>Our analyses simply ignore corresponding code constructs. Also due to the textual and verbose nature of the C standard, the implementation does not align entirely with the behavior of the GNU C compiler. Due to these technical problems, we excluded 4 files of Busybox, and 470 files of Linux from our study. All numbers presented in this paper have been obtained after excluding the problematic files. Still, the comparatively large numbers of 518 files for Busybox, 7 221 files for Linux, and 733 files for OpenSSL deem the approach practical and our evaluation representative. Second, the variants generated by the sampling heuristics represent only a small subset of possible variants (which is the idea of sampling). But, for pair-wise sampling, it may happen that some variants of a file are very similar, as the difference in the respective variant configurations affect the content of a file only to a minor or no extent. However, we argue that our conclusions are still valid, as this lies in the nature of the sampling heuristics, and all heuristics we have used are common in practice.</p><p>Finally, a (standard) threat to external validity is that we considered only three subject systems. We argue that this threat is largely compensated by their size and the fact that many different developers and companies contributed to the development of these systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED WORK</head><p>Our implementations of variability-aware type checking and liveness analysis are inspired by earlier work in two fields.</p><p>First, we and others have developed variability-aware type systems for academic languages such as Featherweight Java <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b24">24]</ref>, Lightweight Java <ref type="bibr" target="#b16">[16]</ref>, the lambda calculus <ref type="bibr" target="#b11">[11]</ref>, and other dialects of Java <ref type="bibr" target="#b24">[24,</ref><ref type="bibr" target="#b42">42]</ref>. First conceptual sketches even reach back 10 years <ref type="bibr" target="#b5">[5]</ref>. Although a prior version of our C type checker has been used to study a variability-aware module systems and has been applied to Busybox, it has not been evaluated in an empirical assessment and comparison to sample-based type checking <ref type="bibr" target="#b26">[26]</ref>.</p><p>Second, researchers proposed variability-aware approaches for data-flow analysis. Closest to our work, Brabrand et al. compared three different algorithms for variability-aware, intra-procedural data-flow analysis for Java against a bruteforce approach <ref type="bibr">[9]</ref>. Similarly, Bodden proposed an approach to extend an existing inter-procedural, data-flow analysis framework to make it variability-aware <ref type="bibr" target="#b8">[8]</ref>. Both approaches are limited to an academic environment in which the input Java programs contain #ifdef-like variability annotations managed by a research tool; there are no substantial variable real-world systems that use this technique. Furthermore, both variability-aware analysis approaches make frequently limiting assumptions on the form of variability (in particular, type uniformity <ref type="bibr" target="#b24">[24]</ref> and annotation discipline <ref type="bibr" target="#b23">[23,</ref><ref type="bibr" target="#b32">32]</ref>), which do not hold in real-world software systems <ref type="bibr" target="#b25">[25,</ref><ref type="bibr" target="#b32">32]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSION</head><p>In this paper, we reported on our experience with the implementation and performance of practical, scalable, variabilityaware and sampling-based analyses for real-world, large-scale systems written in C, including preprocessor directives. In a series of experiments on three real-world, large-scale subject systems, including the Linux kernel, we compared the performance of variability-aware type checking and liveness analysis with the performance of corresponding state-of-the-art sampling heuristics (single conf, pair-wise, and code coverage).</p><p>In our experiments, we found that the performance of variability-aware analysis scales to large software systems, such as the Linux kernel, and even outperforms some of the sampling heuristics, while still being complete. In contrast to previous work on sampling, we faced many problems and found several limiting factors that render state-of-the-art sampling heuristics, such as pair-wise, infeasible.</p><p>In future work, we aim at the development of further analyses, at experimenting with other sampling heuristics and with more case studies, and at setting up an automated and incremental checking system for producing bug reports.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Running example in C with variability expressed in the form of preprocessor directives (Lines 1-3, 6, and 13); for brevity, we underlined and integrated #ifdef directives inside single code lines.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: C code with preprocessor directives; the header file (left) contains one alternative and one optional definition; the C file (right) uses the definitions of the header file.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Excerpt of the corresponding variable AST (left) and CFG (right) for our running example of Figure 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Experimental setup.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Distribution of analysis times for Busybox (times in milliseconds; logarithmic scale).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Distribution of analysis times for OpenSSL (times in milliseconds; logarithmic scale).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc>Conditional symbol table at Line 6 of our running example of Figure1. Therein, an operation on two variable types can, in the worst case, result in the Cartesian product of the types in either case of the choice, resulting in a variable type with many alternatives. All other type rules are essentially implemented along the same lines. In our running example, we would report a type error in Line 8, because symbol b cannot be resolved in variants without B (see Table</figDesc><table><row><cell cols="2">Symbol (Conditional) Type</cell><cell>Scope</cell></row><row><cell>r</cell><cell>int</cell><cell>0</cell></row><row><cell>foo</cell><cell>Choice(B,int→int→int,int→int)</cell><cell>0</cell></row><row><cell>a</cell><cell>int</cell><cell>1</cell></row><row><cell>b</cell><cell>Choice(B,int,ε)</cell><cell>1</cell></row><row><cell cols="3">we report a type error and pinpoint it to a subset of variants,</cell></row><row><cell cols="3">as characterized by a corresponding presence condition. Sim-</cell></row><row><cell cols="3">ilarly, an assignment is only valid if the expected (variable)</cell></row><row><cell cols="3">type is compatible with the provided (variable) type in all</cell></row><row><cell>variants.</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 :</head><label>2</label><figDesc>Result of liveness computation of our running example of Figure1; b B is shorthand for Choice(B,b,ε).</figDesc><table><row><cell>Line Uses</cell><cell cols="2">Defines In</cell><cell>Out</cell></row><row><cell>10 {a}</cell><cell>{c}</cell><cell>{a,bB }</cell><cell>{a,bB ,c}</cell></row><row><cell>11 {c}</cell><cell>{}</cell><cell cols="2">{a,bB ,c} {a,bB ,c}</cell></row><row><cell>12 {a,c}</cell><cell>{c}</cell><cell cols="2">{a,bB ,c} {bB ,c}</cell></row><row><cell cols="2">13 {bB ,cB } {cB }</cell><cell cols="2">{bB ,cB } {cB }</cell></row><row><cell>15 {c}</cell><cell>{}</cell><cell>{c}</cell><cell>{}</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>, local variability representation aims at keeping variability local in intermediate results. For example, instead of copying the entire symbol table for a single variable entry, we have only a single symbol table with conditional entries (technically, we use Map[String,Choice[Type]] instead of Choice[Map[String,Type]]</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>•</head><label></label><figDesc>The Busybox tool suite reimplements most standard Unix tools for resource-constrained systems. With 792 configuration options it is highly configurable; most of the options refer to independent and optional subsystems; the variability model in conjunctive normal form has 993 clauses. We use Busybox version 1.18.5 (522 files and 191 615 lines of source code). The cryptographic library OpenSSL implements different protocols for secure Internet communication. OpenSSL can be tailored to many different platforms, and it provides a rich set of 589 configuration options. We analyze OpenSSL version 1.0.1c with 733 files and 233 450 lines of code. Since OpenSSL does not come with a formal variability model like Busybox or Linux, we extracted a variability model based on manual analysis. The resulting variability model has 15 clauses.</figDesc><table><row><cell>• The Linux kernel (x86 architecture, version 2.6.33.3) is</cell></row><row><cell>an operating-system kernel with millions of installations</cell></row><row><cell>worldwide, from high-end servers to mobile phones.</cell></row><row><cell>With 6 918 configuration options it is highly config-</cell></row><row><cell>urable. In a previous study, we identified the Linux ker-</cell></row><row><cell>nel as one of the largest and most complex (w.r.t. vari-</cell></row><row><cell>ability) publicly available variable software systems [31].</cell></row><row><cell>It has 7 691 source code files with 6.5 million lines of</cell></row><row><cell>code. Note that already the variability model of Linux</cell></row><row><cell>is of substantial size: the corresponding extracted for-</cell></row><row><cell>mula in conjunctive normal form has over 60 000 vari-</cell></row><row><cell>ables and nearly 300 000 clauses; a typical satisfiability</cell></row><row><cell>check requires half a second on a standard computer.</cell></row><row><cell>•</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 3 :</head><label>3</label><figDesc>Total times for analyzing the subjects with each approach (time in seconds, with three significant digits).</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">Type checking</cell><cell cols="2">Liveness analysis</cell></row><row><cell>Busybox</cell><cell cols="2">Single conf Code coverage NH Code coverage Pair-wise Variability-aware</cell><cell></cell><cell cols="2">40.3 107 2 030 1 110 223</cell><cell></cell><cell></cell><cell>19.4 67.1 985 544 97.3</cell></row><row><cell>Linux</cell><cell cols="2">Single conf Code coverage NH Pair-wise Variability-aware</cell><cell></cell><cell cols="2">5 060 33 000 569 000 73 500</cell><cell></cell><cell></cell><cell>2 560 22 500 380 000 13 900</cell></row><row><cell>OpenSSL</cell><cell cols="2">Single conf Code coverage NH Code coverage Pair-wise Variability-aware</cell><cell></cell><cell cols="2">64.1 86.9 388 1 110 228</cell><cell></cell><cell></cell><cell>24.5 37.6 145 455 44.7</cell></row><row><cell>Liveness analysis</cell><cell>variability-aware pair-wise (30.6±2.52 c. p. f.) code coverage (43.9±6.55 c. p. f.) code coverage NH (2.53±3.59 c. p. f.) single conf (1 config per file)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>20</cell><cell>50</cell><cell></cell><cell>100</cell><cell cols="2">200</cell><cell>500</cell><cell>1000</cell><cell>2000</cell></row><row><cell></cell><cell>single conf</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Type checking</cell><cell>variability-aware pair-wise (30.6±2.52 c. p. f.) code coverage (43.9±6.55 c. p. f.) code coverage NH (2.53±3.59 c. p. f.) (1 config per file)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>2</cell><cell>5</cell><cell>10</cell><cell>20</cell><cell>50</cell><cell>100 200</cell><cell></cell><cell>500 1000</cell><cell>5000</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 4 :</head><label>4</label><figDesc>Speedup of variability-aware analysis; a speedup &lt; 1.0 means that sampling is faster and a speedup &gt; 1.0 means that variability-aware analysis is faster (nonsignificant result in parentheses). OpenSSL) variants. That is, if a sampling heuristic produces a sampling set larger than that (or if continuing random sampling for more than this number of samples), variability-aware analysis is faster and also complete. All values are very low compared with the number of the possible variants of the respective system,</figDesc><table><row><cell>Variability-aware vs.</cell><cell>Type checking</cell><cell>Liveness analysis</cell></row><row><cell cols="3">Busybox 0.20 sis is not a bottleneck, not even for large systems such as Single conf 0.18</cell></row><row><cell cols="3">the Linux kernel. Overall, variability-aware type checking</cell></row><row><cell cols="3">(compared to single conf) in Busybox takes as much time as</cell></row><row><cell cols="3">checking 6 variants (15 variants in Linux and 4 variants in</cell></row><row><cell cols="3">OpenSSL). For liveness analysis, the break-even point is after</cell></row><row><cell cols="2">5 (Busybox), 6 (Linux), and 2 (</cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>https://www.kernel.org/doc/Documentation/kbuild/ kconfig-language.txt</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>For more details on the optimal algorithm, see https://github. com/ckaestne/OptimalCoverage.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>http://heim.ifi.uio.no/martifag/splcatool</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_3"><p>In addition to the given variability model, the build system of Linux defines presence conditions for individual files. So, as for Linux, each file has its own variability model. Nevertheless, we use the global variability model for the computation of pair-wise sample sets. Since, the sample may contain configurations that are not valid for a file, the overall number of analyzed configurations for a file decreases.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_4"><p>Bug reports: https://bugs.busybox.net/show_bug.cgi?id=4994 ; http://lists.busybox.net/pipermail/busybox/2012-April/ 077683.html</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGMENTS</head><p>We thank Tillmann Rendel for fruitful discussions on patterns in variability-aware analysis, and Klaus Ostermann for pushing us to generalize the underlying concepts of variabilityaware analysis. This work has been supported in part by the German Research Foundation (AP 206/2, AP 206/4, AP 206/5, and LE 912/13) and ERC grant #203099.</p></div>
			</div>


			<div type="availability">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Code coverage NH 0.48 ( 0.69 ) Code coverage 9.10 10.12 Pair-wise 5.01 5.59 Linux Single conf 0.07 0.18 Code coverage NH 0.45 1.61 Pair-wise 7.74 27.24 OpenSSL Single conf 0.28 0.54 Code coverage NH 0.38 0.84 Code coverage 1.70 3.24 Pair-wise 4.88 10.17</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">An Overview of Feature-Oriented Software Development</title>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kästner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Object Technology</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="49" to="84" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Type Safety for Feature-Oriented Product Lines</title>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kästner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Größlinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lengauer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Automated Software Engineering</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="251" to="300" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Detection of Feature Interactions using Feature-Aware Verification</title>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Speidel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wendler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Von Rhein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Beyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Automated Software Engineering (ASE)</title>
		<meeting>Int. Conf. Automated Software Engineering (ASE)</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="372" to="375" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Strategies for Product-Line Verification: Case Studies and Experiments</title>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Von Rhein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wendler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Größlinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Beyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Software Engineering (ICSE)</title>
		<meeting>Int. Conf. Software Engineering (ICSE)</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="482" to="491" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Handling Preprocessor-Conditioned Declarations</title>
		<author>
			<persName><forename type="first">L</forename><surname>Aversano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">Di</forename><surname>Penta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Baxter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Working Conf. Source Code Management and Manipulation (SCAM)</title>
		<meeting>Working Conf. Source Code Management and Manipulation (SCAM)</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="83" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Feature-to-Code Mapping in Two Large Product Lines</title>
		<author>
			<persName><forename type="first">T</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>She</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Czarnecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wasowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Software Product Line Conference (SPLC)</title>
		<meeting>Int. Software Product Line Conference (SPLC)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="498" to="499" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Variability Modelling in the Real: A Perspective from the Operating Systems Domain</title>
		<author>
			<persName><forename type="first">T</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>She</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lotufo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wasowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Czarnecki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Automated Software Engineering (ASE)</title>
		<meeting>Int. Conf. Automated Software Engineering (ASE)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="73" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">SPL LIFT -Statically Analyzing Software Product Lines in Minutes Instead of Years</title>
		<author>
			<persName><forename type="first">E</forename><surname>Bodden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mezini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Brabrand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Tolêdo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ribeiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Borba</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Programming Language Design and Implementation (PLDI)</title>
		<meeting>Int. Conf. Programming Language Design and Implementation (PLDI)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="355" to="364" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Intraprocedural Dataflow Analysis for Software Product Lines</title>
		<author>
			<persName><forename type="first">C</forename><surname>Brabrand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ribeiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Tolêdo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Borba</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Aspect-Oriented Software Development (AOSD)</title>
		<meeting>Int. Conf. Aspect-Oriented Software Development (AOSD)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="13" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Feature Interaction Detection by Pairwise Analysis of LTL Properties: A Case Study</title>
		<author>
			<persName><forename type="first">M</forename><surname>Calder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Methods in System Design</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="213" to="261" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">An Error-Tolerant Type System for Variational Lambda Calculus</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Erwig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Walkingshaw</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Functional Programming (ICFP)</title>
		<meeting>Int. Conf. Functional Programming (ICFP)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="29" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Counterexample-guided Abstraction Refinement for Symbolic Model Checking</title>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Veith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="752" to="794" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Peled</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Model Checking. The MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Model Checking Lots of Systems: Efficient Verification of Temporal Properties in Software Product Lines</title>
		<author>
			<persName><forename type="first">A</forename><surname>Classen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Heymans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-Y</forename><surname>Schobbens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Legay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-F</forename><surname>Raskin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Software Engineering (ICSE)</title>
		<meeting>Int. Conf. Software Engineering (ICSE)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="335" to="344" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">K</forename><surname>Czarnecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Eisenecker</surname></persName>
		</author>
		<title level="m">Generative Programming: Methods, Tools, and Applications</title>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Fitting the Pieces Together: A Machine-Checked Model of Safe Composition</title>
		<author>
			<persName><forename type="first">B</forename><surname>Delaware</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Batory</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Symp. Foundations of Software Engineering (FSE)</title>
		<meeting>Int. Symp. Foundations of Software Engineering (FSE)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="243" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Understanding Linux Feature Distribution</title>
		<author>
			<persName><forename type="first">C</forename><surname>Dietrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tartler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Schröder-Preikshat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lohmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. AOSD Workshop Modularity in Systems Software (MISS)</title>
		<meeting>AOSD Workshop Modularity in Systems Software (MISS)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="15" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The Choice Calculus: A Representation for Software Variation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Erwig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Walkingshaw</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Software Engineering and Methodology</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="6" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Feature Interaction Faults Revisited: An Exploratory Study</title>
		<author>
			<persName><forename type="first">B</forename><surname>Garvin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Cohen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Symp. Software Reliability Engineering (ISSRE)</title>
		<meeting>Int. Symp. Software Reliability Engineering (ISSRE)</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="90" to="99" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">C/C++ Conditional Compilation Analysis using Symbolic Execution</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Merlo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dagenais</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Lagüe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Software Maintenance (ICSM)</title>
		<meeting>Int. Conf. Software Maintenance (ICSM)</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="196" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Properties of Realistic Feature Models Make Combinatorial Testing of Product Lines Feasible</title>
		<author>
			<persName><forename type="first">M</forename><surname>Johansen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ø</forename><surname>Haugen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Fleurey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Model Driven Engineering Languages and Systems (MODELS)</title>
		<meeting>Int. Conf. Model Driven Engineering Languages and Systems (MODELS)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="638" to="652" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">An Algorithm for Generating t-Wise Covering Arrays from Large Feature Models</title>
		<author>
			<persName><forename type="first">M</forename><surname>Johansen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Haugen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Fleurey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Software Product Line Conference (SPLC)</title>
		<meeting>Int. Software Product Line Conference (SPLC)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="46" to="55" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Granularity in Software Product Lines</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kästner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kuhlemann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Software Engineering (ICSE)</title>
		<meeting>Int. Conf. Software Engineering (ICSE)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="311" to="320" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Type Checking Annotation-Based Product Lines</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kästner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Thüm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Saake</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Software Engineering and Methodology</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="39" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Variability-Aware Parsing in the Presence of Lexical Macros and Conditional Compilation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kästner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Giarrusso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rendel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Erdweg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ostermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Berger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conf. Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</title>
		<meeting>Conf. Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="805" to="824" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A Variability-Aware Module System</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kästner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ostermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Erdweg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conf. Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</title>
		<meeting>Conf. Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="773" to="792" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Toward Variability-Aware Testing</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kästner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Von Rhein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Erdweg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pusch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rendel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ostermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Workshop Feature-Oriented Software Development (FOSD)</title>
		<meeting>Int. Workshop Feature-Oriented Software Development (FOSD)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Software Fault Interactions and Implications for Software Testing</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kuhn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gallo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Engineering</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="418" to="421" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Fast Symbolic Evaluation of C/C++ Preprocessing using Conditional Values</title>
		<author>
			<persName><forename type="first">M</forename><surname>Latendresse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. European Conf. Software Maintenance and Reengineering (CSMR)</title>
		<meeting>European Conf. Software Maintenance and Reengineering (CSMR)</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="170" to="179" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Model Checking of Domain Artifacts in Product Line Engineering</title>
		<author>
			<persName><forename type="first">K</forename><surname>Lauenroth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Toehning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pohl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Automated Software Engineering (ASE)</title>
		<meeting>Int. Conf. Automated Software Engineering (ASE)</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="269" to="280" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">An Analysis of the Variability in Forty Preprocessor-Based Software Product Lines</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liebig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lengauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kästner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schulze</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Software Engineering (ICSE)</title>
		<meeting>Int. Conf. Software Engineering (ICSE)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="105" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Analyzing the Discipline of Preprocessor Annotations in 30 Million Lines of C Code</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liebig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kästner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Aspect-Oriented Software Development (AOSD)</title>
		<meeting>Int. Conf. Aspect-Oriented Software Development (AOSD)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="191" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Model-based Pairwise Testing for Feature Interaction Coverage in Software Product Line Engineering</title>
		<author>
			<persName><forename type="first">M</forename><surname>Lochau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Oster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Goltz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schürr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software Quality Journal</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="567" to="604" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">SAT-based Analysis of Feature Models is Easy</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mendonça</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wasowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Czarnecki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Software Product Line Conference (SPLC)</title>
		<meeting>Int. Software Product Line Conference (SPLC)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="231" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">A Survey of Combinatorial Testing</title>
		<author>
			<persName><forename type="first">C</forename><surname>Nie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Leung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="29" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Automated Incremental Pairwise Testing of Software Product Lines</title>
		<author>
			<persName><forename type="first">S</forename><surname>Oster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Markert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ritter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Software Product Line Conference (SPLC)</title>
		<meeting>Int. Software Product Line Conference (SPLC)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="196" to="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Pairwise Testing for Software Product Lines: Comparison of Two Approaches</title>
		<author>
			<persName><forename type="first">G</forename><surname>Perrouin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Oster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Baudry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Traon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software Quality Journal</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="605" to="643" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Predicting Performance via Automated Feature-Interaction Detection</title>
		<author>
			<persName><forename type="first">N</forename><surname>Siegmund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kolesnikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kästner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Batory</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rosenmüller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Saake</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Software Engineering (ICSE)</title>
		<meeting>Int. Conf. Software Engineering (ICSE)</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="167" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Is the Linux Kernel a Software Product Line?</title>
		<author>
			<persName><forename type="first">J</forename><surname>Sincero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Schirmeier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Schröder-Preikschat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Spinczyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Workshop Opens Source Software and Product Lines (OSSPL)</title>
		<meeting>Int. Workshop Opens Source Software and Product Lines (OSSPL)</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Feature Consistency in Compile-Time Configurable System Software</title>
		<author>
			<persName><forename type="first">R</forename><surname>Tartler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lohmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Dietrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Egger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sincero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EuroSys Conf</title>
		<meeting>EuroSys Conf</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="47" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Configuration Coverage in the Analysis of Large-scale System Software</title>
		<author>
			<persName><forename type="first">R</forename><surname>Tartler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lohmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Dietrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Egger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sincero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGOPS Oper. Syst. Rev</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="10" to="14" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Safe Composition of Product Lines</title>
		<author>
			<persName><forename type="first">S</forename><surname>Thaker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Batory</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kitchin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Generative Programming and Component Engineering (GPCE)</title>
		<meeting>Int. Conf. Generative Programming and Component Engineering (GPCE)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="95" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">Analysis Strategies for Software Product Lines</title>
		<author>
			<persName><forename type="first">T</forename><surname>Thüm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kästner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kuhlemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Schaefer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Saake</surname></persName>
		</author>
		<idno>FIN-004-2012</idno>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
		<respStmt>
			<orgName>University of Magdeburg</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Family-Based Theorem Proving for Deductive Verification of Software Product Lines</title>
		<author>
			<persName><forename type="first">T</forename><surname>Thüm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Schaefer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hentschel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Generative Programming and Component Engineering (GPCE)</title>
		<meeting>Int. Conf. Generative Programming and Component Engineering (GPCE)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="11" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">LR Parsers for Natural Languages</title>
		<author>
			<persName><forename type="first">M</forename><surname>Tomita</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Computational Linguistics (ACL)</title>
		<meeting>Int. Conf. Computational Linguistics (ACL)</meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="354" to="357" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Introducing Binary Decision Diagrams in the Explicit-State Verification of Java Code</title>
		<author>
			<persName><forename type="first">A</forename><surname>Von Rhein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Raimondi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Java Pathfinder Workshop</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page">11</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Software Unit Test Coverage and Adequacy</title>
		<author>
			<persName><forename type="first">H</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>May</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="366" to="427" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
