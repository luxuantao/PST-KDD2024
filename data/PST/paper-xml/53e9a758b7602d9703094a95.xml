<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Flexible Conflict Detection and Management In Collaborative Applications</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Keith</forename><surname>Edwards</surname></persName>
							<email>kedwards@parc.xerox.com</email>
							<affiliation key="aff0">
								<orgName type="department">Xerox Palo Alto Research Center</orgName>
								<address>
									<addrLine>3333 Coyote Hill Road</addrLine>
									<postCode>94304</postCode>
									<settlement>Palo Alto</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><surname>Uist</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Xerox Palo Alto Research Center</orgName>
								<address>
									<addrLine>3333 Coyote Hill Road</addrLine>
									<postCode>94304</postCode>
									<settlement>Palo Alto</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Bmfj</forename><surname>Alberta</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Xerox Palo Alto Research Center</orgName>
								<address>
									<addrLine>3333 Coyote Hill Road</addrLine>
									<postCode>94304</postCode>
									<settlement>Palo Alto</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><surname>Conch</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Xerox Palo Alto Research Center</orgName>
								<address>
									<addrLine>3333 Coyote Hill Road</addrLine>
									<postCode>94304</postCode>
									<settlement>Palo Alto</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Flexible Conflict Detection and Management In Collaborative Applications</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">7AAB0CFFAD34525C2A8D45A40CFC2437</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:21+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>CSCW</term>
					<term>collaborative infrastructure</term>
					<term>conflict management</term>
					<term>Timewarp</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper presents a comprehensive model for dealing with semantic conflicts in applications, and the implementation of this model in a toolkit for collaborative systems. Conflicts are defined purely through application semantics-the set of behaviors supported by the applications-and yet can be detected and managed by the infrastmcture with minimal application code. This work describes a number of novel techniques for managing conflicts, both in the area of resolution policies and user interfaces for presenting standing conflicts in application data.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>INTRODUCTION</head><p>Most collaborative applications involve the shared use of some artifact by a number of users. Infrastructures for supporting such applications must implement mechanisms for dealing with consistency in the shared artifact-that is, the degree to which the views and data shared by the participants are the same, and structurally intact. Some systems support a strict consistency model, in which all participants have exactly the same views and data at all times. Examples of mechanisms for supporting strict consistency include floor control systems and pessimistic locking protocols.</p><p>Other systems allow divergence-albeit usually temporary-among replicas. Examples of such mechanisms include optimistic locking <ref type="bibr">[7]</ref> and "operational transformation" strategies <ref type="bibr">[6]</ref>. In all of these cases, the developers of the infrastructure make an implicit choice about the form of consistency control that will be used by applications built atop the infrastructure. This choice represents some point in the space of consistency versus performance and scalability. participate in the definition of consistency and the particulars of how-and whether--consistency will be maintained and managed.</p><p>More concretely, this work deals with the issue of conflicts-violations of the consistency invariants in a given application. Rather than simply taking the approach that conflicts must be avoided through consistency controls, resolution protocols, and the like, this model treats conflicts as a naturally-arising side effect of the collaborative process. These conflicts may be resolved in any number of ways, or even tolerated and allowed to stand. Further, since applications have widely-varying notions of what constitutes a conflict, this work accommodates appliwtion-d-e$ned (rather than a priori infrastructuredefined) semantics for describing what constitutes a conflict and how conflicts are managed.</p><p>The goal of this work is to address a set of mechanisms that can be used across applications to manage "high-level" application-defined conflicts. Put another way, the central question here is how one builds infrastructure, which by its nature must be general, that can detect and manage conflicts which by their nature arise from application semantics. This work is described in the context of the Timewarp collaborative toolkit <ref type="bibr">[5]</ref>. Timewarp is an infrastructure for building applications that permit divergent views of an artifact shared among participants. Users of Timewarp applications have available to them the complete, global history of the artifact, and can move through and edit the multiple, parallel histories of the artifact to manage divergence. Timewarp provides an explicit representation of the work of multiple users across versions of an artifact. The history of the artifact itself becomes a shared, globallyavailable artifact that can be used to mediate collaboration.</p><p>While the implementation discussed here, and even the notion of making artifact histories explicis is particular to Timewarp, the model of divergence that it makes explicit is essentially identical to the implicit divergence that exists in many multi-user systems. In such systems, multiple users work with versions of an artifact that may be divergent, and often are later reconciled or merged into a single version. Timewarp presents the problems of versioning and alternate artifact histories in a microcosm-all of these applications deal with the same problems, but reify their models of operations and wnflicts in different ways. The strategies and mechanisms for dealing with conflicts in'Timewarp should be "portable" to other collaborative infrastructures.</p><p>This paper begins by discussing some goals for this work, based on the perspective of several applications that support rich conflict semantics. From this perspective, we next examine a taxonomy of the types of conflicts that may arise in collaborative applications. This analysis raises several issues that must be addressed by a conflict management system, and motivates our discussion of a particular model for conflict management, and the requirements for a supple infrastructure to support conflict management. We discuss the two major features of our model-conflict detection and management-and describe how these features can be applied to a range of application, needs. A number of novel approaches to conflict management-are explored We then examine the particulars of 'how the -Timewarp toolkit implements this model. I</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PERSPECTIVE, MOTIVATIOh&amp;-AND GOALS</head><p>When work started on the Timewarp'toolkit, it was clear that the issue of conflict management would be of paramount importance in determining '-its usability and power. Nevertheless, early versions. ,of the system had little infrastructure sufiport to assist m managing conflicts.</p><p>The first application, a structured drawing editor, had a relatively simple conflict model. Still, the code to detect, resolve, and manage conflicts, as well as provide a user interface to these functions, quickly grew to several thousand lines of code that was difficult to manage and more difficult to extend. Worse from the perspective of a toolkit designer, the conflict management code began to "pollute" the relatively clean application programming model.</p><p>The situation worsened with the next application, an office furniture layout program.' While superficially similar to the drawing tool, tbis application supported multi@e types of conflicts. These conflict types, in addition to having very different semantics, have radically different requirements for detection and resolution, as we shall see later in the paper.</p><p>Complicating the matter further -was the fact that some operations in the application could simultaueously cause multiple types of wnflicts to arise. Dealing with wnflicts in complex applications can potentially cause an explosion in code size and complexity, especially when the combinatorial nature of most conflicts is considered.</p><p>From experiences with these and other later applications, several goals arose for this worE l Simplicity. The infrastructure should, it all WSQ, minimize the required work for application writers.</p><p>l Scope. The infrastructure must support not only conflict detection, but also resolution and user interface issues.</p><p>l Flexibility. Despite outward similarities, the drawing and layout applications used very different approaches and user interfaces for dealing with conflicts. The infrastructure must support a wide range of application requirements in the arena of conflict management.</p><p>. Modularity. The mechanics of con&amp;t detection should be separated from conflict handling policy. Thus, application writers should be able to "plug in" different conflict handling policies and have their applications still work. This modularity should enwurage experimentation with radically new forms of conflict management.</p><p>More specifically, there are a number of concrete issues that must be addressed by an infrastructure to provide flexible management of wnflicts. Applications may have widely varying requirements for dealing with conflicts-some applications may be able to tolerate certain types of semantic conflicts; others may not. Some applications in which conflicts may occur may be able to automatically resolve some conflicts without human intervention; others may require manual resolution. Thus our conflict infrastructure must be able to deal with several distinct, specific problems:</p><p>Detecting the presence of runtime inconsistencies within sets of application-supplied invariants.</p><p>Supporting mechanisms for'both automatic and manual resolution of conflicts. 'Resolution" means doing away with the situation that caused the conflict to arise in the firstplace. ,</p><p>All&amp;ing certain types of unresolved conflicts to be tolerated, and others to be disallowed, depending on application semantics and requirements.</p><p>Providing a systematic way of dealing with UI concerns about notification and comprehension of conflicts.</p><p>In the next.section we examine the types of conflicts that can arise in multi-user applications. Most multi-user applications can support rich models of conflict; understanding how conflicts arise and i&amp;act is essential for developing robust conflict-management strategies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A BESTlkRY OF CONFLICTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Syntactic versus Semantic Conflicts</head><p>It is useful io make a distinction between two broad classes of wnflicts. Dourish [3] classifies conflicts as either synta@ " or semantic. Syntactic conflicts represent inconsistencies that occur below the level of application code; that is, in the toolkit and systems infrastructure itself. Semantic conflicts are inconsistencies that occur above the dividing line between application and infrastructure.</p><p>A given application may have completely sound, intemallyconsistent data structures (that is, have no syntactic conflicts), and yet still expose application-level semantic conflicts-to its users. A common example of such a system is a version control tool. Such a tool expects its revision logs to be accurate and internally-consistent, but can expose semantic conflicts when merging disparate file versions to its users.</p><p>Conversely, although more rare, applications may be built on an infrastructure that allows-perhaps temporarilysyntactic inconsistencies; these systems may or may not expose application-level semantic conflicts. In fact, in some cases the application itself may not even be "aware" that the infrastructure is managing internal conflicts as it runs, An example of such an infrastructure is the Bayou system [ll], a weakly-consistent distributed data storage system that presents a relational data model to application writers. At any given moment, a Bayou server may contain data that, from the perspective of the application using the data, is not internally consistent. Applications can choose the level of consistency they wish the infrastructure to expose to them.</p><p>Although this distinction is a somewhat artificial one-one person's infrastructure is another person's application-it turns out to be useful when considering problems of programmatic interfaces and application support for managing wnflicts.</p><p>This work addresses facilities for managing semantic conjkts. We shall not deal with mechanisms for supporting weak consistency, or epidemic algorithms for obtaining eventual consistency, or locking, or other approaches for addressing syntactic consistency. Further, we shall not address the issue of how conflicts arise-whether through weak consistency or network partitioning or merging.</p><p>Rather, this work assumes that in most complex collaborative systems, conflicts will occur simply because of the semantics of multi-user applications. The specific focus of this work is how to build a systems infrastructure that can support the needs of applications to manage the types of conflicts that arise purely because of their own particular semantics. The model here does not necessarily assume that applications require syntactic consistency. Rather it does not address the problems of syntactic consistency at all, and considers them orthogonal to the problems of semantic consistency. Applications using this model may or may not be built on an infrastructure that tolerates syntactic inconsistencies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Some Classes of Semantic Conflicts</head><p>Within the category of semantic conflicts, there are potentially any number of classes of conflicts that can arise. Consider a shared drawing application as an example. Suppose that because of the architecture of this application, operations on the shared artifact can become arbitrarily interleaved-whether through weak consistency among replicas, editable timelines a la Timewarp, or the merging of two divergent versions of the drawing.</p><p>Several types of semantic wnfhcts can arise in this situation. First, consider the case where an operation draws a new figure on the canvas, and is followed by an operation that moves that same figure. Now, if an operation that deletes the figure is performed between the draw and move operations, a temporal conflict will result-the move operation will now refer to a figure which no longer exists in the,drawmg.</p><p>Temporal wnflicts arise because of inconsistencies in the up-stream (earlier) and down-stream (later) dependencies in a sequence of ordered operations.</p><p>As a second example, imagine an office furniture layout tool that does not allow overlapping figures. In this case, even if the application does not allow a single user to place an object directly on top of another one, operations may still become interleaved in such a way that objects overlap one another, whether through merging or movement toward eventual consistency. This example shows a spatial conflict-an application constraint on the placement of objects has been violated.</p><p>Both of these classes of conflicts, temporal and spatial, arise purely through the semantics of the particular application. Other applications may not consider such sequences of operations conflicts, or may not even support similar operations at all. Likewise, other applications may have completely new classes of conflicts: structural conflicts in a flowchart editor that requires that all nodes be reachable from a root, for example.</p><p>These examples by no means represent all types of conflicts that can occur in applications. Rather, the represent several specific types of conflicts that can happen in a given application, and point to the complexities and wide variations that arise in defining application-specific conflicts. Further, they illustrate that any given ,operation may simultaneously participate in multiple classes of conflicts. As described above, the move operation, for example, participates in both temporal and spatial conflicts.</p><p>The next section describes the setting in which applicationdefined conflictsmay occur. This setting provides a basis for describing the divergent state of artifacts that are the focus of a collaboration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ASSUMPTIONS</head><p>This work assumes that, for any application, there exists a set of atomic operations that affect the artifacts exposed by the application; these operations are called actions. Further, these actions are the only way to change the state of the artifact in a way that is significant to other users of the artifact. For example, in a shared drawing tool, the artifact is the drawing itself. The atomic operations on this drawing may include drawing a new figure at specified coordinates, moving an existing figure, or cutting, copying, or pasting figures to and from the clipboard Other operations that do not globally change the state of the artifact-such as setting a zoom factor that only changes the local view-need not be represented inthis set of atomic operations.</p><p>At nmtime, actions are ordered into a directed acyclic graph called a history. Each edge represents an action performed by the user, and each node represents the state of the artifact after all upstream actions have been applied. The history represents the complete record of the artifact as it exists across time. For applications that enforce a strict global, . serial ordering, the history graph may be simply a straight line of actions. For applications that allow multiple users, perhaps at different sites, to see (or "receive") actions in arbitrary orders, the history graph will be more divergent.</p><p>This history graph is conceptually identical to graphs representing message broadcasts among a set of machines, or graphs representing multiple versions of an artifact. The same issues of divergence, conflict, and merging arise in any of these cases, and this model for conflict management is applicable to them as it is to Timewarp. Any path tbr~ugh the history is called a limeline and represents a particular ordering of actions-in essence, a</p><p>plausible alternate history of the artifact based on a serial ordering of actions.</p><p>For many applications, each user will have a "current node" that represents the 'location" of that user in the history. In most applications, the current node of a given user will be at a leaf node in the graph, representing the "cutting edge" of time: all upstieam actions will have been seen by that user, and no new, unprocessed actions will have been received. In some applications, however, users may have a current node in the interior of the history. Such applications may allow scanuing through alternate plausible timelines in the history.</p><p>A conjiict is defined simply as a special state that exists between any two actions that have been applied, perhaps tentatively, to the artifact. Thus, in our model, when a conflict occurs it is the operations in a timeline thsit are in cmflict, not states of the artifact. The model itself assigns no special meaning to the "state of being in conflict" Any semantics of the "conflict state," including how the state arises, is defined purely by the application. Thus there are no "intrinsic" contlicts in this model; al2 conflicts are defined as violations of some application-supplied semantics.</p><p>The model here is motivated by other work in the field, including Prosper0 [3], GINA [2], and WeMet [lo].</p><p>In the next section we address mechanisms for detecting cmflicts that occur in this setting of ordered, atomic operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DETECTION OF CONFLICTS r</head><p>As stated earlier, this work deals with types of conflicts that arise purely from application semantics. An important issue, then, is how we can build an infrastructure that can detect these conflicts, when only application code "tmderstands' that the conflicts exist? How can application semantics inform the infrastructure to detect types of conflicts such as those seen earlier (spatial, temporal, and so on)?</p><p>Just as the set of actions provided by an application define its semantics of behavior, these same actions also define the semantics of determimng when a conflict exists. Since the notion of whether a conflict exists arises solely tbrough the semantics of what particular actions do, the actions set the conflict &amp;t+ion semantics for the applications, since only they can "know" how their behavior can create the presence of conflicts. , * This section describes our detection model, based on using application-provided actions to define conflict relationships.</p><p>After the model is discussed in the abstract, we detail a particular implementation of it in the Timewarp toolkit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conflict Sets</head><p>The combination of some types of actions in the history graph may potentially cause conflicts to arise; other types of actions may be "immune" to conflicts-no matter how they are added, or in what order, they will never cause a conflict to arise. Types of actions that may potentially cause conflicts among other actions in a limited group are said to define a conflict set. A conflict set is simply a group of types or classes of actions that have the potential to generate conflicts with each other. The presence of an action class in a conflict set is statically-defined, in the sense that it will not change as long as application semantics do not change.</p><p>These sets correspond to the various types of conflicts that may exist in an application. For example, in a drawing application, a temporal conflict set may include Cut actions, as well as any actions that refer to or modify the state of objects in the drawing, including Move actions. These action classes are grouped together because the addition of any one can interact with other actions in the set to potentially cause a conflict to arise, based on the order of the actions. So for example, if a Cut action is placed in a timeline before some other action Moves the object which is cut, a temporal conflict will exist. Likewise, if a Move is added after a Cut is in place, a temporal conflict will exist.</p><p>A given action class may simultaneously exist in multiple, overlaIjping conflict sets. In a flowchart editor, a Move operation may also have the potential to violate structural consistency-perhaps by dislodging an object's connections to its neighbors. In this situation, the Move action would exist in both the temporal and the structural conflict sets.</p><p>In essence, a conflict set is simply a means of grouping together types of atomic operations that can cause conflicts with each other based on the semantics supplied by the application.,Action classes can exist in multiple conflict sets simultaneously.</p><p>Since, by definition, actions can only cause conflicts with other actions in their same sets, sets allow us to partition the space we must consider when searching for conflicts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conflict Roles</head><p>Within a conflict set the comprised action classes are grouped into conjkt roles, indicating the part the actions play in the set. So, for example, in the temporal conflict set in the drawing application, all actions that remove dmwn objects (such as Cut) might be grouped together in a role; similarly, all actions that modify existing objects (such as Move) might play a similar role in the set and would thus ,be groupedinto a single conflict role. Actions in the same role behave similarly with respect to the set they are in. Roles partition the. functions of actions within a set. For purposes of detection, we need only consider the roles an action plays in its sets, not the semantics of the action itself,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>An Example Conflict Hierarchy from a Layout Appllcatlon</head><p>Figure <ref type="figure">1</ref> shows the conflict sets and roles for the layout , application mentioned earlier. These are simply the conflict relationships for a particular applicationi other applications may have different types bf conflicts, and hence very different relationships expressed through their sets and roles.</p><p>Here, the sets and roles are presented as a hierarchy, although conceptually each could exist independently. (The description here matches the implementation used by Timewarp; see the Implementation section for more details), If ,an action is not a member of any of these sets then it is "immune" from causing any conflicts, no matter how or in what order it is inserted into the history graph.</p><p>There are two first-level sets: Temporal and Momentary.</p><p>The Temporai set represents all types of conflicts that cause inconsistencies across a timeline; Momentary conflicts, which include both Spatial and Structural conflicts, are only based on the instantaneous state of the artifact and do not affect all of a timeline (this distinction, and the implications of it, will be explained more thoroughly in the next section).</p><p>Within the Temporal Set there are three roles that aCtiOnS may play. The dependson role indicates that the action depends on some other action being earlier in the timeline.</p><p>The dependable role indicates that the action may be used as a target of a dependson relation. The SeversDependsOn role indicates that the action may break, or sever, any downstream dependson references to an upstream dependable action.</p><p>Within the Spatial subset of Momentary, the existsht role indicates that the action it is associated with produces or modifies some figure in the drawing so that it "exists at" a certain spatial location. The seversExistsAt role indicates that the action associated with it removes an object created by another action. Table <ref type="table" target="#tab_1">1</ref> shows the actions that constitute the layout application. Note that most actions participate in several different conflict sets. The CreateObject action participates in both the Temporal and Spatial sets. It is dependable because it creates an object that may later be referred to by another action; it also existsAt since it produces a figure in the layout which has a physical position and size. The MoveObject action dependson a previous object that it will move. It undoes that object's old position</p><formula xml:id="formula_0">(via SeversExistsAt)</formula><p>and relocates it (via existsat). CutObject both dependson the existence of an upstream object that it will cut, and, via SeversDependsOn, indicates that any downstream objects that depends on the deleted object are now in conflict with this CutObj ect operation.</p><p>When an application writer creates a new application, he or she defines the set of actions that represent the allowable operations in the application. At the same time, the application writer defines the conflict relationships between these applications by designing a group of conflict sets and assigning the actions into it. These relationships are used by  the detection machinery to identify conflicts automatically when they occur.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Gathering Conflict Candidates</head><p>At an abstract level, the detection process uses a source action and compares it repeatedly against other target actions to see if they are in conflict. The first phase of the detection process is to gather all of the potential conflict candidates.</p><p>These are the other actions in the history graph that can, in any way, factor into the decision of whether conflicts exist. For a given action, its candidates are the other actions from some sub-region of the history graph that are members of the same sets as itself. The particular sub-region that is considered depends on the sets in which the source action is a member. Consider, for example, temporal conflicts. When a new Cut operation is inserted into the history graph at a given point, the conflict detection machinery must consider all paths that pass through the new action, looking for violated downstream dependencies, to determine if a conflict exists. This is because temporal conflicts, by their very nature, are inconsistencies affecting downstream actions.</p><p>See Figure <ref type="figure" target="#fig_2">2</ref> for an example of such a conflict. It is possible that the insertion of the action will cause a conflict in one path, but not another. For this reason, all actions in all timelines passing through the insertion point are considered candidates for temporal conflicts. Because such conflicts are situated in the timeline itself, they corrupt the entire timeline they exist in, from the point of the earliest conflicting action.</p><p>In the figure, the entire upper path from the point of insertion of the Cut operation is in an inconsistent state.</p><p>Spatial conflicts do not have this unbounded property, however. The determination of whether a spatial conflict exists depends only on the current state of the artifact, which may be represented as the sequence of actions leading up to the insertion point. Downstream actions do not play into the decision of whether a conflict exists. So for spatial conflicts, all actions up to the insertion point are considered to be candidates for conflict.  Since .temporal and spatial conflicts involve different sets of actions, we must use different, gathering strategies for each (and potentially different strategies for all the types of conflicts in an application). Since an action may be a member of multiple conflict sets, gathering is performed separately for each set and candidates are then passed to the identification phase of detection..'</p><formula xml:id="formula_1">Identification.</formula><p>After the set of conflict candidates has been gathered, actual identification ofconflicts is performed. The identification process for a given set is only 'handed" the gathered candidates for that set, even if the action in question is a member of multiple sets. Identification of conflicts is separated by set to make the task of identification of conflicts for a particular set independent of all other sets.</p><p>The process of identification simply iterates through the gathered candidates. For each candidate, a set-specific predicate function is evaluated to determine if a conflict exists between the source and candidate. If a conflict does exist, implementations may cache the pair of conflicting actions, along with information about the conflict set.</p><p>This phase only accumulates actual conflicts from the set of potential conflicts gathered earlier. No action is taken to resolve or disallow any conflicting actions at this point.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Requirements for the Application Writer</head><p>Despite the complexity of the detection process, adapting an application to work in this model requires fairly little effort. At a minimum, the application writer must define the types of conflicts that can exist in the application, and assign the various operations supported by the application to conflict sets and roles. The infrastructure needs to be able to query actions for a list of the sets they are members of, and their roles in those sets. The particulars of how set and role information is associated with actions can vary from implementation to implementation. Timewarp implements the model by requiring actions to implement Java interfaces that represent their conflict roles (see the section on Implementation). Other implementations may use multiple inheritance, or simply a set of type flags. This definition phase is a static (compile-time) process that will not change as long as the semantics of the application do not change.</p><p>Next, the application writer must define per-set gathering and identification functions for each conflict set in the application. In most cases, one of the two types of gathering described earlier-whole-path gathering or current-state gathering-will be applicable, and thus gathering functions can be reused. The identification function is simply a predicate that is passed two actions in the same set and returns either true or false indicating whether they are in conflict. Typically these functions are on the order of a few dozen lines of code total.</p><p>The model partitions the detection process both procedurally-into gathering and identification phases-and structurally-by grouping actions into sets and roles. This partitioning greatly reduces the "cross-talk" among types of conflicts, and minimizes and simplifies the amount of application code required. Once this process of defining the conflict relationships in an application has been completed, an infrastructure using this model can automatically detect conflicts that arise among the actions in an ,application. Further, as we shall see, our infrastructure will also be able to automatically manage any conflicts that are detected</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MANAGEMENT OF CONFLICTS</head><p>Handling conflicts in an application has two aspects. First, the description of what constitutes a conflict is staticallydefined and rooted in the semantics of a particular application. These semantics are made manifest as actions, and hence actions are statically grouped into conflict sets and roles to denote their relationships to one another. The previous section on detection of conflicts covered this process.</p><p>The second aspect of conflict handling, however, is independent of the particular semantics of the set of actions used by a given application. Unlike detection, this aspect is dynamic-it indicates what to do with conflicts once they have been detected This process is run-time behaviorunlike the compiletime definition of conflict relations-d can be made largely independent of the semantics-based detection mechanisms.</p><p>Our model codifies this distinction by separating conflict detection from the behavioral aspects of dealing with a set of detected conflicts. The behavioral aspects are dictated by a confIict policy that embodies the semantics of conflict management at run-time, separate from detection.</p><p>One benefit of making the distinction between action-based detection and policy-based management is that the conflict policies can be made independent of the semantics of the conflicts they are asked to manage. So, for example, an application may come with a set of "pluggable" conflict policies that can be swapped in and out. Any of these policies would be capable of managing any set of conflicts detected as described above. If they so desire, however, application writers can create policies that have intimate knowledge of the semantics of particular classes of conflicts.</p><p>Conflict management is performed in response to detected conflicts. When a new action is created but before it is installed in the history, detection is done to determine whether the tentatively installed action would cause any conflicts to arise. If conflicts would be caused by this new action, then the conflict management system is invoked to deal with the detected conflicts.</p><p>Conflict policies are associated with particular conflict sets.</p><p>Typically an application will associate a policy with each conflict set defined by the application.</p><p>In our model there are several different aspects of conflict management that policies provide:</p><p>Resolution. If a tentative action causes an inconsistency, the infrastructure can provide support for either automatic or manual resolution of the inconsistency.</p><p>Tolerance. After any optional resolution is performed, the policy can decide whether the tentative action should indeed be inserted into the graph. This model allows conflicts that have not been resolved to still be tolerated in the graph, at the discretion of the application.</p><p>Interface. Once inserted into the graph, actions that cause unresolved-but-tolerated conflicts may influence the user interface of the application. The infrastructure provides "hooks" for allowing applications to trigger user interface changes when conflicting data is presented.</p><p>The conflict management policies can manage any detected conflict, regardless of the conflict set it originated from.</p><p>Policies define how-and whether-resolution will be performed, whether standing conflicts will be tolerated, and interface changes that will be associated with conflicting onscreen objects. Conflict policies have complete access to the history graph and can make arbitrary changes to it (Perhaps recursively causing new conflicts). We will now examine these aspects of conflict management in detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conflict Resolution</head><p>When an action is tentatively installed and conflicts are detected the system may attempt to resolve them, thereby removing any inconsistencies that would be caused.</p><p>Resolution is accomplished by handing the identified conflicts to the policies associated with any sets that identified conflicts. Of course, since actions may be in multiple sets, if these sets are mapped to different policies each policy may participate in the resolution process.</p><p>There are a number of common resolution strategies that can be implemented by conflict policies. The simplest strategy is to simply provide the user with the option of not performing the new, conflicting operation. If the operation is undone before being actually inserted into the history, no conflicts will be caused.</p><p>Policies may, however, implement other, more complex strategies for resolving conflicts. Some policies may implement these strategies as automatic resolution procedures,. which run without user intervention. Others may interact with the user to "tune" the resolution process.</p><p>7%e Explosion Strategy. This strategy lets computation proceed at the cost of history complexity. At any point where a conflicting action exists in the history, the history is forked into multiple downstream paths. Each of these paths represents an alternate in which conflicts are avoided by selectively removing actions involved in a conflict. The Promotion Strategy. This strategy "promotes" actions that depend on upstream results into actions that can exist without reference to any upstream information.</p><p>Figure <ref type="figure">5</ref> shows an example of promotion. Here, a figure has been copied to the clipboard, and then pasted. If the figure is removed before being copied, an inconsistency exists because there is no object to copy to the clipboard, and hence the paste operation cannot proceed. /'</p><p>In the figure, promotion is used to replace 'the Paste operation, which depends on the existence of upstream actions, into a "stand-alone" &amp;aw operation that has no such dependencies. In effect, the dependency is severed and the conflict is undone.</p><p>Such a strategy may not be effective for all situations. But in cases where the Paste was performed by the user essentially as a "short-cut" for a Draw, promoting conflicting Paste operations 'to Draw operations preserves the intended meaning of the user. ----)1--+2--)3--)4-</p><formula xml:id="formula_2">Draw A Delete A Copy A Draw A'</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FIGURE 5: The Promotion Strategy</head><p>The Recursive Accepfance Strategy One obvious option for resolving conflicts is, rather than disallowing the insertion of the new action, remove any downstream actions that conflict with it. Of course, the removal of these actions may itself cause new conflicts to be created, which may be resolved.</p><p>The recursive acceptance strategy uses this approach. When a conflict is detected, the user has the option of removing either the source action, or any conflicting targets. When a target is "remove4" the system actually creates a new tentative timeline and recursively executes the. conflict detection code to determine what new conflict may have been created. At this point, the resolution policies for these new conflicts is executed. The process continues until the user has either reconciled the timeline or allowed the conflicts to stand. At any point the user can "back out" to undo an earlier conflict decision.</p><p>The Quantum Uncerfainfy Sfrafegy Quantum uncertainty is. not so much a pure resolution strategy as a combination of tolerance and user interface ideas. In quanm uncertainty, inconsistent operations are allowed to exist. All such operations are said to be in an "uncertain" state, and have a numeric "uncertainty" value associated with them. This value is recalculated whenever a change is made to the history graph, and represents an index of the validity that the action seems to have, based on the other actions around it.</p><p>In quantum uncertainty, the accretion of actions in a history is used to posit a likely interpretation of inconsistent data, Thus, a set of actions that reinforce one interpretation of a conflict lessens the uncertainty of one of the actions participating in the conflict, while increasing the uncertainty of the other. Conflict Tolerance</p><p>An important trait of the Timewarp conflict model is that it allows applications to manage tolerated conflicts. That is, some applications may decide that certain types of conflicts need not be resolved, but can be allowed to exist in a timeline. A common reason for tolerating conflicts is to ease users' burden-if the users of a tool understand the intended state of the shared artifact and are satisfied with it, there may be no reason to force them to go through a series of steps to manually resolve any existing inconsistencies. Work can proceed at its own pace, and users can elect to resolve conflicts later, if at all.</p><p>For example, in the layout application, conflicts often arise because two users working independently merge disparate action paths into one shared state. The merge may cause certain objects to overlap, violating spatial constraints in the application. Rather than forcing the users to readjust the entire layout to do away with the inconsistencies, the system allows the inconsistencies to remain, but flags them in the interface (more on this later).</p><p>Whether or not a class of conflicts will be tolerated depends solely on the conflict policy in effect for that class of conflicts. In the Timewarp implementation, determination of tolerance occurs after the optional resolution step; the policy returns a boolean value indicating whether the tentatively inserted action should be installed in the history graph, or should be discarded. Tolerated conflicts are cached so that they can be used to effect interface changes if desired.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conflict Interfaces</head><p>Allowing standing conflicts to exist in an application raises questions about how they should be presented to users. Our infrastructure must be able to allow application codeespecially the application's user interface code-to collude with the conflict management system to systematically modify the application interface to reflect conflicts.</p><p>interface Examples. One of the goals of this work is to explore rich interfaces for presenting conflicts. Several interfaces for interacting with standing conflicts have been developed. In the layout application, spatial conflicts are handled by a policy that allows the conflicting, overlapping objects to co-exist, but renders them transparently and slightly blurred via a Gaussian blur <ref type="bibr">([5]</ref> contains an image of this effect). This technique provides an immediately obvious cue that the state of these objects is somehow "different" than their neighbors. The fact that the objects are physically on top of one another and yet can both be seen strengthens the perception of the cue as indicative of spatial conflict.</p><p>In the drawing application, temporal conflicts are handled by quantum uncertainty. Drawing of conflicting objects is modified so that the transparency of au object represents its degree of uncertainty. Fully certain, unambiguous objects are rendered fully opaque. Other objects, as their uncertainty increases, gradually fade out over time.</p><p>Other policies may annotate drawn objects that are involved in conflicts with controls that allow the user to pop up a panel of information about the conflicts they are involved in.</p><p>Interface Implementation. The interface of any application is, by necessity, dictated by the user interface toolkit being used as well as the semantics of the particular application. This requires that particular implementations of our conflict model know about and support a particular UI toolkit. Still, the conflict management infrastructure can provide generic mechanisms for supporting a range of application needs given a particular UI toolkit.</p><p>Our model distinguishes between basic conflict policies and drawable conj%ct policies. Drawable conflict policies are policies that know how to interact with the rendering system of a particular UI toolkit. Drawable conflict policies add a number of new behaviors over simple conflict policies; these behaviors are used by application code to allow some of the application's drawing behavior to be delegated to the policy.</p><p>Whenever conflicts are detected along a given path, they are stored and indexed by the particular sets they represent.</p><p>147</p><p>When application user interface code is about to draw an onscreen object that is a part of the shared artifact-and, hence, may potentially be the product of actions that are involved in standing conflicts-the application may delegate drawing to the drawable conflict policies that affect the object.</p><p>Again, the particulars of how this delegation is done depends on the particular toolkit in use. The current implementation ' of Timewarp provides a drawable conflict policy infrastructure for interacting with the SubArctic GUI toolkit [S], but the general concepts are portable to other UI toolkits, albeit perhaps with more work for implementors.</p><p>The infrastructure provides a mapping from on-screen objects to the actions which have affected them. Once this mapping has been created, applications can inquire to the conflict management system about whether a particular onscreen object should have its drawing delegated to one or more drawable conflict policies. If the conflict management system indicates that drawing should be delegated, the application passes the on-screen object into the conflict management system for drawing. The conflict management system then identifies all of the drawable conflict policies that are involved in conflicts for the object. These policies are applied-pipeline fashion-to the drawing process for the object. The final result is that each policy has a chance to impose its own policy-specific drawing modifications to objects involved in conflicts.</p><p>This mechanism addresses the integration of conflict management with a LJI toolkit, and is extensible to new policies, new applications, and new UI toolkits-it requires only the cooperation of the set of actions used in the application, and the particular conflict policy used to manage the interfaces of conflicts among these actions. No changes are required to the basic conflict management system, and the conflict management code does not have to understand the particulars of a given UI toolkit only the particular drawable conflict policies in use are required to be able to "speak" to a particular UI toolkit.</p><p>The next section discusses 'the particulars of the conflict interface implementation provided by Timewarp, along with other implementation details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CONFLICT IMPLEMENTATION IN TIMEWARP</head><p>In Timewarp, the ordered atomic operations model is realized as a set of concrete classes, in the object-oriented sense. Actions are classes that represent the atoms of behavior in a given application; particular action classes are provided by application .svriters when they build their applications. When a new operation is performed, a new action instance is created to represent it, and is installed in a history graph that provides an explicit representation of the parallel timelines of the shared artifact..</p><p>Timewarp uses an open implementation [9] approach: the infrastructure "speaks" in terms of actions, generically. Applicati9ns are built by extending these actions through subclassing, and then "pushing" them back into the infrastructure, thereby inserting their own semantics into the toolkit framework.</p><p>Conflict sets and roles are represented as a hierarchy-of interfaces that.can be multiply inherited by the actions. So application writers, when creating the actions that constitute their application, declaratively assign these actions to a number of interfaces representing the roles of a particular set. The use of interfaces here provides a declarative notational convenience and strong compiletime type safety.</p><p>All of the inli-astructure (non-application) code for detecting and rnumging conflicts is localized in the ConflictManager class.' This class 'uses information provided in the types of the actions' defined by the application,, writer (accessed via reflection),. as well as explicitly-provided application code such as ,.detection predicates, to implement the conflict model described here.</p><p>b. The current implementation provides a number' of drawable conflict policies that interact with the SubArctic GUI toolkit. These policies leverage the "drawing isolation" features of that toolkit <ref type="bibr">[4]</ref> to provide convenient pipelines of drawing operations that represent the effects .of multiple drawable conflict policies. UI-specific code -is not present in the infrastructure, with the exception of the particular drawable conflict policies where it is isolated _</p><p>The Timewarp system is implemented entirely-in the Java programming language 111. ,Currently, the framework itself is approximately 15,800 lines of code: The entire conflict subsystem, along with the set of "pluggable" policies described above, represents 2,000 lines of the total. A number of applications have been'created using this system.</p><p>.The total number of lines devoted to conflict management in each of these applications averages only 60 lines of code, almost exclusively in the detection protocols. . . _. /_,, ii-*:-__.,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SUMMARY AND FUTURE DIRECTIONi</head><p>' _.</p><p>This paper has described a comprehensive model for thinking about the detection and management of semantic conflicts in applications. These conflicts can arise in any number of application genres, from' distributed systems to version control to collaboration. The model here supports rich definition of conflicts, including the ability to define multiple simultaneous conflict categories. Further, the model provides a framework for the resolution and tolerance of detected conflicts, and can interact with application code to produce novel interface effects based on standing conflicts.</p><p>This model has been implemented as a part of the Timewarp collaborative' infrastructure. While this toolkit provides significant capabilities to application writers for defining and managing conflicts, the amount of work required by application writers to participate in conflict management is minimal. Typically only a small amount of code must be written to interact with the conflict subsystem.</p><p>There are a number of future directions for this work. An obvious area is the investigation of more forms of conflict resolution. The forms described here, while novel, do not capture the entire space of conflict,resolution. A second area of focus is on conflict interfaces. Chu current model only supports output changes in response to standing conflicts. We would like to also be able to modify the input to onscreen objects based on the conflict policies in effect. A final area for future work is on declarative specification of detection protocols. In the current system, detection is implemented procedurally by the application writer in the form of. a detection predicate. We are investigating a declarative implementation based on constraints, which may provide a more natural way to define conflict relationships. .</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>FIGURE 1: Hierarchy of Conflicts for a Layout Application</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure3</head><label></label><figDesc>Figure3 shows an example of such a conflict. Action 1 causes a figure to be drawn at coordinates X,Y. Action 2 moves a different figure to the same coordinates. This action</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>FIGURE 2 :</head><label>2</label><figDesc>FIGURE 2: Temporal Cdnflicts Invalidate Some Downstream Timelines, But Not Others causes 'a conflict to occur, based only on the state of the artifact up to the point of the insertion--by examining only upstream actions, the system can determine that two objects are in the same position. Further, note that such momentary conflict exist only for a bounded span of a timeline. Action 3 moves the second figure to S; new, non-conflicting location. Thus, unlike temporal conflicts in which an entire timeline is corrupted, momentary conflicts are confined to a limited area of a timeline. Action 2 causes a momenfaryconfiict which only exists in the timeirne until Action 3 is evaluated. 0' l '1 b2 w 3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure4FIGURE 4 :</head><label>4</label><figDesc>Figure4 shows such an example, where an inserted Cut operation would conflict with a downstream Move. The history is forked into two branches. The first branch "favors" the Cut by letting it stand and removing its conflicting partner, the Move. The second branch does the opposite: the Move is favored and the Cut is deleted.The explosion strategy resolves conflicts by providing both (or multiple) valid interpretations of the state of the artifact when an inconsistency is encountered.Before: A Cut is inserted between a Draw and a Move</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>The Paste is "promoted" into a Draw of A', a new object derived from A.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6</head><label>6</label><figDesc>Figure 6 shows an example of quantum uncertainty. Here, we see our by-now classic Draw-Cut-Move inconsistency, After the insertion of the Cut, both the Cut and Move operations have uncertainty values of 0.5 indicating that they are equally uncertain. In the second graph shown, a sequence of Moves and Copies of the supposedly-cut object are appended to the timeline. These actions all "ignore" the interpretation of the conflict that favors the Cut operation, so they lessen the uncertainty of the Move, and all other actions that conflict with the Cut, at the expense of the Cut. In effect, these later operations reinforce the interpretation that the Cut should be ignored. Other divergent paths may favor the Cut, in which case the situation would be reversed in those paths. _ -WI ',:2-b 3 II-Draw A %!iA MY-A t .1-+2--)3+4+5-Draw A Cut A</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE 1 : Conflict Roles of Actions in the Layout Application</head><label>1</label><figDesc></figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>Thanks to Paul Dourish, Beth Mynatt, and Ian Smith for their contributions in reviewing and editing this paper,</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Cl1 PI [31. I .[41 &apos;_ ^</title>
		<idno>El [71 P-31 t- PI WA c</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">The Java Programming LhnguagL</title>
		<author>
			<persName><forename type="first">K</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gosling</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Addison-Wesley Co</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A Framework for Shared Applications with a Replicated Architecture</title>
		<author>
			<persName><forename type="first">T</forename><surname>Berlage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Genau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">@wish, P. Open Implementation and Flexibility in Collaboration Toolkits</title>
		<meeting><address><addrLine>Atlanta, GA; London</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-11">November, 1993. June, 1996</date>
		</imprint>
		<respStmt>
			<orgName>Computer Science Department, University College</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. dissertation</note>
	<note>Proc. ACM Symposium on User Intetiace Sofnvare and Technology (UIST)</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Systematic Output Modification in a 2D User Interface Toolkit</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">K</forename><surname>Edwards</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">E</forename><surname>Hudson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Marianucci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rodenstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rodriguez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">K</forename><surname>Edwards</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">D</forename><surname>My&amp;</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Conference on Computer-Human Interaction (CHZ)</title>
		<meeting>the ACM Conference on Computer-Human Interaction (CHZ)<address><addrLine>Banff, Alberta; Atlanta, GA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-03">Oct. 1997. March. 1997</date>
		</imprint>
	</monogr>
	<note>Proc. ACM Symposium on User Interface Sofnvare and Technology (UZST)</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Concurrency Control in Groupware Systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ellis ; Gibbs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD Conference on Management of Data</title>
		<meeting>ACM SIGMOD Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="1989-06">June 1989</date>
		</imprint>
	</monogr>
	<note>CA.:&apos; ar$</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Real Time Group ware as a Distributed System: Concurrency Control and its Effect on the Interface</title>
		<author>
			<persName><forename type="first">S</forename><surname>Greenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Marwood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Confeence on Computer-Supported : Cooperative Work (CSCW). Chapel Hill?</title>
		<meeting>ACM Confeence on Computer-Supported : Cooperative Work (CSCW). Chapel Hill?</meeting>
		<imprint>
			<date type="published" when="1994-10">October. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Ultra-Lightweight Constraints</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hudson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Symposium on User Interjade SofMare and Technology</title>
		<meeting>ACM Symposium on User Interjade SofMare and Technology<address><addrLine>UhS7&apos;)~ Seattle, WA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-11">November 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Beyond the&apos;Black Box: Open Implementation</title>
		<author>
			<persName><forename type="first">G</forename><surname>K&amp;ales</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<date type="published" when="1996-01">January, 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">T&amp;for Supporting the Collaborative F&apos;rocess</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Rhyne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">G</forename><surname>Wolf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Symposium on User Infer&amp;e Software and Technology (UIST)</title>
		<meeting>ACM Symposium on User Infer&amp;e Software and Technology (UIST)<address><addrLine>Atlanta, GA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992-11">November, 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Managing Update Conflicts in Bayou, a Weakly Connected Replicated Storage System</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Terry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Thehner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Petersen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Demers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Spreitzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hauser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Symposium on Operating Systems Principles (SOSP)</title>
		<meeting>ACM Symposium on Operating Systems Principles (SOSP)</meeting>
		<imprint>
			<date type="published" when="1995-12">Dec. 1995. 1</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
