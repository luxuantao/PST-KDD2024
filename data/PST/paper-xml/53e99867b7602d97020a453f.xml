<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">CWC: A high-performance conventional authenticated encryption mode</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2004-01-15">January 15, 2004</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Tadayoshi</forename><surname>Kohno</surname></persName>
							<email>tkohno@cs.ucsd.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Science and Engineering</orgName>
								<orgName type="institution">University of California at San Diego</orgName>
								<address>
									<addrLine>9500 Gilman Drive, La Jolla</addrLine>
									<postCode>92093</postCode>
									<region>California</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">John</forename><surname>Viega</surname></persName>
							<email>viega@securesoftware.com</email>
							<affiliation key="aff1">
								<orgName type="department">Falls Church</orgName>
								<orgName type="institution">Virginia Tech</orgName>
								<address>
									<addrLine>Suite 500</addrLine>
									<postCode>6066, 22041</postCode>
									<settlement>Leesburg Pike</settlement>
									<region>VA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Doug</forename><surname>Whiting</surname></persName>
							<email>dwhiting@hifn.com</email>
							<affiliation key="aff2">
								<orgName type="institution">Hifn, Inc</orgName>
								<address>
									<addrLine>5973 Avenida Encinas, Suite 110</addrLine>
									<postCode>92009</postCode>
									<settlement>Carlsbad</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">CWC: A high-performance conventional authenticated encryption mode</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2004-01-15">January 15, 2004</date>
						</imprint>
					</monogr>
					<idno type="MD5">C711A09F4A01D6A705CEA73FAFE38E07</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Authenticated encryption</term>
					<term>modes of operation</term>
					<term>parallelism</term>
					<term>performance</term>
					<term>security proofs</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We introduce CWC, a new block cipher mode of operation for protecting both the privacy and the authenticity of encapsulated data. CWC is currently the only such mode having all five of the following properties: provable security, parallelizability, high performance in hardware, high performance in software, and no intellectual property concerns. We believe that having all five of these properties makes CWC a powerful tool for use in many performance-critical cryptographic applications. CWC is also the only appropriate solution for some applications; e.g., standardization bodies like the IETF and NIST prefer patent-free modes, and CWC is the only such mode capable of processing data at 10Gbps in hardware, which will be important for future IPsec (and other) network devices. As part of our design, we also introduce a new parallelizable universal hash function optimized for performance in both hardware and software.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>An authenticated encryption associated data (AEAD) scheme is a symmetric encryption scheme designed to protect both the privacy and the authenticity of encapsulated data. There has recently been a strong push toward producing block cipher-based AEAD schemes <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b4">5]</ref>. Despite this push, among the previous works there does not exist any AEAD scheme simultaneously having all of the following properties: provable security, parallelizability, high performance in hardware, high performance in software, and free from intellectual property concerns. Even though not all applications will require all five of the these properties, almost all applications will require at least one of the them, and may very likely have to be able to interoperate with an application requiring a different property. We thus view finding an appropriate scheme having all five of these properties as a very important research goal.</p><p>Finding an appropriate balance between all five of the aforementioned properties is, however, not easy because the most natural approaches to addressing some of the properties are actually disadvantageous with respect to other properties. We believe we have overcome these challenges and, in doing so, introduce a new mode of operation called CWC, or Carter-Wegman Counter mode.</p><p>Motivating example. One of the primary motivations for such a block cipher-based AEAD scheme is IPsec. From a pragmatic perspective, we note that many vendors and standardization bodies prefer patent-free modes over patented modes (the elegant OCB mode was apparently rejected from the IEEE 802.11 working group because of patent concerns). And, from a hardware performance perspective, we note that because none of the existing patent-free AEAD schemes are parallelizable, it to impossible to make existing patent-free AEAD schemes run faster than about 2Gbps using conventional ASIC technology and a single processing unit. Nevertheless, future network devices will be expected to run at 10Gbps. CWC addresses these issues, being both patent-free and capable of processing data at 10Gbps using conventional ASIC technology.</p><p>The CWC solution. Our new mode of operation, called CWC, has all five of the properties mentioned above. It is provably secure. Moreover, our provable security-based analyses helped guide our research and helped us reject other schemes with similar performance properties but with slightly worse provable security bounds. CWC is also parallelizable, which means that we can make CWC-AES run at 10Gbps using conventional ASIC technology. CWC is also fast in software. Our current implementation of CWC-AES runs at about the same speed as the other patent-free modes on 32-bit architectures (Table <ref type="table">1</ref>), and we anticipate significant performance gains on 32-bit CPUs when using more sophisticated implementation techniques (Section 6), and we also see significantly better performance on 64-bit architectures. Of course, we do remark that the patented modes like OCB are capable of running even faster in software, which would make them very attractive were they not also encumbered in intellectual property issues.</p><p>Like the other two unpatented block cipher-based AEAD modes, CCM <ref type="bibr" target="#b28">[29]</ref> and EAX <ref type="bibr" target="#b4">[5]</ref>, CWC avoids patents by using two inter-related but mostly independent modules: one module to "encrypt" the data and one module to "authenticate" the data. Adopting the terminology used in <ref type="bibr" target="#b4">[5]</ref>, it is because of the two-module structure that we call CWC a "conventional" block cipher-based AEAD scheme. Although CWC uses two modules, it can be implemented efficiently in a single pass. By using the conventional approach, CCM, EAX, and CWC are very much like composition-based AEAD scheme <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b14">15]</ref>, or AEAD schemes composed from existing encryption schemes and MACs. Unlike composition-based AEAD schemes, however, by designing CWC directly from a block cipher, we eliminate redundant steps and fine-tune CWC for efficiency, again keeping in mind both our hardware and software goals. For example, we use only one block cipher key, which saves expensive memory access in hardware.</p><p>The encryption core of CWC is essentially counter (CTR) mode encryption, which is well-known  <ref type="table">1</ref>: Software performance (in clocks per byte) for the three patent-free block cipher-based AEAD modes on a Pentium III. All implementations were in C and written by Brian Gladman <ref type="bibr" target="#b8">[9]</ref> and use 128-bit AES keys. Values are averaged over 50 000 samples. We do not include software performance for the patented modes, like OCB, in this table; the performance for these modes in software will be approximately twice as fast as the shown measurements. Please see the text for additional information and discussion.</p><p>to be efficient and parallelizable. Finding an appropriate algorithm for the authentication core of CWC proved to be more of a challenge. For authentication, we decided to base our design on the Carter-Wegman <ref type="bibr" target="#b27">[28]</ref> universal hash function approach for message authentication. Part of the difficulty in the design came down to choosing the right type of universal hash function, with the right parameters. Since polynomial evaluation can be parallelized (if the polynomial is in x, one can split it into i polynomials in x i ), we chose to use a universal hash function consisting of evaluating a polynomial modulo the prime 2 127 -1. We note the our hash function is similar to Bernstein's hash127 <ref type="bibr" target="#b5">[6]</ref> except that Bernstein's hash function was optimized for software performance at the expense of hardware performance. To address this issue, we use larger coefficients than Bernstein uses. We believe our hardware-and software-optimized universal hash function to be of independent interest.</p><p>Notation. As part of our research, we first created a general approach for combining CTR mode encryption with a universal hash function in order to provide authenticated encryption. We shall refer to this general approach as CWC (note no change in font), and shall use CWC-BC to refer to a CWC instantiation with a 128-bit block cipher BC as the underlying block cipher and with the universal hash function described briefly above. We shall use CWC as shorthand for CWC-BC and use CWC-AES to mean CWC-BC with AES <ref type="bibr" target="#b7">[8]</ref> as the underlying block cipher. Other instantiations of the general CWC approach are possible, e.g., for legacy 64-bit block ciphers. Since we are primarily targeting new applications, and since a mode using a 128-bit block cipher will never be asked to interoperate with a mode using a 64-bit block cipher, we focus this paper only on our 128-bit CWC instantiation.</p><p>When we say that an AEAD scheme's encryption algorithm takes a pair (A, M ) as input and produces a ciphertext as output, we mean that the AEAD scheme is designed to protect the privacy of M and the authenticity of both A and M . This will be made more formal in the body.</p><p>Performance. Let (A, M ) be some input to the CWC encryption algorithm. The CWC encryption algorithm derives a universal hash subkey from the block cipher key. Assuming that the universal hash subkey is maintained across invocations, encrypting (A, M ) takes |M |/128 + 2 block cipher invocations. The polynomial used in CWC's universal hashing step will have degree d = |A|/96 + |M |/96 . There are several ways to evaluate this polynomial (details in Section 6). As noted above, we could evaluate it in parallel. Serially, assuming no precomputation, we could evaluate this polynomial using d 127x127-bit multiplies. As another example, assuming n precomputed powers of the hash subkey, which are cheap to maintain in software for reasonable n, we could evaluate the polynomial using d -m 96x127-bit multiplies and m 127x127-bit multiplies, where m = (d + 1)/n -1.</p><p>In hardware using conventional ASIC technology at 0.13 micron, it takes approximately 300 Kgates to reach 10 Gbps throughput for CWC-AES. This is around twice as much as OCB, but avoids IP negotiation overhead and royalty payments to three parties. Table <ref type="table">1</ref> relates the software performance, on a Pentium III, of CWC-AES to the two other patent-free AEAD modes CCM and EAX; the patented modes such as OCB are not included in this table, but are about twice as fast as the times given for the patent-free modes. The implementations used to compute Table <ref type="table">1</ref> were written in C by Brian Gladman <ref type="bibr" target="#b8">[9]</ref> and all use 128-bit AES keys; the current CWC-AES implementation does not use the above-mentioned precomputation approach for evaluating the polynomial. Table <ref type="table">1</ref> shows that the current implementations of the three modes have comparable performance in software, the relative "best" depending on the OS/compiler and the length of the message. Using the above-mentioned precomputation approach and switching to assembly, we anticipate reducing the cost of CWC's universal hashing step to around 8 cpb, thereby significantly improving the performance of CWC-AES in software compared to CCM-AES and EAX-AES (since the authentication portions of CCM-AES and EAX-AES are limited by the speed of AES but the authentication portion of CWC-AES is limited by the speed of the universal hash function). For comparison, Bernstein's related hash127, which also evaluates a polynomial modulo 2 127 -1 but whose specific structure makes it less attractive in hardware, runs around 4 cpb on a Pentium III when written in assembly and using the precomputation approach. On 64-bit G5s, our initial implementation of the hash function runs at around 6 cpb, thus showing that CWC-AES is very attractive on 64-bit architectures (when running the G5 in 32-bit mode, our implementation runs at around 15 cpb).</p><p>We do not claim that CWC-AES will be particularly efficient on low-end CPUs such as 8-bit smartcards. However, our goal was not to develop an AEAD scheme for such low-end processors.</p><p>The patent issue. The patent issue is a very peculiar one. While it may initially sound odd to let patents influence research, we note that it is also not uncommon, especially in other sciences. Indeed, we view this line of research as discovering the most appropriate solution given real-world constraints. And, just like performance constraints, intellectual property constraints are very real.</p><p>Background and related work. The notion of an authenticated encryption (AE) scheme was formalized by Katz and Yung <ref type="bibr" target="#b12">[13]</ref> and by Bellare and Namprempre <ref type="bibr" target="#b3">[4]</ref> and the notion of an authenticated encryption with associated data (AEAD) scheme was formalized by Rogaway <ref type="bibr" target="#b22">[23]</ref>. Bellare and Namprempre <ref type="bibr" target="#b3">[4]</ref> and <ref type="bibr">Krawczyk [15]</ref> explored ways to combine standard encryption schemes with MACs to achieve authenticated encryption. A number of dedicated AE and AEAD schemes also exist, including RPC <ref type="bibr" target="#b12">[13]</ref>, XECB <ref type="bibr" target="#b9">[10]</ref>, IAPM <ref type="bibr" target="#b11">[12]</ref>, OCB <ref type="bibr" target="#b23">[24]</ref>, CCM <ref type="bibr" target="#b28">[29]</ref>, and EAX <ref type="bibr" target="#b4">[5]</ref>. CWC is similar to the combination of McGrew's UST <ref type="bibr" target="#b19">[20]</ref> and TMMH <ref type="bibr" target="#b18">[19]</ref>, where one of the main advantages of CWC over UST+TMMH is CWC's small key size, which, as the author of UST and TMMH noted, can be a bottleneck for UST+TMMH in hardware at high speeds. The integrity portion of CWC builds on top of the Carter-Wegman universal hashing approach to message authentication <ref type="bibr" target="#b27">[28]</ref>. The specific hash function CWC uses is similar to Bernstein's hash127 <ref type="bibr" target="#b5">[6]</ref>, but is better suited for hardware. Shoup <ref type="bibr" target="#b25">[26]</ref> and Nevelsteen and Preneel <ref type="bibr" target="#b20">[21]</ref> also worked on software optimizations for universal hash functions. Rogaway and Wagner released a critique of CCM <ref type="bibr" target="#b24">[25]</ref>. For each issue raised in <ref type="bibr" target="#b24">[25]</ref>, we find that we have addressed the issue (e.g., we designed CWC to be on-line) or we disagree with the issue (e.g., we feel that it is sufficient for new modes of operation to handle arbitrary octet-length, as opposed to arbitrary bit-length, messages; we stress, however, that, if desired, it is easy to modify CWC to handle arbitrary bit-length messages, see Section 5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>Notation. If x is a string then |x| denotes its length in bits. Let ε denote the empty string. If x and y are two equal-length strings, then x ⊕ y denotes the xor of x and y. If x and y are strings, then x y denotes their concatenation. If N is a non-negative integer and l is an integer such that 0 ≤ N &lt; 2 l , then tostr(N, l) denotes the encoding of N as an l-bit string in big-endian format. If x is a string, then toint(x) denotes the integer corresponding to string x in big-endian format (the most significant bit is not interpreted as a sign bit). For example, toint(10000010) = 2 7 + 2 = 130. If b is a bit and n a non-negative integer, then b n denote b concatenated with itself n times; e.g., 10 7 is the string 10000000. Let x ← y denote the assignment of y to x. If X is a set, let x $ ← X denote the process of uniformly selecting at random an element from X and assigning it to x. If f is a randomized algorithm, let x $ ← f (y) denote the process of running f with input y and a uniformly selected random tape. When we refer to the time of an algorithm or experiment, we include the size of the code (in some fixed encoding). There is also an implicit big-O surrounding all such time references.</p><p>Authenticated encryption schemes with associated data. We use Rogaway's notion of an authenticated encryption with associated data (AEAD) scheme or mode <ref type="bibr" target="#b22">[23]</ref>. An AEAD scheme SE = (K e , E, D) consists of three algorithms and is defined over some key space KeySp SE , some nonce space NonceSp SE = {0, 1} n , n a positive integer, some associated data (header) space AdSp SE ⊆ {0, 1} * , and some payload message space MsgSp SE ⊆ {0, 1} * . We require that membership in MsgSp SE and AdSp SE can be efficiently tested and that if M, M are two strings such that M ∈</p><formula xml:id="formula_0">MsgSp SE and |M | = |M |, then M ∈ MsgSp SE .</formula><p>The randomized key generation algorithm K e returns a key K ∈ KeySp SE ; we denote this process as K $ ← K e . The deterministic encryption algorithm E takes as input a key K ∈ KeySp SE , a nonce N ∈ NonceSp SE , a header (or associated data) A ∈ AdSp SE , and a payload message M ∈ MsgSp SE , and returns a ciphertext C ∈ {0, 1} * ; we denote this process as C ← E N,A K (M ) or C ← E K (N, A, M ). The deterministic decryption algorithm D takes as input a key K ∈ KeySp SE , a nonce N ∈ NonceSp SE , a header A ∈ AdSp SE , and a string C ∈ {0, 1} * and outputs a message M ∈ MsgSp SE or the special symbol INVALID on error; we denote this process as M ← D N,A K (C). We require that D  <ref type="figure">|</ref>). Under the correct usage of an AEAD scheme, after a random key is selected, the application should never invoke the encryption algorithm twice with the same nonce value until a new key is randomly selected. In order to ensure that a nonce does not repeat, implementations typically use nonces that contain counters. We use the notion of a nonce, rather than simply a counter, because the notion of a nonce is more general and allows the developer the freedom to structure the nonce as he or she desires.</p><formula xml:id="formula_1">N,A K (E N,A K (M )) = M for all K ∈ KeySp SE , N ∈ NonceSp SE , A ∈ AdSp SE ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Block ciphers. A block cipher</head><formula xml:id="formula_2">E : {0, 1} k × {0, 1} L → {0, 1} L is a function from k-bit keys and L-bit blocks to L-bit blocks. We use E K (•), K ∈ {0, 1} k , to denote the function E(K, •) and we use f $ ← E as short hand for K $ ← {0, 1} k ; f ← E K .</formula><p>Block ciphers are families of permutations; namely, for each key K ∈ {0, 1} k , E K is a permutation on {0, 1} L . We call k the key length of E and we call L the block length.</p><p>We adopt the notion of security for block ciphers introduced in <ref type="bibr" target="#b16">[17]</ref> and adopted for the concrete setting in <ref type="bibr" target="#b1">[2]</ref>. Let E : {0, 1} k × {0, 1} L → {0, 1} L be a block cipher and let Perm(L) denote the set of all permutations on {0, 1} L . Let A be an adversary with access to an oracle and that returns a bit. Then</p><formula xml:id="formula_3">Adv prp F (A) = Pr f $ ← E : A f (•) = 1 -Pr g $ ← Perm(L) : A g(•) = 1</formula><p>denotes the prp-advantage of A in distinguishing a random instance of E from a random permutation. Intuitively, we say that E is a secure prp, or a secure block cipher, if the prp-advantages of all adversaries using reasonable resources is small. Modern block ciphers, such as AES <ref type="bibr" target="#b7">[8]</ref>, are believed to be secure prps.</p><p>3 The CWC mode of operation</p><p>We now describe our new AEAD scheme. Let BC : {0, 1} kl × {0, 1} 128 → {0, 1} 128 be a 128-bit block cipher. Let tl ≤ 128 is the desired tag length in bits. Then the CWC mode of operation using BC with tag length tl, CWC-BC-tl = (K, CWC-ENC, CWC-DEC), is defined as follows. The message spaces are:</p><formula xml:id="formula_4">MsgSp CWC-BC-tl = { x ∈ ({0, 1} 8 ) * : |x| ≤ MaxMsgLen } AdSp CWC-BC-tl = { x ∈ ({0, 1} 8 ) * : |x| ≤ MaxAdLen } KeySp CWC-BC-tl = {0, 1} kl NonceSp CWC-BC-tl = {0, 1} 88</formula><p>where MaxMsgLen and MaxAdLen are both 128 • (2 32 -1). That is, the payload and associated data spaces for CWC-BC-tl consist of all strings of octets that are at most 2 32 -1 blocks long.</p><p>The CWC-BC-tl key generation, encryption, and decryption algorithms are defined as follows:</p><formula xml:id="formula_5">Algorithm K K $ ← {0, 1} kl Return K Algorithm CWC-ENC K (N, A, M ) σ ← CWC-CTR K (N, M ) τ ← CWC-MAC K (N, A, σ) Return σ τ Algorithm CWC-DEC K (N, A, C) If |C| &lt; tl then return INVALID Parse C as σ τ where |τ | = tl If A ∈ AdSp CWC-BC-tl or σ ∈ MsgSp CWC-BC-tl then return INVALID If τ = CWC-MAC K (N, A, σ) then return INVALID M ← CWC-CTR K (N, σ) Return M</formula><p>The remaining algorithms (CWC-CTR, CWC-MAC, CWC-HASH) are defined below. The CWC-CTR algorithm handles generating the encryption and decryption keystreams, CWC-MAC handles the generation of an authentication tag, and uses CWC-HASH as the underlying universal hash function.</p><formula xml:id="formula_6">Algorithm CWC-CTR K (N, M ) α ← |M |/128 For i = 1 to α do s i ← BC K (10 7 N tostr(i, 32)) x ← first |M | bits of s 1 s 2 • • • s α σ ← x ⊕ M Return σ Algorithm CWC-MAC K (N, A, σ) R ← BC K (CWC-HASH K (A, σ)) τ ← BC K (10 7 N 0 32 ) ⊕ R Return first tl bits of τ Algorithm CWC-HASH K (A, σ) Z ← last 127 bits of BC K (110 126 ) K h ← toint(Z) l ← min integer such that 96 divides |A 0 l | l ← min integer such that 96 divides |σ 0 l | X ← A 0 l σ 0 l ; β ← |X|/96 Break X into chunks X 1 , X 2 , . . . , X β For i = 1 to β do Y i ← toint(X i ) l σ ← |σ|/8 ; l A ← |A|/8 Y β+1 ← 2 64 • l A + l σ R ← Y 1 K β h + • • • + Y β K h + Y β+1 mod 2 127 -1 Return tostr(R, 128)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Theorem statements</head><p>The CWC scheme is a provably secure AEAD scheme assuming that the underlying block cipher, e.g., AES, is a secure pseudorandom permutation. This is a quite reasonable assumption since most modern block ciphers, including AES, are believed to be pseudorandom. Furthermore, all provablysecure block cipher modes of operation that we are aware of make at least the same assumptions we make, and some modes, such as OCB <ref type="bibr" target="#b23">[24]</ref>, require the stronger, albeit still reasonable, assumption of super-pseudorandomness.</p><p>The specific results for CWC appear as Theorem 4.1 and Theorem 4.2 below, and are proven in Appendix C. In Appendix C we also present results for the general CWC construction, from which Theorems 4.1 and 4.2 follow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Privacy</head><p>We first show that if BC is a secure block cipher, then CWC-BC-tl will preserve privacy under chosen-plaintext attacks. For our notion of privacy for AEAD schemes, we use the strong definition of indistinguishability from <ref type="bibr" target="#b22">[23]</ref>. Let SE = (K e , E, D) be an AEAD scheme with length function l(•). Let $(•, •, •) be an oracle that, on input (N, A, M ) ∈ NonceSp SE × AdSp SE × MsgSp SE , returns a random string of length l(|M |). Let B be an adversary with access to an oracle and that returns a bit. Then</p><formula xml:id="formula_7">Adv priv SE (B) = Pr K $ ← K e : B E K (•,•,•) = 1 -Pr B $(•,•,•) = 1</formula><p>is the ind$-cpa-advantage of B in breaking the privacy of SE under chosen-plaintext attacks; i.e., Adv priv SE (B) is the advantage of B in distinguishing between ciphertexts from E K (•, •, •) and random strings. An adversary B is nonce-respecting if it never queries its oracle with the same nonce twice. Intuitively, a scheme SE preserves privacy under chosen plaintext attacks if the ind$-cpa-advantage of all nonce-respecting adversaries using reasonable resources is small. Theorem 4.1 [Privacy of CWC.] Let CWC-BC-tl be as in Section 3. Then given a noncerespecting ind$-cpa adversary A against CWC-BC-tl one can construct a prp adversary C A against BC such that if A makes at most q oracle queries totaling at most µ bits of payload message data, then</p><formula xml:id="formula_8">Adv priv CWC-BC-tl (A) ≤ Adv prp BC (C A ) + (µ/128 + 3q + 1) 2 2 129 . (<label>1</label></formula><formula xml:id="formula_9">)</formula><p>Furthermore, the experiment for C A takes the same time as the experiment for A and C A makes at most µ/128 + 3q + 1 oracle queries.</p><p>Let us elaborate on why Theorem 4.1 implies that CWC-BC will preserve privacy under chosenplaintext attacks. Assume BC is a secure block cipher. This means that Adv prp BC (C) must be small for all adversaries C using reasonable resources and, in particular, this means that, for C A as described in the theorem statement, Adv prp BC (C A ) must be small assuming that A uses reasonable resources. And if Adv prp BC (C A ) is small and µ, q are small, then, because of the above equations, Adv priv CWC-BC-tl (A) must also be small as well. I.e., any adversary A using reasonable resources will only be able to break the privacy of CWC-BC-tl with some small probability.</p><p>As a concrete example, let us consider limiting the number of applications of CWC-BC-tl between rekeyings to some reasonable value such as q = 2 32 , and let us limit the total number of payload bits between rekeyings to µ = 2 50 . Then Equation <ref type="formula" target="#formula_8">1</ref>becomes</p><formula xml:id="formula_10">Adv priv CWC-BC-tl (A) ≤ Adv prp BC (C A ) + 1 2 42</formula><p>which means that, assuming that the underlying block cipher is a secure prp, an attacker will not be able to break the privacy of CWC-BC-tl with advantage much greater than 2 -42 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Integrity/authenticity</head><p>We now present our results showing that if BC is a secure block cipher, then CWC-BC-tl will protect the authenticity of encapsulated data. We use the strong notion of authenticity for AEAD schemes from <ref type="bibr" target="#b22">[23]</ref>. Let SE = (K e , E, D) be an AEAD scheme. Let F be a forging adversary and consider an experiment in which we first pick a random key K $ ← K e and then run F with oracle access to</p><formula xml:id="formula_11">E K (•, •, •). We say that F forges if F returns a pair (N, A, C) such that D N,A K (C) = INVALID but F did not make a query (N, A, M ) to E K (•, •, •) that resulted in a response C. Then Adv auth SE (F ) = Pr K $ ← K e : F E K (•,•,•) forges</formula><p>is the auth-advantage of F in breaking the integrity/authenticity of SE. Intuitively, the scheme SE preserves integrity/authenticity if the auth-advantage of all nonce-respecting adversaries using reasonable resources is small. (Recall that BC is a 128-bit block cipher and that the tag length tl is ≤ 128.) Consider a noncerespecting auth adversary A against CWC-BC-tl. Assume the execution environment allows A to query its oracle with associated data that are at most n ≤ MaxAdLen bits long and with messages that are at most m ≤ MaxMsgLen bits long. Assume A makes at most q -1 oracle queries and the total length of all the payload data (both in these q -1 oracle queries and the forgery attempt) is at most µ. Then given A we can construct a prp adversary C A against BC such that</p><formula xml:id="formula_12">Adv auth CWC-BC-tl (A) ≤ Adv prp BC (C A ) + (µ/128 + 3q + 1) 2 2 129 + n + m 2 133 + 1 2 125 + 1 2 tl .</formula><p>(2)</p><p>Furthermore, the experiment for C A takes the same time as the experiment for A and C A makes at most µ/128 + 3q + 1 oracle queries.</p><p>Let us elaborate on why Theorem 4.2 implies that CWC-BC will preserve authenticity. Assume BC is a secure block cipher. This means that Adv prp BC (C) must be small for all adversaries C using reasonable resources and, in particular, this means that, for C A as described in the theorem statement, Adv prp BC (C A ) must be small assuming that A uses reasonable resources. And if Adv prp BC (C A ) is small and µ, q, m and n are small, then, because of the above equations, Adv auth CWC-BC-tl (A) must also be small as well. I.e., any adversary A using reasonable resources will only be able to break the authenticity of CWC-BC-tl with some small probability.</p><p>Let us consider some concrete examples. Let n = MaxAdLen and m = MaxMsgLen, which is the maximum possible allowed by the CWC-BC construction. Then Equation <ref type="formula">2</ref>becomes</p><formula xml:id="formula_13">Adv auth CWC-BC-tl (A) ≤ Adv prp BC (C A ) + (µ/128 + 3q + 1) 2 2 129 + 1 2 93 + 1 2 tl .</formula><p>If we set q = 2 32 and µ = 2 50 as before, and if we take tl ≥ 43, then the above equation becomes</p><formula xml:id="formula_14">Adv auth CWC-BC-tl (A) ≤ Adv prp BC (C A ) +<label>1</label></formula><p>2 41 which means that, assuming that the underlying block cipher is a secure prp, an attacker will not be able to break the unforgeability of CWC-BC-tl with probability much greater than 2 -41 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Remark 4.3 [Chosen-ciphertext privacy.]</head><p>Since CWC-BC-tl preserves privacy under chosenplaintext attacks (Theorem 4.1) and provides integrity (Theorem 4.2) assuming that BC is a secure pseudorandom permutation, it also provides privacy under chosen-ciphertext attacks under the same assumption about BC. See <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b22">23]</ref> for a discussion of the relationship between chosen-plaintext privacy, integrity, and chosen-ciphertext privacy; this relationship was also used, for example, by the designers of OCB <ref type="bibr" target="#b23">[24]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Design decisions</head><p>Finding an appropriate balance between provable security, hardware efficiency, and software efficiency, while simultaneously avoiding existing intellectual property issues, proved to be one the the biggest challenges of this research project. In this section we discuss how our diverse set of goals affected our design decisions.</p><p>The CWC-HASH universal hash function. We found that the best way to simultaneously achieve our parallelizability, hardware, and software goals was to base the authentication portion of CWC on the Carter-Wegman <ref type="bibr" target="#b27">[28]</ref> universal hash function approach to message authentication. This is because universal hash functions, and especially the one we created for CWC, can be implemented in a multitude of ways, thus allowing different platforms and applications to implement CWC-HASH in the way most appropriate for them. For example, hardware implementations will like parallelize the computation of CWC-HASH by splitting it into multiple polynomials in K i h for some i. In more detail, if the polynomial is</p><formula xml:id="formula_15">Y 1 K β h + Y 2 K β-1 h + Y 3 K β-2 h + Y 4 K β-3 h + • • • + Y β K h + Y β+1 mod 2 127 -1 .</formula><p>then, setting i = 2, and y = K 2 h mod 2 127 -1, and assuming β is odd for illustration purposes, we can rewrite the above polynomial as</p><formula xml:id="formula_16">Y 1 y m + Y 3 y m-1 + • • • + Y β x + Y 2 y m + Y 4 y m-1 + • • • + Y β+1 mod 2 127 -1 ,</formula><p>After splitting the polynomial, hardware implementations will then likely compute each polynomial using Horner's rule (e.g., the polynomial aK 2i h +bK i h +c would be evaluated as (((a)K i h +b)K i h )+c). Software implementations on modern CPUs, for which memory is cheap, will likely precompute a number of powers of K h and evaluate the CWC-HASH polynomial directly, or almost directly, using a hybrid between a precomputation approach and Horner's rule. We consider a number of possible implementation strategies in more detail in Section 6.</p><p>CWC-HASH is an instantiation of the classic polynomial universal hash approach to message authentication <ref type="bibr" target="#b27">[28]</ref>, and is closely related to Bernstein's hash127 <ref type="bibr" target="#b5">[6]</ref>, which also evaluates a polynomial modulo 2 127 -1. Although hash127 is very fast in software, its structure makes it less suitable for use on high-speed hardware. In particular, Bernstein's choice of 32-bit coefficients, while great for software implementations with precomputed powers of K h , means that hardware implementations using Horner's rule will be "wasting work." Specifically, even with 32-bit coefficients, incorporating each new coefficient using Horner's rule will require a 127x127-bit multiply because the accumulated value will be 127 bits long. By defining the CWC-HASH coefficients to be 96-bits long, we increase the performance of Horner's rule implementations by a factor of three. (Of course, we could have gone even further and made the coefficients 126 bits long, but doing so would have required considerable additional complexity to perform bit and byte shifting within the coefficients.) An alternative approach for increasing the performance of a serial implementation of Horner's rule would be to reduce the size of the CWC-HASH subkey K h to 96 bits. We discuss why we rejected this option in more detail later, but remark here that there are already more efficient strategies than Horner's rule for implementing CWC-HASH in software, and that in a parallelized approach the values K i h , i ≥ 2, will most often be full 127-bit values even if K h is only 96-bits long. On using a single key. From a security perspective, it would have been perfectly acceptable, and in fact more traditional, to make the CWC-CTR block cipher key and the two CWC-MAC block cipher keys independent. Like others <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b4">5]</ref>, however, we acknowledge that there are several important reasons for sharing keys between the encryption and authentication portions of modes such as CWC. One of the most important reasons is simplicity of key management. Indeed, fetching key material can be a major bottleneck in high-speed hardware, and minimizing key material is thus important. This fact is also why we derive the hash subkey from the block cipher key rather than use an independent hash subkey. We could, of course, have defined a mode that derived a number of essentially independent block cipher and hash keys from a single block cipher key, but doing so would either have required more memory or more computation and, because we have proofs that our construction works, would have been unnecessary.</p><p>Sharing the block cipher key in the way described above and deriving the hash subkey from the block cipher key did, however, mean that we had to be very careful with our proofs of security. To facilitate our proofs, we took extra care in our design to ensure that there would never be a collision in the plaintext inputs to the block cipher between the different usages of the block cipher. For example, by defining CWC-HASH to produce a 127-bit value as output, we know that the first application of BC to CWC-HASH K (A, σ) in CWC-MAC will always have its first bit set to 0. To avoid a collision with the input to the keystream generator, the block cipher inputs in CWC-CTR always have the first two bits set to 10. When using the block cipher to create the hash subkey K h , the first two bits of the input are set to 11.</p><p>On the choice of parameters. Part of this effort involved specifying the appropriate parameters for the CWC encryption mode. Example parameters include the nonce length and the way the nonce is encoded in the input to the block cipher. We chose to fix these parameters for interoperability purposes, but note that our general approach in Appendix C does not have theses parameters fixed. We chose to set the nonce length to 88 bits in order to handle future IPsec sequence numbers. And we chose to set the block counter length to 32 bits in order to allow CWC to be used with IPsec jumbograms and other large packets. We also chose to use big-endian byte ordering for consistency purposes and to maintain compatibility with McGrew's ICM Internet-Draft <ref type="bibr" target="#b17">[18]</ref> and the IETF, which strongly favors big-endian byte-ordering.</p><p>Handling arbitrary bit-length messages. Since we do not believe that many applications will actually require the ability to encrypt arbitrary bit-length messages, we do not define CWC to take arbitrary bit-length messages as input. That said, we did design CWC in such a way that it will be easy to modify the specification to take arbitrary bit-length messages without affecting interoperability with existing implementations when octet-strings are communicated. For example, one could augment the computation of Y β+1 in CWC-HASH as follows:</p><formula xml:id="formula_17">r A ← |A| mod 8 ; r σ ← |σ| mod 8 ; Y β+1 ← 2 120 • r A + 2 112 • r σ + 2 64 • l A + l σ .</formula><p>Of course, a cleaner approach for handling arbitrary bit-length messages would be to compute l A ← |A| and l σ ← |σ| in CWC-HASH. We do not define CWC this way because we do not consider it a good trade-off to define a mode for arbitrary bit-length messages at the expense of octet-oriented systems.</p><p>64-bit block ciphers. We did not define CWC for use with 64-bit block ciphers because we are targeting future high-speed cryptographic applications. Nevertheless, the general CWC approach in Appendix Ccan be instantiated with 64-bit block ciphers. A 64-bit instantiation may, however, require several uncomfortable tradeoffs; e.g., in the length of the nonce.</p><p>On the length of the hash subkey. As noted earlier, it is possible to use smaller subkeys K h in CWC-HASH (simply truncate BC K (110 126 ) appropriately). Recall that we have fixed the block length of BC to 128 bits. Let hkl denote the length of the hash subkey in an altered construction. is already very small (and, in fact, dominated by the (µ/128 + 3q + 1) 2 • 2 -129 term for some reasonable values of q and µ), from a provable-security perspective, developers would be justified in using 96-bit hash subkeys.</p><p>Rather than use shorter hash subkeys, however, our current CWC instantiation in Section 3 uses 127-bit hash subkeys. We do so for several reasons. First, in hardware, to obtain maximum speed, one would parallelize the CWC hash function by evaluating, for example, two polynomials in K 2 h in parallel. As noted before, since K 2 h would generally not be 96-bits long, there is no performance advantage with using 96-bit subkeys K h in this situation. In software, the use of 96-bit hash subkeys could lead to improved performance when evaluating the polynomial using Horner's rule. However, the performance of such a construction is essentially equivalent to the performance of the current construct when not using Horner's rule but using pre-computed powers of K h . Since we believe that high-performance implementations will not benefit from the use of 96-bit hash subkeys (i.e., the additional 31 key bits come with no or negligible additional cost), we have chosen to fix the length of our hash subkeys to 127 bits.</p><p>There may occasionally be reasons to use a CWC variant with hash subkeys even shorter than 96 bits. When these situations arise, caution must be exercised since the use of the shorter hash subkeys could significantly impact security. For example, using a 64-bit hash subkey would increase the upper-bound on the probability of an adversary forging to around 2 -30 , which may be too large for some applications.</p><p>On computing the tag. In CWC the MAC consisted of hashing (A, σ), enciphering the hash with the block cipher, and then xoring the result with some keystream (i.e., in the current proposal the tag is BC K (10 7 N 0 32 ) ⊕ BC K (CWC-HASH K (A, σ))).</p><p>Instead of the two block cipher applications, one could use BC K (h K (N, A, σ)) as the tag, where h is a modified version of CWC-HASH designed to hash 3-tuples instead of pairs of strings (this is important because the nonce must also be authenticated). The main disadvantage of this approach is that it would change the upper-bound in Equation <ref type="formula">2</ref>to</p><formula xml:id="formula_18">Adv prp BC (C A ) + (µ/128 + 3q + 1) 2 2 129 + q 2 • n + m 2 133 + 1 2 125 + 1 2 tl</formula><p>(note the new q 2 term). If we set n = MaxAdLen, m = MaxMsgLen, q = 2 32 , and µ = 2 50 , then for any tl ≥ 29, we get that the advantage of an adversary in breaking the unforgeability of this modified CWC variant is upper-bounded by 2 -27 , which, although not extremely large, is worse than the upper-bound of 2 -41 we get using Equation <ref type="formula">2</ref>. Even if n and m are at most one million blocks long, we see that the integrity upper-bound for the altered CWC construction is worse than the upper-bound for the CWC construction we present in Section 3. More generally, this means that for reasonable values of n, m, q, µ, the insecurity upper-bounds of this alternative will be worse than the insecurity upper-bounds of the CWC mode described in Section 3. Furthermore, the upper-bound would be even worse if one keys the hash function with shorter keys, which may happen in some situations.</p><p>Another possible way to reduce the number of block cipher invocations necessary to compute the MAC would be to take the output of the current hash function and run it through another hash function that is almost-xor-universal (see Appendix C for a description of this property). However, this approach is not attractive because it requires additional key material. In particular, while this approach may save one block cipher operation, in hardware the block cipher operation is actually smaller and simpler than managing the extra key material, given that the hardware already has a block cipher encryptor running at high speed. We could, of course, take another block cipher operation to generate the extra key material, but doing so would defeat the purpose.</p><p>Another possibility would be to use something like  <ref type="formula">2</ref>, we see the presence of a 2 34-tl term. This means that, in some situations, when using the above upper-bound as a guide for parameter selection, tag lengths must be longer than one might expect. For example, if tl = 32, then the above equation would upper-bound the advantage of an adversary against this modified construction as 1. This means that 32-bit tags should not be used with this modified construction when authenticating long messages. While one might consider this more of a "certificational" problem than a real problem, we view this property as undesirable.</p><formula xml:id="formula_19">BC K (N ) + Y 1 K β+2 h + • • • + Y β K 3 h + l A K 2 h + l σ K h mod 2 127 -1,</formula><p>EAX2. Motivated by EAX2 <ref type="bibr" target="#b4">[5]</ref>, one possible alternative to CWC might be to use BC K (1110 5 N ) both as the value to encrypt R in CWC-MAC and as the initial counter to CTR mode-encrypt M (with the first two bits of the counter always set to 10). Other EAX2-motivated constructions also exist. For example, the tag might be set to BC</p><formula xml:id="formula_20">K (h(X 0 N )) ⊕ BC K (h(X 1 A)) ⊕ BC K (h(X 2 σ)),</formula><p>where X 0 , X 1 , X 2 are strings, none of which is a prefix of the other, and h is a parallelizable universal hash function, like CWC-HASH but hashing only single strings (as opposed to pairs of strings). Compared to CWC, these alternatives have the ability to take longer nonces as input, and, from a functional perspective, can be applied to strings up to 2 126 blocks long. But we do not view this as a reason to prefer these alternatives over CWC. From a practical perspective, we do not foresee applications needing nonces longer than 11 octets, or needing to encrypt messages longer than 2 32 -1 blocks. Moreover, from a security perspective, applications should not encrypt too many packets between rekeyings, implying that even 11 octet nonces are more than sufficient. We do comment, however, that we believe the alternatives discussed in this paragraph are still more attractive than EAX because, like CWC but unlike EAX, these alternatives are parallelizable.</p><p>Using existing MACs. We chose not to base the authentication portion of our new mode on XOR-MAC <ref type="bibr" target="#b2">[3]</ref> or PMAC <ref type="bibr" target="#b6">[7]</ref> because of patent concerns and our software performance requirements and we chose not to base the authentication portion on software-efficient MACs such as HMAC <ref type="bibr" target="#b0">[1]</ref> because of our hardware parallelizability requirement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Performance</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Hardware</head><p>Since one of our main goals was to achieve high performance in hardware and, in particular, to provide a solution for future 10 Gbps IPsec (and other) network devices, let us focus first on hardware costs. As noted in the introduction, using 0.13 micron CMOS ASIC technology, it should take approximately 300 Kgates to achieve 10 Gbps throughput for CWC-AES. This estimate, which is applicable to AES with all key lengths, includes four AES counter-mode encryption engines, each running at 200 MHz and requiring about 25Kgates each. In addition, there are two 32x128-bit multiply/accumulate engines, each running at 200 MHz with a latency of four clocks, one each for the even and odd polynomial coefficients. Of course, simply keeping these engines "fed" may be quite a feat in itself, but that is generally true of any 10 Gbps path. Also, there may well be better methods to structure an implementation, depending on the particular ASIC vendor library and technology, but, regardless of the implementation strategy, 10 Gbps is quite achievable because of the inherent parallelism of CWC.</p><p>Since OCB is CWC's main competitor for high-speed environments, it is worth comparing CWC with OCB instantiated with AES (we do not compare CWC with CCM and EAX here since the latter two are not parallelizable). We first note that CWC-AES saves some gates because we only have to implement AES encryption in hardware. However, at 10 Gbps, OCB still probably requires only about half the silicon area of CWC-AES. The main question for many hardware designers is thus whether the extra silicon area for CWC-AES costs more than three royalty payments, as well as negotiation costs and overhead. With respect to negotiation costs and royalty payments, we note that despite significant demands, to date the relevant parties have not all offered publicly available IP fee schedules. Given this fact, and given today's silicon costs, we believe that the extra silicon for CWC-AES is probably cheaper overall than the negotiation costs and IP fees required for OCB.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Software</head><p>CWC-AES can also be implemented efficiently in software. Table <ref type="table">1</ref> shows timing information for CWC-AES, as well as CCM-AES and EAX-AES, on a 1.133GHz mobile Pentium III dual-booting RedHat Linux 9 (kernel 2.4.  and Windows 2000 SP2. The numbers in the table are the clocks per byte for different message lengths averaged over 50 000 runs and include the entire time for setting up (e.g., expanding the AES key-schedule) and encrypting. All implementations were in C and written by Brian Gladman <ref type="bibr" target="#b8">[9]</ref> and use 128-bit AES keys. The Linux compiler was gcc version 3.2.2; the Windows compiler was Visual Studio 6.0. To be fair, we note that OCB does run at about twice the speeds given in Table <ref type="table">1</ref>.</p><p>From Table <ref type="table">1</ref> we conclude that the three patent-free modes, as currently implemented by Gladman, share similar software performances. The "best" performing one appears to depend on OS/compiler and the length of the message being processed. On Linux, it appears that CWC-AES performs slightly better than EAX-AES for all message lengths that we tested, and better than CCM-AES for the longer messages, whereas Gladman's CCM-AES and EAX-AES implementations slightly outperform his CWC-AES implementation on Windows for all the message lengths that we tested.</p><p>Note, however, that all the implementations used to compute Table <ref type="table">1</ref> were written in C. Furthermore, the current CWC-AES code does not make use of all of the optimization techniques (and in particular precomputation) that we describe below. By switching to assembly and using the additional optimization techniques, we anticipate the speed for CWC-HASH to drop to better than 8 clocks per byte, whereas the speed for the CBC-MAC portion of CCM-AES and EAX-AES will be limited by the speed of AES (the best reported speed for AES on a Pentium III is 14.1 cpb, due to a proprietary library by Helger Lipmaa; Gladman's free hand-optimized Windows assembly implementation runs at 17.5 cpb <ref type="bibr" target="#b15">[16]</ref>). Returning to the speed of CWC-HASH, for reference we note that Bernstein's related hash127 <ref type="bibr" target="#b5">[6]</ref> runs around 4 cpb on a Pentium III when written in assembly and using the precomputation approach. Bernstein's hash127 also works by evaluating a polynomial modulo 2 127 -1; the main difference is that the coefficients for hash127 are 32 bits long, whereas the coefficients for CWC-HASH are 96 bits long (recall Section 5, which discusses why we use 96-bit coefficients). We also note that the performance of CWC-HASH will increase dramatically on 64-bit architectures with larger multiplies; an initial implementation on a G5 using 64-bit integer operations runs at around 6 cpb (when running the G5 in 32-bit mode, the hash function runs at around 15 cpb).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.1">Implementing CWC-HASH in software</head><p>Since the implementation of CWC-HASH is more complicated than the implementation of the CWC-CTR portion of CWC, we devote the rest of this section to discussing CWC-HASH.</p><p>Precomputation. As noted in Section 5, there are two general approaches to implementing CWC-HASH in software. The first is to use Horner's rule. The second is to evaluate the polynomial directly, which can be faster if one precomputes powers of the hash key K h at setup time (here the powers of K h can be viewed as an expanded key-schedule). In particular, as noted in Section 5, evaluating the polynomial using Horner's rule requires a 127x127-bit multiply for each coefficient, whereas evaluating the polynomial directly using precomputed powers of K h requires a 96x127bit multiply for each coefficient. (We discuss elsewhere why we did not make the hash subkey 96-bits, which could have sped up a serial Horner's rule implementation.) The advantage with precomputation was first observed by Bernstein in the context of hash127 <ref type="bibr" target="#b5">[6]</ref>.</p><p>The above description of the precomputation approach assumed that if the polynomial is</p><formula xml:id="formula_21">Y 1 K γ-1 h + • • • + Y γ-1 K h + Y γ (i.e.</formula><p>, the polynomial has γ coefficients), then we had precomputed the powers of K i h for all i ∈ {1, . . . , γ -1}. The precomputation approach extends naturally to the case where we have precomputed the powers K j h , j ∈ {1, . . . , n}, for some n ≤ γ -1. For simplicity, first assume that we know the polynomial has a multiple of n coefficients. For such a polynomial, one processes the first n coefficients (to get</p><formula xml:id="formula_22">Y 1 K n-1 h + . . . + Y n-1 K h + Y n ), then multiplies the in- termediate result by K n h (to get Y 1 K 2n-1 h + . . . + Y n-1 K n+1 h + Y n K n h )</formula><p>. After that, one can continue processing data with the same precomputed values (to get Y 1 K 2n-1 h + . . . + Y 2n-1 K h + Y 2n ), and so on. Note that each chunk of n coefficients takes (n -1) 96x127-bit multiplies, and all but the last chunk takes an additional 127x127-bit multiply. Now assume that the number of coefficients m in the polynomial is not necessarily a multiple of n. If m is known in advance, one could first process m mod n coefficients, multiply by K n h , then process in n-coefficient chunks as before. Alternately, as long as the end of the message is known n coefficients in advance, one could process n-coefficients chunks, and then finish off the final m mod n coefficients using Horner's rule. Or, if the number of coefficients in the polynomial is not known until the final coefficient is reached, one could process the message in n-coefficient chunks and then multiply by a precomputed power of K -1 h once the end of the message hash been reached.</p><p>Naturally, precomputation requires extra memory, but that is usually cheap and plentiful in a software-based environment. Using 32-bit multiplies, the precomputation approach requires 12 32-bit multiplies per 96-bit coefficient, as well as 17 adds, all of which may carry. In assembly, most of these carry operations can be implemented for free, or close to it by using a special variant of the add instruction that adds in the operand as well as the value of the carry from the previous add operation. But when implemented in C, they will generally compile to code that requires a conditional branch and an extra addition. An implementation using Horner's rule requires an additional four multiplies and three additions with carry per coefficient, adding about 33% overhead, since the multiplies dominate the additions. A 64-bit platform only requires four multiplies and four adds (which may all carry), no matter the implementation strategy taken, which explains why implementations of CWC-HASH for 64-bit architectures are much faster.</p><p>Exploiting the parallelism of some instruction sets. On most 32-bit platforms, it turns out that the integer execution unit is not the fastest way to implement CWC-HASH. Many platforms have multimedia instructions that can be used to speed up the implementation. As another alternative, Bernstein demonstrated that, on most platforms, the floating point unit can be used to implement this class of universal hash functions far more efficiently than can be done in the integer unit. This is particularly true on the x86 platform where, in contrast to using the standard registers, two floating point multiples can be started in close proximity without introducing a pipeline stall. That is, the x86 can effectively perform two floating-point operations in parallel. The disadvantage of using floating-point registers is that the operands for the individual multiplies need to be small, so that the operations can be done without loss of precision. On the x86, Bernstein multiplies 24-bit values, allowing the sums of product terms to fit into double precision values with 53 bits of precision without loss of information. Bernstein details many ways to optimize this sort of calculation in <ref type="bibr" target="#b5">[6]</ref>.</p><p>As noted before, there are only two main differences between the structure of the polynomials of Bernstein's hash127 and CWC-HASH. The first is that Bernstein uses signed coefficients, whereas CWC-HASH uses unsigned coefficients; this should not have an impact on efficiency. The other difference is that Bernstein uses 32-bit coefficients, whereas CWC-HASH uses 96-bit coefficients. While both solutions average one multiplication per byte when using integer math, Bernstein's solution requires only .75 additions per byte, whereas CWC-HASH requires 1.42 additions per byte, nearly twice as many. Using 32-bit multiplies to build a 96x127 multiplier (assuming precomputation), CWC-HASH should therefore perform no worse than at half the speed of hash127. When using 24bit floating point coefficients to build a multiply (without applying any non-obvious optimizations), hash127 requires 12 multiplies and 16 adds per 32-bit word. CWC can get by with 8 multiples per word and 12.67 additions per word. This is because a 96-bit coefficient fits exactly into four 24-bit values, meaning we can use a 6x4 multiply for every three words. With 32-bit coefficients, we need to use two 24-bit values to represent each coefficient, resulting in a single 6x2 multiply that needs to be performed for each word.</p><p>Gladman's C implementation of CWC-HASH uses floating point arithmetic, but uses Horner's rule instead of performing precomputation to achieve extra speed. Nothing about the CWC hash indicates that it should run any worse than half the speed of hash127, if implemented in a similar manner, in assembly, and using the floating point registers and precomputation. This upper-bound paints an encouraging picture for CWC performance, because hash127 on a Pentium III runs around 4 cpb when implemented in assembly and using the floating point registers and precomputation. This indicates that a well-optimized software version of CWC-HASH should run no slower than 8 cycles per byte on the same machine.</p><p>Finally, it may be possible to further improve the performance of CWC-HASH. For example, literature from the gaming community <ref type="bibr" target="#b10">[11]</ref> indicates that one can use both integer and floating point registers in parallel. Although we have not tested this approach, it seems reasonable to conclude that one might be able to interleave integer operations, and thereby obtain additional speedups.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions</head><p>In this work we present CWC, the first AEAD mode that is simultaneously provably secure, parallelizable, efficient in hardware and software, and free from intellectual property concerns. Because of its inherent parallelism, CWC-AES is capable of processing data at 10 Gbps in hardware, making it ideal for use with coming 10 Gbps IPsec network devices. CWC-AES is also efficient in software, with the current implementation on 32-bit CPUs comparable to current implementations of the other patent-free (albeit not parallelizable) modes of operations CCM-AES and EAX-AES. In soft-ware, we anticipate significant speedups after switching to assembly and using the precomputation approach for CWC-HASH discussed in Section 6, and we have observed significant performance gains on 64-bit CPUs. messages, if desired.)</p><p>Ciphertext expansion. The ciphertext expansion is the minimum possible while still providing a tl-bit tag. That is, on input a pair (A, M ), a nonce N , and a key K, CWC-ENC K (N, A, M ) outputs a ciphertext C with length |C| = |M | + tl.</p><p>Block cipher invocations. If the hash subkey K h is computed as part of the key generation process and not during each invocation of the CWC encapsulation routine, then CWC makes one block cipher invocation during key setup and |M |/128 + 2 block cipher invocations during encapsulation and decapsulation. If the hash subkey K h is not computed as part of the key generation process, then CWC makes no block cipher invocations during key setup and |M |/128 + 3 block cipher invocations during encapsulation and decapsulation.</p><p>Provable security. CWC is a provably-secure AEAD mode assuming that the underlying block cipher (e.g., AES) is a secure pseudorandom function or permutation. The proofs of security do not require the block cipher to satisfy the strong notion of super-pseudorandomness required by some other block cipher modes of operation.</p><p>Number of options and interoperability. CWC uses a minimal number of options. The only options are the choice of the underlying block cipher (and key length) and the tag length. Having fewer options makes interoperability easier.</p><p>On-line. The CWC encryption algorithm is on-line. This means that CWC can process data as it arrives, rather than waiting for the entire message to be buffered before beginning the encryption processes. This may be advantageous when encrypting streaming data sources. (Note, however, that, like any other AEAD mode, the decryptor should still buffer the entire message and check the tag τ before revealing the plaintext and associated data.) Patent status. To the best of our knowledge CWC is not covered by any patents.</p><p>Performance. CWC is efficient in both hardware and software. In hardware, CWC can process data at 10 Gbps.</p><p>Simplicity. Although simplicity is a matter of perspective, we believe that CWC is a very simple construction. It combines standard CTR mode encryption with the evaluation of a polynomial modulo 2 127 -1. Because of its simplicity, we believe that CWC is easy to implement and understand. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C Proofs of</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.1 More definitions</head><p>We begin with a few additional definitions.</p><p>Universal hash functions. A hash function HF = (K h , H) consists of two algorithms and is defined over some key space KeySp HF , some message space MsgSp HF , and some hash space HashSp HF . The randomized key generation algorithm returns a random key K ∈ KeySp HF ; we denote this as K $ ← K h . The deterministic hash algorithm takes a key K ∈ KeySp HF and a message M ∈ MsgSp HF and returns a hash value h ∈ HashSp HF ; we denote this as h ← H K (M ). Let H $ ← HF be shorthand for Let F be a family of functions from D to R. Let A be an adversary with access to an oracle and that returns a bit. Then</p><formula xml:id="formula_23">K $ ← K h ; H ← H K .</formula><formula xml:id="formula_24">Adv prf F (A) = Pr f $ ← F : A f (•) = 1 -Pr g $ ← Func(D, R) : A g(•) = 1</formula><p>denotes the prf-advantage of A in distinguishing a random instance of F from a random function.</p><p>Intuitively, we say that F is a secure prf if the prf-advantages of all adversaries using reasonable resources is small.</p><p>Message authentication. A nonced message authentication scheme MA = (K m , T , V) consists of three algorithms and is defined over some key space KeySp MA , some nonce space NonceSp MA , some message space MsgSp MA , and some tag space TagSp MA . The randomized key generation algorithm returns a key K ∈ KeySp MA ; we denote this as K $ ← K m . The deterministic tagging algorithm T takes a key K ∈ KeySp MA , a nonce N ∈ NonceSp MA , and a message M ∈ MsgSp MA and returns a tag τ ∈ TagSp MA ; we denote this process as τ ← T N K (M ) or τ ← T K (N, M ). The deterministic verification algorithm V takes as input a key K ∈ KeySp MA , a nonce N ∈ NonceSp MA , a message M ∈ MsgSp MA , and a candidate tag τ ∈ {0, 1} * , computes τ = T N K (M ), and returns accept if τ = τ and returns reject otherwise.</p><p>Let F be a forging adversary and consider an experiment in which we first pick a random key K $ ← K m and then run F with oracle access to T K (•, •). We say that F forges if F returns a triple (N, M, τ ) such that V N K (M, τ ) = accept but F did not make a query (N, M ) to T K (•, •) that resulted in a response τ . Then</p><formula xml:id="formula_25">Adv uf MA (F ) = Pr K $ ← K m : F T K (•,•) forges</formula><p>denotes the uf-advantage of F in breaking the unforgeability of MA. An adversary is noncerespecting if it never queries its tagging oracle with the same nonce twice. Intuitively, MA is unforgeable if the uf-advantage of all nonce-respecting adversaries with reasonable resources is small.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.2 The general CWC construction</head><p>We now describe our generalization of the CWC construction.</p><p>Construction C.1 [General CWC.] Let l, L, n, o, t, k be positive integers such that t ≤ L. (Further restrictions will be placed shortly.) Essentially, l is the length of the input to a prf (e.g., 128), L is the length of the output from the prf (e.g., 128), n is the length of the nonce (e.g., 88), o is the length of the offset (e.g., 32), t is the length of the desired tag (e.g., 64 or 128), k is the length of the hash function's keysize (e.g., 127).</p><p>Let F be a family of functions from {0, 1} l to {0, 1} L . Let HF = (K h , H) be a family of hash functions with HashSp HF = {0, 1} l and KeySp HF = {0, 1} k (and K h works by randomly selecting and returning an element from {0, 1} k with uniform probability). Let ctr0 :</p><formula xml:id="formula_26">Z k/L → {0, 1} l , ctr1 : {0, 1} n ×(Z 2 o -{0}) → {0, 1} l and ctr2 : {0, 1} n → {0, 1} l be efficiently-computable injective functions. If W = { ctr0(O) : O ∈ Z k/L }, X = { ctr1(N, O) : N ∈ {0, 1} n , O ∈ (Z 2 o -{0}) }, Y = { ctr2(N ) : N ∈ {0, 1} n }, and Z = { H K (M ) : K ∈ KeySp HF , M ∈ MsgSp HF },</formula><p>we require that W , X, Y , and Z be pairwise mutually exclusive.</p><p>Let extract : {0, 1} k/L •L → {0, 1} k be a function that takes as input a k/L • L-bit string and that outputs a k-bit string. We require that extract always pick the same k bits from the input string and always outputs those bits in the exact same order (e.g., extract returns the first k bits of its input).</p><p>Let SE[F, HF] = (K e , E, D) be an AEAD scheme built from function family F and hash function HF and using the above functions extract, ctr0, ctr1, ctr2. We assume that AdSp SE[F,HF ] × MsgSp SE[F,HF ] ⊆ MsgSp HF and that all messages in MsgSp SE[F,HF ] have length at most L • (2 o -1). Note that the former means that the message space of HF actually consists of pairs of strings. Let NonceSp SE[F,HF ] = {0, 1} n . Let SE[F, HF]'s component algorithms be defined as follows:</p><formula xml:id="formula_27">Algorithm K e f $ ← F K h ← extract(f (ctr0(0)) f (ctr0(1)) • • • f (ctr0( k/L -1))) ; H ← H K h Return f, H Algorithm E N,A f,H (M ) σ ← CTR-MODE N f (M ) τ ← first t bits of (f (ctr2(N )) ⊕ f (H(A, σ))) Return σ τ Algorithm D N,A f,H (C) If |C| &lt; t then return INVALID Parse C as σ τ // |τ | = t If A ∈ AdSp SE[F,HF ] or σ ∈ MsgSp SE[F,HF ] then return INVALID τ ← first t bits of (f (ctr2(N )) ⊕ f (H(A, σ))) If τ = τ return INVALID M ← CTR-MODE N f (σ) Return M Algorithm CTR-MODE N f (X) α ← |X|/L For i = 1 to α do Z i ← f (ctr1(N, i)) Y ← (first |X| bits of Z 1 Z 2 • • • Z α ) ⊕ X Return Y</formula><p>Before proceeding we make several observations. Recall that one requirement on the message space for any AEAD scheme is that if it contains any string M , then it contains all strings of length |M |. This means that the membership test σ ∈ MsgSp SE[F,HF ] and the application of H to (A, σ) makes sense.</p><p>As specified in the definition, AdSp SE[F,HF ] × MsgSp SE[F,HF] ⊆ MsgSp HF . This means that we HF is used to hash pairs of strings, not just string. This is not a serious restriction since given algorithm selects a random key K from {0, 1} 127 and let H K be the CWC-HASH function except that we replace Z ← last 127 bits of BC K (110 126 ) with</p><formula xml:id="formula_28">Z ← K .</formula><p>Note that AdSp CWC-BC-tl × MsgSp CWC-BC-tl ⊆ MsgSp HF ; that is, H K takes two strings as input. Assume HF hashes pairs of strings where the first string is always at most n ≤ MaxAdLen bits long and the second string is always at most m ≤ MaxMsgLen bits long. Then HF is -almost universal where</p><formula xml:id="formula_29">≤ n + m 2 133 + 1 2 125 .</formula><p>Proof of Lemma C.4: Let (A, σ) and (A , σ ) be two distinct inputs to H K and let X = (B 1 , . . . , B β+1 ) and Y = (C 1 , . . . , C γ+1 ) respectively denote their encodings as vectors of 96-bit integers (with B β+1 and C γ+1 possibly longer than 96-bits long). Without loss of generality, assume β ≤ γ and let X = (B 1 , . . . , B γ+1 ) where B j = 0 for j ∈ {1, . . . , γ -β} and B j = B j-γ+β for j ∈ {γ -β + 1, . . . , γ + 1} (i.e., prepend γ -β zero elements to the X vector).</p><p>If (A, σ) = (A , σ ) then X = Y . This follows from the fact that B γ+1 and C γ+1 respectively encode the lengths of A and σ and of A and σ and that if X = Y , then the B γ+1 = C γ+1 and (A, σ) = (A , σ ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Note that H</head><formula xml:id="formula_30">K (A, σ) = H K (A , σ ) when B 1 • K γ h + • • • + B γ • K h + B γ+1 -C 1 • K γ h + • • • + C γ • K h + C γ+1 = 0 mod 2 127 -1<label>(3)</label></formula><p>where K h is the hash key derived from K as specified in CWC-HASH. Since the vectors X and Y are not equal,</p><formula xml:id="formula_31">B 1 • K γ h + • • • + B γ • K h + B γ+1 -C 1 • K γ h + • • • + C γ • K h + C γ+1</formula><p>is a non-zero polynomial of degree at most γ. Therefore, by the Fundamental Theorem of Algebra, Equation 3 has at most γ solution modulo 2 127 -1.</p><p>Since we are interested in the probability, over the 127-bit keys K, that Equation 3 is true, we note that all keys K h modulo 2 127 -1 (except 0) have exactly one ways of occurring and that the 0 key can occur in one additional way (i.e., the all 0 string and the all 1 string). This means that of the 2 127 possible keys K, at most γ + 1 can lead to keys K h such that Equation 3 is true.</p><p>Finally, note that γ is at most 2 + (n + m)/96 (the +2 comes from the fact that we append 0 bits to A and σ). Consequently Since BC plays the role of F , we have that l = L = 128. Furthermore, as described in Section 3, n = 88, o = 32, t = tl, and k = 127. We note that the output the hash function is a 128-bit string whose first bit is always 0. This property, as well as the encodings for the nonce/offsets when encrypting the message and the Carter-Wegman MAC and when generating the hash key, ensure that requisite properties for the interactions between the hash function, ctr0, ctr1, and ctr2.</p><p>A direct comparison of the Construction C.1 algorithms and the algorithms from Section 3 shows that they are equivalent. CWC-BC-tl is therefore an instantiation of Construction C.1 and the provable security of CWC-BC-tl follows.</p><p>Finally, we apply the standard prf-prp switching technique in order to model the underlying block cipher as a prp rather than a prf in Theorem 4.2 and Theorem 4.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.5 Proof of Lemma C.2</head><p>We being by sketching the proof of Lemma C.2. We first show that applying a random function to the output of an -au hash function yields an -axu hash function (Proposition C.6). We then recall the result of <ref type="bibr">Krawczyk [14]</ref> that xoring the output of an axu hash function with a one-time pad yields a secure MAC (Proposition C.8). Such a MAC essentially corresponds to the second and third boxed steps in Construction C.1. (We do not need this final block cipher application if the input to the hash includes the nonce and if we accept a birthday term of the form q 2 .)</p><p>We then observe that if we consider a construction like Construction C.1 but with the latter two boxed steps replaced with calls to a secure MAC that tags pairs of strings (A, σ) with nonces N , then that construction would be unforgeable (Proposition C.10). In Proposition C.13 we use the above results to show that SE[Func(l, L), HF] preserves integrity (where SE[Func(l, L), HF] is as in Construction C.1). Lemma C.2 follows.</p><p>From AU to AXU. Let us begin with the following construction.</p><p>Construction C.5 [Building AXU hash functions from AU hash functions.] Let HF = (K h , H) be a hash function and let HF[t] = (K h , H), t a positive integer, be the hash function defined as follows: This result follows from a result in <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b21">22]</ref> which states that the composition of an -axu hash function, with domain B and range C, with an -au hash function, with domain A and range B, is an ( + )-axu hash function with domain A and range C, and the fact that the hash function whose key generation algorithm returns a random function from Func(HashSp HF , {0, 1} t ) is 2 -t -axu.</p><formula xml:id="formula_32">K h H $ ← HF e $ ← Func</formula><p>Carter-Wegman MACs. Consider now the following construction.</p><p>Construction C.7 [Building MACs from AXU hash functions.] Let HF = (K h , H) be a hash function with hash space {0, 1} t , t a positive integer. We can construct a nonced message authentication scheme MA = (K m , T , V) as follows:</p><formula xml:id="formula_33">K m H $ ← HF g $ ← Func(NonceSp MA , {0, 1} t ) Return H, g T H,g (N, M ) Return g(N ) ⊕ H(M ) V H,g (N, M, τ ) If g(N ) ⊕ H(M ) = τ then return accept Else return reject</formula><p>Note that MsgSp MA = MsgSp HF , TagSp MA = {0, 1} t , and that NonceSp MA is arbitrary.</p><p>We now state the following result, due to Krawczyk <ref type="bibr" target="#b13">[14]</ref>.</p><p>Proposition C.8 Let HF and MA be as in Construction C.7. If HF is -axu, then for all nonce-respecting uf adversaries F attacking MA, Adv uf MA (F ) ≤ . As noted in <ref type="bibr" target="#b13">[14]</ref>, this proposition follows from the facts that xoring the output of the hash function with g(N ) prevents any loss of information (assuming that the adversary is nonce-respecting), that a forgery attempt with a previous nonce is upper-bounded by , and that a forgery attempt with a new nonce is upper-bounded by 2 -t ≤ .</p><p>Encrypt-then-Authenticate. Consider the following Encrypt-then-Authenticate <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b14">15]</ref> construction.</p><p>Construction C.9 [Encrypt-then-Authenticate.] Let l, L, n, o, t be positive integers. (Further restrictions will be placed shortly.) Essentially, l is the length of the input to a prf (e.g., 128), L is the length of the output from the prf (e.g., 128), n is the length of the nonce (e.g., 88), o is the length of the offset (e.g., 32).</p><p>Let F be a family of functions from {0, 1} l to {0, 1} L . Let MA = (K m , T , V) be a message authentication scheme with NonceSp MA = {0, 1} n and TagSp MA = {0, 1} t . Let ctr1 : {0, 1} n × (Z 2 o -{0}) → {0, 1} l be an efficiently-computable injective function.</p><p>Let SE[F, MA] = (K e , E, D) be an AEAD scheme built from function family F and message authentication scheme MA and using the above function ctr1. We assume that AdSp  <ref type="bibr" target="#b11">12</ref> Let SE[F, HF] be as in Construction C.11 and let HF be an -au hash function. Then the advantage of any nonce-respecting auth adversary A in breaking the authenticity of SE[F, HF] is upper bounded by</p><formula xml:id="formula_34">Algorithm K e f $ ← F K $ ← K m Return f, K Algorithm E N,A f,K (M ) σ ← CTR-MODE N f (M ) τ ← T N K (A, σ) Return σ τ Algorithm D N,A f,K (C) If |C| &lt; t then return INVALID Parse C as σ τ // |τ | = t If A ∈ AdSp SE[F,MA] or σ ∈ MsgSp SE[F,MA] then return INVALID τ ← T N K (A, σ) If τ = τ return INVALID M ← CTR-MODE N f (σ) Return M Algorithm D N,A f,H,e,g (C) If |C| &lt; t then return INVALID Parse C as σ τ // |τ | = t If A ∈ AdSp SE[F,HF ] or σ ∈ MsgSp SE[F,HF ] then return INVALID τ ← g(N ) ⊕ e(H(A, σ)) If τ = τ return INVALID M ← CTR-MODE N f (σ) Return M Algorithm CTR-MODE N f (X) α ← |X|/L For i = 1 to α do Z i ← f (ctr1(N, i)) Y ← (first |X| bits of Z 1 Z 2 • • • Z α ) ⊕ X Return Y Proposition C.</formula><formula xml:id="formula_35">Adv auth SE[F,HF] (A) ≤ + 2 -t .</formula><p>Proof of Proposition C.12: We first note that the steps d  </p><formula xml:id="formula_36">$ ← Func(Z k/L , {0, 1} L ) ; K h ← extract(d(0) d(1) • • • d( k/L -1)) ; H ← H K h is</formula><formula xml:id="formula_37">(A) = Pr f $ ← F : B f (•) A = 1 and Adv auth SE[Func(l,L),HF ] (A) = Pr f $ ← Func(l, L) : B f (•) A = 1 . Since Adv auth SE[Func(l,L),HF ] (A) ≤ + 2 -t by Proposition C.13, we have Adv auth SE[F,HF] (A) = Adv auth SE[F,HF ] (A) -Adv auth SE[Func(l,L),HF ] (A) + Adv auth SE[Func(l,L),HF ] (A) ≤ Pr f $ ← F : B f (•) A = 1 -Pr f $ ← Func(l, L) : B f (•) A = 1 + + 2 -t = Adv prf F (B A ) + + 2</formula><formula xml:id="formula_38">← K e : A E f,h (•,•,•) = 1 = Pr g $ ← F : B g(•)</formula><p>A = 1 since when B A is given a random instance of F it runs A exactly as if A was given the real encryption oracle. Furthermore  <ref type="figure">------------------------------------------------------------</ref>  <ref type="figure">------------------------------------------------------------</ref>  <ref type="figure">-------------------------------------------------------------</ref>  <ref type="figure">------------------------------------------------------------</ref>  <ref type="figure">------------------------------------------------------------</ref>  <ref type="figure">-------------------------------------------------------------</ref>  <ref type="figure">------------------------------------------------------------</ref>  <ref type="figure">------------------------------------------------------------</ref>  <ref type="figure">------------------------------------------------------------</ref>  <ref type="figure">------------------------------------------------------------</ref>  <ref type="figure">------------------------------------------------------------</ref>  <ref type="figure">------------------------------------------------------------</ref>  <ref type="figure">------------------------------------------------------------</ref>  <ref type="figure">------------------------------------------------------------</ref>  <ref type="figure">------------------------------------------------------------</ref>  <ref type="figure">------------------------------------------------------------</ref>  <ref type="figure">------------------------------------------------------------</ref>  <ref type="figure">------------------------------------------------------------</ref> </p><formula xml:id="formula_39">Pr A $(•,•,•) = 1 = Pr g $ ← Func(l, L) : B g(•) A = 1 since B A replies</formula></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Theorem 4 . 2 [</head><label>42</label><figDesc>Integrity/authenticity of CWC.] Let CWC-BC-tl be as specified in Section 3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Theorem 4.1 and Theorem 4.2 Before proving Theorem 4.1 and Theorem 4.2, we first state results about the general CWC construction (see Lemma C.2 and Lemma C.3 below). We then show how Theorems 4.1 and 4.2 follow from Lemmas C.2 and C.3. We then prove these two lemmas.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>The hash function HF is said to be -almost universal( -au)  if for all distinct m, m ∈ MsgSp HF , Pr H $ ← HF : H(m) = H(m ) ≤ . The hash function HF is said to be -almost xor universal ( -axu) if HashSp HF = {0, 1} n for some positive integer n and for all distinct m, m ∈ MsgSp HF and c ∈ {0, 1} n , Pr H $ ← HF : H(m) ⊕ H(m ) = c ≤ . Pseudorandom functions. If X and Y are sets, then Func(X, Y ) denotes the set of all functions from X to Y . If l and L are positive integers, then Func(l, L) denotes the set of all functions from {0, 1} l to {0, 1} L .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Theorem 4.2 and Theorem 4.1, which are corollaries of Lemmas C.2, C.3, and C.4. Proof of Theorem 4.2 and Theorem 4.1: To prove these theorems we must show that the CWC-BC-tl constructions from Section 3 are instantiations of Construction C.1. We begin by noting that the block cipher BC in CWC-BC-tl plays the role of F in Construction C.1 and that the hash function CWC-HASH (with the simplified key generation algorithm from Lemma C.4) plays the role of HF in Construction C.1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>SE[F,MA] × MsgSp SE[F,MA] ⊆ MsgSp MA and that all messages in MsgSp SE[F,MA] have length at most L•(2 o -1). Note that the former means that the message space of MA actually consists of pairs of strings. Let NonceSp SE[F,MA] = NonceSp MA . Let SE[F, MA]'s component algorithms be defined as follows:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>and M ∈ MsgSp SE . Let l(•) denote the length function of SE; i.e., for all keys K, nonces N , headers A,</figDesc><table><row><cell>and messages M , |E N,A K (M )| = l(|M</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>If hkl &lt; 127, then the upper-bound in Equation2becomes Consider an application that sets hkl to 96. If we replace m and n by their maximum possible values, the upper-bound becomes</figDesc><table><row><cell>Adv prp BC (C A ) +</cell><cell cols="2">(µ/128 + 3q + 1) 2 2 129</cell><cell>+</cell><cell cols="3">(n + m)/96 + 2 2 hkl</cell><cell>+</cell><cell>1 2 tl .</cell></row><row><cell cols="2">Adv prp BC (C A ) +</cell><cell cols="3">(µ/128 + 3q + 1) 2 2 129</cell><cell>+</cell><cell>1 2 62 +</cell><cell>1 2 tl .</cell></row><row><cell>Since 2 -62</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>encoded as a 127-bit string and truncated to tl bits, as the MAC (here BC K (N ) is interpreted as an integer). Doing so would, however, result in a new integrity upper-bound If we take n and m to be MaxAdLen and MaxMsgLen, respectively, then the upper-bound becomes</figDesc><table><row><cell>Adv prp BC (C A ) +</cell><cell cols="2">(µ/128 + 2q + 1) 2 + 4q + 4 2 129</cell><cell>+</cell><cell cols="2">(n + m)/96 + 5 2 tl</cell><cell>.</cell></row><row><cell cols="2">Adv prp BC (C A ) +</cell><cell cols="3">(µ/128 + 2q + 1) 2 + 4q + 4 2 129</cell><cell>+</cell><cell>2 34 2 tl .</cell></row><row><cell>Compared to Equation</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>(HashSp HF , {0, 1} t ) Note that MsgSp HF [t] = MsgSp HF and HashSp HF [t] = {0, 1} t . Let HF, t, and HF[t] be as in Construction C.5. If HF is -au, then HF[t] is ( + 2 -t )-axu.</figDesc><table><row><cell>H H,e (M )</cell></row><row><cell>Return e(H(M ))</cell></row><row><cell>Return H, e</cell></row><row><cell>Proposition C.6</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>equivalent to the step H By Proposition C.10, given A we can construct an adversary B A against MA such that Integrity of SE[Func(l, L), HF]. We now consider the integrity of SE[Func(l, L), HF].Proposition C.<ref type="bibr" target="#b12">13</ref> Let SE[Func(l, L), HF] be a AEAD scheme as in Construction C.1. Then for any nonce-respecting auth adversary A against SE[Func(l, L), HF], we have that HF] and SE [Func(l, L), HF] are identical except that the former uses only one random function f and SE [Func(l, L), HF] uses four random functions (one to generate the hash key, one to CTR-mode encrypt the message, one to encipher the output of the hash function, and one to CTR-mode encrypt the output of the hash function). Furthermore, recall that, for SE[Func(l, L), HF], there is never a collision in the input to f between the four different uses of f (this was a requirement imposed on HF, ctr0, ctr1, and ctr2). Consequently, the fact that SE [Func(l, L), HF] uses four random functions and SE[Func(l, L), HF] uses one is immaterial. Hence the probability that A forges against SE[Func(l, L), HF] is the same as the probability that it forges against SE [Func(l, L), HF]. I.e., By Proposition C.12, we know the latter probability is upper bounded by + 2 -t .Proof of Lemma C.2. We now prove Lemma C.2.Proof of Lemma C.2: Adversary B A runs A and replies to A's oracle queries using its oracle f . If A returns a valid forgery, B A returns 1, otherwise B A returns 0. This implies that</figDesc><table><row><cell>Note that e(H(A, σ)) can be rewritten as H H,e (A, σ) where HF[t] = (K h , H) is composed from HF per Construction C.5. Also note that g(N ) ⊕ H H,e (A, σ) can be replaced with T N H H,e ,g (A, σ) where MA = (K m , T , V) is composed from HF[t] as per Construction C.7. Adv auth SE[F,HF ] (A) ≤ Adv uf MA (B A ) . By Proposition C.8 we know that Adv uf MA (B A ) ≤ where is + 2 -t (the latter by Proposition C.6). Adv auth SE[Func(l,L),HF ] (A) ≤ + 2 -t . Proof of Proposition C.13: Let SE [Func(l, L), HF] be as in Construction C.11. Note that SE[Func(l,L),HF ] (A) = Adv auth SE [Func(l,L),HF] (A) . SE[Func(l, L), Adv auth Adv auth SE[F,HF ]</cell></row></table><note><p><p>$</p>← HF.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>to all of A's oracle queries with independently selected random strings. Consequently</figDesc><table><row><cell cols="2">D Test vectors</cell></row><row><cell cols="2">Vector #1: CWC-AES-128</cell></row><row><cell>AES KEY:</cell><cell>00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F</cell></row><row><cell cols="2">PLAINTEXT: 00 01 02 03 04 05 06 07</cell></row><row><cell cols="2">ASSOC DATA: &lt;None&gt;</cell></row><row><cell>NONCE:</cell><cell>FF EE DD CC BB AA 99 88 77 66 55</cell></row><row><cell>-</cell><cell></cell></row><row><cell></cell><cell>Adv priv SE[F,HF ] (A) ≤ Adv prf F (B A )</cell></row><row><cell>as desired.</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_17"><head>-</head><label></label><figDesc>HASH KEY: 34 AE 6A 6F E9 51 78 94 AC CC BB 9E BA E7 20 8C HASH VALUE: 51 AE 9D 7E 86 BD E0 B2 AA 18 2C 91 87 0A 9C A5 AES(HVAL): DF 48 30 BD 1D DC E0 59 B1 C2 0B 29 01 4F 80 10 MAC CTR PT: 80 FF EE DD CC BB AA 99 88 77 66 55 00 00 00 00 AES(MCPT): AB 89 DD E9 C4 55 C1 FE BE 7E E7 58 82 D4 8A D2</figDesc><table><row><cell cols="2">CIPHERTEXT: 88 B8 DF 06 28 FD 51 CC 31 E6 6E 57 0B 0F 77 74</cell></row><row><cell></cell><cell>C1 ED 54 D9 89 21 A7 0F BC EC 71 83 9B 0A C2</cell></row><row><cell cols="2">Vector #11: CWC-AES-192</cell></row><row><cell>AES KEY:</cell><cell>00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F</cell></row><row><cell></cell><cell>F0 E0 D0 C0 B0 A0 90 80</cell></row><row><cell cols="2">PLAINTEXT: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E</cell></row><row><cell cols="2">ASSOC DATA: 54 68 69 73 20 69 73 20 61 20 70 6C 61 69 6E 74</cell></row><row><cell></cell><cell>65 78 74 20 68 65 61 64 65 72 2E 00</cell></row><row><cell>NONCE:</cell><cell>FF EE DD CC BB AA 99 88 77 66 55</cell></row><row><cell>-</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_18"><head></head><label></label><figDesc>-HASH KEY: 4F A8 88 AF 06 83 60 0C AB 35 75 EF 0A E6 01 A5 HASH VALUE: 51 60 E7 81 DC 64 F9 CD 54 BA 02 40 A2 E8 EE 99 AES(HVAL): A0 30 58 13 22 B6 80 53 64 B0 3E 52 41 D2 2D 0A MAC CTR PT: 80 FF EE DD CC BB AA 99 88 77 66 55 00 00 00 00 AES(MCPT): C6 B6 F4 33 F9 12 39 4F 6A 8C B9 D3 F2 7B 0C 72 CIPHERTEXT: F0 DB A9 74 12 30 01 B0 E1 42 B7 58 87 C9 00 66 86 AC 20 DB A4 B9 1C 0E 3C 87 81 B3 A9 21 78</figDesc><table><row><cell cols="2">Vector #12: CWC-AES-256</cell></row><row><cell>AES KEY:</cell><cell>00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F</cell></row><row><cell></cell><cell>F0 E0 D0 C0 B0 A0 90 80 70 60 50 40 30 20 10 00</cell></row><row><cell cols="2">PLAINTEXT: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E</cell></row><row><cell cols="2">ASSOC DATA: 54 68 69 73 20 69 73 20 61 20 70 6C 61 69 6E 74</cell></row><row><cell></cell><cell>65 78 74 20 68 65 61 64 65 72 2E 00</cell></row><row><cell>NONCE:</cell><cell>FF EE DD CC BB AA 99 88 77 66 55</cell></row><row><cell>-</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_23"><head></head><label></label><figDesc>-HASH KEY: 34 AE 6A 6F E9 51 78 94 AC CC BB 9E BA E7 20 8C HASH VALUE: 05 EE B6 CB DF A6 E5 B8 4C 65 DD F4 8C C8 25 23 AES(HVAL): 62 E5 23 FE 48 8F BC 14 E3 77 15 6C 4D 0F D0 8B MAC CTR PT: 80 FF EE DD CC BB AA 99 88 77 66 55 00 00 00 00</figDesc><table><row><cell cols="2">AES(MCPT): AB 89 DD E9 C4 55 C1 FE BE 7E E7 58 82 D4 8A D2</cell></row><row><cell cols="2">CIPHERTEXT: 88 B8 DF 06 28 FD 51 CC 31 E6 6E 57 0B 0F 77 0F</cell></row><row><cell></cell><cell>48 5B 82 64 6E CF B9 F9 A0 B0 75 4F D5 94 36 5A</cell></row><row><cell></cell><cell>C9 6C FE 17 8C DA 7D EA 5D 09 F2 34 CF DB 5A 59</cell></row><row><cell cols="2">Vector #17: CWC-AES-192</cell></row><row><cell>AES KEY:</cell><cell>00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F</cell></row><row><cell></cell><cell>F0 E0 D0 C0 B0 A0 90 80</cell></row><row><cell cols="2">PLAINTEXT: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F</cell></row><row><cell></cell><cell>80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F</cell></row><row><cell cols="2">ASSOC DATA: 54 68 69 73 20 69 73 20 61 20 70 6C 61 69 6E 74</cell></row><row><cell></cell><cell>65 78 74 20 68 65 61 64 65 72 2E 00</cell></row><row><cell>NONCE:</cell><cell>FF EE DD CC BB AA 99 88 77 66 55</cell></row><row><cell>-</cell><cell></cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank Peter Gutmann, David McGrew, Fabian Monrose, Avi Rubin, Adam Stubblefield, and David Wagner for their comments. Additionally, we thank Brian Gladman for helping to validate our test vectors and for working with us to obtain timing information.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Intellectual property statement</head><p>The authors hereby explicitly release any intellectual property rights to the CWC mode into the public domain. The authors are not aware of any patent or patent application anywhere in the world that cover this mode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Summary of properties</head><p>In this appendix we summarize some of the properties of CWC. We include all of the properties listed in the submission guidelines on the NIST Modes of Operation website. We also discuss some additional properties that we feel are important.</p><p>Security function. CWC is a provably secure authenticated encryption with associated data (AEAD) mode. Informally, this means that the encapsulation algorithm, on input a pair of messages (A, M ) and some nonce N , encapsulates (A, M ) in a way that protects the privacy of M and the integrity of both A and M . Our formal security statements appear in Section 4 and the proofs appear in Appendix C.</p><p>Error propagation. Assuming that the underlying block cipher is a secure pseudorandom function or permutation, any attempt, by an adversary using reasonable resources, to forge a new ciphertext will, with very high probably, be detected. This follows from the fact that CWC is a provably-secure AEAD mode.</p><p>Synchronization. Synchronization is based on the nonce. As with other nonce-based AEAD modes, the nonce must either be sent with the ciphertext or the receiver must know how to derive the nonce on its own. Parallelizability. CWC is parallelizable. The amount of parallelism for the hashing portion can be determined by the implementor without affecting interoperability.</p><p>Keying material required. CWC is defined to be a single-key AEAD mode. However, CWC does internally use two keys (the main block cipher key and a hash key which is derived using the block cipher key). Implementors can decide whether to store the derived hash key in memory or whether to re-derive it as needed.</p><p>Counter/IV/nonce requirements. CWC uses a 11-octet nonce. CWC is provably secure as long as one does not query the encryption algorithm twice with the same nonce. Although it is possible to instantiate the generic CWC construction with other nonce lengths, for CWC the nonce size is fixed at 11-octets in order to minimize interoperability issues.</p><p>Memory requirements. The software memory requirements are basically those of the underlying block cipher. For example, fast AES in software requires 4K bytes of table, and about 200 bytes of expanded key material. In some situations, software implementations may precompute powers of the hash subkey.</p><p>Pre-processing capability. The underlying CTR mode keystream can be precomputed. The only block cipher input that cannot be precomputed is the output of CWC-HASH.</p><p>CWC can preprocess its associated data, thereby reducing computation time if the associated data remains static or changes only infrequently.</p><p>Message length requirements. The associated data and message can both be any string of octets with length at most 128 • (2 32 -1) bits. Because there does not appear to be a need to handle strings of arbitrary bit-length, CWC as currently specified cannot encapsulate arbitrary bit-length messages. (As discussed in Section 3, it is easy to modify CWC to handle arbitrary bit-length any hash function that hashes strings, it is trivial to construct a hash function that hashes pairs of strings (by encoding the pair of strings as a single string in some appropriate manner).</p><p>It is also worth commenting on the purpose of ctr0, ctr1, and ctr2. As shown in Construction C.1, these functions are used to derive the inputs to the construction's underlying function f . By requiring that none of the outputs collide (i.e., that the sets W, X, Y, Z in the definition are pairwise mutually exclusive), we ensure that the inputs to f for different purposes never collide. For example, the inputs to f used for counter mode encryption will always be different than the inputs to f when enciphering the output of H.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.3 The security of the general CWC construction</head><p>We now state the following results for all Construction C.1-style AEAD schemes. We shall prove Lemmas C. </p><p>Furthermore, the experiment for B A takes the same time as the experiment for A and, if A makes at most q -1 oracle queries and a total of at most µ bits of payload data (for both these q -1 oracle queries and the forgery attempt), then B A makes at most µ/L + 3q + k/L oracle queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma C.3 [Privacy of Construction C.1.] Let SE[F, HF] be as in Construction C.1. Then given a nonce-respecting ind$-cpa adversary A against SE[F, HF] one can construct a prf adversary B A against F such that</head><p>Adv priv SE[F,HF ] (A) ≤ Adv prf F (B A ) . Furthermore, the experiment for B A takes the same time as the experiment for A and, if A makes at most q oracle queries totaling at most µ bits of payload data, then B A makes at most µ/L + 3q + k/L oracle queries.</p><p>We interpret these lemmas as follows. Intuitively, the first lemma states that if F is a secure prf, if HF is -au where is not too large, and if t is not too small, then SE[F, HF] preserves integrity. We comment that most modern block ciphers (e.g., AES) are considered to be secure prps (and therefore also secure prfs up to a birthday term). We also comment that we can construct hash functions HF with provably small .</p><p>Intuitively, the second lemma states that if F is a secure prf, then SE[F, HF] will preserve privacy. We discuss the meaning of these types of proofs in more detail in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.4 Proof of Theorem 4.2 and Theorem 4.1</head><p>The security of the CWC construction from Section 3 follows from Lemmas C.2 and C.3 assuming that (1) CWC as described in Section 3 is really an instantiation of Construction C.1 and (2) that the hash function used in Section 3 is -au for some small . We begin by justifying the second bullet.</p><p>Lemma C.4 [CWC-HASH (Section 3) is -almost universal.] Consider the CWC-BC-tl construction from Section 3. Let HF = (K h , H) be the hash function function whose key generation <ref type="bibr" target="#b9">10</ref> Let SE[F, MA] be as in Construction C.9. Then given a nonce-respecting auth adversary B against SE[F, MA], we can construct a nonce-respecting forgery adversary</p><p>) . Furthermore the experiment for D B uses the same time as the experiment for B and if B makes q encryption oracle queries, then D B makes q tagging oracle queries.</p><p>To prove Proposition C.10, we use the approach in <ref type="bibr" target="#b3">[4]</ref> for analyzing Encrypt-then-Authenticate constructions. The only difference is that we consider MACs that also take nonces as input.</p><p>Combining these constructions. Let us now combine these constructions.</p><p>Construction C.11 [Combined CWC.] Let l, L, n, o, t, k be positive integers such that t ≤ L. (Further restrictions will be placed shortly.) Essentially, l is the length of the input to a prf (e.g., 128), L is the length of the output from the prf (e.g., 128), n is the length of the nonce (e.g., 88), o is the length of the offset (e.g., 32), t is the length of the desired tag (e.g., 64 or 128), k is the length of the hash function's keysize (e.g., 128).</p><p>Let F be a family of functions from {0, 1} l to {0, 1} L . Let HF = (K h , H) be a family of hash functions with HashSp HF = {0, 1} l and KeySp HF = {0, 1} k (and K h works by randomly selecting and returning an element from {0, 1} k with uniform probability). Let ctr1 : {0, 1} n × (Z 2 o -{0}) → {0, 1} l be an efficiently-computable injective function. Let extract : {0, 1} k/L •L → {0, 1} k be a function that takes as input a k/L • L-bit string and that outputs a k-bit string. We require that extract always pick the same k bits from the input string and always outputs those bits in the exact same order (e.g., extract returns the first k bits of its input).</p><p>Let SE[F, HF] = (K e , E, D) be an AEAD scheme built from function family F and hash function HF and using the above functions extract and ctr1. We assume that AdSp </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Keying hash functions for message authentication</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Koblitz</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1109</biblScope>
			<biblScope unit="page" from="1" to="15" />
			<date type="published" when="1996-08">Aug. 1996</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A concrete security treatment of symmetric encryption</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Desai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Jokipii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 38th FOCS</title>
		<meeting>of the 38th FOCS</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="394" to="403" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">XOR MACs: New methods for message authentication using finite pseudorandom functions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Guérin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Coppersmith</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">963</biblScope>
			<biblScope unit="page" from="15" to="28" />
			<date type="published" when="1995-08">Aug. 1995</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Authenticated encryption: Relations among notions and analysis of the generic composition paradigm</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Namprempre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1976</biblScope>
			<biblScope unit="page" from="531" to="545" />
			<date type="published" when="2000-12">2000. Dec. 2000</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The EAX mode of operation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 2004, LNCS</title>
		<editor>
			<persName><forename type="first">W</forename><surname>Meier</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Roy</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Floating-point arithmetic and message authentication</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bernstein</surname></persName>
		</author>
		<ptr target="http://cr.yp.to/papers.html#hash127" />
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A block-cipher mode of operation for parallelizable message authentication</title>
		<author>
			<persName><forename type="first">J</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Knudsen</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2332</biblScope>
			<date type="published" when="2002">2002. 2002</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">The Design of Rijndael</title>
		<author>
			<persName><forename type="first">J</forename><surname>Daemen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Rijmen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">AES and combined encryption/authentication modes</title>
		<author>
			<persName><forename type="first">B</forename><surname>Gladman</surname></persName>
		</author>
		<ptr target="http://fp.gladman.plus.com/AES/index.htm" />
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Fast encryption and authentication: XCBC encryption and XECB authentication modes</title>
		<author>
			<persName><forename type="first">V</forename><surname>Gligor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Donescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Matsui</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2001">2001. 2001</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Perspective texture mapping, part V: It&apos;s about time</title>
		<author>
			<persName><forename type="first">C</forename><surname>Hecker</surname></persName>
		</author>
		<ptr target="http://www.d6.com/users/checker/pdfs/gdmtex5.pdf" />
	</analytic>
	<monogr>
		<title level="j">Game Developer</title>
		<imprint>
			<date type="published" when="1996-04">Apr. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Encryption modes with almost free message integrity</title>
		<author>
			<persName><forename type="first">C</forename><surname>Jutla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Pfitzmann</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2045</biblScope>
			<biblScope unit="page" from="529" to="544" />
			<date type="published" when="2001-05">2001. May 2001</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Unforgeable encryption and chosen ciphertext secure modes of operation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Schneier</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1978</biblScope>
			<biblScope unit="page" from="284" to="299" />
			<date type="published" when="2000-04">2000. Apr. 2000</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">LFSR-based hashing and authentication</title>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">Y</forename><surname>Desmedt</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">94</biblScope>
			<date type="published" when="1994-08">Aug. 1994</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The order of encryption and authentication for protecting communications (or: How secure is SSL?)</title>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2139</biblScope>
			<biblScope unit="page" from="310" to="331" />
			<date type="published" when="2001-08">2001. Aug. 2001</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">AES/Rijndael: speed</title>
		<author>
			<persName><forename type="first">H</forename><surname>Lipmaa</surname></persName>
		</author>
		<ptr target="http://www.tcs.hut.fi/~helger/aes/rijndael.html" />
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">How to construct pseudorandom permutations from pseudorandom functions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rackoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Computation</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1988-04">Apr. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Integer counter mode</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mcgrew</surname></persName>
		</author>
		<ptr target="http://www.ietf.org/internet-drafts/draft-irtf-cfrg-icm-01.txt" />
		<imprint>
			<date type="published" when="2002-10">Oct. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">The truncated multi-modular hash function (TMMH), version two</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mcgrew</surname></persName>
		</author>
		<ptr target="http://www.ietf.org/internet-drafts/draft-irtf-cfrg-tmmh-00.txt" />
		<imprint>
			<date type="published" when="2002-10">Oct. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">The universal security transform</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mcgrew</surname></persName>
		</author>
		<ptr target="http://www.ietf.org/internet-drafts/draft-irtf-cfrg-ust-01.txt" />
		<imprint>
			<date type="published" when="2002-10">Oct. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<author>
			<persName><forename type="first">W</forename><surname>Nevelsteen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT &apos;99</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Stern</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1592</biblScope>
			<biblScope unit="page" from="24" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Bucket hashing and its applications to fast message authentication</title>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptology</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="91" to="115" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Authenticated encryption with associated data</title>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 9th CCS</title>
		<meeting>of the 9th CCS</meeting>
		<imprint>
			<date type="published" when="2002-11">Nov. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">OCB: A block-cipher mode of operation for efficient authenticated encryption</title>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Krovetz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 8th CCS</title>
		<meeting>of the 8th CCS</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="196" to="205" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">A critique of CCM</title>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2003/070/" />
		<imprint>
			<date type="published" when="2003-04">Apr. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">On fast and provably secure message authentication based on universal hashing</title>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Koblitz</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1109</biblScope>
			<biblScope unit="page" from="313" to="328" />
			<date type="published" when="1996-08">Aug. 1996</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Universal hashing and authentication codes</title>
		<author>
			<persName><forename type="first">D</forename><surname>Stinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Designs, Codes and Cryptography</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="369" to="380" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">New hash functions and their use in authentication and set equality</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wegman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Carter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="265" to="279" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Counter with CBC-MAC (CCM)</title>
		<author>
			<persName><forename type="first">D</forename><surname>Whiting</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ferguson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Housley</surname></persName>
		</author>
		<ptr target="http://csrc.nist.gov/CryptoToolkit/modes/proposedmodes/" />
	</analytic>
	<monogr>
		<title level="m">Submission to NIST</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
