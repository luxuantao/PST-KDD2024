<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">FleXOR: Flexible Garbling for XOR Gates That Beats Free-XOR</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Vladimir</forename><surname>Kolesnikov</surname></persName>
							<email>kolesnikov@research.bell-labs.com</email>
							<affiliation key="aff0">
								<orgName type="institution">Bell Labs</orgName>
								<address>
									<settlement>Murray Hill</settlement>
									<region>NJ</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Payman</forename><surname>Mohassel</surname></persName>
							<email>pmohasse@cpsc.ucalgary.ca</email>
							<affiliation key="aff1">
								<orgName type="institution">University of Calgary</orgName>
								<address>
									<settlement>Calgary</settlement>
									<region>AB</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mike</forename><surname>Rosulek</surname></persName>
							<email>rosulekm@eecs.oregonstate.edu</email>
							<affiliation key="aff2">
								<orgName type="institution">Oregon State University</orgName>
								<address>
									<settlement>Corvallis</settlement>
									<region>OR</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">FleXOR: Flexible Garbling for XOR Gates That Beats Free-XOR</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">92118C0124E7228E6EEE7C16897DCD8D</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:14+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Most implementations of Yao's garbled circuit approach for 2-party secure computation use the free-XOR optimization of Kolesnikov  &amp; Schneider (ICALP 2008). We introduce an alternative technique called flexible-XOR (fleXOR) that generalizes free-XOR and offers several advantages. First, fleXOR can be instantiated under a weaker hardness assumption on the underlying cipher/hash function (related-key security only, compared to related-key and circular security required for free-XOR) while maintaining most of the performance improvements that free-XOR offers. Alternatively, even though XOR gates are not always "free" in our approach, we show that the other (non-XOR) gates can be optimized more heavily than what is possible when using free-XOR. For many circuits of cryptographic interest, this can yield a significantly (over 30%) smaller garbled circuit than any other known techniques (including free-XOR) or their combinations.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>This work proposes efficiency improvements of two-party Secure Function Evaluation (SFE). SFE allows two parties to evaluate any function on their respective inputs x and y, while maintaining privacy of both x and y. SFE of some useful functions today is borderline practical, and first uses of secure computation begin to crop up in industry. The main obstacle in SFE's wider adoption is the cost. Indeed, SFE of most of today's functions of interest is either completely out of reach of practicality, or carries costs sufficient to deter would-be adopters, who instead choose stronger trust models, entice users to give up their privacy with incentives, or use similar crypto-workarounds. We believe that truly practical efficiency is required for SFE to see use in real-life applications.</p><p>Our results and motivation. We improve both the required assumptions and efficiency, albeit not both simultaneously, of a commonly used SFE tool, Garbled Circuit (GC).</p><p>On the practical side, our construction results in savings of GC size of over 30% (in garbled circuits typically analyzed in the literature) as compared to the state-of-the-art GC variant using the free-XOR technique of Kolesnikov &amp; Schneider <ref type="bibr" target="#b16">[15]</ref>. For a fundamental protocol, which has been studied and optimized for over three decades, this is a significant improvement. We emphasize that the fleXOR approach is more general than the specific instantiations we show, and we expect better optimizations to be discovered later on. At the same time, we prove that computing optimal instantiations (i.e. those minimizing the GC size) is NP-complete.</p><p>On the theoretical side, we aim to remove the Random Oracle (RO) requirement of the free-XOR technique without sacrificing efficiency. We weaken the RO assumption to that of correlation-robustness (CR) while retaining most of the performance improvements associated with free-XOR (only 10 -20% loss for analyzed circuits). <ref type="foot" target="#foot_0">1</ref> This choice is natural, motivated by several pragmatic considerations:</p><p>(1) Perhaps most importantly, today an efficient GC protocol will almost certainly use the OT extension of Ishai et al. <ref type="bibr" target="#b11">[11]</ref>. Indeed, the orders of magnitude efficiency improvement brought by the IKNP OT extension transformed the field of secure computation. The OT extension, as well as its follow-up constructions, requires CR hash functions. Thus, our choice allows to avoid the introduction of any additional assumptions in most cases.</p><p>(2) Another important factor is the degree of analysis of the candidate implementations of the employed function. Cryptanalysts study at length related-key attacks for real-world block ciphers/primitives, but, to our knowledge, key circularity attacks are less researched.</p><p>Further, the question of understanding and reducing/eliminating the RO assumption associated with free-XOR is motivated by recent work. Choi et al. <ref type="bibr" target="#b4">[5]</ref> shows that circular-correlation robustness is a sufficient condition for free-XOR. It also presents a black-box separation which demonstrates that CR is strictly weaker than circular-correlation robustness (which, in turn, is weaker than RO). Choi et al. <ref type="bibr" target="#b4">[5]</ref> explicitly leave open the question: "is there a garbled-circuit variant where certain gates can be evaluated for free, without relying on assumptions beyond CPA-secure encryption?" Addressing this question, Applebaum <ref type="bibr" target="#b0">[1]</ref> showed that free-XOR can be realized in the standard model under the learning parity with noise (LPN) assumption. While novel at the fundamental level, the efficiency of the protocol of <ref type="bibr" target="#b0">[1]</ref> is far from practical.</p><p>Our work raises and addresses related questions: Can the efficiency improvement of free XOR be extended? Can it be achieved under weaker assumptions? Our metric: computation vs communication. In this work we focus on measuring performance by the size of the GC, a very clean and expressive metric. Since the associated computations are fast, we believe that in many (but not all, of course) practical scenarios communication complexity of our constructions will correlate with their total execution time. Indeed, in this work, we use aggressive (2-row) garbled row reduction (GRR2) due to Pinkas et al. <ref type="bibr" target="#b20">[19]</ref>, which involves computing polynomial interpolation. While more expensive than the standard PRF or hash function garbling, GRR2 nevertheless is a very efficient technique as evidenced by the performance experiments in <ref type="bibr" target="#b20">[19]</ref>. GRR2 approach (denoted PRF-SS in the performance tables in <ref type="bibr" target="#b20">[19]</ref>) is about 1x-3x times slower than the fastest experiment. However, note that a very fast 1Gbps network and a slow 2-core computer was used in <ref type="bibr" target="#b20">[19]</ref>. Today, 1Gbps channel is still state-of-the-art, but computational power of a typical machine grew by factor of 4-6, mainly due to increased number of cores. Thus, we expect that today, the bottleneck of the <ref type="bibr" target="#b20">[19]</ref> experiments would be in the network traffic, and not in the CPU load. This is even more likely to be so in the future, as historical hardware trends indicate faster advances in computational power than in network speeds.</p><p>At the same time, of course, specific use cases may dictate an extremely lowpower CPU with an available fast network, which would imply different cost structure of our protocols. However, as argued above, today and in the expected future, communication performance is a good metric for our protocols.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Overview of Our Approach</head><p>In a garbled circuit, each wire receives a pair (A, B) of (bitstring) labels which conceptually encode true and false. Let us call A ⊕ B the offset of the wire. The idea behind the free XOR technique is to ensure that all wires have the same (secret) offset. Then the garbled gate can be evaluated by simply XOR-ing the wire labels.</p><p>FleXOR. With the idea of "wire offsets" in mind, consider the case where an XOR gate's input wires do not have the same wire offset. Intuitively, the free-XOR approach can be applied if we "translate" the incoming wire labels to bring them to the desired output offset. Namely, let the two input wires have wire labels (A, A ⊕ Δ 1 ) and (B, B ⊕ Δ 2 ), and suppose we would like the output wire labels to have offset Δ 3 . We then select random "translated" wire values A, B. Let E be gate encryption function. Then we can garble this XOR gate with the following ciphertexts:</p><formula xml:id="formula_0">E A ( A); E A⊕Δ1 ( A ⊕ Δ 3 ); E B ( B); E B⊕Δ2 ( B ⊕ Δ 3 );</formula><p>Now, the first two ciphertexts allow the evaluator to translate wire labels (A, A⊕ Δ 1 ) with offset Δ 1 into new ones ( A, A ⊕ Δ 3 ) of the desired offset Δ 3 . Similarly the last two ciphertexts permit (B, B ⊕ Δ 2 ) ( B, B ⊕ Δ 3 ). Now, these "translated" wire labels share the same offset Δ 3 and so the output labels ( A ⊕ B, A ⊕ B ⊕ Δ 3 ) can be obtained simply by XORing the "translated" labels.</p><p>So far we did not save anything: this method requires 4 ciphertexts to garble an XOR gate. However, we can reduce this cost with two simple observations:</p><p>-If we can arrange the wire label assignments so that Δ 1 = Δ 3 , then the first two ciphertexts are not needed at all (the labels on this wire already have the correct offset). If Δ 2 = Δ 3 , then the second two ciphertexts are not needed. Indeed, Δ 1 = Δ 2 = Δ 3 , corresponds to the free-XOR case. -Next, we can apply a standard garbled row-reduction technique (GRR)</p><p>of <ref type="bibr" target="#b20">[19]</ref>. The idea is that ciphertexts 1 &amp; 3 above can always be set to the string 0 λ , implicitly setting A = D A (0 λ ) and B = D B (0 λ ), where D is the gate decryption function. Hence, ciphertexts 1 &amp; 3 never need to be sent.</p><p>As a result, we obtain a method to garble XOR gates that requires 0, 1, or at most 2 ciphertexts total, depending on how many of {Δ 1 , Δ 2 , Δ 3 } are unique. <ref type="foot" target="#foot_1">2</ref>We call this method flexible-XOR, or fleXOR for short.</p><p>FleXOR application. We show how the fleXOR tool can be used to achieve the two goals motivating this work.</p><p>Consider grouping circuit wires into equivalence classes, where wires in the same equivalence class have the same offset. Since the arrangement of equivalence classes affects the cost of garbling each XOR gate, we are interested in assignments that minimize the total cost for all XOR gates.</p><p>If minimizing cost of XOR gates was the only constraint, then we could simply place all wires into a single equivalence class, and our construction in fact collapses to standard free-XOR. However, we consider additional constraints in class assignment, which result in the following improvements over the state-ofthe-art GC (with free-XOR + GRR):</p><p>-Performance improvement. Recall, row reduction <ref type="bibr" target="#b20">[19]</ref> is a technique for "compressing" a standard garbled gate from a size of 4 ciphertexts down to either 3 or 2. Free-XOR is compatible with the milder 3-ciphertext row reduction (which we call GRR3), but not with the more aggressive 2-ciphertext variant (GRR2). The problem is that gates garbled under GRR2 will have output wire labels with an unpredictable offset -it is not possible to force them to use the global wire offset Δ used by free-XOR. In contrast, our fleXOR generalization does not force any specific wires to share the same offset hence there is no inherent incompatibility with using GRR2. Nevertheless it is necessary to put some constraints on the class assignment (a "safety" property that we define). We propose a heuristic algorithm for obtaining a safe assignment, and use it to obtain significant reduction in the GC size, in the experiments we run. -Weakened assumptions. In the free-XOR world, the non-XOR gates are garbled by encrypting plaintexts X, X ⊕Δ using combinations of keys Y, Y ⊕ Δ. The appearance of a secret value Δ as both a key and plaintext requires a circularity assumption on the gate-level cipher <ref type="bibr" target="#b4">[5]</ref>. With an appropriate constraint (i.e. monotonicity property) on wire equivalence classes, we can ensure that wire labels from the class indexed i are used as keys to encrypt wire labels only from a class indexed j &gt; i. Under this additional constraint, our construction can be instantiated under a significantly weaker (related-key only, not circular) hardness assumption than free-XOR. At the same time, our experiments show only mild performance loss as compared to state-ofthe-art algorithms needing circularity assumption.</p><p>Recall that fleXOR easily collapses to free-XOR when grouping all wires in the same class. We view this as an important feature of our scheme. In terms of size of garbled circuits, free-XOR performs better in some settings while the new fleXOR method performs better in others. By adopting and implementing fleXOR, one can always have available both options, and seamlessly choose the best method via appropriate choice of wire equivalence classes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Organization of Paper</head><p>After discussing related work (Section 1.3) and preliminaries (Section 2), we set up the required technical details. In Section 3, we formalize the notion of gate cipher and show that it can be instantiated with RO and correlation-robust (CR) functions. In Section 4, we explicitly write our circuit garbling scheme in the recent "garbling schemes" convention <ref type="bibr" target="#b2">[3]</ref>, and provide a proof of security with a concrete reduction to the security of the underlying gate cipher. In Section 5 we explicitly integrate garbled row reductions from <ref type="bibr" target="#b20">[19]</ref> into the garbling protocols and prove security via concrete reductions.</p><p>Once this set up is in place, in Section 6 we present two algorithms for assigning wire classes. One, achieving what we call monotone ordering, allows us to avoid circularity in key applications. The second, more performance-oriented, achieving what we call safe ordering, allows our garbling protocols to generate GC up to and over 30% smaller than currently best known.</p><p>In Section 7, we provide detailed performance comparison of both of our heuristic algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Related work</head><p>Garbled circuit is a general and an extremely efficient technique of secure computation, requiring only one round of interaction in the semi-honest model. Due to this generality and practicality, GC and related protocols have been receiving a lot of attention in the literature.</p><p>The basic GC is so simple and minimal that it has proven hard to improve. Most of the GC research considers its application to solving problems at hand, such as set intersection, auction design, etc. A much smaller number of papers deal with technical improvements to GC-based two-party SFE, such as OT extension <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b15">14]</ref> or cut-and-choose improvements for malicious case <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b17">16,</ref><ref type="bibr" target="#b18">17]</ref>.</p><p>Our work belongs to a third category, aiming to improve and understand the garbling scheme itself. Since the original paper of Yao over 30 years ago, only a few works fit into this category. Beaver et al. <ref type="bibr" target="#b1">[2]</ref> introduced the pointand-permute idea, which allows the evaluator to decrypt just a single ciphertext in the garbled gate. Naor et al. <ref type="bibr" target="#b19">[18]</ref> introduced 3-row garbled row reduction optimization. Kolesnikov and Schneider <ref type="bibr" target="#b16">[15]</ref> introduced the popular free-XOR technique allowing XOR gates to be evaluated without cost. Pinkas et al. <ref type="bibr" target="#b20">[19]</ref> introduced 2-row GRR and observed that GRR3 is compatible with free-XOR. Choi et al. and Appelbaum helped clarify the underlying assumptions for free-XOR, now seen as a natural part of GC. Choi et al. <ref type="bibr" target="#b4">[5]</ref> weakened the free-XOR assumption, by defining a sufficient gate cipher property, circular security. Applebaum <ref type="bibr" target="#b0">[1]</ref> showed how to implement free-XOR in the standard model (using the LPN assumption, and hence not competitive with today's standard GC).</p><p>In related but incomparable work, Kolesnikov and Kumaresan <ref type="bibr" target="#b14">[13]</ref> obtained approximately 3x factor performance improvement over state-of-the-art GC by evaluating slices of information-theoretic GC of Kolesnikov <ref type="bibr" target="#b12">[12]</ref>. Their protocol has linear number of rounds and is not secure against malicious evaluator. We also mention, but do not discuss in detail multi-party SFE such as <ref type="bibr" target="#b9">[9,</ref><ref type="bibr" target="#b8">8,</ref><ref type="bibr" target="#b6">6]</ref>.</p><p>Bellare et al. <ref type="bibr" target="#b2">[3]</ref> introduced the garbling schemes abstraction, which we use here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Code-Based Games</head><p>We use the convention of code-based games <ref type="bibr" target="#b3">[4]</ref>: A game G starts by executing the Initialize procedure. Then the adversary A is invoked and allowed to query the procedures that comprise the game. When the adversary halts, the Finalize procedure is called with the output of the adversary. The output of the Finalize procedure is taken to be the outcome of the game, whose random variable we denote by G A (λ), where λ is the global security parameter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Garbling Schemes</head><p>Bellare, Hoang, and Rogaway <ref type="bibr" target="#b2">[3]</ref> introduce the notion of a garbling scheme as a cryptographic primitive. We refer the reader to their work for a complete treatment and give a brief summary here. <ref type="foot" target="#foot_2">3</ref> A garbling scheme consists of the following algorithms: Garble takes a circuit f as input and outputs (F, e, d) where F is a garbled circuit, e is encoding information, and d is decoding information. Encode takes an input x and encoding information e and outputs a garbled input X. Eval takes a garbled circuit F and garbled input X and outputs a garbled output Y . Finally, Decode takes a garbled output Y and decoding information d and outputs a plain circuit-output (or an error ⊥).</p><p>Our work uses the prv.sim (privacy), obv.sim (obliviousness), and aut (authenticity) security definitions from <ref type="bibr" target="#b2">[3]</ref>, which we state below. In the prv.sim and obv.sim games, the Initialize procedure chooses β ← {0, 1}, and the Finalize(β ) procedure returns β ? = β . In all three games, the adversary can make a single call to the Garble procedure, which is defined below. Additionally, the function Φ denotes the information about the circuit that is allowed to be leaked by the garbling scheme; the function S is a simulator, and G denotes a garbling scheme.</p><p>prv.sim G,Φ,S :</p><formula xml:id="formula_1">Garble(f, x): if β = 0 (F, e, d) ← Garble(1 λ , f) X ← Encode(e, x) else (F, X, d) ← S(1 λ , f(x), Φ(f )) return (F, X, d) obv.sim G,Φ,S : Garble(f, x): if β = 0 (F, e, d) ← Garble(1 λ , f) X ← Encode(e, x) else (F, X) ← S(1 λ , Φ(f )) return (F, X) aut G : Garble(f, x): (F, e, d) ← Garble(1 λ , f) X ← Encode(e, x) return (F, X) Finalize(Y ): return Decode(d, Y ) ∈ {⊥, f(x)}</formula><p>We then define the advantage of the adversary in the three security games:</p><formula xml:id="formula_2">Adv prv.sim G,Φ,S (A, λ) := Pr[prv.sim A G,Φ,S (λ) = 1] - 1 2 ; Adv obv.sim G,Φ,S (A, λ) := Pr[obv.sim A G,Φ,S (λ) = 1] - 1 2 . Adv aut G (A, λ) := Pr[aut A G (λ) = 1];</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Our Gate-Level Cipher Abstraction</head><p>Yao's technique conceptually garbles each gate with "boxes locked via two keys."</p><p>We adopt the approach used by <ref type="bibr" target="#b20">[19]</ref> and elsewhere, in which gates are garbled as H(w i w j T ) ⊕ w k , where w i , w j are wire labels on input wires, T is a tweak/nonce, w k is a wire label of an output wire, and H is a key-derivation function. We now describe more specifically what property is needed of H.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Definitions</head><p>We define two security games formally. They are parameterized by a KDF H : {0, 1} * → {0, 1} λ+1 . Game kdf.rk H,n includes the boxed statement, and kdf.circ H,n excludes the boxed statement.</p><p>Initialize:</p><formula xml:id="formula_3">Δ 1 , . . . , Δ n ← {0, 1} λ Δ 0 := Δ ∞ := 0 λ β ← {0, 1} Finalize(β ): return β ? = β Fn(X, Y, a, b, c, T ): return ⊥ if T previously used in any Fn query or {a, b} ⊆ {0, ∞} or c ≤ max{a, b} if β = 0 then Z := H(X ⊕ Δ a , Y ⊕ Δ b , T ) ⊕ (Δ c 0) else Z ← {0, 1} λ+1 return Z</formula><p>Briefly, the games proceed as follows. The challenger generates n random (secret) wire offsets {Δ i } i , where n is a parameter of the game. The values Δ 0 := Δ ∞ := 0 λ are set as a convenience.</p><p>The adversary can then make queries of the form In the kdf.rk variant of the game, there is an additional "monotonicity" restriction, that c &gt; max{a, b}, which prevents the adversary from invoking "key cycles" among the secret Δ i values. It is in this setting that having two values Δ 0 and Δ ∞ is convenient. A query of the form H(X, Y ⊕ Δ i , T ) can be made via a = 0, b = i, c = ∞, so that the monotonicity condition is satisfied (c = 0, for example, would break monotonicity). Definition 1. Let H : {0, 1} * → {0, 1} λ+1 be a KDF, A be a PPT adversary, and the games kdf.rk H,n , kdf.circ H,n be defined as above. We then define the advantage of the adversary in these games as:</p><formula xml:id="formula_4">H(X ⊕ Δ a , Y ⊕ Δ b , T ) ⊕ Δ c , provided that at least one of {Δ a , Δ b } is unknown (i.</formula><formula xml:id="formula_5">Adv kdf.rk H,n (A, λ) := Pr[kdf.rk A H,n (λ) = 1] - 1 2 ; Adv kdf.circ H,n (A, λ) := Pr[kdf.circ A H,n (λ) = 1] - 1<label>2</label></formula><p>Single-key vs. Dual-key. In our main construction, we garble XOR gates using only one key (wire label) and non-XOR gates using two keys (wire labels). We let H 2 be a synonym for H, and define shorthand:</p><formula xml:id="formula_6">H 1 (K, T ) def = H 2 (K, K, T )[1..λ]</formula><p>We take only the first λ bits of the output for H 1 because we do not need the 1 extra bit in our construction when using H 1 (the extra bit is used for the permute bit, which is easier to handle for XOR gates).</p><p>Since H 1 takes a shorter input than H 2 , it is conceivable that H 1 could be implemented more efficiently than H 2 in practice (e.g., invoking a hash function with a smaller input and hence fewer iterations). However, this kind of optimization not the focus of our work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Instantiation from a Random Oracle</head><p>Lemma 1. Let H : {0, 1} * → {0, 1} λ+1 be a random oracle. Then for all A, we have Adv kdf.circ H,n (A, λ) ≤ 16n(q A + q C ) 2 /2 λ , where q A , q C are the number of queries made to the random oracle (locally) and to the Fn procedure, respectively, by A (and n is the parameter of the security game).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Instantiation from Correlation-Robustness</head><p>The free-XOR approach was formally proven secure in the RO model, and believed secure under some (unspecified) variant of correlation-robustness <ref type="bibr" target="#b11">[11]</ref>. Choi et al <ref type="bibr" target="#b4">[5]</ref> showed that the most natural variant of correlation-robustness (called 2-correlation-robust) was in fact insufficient for free-XOR. Below we have translated their definition to the framework of code-based games. We then show that 2-correlation-robustness is sufficient for kdf.rk security.</p><p>Definition 2 (adapted from <ref type="bibr" target="#b4">[5]</ref>). Let H : {0, 1} * → {0, 1} λ+1 be a hash function. <ref type="foot" target="#foot_3">4</ref> Define Adv 2corr</p><formula xml:id="formula_7">H (A, λ) := | Pr[2corr A H (λ) = 1] -1 2 |</formula><p>, where 2corr H is the game defined as follows:</p><formula xml:id="formula_8">Initialize: Δ ← {0, 1} λ β ← {0, 1} Finalize(β ): return β ? = β Fn(X, Y, T ): return ⊥ if this query previously made if β = 0 then Z 1 := H(X ⊕ Δ, Y ⊕ Δ, T ) Z 2 := H(X ⊕ Δ, Y, T ) Z 3 := H(X, Y ⊕ Δ, T ) else Z 1 , Z 2 , Z 3 ← {0, 1} λ return Z 1 , Z 2 , Z 3 Lemma 2. For all probabilistic polynomial-time A, we have Adv kdf.rk Σ,n (A, λ) ≤ n • Adv 2corr R (A , λ)</formula><p>, where A has comparable runtime to A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Baseline Construction</head><p>We now present our "basic" fleXOR garbling scheme. It requires some auxiliary information about the circuit, defined below: </p><formula xml:id="formula_9">(i) = L(k): w 0 i ← {0, 1} λ ; w 1 i := w 0 i ⊕ Δ L(k) for b ∈ {0, 1}: c0,b := H 1 (w b i , g 0 b) ⊕ w b i else for b ∈ {0, 1}: w b i := w b i ; c0,b := ⊥ if L(j) = L(k): w 0 j ← {0, 1} λ ; w 1 j := w 0 j ⊕ Δ L(k) for b ∈ {0, 1}: c1,b := H 1 (w b j , g 1 b) ⊕ w b j else for b ∈ {0, 1}: w b j := w b j ; c1,b := ⊥ w 0 k := w 0 i ⊕ w 0 j ; w 1 k := w 1 i ⊕ w 0 j ; bk := bi ⊕ bj else g computes logic G : {0, 1} 2 → {0, 1}: bk ← {0, 1} w 0 k ← {0, 1} λ ; w 1 k := w 0 k ⊕ Δ L(k) for a, b ∈ {0, 1} 2 : v := bk ⊕ G(a ⊕ bi, b ⊕ bj ) ca,b = H 2 (w a i , w b j , g a b) ⊕ w v k v F [g] := (c00, c01, c10, c11)</formula><p>for each output bit i corresponding to wire j of C:</p><formula xml:id="formula_10">for v ∈ {0, 1}: d[i, v] := H 1 (w v⊕b j j , out j v) return (F, e, d)</formula><p>Encode(e, x) : for i = 1 to |x|:</p><formula xml:id="formula_11">X[i] := e[i, xi] return X Eval(F, X) : for each input wire i in C: w * i b * i ← X[i]</formula><p>for each gate g in C, in topological order: let i, j denote g's input wires let k denote g's output wire parse F [g] as (c00, c01, c10, c11) if g is an XOR gate:</p><formula xml:id="formula_12">if c01 = ⊥ then w * i := w * i else w * i := H 1 (w * i , g 0 b * i ) ⊕ c 0,b * i if c11 = ⊥ then w * j := w * j else w * j := H 1 (w * j , g 1 b * j ) ⊕ c 1,b * j w * k := w * i ⊕ w * j ; b * k := b * i ⊕ b * j else: w * k b * k := H 2 (w * i , w * j , g b * i b * j ) ⊕ c b * i ,b * j</formula><p>for each output bit i in C: let j be the corresponding wire 1. for each XOR gate, with input wires i &amp; j and output wire k: L(k) ≥ max{L(i), L(j)}, and 2. for each non-XOR gate, with input wires i &amp; j and output wire k: L(k) &gt; max{L(i), L(j)}.</p><formula xml:id="formula_13">Y [i] := H 1 (w * j , out j b * j ) return Y Decode(Y, d) : for i = 1 to Y.len: if Y [i] = d[i, 0] then yi = 0 elsif Y [i] = d[i, 1] then yi = 1 else return ⊥ return y</formula><p>We now give the complete description of our garbling scheme. Following <ref type="bibr" target="#b2">[3]</ref>, the scheme consists of 4 algorithms: Garble, Encode, Eval, Decode. We make one syntactic change, and allow Garble to accept as input auxiliary information L, which is a wire ordering of the given circuit.</p><p>The scheme is described formally in Figure <ref type="figure" target="#fig_1">1</ref>. It follows the typical Yao approach for garbling a circuit. Briefly, for each wire i, the garbler chooses two wire labels w 0 i , w 1 i such that w 0 i ⊕ w 1 i = Δ L(i) . We use the point-and-permute bit optimization of <ref type="bibr" target="#b19">[18]</ref>, where a permute bit b i is chosen so that w bi i encodes false on wire i, and w 1⊕bi i encodes true. Non-XOR gates are garbled in the usual way.</p><p>XOR gates use the approach described in the introduction. Namely, suppose an XOR gate has input wires i, j and output wire k. If L(i) = L(k), then no action is required for wire i in this gate (and no ciphertexts are included in the garbled circuit). Otherwise, we choose "adjusted" wire labels w 0 i , w 1 i whose offset is the target value Δ L(k) and provide two ciphertexts that allow the evaluator to obtain w b i from w b i . The same logic applies for input wire j, and finally a "free XOR" is performed on these adjusted wire labels. <ref type="figure" target="#fig_1">1</ref>), where H is a KDF. Let Φ denote the side information function that leaks the circuit topology, distinction between XOR vs non-XOR gates (but not distinctions among non-XOR gates), and the wire ordering function L used. Then, for all probabilistic polynomial-time A, there exists a polynomial-time simulator S such that:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1. Let G[H] denote our garbling scheme (Figure</head><formula xml:id="formula_14">Adv prv.sim G[H],Φ,S (A, λ) ≤ Adv kdf.circ H,|L| (A , λ)</formula><p>where A has runtime essentially the same as A. Furthermore, when the wire ordering function L is monotone, we have:</p><formula xml:id="formula_15">Adv prv.sim G[H],Φ,S (A, λ) ≤ Adv kdf.rk H,|L| (A , λ)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Incorporating Row Reductions</head><p>Row-reduction optimizations were introduced by Naor et al. <ref type="bibr" target="#b19">[18]</ref> and later formalized and extended by Pinkas et al. <ref type="bibr" target="#b20">[19]</ref>. They describe two flavors of row reduction, which we discuss and adapt to our fleXOR technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Optimization 1: Mild Row Reduction</head><p>In the first variant of row reduction, Naor et al. describe how to reduce standard 4-ciphertext garbled gates to 3 ciphertexts. Conceptually, this is done by fixing one of the ciphertexts to be the all-zeroes string. The idea is that if, say, c 00 is known to always consist of all zeroes, then it does not actually need to be included in the garbled output. For example, when garbling a non-XOR gate we see that ciphertext c 00 will be zero if the appopriate output wire label (concatenated with its permute bit) is chosen to be H 2 (w 0 i , w 0 j , g 00), which is the value that would be used to mask that wire label.</p><p>Hence, instead of choosing wire labels and permute bits uniformly, we choose one wire label to be an output of the KDF H and set the other label so that the two labels have the desired offset. We can use this idea with our XOR gates as well, following the ideas described in the introduction. Recall that to garble an XOR gate, we choose random "adjusted" wire labels for each input wire (whose offset requires adjusting). Instead of choosing these adjusted wire labels uniformly, we choose them to be the appropriate output of the KDF.</p><p>The formal description of this optimization is given in the full version. When garbling XOR gates, the ciphertexts c 00 , c 10 are always empty (implicitly set to all zeroes). Hence, XOR gates require 0, 1, or 2 ciphertexts. For non-XOR gates, the ciphertext c 00 is always empty (implicitly set to all zeroes), so these gates require 3 ciphertexts.</p><p>That this optimization requires no additional properties of the wire ordering, and it achieves essentially identical security to our baseline construction:</p><p>Theorem 2. Let G 1 [H] denote our "optimization #1" garbling scheme described above. Let Φ be as in Theorem 1. Then, for all probabilistic polynomialtime A, there exists a polynomial-time simulator S such that:</p><formula xml:id="formula_16">Adv prv.sim G 1 [H],Φ,S (A, λ) ≤ Adv kdf.circ H,|L| (A , λ)</formula><p>where A has runtime essentially the same as A. Furthermore, when the wire ordering function L is monotone, we have:</p><formula xml:id="formula_17">Adv prv.sim G 1 [H],Φ,S (A, λ) ≤ Adv kdf.rk H,|L| (A , λ)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Optimization 2: Aggressive Row Reduction</head><p>The second variant of row reduction reduces each garbled gate from 4 to 2 ciphertexts. Here we consider applying this optimization to the non-XOR gates in our scheme. This optimization has the effect of setting both output wire labels (and hence, their offset) implicitly. Superficially, this seems at odds with our approach, in which we always choose wire labels to have some desired offset. However, suppose that g is a non-XOR gate with output wire k. If we process this gate before any other wire i with L(i) = L(k), then we can indeed set the offset Δ L(k) implicitly based on the result of the row-reduction applied to this gate. If we process the gates in a topological order, one can capture this property by requiring that L(k) &gt; L(j) for every wire j that influences k (i.e. j has to be processed before k). We will also require that no other non-XOR gate in the circuit has output wire k with L(k) = L(k ), though XOR gates can safely have this property.</p><p>The necessary properties on the wire ordering are summarized in the following definition: Definition 4. We say that L is safe if:</p><p>1. for each non-XOR gate g with output wire k, and each wire j that influences <ref type="foot" target="#foot_4">5</ref>g, we have L(k) &gt; L(j). 2. for each value , there is at most one non-XOR gate whose output wire k satisfies L(k) = .</p><p>Note that a wire ordering may be any combination of safe/non-safe, monotone/ non-monotone. We say that a topological ordering of gates in a circuit C is safety-respecting of L if for every non-XOR gate g with output wire k, g appears earlier in the ordering than any other gate g with output wire k satisfying L(k) = L(k ).</p><p>Assuming that L is safe, we can garble all non-XOR gates using only two ciphertexts, plus 4 additional bits. XOR gates still require 0, 1, or 2 ciphertexts as in the previous section.</p><p>Our approach for row-reduction is the same as <ref type="bibr" target="#b20">[19]</ref>, but we give a short overview here in the interest of completeness. For simplicity, we assume that all non-XOR gates compute boolean-AND logic. Briefly, for each (a, b), we compute V ab = H 2 (w a i , w b j , g a b). Hence, only one V ab value is accessible to the evaluator. If the evaluator obtains V ab with (a, b) = (b i , b j ), then the evaluator has true on both input wires and hence this V ab should allow the evaluator to obtain the "true" output wire label w 1⊕b k k . All other V ab values should allow the evaluator to obtain the "false" label w b k k . To make this work, let P be the degree-2 polynomial that passes through the 3 points of the form (2a + b, V ab ), for the (a, b) pairs which are supposed to yield w b k k . Then let Q be the degree-2 polynomial that passes through the points (4, P (4)), (5, P (5)), and the point (2a + b, V ab ) for the "other" pair (a, b). The idea is that we can give the evaluator the values P (4) and P (5). When combined with his unique V ab value, he can interpolate to obtain either the polynomial P or Q, depending on the output logic of the gate. Hence, we can set the two wire labels to be points on P and Q respectively, say, P (-1) and Q(-1).</p><p>The formal description of this optimization is given in the full version. We must also account for the permute bits, which require 4 extra bits. Overall, each AND-gate requires 2λ + 4 bits, while XOR-gates still require 0, λ, or 2λ bits. We require the garbling procedure to process gates in a safety-respecting topological order, which ensures that Δ gets set (while garbling an AND-gate) before it is used when later garbling an XOR gate. Theorem 3. Let G 2 [H] denote our "optimization #2" garbling scheme described above. Let Φ be as in Theorem 1. Then, for all probabilistic polynomialtime A, there exists a polynomial-time simulator S such that:</p><formula xml:id="formula_18">Adv prv.sim G 2 [H],Φ,S (A, λ) ≤ (n + 1) • Adv kdf.circ H,|L| (A , λ)</formula><p>where A has runtime essentially the same as A. Furthermore, when the wire ordering function L is monotone, we have:</p><formula xml:id="formula_19">Adv prv.sim G 2 [H],Φ,S (A, λ) ≤ (n + 1) • Adv kdf.rk H,|L| (A , λ)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">GRR2-Salvaging</head><p>In general, it is not possible to combine fleXOR garbling with aggressive row reduction if the wire ordering is non-safe. Nevertheless, we observe that it is possible to garble one non-XOR gate in each L-equivalence class using aggressive row reduction. Roughly speaking, for each value , we identify the topologically first non-XOR gates g whose output wire i satisfies L(i) = . We ensure that g is processed before any other such gates, garble it with GRR2, and use the result to implicitly set Δ . The remaining gates in g's equivalence class can then be garbled using GRR3. This approach slightly generalizes our construction in the previous section. It provides a modest reduction in size, which we discuss in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Optimizing the Choice of Wire Orderings</head><p>We have identified two types of wire orderings for use with our fleXOR construction: monotone and safe ordering. In this section, we consider the problem of optimizing the choice of wire ordering: i.e., a safe/monotone wire ordering that minimizes the size of the fleXOR-garbled circuit. In particular, we need only consider the total size of garbled XOR gates. An XOR gate with input wires i and j and output wire k, requires two ciphertexts if L(i) = L(k) and L(j) = L(k), requires one ciphertext if only one of the inequalities holds, and is "free" (no ciphertexts) if L(i) = L(j) = L(k).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Monotone Orderings</head><p>We start by showing that the problem of finding an optimal monotone ordering of a circuit is NP-complete. In particular, we prove the following theorem in the full version, via a simple reduction to 3SAT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 4.</head><p>The following problem is NP-complete: Given a circuit C and integer N , determine whether there is a monotone wire ordering of C for which garbling the XOR gates using the fleXOR scheme requires at most N ciphertexts.</p><p>It is, however, easy to find at least some monotone wire ordering, using an elementary linear-time algorithm. First, assign each input wire i to L(i) = 1. Then process the gates in topological order and assign to each output wire the minimum L allowed by the monotonicity condition. We mention this simple approach only because it can be computed on the fly at basically no expense, in the same pass that garbles the circuit. This may be important in memory-critical applications where circuits are processed via streaming.</p><p>In Figure <ref type="figure">2</ref>, we propose a better heuristic for monotone orderings, inspired by the following observation. Note that it is only the non-XOR gates which necessarily increase the wire ordering number between input and output wires of a gate. Define the non-XOR-depth of a wire i in a circuit C as the maximum number of non-XOR gates among all directed paths from i to an output wire. The non-XOR-depth of every gate in a circuit can be computed via a simple dynamic programming approach. Then, we define a wire-ordering function L so that L(i) + non-XOR-depth(i) is constant for all wires i. Hence, wires closer to the outputs receive higher wire-ordering. This heuristic is in fact optimal, and results in all XOR gates free, when the circuit has fan-out 1 (i.e., the circuit encodes a formula). It is also not hard to prove that it minimizes the size of the range of the wire-ordering function hence (intuitively) increasing the likelihood of the input and output wires of an XOR gate being in the same class.</p><p>We further refine this heuristic by revisiting each XOR gate one more time, in topological order, and reducing the order of each output wire to maximum of orders of its input wires (if this is not already the case). If done in topological order, this does not affect the monotonicity of the ordering. Proposition 5. The algorithm of Figure <ref type="figure">2</ref>  We implemented both heuristic algorithms for monotone orderings, and tested them on a wide range of circuits. In general, our second heuristic algorithm outperforms the elementary one by 20-40% (in terms of average cost per XOR gate).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Safe Orderings</head><p>The constraints for safe wire ordering are fairly strict, making it challenging to devise good heuristic algorithms that minimize the number ciphertexts needed to garble XOR gates. Nevertheless, we introduce a simple and intuitive algorithm that performs well in practice as demonstrated in our analysis in the following section.</p><p>Since the output wires of non-XOR gates must have distinct L-values in a safe ordering, our idea is to assign such wires values incrementally, and in topological order, starting from 2. Then, for each XOR gate, we let the L-value of its output wire be 1 (see Figure <ref type="figure">3</ref>). The resulting ordering will always satisfy the definition of a safe ordering. In particular, if wire i influences a non-XOR gate with output wire j, then L(i) &lt; L(j), either by the topological constraint (when wire i emanates from a non-XOR gate), or because L(i) = 1 &lt; L(j) (when i emanates from an XOR gate). Proposition 6. The algorithm of Figure <ref type="figure">3</ref> computes a safe wire ordering in linear time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Other Constraints for Wire Orderings</head><p>Here we considered safe and monotone orderings separately, but we note that it is possible (and interesting) to consider their combination i.e. optimization problems for orderings that are both safe and monotone. We leave open the problem of designing good heuristics for this problem.</p><p>As mentioned earlier, using a trivial wire ordering (all wires assigned the same index) causes fleXOR construction to collapse to free-XOR.</p><p>Most 2PC protocols based on garbled circuits require only what is provided by the "garbling schemes" abstraction of <ref type="bibr" target="#b2">[3]</ref>  construction is thus automatically compatible with these protocols. However, some protocols <ref type="bibr" target="#b21">[20,</ref><ref type="bibr" target="#b17">16]</ref> "break the abstraction boundary" of garbling schemes and include optimizations that take advantage of specific properties of free-XOR. In particular, they only require that either the input wires or output wires all share a common offset (sometimes across several garbled circuits); they do not require anything of the internal wires. It is easy to include such a constraint on input/output wires in a fleXOR wire ordering, allowing fleXOR to be compatible with these protocols as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Performance Comparison</head><p>In this section we empirically evaluate the performance of our fleXOR approach against free-XOR and standard (GRR2) garbling. We obtained several circuits of interest <ref type="bibr" target="#b23">[21,</ref><ref type="bibr" target="#b7">7]</ref> and evaluated the performance of our garbling schemes on them. As outlined in the introduction, our primary metric is the size (number of ciphertexts) needed to garble a circuit. The results are summarized in Figure <ref type="figure">4</ref>.</p><p>Eliminating the circularity assumption. As discussed earlier, fleXOR avoids the strong circular-security assumption of free-XOR, when instantiated with a monotone wire ordering. Weakening the assumption does come at a cost, since not all XOR gates are free as a result. Comparing the 2nd and 3rd colums in Figure <ref type="figure">4</ref> illustrates the cost savings of circularity. In general, we show that the circularity assumption can be eliminated with a typical increase in garbled circuit size of around 10% (and never more than 20% in our analysis).</p><p>We used the heuristic method of Figure <ref type="figure">2</ref> for finding good monotone wire orderings (it performed better than the elementary method, on all circuits we tried). The numbers for free-XOR and for fleXOR+monotone both reflect mild (GRR3) row reduction for the non-XOR gates, except that we apply GRR2salvaging (Section 5.3) for fleXOR. The gain from GRR2-salvaging varies considerably, but is sometimes noticeable. For example, the numbers in Figure <ref type="figure">4</ref> reflect a savings from GRR2-salvaging of 3976 ciphertexts for SHA256, but only 40 for the AES circuit.</p><p>Beating (and matching) free-XOR efficiency. As discussed earlier, fleXOR is compatible with aggressive (GRR2) row reduction when it is instantiated with a safe wire ordering. We used the heuristic of Figure <ref type="figure">3</ref> to compute good safe orderings for all circuits. The last column of Figure <ref type="figure">4</ref> shows the size of the resulting garbled circuits. We point out that the fleXOR-garbled circuit was larger than the free-XOR garbled circuit in only two cases: For the AES circuit (which contained a significantly higher proportion of XOR gates than any other circuit we obtained), the fleXOR garbling was 12% larger than free-XOR; for the fast multiplication circuit, fleXOR was 5% larger. Our best performance was from the DES circuit, whose fleXOR-garbled circuit was 32% smaller than free-XOR.</p><p>Again we emphasize that any implementation of fleXOR matches the performance of free-XOR when assigning all wires the same index in the wire ordering. Hence, any implementation of fleXOR would easily be able to be provide whichever of the two wire orderings -safe fleXOR or free-XOR -was preferable, on a per-circuit basis, to realize the column labeled "best" in Figure <ref type="figure">4</ref>.</p><p>(Sub)Optimality. Finally, we emphasize that we did not attempt to find optimal orderings for any circuit (which is NP-hard in general), only "good enough" wire orderings found by our simple heuristics. Hence, fleXOR has potential to produce garbled circuits even smaller than the ones reflected in our empirical results here. It is also possible that the circuits themselves could be optimized for fleXOR, similar to how some circuits are currently optimized for free-XOR (i.e., to minimize the number of non-XOR gates).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>e., a, b ∈ {0, ∞}), and the tweak values T are never reused. The result of this expression should be indistinguishable from random.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Our baseline garbling scheme</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>computes a monotone wire ordering in linear time.</figDesc><table><row><cell>for every wire i:</cell><cell>for each input wire i:</cell></row><row><cell>compute non-XOR-depth[i]</cell><cell>set L[i] := 1</cell></row><row><cell>set Λ = 1 + num wires in circuit</cell><cell>set count := 2</cell></row><row><cell>for each wire i:</cell><cell>for each gate g, in topo. order:</cell></row><row><cell>set L[i] := Λ -non-XOR-depth[i]</cell><cell>denote g's output wire by k</cell></row><row><cell>for each XOR gate g in topo. order:</cell><cell>if g is an XOR gate:</cell></row><row><cell>denote g's inputs wires by i, j</cell><cell>set L[k] := 1</cell></row><row><cell>denote g's output wire by k</cell><cell>else:</cell></row><row><cell>if L[k] &gt; max{L[i], L[j]}</cell><cell>set L[k] := count</cell></row><row><cell>set L[k] := max{L[i], L[j]}</cell><cell>count := count + 1</cell></row><row><cell>Fig. 2. Monotone wire ordering heuristic</cell><cell>Fig. 3. Safe wire ordering heuristic</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>which we use here. The fleXOR Comparison of standard garbling (with GRR2 row reduction), free-XOR, and fleXOR instantiations. The main number in each cell shows average number of ciphertexts per gate; the number in the parentheses shows average number of ciphertexts per XOR gate only.</figDesc><table><row><cell></cell><cell></cell><cell>fleXOR</cell><cell></cell><cell></cell></row><row><cell>circuit</cell><cell>GRR2</cell><cell>free-XOR monotone</cell><cell>safe</cell><cell>best</cell></row><row><cell>DES</cell><cell cols="4">2.0 (2.0) 2.79 (0.0) 2.84 (0.93) 1.89 (0.38) 1.89</cell></row><row><cell>AES</cell><cell cols="4">2.0 (2.0) 0.64 (0.0) 0.76 (0.15) 0.72 (0.37) 0.64</cell></row><row><cell>SHA-1</cell><cell cols="4">2.0 (2.0) 1.82 (0.0) 2.02 (0.75) 1.39 (0.45) 1.39</cell></row><row><cell>SHA-256</cell><cell cols="4">2.0 (2.0) 2.05 (0.0) 2.26 (0.76) 1.56 (0.60) 1.56</cell></row><row><cell cols="5">Hamming distance 2.0 (2.0) 0.50 (0.0) 0.67 (0.20) 0.50 (0.20) 0.50</cell></row><row><cell>minimum in set</cell><cell cols="4">2.0 (2.0) 0.87 (0.0) 1.01 (0.41) 0.87 (0.41) 0.87</cell></row><row><cell cols="5">32 × 32 fast mult 2.0 (2.0) 0.90 (0.0) 1.15 (0.36) 0.94 (0.49) 0.90</cell></row><row><cell cols="5">1024-bit millionaires 2.0 (2.0) 1.00 (0.0) 1.08 (0.25) 1.00 (0.50) 1.00</cell></row><row><cell>Fig. 4.</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>In fact, there is no penalty at all for formulas (circuits with fan-out 1). That is, our approach matches the performance of free-XOR on formulas, but under the weaker correlation-robustness assumption.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Our high-level description does not indicate how to garble an XOR gate using just one ciphertext in the case that Δ1 = Δ2 = Δ3. This is indeed possible using similar techniques (perform free XOR on the input wires, since they share a common offset, and then, with one ciphertext, adjust the result to Δ3). However, our wire-ordering heuristics never produce XOR gates with this property, hence we do not consider this case throughout the writeup.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>Their definitions apply to any kind of garbling, but we specify the notation for circuit garbling.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>H may be drawn from a family of hash functions, but for simplicity we refer to H as a single function.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>A wire j influences a wire k if there is a directed path in the circuit that contains wire j before wire k.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Supported in part by the Intelligence Advanced Research Project Activity (IARPA) via Department of Interior National Business Center (DoI/NBC) contract Number D11PC20194. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright annotation thereon. Disclaimer: The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of IARPA, DoI/NBC, or the U.S. Government. Supported by NSF award CCF-1149647.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Garbling XOR gates &quot;For free&quot; in the standard model</title>
		<author>
			<persName><forename type="first">B</forename><surname>Applebaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2013</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">7785</biblScope>
			<biblScope unit="page" from="162" to="181" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The round complexity of secure protocols (extended abstract)</title>
		<author>
			<persName><forename type="first">D</forename><surname>Beaver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">22nd ACM STOC</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="503" to="513" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Foundations of garbled circuits</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">T</forename><surname>Hoang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS 2012</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Yu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Danezis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">V</forename><forename type="middle">D</forename><surname>Gligor</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="784" to="796" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The security of triple encryption and a framework for code-based game-playing proofs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2006</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Vaudenay</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4004</biblScope>
			<biblScope unit="page" from="409" to="426" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">On the security of the &quot;Free-XOR&quot; technique</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kumaresan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-S</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2012</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">7194</biblScope>
			<biblScope unit="page" from="39" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Scalable multiparty computation with nearly optimal work and resilience</title>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krøigaard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Nielsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2008</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5157</biblScope>
			<biblScope unit="page" from="241" to="261" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Memory efficient secure function evaluation</title>
		<author>
			<persName><forename type="first">W</forename><surname>Henecka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schneider</surname></persName>
		</author>
		<ptr target="https://code.google.com/p/me-sfe/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A dynamic tradeoff between active and passive corruptions in secure multi-party computation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hirt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Maurer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lucas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2013, Part II</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8043</biblScope>
			<biblScope unit="page" from="203" to="219" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Efficient general-adversary multi-party computation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hirt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tschudi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2013, Part II</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Sako</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Sarkar</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8270</biblScope>
			<biblScope unit="page" from="181" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Efficient secure two-party computation using symmetric cut-and-choose</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Evans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2013, Part II</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8043</biblScope>
			<biblScope unit="page" from="18" to="35" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Extending oblivious transfers efficiently</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nissim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Petrank</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2003</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2729</biblScope>
			<biblScope unit="page" from="145" to="161" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Gate evaluation secret sharing and secure one-round two-party computation</title>
		<author>
			<persName><forename type="first">V</forename><surname>Kolesnikov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2005</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Roy</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">3788</biblScope>
			<biblScope unit="page" from="136" to="155" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Improved secure two-party computation via information-theoretic garbled circuits</title>
		<author>
			<persName><forename type="first">V</forename><surname>Kolesnikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kumaresan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SCN 2012</title>
		<editor>
			<persName><forename type="first">I</forename><surname>Visconti</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>De Prisco</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7485</biblScope>
			<biblScope unit="page" from="205" to="221" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Improved OT extension for transferring short secrets</title>
		<author>
			<persName><forename type="first">V</forename><surname>Kolesnikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kumaresan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2013, Part II</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8043</biblScope>
			<biblScope unit="page" from="54" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Improved garbled circuit: Free XOR gates and applications</title>
		<author>
			<persName><forename type="first">V</forename><surname>Kolesnikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP 2008, Part II</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Aceto</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Goldberg</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Halldórsson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Ingólfsdóttir</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">I</forename><surname>Walukiewicz</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5126</biblScope>
			<biblScope unit="page" from="486" to="498" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Fast cut-and-choose based protocols for malicious and covert adversaries</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2013, Part II</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8043</biblScope>
			<biblScope unit="page" from="1" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Garbled circuits checking garbled circuits: More efficient and secure two-party computation</title>
		<author>
			<persName><forename type="first">P</forename><surname>Mohassel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Riva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2013, Part II</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8043</biblScope>
			<biblScope unit="page" from="36" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Privacy preserving auctions and mechanism design</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sumner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st ACM Conference on Electronic Commerce, EC 1999</title>
		<meeting>the 1st ACM Conference on Electronic Commerce, EC 1999<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="129" to="139" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Secure two-party computation is practical</title>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Smart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2009</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Matsui</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5912</biblScope>
			<biblScope unit="page" from="250" to="267" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Two-output secure computation with malicious adversaries</title>
		<author>
			<persName><forename type="first">A</forename><surname>Shelat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-H</forename><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2011</title>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Paterson</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">6632</biblScope>
			<biblScope unit="page" from="386" to="405" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Tillich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Smart</surname></persName>
		</author>
		<ptr target="http://www.cs.bris.ac.uk/Research/CryptographySecurity/MPC/" />
		<title level="m">Circuits of basic functions suitable for MPC and FHE</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
