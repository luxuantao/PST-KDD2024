<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">G-Free: Defeating Return-Oriented Programming through Gadget-less Binaries</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Kaan</forename><surname>Onarlioglu</surname></persName>
							<email>onarliog@cs.bilkent.edu.tr</email>
						</author>
						<author>
							<persName><forename type="first">Leyla</forename><surname>Bilge</surname></persName>
							<email>bilge@eurecom.fr</email>
						</author>
						<author>
							<persName><forename type="first">Andrea</forename><surname>Lanzi</surname></persName>
							<email>lanzi@eurecom.fr</email>
						</author>
						<author>
							<persName><forename type="first">Davide</forename><surname>Balzarotti</surname></persName>
							<email>balzarotti@eurecom.fr</email>
						</author>
						<author>
							<persName><forename type="first">Engin</forename><surname>Kirda</surname></persName>
							<email>kirda@eurecom.fr</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Bilkent University</orgName>
								<address>
									<settlement>Ankara</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<address>
									<settlement>Eurecom</settlement>
									<country>Sophia Antipolis</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<address>
									<settlement>Eurecom</settlement>
									<country>Sophia Antipolis</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<address>
									<settlement>Eurecom</settlement>
									<country>Sophia Antipolis</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<address>
									<settlement>Eurecom</settlement>
									<country>Sophia Antipolis</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">G-Free: Defeating Return-Oriented Programming through Gadget-less Binaries</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">241408B566027F6FE89D0C6407B67512</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Security and Protection Return-oriented programming</term>
					<term>ROP</term>
					<term>return-to-libc</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Despite the numerous prevention and protection mechanisms that have been introduced into modern operating systems, the exploitation of memory corruption vulnerabilities still represents a serious threat to the security of software systems and networks. A recent exploitation technique, called Return-Oriented Programming (ROP), has lately attracted a considerable attention from academia. Past research on the topic has mostly focused on refining the original attack technique, or on proposing partial solutions that target only particular variants of the attack.</p><p>In this paper, we present G-Free, a compiler-based approach that represents the first practical solution against any possible form of ROP. Our solution is able to eliminate all unaligned free-branch instructions inside a binary executable, and to protect the aligned free-branch instructions to prevent them from being misused by an attacker. We developed a prototype based on our approach, and evaluated it by compiling GNU libc and a number of real-world applications. The results of the experiments show that our solution is able to prevent any form of return-oriented programming.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>As the popularity of the Internet increases, so does the number of attacks against vulnerable services <ref type="bibr" target="#b3">[3]</ref>. A common way to compromise an application is by exploiting memory corruption vulnerabilities to transfer the program execution to a location under the control of the attacker. In these kinds of attacks, the first step requires to find a technique to overwrite a pointer in memory. Overflowing a buffer on the stack <ref type="bibr" target="#b5">[5]</ref> or exploiting a format string vulnerability <ref type="bibr" target="#b26">[26]</ref> are well-known examples of such techniques. Once the attacker is able to hijack the control flow of the application, the next step is to take control of the program execution to perform some malicious activity. This is typically done by injecting in the process memory a small payload that contains the machine code to perform the desired task.</p><p>A wide range of solutions have been proposed to defend against memory corruption attacks, and to increase the complexity of performing these two attack steps <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b35">35]</ref>. In particular, all modern operating systems support some form of memory protection mechanism to prevent programs from executing code that resides in certain memory regions <ref type="bibr" target="#b33">[33]</ref>. The goal of this technique is to protect against code injection attacks by setting the permissions of the memory pages that contain data (such as the stack and the heap of the process) as non-executable.</p><p>One of the techniques to bypass non-executable memory without relying on injected code involves reusing the functionality provided by the exploited application. Using this technique, which was originally called return-to-lib(c) <ref type="bibr" target="#b31">[31]</ref>, an attacker can prepare a fake frame on the stack and then transfer the program execution to the beginning of a library function. Since some popular libraries (such as the libc) contain a wide range of functionality, this technique is sufficient to take control of the program (e.g., by exploiting the system function to execute /bin/sh).</p><p>In 2007, Shacham <ref type="bibr" target="#b29">[29]</ref> introduced an evolution of return-to-lib(c) techniques <ref type="bibr" target="#b23">[23,</ref><ref type="bibr" target="#b27">27,</ref><ref type="bibr" target="#b31">31]</ref> called Return-Oriented Programming (ROP). The main contribution of ROP is to show that it is possible for an attacker to execute arbitrary algorithms and achieve Turing completeness without injecting any new code inside the application.</p><p>The idea behind ROP is simple: Instead of jumping to the beginning of a library function, the attacker chains together existing sequences of instructions (called Gadgets) that have been previously identified inside existing code. The large availability of gadgets in common libraries allows the attacker to implement the same functionality in many different ways. Thus, removing potentially dangerous functions (e.g., system) from common libraries is ineffective against ROP, and does not provide any additional security.</p><p>ROP is particularly appealing for rootkit development since it can defeat traditional defense techniques based on kernel data integrity <ref type="bibr" target="#b36">[36]</ref> or code verification <ref type="bibr" target="#b24">[24,</ref><ref type="bibr" target="#b28">28]</ref>. Another interesting domain is related to exploiting architectures with immutable memory protection (e.g., to compromise electronic voting machines as shown in <ref type="bibr" target="#b7">[7]</ref>). ROP was also recently adopted by real attacks observed in the wild as a way to bypass Windows' Data Execution Prevention (DEP) technology <ref type="bibr" target="#b2">[2]</ref>.</p><p>The great interest around ROP quickly evolved into an arms race between researchers. On the one side, the basic attack technique was extended to various processor architectures <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b34">34]</ref> and the feasibility of mounting this attack at the kernel level was demonstrated <ref type="bibr" target="#b19">[19]</ref>. On the other side, ad-hoc detection and protection mechanisms to mitigate the attack were proposed <ref type="bibr">[9,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b16">16,</ref><ref type="bibr" target="#b22">22]</ref>. To date, existing solutions have focused only on the basic attack, by detecting, for instance, the anomalous frequency of return instructions executed <ref type="bibr">[9,</ref><ref type="bibr" target="#b16">16]</ref>, or by removing the ret opcode to prevent the gadget creation <ref type="bibr" target="#b21">[21]</ref>. Unfortunately, a recent advancement in ROP <ref type="bibr" target="#b8">[8]</ref> has already raised the bar by adopting different instructions to chain the gadgets together, thus making all existing protection techniques ineffective.</p><p>In this paper, we generalize from all the details that are specific to a particular exploitation technique to undermine the foundation on top of which return-oriented programming is built: the availability of instruction sequences that can be reused by an attacker. We present a general approach for the IA-32 instruction set that combines different techniques to eliminate all possible sources of reusable instructions. More precisely, we use code rewriting techniques to remove all unaligned instructions that can be used to link the gadgets. Moreover, we introduce a novel protection technique to prevent the attacker from misusing existing return or indirect jump/call instructions.</p><p>We implemented our solution under Linux as a pre-processor for the popular GNU Assembler. We then evaluated our tool on different real-world applications, with a special focus on the GNU libc (glibc) library. Our experiments show that our solution can be applied to complex programs, and it is able to remove all possible gadgets independently from the mechanism used to connect them together. A program compiled with our system is, on average, 26% larger and 3% slower (when all the linked libraries are also compiled with our solution). This is a reasonable overhead that is in line with existing stack protection mechanisms such as StackGuard <ref type="bibr" target="#b11">[11]</ref>.</p><p>This paper makes the following contributions:</p><p>• We present a novel approach to prevent an attacker from reusing fragments of existing code as basic blocks to compose malicious functionality.</p><p>• To the best of our knowledge, we are the first to propose a general solution to defeat all forms of ROP. That is, our solution can defend against both known variations and future evolutions of the attack.</p><p>• We developed G-Free, a proof-of-concept implementation to generate programs that are hardened against return-oriented programming. Our solution requires no modification to the application source code, and can also be applied to system applications that contain large sections of assembly code.</p><p>• We evaluated our technique by compiling gadget-free versions of glibc and other real-world applications.</p><p>The rest of the paper is structured as follows: In Section 2, we analyze the key concepts of return-oriented programming.In Section 3, we summarize proposed defense techniques against memory corruption attacks and ROP. In Section 4, we present our approach for compiling gadget-free applications. In Section 5, we describe our prototype implementation. In Section 6, we show the results of the experiments we conducted for evaluating the impact and performance of our system. Finally, in Section 7, we briefly conclude the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">GADGETS</head><p>Before presenting the details of our approach, we establish a more precise and general model for the class of attacks we wish to prevent. Therefore, we generalize the concept of return-oriented programming by abstracting away from all the details that are specific to a particular attack technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Programming with Gadgets</head><p>The core idea of return-oriented programming is to "borrow" sequences of instructions from existing code (either inside the application or in the linked libraries) and chaining them together in an order chosen by the attacker. Therefore, in order to use this technique, the attacker has to first identify a collection of useful instruction sequences that she can later reuse as basic blocks to compose the code to be executed. A crucial factor that differentiates return-oriented programming from simpler forms of code reuse (such as traditional return-to-lib(c) attacks) is that the collection of code snippets must provide a comprehensive set of functionalities that allows the attacker to achieve Turing completeness without injecting any code <ref type="bibr" target="#b29">[29]</ref>. The second step of ROP involves devising a mechanism to manipulate the control flow in order to chain these code snippets together, and build meaningful algorithms.</p><p>Note that these two requirements are not independent: To allow the manipulation of the control flow, the instruction sequences must exhibit certain characteristics that impose constraints on the way they are chosen. For example, sequences may have to terminate with a return instruction, or they may have to preserve the content of a certain CPU register. In this paper, we use the term Gadget to refer to any valid sequence of instructions that satisfies the control flow requirements.</p><p>In a traditional ROP attack, the desired control flow is achieved by placing the addresses of the gadgets on the stack and then exploiting ret instructions to fetch and copy them to the instruction pointer. In other words, if we consider each gadget as a monolithic instruction, the stack pointer plays the role of the instruction pointer in a normal program, transferring the control flow from one gadget to the next. Consequently, gadgets are initially defined by Shacham as useful snippets of code that terminate with a ret instruction <ref type="bibr" target="#b29">[29]</ref>.</p><p>However, the use of ret instructions is just one possible way of chaining gadgets together. In a recent refinement of the technique <ref type="bibr" target="#b8">[8]</ref>, Checkoway and Shacham propose a variant of ROP in which return-like instructions are employed to fetch the addresses from the stack. Because these sequences are quite rare in regular binaries, indirect jumps (e.g., jmp * %eax) are used as gadget terminators to jump to a previously identified return-like sequence. In theory, it is even possible to design control flow manipulation techniques that are not stack-based, but that store values in other memory areas accessible at runtime by an attacker (e.g., on the heap or in global variables).</p><p>As a result, in order to find a general solution to the ROP threat, we need to identify a property that all possible variants of returnoriented programming have in common. Kornau <ref type="bibr" target="#b34">[34]</ref> identified such a property in the fact that every gadget, in order to be reusable, has to end with a "free-branch" instruction, i.e., an instruction that can change the program control flow to a destination that is (or that can be under certain circumstances) controlled by the attacker. According to this definition, in each gadget, we can recognize two parts: the code section that implements the gadget's functionality and the linking section that contains the instructions used to transfer the control to the next gadget. The linking section needs to end with a free branch, but it can also contain additional instructions. For instance, a possible linking section could be the following se- </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Gadget Construction</head><p>In the x86 architecture, gadgets are not limited to sequences of existing instructions. In fact, since the IA-32 instruction set does not have fixed length instructions, the opcode that will be executed depends on the starting point of the execution in memory. Therefore, the attacker can build different gadgets by jumping inside existing instructions.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> shows how, depending on the alignment of the first and last instruction, it is possible to construct three different kinds of gadgets. Gadget1 is an aligned gadget that only uses "intended" instructions already present in the function code. Gadget2 is a gadget that contains only "unaligned" instructions ending with the unintended call * %eax. Finally, Gadget3 starts by using an unintended add instruction, then re-synchronizes with the normal execution flow, and ends by reaching the function return. This example demonstrates how a short sequence of 14 bytes can be used for constructing many possible gadgets. Considering that a common library such as libc contains almost 18K free branch instructions and that each of them can be used to construct multiple gadgets, it is not difficult for an attacker to find the functionality he needs to execute arbitrary code.</p><p>If we can prevent the attacker from finding useful instruction sequences that terminate with a free branch, we can prevent any return-oriented programming technique. We present our approach to reach this goal in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">RELATED WORK</head><p>Several defense mechanisms attempt to detect memory exploits which represent a fundamental basic block for mounting return-tolib(c) attacks. StackGuard <ref type="bibr" target="#b11">[11]</ref> and ProPolice <ref type="bibr" target="#b18">[18]</ref> are compiletime solutions that aim at detecting stack overflows. PointGuard encrypts pointers stored in memory to prevent them from being corrupted <ref type="bibr" target="#b10">[10]</ref>. StackShield <ref type="bibr" target="#b35">[35]</ref> and StackGhost <ref type="bibr" target="#b17">[17]</ref> use a shadow return address stack to save the return addresses and to check whether they have been tampered with at function exits. A complete survey of traditional mitigation techniques together with their drawbacks is presented in <ref type="bibr" target="#b12">[12]</ref>. Our solution, in order to avert ROP attacks, prevents tampering with the return address as well; but it does not target other memory corruption attacks.</p><p>One of the most effective techniques that hamper return-to-lib(c) attacks is Address Space Layout Randomization (ASLR) <ref type="bibr" target="#b32">[32]</ref>. In its general form, this technique randomizes positions of stack, heap, and code segments together with the base addresses of dynamic libraries inside the address space of a process. Consequently, an attacker is forced to correctly guess the positions where these data structures are located to be able to mount a successful attack. Despite the better protection offered by this mechanism, researchers showed that the limited entropy provided by known ASLR implementations can be evaded either by performing a brute-force attack on 32-bit architectures <ref type="bibr" target="#b30">[30]</ref> or by exploiting Global Address Table and de-randomizing the addresses of target functions <ref type="bibr" target="#b25">[25]</ref>.</p><p>Various approaches proposed by the research community aim at impeding ROP attacks by ensuring the integrity of saved return addresses. Frantsen et al. <ref type="bibr" target="#b17">[17]</ref> presented a shadow return address stack implemented in hardware for the Atmel AVR microcontroller, which can only be manipulated by ret and call instructions. ROPdefender <ref type="bibr" target="#b22">[22]</ref> uses runtime binary instrumentation to implement a shadow return address stack where saved return addresses are duplicated and later compared with the value in the original stack at function exits. Even though ROPdefender is suitable for impeding basic ROP attacks, it suffers from performance issues due to the fact that the system checks every machine instruction executed by a process.</p><p>Another method, called program shepherding <ref type="bibr" target="#b20">[20]</ref>, can prevent basic forms of ROP as well as code injection by monitoring control flow transfers and ensuring library code is entered from exported interfaces.</p><p>Other approaches <ref type="bibr">[9,</ref><ref type="bibr" target="#b13">13]</ref> aim to detect ROP-based attacks relying on the observation that running gadgets results in execution of short instruction sequences that end with frequent ret instructions. They proposed to use dynamic binary instrumentation to count the number of instructions executed between two ret opcodes. An alert is raised if there are at least three consecutive sequences of five or fewer instructions ending with a ret.</p><p>The most similar approach to ours is a compiler-based solution developed in parallel to our work by Li et al. <ref type="bibr" target="#b21">[21]</ref>. This system eliminates unintended ret instructions through code transformations, and instruments all call and ret instructions to implement return address indirection. Specifically, each call instruction is modified to push onto the stack an index value that points to a return address table entry, instead of the return address itself. Then, when a ret instruction is executed, the saved index is used for looking up the return address from the table. Although this system is more efficient compared to the previous defenses, it is presented as a solution specifically tailored for gadgetless kernel compilation, and it exploits characteristics of kernel code for gadget elimination and increased performance. Moreover, the implementation requires manual modifications to all the assembly routines.</p><p>It is important to note that none of the defenses proposed so far can address more advanced ROP attacks that utilize free-branch instructions different from ret. The solution we present in this paper is the first to address all free-branch instructions, and the first that can be applied at compile-time to protect any program from ROP attacks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">CODE WITHOUT GADGETS</head><p>Our goal is to provide a proactive solution to build gadget-free executables that cannot be targeted by any possible ROP attack. In particular, we strive to achieve a comprehensive, transparent, and safe solution. By comprehensive, we mean that we would like our solution to eliminate all possible gadgets by removing the linking mechanisms that are necessary to chain instruction sequences together. Transparent means that this process must require no intervention from the user, such as manual modifications to the source code. Finally, we would like to present a solution that is safe: That is, it should preserve the semantics of the program, be compatible with compiler optimizations, and support applications that contain routines written in assembly language.</p><p>In order to reach our goals, we devise a compiler-based approach that first eliminates all unaligned free-branch instructions inside a binary executable, and then protects the aligned free-branch instructions to prevent them from being misused by an attacker.</p><p>We achieve the first point through a set of code transformation techniques that ensure free-branch instructions never appear inside any legitimate aligned instruction. This leaves the attacker with the only option of exploiting existing ret and jmp * /call * instructions. To eliminate this possibility, we introduce a mechanism that protects these potentially dangerous instructions by ensuring that they can be executed only if the functions in which they reside were executed from their entry points.</p><p>Consequently, an attacker can only execute entire functions from the start to the end as opposed to running arbitrary code. This effectively de-generalizes the threat to a traditional return-to-lib(c) attack, eliminating the advantages of achieving Turing completeness without injecting any code in the target process.</p><p>Our approach uses a combination of techniques, namely alignment sleds, return address encryption, frame cookies and code rewriting. The rest of this section describes each technique in detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Free Branch Protection</head><p>The first set of techniques aim to protect the aligned free-branch instructions available in the binary. These include the actual ret instructions at the end of each function and the jmp * /call * instructions that are sometimes present in the code.</p><p>Unfortunately, these instructions cannot be easily eliminated without altering the application's behavior. In addition, replacing them with semantically equivalent pieces of code is likely not going to solve the problem because the attacker could still use the replacements to achieve the same functionality.</p><p>Therefore, we propose a simple solution inspired by existing stack protection mechanisms (e.g., StackGuard <ref type="bibr" target="#b11">[11]</ref>). The goal is to instrument functions with short blocks of code to ensure that aligned free-branch instructions can only be executed if the running function has been entered from its proper entry point. In particular, we employ two complementary techniques: an efficient return address encryption to protect ret instructions, and a more sophisticated cookie-based technique we additionally apply only to those functions that contain jmp * /call * instructions. In Section 4.3, we discuss the possibility that an attacker attempts to exploit these protection blocks, and in Section 5.5 we show how we avoid this threat in our prototype.</p><p>Finally, we prepend the code performing the checks with alignment sleds. Alignment sleds are special sequences of bytes by which we enforce aligned execution of a set of critical instructions. In particular, we use this technique to prevent an attacker from bypassing our free branch protection code by executing it in an unaligned fashion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Alignment Sleds</head><p>An alignment sled is a sufficiently-long sequence of bytes, encoding one or more instructions that have no effect on the status of the execution. Its length is set to ensure that regardless of the alignment prior to reaching the sled, the execution will eventually land on the sled and execute it until the end. Even if an attacker jumps into the binary at an arbitrary point and executes a number of unaligned instructions, when she reaches the sled, the execution will be forced to realign with the actual code. Thus, it will never reach any unintended opcode present in the instructions following the sled.</p><p>The simplest way to implement an alignment sled is to use a sequence of nop instructions (see Figure <ref type="figure" target="#fig_1">2</ref> for an example). The number of nop instructions must be determined by taking into consideration the maximum number of consecutive nop bytes (0x90) that can tail a valid instruction. If we set the length to anything less than that, an attacker could find an unintended instruction that encompasses the whole sled and any number of bytes from the following instruction, in which case the execution will continue in an unaligned fashion. In the IA-32 architecture, the longest such sequence becomes possible when we have both an address displacement and an immediate value entirely composed of 0x90 bytes <ref type="bibr" target="#b4">[4]</ref>, which makes a total of 8 bytes. Additionally, we can have either a ModR/M byte, a SIB byte or an opcode with the value 0x90 (but only one of them at a time). As a result, we can safely set the number of nop instructions in our sled to 9.</p><p>Note that the sled length calculation presented in this section is an over-approximation: By also taking into account the bytes preceding the sled and which instructions they can possibly encode, it is possible to automatically compute the required sled length caseby-case.</p><p>Finally, we prepend the sled with a relative jump instruction to skip over the sled bytes. Consequently, if the execution is already aligned it will hit the jump and not incur the performance penalty of executing the sequence of nop instructions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Return Address Protection</head><p>This technique involves instrumenting entry points of the functions that contain ret instructions with a short header that encrypts the saved return address stored on the stack. Before ret instructions, we then insert a corresponding footer to restore the return address to its original value. If an attacker jumps into a function at an arbitrary position and eventually reaches our footer, the decryption routine processes the unencrypted return address provided by the attacker, computes an invalid value and the following ret instruction attempts to transfer the execution flow to an incorrect address that the attacker cannot control. This technique is similar to the random XOR canary implemented by StackGuard <ref type="bibr" target="#b11">[11]</ref>.</p><p>The encryption method we utilize is a simple exclusive-or of the return address with a random key. Since this solution does not affect the layout of the stack in any way, it does not require any further modifications to the function code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.3">Frame Cookies</head><p>In order to prevent the attacker from using existing jmp * /call * instructions, we need to adopt another protection mechanism.  <ref type="table">1</ref>: ModR/M and SIB values encoding ret opcodes this end, we instrument entry points of the functions that contain jmp * /call * instructions with an additional header to compute and push a random cookie onto the stack. This cookie is an exclusiveor of a random key generated at runtime and a per-function constant generated at compile time. The constant is used for uniquely identifying the function and it does not need to be kept secret.</p><p>Then, we prepend all the jmp * /call * instructions with a validation block which fetches the cookie, decrypts it, and compares the result with the per-function constant. If the cookie is not found or the values do not match, we invalidate the jump/call destination causing the application to crash. Finally, in the function footer, we insert a simple instruction to remove the cookie from the stack.</p><p>A significant consequence of this technique is that it alters the layout of the stack by storing an additional value. This requires us to fix the memory offsets of some of the instructions that access the stack according to the location where we store the cookie (we discuss the details of this issue in Section 5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Code Rewriting</head><p>The second set of techniques we adopt in our approach focus on removing any unaligned free-branch instructions.</p><p>In the IA-32 architecture, instructions consist of some or all of the following fields: instruction prefixes, an opcode, a ModR/M byte, a SIB (Scale-Index-Base) byte, an address displacement, and finally, an immediate value. A ret instruction can be encoded with any of the 0xc2, 0xc3, 0xca or 0xcb bytes, and, as such, can be part of any of the instruction fields (excluding the prefixes). On the other hand, jmp * /call * instructions are encoded by two-byte opcodes: an 0xff followed by an ModR/M byte carrying certain three-bit sequences. Hence, in addition to appearing inside a single instruction, they can also be obtained by a combination of two bytes coming from two consecutive instructions.</p><p>In this section, we discuss the various cases and describe the code rewriting techniques we use to eliminate all unintended free-branch opcodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Register Reallocation</head><p>The ModR/M and the SIB bytes are used for encoding the addressing mode and operands of an instruction. The use of certain registers as operands cause either the ModR/M or the SIB byte to be set to a value that corresponds to a ret opcode. The possible undesired encodings of these bytes are shown in Table <ref type="table">1</ref>. For instance, an instruction that specifies %eax as the source operand and %ebx as the destination, such as movl %eax, %ebx, assigns the value 0xc3 to the ModR/M byte. Similarly, using %edx as the base and (%ecx * 8) as the scaled index, the instruction addl $0x2a,(%edx,%ecx,8) contains 0xca in its SIB byte.</p><p>In order to eliminate the unintended ret opcodes that result from such circumstances, we must avoid all of the undesired register pairings listed in Table <ref type="table">1</ref>. We achieve this by manipulating the register allocation performed during compilation to ensure that those pairs of registers never appear together in a generated instruction. When we detect such an instruction, we can perform the compiler's register allocation stage again, this time enforcing a different register assignment. As an alternative, we can perform a local reallocation by temporarily swapping the contents of the original operand with a new register, and then rewriting the instruction with this new register as its operand. In this way, we can bring forth an acceptable register pairing for the same instruction.</p><p>Finally, in some cases, the ModR/M byte could be used to specify an opcode extension and a single register operand. Sometimes, it is possible to rewrite these instructions using the same techniques described above to replace the register operand with a different one. However, floating point instructions can use implicit operands that cannot be substituted with others (e.g, fld %st(2)). Since all these instructions can have the ret opcode only in their second byte, we instead prepend them with an alignment sled. This leaves to the attacker only one byte (the opcode that specifies the FPU instruction) before the unaligned ret, and it is therefore impossible to use this byte to create any gadget.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Instruction Transformations</head><p>ret bytes appear in opcodes encoding movnti (0x0f 0xc3) and bswap (0x0f 0xc8+&lt;register_identifier&gt;) instructions. In the first case, movnti acts like a regular mov operation except that it uses a non-temporal hint to reduce cache pollution. Thus, we can safely replace it with a regular mov without any significant consequence. For the second, the opcode is determined according to the operand register and can encode a ret byte when certain registers are specified as the operand; therefore, as described in the previous section, we can perform a register reallocation to choose a different operand and obtain a safe bswap opcode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Jump Offset Adjustments</head><p>Jump and call instructions may contain free-branch opcodes when using immediate values to specify their destinations. For instance, jmp .+0xc8 is encoded as "0xe9 0xc3 0x00 0x00 0x00".</p><p>A free-branch opcode can appear at any of the four bytes constituting the jump/call target. If the opcode is the least significant byte, it is sufficient to append the forward jump/call with a single nop instruction (or prepend it if it is a backwards jump/call) in order to adjust the relative distance between the instruction and its destination:</p><p>jmp .+0xc8 ⇒ jmp .+0xc9 nop However, when the opcode is at a different byte position, the number of nop instructions we need to insert increase drastically (256 for the second, 64K for the third and 16M for the last byte).</p><p>Fortunately, it is highly uncommon to have a free-branch opcode in one of the most significant bytes. For example, a jump offset encoded by "0x00 0x00 0xc3 0x00" indicates a 12MB forward jump. Considering the fact that jump instructions are ordinarily used for local control flow transitions inside a function, a 12MB offset would be infeasible in practice. Even if we were to come across such an offset, it is still possible to relocate the functions or code chunks addressed by the instruction to remove the opcodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.4">Immediate and Displacement Reconstructions</head><p>Several arithmetic, logic and comparison operations can take immediate values as an operand, which may contain free-branch instruction opcodes. We can remove these by substituting the instruction with a sequence of different instructions that construct the immediate value in steps while carrying the same semantics. The fol-lowing examples demonstrate the reconstruction process, assuming that %ebx is free or has been saved beforehand:</p><formula xml:id="formula_0">addl $0xc2, %eax ⇒ addl $0xc1, %eax inc %eax xorb $0xca, %al ⇒ movb $0xc9, %bl incb %bl xorb %bl, %al</formula><p>Instructions that perform memory accesses can also contain freebranch instruction opcodes in the displacement values they specify (e.g., movb %al, -0x36(%ebp) represented as "0x88 0x45 0xca"). In such cases, we need to substitute the instruction with a semantically equivalent instruction sequence that uses an adjusted displacement value to avoid the undesired bytes. We achieve this by setting the displacement to a safe value and then compensating for our changes by temporarily adjusting the value in the base register. For example, we can perform a reconstruction such as: movb $0xal, -0x36(%ebp) ⇒ incl %ebp movb %al, -0x37(%ebp) decl %ebp</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.5">Inter-Instruction Barriers</head><p>Unintended jmp * /call * opcodes can result from the combination of two consecutive instructions. This happens when the last byte of an instruction is 0xff and the first byte of the following instruction encodes a suitable opcode extension. We can remove these unintended jmp * /call * opcodes by inserting a barrier between two such instructions, effectively separating them and destroying the unintended opcode. For the barrier, the trivial choice of a nop instruction is not suitable since an 0xff followed by a 0x90 still encodes an indirect call. Thus, we have to choose a safe nop-like alternative, such as "movl %eax, %eax".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Limitations of the Approach</head><p>By applying the techniques presented in this section, it is possible to remove all unaligned free-branch instructions from a binary, and to protect the aligned ones from being misused by an attacker. However, since our protection mechanism does not remove the free branches, but prepends a short piece of code to protect them, the result of the compilation will still contain some gadgets.</p><p>In fact, an attacker may skip the alignment sled by directly jumping into the return address or indirect jump/call protection blocks. This may result in executing a useful instruction sequence (intended or unintended) which terminates at the free-branch instruction we intend to protect.</p><p>However, since our approach only requires inserting two very short pieces of code, the number of possible gadgets that can be built is very limited and the gadget sizes are restricted to few instructions. By keeping this issue in mind, it is, therefore, possible to specifically craft the return address and indirect jump/call protection blocks to make sure they do not contain any convenient gadgets.</p><p>In particular, we discuss the techniques we used in our prototype implementation and the number and type of gadgets that are left in the applications compiled by our tool in Section 5.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">IMPLEMENTATION</head><p>Our implementation efforts primarily focus on creating a fullyautomated system that would not require any modifications to the program's source code or to the existing compilation tools. Unfortunately, system-wide libraries, which are the primary targets of ROP attacks, often rely on hand-tuned assembly routines to perform low-level tasks. This makes a pure compiler-based solution unable to intercept part of the final code. Therefore, we implemented our prototype in two separate components: an assembly code pre-processor designed to work as a wrapper for the GNU Assembler (gas), and a simple binary analyzer responsible for gathering some information that is not available in the assembly source code.</p><p>In this section, we describe G-Free, a prototype system we developed based on the techniques presented in Section 4, and we discuss some of the issues we encountered while compiling glibc using our prototype.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Assembly Code Pre-Processor &amp; Binary Analyzer</head><p>The assembly code pre-processor intercepts the assembly code generated by cc1 (the GNU C compiler included in the GNU Compiler Collection) or coming directly from an assembly language source file. It then performs the required modifications to remove all the possible gadgets, and finally passes the control to the actual gas assembler. We must stress that in this implementation we modify neither the compiler nor the assembler; both are completely oblivious to the existence of our pre-processing stage. We only replace the gas executable with a small wrapper responsible for invoking our pre-processor before executing the assembler.</p><p>Our system successfully handles assembly routines written using non-standard programming practices. It supports position independent code (PIC) and compiler optimizations, including all of the GCC standard optimization levels (in fact, glibc does not compile if GCC optimizations are disabled).</p><p>There is one significant implication of directly working with assembly code: Our pre-processor is not exposed to the numeric values of immediate operands and memory displacements since these are often represented by symbolic values until linkage. Thus, it is not possible for us to identify all of the instructions that contain unintended free-branch opcodes just by looking at the assembly code. In order to address this issue, we use a two-step compilation approach. First, our system compiles a given program without doing any modifications to the original code. During this compilation, our pre-processor tags each of the instructions that contain immediate values or displacements with unique symbols. This information is then exported in the final executable's symbol table. In a second step, we use a binary analyzer to read the symbol table of the executable and check whether any of the instructions pointed to by our tagged symbols needs to be rewritten because it contains unaligned free-branch instructions. This analysis produces a log of the tags corresponding to the instructions we need to modify. This log is consumed by the pre-processor during a second compilation phase in order to provide it with the previously missing information.</p><p>Unfortunately, inserting a nop at a certain position to fix a jump offset may actually affect the offsets of many other jumps since it alters the whole address space of the binary. Our prototype binary analyzer does not consider the overall structure of the binary file when reporting the instructions to fix. Therefore, while fixing a set of jump offsets, several other offsets may start to contain freebranch opcodes. This makes it necessary to perform several compilations until all the offsets are fixed. Note that in this process, we may need to fix a single jump instruction several times. However, since inserting nop instructions between a jump and its destination can only increase the offset but never decrease it, we are sure to find a safe offset after a finite number of iterations.</p><p>A more optimized analyzer that can perform a global analysis and take into account the target of every jump instruction would eliminate this problem. It would also produce smaller executables since recompilations insert otherwise unnecessary nop bytes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Random Keys</head><p>As described in Section 4, our approach requires a random value to encrypt both the return address and the cookie stored on the stack. For this purpose, our prototype inserts a key generation routine at the beginning of the program's entry point (or initialization routine if it is a library). In our prototype, this routine simply reads a 32-bit random value from the Linux special file /dev/random and stores the value in a global memory location.</p><p>If the attacker has a way to read arbitrary memory locations before performing the actual attack, he could be able to fetch the per-process random key and use it to craft the required values on the stack to defeat our implementation. This limitation is common to many canary-based stack protection mechanism such as StackGuard <ref type="bibr" target="#b11">[11]</ref> and ProPolice <ref type="bibr" target="#b18">[18]</ref>. However, this problem can be avoided by substituting the per-process random key with a perfunction key computed at runtime in the function headers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Stack Reference Adjustments</head><p>We store our cookie just above the saved return address in the stack, shifting the frame base upwards by 4 bytes. Since a function usually uses the %ebp register to reference the stack relative to the frame base, and our cookie is located below the frame base, references to the stack local variables remain unchanged. On the contrary, references to function parameters which are stored below the frame base, and therefore below our cookie, need to be adjusted by 4 bytes.</p><p>We achieve this by simply correcting each positive displacement to %ebp by adding to it the size of our cookie:</p><formula xml:id="formula_1">movl 0x8(%ebp), %eax ⇒ movl 0xc(%ebp), %eax</formula><p>Note that compiler optimizations that adopt Frame Pointer Omission (FPO) use the stack pointer to reference arguments and local variables. In this case, we need to compute the displacement of the stack pointer to the function's frame at any given position in the function in order to identify and fix the references and locate our cookie in the stack. This requires a comprehensive stack depth analysis. We have designed our pre-processor to perform this analysis on the fly without the need for any extra pass over the source file, even when the execution flow of the processed function is nonlinear. We keep track of push &amp; pop operations and arithmetic computations on the stack pointer and update the system's view of stack depth accordingly. Depending on the state of the stack, we can then decide whether a stack access (e.g., 120(%esp)) points to a local variable or to a function's parameter, so that we can apply the displacement adjustment where appropriate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Conditional Code Rewriting</head><p>Our prototype implements all immediate and displacement reconstruction strategies we described in Section 4. However, to reduce the performance overhead, we apply those transformations only when absolutely necessary. Otherwise, we use a faster approximate solution. In particular, during the first compilation phase, we prepend each instruction that contains free-branch opcodes among its immediate or displacement fields with an alignment sled. The sled protects the instruction, but does not actually remove the free branch from the code. Therefore, an attacker can sometimes build very short gadgets that fit the few bytes between the end of the sled and the unaligned free-branch instruction.</p><p>Our system automatically checks these bytes after the compilation. If it detects that they do indeed contain valid instructions, it falls back to the safer (but slightly less efficient) immediate or displacement reconstruction methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Return Address and Indirect Jump/Call Protection Blocks</head><p>As previously explained in Section 4, our solution protects aligned free-branch instructions by introducing two short blocks of code: the return address protection block and the indirect jump/call protection block (the current implementations are shown in Figure <ref type="figure">3</ref>). These two pieces of code are the only ones in the final executable that can still contain gadgets and, therefore, they must be carefully designed to prevent any possible attack.</p><p>The return address protection code is 11 bytes long and all bytes are under our control, with the exception of the 4-byte address of the random key, which could change for each compiled program and for shared libraries at each relocation. To ensure that the code is safe to use, we need to prevent this value from containing potentially dangerous instructions. In our implementation, we control the least significant two bytes by automatically inserting appropriate alignment directives into the assembled code when defining the key storage location, ensuring that the address always ends with the innocuous "0xf0 0x00" sequence. In addition, according to the Linux process memory layout, the most significant address byte of the .bss section (where we store our random key) is limited in practice to 0x08 for regular ELF executables and 0xb * for shared libraries <ref type="foot" target="#foot_0">1</ref> . Therefore, it encodes either a variation of a load immediate into register instruction (e.g., mov $IMM, %reg), or an or instruction between two 8-bit operands.</p><p>The indirect jump/call protection block is 19 bytes long and contains an additional 4-byte-long dynamic section, the per-function constant identifier we generate at compile time to compute the cookie. The example shown in Figure <ref type="figure">3</ref> (that uses a 0x0f0f1f76 function identifier) is entirely gadget-free because it contains no aligned or unaligned instruction sequences that would make it possible for an attacker to reach jmp * %edx without invalidating its contents. In fact, any logic/arithmetic operation that does not yield a result of zero (e.g., incl %ebp, unless %ebp overflows) clears the zero flag in the processor and prevents the use of the conditional jump jz .+4 (this instruction only jumps if the zero flag is set in the processor). Consequently, the value inside %edx is cleared.</p><p>Different values of the function identifier could potentially introduce a new and useful gadget; but since these constants can be arbitrarily chosen and do not need to be kept secret, we can easily work around problematic cases. In order to minimize the risk in the first place, we use simple heuristics such as using bytes that represent invalid opcodes (e.g., 0x0f 0x0f) and avoiding dangerous opcodes such as those encoding mov or free-branch instructions.</p><p>Figure <ref type="figure" target="#fig_2">4</ref> shows all the gadgets that can be extracted from our current system implementation. As can be seen, apart from the ability to load the %eax with a controlled value (popl %eax), the gadgets have no value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Compiling glibc</head><p>During our case study of compiling glibc using G-Free, we have encountered several issues requiring particular care. These were mostly related to unconventional programming practices used for dealing with low-level tasks, or manually optimized assembly code. This section explains our observations in this regard, and explains how we cope with these special cases.</p><p>Multiple Entry Points: We have come across various functions in glibc that include more than one possible entry point. Our system 50 pushl %eax a1 00 f0 fd b7 movl 0xb7fdf000, %eax 31 <ref type="bibr">44</ref>   successfully detects such functions and instruments all entry points with the appropriate headers. Additionally, we prepend each header that lies in the execution path of other entry points with a jump instruction to skip over the header, ensuring that only one header is executed per function call.</p><p>Functions that Access the Saved Return Address: In glibc, we have encountered a single function, namely setjmp that accesses the saved return address on the stack. setjmp, together with the function longjmp, is used for implementing non-local jumps: a call to setjmp saves the current stack context to restore it afterwards when longjmp is invoked. This behavior conflicts with our return address protection scheme. Since the return address is stored in an encrypted form on the stack, a call to setjmp saves the encrypted return address and a subsequent call to longjmp results in an illegal memory access. In order to solve this problem, we modified our prototype to detect when the saved return address is moved to a register and perform the decryption on the duplicated value to ensure correct functionality.</p><p>Jumps between Functions: In numerous cases, a function directly jumps to another one without saving the return address, essentially making that jump an exit point. During compilation, we check every jump destination to recognize jumps outside the current function and treat them as regular exit points for inserting the necessary footers. These footers are not meant to protect a freebranch instruction, since none follows, but to restore the return address to its original value before transferring the execution flow to another function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">EVALUATION</head><p>The main goal of our evaluation is to show that our technique can be applied to compile real-world applications and produce gadgetfree executables. To demonstrate that we are able accomplish this goal, we performed a set of experiments in which we measured the impact of our code transformations in terms of performance and size overheads of the binaries produced by our tool.</p><p>In our tests, we combined the G-Free pre-processor with gas 2.20 and GCC 4.4.3. All the experiments were performed on a 2GHz Intel Core 2 Duo T7300 machine with 2GB of memory, running Arch Linux (i686) with Linux kernel 2.6.33.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Compilation Results</head><p>Since ROP attacks usually extract their gadgets from common libraries, we focus our evaluation on glibc version 2.11.1. The original version compiled without G-Free contains 9921 ret instructions (6106 of which unaligned) and 8018 jmp * /call * instructions (6602 of which unaligned). This sums up to almost 18K free-branch opcodes, each of which can be potentially used by an attacker to build many different gadgets.</p><p>After we compiled glibc using our system, all unintended ret and jmp * /call * instructions were either removed or made ineffective by prepending them with an alignment sled. In addition, all aligned free-branch instructions were protected by adding our return and indirect jump/call protection blocks. As a result, the library compiled with G-Free contained only the four type of gadgets we present in Figure <ref type="figure" target="#fig_2">4</ref>.</p><p>However, due to the newly inserted code and instruction rewriting techniques, the size of the gadget-free version of the library increased by 30%. Although this value might appear to be high, one third of the overhead is caused by nop instructions included in the alignment sleds. As already discussed in Section 5, most of these could be eliminated by a more optimized implementation.</p><p>Unfortunately, providing a gadget-free version of glibc is not sufficient to completely prevent ROP attacks, since the attacker could still build the gadget set from other libraries or the application binary itself. Therefore, to achieve a complete protection  <ref type="table">3</ref>: Performance comparisons when the application and all the linked libraries are compiled with G-Free against ROP, it is necessary to compile the entire application and all the linked libraries with our technique. To demonstrate that our tool can be applied to this more general scenario, we include in our evaluation a number of common Linux applications.</p><p>Table <ref type="table" target="#tab_2">2</ref> shows statistics about the binaries compiled with G-Free. Our tool was able to successfully remove all unintended instructions and protect the aligned ones with an average size increase of 25.9% (more than half of which were caused by redundant nop instructions). The last two columns show that most of the functions can be protected by our very efficient return address encryption technique while very few of them required the more complex indirect jump/call protection block. This is a consequence of the fact that, according to what we observed in our experiments, programs rarely use jmp * /call * instructions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Performance Measurements</head><p>Table <ref type="table">3</ref> shows the performance overheads we measured by running the different applications compiled with our prototype (this includes the gadget-free versions of the programs and all their linked libraries). For each application, we designed a set of programspecific test cases, summarized in Column 2 of the table. The average performance overhead was 3.1% -a value comparable with the overhead caused by well known stack protection systems such as StackShield <ref type="bibr" target="#b35">[35]</ref> and StackGuard <ref type="bibr" target="#b11">[11]</ref>.</p><p>Since a library cannot be run as a standalone program, we evaluated the performance overhead of our gadget-free version of glibc using a set of well-known benchmarks. In particular, we downloaded and installed the Phoronix Test Suite <ref type="bibr" target="#b1">[1]</ref> which provides one of the most comprehensive benchmark sets for the Linux platform. Table <ref type="table" target="#tab_3">4</ref> lists a sample of the benchmarks that represent different application categories such as games, mathematical and physical simulations, 3D rendering, disk and file system activities, compression, and well-known server applications. The results indicate that the performance overhead of an application using our gadget-free version of glibc is on average 1.09%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSIONS</head><p>Return-oriented programming is an attack technique that recently attracted significant attention from the scientific community. Even though much research has been conducted on the topic, no comprehensive defense mechanism has been proposed to date.</p><p>In this paper we propose a novel, comprehensive solution to defend against return-oriented programming by removing all gadgets from a program binary at compile-time. Our approach targets all possible free-branch instructions, and, therefore, is independent from the techniques used to link the gadgets together. We implemented our solution in a prototype that we call G-Free, a preprocessor for the GNU Assembler. Our experiments show that G-Free is able to remove all gadgets at the cost of a very low performance overhead and an acceptable increase in the file size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Benchmark</head><p>Orig. Libc G-Free (Overhead) FS-Mark (Files/s) <ref type="bibr" target="#b15">15</ref> </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Examples of different gadgets that can be extracted from a real byte sequence</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Application of an alignment sled to prevent executing an unaligned ret (0xc3) instruction</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Gadgets available in the return address (A) and in the indirect jump/call (B) protection blocks</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Table</figDesc><table><row><cell>ModR/M</cell><cell cols="2">Operand 1</cell><cell>Operand 2</cell></row><row><cell>0xc2</cell><cell cols="3">%eax, %ax, %al %edx, %dx, %dl</cell></row><row><cell>0xc3</cell><cell cols="3">%eax, %ax, %al %ebx, %bx, %bl</cell></row><row><cell>0xca</cell><cell cols="3">%ecx, %cx, %cl %edx, %dx, %dl</cell></row><row><cell>0xcb</cell><cell cols="3">%ecx, %cx, %cl %ebx, %bx, %bl</cell></row><row><cell></cell><cell>SIB</cell><cell cols="2">Base Scaled Index</cell></row><row><cell></cell><cell>0xc2</cell><cell>%edx</cell><cell>%eax * 8</cell></row><row><cell></cell><cell>0xc3</cell><cell>%ebx</cell><cell>%eax * 8</cell></row><row><cell></cell><cell>0xca</cell><cell>%edx</cell><cell>%ecx * 8</cell></row><row><cell></cell><cell>0xcb</cell><cell>%ebx</cell><cell>%ecx * 8</cell></row><row><cell></cell><cell></cell><cell></cell><cell>To</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>Statistics on binaries compiled with G-Free (RAP=Return Address Protection, JCP=indirect Jump/Call Protection)</figDesc><table><row><cell>Program Name</cell><cell cols="2">Original</cell><cell>G-Free Size</cell><cell>Unaligned</cell><cell>Unaligned</cell><cell>Number of</cell><cell>Number of</cell></row><row><cell>and Version</cell><cell cols="2">Size(KB)</cell><cell>(Overhead)</cell><cell>ret</cell><cell cols="3">jmp * /call * functions with RAP functions with JCP</cell></row><row><cell>glibc 2.11.1</cell><cell cols="2">1320.4</cell><cell>1728.4 (30.9%)</cell><cell>6106</cell><cell>6602</cell><cell>2817</cell><cell>827</cell></row><row><cell>gzip 1.4</cell><cell></cell><cell>72.7</cell><cell>92.4 (27.0%)</cell><cell>433</cell><cell>410</cell><cell>122</cell><cell>10</cell></row><row><cell>grep 2.6.3</cell><cell></cell><cell>86.3</cell><cell>106.3 (23.2%)</cell><cell>523</cell><cell>369</cell><cell>174</cell><cell>20</cell></row><row><cell>dd coreutils-8.5</cell><cell></cell><cell>48.0</cell><cell>57.9 (20.6%)</cell><cell>252</cell><cell>181</cell><cell>95</cell><cell>8</cell></row><row><cell>md5sum coreutils-8.5</cell><cell></cell><cell>30.9</cell><cell>37.7 (22.1%)</cell><cell>203</cell><cell>86</cell><cell>68</cell><cell>3</cell></row><row><cell>ssh-keygen openssh-5.5p1</cell><cell></cell><cell>140.6</cell><cell>182.5 (29.7%)</cell><cell>607</cell><cell>712</cell><cell>271</cell><cell>20</cell></row><row><cell>lame 3.98.3</cell><cell></cell><cell>322.6</cell><cell>406.6 (26.0%)</cell><cell>2228</cell><cell>1342</cell><cell>669</cell><cell>28</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Execution Time (seconds)</cell></row><row><cell cols="2">Program Name</cell><cell cols="2">Test case</cell><cell cols="3">Original Version G-Free Version (Overhead)</cell></row><row><cell>gzip</cell><cell></cell><cell cols="2">Compress a 2GB file</cell><cell></cell><cell>66.5</cell><cell>68.4 (2.9%)</cell></row><row><cell>grep</cell><cell></cell><cell cols="2">Search in a 2GB file</cell><cell></cell><cell>81.3</cell><cell>82.9 (2.0%)</cell></row><row><cell>dd</cell><cell></cell><cell cols="3">Create a 2GB zero-filled file</cell><cell>86.6</cell><cell>88.9 (2.6%)</cell></row><row><cell>md5sum</cell><cell></cell><cell cols="3">Compute hash of a 2GB file</cell><cell>82.5</cell><cell>82.9 (0.6%)</cell></row><row><cell>ssh-keygen</cell><cell></cell><cell cols="3">Generate 100 2048-bit RSA keys</cell><cell>51.2</cell><cell>53.6 (4.6%)</cell></row><row><cell>lame</cell><cell></cell><cell cols="3">Encode a 10 min long wav file</cell><cell>115.5</cell><cell>122.0 (5.6%)</cell></row><row><cell>Table</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 4 :</head><label>4</label><figDesc>Performance comparison of the original and G-Free glibc using benchmarks from the Phoronix Test Suite</figDesc><table><row><cell></cell><cell>.1</cell><cell>14.9 (1.3%)</cell></row><row><cell>IOzone-write (MB/s)</cell><cell>22.8</cell><cell>22.6 (0.4%)</cell></row><row><cell>IOzone-read (MB/s)</cell><cell>23.0</cell><cell>22.7 (1.4%)</cell></row><row><cell>Dbench (MB/s)</cell><cell>83.7</cell><cell>82.0 (2.0%)</cell></row><row><cell>Minion (s)</cell><cell>250.2</cell><cell>250.7 (0.2%)</cell></row><row><cell>Sudokut (s)</cell><cell>97.1</cell><cell>100.4 (3.5%)</cell></row><row><cell>TSCP (Nodes/s)</cell><cell>224642.0</cell><cell>224385.0 (0.1%)</cell></row><row><cell>GMPbench (Score)</cell><cell>2955.5</cell><cell>2954.5 (0.03%)</cell></row><row><cell>BYTE (Lines/s)</cell><cell>7288371.3</cell><cell>6948792.8 (4.6%)</cell></row><row><cell>PyBench (s)</cell><cell>6791.0</cell><cell>6959.0 (2.5%)</cell></row><row><cell>PHP Comp (s)</cell><cell>102.9</cell><cell>107.3 (4.3%)</cell></row><row><cell>7-Zip (MIPS)</cell><cell>2822.0</cell><cell>2802 (0.7%)</cell></row><row><cell>Unpack Linux Kernel (s)</cell><cell>30.30</cell><cell>31.01 (2.3%)</cell></row><row><cell>LZMA (s)</cell><cell>291.67</cell><cell>291.86 (0.01%)</cell></row><row><cell>BZIP2 (s)</cell><cell>65.63</cell><cell>65.84 (0.3%)</cell></row><row><cell>FLAC Audio Encoding (s)</cell><cell>12.96</cell><cell>13.09 (1.0%)</cell></row><row><cell>Ogg Encoding (s)</cell><cell>27.14</cell><cell>27.20 (0.2%)</cell></row><row><cell>Himeno (MFLOPS)</cell><cell>152</cell><cell>151.44 (0.4%)</cell></row><row><cell>dcraw (s)</cell><cell>52.68</cell><cell>52.99 (0.6%)</cell></row><row><cell>Bullet Physics Engine (s)</cell><cell>39.58</cell><cell>39.74 (0.4%)</cell></row><row><cell>Timed MAFFT (s)</cell><cell>52.48</cell><cell>52.55 (0.1%)</cell></row><row><cell>PostgreSQL (Trans/s)</cell><cell>155.24</cell><cell>156.66 (0.9%)</cell></row><row><cell>SQLite (s)</cell><cell>189.09</cell><cell>191.78 (1.4%)</cell></row><row><cell>Apache(Requests/s)</cell><cell>7129.05</cell><cell>6836.24 (4.1%)</cell></row><row><cell>x2642009 (Frames/s)</cell><cell>13.72</cell><cell>13.62 (0.7%)</cell></row><row><cell>GtkPerf (s)</cell><cell>20.89</cell><cell>20.49 (1.9%)</cell></row><row><cell>x11perf (Operations/s)</cell><cell>912000</cell><cell>912000 (0.0%)</cell></row><row><cell>Urban Terror (Frames/s)</cell><cell>34.20</cell><cell>34.05 (0.9%)</cell></row><row><cell>OpenArena (Frames/s)</cell><cell>46.93</cell><cell>46.67 (0.6%)</cell></row><row><cell>C-Ray (s)</cell><cell>553.7</cell><cell>554.0 (0.05%)</cell></row><row><cell>FFmpeg (s)</cell><cell>24.93</cell><cell>25.02 (0.4%)</cell></row><row><cell>GraphicsMagick (Iter/min)</cell><cell>45</cell><cell>44 (2.2%)</cell></row><row><cell>OpenSSL (Signs/s)</cell><cell>25.28</cell><cell>25.28 (0.0%)</cell></row><row><cell>Gcrypt Library (micros)</cell><cell>6963</cell><cell>6983 (0.3%)</cell></row><row><cell>John The Ripper (Real C/S)</cell><cell>1854667</cell><cell>1857333 (0.1%)</cell></row><row><cell>GnuPG (s)</cell><cell>20.46</cell><cell>20.67 (1.0%)</cell></row><row><cell>Timed HMMer Search (s)</cell><cell>88.93</cell><cell>89.31 (0.4%)</cell></row><row><cell>Bwfirt (s)</cell><cell>284.9</cell><cell>285.3 (0.2%)</cell></row><row><cell>Average:</cell><cell></cell><cell>1.09%</cell></row><row><cell>Std:</cell><cell></cell><cell>1.27</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The Linux process memory layout dictates that dynamic shared libraries are loaded at the address range 0xc0000000-0x40000000, starting from higher addresses. As a result, in practice almost any shared library has 0xb * as the most significant address byte of its .bss section.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGMENTS</head><p>The research leading to these results was partially funded from the European Union Seventh Framework Programme (FP7/2007-2013) under grant agreement nř 257007. This work has also been supported in part by the European Commission through project IST-216026-WOMBAT funded under the 7th framework program. This publication reflects the views only of the authors, and the Commission cannot be held responsible for any use which may be made of the information contained therein. We would also like to thank Secure Business Austria for their support for this research.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="http://www.phoronix-test-suite.com/" />
		<title level="m">Phoronix test suite</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Rop attack against data execution prevention technology</title>
		<ptr target="http://www.h-online.com/security/news/item/Exploit-s-new-technology-trick-%dodges-memory-protection-959253.html" />
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName><surname>Symantec</surname></persName>
		</author>
		<ptr target="http://www4.symantec.com/Vrt/wl?tu_id=jLac123913792490340803" />
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
	<note type="report_type">Internet Security Threat Report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<ptr target="http://www.intel.com/products/processor/manuals/" />
		<title level="m">Intel 64 and IA-32 Architectures Software Developer&apos;s Manuals</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Smashing the stack for fun and profit</title>
		<author>
			<persName><forename type="first">Aleph</forename><surname>One</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Phrack Magazine n</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">49</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">When Good Instructions Go Bad: Generalizing Return-Oriented Programming to RISC</title>
		<author>
			<persName><forename type="first">E</forename><surname>Buchanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Roemer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Savage</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th ACM Conference on Computer and Communications Security (CCS)</title>
		<meeting>the 15th ACM Conference on Computer and Communications Security (CCS)</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Can DREs Provide Long-Lasting Security? The Case of Return-Oriented Programming and the AVC Advantage</title>
		<author>
			<persName><forename type="first">S</forename><surname>Checkoway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Feldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kantor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Halderman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Felten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings</title>
		<meeting>null</meeting>
		<imprint>
			<publisher>USENIX/ACCURATE/IAVoSS</publisher>
			<date type="published" when="2009">2009. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Escape from return-oriented programming: Return-oriented programming without returns (on the x86)</title>
		<author>
			<persName><forename type="first">S</forename><surname>Checkoway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Drop: Detecting return-oriented programming malicious code</title>
		<author>
			<persName><forename type="first">P</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Xie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">PointGuard: Protecting Pointers from Buffer Overflow Vulnerabilities</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cowan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Beattie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Johansen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wagle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th Usenix Security Symposium</title>
		<meeting>the 12th Usenix Security Symposium</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">StackGuard: Automatic adaptive detection and prevention of buffer-overflow attacks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cowan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Walpole</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bakke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Beattie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Grier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wagle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hinton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7 th USENIX Security Symposium</title>
		<meeting>the 7 th USENIX Security Symposium<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Buffer overflows: Attacks and Defenses for the Vulnerability of the Decade</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cowan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wagle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Beattie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Walpole</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the DARPA Information Survivability Conference and Exposition</title>
		<meeting>the DARPA Information Survivability Conference and Exposition</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Dynamic integrity measurement and attestation: Towards defense against return-oriented programming attacks</title>
		<author>
			<persName><forename type="first">L</forename><surname>Davi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Winandy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ACM workshop on Scalable trusted computing</title>
		<meeting>ACM workshop on Scalable trusted computing</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Confidence 2.0,. Developments in Cisco IOS forensics</title>
		<author>
			<persName><forename type="first">Felix</forename><surname>Lidner</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Code injection attacks on harvard-architecture devices</title>
		<author>
			<persName><forename type="first">A</forename><surname>Francillon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Castelluccia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CCS</title>
		<meeting>CCS</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Defending embedded systems against control flow attacks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Francillon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Perito</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Castelluccia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the first ACM workshop on Secure execution of untrusted code</title>
		<meeting>the first ACM workshop on Secure execution of untrusted code</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Stackghost: Hardware facilitated stack protection</title>
		<author>
			<persName><forename type="first">M</forename><surname>Frantsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shuey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of USENIX security</title>
		<meeting>USENIX security</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">GCC Extension for Protecting Applications from Stack-Smashing Attacks (ProPolice)</title>
		<author>
			<persName><forename type="first">Hiroaki</forename><surname>Etoh</surname></persName>
		</author>
		<ptr target="http://www.trl.ibm.com/projects/security/ssp/" />
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Return-Oriented Rootkits: Bypassing Kernel Code Integrity Protection Mechanisms</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Holz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Freiling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th USENIX Security Symposium</title>
		<meeting>the 18th USENIX Security Symposium<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Secure execution via program shepherding</title>
		<author>
			<persName><forename type="first">V</forename><surname>Kiriansky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bruening</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Amarasinghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th USENIX Security Symposium</title>
		<meeting>the 11th USENIX Security Symposium<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="191" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Defeating Return-Oriented Rootkits with Return-less Kernels</title>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Grace</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bahram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th ACM SIGOPS EuroSys Conference</title>
		<meeting>the 5th ACM SIGOPS EuroSys Conference</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Ropdefender: A detection tool to defend against return-oriented programming attacks</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Lucas Davi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ahmad-Reza</forename><surname>Sadeghi</surname></persName>
		</author>
		<idno>HGI-TR-2010-001</idno>
		<imprint/>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The advanced return-into-lib(c) exploits</title>
		<author>
			<persName><surname>Nergal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Phrack Magazine n</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">58</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Guest-transparent prevention of kernel rootkits with vmm-based memory shadowing</title>
		<author>
			<persName><forename type="first">R</forename><surname>Riley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RAID &apos;08: Proceedings of the 11th international symposium on Recent Advances in Intrusion Detection</title>
		<meeting><address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="1" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Surgically returning to randomized lib(c)</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">F</forename><surname>Roglia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Martignoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Paleari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bruschi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25 th Annual Computer Security Applications Conference (ACSAC)</title>
		<meeting>the 25 th Annual Computer Security Applications Conference (ACSAC)<address><addrLine>Honolulu, Hawaii, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2009-12">Dec. 2009</date>
			<biblScope unit="page" from="60" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Exploiting format string vulnerabilities</title>
		<author>
			<persName><forename type="first">Team</forename><surname>Scut</surname></persName>
		</author>
		<author>
			<persName><surname>Teso</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">x86-64 buffer overflow exploits and the borrowed code chunks exploitation technique</title>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Krahmer</surname></persName>
		</author>
		<ptr target="http://www.suse.de/~krahmer/no-nx.pdf" />
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Secvisor: A tiny hypervisor to provide lifetime kernel code integrity for commodity oses</title>
		<author>
			<persName><forename type="first">A</forename><surname>Seshadri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Luk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Qu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Operating System Symposium SOSP</title>
		<meeting>Operating System Symposium SOSP</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The Geometry of Innocent Flesh on the Bone: Return-into-libc without Function Calls (on the x86)</title>
		<author>
			<persName><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th ACM Conference on Computer and Communications Security (CCS)</title>
		<meeting>the 14th ACM Conference on Computer and Communications Security (CCS)</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">On the effectiveness of address-space randomization</title>
		<author>
			<persName><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Page</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pfaff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E.-J</forename><surname>Goh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Modadugu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th ACM Conference on Computer and Communications Security (CSS)</title>
		<meeting>the 11th ACM Conference on Computer and Communications Security (CSS)</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Solar Designer. return-to-libc attack</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
	<note>bugtraq</note>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Pax address space layout randomization</title>
		<author>
			<persName><forename type="first">The</forename><surname>Pax</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Team</forename></persName>
		</author>
		<ptr target="http://pax.grsecurity.net/docs/aslr.txt" />
		<imprint/>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Pax non-executable pages</title>
		<ptr target="http://pax.grsecurity.net/docs/noexec.txt" />
		<imprint/>
		<respStmt>
			<orgName>The PaX Team</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Return oriented programming for the arm architecture</title>
		<author>
			<persName><forename type="first">Tim</forename><surname>Kornau</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
		<respStmt>
			<orgName>Ruhr-Universität Bochum</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">A &quot;stack smashing&quot; technique protection tool for linux</title>
		<author>
			<persName><surname>Vendicator</surname></persName>
		</author>
		<author>
			<persName><surname>Stackshield</surname></persName>
		</author>
		<ptr target="http://www.angelfire.com/sk/stackshield/" />
		<imprint/>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Countering kernel rootkits with lightweight hook protection</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th ACM Conference on Computer and Communications Security</title>
		<meeting>the 16th ACM Conference on Computer and Communications Security</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
