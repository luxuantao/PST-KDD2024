<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">EME * : extending EME to handle arbitrary-length messages with associated data</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2004-05-27">May 27, 2004</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Shai</forename><surname>Halevi</surname></persName>
							<email>shaih@watson.ibm.com</email>
							<affiliation key="aff0">
								<orgName type="institution">IBM T.J. Watson Research Center</orgName>
								<address>
									<postBox>P.O. Box 704</postBox>
									<postCode>10598</postCode>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sp</forename><forename type="middle">←</forename><surname>Ppp</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">IBM T.J. Watson Research Center</orgName>
								<address>
									<postBox>P.O. Box 704</postBox>
									<postCode>10598</postCode>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><surname>Mp</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">IBM T.J. Watson Research Center</orgName>
								<address>
									<postBox>P.O. Box 704</postBox>
									<postCode>10598</postCode>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">IBM T.J. Watson Research Center</orgName>
								<address>
									<postBox>P.O. Box 704</postBox>
									<postCode>10598</postCode>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">←</forename><surname>Ppp</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">IBM T.J. Watson Research Center</orgName>
								<address>
									<postBox>P.O. Box 704</postBox>
									<postCode>10598</postCode>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">IBM T.J. Watson Research Center</orgName>
								<address>
									<postBox>P.O. Box 704</postBox>
									<postCode>10598</postCode>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">IBM T.J. Watson Research Center</orgName>
								<address>
									<postBox>P.O. Box 704</postBox>
									<postCode>10598</postCode>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">⊕</forename><surname>Sp ⊕ H K</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">IBM T.J. Watson Research Center</orgName>
								<address>
									<postBox>P.O. Box 704</postBox>
									<postCode>10598</postCode>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">R</forename><surname>| = N Then Mc</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">IBM T.J. Watson Research Center</orgName>
								<address>
									<postBox>P.O. Box 704</postBox>
									<postCode>10598</postCode>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">←</forename><surname>Mp</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">IBM T.J. Watson Research Center</orgName>
								<address>
									<postBox>P.O. Box 704</postBox>
									<postCode>10598</postCode>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">IBM T.J. Watson Research Center</orgName>
								<address>
									<postBox>P.O. Box 704</postBox>
									<postCode>10598</postCode>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">IBM T.J. Watson Research Center</orgName>
								<address>
									<postBox>P.O. Box 704</postBox>
									<postCode>10598</postCode>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">⊕</forename><surname>Mc</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">IBM T.J. Watson Research Center</orgName>
								<address>
									<postBox>P.O. Box 704</postBox>
									<postCode>10598</postCode>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">IBM T.J. Watson Research Center</orgName>
								<address>
									<postBox>P.O. Box 704</postBox>
									<postCode>10598</postCode>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">←</forename><surname>Mc</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">IBM T.J. Watson Research Center</orgName>
								<address>
									<postBox>P.O. Box 704</postBox>
									<postCode>10598</postCode>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">IBM T.J. Watson Research Center</orgName>
								<address>
									<postBox>P.O. Box 704</postBox>
									<postCode>10598</postCode>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sc</forename><forename type="middle">←</forename><surname>Ccc</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">IBM T.J. Watson Research Center</orgName>
								<address>
									<postBox>P.O. Box 704</postBox>
									<postCode>10598</postCode>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">⊕</forename><surname>Sc ⊕ H K</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">IBM T.J. Watson Research Center</orgName>
								<address>
									<postBox>P.O. Box 704</postBox>
									<postCode>10598</postCode>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><surname>Mc J ← Ccc</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">IBM T.J. Watson Research Center</orgName>
								<address>
									<postBox>P.O. Box 704</postBox>
									<postCode>10598</postCode>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">EME * : extending EME to handle arbitrary-length messages with associated data</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2004-05-27">May 27, 2004</date>
						</imprint>
					</monogr>
					<idno type="MD5">7A462FF71A5F7086E7AD044B2EB80379</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T04:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work describes a mode of operation, EME * , that turns a regular block cipher into a length-preserving enciphering scheme for messages of (almost) arbitrary length. Specifically, the resulting scheme can handle any bit-length, not shorter than the block size of the underlying cipher, and it also handles associated data of arbitrary bit-length. Such a scheme can either be used directly in applications that need encryption but cannot afford length expansion, or serve as a convenient building block for higher-level modes.</p><p>The mode EME * is a refinement of the EME mode of Halevi and Rogaway, and it inherits the efficiency and parallelism from the original EME.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introductions</head><p>Adding secrecy protection to existing (legacy) protocols and applications raises some unique problems. One of these problems is that existing protocols sometimes require that the encryption be "transparent", and in particular preclude length-expansion. One example is encryption of storage data "at the sector level", where both the higher-level operating system and the lower-level disk expect the data to be stored in blocks of 512 bytes, and so any encryption method would have to accept 512-byte plaintext and produce 512-byte ciphertext.</p><p>Clearly, insisting on a length-preserving (and hence deterministic) transformation has many drawbacks. Indeed, even the weakest acceptable notion of "secure encryption" (i.e., semantic security <ref type="bibr" target="#b4">[5]</ref>) cannot be achieved by deterministic encryption. Still, there may be cases where lengthpreservation is a hard requirement (due to technical, economical or even political constrains), and in such cases one may want to use some encryption scheme that gives better protection than no encryption at all. The strongest notions of security for a length-preserving transformation is "strong pseudo-random permutation" (SPRP) as defined by Luby and Rackoff <ref type="bibr" target="#b9">[10]</ref>, and its extension to "tweakable SPRP" by Liskov et al. <ref type="bibr" target="#b8">[9]</ref>. A "tweak" is an additional input to the enciphering and deciphering procedures that need not be kept secret. This report uses the terms "tweak" and "associated data" pretty much interchangeably, except that "associated data" hints that it can be of arbitrary length, whereas "tweak" is sometimes thought of as a fixed-length quantity.</p><p>Motivated by the application for "sector level encryption", some efficient modes of operation that implement "tweakable SPRP" on large blocks were recently described by Halevi and Rogaway <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7]</ref>. As "general purpose modes", however, these modes are somewhat limited, in that they can only be applied to input messages whose size is a multiple of n, the block-size of the underlying cipher. Also, the mode CMC from <ref type="bibr" target="#b5">[6]</ref> is inherently sequential (and it was only proven secure against attack model where all the messages are of the same length), and the mode EME from <ref type="bibr" target="#b6">[7]</ref> is limited to messages of at most n 2 bits. The current work is aimed at eliminating these limitations.</p><p>The mode EME * , presented below, takes a standard cipher with n-bit blocks and turns it into a tweakable enciphering scheme with message space M = {0, 1} n+ (i.e., any string of at least n bits) and tweak space T = {0, 1} * . The key for EME * consists of one key of the underlying cipher and two additional n-bit blocks. The mode EME * has similar structure to the mode EME from <ref type="bibr" target="#b6">[7]</ref>. Roughly, it consists of two layers of masked ECB encryption, with a layer of "lightweight mixing" in between. As a consequence, EME * is highly parallelizeable, <ref type="foot" target="#foot_0">1</ref> and also quite work-efficient. Processing an mblock query with ℓ blocks of associated data takes at most ℓ + 2m + ⌈m/n⌉ block encryptions (or decryptions). (We note that another mode for arbitrary-length messages, following the Luby-Rackoff approach, was recently proposed by McGrew and Viaga <ref type="bibr" target="#b10">[11]</ref>.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">What about very short blocks?</head><p>The mode EME * can handle blocks of any bit-length but not less that the block size of the underlying cipher. The underlying structure of EME * , being based on ECB encryption, does not lend itself to handling shorter blocks. In fact, in my opinion there is no good solution today for handling arbitrary short blocks. The solutions that I am aware of are the following:</p><p>• For blocks that are not too short (say, at least 64 bits), one can simply switch to using a different block cipher. For example, one could use EME * [AES] to process blocks that are 128 bits or more, and use a separately keyed EME * [3DES] to handle blocks of length between 64 and 127 bits.</p><p>This solution, however, is quite expensive, as it mandates the implementation of two different ciphers. (Of course, one could use EME * [3DES] also to handle longer messages, but then the security parameter would be much reduced.) Moreover this solution does not address blocks shorter than 64 bits.</p><p>• For very short blocks (e.g., one byte) it is possible to pre-compute a pseudorandom permutation and store it in a table. This approach, however, clearly runs out of steam for blocks longer than two bytes, and it is extremely wasteful of space even before that. (Also, it is not clear how to incorporate a "tweak" into this approach.)</p><p>• Alternatively, one could apply the Luby-Rackoff construction to implement the narrow-block cipher, using the underlying cipher for the pseudorandom functions. (Indeed, the ABL mode of McGrew and Viaga <ref type="bibr" target="#b10">[11]</ref> does just that.) This solution extends to handle messages of any length, but at a price of a severely reduced security-parameter. For example, although 128-bit blocks may enjoy "128 bits of security", 127-bit blocks only enjoy "63 bits of security". Even worse, 64-bit blocks have to make due with a pathetic "32 bits of security".</p><p>It is possible to use six or more rounds of the Luby-Rackoff construction to make the security parameter a little less miserable (cf. Patarin's work <ref type="bibr" target="#b11">[12]</ref>), but the price is an extremely slow mode for small blocks.</p><p>• Another approach is to use a parameterizable cipher (e.g., RC5 <ref type="bibr" target="#b12">[13]</ref>) as the underlying block cipher. Parameterizable ciphers can be instantiated to handle various block sizes, so in particular they can be used in their narrow-block instantiation to handle the small blocks. However, to the best of my knowledge there is a fairly small number of such ciphers, and they were never seriously analyzed for small blocks. So it unlikely that they provide very good security, especially in the very small block sizes. Worse still, it is likely that using the same key for different block sizes would have disastrous consequences.</p><p>I view the problem of handling arbitrary small blocks as wide open. The two plausible approaches for addressing it are either to design a mode of operation with good security-performance tradeoff for small blocks, or to design an efficient block cipher that can handle small blocks securely. I believe that a good cipher is more likely to be possible than a good mode of operation (but perhaps this is only because I know more about modes of operation than about block ciphers.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Organization</head><p>Section 2 recalls some standard definitions (this section is taken almost verbatim from <ref type="bibr" target="#b6">[7]</ref>). Section 3 describes the EME * mode with a brief discussion of the extensions of EME * over EME. The security of EME * is stated in Section 4 and proven in the appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>Basics. A tweakable enciphering scheme is a function E: K × T × M → M where M = i∈I {0, 1} i is the message space (for some nonempty index set I ⊆ N) and K = ∅ is the key space and T = ∅ is the tweak space. We require that for every K ∈ K and T ∈ T we have that E(K, T, •) = E T K (•) is a length-preserving permutation on M. The inverse of an enciphering scheme E is the enciphering scheme</p><formula xml:id="formula_0">D = E -1 where X = D T K (Y ) if and only if E T K (X) = Y .</formula><p>A block cipher is the special case of a tweakable enciphering scheme where the message space is M = {0, 1} n (for some n ≥ 1) and the tweak space is T = {ε} (the empty string). The number n is called the blocksize. By Perm(n) we mean the set of all permutations on {0, 1} n . By Perm T (M) we mean the set of all functions π: T × M → M where π(T, •) is a length-preserving permutation.</p><p>An adversary A is a (possibly probabilistic) algorithm with access to some oracles. Oracles are written as superscripts. By convention, the running time of an algorithm includes its description size. The notation A ⇒ 1 describes the event that the adversary A outputs the bit one.</p><p>Security measure. For a tweakable enciphering scheme E: K × T × M → M we consider the advantage that the adversary A has in distinguishing E and its inverse from a random tweakable permutation and its inverse:</p><formula xml:id="formula_1">Adv ± prp E (A) = Pr K $ ← K : A E K (•,•) E -1 K (•,•) ⇒ 1 -Pr π $ ← Perm T (M) : A π(•,•) π -1 (•,•) ⇒ 1</formula><p>The notation shows, in the brackets, an experiment to the left of the colon and an event to the right of the colon. We are looking at the probability of the indicated event after performing the specified experiment. By X $ ← X we mean to choose X at random from the finite set X . In writing ± prp the tilde serves as a reminder that the PRP is tweakable and the ± symbol is a reminder that this is the "strong" (chosen plaintext/ciphertext attack) notion of security. For a block cipher, we omit the tilde.</p><p>Without loss of generality we assume that an adversary never repeats an encipher query, never repeats a decipher query, never queries its deciphering oracle with (T, C) if it got C in response to some (T, M ) encipher query, and never queries its enciphering oracle with (T, M ) if it earlier got M in response to some (T, C) decipher query. We call such queries pointless because the adversary "knows" the answer that it should receive.</p><p>When R is a list of resources and Adv xxx Π (A) has been defined, we write Adv xxx Π (R) for the maximal value of Adv xxx Π (A) over all adversaries A that use resources at most R. Resources of interest are the running time t and the number of oracle queries q and the query complexity σ n (where n ≥ 1 is a number). The query complexity σ n is just the total number of n-bit blocks in all the queries that the adversary makes (including both the data and the associated data). Namely, the query complexity of any one call (T, P ) is ⌈|T |/n⌉ + ⌈|P |/n⌉, and the query complexity of an attack is the sum of the query complexity of all the calls. The name of an argument (e.g., t, q, or σ n ) will be enough to make clear what resource it refers to.</p><p>Finite fields. We interchangeably view an n-bit string as: a string; a nonnegative integer less than 2 n (msb first); a formal polynomial over GF(2) (with the coefficient of x n-1 first and the free term last); and an abstract point in the finite field GF(2 n ). To do addition on field points, one xors their string representations. To do multiplication on field points, one must fix a degree-n irreducible polynomial. We choose to use the lexicographically first primitive polynomial of minimum weight. For n = 128 this is the polynomial x 128 + x 7 + x 2 + x + 1. See <ref type="bibr" target="#b2">[3]</ref> for a list of the indicated polynomials. We note that with this choice of field-point representations, the point x = 0 n-2 10 = 2 will always have order 2 n -1 in the multiplicative group of GF(2 n ), meaning that 2, 2 2 , 2 3 , . . . , 2 2 n -1 are all distinct. Finally, we note that given</p><formula xml:id="formula_2">L = L n-1 • • • L 1 L 0 ∈ {0, 1} n it</formula><p>is easy to compute 2L. We illustrate the procedure for n = 128, in which case 2L = L&lt; &lt;1 if firstbit(L) = 0, and 2L = (L&lt; &lt;1) ⊕ Const87 if firstbit(L) = 1. Here Const87 = 0 120 10 4 1 3 and firstbit(L) means L n-1 and L&lt; &lt;1 means</p><formula xml:id="formula_3">L n-2 L n-3 • • • L 1 L 0 0. 3 Specification of EME * Mode Consider a block cipher E: K × {0, 1} n → {0, 1} n . Then EME * [E]: (K × {0, 1} 2n ) × T × M → M</formula><p>is an enciphering scheme with associated data, where K is the same as the underlying cipher, T = {0, 1} 0..n(2 n -3) , and M = {0, 1} n..n(2 n -2) . In words, the key for EME * [E] consists of one key K of the underlying block cipher E and two n-bit blocks, L and R. EME * [E] accepts messages of any bit length grater than or equal to n (but no more than n(2 n -2)), and associated data of arbitrary bit-length (but no more than n(2 n -3)). Obviously, in practical terms the upper limits are no limitation at all. </p><formula xml:id="formula_4">: K × {0, 1} n → {0, 1} n is a block cipher. The associated data is T ∈ {0, 1} * , the plaintext is P = P 1 • • • P m and the ciphertext is C = C 1 • • • C m . . . . . . . 2M 1 P n+3 PPP n+3 CCC n+3 C n+3 pad pad 2 n-1 M 1 CCC n PPP n C n P n CC n M 1 M 1 PP n H SC ⊕ T SP ⊕ T T Associated data MM 2 n-1 L 2 n L 2 n+1 L 2 n+1 L PPP n+2 2M 2 P n+2 C n+2 PP n+2 CC n+2 CCC n+2 2 n-1 L 2 n L PPP n+1 P n+1 PP n+1 MC 2 MP 2 CC n+1 CCC n+1 C n+1 2L CC 2 CCC 2 C 2 PPP 2 PP 2 2L P 2 P 1 MC 1 L CCC 1 CC 1 C 1 MP 1 PPP 1 PP 1 L MM Figure 2:</formula><p>Enciphering under EME * a buffer with n + 2 full blocks and one partial block. The boxes represent E K . We set the masks as</p><formula xml:id="formula_5">SP = PPP 2 ⊕ • • • PPP n+3 , M i = MP i ⊕ MC i , and SC = CCC 2 ⊕ • • • ⊕ CCC n+3 .</formula><p>The scheme EME * [E] follows the same general principles of the tweakable scheme EME from <ref type="bibr" target="#b6">[7]</ref>. Roughly, it consists of two layers of masked ECB encryption, with a layer of "lightweight mixing" in between. A complete specification of the enciphering scheme EME * [E] is given in Figure <ref type="figure" target="#fig_0">1</ref>, and an illustration (for a message of n + 2 full blocks and one partial block) is provided in Figure <ref type="figure">2</ref>. For those familiar with EME, the differences between EME and EME * are as follows:</p><p>• Hashing the "tweak". The original EME scheme requires that the "tweak value" be an n-bit string, whereas here we allow associated data of any length. For this purpose, we hash the associated data to an n-bit string. The hash function need only be xor-universal, yet I chose to implement it using the underlying block cipher in a PMAC-like mode <ref type="bibr" target="#b1">[2]</ref>.</p><p>• More than one mask. The EME scheme uses (multiples of) a single mask value M in the "lightweight masking" layer. It was shown in <ref type="bibr" target="#b6">[7]</ref>, however, that this masking technique with just one mask cannot be used for messages longer than n<ref type="foot" target="#foot_1">2</ref> bits.</p><p>Longer messages are handled in EME * using the approach that was proposed in the appendix of <ref type="bibr" target="#b6">[7]</ref>. The message is broken to chunks of at most n 2 bits each, and a different mask value is used for every chunk. To handle the last partial block (if any), yet another mask is computed and xor-ed into the last partial plaintext block, thus getting the last partial ciphertext block.</p><p>We comment that it is possible to derive the two key blocks L, R from the cipher key K, say by setting L = 2E K (0) and R = 3E K (0). 2 The proof below does not prove this variant, since proving it would mean adding a few more pages to a proof that is already way too long.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Security of EME *</head><p>The following theorem relates the advantage of an adversary in attacking EME * [E] to the advantage an adversary in attacking the block cipher E.</p><p>Theorem 1 [EME * security] Any adversary that tries to distinguish EME * [Perm(n)] from a truly random tweakable length-preserving permutation, using at most q queries totaling at most σ n blocks (some of which may be partial), has advantage at most (2.5σ n + 3q) 2 /2 n+1 . Using the notations from Section 2, we have</p><formula xml:id="formula_6">Adv ± prp EME * [Perm(n)] (q, σ n ) ≤ (2.5σ n + 3q) 2 2 n+1<label>(1)</label></formula><p>Corollary 1 Fix n, t, q, σ n ∈ N and a block cipher E: K × {0, 1} n → {0, 1} n . Then</p><formula xml:id="formula_7">Adv ± prp EME * [E] (t, q, σ n ) ≤ (2.5σ n + 3q) 2 2 n+1 + 2 Adv ±prp E t ′ , 2q + (2 + 1 n )σ n where t ′ = t + O(nσ n ).<label>2</label></formula><p>Note that the theorem and corollary do not restrict messages to one particular length: proven security is for a variable-input-length (VIL) cipher, not just fixed-input-length (FIL) one. The proof of Theorem 1 is given in Appendix A. Corollary 1 embodies the standard way to pass from the information-theoretic setting to the complexity-theoretic one.</p><p>A Proof of Theorem 1 -Security of EME * A personal comment. The proof below spans more than 23 pages, and as much as I tried to simplify and to explain clearly, it is quite a pain to read. Frankly, I don't believe that anyone will ever go through the trouble of reading and verifying it. Assuming this is the case, one can still get some assurance in the correctness of the mode, even from a proof that no one reads: At least it implies that the author went carefully through all the different cases and was convinced that they all work. Indeed, the proof below uses the same mechanism that was used to prove CMC <ref type="bibr" target="#b5">[6]</ref> and EME <ref type="bibr" target="#b6">[7]</ref>, and this mechanism in effect forces one to cover all the cases. Also, the mode EME * is close enough to the original mode EME, so that one who verified the proof for EME (which is shorter) may be able to be convinced of the correctness of EME * just "by inspection".</p><p>A useful lemma. The proof of security is divided into two parts: in Section A.1 we carry out a game-substitution argument, reducing the analysis of EME * to the analysis of a simpler probabilistic game. In Section A.2 we analyze that simpler game. Before we begin we first recall a little lemma, saying that a (tweakable) truly random permutation looks very much like an oracle that just returns random bits (as long as you never ask pointless queries). So instead of analyzing indistinguishability from a random permutation we can analyze indistinguishability from random bits.</p><p>Let E: K × T × M → M be a tweaked block-cipher and let D be its inverse. Define the advantage of distinguishing E from random bits, Adv ± rnd E , by</p><formula xml:id="formula_8">Adv ± rnd E (A) = Pr[K $ ← K : A E K (•,•) D K (•,•) ⇒ 1 ] -Pr[ A $(•,•) $(•,•) ⇒ 1 ]</formula><p>where $(T, M ) returns a random string of length |M |. We insist that A makes no pointless queries, regardless of oracle responses, and A asks no query (T, M ) outside of T × M. We extend the definition above in the usual way to its resource-bounded versions. We have the following lemma, whose (standard) proof can be found, for example, in the full version of <ref type="bibr" target="#b5">[6]</ref>.</p><p>Lemma 2 [± prp-security ≈ ± rnd-security] Let E: K × T × M → M be a tweaked block-cipher and let q ≥ 1 be a number. Then |Adv ± prp E (q) -Adv ± rnd E (q)| ≤ q(q -1)/2 N +1 where N is the length of a shortest string in the message space M. 2</p><p>A.1 The game-substitution sequence</p><p>Fix n, σ n , and q. Let A be an adversary that asks q oracle queries (none pointless) totaling σ n blocks (of both data and associated data, potentially some of them partial blocks). Our goal in this part is to tie the advantage Adv ± rnd EME[Perm(n)] (A) to the probability Pr[ N2 sets bad ], where N2 is some probability space and " N2 sets bad " is an event defined there. Later we bound Pr[ N2 sets bad ], and, putting that together with Lemma 2, we get Eq. (1) of Theorem 1. Game N2 is obtained by a game-substitution argument, as carried out in works like <ref type="bibr" target="#b7">[8]</ref>. The goal is to simplify the rather complicated setting of A adaptively querying its oracles, and to arrive at a simpler setting where there is no adversary and no interaction-just a program that flips coins and a flag bad that does or does not get set.</p><p>Abstracting the function H K,R : The analysis below turns out to be quite complicated. We somewhat simplify it by replacing the function H K,R by an abstract function h : {0, 1} * → {0, 1} n , chosen from a pairwise independent family H. The properties of h that we use in the analysis are:</p><p>(i) For a fixed T ∈ {0, 1} * , h(T) is uniform in {0, 1} n when h is chosen at random from H.</p><p>(ii) For fixed</p><formula xml:id="formula_9">T = T ′ ∈ {0, 1} * , h(T) ⊕ h(T ′ ) is uniform in {0, 1} n when h $ ← H. (iii) The choice h $ ← H is</formula><p>independent of all the other random choices in the game.</p><p>We can justify these assumptions on h by replacing the computation of E K (T ⊕ jR) ⊕ jR (with j a constant) in lines 10, 11, and 12 of Figure <ref type="figure" target="#fig_0">1</ref>, by the computation f j (T ) where for each j we have an independent random function f j : {0, 1} n → {0, 1} n . It is known that replacing a masked random permutation by a collection of random functions this way entails only a negligible difference on the view of the adversary. Specifically, one could prove the following: Fix some integers n, q p , q f ∈ N and an adversary with three oracles A E(•),D(•),F (•,•) , and consider the two following experiments.</p><p>• In the first experiment (Expr1), we choose at random a permutation π over {0, 1} n and a string R ∈ {0, 1} n . Then for x, y, j ∈ {0, 1} n with j = 0, an oracle-query E(x) is answered by π(x), an oracle query D(y) is answered by π -1 (y), and an oracle query F (j, x) is answered by π(x ⊕ jR) ⊕ jR (where the multiplication jR is over GF (2 n )).</p><p>• In the second experiment (Expr2), we choose at random a permutation π over {0, 1} n , and 2 n functions {f j : {0, 1} n → {0, 1} n } j∈{0,1} n . Then for x, y, j ∈ {0, 1} n , with j = 0, the oracle-queries E(x) and D(y) are answered as before by π(x) and π -1 (y), respectively, but an oracle query F (j, x) is answered by f j (x).</p><p>Lemma 3 Fix some n, q p , q f ∈ N. For any adversary A E(•),D(•),F (•,•) as above that makes at most q p queries to E and D, and at most q f queries to F , it holds that Pr</p><formula xml:id="formula_10">Expr1 [ A E,D,F ⇒ 1 ] -Pr Expr2 [ A E,D,F ⇒ 1 ] ≤ q f (q f + 2q p )/2 n 2</formula><p>This lemma is pretty much folklore by now, although I could not find a reference where it is proven.</p><p>A similar result wes proven by by Even and Mansour <ref type="bibr" target="#b3">[4]</ref> (but the masks there are completely independent, rather than pairwise independent). A proof for a special case of this lemma can be found in [1, <ref type="bibr">Lemma 4]</ref>, and that proof can easily be extended to prove Lemma 3 itself.</p><p>Using Lemma 3, we can replace the function H K,R from Figure <ref type="figure" target="#fig_0">1</ref> by the following function h (that depends on the 2 n random functions f j ). In the code below, the constants 2 i are computed in the finite field GF (2 n ).</p><formula xml:id="formula_11">function h(T 1 • • • T ℓ-1 , T ℓ ): // |T 1 | = • • • = |T ℓ-1 | = n, 0 &lt; |T ℓ | ≤ n 01 if T is empty return f 1 (0) 10 for i ∈ [1..ℓ -1] do TTT i ← f 2 i (T i ) 11 if |T ℓ | = n then TTT ℓ ← f 2 ℓ (T ℓ ) 12 else TTT ℓ ← f 2 ℓ+1 (T ℓ 10..0)) 13 return T T T 1 ⊕ • • • ⊕ T T T ℓ</formula><p>Divide the total number of blocks σ n in an attack on EME * into σ n = σ d n + σ a n where σ d n is the number of blocks in the data itself, and σ a n is the number of blocks in the associated data. Let N be Subroutine Choose-π(X): denote the total number of block encryptions that are used throughout the attack (not counting the computation of H), and we can bound it by</p><formula xml:id="formula_12">010 Y $ ← {0, 1} n ; if Y ∈ Range then bad ← true , Y $ ← Range 011 if X ∈ Domain then bad ← true , Y ← π(X) 012 π(X) ← Y , Domain ← Domain ∪ {X}, Range ← Range ∪ {Y }; return Y Subroutine Choose-π -1 (Y ): 020 X $ ← {0, 1} n ; if X ∈ Domain then bad ← true , X $ ← Domain 021 if Y ∈ Range then bad ← true , X ← π -1 (Y ) 022 π(X) ← Y , Domain ← Domain ∪ {X}, Range ← Range ∪ {Y }; return X</formula><formula xml:id="formula_13">N be &lt; (2 + 1 n )σ d n + 2q<label>(2)</label></formula><p>Then from Lemma 3 it follows that the statistical distance in the view of the adversary due to the replacement of H K,R by h is bounded by σ a n (σ a n + 2N be )/2 n . Once we made that replacement, it is clear that the choice of h is now independent of all the other random choices in the attack, so we only need to prove the properties (i) and (ii). This is done next:</p><formula xml:id="formula_14">Claim 2 When 2 n functions {f j : {0, 1} n → {0, 1} n } j∈{0,1}</formula><p>n are chosen at random and h is defined as above, it holds that:</p><p>(i) For any fixed</p><formula xml:id="formula_15">T ∈ {0, 1} 0..n(2 n -3) , h(T ) is uniform in {0, 1} n . (ii) For any fixed T = T ′ ∈ {0, 1} 0..n(2 n -3) , h(T ) ⊕ h(T ′ ) is uniform in {0, 1} n .</formula><p>Proof: Property (i) is obvious, since the output of h at any point T depend on at least one application of one of the functions f j , and these are all random functions. To prove Property (ii), fix some T = T ′ , and denote T = T 1 . . . T ℓ and similarly T = T 1 . . . T ℓ ′ , where ℓ = ⌈|T |/n⌉ and ℓ ′ = ⌈|T ′ |/n⌉. (The proof below use the fact that 2 is a primitive element in GF (2 n ) and ℓ ′ ≤ 2 n -3, so for any i</p><formula xml:id="formula_16">= i ′ ≤ ℓ ′ + 1 we have 2 i = 2 i ′ in GF (2 n ).)</formula><p>If ℓ = ℓ ′ then there must be at least one index i ≤ ℓ such that</p><formula xml:id="formula_17">T i = T ′ i . If T i and T ′ i are full blocks then h(T ) ⊕ h(T ′ ) = something-independent-of-f 2 i ⊕ f 2 i (T i ) ⊕ f 2 i (T ′ i ), which is uniform since f 2 i is a random function. If they are both partial blocks (so i = ℓ) then we get h(T ) ⊕ h(T ′ ) = something-independent-of-f 2 ℓ+1 ⊕ f 2 ℓ+1 (T i 10..0) ⊕ f 2 ℓ+1 (T ′ i 10..0), which is again uniform since T i = T ′ i implies that also T i 10..0 = T ′ i 10..0 and f 2 ℓ+1 is a random function. If T i is a full block and T ′ i is partial, then we similarly get h(T ) ⊕ h(T ′ ) = something-independent-of-f 2 ℓ+1 ⊕ f 2 ℓ+1 (T ′ i 10..0). If ℓ = ℓ ′ , then assume that ℓ ′ &gt; ℓ. If T ′ i is a partial block then as before we get h(T ) ⊕ h(T ′ ) = something-independent-of-f 2 ℓ ′ +1 ⊕ f 2 ℓ ′ +1 (T ′ i 10..0). Similarly if T ′ i is a full block and either ℓ ′ &gt; ℓ + 1 or T ℓ is a full block, then h(T ) ⊕ h(T ′ ) = something-independent-of-f 2 ℓ ′ ⊕ f 2 ℓ ′ (T ′ i ). The last case is when ℓ ′ = ℓ + 1 and T ′ ℓ ′ is a full block and T ℓ is a partial block. In this case h(T ′ ) includes the term f 2 ℓ (T ′ ℓ ) but h(T ) is independent of f 2 ℓ , so again h(T ) ⊕ h(T ′ ) is uniform. Initialization: 050 Domain ← Range ← ∅; for all X ∈ {0, 1} n do π(X) ← undef 051 bad ← false; L $ ← {0, 1} n ; h ← H</formula><p>Respond to the s-th adversary query as follows:</p><p>An encipher query, Enc(T s ;</p><formula xml:id="formula_18">P s 1 • • • P s m s ): 102 if |P s m s | = n then lastFull s ← m s 103 else lastFull s ← m s -1 104 PPP s m s ← P s m s padded with 10..0 110 for i ← 1 to lastFull s do 111 r = r[s, i] is the 1st index s.t. P s i = P r i 112 if r &lt; s then PP s i ← PP r i 113 PPP s i ← PPP r i 114 else PP s i ← P s i ⊕ 2 i-1 L 115 PPP s i ← Choose-π(PP s i ) 120 MP s 1 ← PPP s 1 ⊕ • • • ⊕ PPP s m s ⊕ h(T s ) 121 if |P s m s | = n then MC s 1 ← Choose-π(MP s 1 ) 122 else MM s ← Choose-π(MP s 1 ) 123 MC s 1 ← Choose-π(MM s ) 124 C s m s ← P s m s ⊕ (MM s truncated) 125 CCC s m s ← C s m s padded with 10..0 126 M s 1 ← MP s 1 ⊕ MC s 1 130 for i ← 2 to lastFull s do 131 j = ⌈i/n⌉, k = (i -1) mod n 132 if k = 0 then 133 MP s j ← PPP s i ⊕ M s 1 134 MC s j ← Choose-π(MP s j ) 135 M s j ← MP s j ⊕ MC s j 136 CCC s i ← MC s j ⊕ M s 1 137 else CCC s i ← PPP s i ⊕ 2 k M s j 138 CCC s 1 ← MC s 1 ⊕ CCC s 2 ⊕ • • • CCC s m s ⊕ h(T s ) 140 for i ← 1 to lastFull s do 141 CC s i ← Choose-π(CCC s i ) 142 C s i ← CC s i ⊕ 2 i-1 L 150 return C s 1 • • • C s m s A decipher query, Dec(T s ; C s 1 • • • C s m s ): 202 if |C s m s | = n then lastFull s ← m s 203 else lastFull s ← m s -1 204 CCC s m s ← C s m s padded with 10..0 210 for i ← 1 to lastFull s do 211 r = r[s, i] is the 1st index s.t. C s i = C r i 212 if r &lt; s then CC s i ← CC r i 213 CCC s i ← CCC r i 214 else CC s i ← C s i ⊕ 2 i-1 L 215 CCC s i ← Choose-π -1 (CC s i ) 220 MC s 1 ← CCC s 1 ⊕ • • • ⊕ CCC s m s ⊕ h(T s ) 221 if |C s m s | = n then MP s 1 ← Choose-π -1 (MC s 1 ) 222 else MM s ← Choose-π -1 (MC s 1 ) 223 MP s 1 ← Choose-π -1 (MM s ) 224 P s m s ← C s m s ⊕ (MM s truncated) 225 PPP s m s ← P s m s padded with 10..0 226 M s 1 ← MP s 1 ⊕ MC s 1 230 for i ← 2 to lastFull s do 231 j = ⌈i/n⌉, k = (i -1) mod n 232 if k = 0 then 233 MC s j ← CCC s i ⊕ M s 1 234 MP s j ← Choose-π -1 (MC s j ) 235 M s j ← MP s j ⊕ MC s j 236 PPP s i ← MP s j ⊕ M s 1 237 else PPP s i ← CCC s i ⊕ 2 k M s j 238 PPP s 1 ← MP s 1 ⊕ PPP s 2 ⊕ • • • PPP s m s ⊕ h(T s ) 240 for i ← 1 to lastFull s do 241 PP s i ← Choose-π -1 (PPP s i ) 242 P s i ← PP s i ⊕ 2 i-1 L 250 return P s 1 • • • P s m s Figure 4: Game E1 describes the attack of A on EME[Perm(n)],</formula><p>where the permutation π is chosen "on the fly" as needed. Game R1 is the same as game E1, except we do not execute the shaded statements in the procedures from Figure <ref type="figure" target="#fig_1">3</ref>.</p><p>The game E1. We describe the attack scenario of A against EME[Perm(n)] (with the abstraction of h as above) as a probabilistic game in which the permutation π is chosen "on the fly", as needed to answer the queries of A. Initially, the partial function π: {0, 1} n → {0, 1} n is everywhere undefined. When we need π(X) and π isn't yet defined at X we choose this value randomly among the available range values. When we need π -1 (Y ) and there is no X for which π(X) has been set to Y we likewise choose X at random from the available domain values. As we fill in π its domain and its range thus grow. In the game we keep track of the domain and range of π by maintaining two sets, Domain and Range, that include all the points for which π is already defined. We let Domain and Range be the complement of these sets relative to {0, 1} n . The game, denoted E1, is shown in Figures <ref type="figure" target="#fig_1">3</ref> and<ref type="figure">4</ref>. Since game E1 accurately represent the attack scenario, we have that</p><formula xml:id="formula_19">Pr[ A Eπ Dπ ⇒ 1 ] ≤ Pr[ A E1 ⇒ 1 ] + σ a n (σ a n + 2N be ) 2 n<label>(3)</label></formula><p>(where the additive factor is due to the abstraction of h). Looking ahead to the game-substitution sequence, we structured the code in Figures <ref type="figure" target="#fig_1">3</ref> and<ref type="figure">4</ref> in a way that makes it easier to present the following games. In particular, here are some things to note about this code:</p><p>• Notations. We denote all the quantities that are encountered during the processing of query s with a superscript s. For example, the number of blocks in the query is denoted m s , and the plaintext is denoted</p><formula xml:id="formula_20">P s = P s 1 • • • P s m s (where |P s i | = n for i &lt; m s and |P s m s | ≤ n).</formula><p>• The notation r[s, i]. When handling the s-th adversary query, we look for each block of the query to see if it is a "new block": if this is an encipher query P s = (P s 1 • • • P s m s ) we look for an earlier plaintext P r = (P r 1 • • • P r m r ) with the same i'th block P s i = P r i . Since we use "masked ECB" encryption, we only expect to choose a new value for π when there is no such prior plaintext. If this is a decipher query then for any i we likewise look for an earlier ciphertext C r with the same i'th block, C s i = C r i . We define r[s, i] to be the index of the first such plaintext or ciphertext. Namely, we define</p><formula xml:id="formula_21">r[s, i] def = min{ r ≤ s : P r i = P s i } if query s is an encipher query min{ r ≤ s : C r i = C s i } if query s is a decipher query</formula><p>• Filling in π and π -1 values. When we need to define π on what is likely to be a new domain point X, setting π(X) ← Y for some Y , we do the following: We first sample Y from {0, 1} n ; then re-sample, this time from Range, if the initially chosen sample Y was already in the range of π; finally, if π already had a value at X, then we forget about the newly chosen value Y and use the previous value of π(X). We behave analogously for π -1 (Y ) values. In Figure <ref type="figure" target="#fig_1">3</ref> we highlight the places where we have to reset a choice we tentatively made. Whenever we do so we set a flag bad. The flag bad is never seen by the adversary A that interacts with the E1 game-it is only present to facilitate the subsequent analysis.</p><p>Game R1. We next modify game E1 by omitting the statements that immediately follow the setting of bad to true. (This is the usual trick under the game-substitution approach.) Namely, before we were making some consistency checks after each random choice π(X) = Y $ ← {0, 1} n to see if this value of Y was already in use, or if π was already defined at X, and we reset out choice Initialization:</p><formula xml:id="formula_22">050 Domain ← Range ← ∅; bad ← false; L $ ← {0, 1} n ; h ← H</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Respond to the s-th adversary query as follows:</head><p>An encipher query, Enc(T s ; P s of Y as needed. Now we still make these checks and set the flag bad, but we do not reset the chosen value of Y . The game R1 is described in Figure <ref type="figure" target="#fig_2">5</ref>. (In this figure we omitted the function π from the code, since it is never used anymore.) These changes mean that π may end up not being a permutation, and moreover we may reset its value on previously chosen points. Still, the games E1 and R1 are syntactically identical apart from what happens after the setting of the flag bad to true. Once the flag bad is set to true the subsequent behavior of the game does not impact the probability that an adversary A interacting with the game can set the flag bad to true. This is exactly the setup used in the game-substitution method to conclude that</p><formula xml:id="formula_23">1 • • • P s m s ): 101 if |P s m s | = n then lastFull s ← m s 102 else lastFull s ← m s -1 103 PPP s m s ← P s m s padded with 10..0 110 for i ← 1 to lastFull s do 111 r = r[s, i] is the 1st index s.t. P s i = P r i 112 if r &lt; s then PP s i ← PP r i ; PPP s i ← PPP r i 113 else PP s i ← P s i ⊕ 2 i-1 L; PPP s i $ ← {0, 1} n 114 if PP s i ∈ Domain or PPP s i ∈ Range then bad ← true 115 Domain ← Domain ∪ {PP s i }; Range ← Range ∪ {PPP s i } 120 MP s 1 ← PPP s 1 ⊕ • • • ⊕ PPP s m s ⊕ h(T s ) 121 if |P s m s | = n then MC s 1 $ ← {0, 1} n ; M s 1 ← MP s 1 ⊕ MC s 1 122 if MP s 1 ∈ Domain or MC s 1 ∈ Range then bad ← true 123 Domain ← Domain ∪ {MP s 1 }; Range ← Range ∪ {MC s 1 } 124 else MM s $ ← {0, 1} n ; MC s 1 $ ← {0, 1} n ; M s 1 ← MP s 1 ⊕ MC s 1 125 if MP s 1 ∈ Domain or MM s ∈ Range then bad ← true 126 if MM s ∈ Domain ∪ {MP s 1 } or MC s 1 ∈ Range ∪ {MM s } then bad ← true 127 Domain ← Domain ∪ {MP s 1 , MM s }; Range ← Range ∪ {MM s , MC s 1 } 128 C s m s ← P s m s ⊕ (MM s truncated); CCC s m s ← C s m s padded with 10..0 130 for i ← 2 to lastFull s do 131 j = ⌈i/n⌉, k = (i -1) mod n 132 if k = 0 then 133 MP s j ← PPP s i ⊕ M s 1 ; MC s j $ ← {0, 1} n ; M s j ← MP s j ⊕ MC s j 134 if MP s j ∈ Domain or MC s j ∈ Range then bad ← true 135 Domain ← Domain ∪ {MP s j }; Range ← Range ∪ {MC s j } 136 CCC s i ← MC s j ⊕ M s 1 137 else CCC s i ← PPP s i ⊕ 2 k M s j 138 CCC s 1 ← MC s 1 ⊕ CCC s 2 ⊕ • • • CCC s m s ⊕ h(T s ) 140 for i ← 1 to lastFull s do 141 CC s i $ ← {0, 1} n ; C s i ← CC s i ⊕ 2 i-1 L 142 if CCC s i ∈ Domain or CC s i ∈ Range then bad ← true 143 Domain ← Domain ∪ {CCC s i }; Range ← Range ∪ {CC s i } 150 return C s 1 • • • C s m s A decipher query, Dec(T s ; C s 1 • • • C s m s ), is treated symmetrically</formula><formula xml:id="formula_24">Pr[ A E1 ⇒ 1 ] -Pr[ A R1 ⇒ 1 ] ≤ Pr[ A R1 sets bad ]<label>(4)</label></formula><p>Game R2. We now make several changes to the order in which variables are chosen in game R1. Specifically, we make the following changes to the code:</p><formula xml:id="formula_25">• Instead of choosing CC s i $ ← {0, 1} n and then setting C s i ← CC s i ⊕ 2 i L (in line 141), we choose C s i $ ← {0, 1} n and then set CC s i ← C s i ⊕ 2 i L.</formula><p>• </p><formula xml:id="formula_26">CCC s i ← PPP s i ⊕ M s j . This is equivalent since MC s j = MP s j ⊕ M s j = PPP s i ⊕ M s 1 ⊕ M s j . • We replace the assignment CCC s 1 ← MC s 1 ⊕ CCC s 2 ⊕ • • • ⊕ CCC s m s ⊕ h(T s ) in line 138 by the equivalent assignment CCC s 1 ← PPP s 1 ⊕ M s 1 ⊕ (PPP s 2 ⊕ CCC s 2 ) ⊕ • • • ⊕ (PPP s m s ⊕ CCC s m s ). This is indeed equivalent since MC s 1 = MP s 1 ⊕ M s 1 = PPP s 1 ⊕ • • • ⊕ PPP s m s ⊕ h(T s ) ⊕ M s 1 .</formula><p>Clearly, these changes preserve the distribution of all those variables, and we make the symmetric changes also for decryption queries.</p><p>In addition to these changes, we also slightly simplify the logic of the game by assigning value to MM s and adding it to Domain and Range even in the case that P s m s is a full block (|P s m s | = n). This has no effect on the answers that are returned to the adversary, but it may increase the probability of the flag bad being set (since we may introduce collisions that were not present before).</p><p>The resulting game R2 is described in Figure <ref type="figure" target="#fig_3">6</ref>. It is clear that the changes we made do has no effect on the probability that A returns one (as they do not change anything in the interaction between A and its oracles), and they can only increase the probability of setting flag bad. Hence we conclude that</p><formula xml:id="formula_27">Pr[ A R1 ⇒ 1 ] = Pr[ A R2 ⇒ 1 ] and Pr[ A R1 sets bad ] ≤ Pr[ A R2 sets bad ]<label>(5)</label></formula><p>We note that in game R2 we respond to any encipher query P s by returning |P s | random bits, and similarly, we respond to any decipher query C s by returning |C s | random bits. Thus R2 provides an adversary with an identical view to a pair of random-bit oracles,</p><formula xml:id="formula_28">Pr[ A R2 ⇒ 1 ] = Pr[ A ± rnd ⇒ 1 ]<label>(6)</label></formula><p>Initialization:</p><formula xml:id="formula_29">050 Domain ← Range ← ∅; bad ← false; L $ ← {0, 1} n ; h ← H</formula><p>Respond to the s-th adversary query as follows:</p><p>An encipher query, Enc(T s ; P s Combining Equations 3, 4, 5, and 6, we thus have that</p><formula xml:id="formula_30">1 • • • P s m s ): 101 if |P s m s | = n then lastFull s ← m s 102 else lastFull s ← m s -1 103 PPP s m s ← P s m s padded with 10..0 110 for i ← 1 to lastFull s do 111 r = r[s, i] is the 1st index s.t. P s i = P r i 112 if r &lt; s then PP s i ← PP r i ; PPP s i ← PPP r i 113 else PP s i ← P s i ⊕ 2 i-1 L; PPP s i $ ← {0, 1} n 114 if PP s i ∈ Domain or PPP s i ∈ Range then bad ← true 115 Domain ← Domain ∪ {PP s i }; Range ← Range ∪ {PPP s i } 120 C s * $ ← {0, 1} n ; M s 1 $ ← {0, 1} n 121 MP s 1 ← PPP s 1 ⊕ • • • ⊕ PPP s m s ⊕ h(T s ); MC s 1 ← MP s 1 ⊕ M s 1 ; MM s ← PPP s m s ⊕ C s * 122 if MP s 1 ∈ Domain or MM s ∈ Range then bad ← true 123 if MM s ∈ Domain ∪ {MP s 1 } or MC s 1 ∈ Range ∪ {MM s } then bad ← true 124 Domain ← Domain ∪ {MP s 1 , MM s }; Range ← Range ∪ {MM s , MC s 1 } 125 if |P s m s | = n then 126 C s m s ← (C s * truncated); CCC s m s ← C s m s padded with 10..0 130 for i ← 2 to lastFull s do 131 j = ⌈i/n⌉, k = (i -1) mod n 132 if k = 0 then 133 MP s j ← PPP s i ⊕ M s 1 ; M s j $ ← {0, 1} n ; MC s j ← MP s j ⊕ M s j 134 if MP s j ∈ Domain or MC s j ∈ Range then bad ← true 135 Domain ← Domain ∪ {MP s j }; Range ← Range ∪ {MC s j } 136 CCC s i ← PPP s i ⊕ 2 k M s j 137 CCC s 1 ← PPP s 1 ⊕ M s 1 ⊕ (PPP s 2 ⊕ CCC s 2 ) ⊕ • • • ⊕ (PPP s m s ⊕ CCC s m s ) 140 for i ← 1 to lastFull s do 141 C s i $ ← {0, 1} n ; CC s i ← C s i ⊕ 2 i-1 L 142 if CCC s i ∈ Domain or CC s i ∈ Range then bad ← true 143 Domain ← Domain ∪ {CCC s i }; Range ← Range ∪ {CC s i } 150 return C s 1 • • • C s m s A decipher query, Dec(T s ; C s 1 • • • C s m s ), is treated symmetrically</formula><formula xml:id="formula_31">Adv ± rnd EME[Perm(n)] (A) = Pr[ A E1 ⇒ 1 ] + σ a n (σ a n + 2N be ) 2 n -Pr[ A R2 ⇒ 1 ] = Pr[ A E1 ⇒ 1 ] -Pr[ A R1 ⇒ 1 ] + σ a n (σ a n + 2N be ) 2 n ≤ Pr[ A R1 sets bad ] + σ a n (σ a n + 2N be 2 n ≤ Pr[ A R2 sets bad ] + σ a n (σ a n + 2N be ) 2 n (<label>7</label></formula><formula xml:id="formula_32">)</formula><p>Our task is thus to bound Pr[ A R2 sets bad ].</p><p>Game R3. Next we reorganize game R2 so as to separate out (i) choosing random values to return to the adversary, (ii) defining intermediate variables, and (iii) setting the flag bad.</p><p>We remarked before that game R2 replies to any z-bit query with z random bits. Now, in game R3, shown in Figure <ref type="figure">7</ref>, we make that even more clear by choosing the blocks</p><formula xml:id="formula_33">C s 1 • • • C s m s -1 C s * or P s 1 • • • P s m s -1 P s</formula><p>* just as soon as the s th query is made. Nothing else is done at that point except for recording if the adversary made an Enc query or a Dec query, and returning the answer to the adversary.</p><p>When the adversary finishes all of its oracle queries and halts, we execute the "finalization" step of game R3. First, we go over all the variables of the game and determine their values, just as we do in game R2. While doing so, we collect all the values in the sets Domain and Range, this time viewing them as multisets D and R, respectively. When we are done setting values to all the variables, we go back and look at D and R. The flag bad is set if (and only if) any of these multisets contains some value more than once. This procedure is designed to set bad under exactly the same conditions as in game R2. The following is thus clear:</p><formula xml:id="formula_34">Pr[ A R2 sets bad ] = Pr[ A R3 sets bad ]<label>(8)</label></formula><p>Game N1. So far we have not changed the structure of the games at all: it has remained an adversary asking q questions to an oracle, our answering those questions, and the internal variable bad either ending up true or false. The next step, however, actually gets rid of the adversary, as well as all interaction in the game. We want to bound the probability that bad gets set to true in game R3. We may assume that the adversary is deterministic, and so the probability is over the random choices that are made while answering the queries (in lines 011 and 021), and the random choices in the finalization phase of the game (lines 050, 113, 120, 133, 213, 220, and 233). We will now eliminate the coins associated to lines 011 and 021. Recall that the adversary asks no pointless queries.</p><p>We would like to make the stronger statement that for any set of values that might be chosen in lines 011 and 021, and for any set of queries (none pointless) associated to them, the finalization step of game R3 rarely sets bad. However, this statement isn't quite true. For example, assume that queries r and s (r &lt; s) are both encipher queries, and that the random choices in line 011 specify that the i'th ciphertext block in the two answers is the same, C r i = C s i . Then the flag bad is sure to be set, since we will have a "collision" between CC r i and CC s i . Formally, since in line 141</p><p>Respond to the s-th adversary query as follows:</p><p>An encipher query, Enc(T s ; P s 1 • • • P s m s ): </p><formula xml:id="formula_35">Finalization: First phase 050 D ← R ← ∅; L $ ← {0, 1} n ; h $ ← H // D,</formula><formula xml:id="formula_36">← P s i ⊕ 2 i-1 L; PPP s i $ ← {0, 1} n ; D ← D ∪ {PP s i }; R ← R ∪ {PPP s i } 120 M s 1 $ ← {0, 1} n 121 MP s 1 ← PPP s 1 ⊕ • • • ⊕ PPP s m s ⊕ h(T s ); MC s 1 ← MP s 1 ⊕ M s 1 ; MM s ← PPP s m s ⊕ C s * 122 D ← D ∪ {MP s 1 , MM s }; R ← R ∪ {MM s , MC s 1 } 130 for i ← 2 to lastFull s do 131 j = ⌈i/n⌉, k = (i -1) mod n 132 if k = 0 then 133 MP s j ← PPP s i ⊕ M s 1 ; M s j $ ← {0, 1} n ; MC s j ← MP s j ⊕ M s j 134 D ← D ∪ {MP s j }; R ← R ∪ {MC s j } 135 CCC s i ← PPP s i ⊕ 2 k M s j 136 CCC s 1 ← PPP s 1 ⊕ M s 1 ⊕ (PPP s 2 ⊕ CCC s 2 ) ⊕ • • • ⊕ (PPP s m s ⊕ CCC s m s ) 140 for i ← 1 to lastFull s do 141 CC s i ← C s i ⊕ 2 i-1 L; D ← D ∪ {CCC s i }; R ← R ∪ {CC s i } 200</formula><p>The case ty s = Dec is treated symmetrically Second phase 300 bad ← (some value appears more than once in D) or (some value appears more than once in R) Figure <ref type="figure">7</ref>: Game R3 is adversarially indistinguishable from game RND2 but defers the setting of bad. </p><formula xml:id="formula_37">050 D ← R ← ∅; L $ ← {0, 1} n ; h $ ← H // D,</formula><formula xml:id="formula_38">← P s i ⊕ 2 i-1 L; PPP s i $ ← {0, 1} n ; D ← D ∪ {PP s i }; R ← R ∪ {PPP s i } 120 M s 1 $ ← {0, 1} n 121 MP s 1 ← PPP s 1 ⊕ • • • ⊕ PPP s m s ⊕ h(T s ); MC s 1 ← MP s 1 ⊕ M s 1 ; MM s ← PPP s m s ⊕ C s * 122 D ← D ∪ {MP s 1 , MM s }; R ← R ∪ {MM s , MC s 1 } 130 for i ← 2 to lastFull s do 131 j = ⌈i/n⌉, k = (i -mod n 132 if k = 0 then 133 MP s j ← PPP s i ⊕ M s 1 ; M s j $ ← {0, 1} n ; MC s j ← MP s j ⊕ M s j 134 D ← D ∪ {MP s j }; R ← R ∪ {MC s j } 135 CCC s i ← PPP s i ⊕ 2 k M s j 136 CCC s 1 ← PPP s 1 ⊕ M s 1 ⊕ (PPP s 2 ⊕ CCC s 2 ) ⊕ • • • ⊕ (PPP s m s ⊕ CCC s m s ) 140 for i ← 1 to lastFull s do 141 CC s i ← C s i ⊕ 2 i-1 L; D ← D ∪ {CCC s i }; R ← R ∪ {CC s i } 200 else // ty s = Dec 201 P s m s ← 1st |C s m s | bits of P s * 202 if |C s m s | = n then lastFull s ← m s 203</formula><p>else lastFull s ← m s -1; PPP s m s ← P s m s padded with 10..0; CCC s m s ← C s m s padded with 10..0</p><formula xml:id="formula_39">210 for i ← 1 to lastFull s do 211 r = r[s, i] is the 1st index s.t. C s i = C r i 212 if r &lt; s then CC s i ← CC r i ; CCC s i ← CCC r i 213 else CC s i ← C s i ⊕ 2 i-1 L; CCC s i $ ← {0, 1} n ; D ← D ∪ {CCC s i }; R ← R ∪ {CC s i } 220 M s 1 $ ← {0, 1} n 221 MC s 1 ← CCC s 1 ⊕ • • • ⊕ CCC s m s ⊕ h(T s ); MP s 1 ← MC s 1 ⊕ M s 1 ; MM s ← CCC s m s ⊕ P s * 222 D ← D ∪ {MP s 1 , MM s }; R ← R ∪ {MM s , MC s 1 } 230 for i ← 2 to lastFull s do 231 j = ⌈i/n⌉, k = (i -1) mod n 232 if k = 0 then 233 MC s j ← CCC s i ⊕ M s 1 ; M s j $ ← {0, 1} n ; MP s j ← MC s j ⊕ M s j 234 D ← D ∪ {MP s j }; R ← R ∪ {MC s j } 235 PPP s i ← CCC s i ⊕ 2 k M s j 236 PPP s 1 ← CCC s 1 ⊕ M s 1 ⊕ (PPP s 2 ⊕ CCC s 2 ) ⊕ • • • ⊕ (PPP s m s ⊕ CCC s m s ) 240 for i ← 1 to lastFull s do 241 PP s i ← C s i ⊕ 2 i-1 L; D ← D ∪ {PP s i }; R ← R ∪ {PPP s i } 300 bad ← (</formula><p>some value appears more than once in D) or (some value appears more than once in R) we set We call such collisions immediate collisions. Formally, an immediate collision on encipher happens whenever s is an encipher query and for some r &lt; s we have either C s i = C r i for some i ≤ lastFull s , or C s * = (P s m s 10..0) ⊕ (P r m r 10..0) ⊕ C r * when |P r m r |, |P s m s | &lt; n. An immediate collision on decipher happens whenever s is an decipher query and for some r &lt; s we have either P s i = P r i for some i ≤ lastFull s , or</p><formula xml:id="formula_40">CC r i = C r i ⊕ 2 i-1 L = C s i ⊕ 2 i-1 L = CC s 1 ,</formula><formula xml:id="formula_41">P s * = (C s m s 10..0) ⊕ (C r m r 10..0) ⊕ P r * when |C r m r |, |C s m s | &lt; n.</formula><p>The probability of an immediate collision (on either encipher or decipher) in game R3 is at most</p><formula xml:id="formula_42">q s=1 m s (s -1) 2 n &lt; q 2 n q s=1 m s = qσ d n 2 n</formula><p>We make from the Finalization part of game R3 a new game, game N1 (for "noninteractive"). This game silently depends on a fixed transcript τ = ty, T, P, C with ty s the "type" of query s (ty s ∈ {Enc, Dec}) and T s ∈ {0, 1} * the associated data to query s. Also for an encipher query s we have This fixed transcript τ may not specify any immediate collisions or pointless queries; we call such a transcript allowed. Thus saying that τ is allowed means that for all r &lt; s we have the following: if ty s = Enc then (i) (T s , P s ) = (T r , P r ), (ii) </p><formula xml:id="formula_43">P s = P s 1 • • • P s m s and C s = C s 1 • • • C s m s -1 , C s * ,</formula><formula xml:id="formula_44">C s i = C r i for any i ∈ [1 .. lastFull s ], (iii) If |P s m s |,</formula><p>This step can be viewed as conditioning on the absence of an immediate collision, followed by the usual argument that an average of a collection of real numbers is at most the maximum of those numbers. One can also view the transition from game R3 to game N1 as augmenting the adversary, letting it specify not only the queries to the game, but also the answers to these queries (as long as it does not specify immediate collisions or pointless queries). In terms of game R3, instead of having the oracle choose the answers to the queries at random in lines 011 and 021, we let the adversary supply both the queries and the answers. The oracle just records these queries and answers. When the adversary is done, we execute the finalization step as before to determine the bad flag. Clearly such an augmented adversary does not interact with the oracle at all, it just determines the entire transcript, giving it as input to the oracle. Now maximizing the probability of setting bad over all such augmented adversaries is the same as maximizing this probability over all allowed transcripts. Game N2. Before we move to analyze the non-interactive game, we make one last change, aimed at reducing the number of cases that we need to handle in the analysis. We observe that due to the complete symmetry between D and R, it is sufficient to analyze the collision probability in just one of them. Specifically, because of this symmetry we can assume w.l.o.g. that in game N1 Pr[some value appears more than once in D] ≥ Pr[some value appears more than once in R] and therefore Pr[ N1 sets bad ] ≤ 2 • Pr[some value appears more than once in D]. We therefore replace the game N1 by game N2, in which we only set the flag bad if there is a collision in D. We now can drop the code that handles R, as well as anything else that doesn't affect the multiset D. Specifically, we make the following changes in the code of the game N1:</p><p>• We drop the multiset R from the code.</p><formula xml:id="formula_46">• We replace the assignment MP s 1 ← MC s 1 ⊕ M s 1 from line 221 in game N1 by the equivalent as- signment MP s 1 ← CCC s 1 ⊕ • • • ⊕ CCC s m s ⊕ h(T s ) ⊕ M s 1 .</formula><p>Similarly, we replace the assignment MP s j ← MC s j ⊕ M s j from line 233 by the equivalent assignment</p><formula xml:id="formula_47">MP s j ← CCC s i ⊕ M s 1 ⊕ M s j .</formula><p>• Now the variable CC s i and MC s j are never used in the code, so we drop them altogether.</p><p>The resulting game is described in Figure <ref type="figure" target="#fig_6">9</ref>, and we have</p><formula xml:id="formula_48">Pr[ N1 sets bad ] ≤ 2 • Pr[ N2 sets bad ]<label>(10)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Analysis of the non-interactive game</head><p>We are now ready to analyze the resulting game N2, showing that the event " N2 sets bad " only happens with small probability. In the analysis we view the multiset D as a set of formal variables (rather than a multiset containing the values that these variables assume). Namely, whenever we set D ← D ∪ {X} for some variable X we think of it as setting D ← D ∪ {"X"} where "X" is the name of that formal variable. Viewed in this light, our goal now is to bound the probability that two formal variables in D assume the same value in the execution of N2. We observe that the formal variables in D are uniquely determined by τ -they don't depend on the random choices made in the game N2; specifically,  We view the formal variables in D as ordered according to when they are assigned a value in the execution of game N2. This ordering too is fixed, depending only on the fixed transcript τ .</p><formula xml:id="formula_49">D = {MM s | s ≤ q} ∪ {MP s j | s ≤ q, j ≤ ⌈lastFull s /n⌉} ∪ {PP s i | ty s = Dec, i ≤ lastFull s } ∪ {PP s i | ty s = Enc, i ≤ lastFull s , s = r[s, i]} ∪ {CCC s i | ty s = Enc, i ≤ lastFull s } ∪ {CCC s i | ty s = Dec, i ≤ lastFull s , s = r[s, i]} 050 D ← ∅; L $ ← {0, 1} n ; h $ ← H // D is</formula><formula xml:id="formula_50">← P s i ⊕ 2 i-1 L; D ← D ∪ {PP s i } ; PPP s i $ ← {0, 1} n 120 M s 1 $ ← {0, 1} n ; MP s 1 ← PPP s 1 ⊕ • • • ⊕ PPP s m s ⊕ h(T s ); MM s ← PPP s m s ⊕ C s * 121 D ← D ∪ {MP s 1 , MM s } 130 for i ← 2 to lastFull s do 131 j = ⌈i/n⌉, k = (i -1) mod n 132 if k = 0 then MP s j ← PPP s i ⊕ M s 1 ; D ← D ∪ {MP s j } ; M s j $ ← {0, 1} n 134 CCC s i ← PPP s i ⊕ 2 k M s j 135 CCC s 1 ← PPP s 1 ⊕ M s 1 ⊕ (PPP s 2 ⊕ CCC s 2 ) ⊕ • • • ⊕ (PPP s m s ⊕ CCC s m s ) 140 for i ← 1 to lastFull s do D ← D ∪ {CCC s i } 200 else // ty s = Dec 201 P s m s ← 1st |C s m s | bits of P s * 202 if |C s m s | = n then lastFull s ← m s 203 else lastFull s ← m s -1; CCC s m s ← C s m s padded with 10..0 210 for i ← 1 to lastFull s do 211 r = r[s, i] is the 1st index s.t. C s i = C r i 212 if r &lt; s then CCC s i ← CCC r i 213 else CCC s i $ ← {0, 1} n ; D ← D ∪ {CCC s i } 220 M s 1 $ ← {0, 1} n ; MP s 1 ← CCC s 1 ⊕ • • • ⊕ CCC s m s ⊕ h(T s ) ⊕ M s 1 ; MM s ← CCC s m s ⊕ P s * 221 D ← D ∪ {MM s , MP s 1 } 230 for i ← 2 to lastFull s do 231 j = ⌈i/n⌉, k = (i -1) mod n 232 if k = 0 then M s j $ ← {0, 1} n ; MP s j ← CCC s i ⊕ M s 1 ⊕ M s j ; D ← D ∪ {MP s j } 234 PPP s i ← CCC s i ⊕ 2 k M s j 235 PPP s 1 ← CCC s 1 ⊕ M s 1 ⊕ (PPP s 2 ⊕ CCC s 2 ) ⊕ • • • ⊕ (PPP s m s ⊕ CCC s m s ) 240 for i ← 1 to lastFull s do PP s i ← P s i ⊕ 2 i-1 L; D ← D ∪ {PP s i } 300 bad ← Some value appears more than once in D</formula><p>Throughout the remainder of this section, in all probability claims, the implicit experiment is that of game N2. We adopt the convention that in an arithmetic or probability expression, a formal variable implicitly refers to its value. For example, Pr[X = X ′ ] means the probability that the value assigned to X is the same as the value assigned to X ′ . (At times we may still write "X" to stress that we refer to the name of the formal variable X, or value(X) to stress that we refer to its value.) The rest of this section is devoted to case analysis, proving the following claim:</p><formula xml:id="formula_51">Claim 3 For any two distinct variable X, X ′ ∈ D we have that Pr[X = X ′ ] ≤ 2 -n .</formula><p>Before proving Claim 3, we show how to use it to complete the proof of Theorem 1. Recall that we denote the total number of block encryptions or decryptions by N be , so there are no more than N be variables in D and the union bound gives us</p><formula xml:id="formula_52">Pr[ N2 sets bad ] ≤ N be 2 /2 n<label>(11)</label></formula><p>Combining Lemma 2 with Equations 7, 8, 9, 10 and 11 we get:</p><formula xml:id="formula_53">Adv ± prp EME[Perm(n)] (A) ≤ Adv ± rnd EME[Perm(n)] (A) + q(q -1)/2 n+1 ≤ 2 • Pr[N2 sets bad] + qσ d n /2 n + σ a n (σ a n + 2N be )/2 n + q(q -1)/2 n+1 ≤ 2 • N be 2 /2 n + qσ d n /2 n + σ a n (σ a n + 2N be )/2 n + q(q -1)/2 n+1</formula><p>Using the bound N be &lt; (2 + 1 n )σ d n + 2q from Eq. ( <ref type="formula" target="#formula_7">2</ref>) and substituting σ n = σ d n + σ a n (and assuming that n &gt; 32), it can be shown that 2</p><formula xml:id="formula_54">N be 2 2 n + qσ d n 2 n + σ a n (σ a n + 2N be ) 2 n + q(q -1) 2 n+1 &lt; (2.5σ n + 3q) 2 2 n+1</formula><p>Since A was an arbitrary adversary with query complexity of q and σ n , we are done.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2.1 The case analysis</head><p>We now need to prove Claim 3. We first prove a few claims, each covering some special cases of collisions (Claim 7 through Corollary 15 below), and then show that all possible cases are indeed covered by these claims.</p><p>Inspecting the code of game N2 we see that some of the variables in this game are directly chosen at random from {0, 1} n , while others are assigned values deterministically. Specifically, the variables that are directly chosen at random (other than the function h) are L, all the variables M s j , the variables PPP s i such that ty s = Enc, i ≤ lastFull s and s = r[s, i], and the variables CCC s i such that ty s = Dec, i ≤ lastFull s and s = r[s, i]. Hereafter we refer to these variables as the free variables of the game, and we let F denote the set of them:</p><formula xml:id="formula_55">F = {L} ∪ {M s j | j ≤ ⌈lastFull s /n⌉} ∪ {PPP s i | ty s = Enc, i ≤ lastFull s , s = r[s, i]} ∪ {CCC s i | ty s = Dec, i ≤ lastFull s , s = r[s, i]}</formula><p>The value of any other variable in the game can be expressed as a deterministic function in these free variables (and in the function h). The bulk of the argument below is roughly to show that for any pair of variables in D, their sum is either some non-zero constant, or it depends linearly on some free variable. <ref type="foot" target="#foot_3">3</ref>We start with some helpful observations regarding the sum of CCC 's (or PPP's) from the same query. Fix some s ≤ q and a non-empty set of indices I ⊆ [1..lastFull s ], and denote its complement by</p><formula xml:id="formula_56">I def = [1..lastFull s ] \ I. Also let j(I) def =    ⌈max(I)/n⌉ if 1 / ∈ I max(I)/n if 1 ∈ I, I = ∅ 1 if I = ∅</formula><p>(Roughly, j(I) is either the index of the "last chunk of n blocks that intersects with I" or the index of the "last chunk that intersects with I", depending on whether or not 1 ∈ I.)</p><p>Claim 4 For an encipher query s and a non-empty set I ⊆ [1 .. lastFull s ], we have i∈I CCC s i = aM s j(I) ⊕ β, where a = 0 is a constant (that depends on the set I), and β is an expression that depends only on constants and variables that were determined before M s j(I) in the game N2. Likewise, if r is a decipher query (ty s = Dec), then i∈I PPP s i = aM s j(I) ⊕ β, where a = 0 is a constant and β is an expression that depends only on constants and variables that were determined before M s j(I) in the game N2.</p><p>Proof: We prove here only the first assertion. The proof of the other assertion is symmetric. Consider first the case where 1 / ∈ I, and denote I last def = {i ∈ I | ⌈i/n⌉ = j(I)}. Notice that I last = ∅. Since s is an encipher query and 1 / ∈ I, then for all i ∈ I, the value of</p><formula xml:id="formula_57">CCC s i is set in line 134 to CCC s i ← PPP s i ⊕ 2 (i-1) mod n • M s ⌈i/n⌉ . Thus we have i∈I CCC s i = i∈I PPP s i ⊕ 2 (i-1) mod n • M s ⌈i/n⌉ = things-that-were-determined-before-M s j(I) ⊕   i∈I last 2 (i-1) mod n   • M s j(I)</formula><p>It is left to show that the coefficient of M s j(I) is non-zero. Let j def = j(I) and recall that I last ⊆ {(j -1)n + 1, . . . , jn}. Hence, if we denote</p><formula xml:id="formula_58">I ′ last = {i -(j -1)n | i ∈ I last } then I ′ last ⊆ {1, . . . n} and I ′ last = ∅, and therefore i∈I last 2 (i-1) mod n = i ′ ∈I ′</formula><p>Recall that in this case 1 ∈ I so I = [2..lastFull s ] \ I. Thus we can write</p><formula xml:id="formula_59">i∈I CCC s i = CCC s 1 ⊕ i∈I, i&gt;1 CCC s i = PPP s 1 ⊕ M s 1 ⊕ lastFull s i=2 (PPP s i ⊕ CCC s i ) ⊕ X s ⊕ i∈I, i&gt;1 CCC s i = X s ⊕ lastFull s i=1 PPP s i ⊕ M s 1 ⊕ i∈I CCC s i = X s ⊕ lastFull s i=1 PPP s i ⊕ M s 1 ⊕ i∈I (PPP s i ⊕ 2 (i-1) mod n • M s ⌈i/n⌉ ) = things-that-were-determined-before-M s 1 ⊕ M s 1 ⊕ i∈I 2 (i-1) mod n • M s ⌈i/n⌉</formula><p>Denote I last def = {i ∈ I | ⌈i/n⌉ = j(I)}, and note that I last = ∅ if and only if I = ∅. Now, if j(I) &gt; 1 (which means that I = ∅ and in particular I last = ∅), then the coefficient of M s j(I) in the expression above is i∈I last 2 (i-1) mod n , which is non-zero since I last is non-empty. If . Let r * be the largest value r[s, i] for any i ∈ I (for example, r * = s if any of the CCC s i 's is a "new block"). Also, let I * be all the indices i ∈ I such that r[s, i] = r * , and let i * be the largest index in I * . That is, we define</p><formula xml:id="formula_60">j(I) = 1 then the coefficient of M s j(I) = M s 1 is (1 ⊕ i∈I last 2 i-1</formula><formula xml:id="formula_61">r * def = max{r[s, i] | i ∈ I}, I * def = {i ∈ I | r[s, i] = r * }, i * def = max(I * )</formula><p>By definition, since I is non-empty then I * must also be non-empty. Also, for any i ∈ I \ I * we have r[s, i] &lt; r * . If query r * is an encipher query, then CCC r * i * is a free variable and we can write</p><formula xml:id="formula_62">i∈I CCC s i = i∈I\{i * } CCC r[s,i] i ⊕ CCC r * i * = things-that-were-determined-before-CCC r * i * ⊕ CCC r * i *</formula><p>Hence the probability that i∈I CCC s i = 0, over the random choice of CCC r * i * , is exactly 2 -n . On the other hand, if query r * is a decipher query, then we can apply Claim 4 to query r * and get</p><formula xml:id="formula_63">i∈I CCC s i = i∈I * CCC r * i ⊕ i∈I\I * CCC r[s,i] i = αM r * j(I * ) ⊕ β ⊕ i∈I\I * CCC r[s,i] i = αM r * j(I * ) ⊕ β ′</formula><p>where α = 0 and β ′ is an expression that depends only on constants and variables that were determined before M r * j(I * ) in the game N2. Again, the probability of i∈I CCC s i = 0, over the random choice of M r * j(I * ) , is exactly 2 -n .</p><p>The "last free variable". In the case analysis to come, we consider for each variable X ∈ D, the last free variable (in the ordering of the game N2) that X depends on, denoted φ(X). Formally, we have a function φ: D → F ∪ {none} that is defined as follows:</p><p>• As the variables MM s are all constants, depending only on P s m s and C s * (or C s m s and P s * ), we denote φ(MM s ) = none for all s.</p><p>• For the formal variables PP s i ∈ D, this last free variable is L, φ(PP s i ) = L.</p><p>• For a formal variable CCC s i ∈ D this last free variable φ(CCC s i ) is either CCC s i itself (on decipher) <ref type="foot" target="#foot_4">4</ref> or M s ⌈i/n⌉ (on encipher, if i &gt; 1), or M s ⌈lastFull s /n⌉ (on encipher, if i = 1). The last two assertions are corollaries of Claim 4 for I = {i}.</p><p>• The rules for the MP s j 's are a bit more involved. Clearly, on decipher we have φ(MP s j ) = M s j for all j, and on encipher we have φ(MP s j ) = M s 1 for all j &gt; 1. To define φ(MP s 1 ) on encipher, recall that we set (in line 120) MP s 1 ← h(T s ) ⊕ m i=1 PPP s i , so the last free variable that MP s depends on, is the "last of the free variables that any PPP s i depends on". Each of these PPP s i 's can either be a free variable itself (if this is a "new block", s = r[s, i]), or it can be set equal to some prior PPP r i (if r = r[s, i] &lt; s). In the latter case, PPP r i is either a free variable (if query r is encipher), or else it depends on M r ⌈i/n⌉ (if query r is decipher and i &gt; 1) or on M r ⌈lastFull r /n⌉ (if query r is decipher and i = 1). To define φ(MP s 1 ), we therefore denote</p><formula xml:id="formula_64">rmax[s] def = max{r[s, i] | 1 ≤ i ≤ lastFull s } imax[s] def = max{i ≤ lastFull s | r[s, i] = rmax[s]} and jmax[s] def =    lastFull rmax[s] /n if imax[s] = 1 ⌈ imax[s]/n ⌉ if imax[s] &gt; 1</formula><p>Thus, when ty s = Enc we have</p><formula xml:id="formula_65">φ(MP s 1 ) =    PPP rmax[s] imax[s] if ty rmax[s] = Enc M rmax[s] jmax[s] if ty rmax[s] = Dec</formula><p>A summary of all these cases appears in Figure <ref type="figure" target="#fig_7">10</ref>. We stress that just like the sets D and F, the function φ too depends only on the fixed transcript τ and not on the random choices in the game N2. Justifying the name "last free variable" we observe the following, which follows from the preceding discussion:</p><formula xml:id="formula_66">φ(MM s ) = none MM φ(PP s i ) = L if ty s = Dec or s = r[s, i] PP φ(CCC s i ) =      CCC s i if ty s = Dec and s = r[s, i] M s ⌈i/n⌉ if ty s = Enc and i &gt; 1 M s ⌈lastFull s /n⌉ if ty s = Enc and i = 1 CCC1 CCC2 CCC3 φ(MP s j ) =            M s j if ty s = Dec M s 1 if ty s = Enc and j &gt; 1 PPP rmax[s] imax[s]</formula><p>if ty s = Enc, j = 1, and ty rmax[s] = Enc Claim 6 Let X ∈ D be a formal variable, and let Y = φ(X). If Y = none then the value that X assumes in game N2 can be expressed as value(X) = a•value(Y ) ⊕ β where a = 0 is a constant (that depends on the name of the formal variable X and the fixed transcript τ ) and β is an expression involving only constants and free variables that are determined before Y in the game N2.</p><p>2</p><p>As an immediate corollary of Claim 6, we get the following.</p><p>Claim 7 Let X, X ′ ∈ D be formal variables such that φ(X) = φ(X ′ ). Then Pr[X = X ′ ] = 2 -n .</p><p>Proof: let Y = φ(X) and let Y ′ = φ(X ′ ), and assume that Y ′ occurs before Y in N2. By Claim 6 above, we have</p><formula xml:id="formula_67">X ⊕ X ′ = a • Y ⊕ β ⊕ a ′ • Y ′ ⊕ β ′</formula><p>where a = 0 is a constant, and β ⊕ a ′ • Y ′ ⊕ β ′ is an expression involving only constants and free variables that are determined before Y . As the value of Y is chosen at random from GF(2 n ), independently of the other free variables, it follows that Pr[X = X ′ ] = 2 -n .</p><p>Claim 7 leaves us with the task of analyzing collisions between variables that depend on the same last free variable. These are handled in the next few claims.</p><p>Claim 8 For any two distinct variables MM s , MM t ∈ D, we have MM s = MM t (with probability one).</p><p>Proof: This follows from the fact that the transcript τ is allowed: Assume, for example, that ty s = Enc and ty t = Dec (the other cases are symmetric).  Proof: From the definition of φ(•) in Figure <ref type="figure" target="#fig_7">10</ref> it follows that:</p><formula xml:id="formula_68">i = PP t i ′ ] ≤ 2 -n . Proof: If i = i ′ then we have PP s i ⊕ PP t i ′ = (P s i ⊕ 2 i-1 L) ⊕ (P t i ′ ⊕ 2 i ′ -1 L) = P s i ⊕ P t i ′ ⊕ (2 i ⊕ 2 i ′ )L and as i = i ′ ,</formula><formula xml:id="formula_69">• If s is a decipher query then φ(CCC s i ) = CCC s i = φ(MP t j ).</formula><p>• If s is an encipher query and s &gt; t then φ(CCC s i ) = M s j ′ = φ(MP t j ), since MP t j cannot depend on anything that happens in a later query s.</p><p>• If s is an encipher query and s &lt; t, then:</p><p>-If t is a decipher query or j &gt; 1, then φ(MP t j ) = M t j ′ = φ(CCC s i ), since CCC s i cannot depend on anything that happens in a later query t.</p><p>-If t is an encipher query and j = 1, then φ(MP t j ) is of the form either PPP r i ′ or M r j ′ , where</p><formula xml:id="formula_70">r def = rmax[t]. If r = s then clearly φ(MP t j ) = XXX r * = Y Y Y s * = φ(CCC s i ). (We use XXX s * , Y Y Y s</formula><p>* to denote some free variables that are set in queries r, s, respectively.) But if r = s then ty r = Enc, so φ(MP t j ) = PPP r i ′ = φ(CCC s i ).</p><p>• If s is an encipher query and s = t and j = 1 then φ(MP s j ) is either some PPP s ′ i ′ = φ(CCC s i ) (rule MM3), or some M r j for r &lt; s (rule MM4) and again φ(MP</p><formula xml:id="formula_71">t j ) = M r j = Y Y Y s * = φ(CCC s i .</formula><p>• If s is an encipher query, s = t, j &gt; 1, and i &gt; n, then φ(CCC</p><formula xml:id="formula_72">s i ) = M s ⌈i/n⌉ = M s 1 = φ(MP t j ).</formula><p>• If s is an encipher query and s = t and j &gt; 1 and i = 1, then φ(CCC s i ) = M s ⌈lastFull s /n⌉ and φ(MP t j ) = M s 1 . But since j &gt; 1 it must be that lastFull s &gt; n, so φ(CCC s i ) = φ(MP t j ).</p><p>In any of the cases above, we get Pr[CCC s i = MP t j ] = 2 -n by Claim 7. The only case left to analyze is when s = t is an encipher query, j &gt; 1, and 1 &lt; i ≤ n. In this case MP s j is assigned value in line 132, MP s j ← PPP s i j ⊕ M s 1 (i j = jnn + 1), and CCC s i is assigned value in line 134,</p><formula xml:id="formula_73">CCC s i ← PPP s i ⊕ 2 i-1 M s 1 . Hence MP s j ⊕ CCC s i = (PPP s i j ⊕ M s 1 ) ⊕ (PPP s i ⊕ 2 i-1 M s 1 ) = PPP s i j ⊕ PPP s i ⊕ (1 ⊕ 2 i-1 )M s<label>1</label></formula><p>The coefficient of M s 1 is 1 ⊕ 2 i-1 = 0 (since i &gt; 1), so the sum MP s j ⊕ CCC s i depends linearly on M s 1 and Pr[CCC s i = MP s j ] = 2 -n . The most involved case to analyze (indeed, the one that embodies the "real reason" that EME * is secure) is collisions of the type MP s j = MP t j ′ . We break the analysis of these collisions into the following three claim: in Claim 12 we analyze the case s = t, in Claim 13 we analyze the case s = t and either j or j ′ are different than one, and in Claim 13 we analyze the (hardest) case where s = t and j = j ′ = 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Claim 12</head><p>For any two distinct variables MP s j , MP s j ′ ∈ D, belonging to the same query s, it holds that Pr[MP s j = MP s j ′ ] ≤ 2 -n .</p><p>Proof: Assume w.l.o.g. that j ′ &gt; j. From Figure <ref type="figure" target="#fig_7">10</ref> we see that if ty s = Dec then we would have φ(MP s j ′ ) = M s j ′ = M s j = φ(MP s j ). Also, if ty s = Enc and j ′ &gt; j = 1, then φ(MP s j ′ ) = M s 1 , but φ(MP s 1 ) is either some PPP r * , or else it is some M r * for an earlier query r &lt; s. (The latter case corresponds to rule MM4 from Figure <ref type="figure" target="#fig_7">10</ref>, and we cannot have r = s since ty s = Enc but ty r = Dec.) In any of these cases, we get φ(MP s j ′ ) = φ(MP s j ) and by Claim 7 Pr[MP s j = MP s j ′ ] = 2 -n . We are left with the case where ty s = Enc, and j ′ &gt; j &gt; 1. Hence both MP s j , MP s j ′ were assigned values in line 132 of Game N2, so</p><formula xml:id="formula_74">MP s j ⊕ MP s j ′ = (PPP s i ⊕ M s 1 ) ⊕ (PPP s i ′ ⊕ M s 1 ) = PPP s i ⊕ PPP s i ′</formula><p>(with i = jnn + 1 and i ′ = j ′ nn + 1). By Corollary 5 (with</p><formula xml:id="formula_75">I = {i, i ′ }), we have Pr[MP s j = MP s j ′ ] = Pr[PPP s i ⊕ PPP s i ′ = 0] = 2 -n .</formula><p>Claim 13 For any two distinct variables MP s j , MP t j ′ ∈ D, such that s = t and at least one of j, j ′ is not equal to one, it holds that Pr[MP s j = MP t j ′ ] ≤ 2 -n .</p><p>Proof: Assume w.l.o.g. that s &lt; t. We observe the following from Figure <ref type="figure" target="#fig_7">10</ref>:</p><p>• If ty t = Dec or j ′ &gt; 1 then φ(MP t j ′ ) = M t j ′′ (for some j ′′ ), but MP s j cannot depend on M t j ′′ which is only determined when processing query t &gt; s. Hence φ(MP s j ) = φ(MP t j ′ ).</p><p>• If ty t = Enc and j ′ = 1 (so j &gt; 1) and r def = rmax[t] = s, then φ(MP t j ′ ) is either some PPP r * or some M r * whereas φ(MP s j ) = M s * , so again φ(MP s j ) = φ(MP t j ′ ).</p><p>• If ty t = Enc and j ′ = 1 (so j &gt; 1) and r def = rmax[t] = s and ty s = Enc, then φ(MP s j ) = M s j = PPP s * = φ(MP t j ′ ).</p><p>In either of these cases we get Pr[MP s j = MP s j ′ ] = 2 -n by Claim 7. The only case left to analyze for this claim is when s &lt; t, ty t = Enc, j ′ = 1 (so j &gt; 1), r def = rmax[t] = s, and ty s = Dec. In this case MP t j ′ = MP t 1 was assigned value in line 120 of Game N2, MP t 1 ← h(T t ) ⊕ m t i=1 PPP t i , and MP s j was assigned value in line 232 in game N2, MP s j ← CCC s i j ⊕ M s 1 ⊕ M s j (where i j = jnn + 1 &gt; 1). Hence we get</p><formula xml:id="formula_76">MP t 1 ⊕ MP s j = (h(T t ) ⊕ m t i=1 PPP t i ) ⊕ (CCC s i j ⊕ M s 1 ⊕ M s j )</formula><p>Inspecting the code of game N2, we see that the all the PPP r i 's, CCC r i 's and M r j 's are independent of the choice of the function h. Hence by property (i) from Claim 2 we get Pr Proof of Claim 3. All that is left now is to verify that Claim 7 through Corollary 15 above indeed cover all the possible types of collisions between X, X ′ ∈ D. So let X, X ′ ∈ D be two distinct variables. We partition the analysis to four cases, depending on the "type" of the variable X. X = "MM s ". Here either X ′ = "MM t " in which case Pr[X = X ′ ] = 0 by Claim 8, or else φ(X ′ ) = none = φ(X) and we have Pr[X = X ′ ] = 2 -n from Claim 7. X = "PP s i ". Similarly to the previous case, either X ′ = "PP s ′ i ′ " and we have Pr[X = X ′ ] = 2 -n by Claim 9, or else φ(X ′ ) = L = φ(X) and we have the same using Claim 7. X = "CCC s i ". If X ′ = "MM t " or X ′ = "MP t i ′ " then φ(X ′ ) = φ(X) and we get Pr[X = X ′ ] = 2 -n from Claim 7. If X ′ = "CCC t i ′ " then we get he same from Claim 10, and if X ′ = "MP t j " then we get he same from Claim 11. X = "MP s j ". If X ′ = "MM t " or X ′ = "MP t i ′ " then φ(X ′ ) = φ(X) and we get Pr[X = X ′ ] = 2 -n from Claim 7. If X ′ = "CCC t i " then we get he same from Claim 11, and if X ′ = "MP t j ′ " then we get he same from Corollary 15. This completes the proof of Claim 3.</p><formula xml:id="formula_77">[MP t 1 = MP s j ] = Pr h   h(T t ) = CCC s i j ⊕ M s 1 ⊕ M s j ⊕ m t i=1 PPP t i   = 2 -</formula></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Enciphering and deciphering under E = EME * [E], where E: K × {0, 1} n → {0, 1} n is a block cipher. The associated data is T ∈ {0, 1} * , the plaintext is P = P 1 • • • P m and the ciphertext is C = C 1 • • • C m .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The procedures that are used in games E1 and R1. The shaded statements are executed in Game E1 but not in Game R1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Game R1 is similar to E1, but does not reset the random choices.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Game R2 is indistinguishable from Game R1 but chooses some of its variables in different order.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Game N1 is based on game R3 but now τ = (ty, T, P, C) is a fixed, allowed transcript.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>|P r m r | &lt; n then C s * = (P s m s 10..0) ⊕ (P r m r 10..0) ⊕ C r * ; while if ty s = Dec then (i) (T s , C s ) = (T r , C r ) and (ii) P s i = P r i for any i ∈ [1 .. lastFull s ], (iii) If |C s m s |, |C r m r | &lt; n then P s * = (C s m s 10..0) ⊕ (C r m r 10..0) ⊕ P r * . Now fix an allowed transcript τ that maximizes the probability of the flag bad being set. This one transcript τ is hardwired into game N1. We have that Pr[ A R3 sets bad ] ≤ Pr[ N1 sets bad ] + qσ d n 2 n</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Game N2. Twice the probability that bad gets set in this game bounds the probability that bad gets set in game N1. We highlight random selection by boxing, statements that grow D by shading.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>MFigure 10 :</head><label>10</label><figDesc>Figure 10: Defining the last free variable, φ(X), associated to formal variable X ∈ D. Transcript τ = (ty, T, P, C) has been fixed and it determines r[•, •], rmax[•], imax[•], jmax[•].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Similarly, instead of choosing MC s 1} n and setting C s m s ← P s m s ⊕ (MM s truncated) (lines 124 and 128) we choose C s *</figDesc><table><row><cell></cell><cell>j</cell><cell>$ ← {0, 1} n and setting M s j ← MP s j ⊕ MC s j (lines 121, 124</cell></row><row><cell>and 133), we choose M s j</cell><cell cols="2">$ ← {0, 1} n and set MC s j ← MP s j ⊕ M s j .</cell></row><row><cell>• Instead of choosing MM</cell><cell></cell></row></table><note><p>$ ← {0, $ ← {0, 1} n and set C s m s ← (C s * truncated) and MM s ← (P s m s 10..0) ⊕ C s * . • We replace the assignment CCC s i ← MC s j ⊕ M s 1 in line 136 by the equivalent assignment</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>R are multisets 051 repeat the following for all s ∈ [1..q]: 100 if ty s = Enc then</figDesc><table><row><cell>101 102</cell><cell>if |P s m s | = n then lastFull s ← m s else lastFull s ← m s -1</cell></row><row><cell>103</cell><cell>PPP s m s ← P s m s padded with 10..0; CCC s m s ← C s m s padded with 10..0</cell></row></table><note><p><p>110 for i ← 1 to lastFull s do 111 r = r[s, i] is the 1st index s.t. P s i = P r i 112 if r &lt; s then PP s i ← PP r i ; PPP s i ← PPP r i 113</p>else PP s i</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>R are multisets 051 for s ← 1 to q do PPP s m s ← P s m s padded with 10..0; CCC s m s ← C s m s padded with 10..0</figDesc><table><row><cell>100</cell><cell>if ty s = Enc then</cell></row><row><cell cols="2">101 102 m 111 C s m s ← 1st |P s m s | bits of C s  *  if |P s r = r[s, i] is the 1st index s.t. P s i = P r i 112 if r &lt; s then PP s i ← PP r i ; PPP s i ← PPP r i</cell></row><row><cell>113</cell><cell>else PP s i</cell></row></table><note><p>s | = n then lastFull s ← m s 103 else lastFull s ← m s -1; 110 for i ← 1 to lastFull s do</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>and since both CC r i and CC s i are added to R we would set bad when we examine their values in line 300. Another example is when encipher queries r, s have last blocks P r m r , P s m s , respectively, that are partial (namely |P r m r |, |P s m s | &lt; n), and the blocks C s * , C r * that are chosen at random in line 11 satisfy (P r m r 10..0) ⊕ C r * = (P s m s 10..0) ⊕ C s * . In this case, we would have MM r = MM s and since both are added to D in line 122 we would set bad when we examine their values in line 300. Similar examples can be shown for decipher queries.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>and for a decipher query we haveP s = P s 1 • • • P s m s -1 P s * and C s = C s 1 • • • C s m s .Below we let lastFull s denote either m s if the last block in query s is full or m s -1 if it is partial. Also, for an encipher query we denote by P s</figDesc><table /><note><p>* the padding of P s m s , P s * = P s m s 10..0, and by C s m s we denote the first |P s m s | bits of C s * . Similarly, for a decipher query we denote C s * = C s m s 10..0, and denote by P s m s the first |C s m s | bits of P s * . Since the transcript τ is fixed, then also all these quantities are fixed.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>PPP s m s ← P s m s padded with 10..0; CCC s m s ← C s m s padded with 10..0</figDesc><table><row><cell cols="2">101 102 m 110 C s m s ← 1st |P s m s | bits of C s  *  if |P s for i ← 1 to lastFull s do</cell></row><row><cell>111 112</cell><cell>r = r[s, i] is the 1st index s.t. P s i = P r i if r &lt; s then PP s i ← PP r i ; PPP s i ← PPP r i</cell></row><row><cell>113</cell><cell>else PP s i</cell></row></table><note><p>a multiset 051 for s ← 1 to q do 100 if ty s = Enc then s | = n then lastFull s ← m s 103 else lastFull s ← m s -1;</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>), which is non-zero since 1 / ∈ I last . For any query s and any fixed non-empty set I ⊆ [1..lastFull s ], we have Pr[ i∈I CCC s i = 0] = 2 -n and similarly Pr[ i∈I PPP s i = 0] = 2 -n .Proof: Again, due to symmetry it is sufficient to prove only the case of i CCC s i . If s is an encipher query then this follows directly from Claim 4. If s is a decipher query, then each CCC s i is either itself a free variable (if it is a "new block", r[s, i] = s) or it is set equal to CCC</figDesc><table><row><cell>Corollary 5 r[s,i] i r[s, i] is the last query such that C r i = C s i ). Hence we can write i∈I CCC s r[s,i] (where i = i∈I CCC i</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>Then MM s = C s * ⊕ (P s m s 10..0) and MM t = P t * ⊕ (C t m t 10..0), so MM s = MM t implies P t</figDesc><table><row><cell>*  = C s  *  ⊕ (P s m s 10..0) ⊕ (C s m t 10..0) which is not</cell></row><row><cell>allowed.</cell></row><row><cell>Claim 9 For any two distinct variables PP s i , PP t i ′ ∈ D, we have Pr[PP s</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>the coefficient of L is non-zero, and therefore Pr[PP s i ⊕ PP t i ′ = 0 n ] = 2 -n . If i = i ′ and t &lt; s then necessarily P s i = P t i ′ . (Otherwise, either query s is encipher, in which case r[s, i] &lt; s and PP s i / ∈ D, or query s is encipher, which means that the transcript τ specifies an immediate collision.) Therefore, with probability one we havePP s i ⊕ PP t i ′ = (P s i ⊕ 2 i-1 L) ⊕ (P t i ⊕ 2 i-1 L) = P s i ⊕ P t i = 0.-n . On the other hand, if s = t and i = i ′ then Pr[CCC s i = CCC s i ′ ] = 2 -n by Corollary 5.</figDesc><table><row><cell>Claim 10 For any two distinct variables CCC s i , CCC t i ′ ∈ D, we have Pr[CCC s i = CCC t i ′ ] = 2 -n .</cell></row><row><cell>Proof: By inspecting Figure 10, we see that for two variable CCC s i , CCC t i ′ ∈ D, if s = t then φ(CCC s i ) = φ(CCC t i ′ ) and then by Claim 7 we get Pr[CCC s i = CCC s i ′ ] = 2 Claim 11 For any two variables CCC s i , MP t j ∈ D, Pr[CCC s i = MP t j ] = 2 -n .</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>n</head><label></label><figDesc>Claim 14  For any two queries s = t, it holds that Pr[MP s 1 = MP t 1 ] ≤ 2 -n .Proof: We again assume w.l.o.g. that s &lt; t. As in Claim 13, we observer that if ty t = Dec or rmax[t] = s then φ(MP t 1 ) = φ(MP s 1 ) and we are done by Claim 7. So from now on we assume that ty t = Enc and rmax[t] = s.Recall that since the transcript τ is allowed, we know that either T s = T t or P s = P t . We start by analyzing the case where T s = T t . Observe that regardless of the direction of queries s, t, it holds thatMP s 1 = h(T s ) ⊕ m s i=1 PPP s i and MP t 1 = h(T t ) ⊕ m s i=1 PPP t i . Thus MP t 1 ⊕ MP s 1 = h(T t ) ⊕ = h(T t ) ⊕ h(T s ) ⊕ things-that-are-independent-of-h and since T s = T t , we have Pr[MP t 1 = MP s j ] = 2 -n by property (ii) from Claim 2.Next we analyze the case where T s = T t and P s = P t . To facilitate treatment of queries with partial blocks, let us denote for all rY r = PPP r m r if |P r m r | &lt; n 0 if |P r m r | = nand note that Y r is a constant, depending only on P r m r , and that if P s m s = P t m t then Y s = Y t . Then we can writeMP s 1 ⊕ MP t 1 = h(T s ) ⊕An easy sub-case is where P s and P t agree on all the "full blocks". That is, denote Ps def = P s 1 . . . P s lastFull s and Pt def = P t 1 . . . P t lastFull t , and we analyze the case where Ps = Pt . Since P s = P t , it must be the case where they differ in their last block, namelyP s m s = P t m t , which means that Y s = Y t . In this case we have lastFull s MP t 1 = Y s ⊕ Y t = 0 with probability one.For the rest of this proof we assume that T s = T t , and Ps = Pt . Let E be the set of indexes where Ps and Pt agree,E def = { i ≤ min(lastFull t , lastFull s ) | P s i = P t i }.We can re-write Eq. (12) asMP s 1 ⊕ MP t 1 = Y s ⊕ Y t ⊕where the equality is justified since P s i = P t i implies PPP s i = PPP t i . Recall that we assume ty t = Enc and rmax[t] = s, and we now distinguish again between two sub-cases:First sub-case: here we assume that ty s = Dec and furthermore Ps is not a prefix of Pt . Since rmax[t] = s, then all the blocks P t i already appeared in queries no later than s, namely r[t, i] ≤ s for all i ∈ [1 .. lastFull t ]. Since for i / ∈ E we have P s i = P t i , it follows that for these indexes r[t, i] &lt; s.Since Ps is not a prefix of Pt , then the set D s def = {i ≤ lastFull s | i / ∈ E} is non-empty. And since query s is decipher, we can apply Claim 4 to conclude that i∈D PPP s i = αMP s j(Ds) ⊕ β where α = 0 and β depends only on things that were determined before MP s j(Ds) . Combining this with Eq. (14) we conclude that MP s 1 ⊕ MP t 1 = αMP s j(Ds) ⊕ β ′ for the same non-zero constant α, where β ′ is a different expression, but it still depends only on things that were determined before MP s j(Ds) . Therefore, Pr[MP s 1 = MP t 1 ] = 2 -n . Second sub-case: Next we analyze the cases where either query s is encipher, ty s = Enc, or Ps is a (proper) prefix of Pt . Recall that query t is encipher, so each PPP t i is either a free variable (if it is a "new block", r[t, i] = t) or else it is identically set to equal PPP r[t,i] i (if r[t, i] &lt; t). And in the case where query s is encipher, then the same holds for each PPP s i . Either way, we can re-write Eq. (13) asMP s 1 ⊕ MP t 1 = Y s ⊕ Y t ⊕In the case that query s is decipher and Ps is a proper prefix of Pt , the equality follows since the summation on i ≤ lastFull s , i / ∈ E ranges over an empty set.) Recall that by definition we have r[s, i] = r[t, i] iff P s i = P t i iff i ∈ E. Let query r * be "the last query that MP s ⊕ MP t depends on", and let I * s , I * t be the sets of indexes of PPP s i 's and P P P t i 's that "come from query r * ". That is, we defineR * def = {r[s, i] | i ≤ lastFull s , i / ∈ E} ∪ {r[t, i] | i ≤ lastFull t , i /From this definition it follows that the sets I * s , I * t are disjoint (since r[s, i] = r[t, i] for i / ∈ E), and their union is non-empty (since R * is non-empty). Using these notation we can rewrite Eq. (15)MP s 1 ⊕ MP t 1 = Y s ⊕ Y t ⊕ If queryr * is decipher, ty r * = Dec, we can use Claim 4 to conclude that i∈I * PPP r * i = αMP r * j(I * ) ⊕ β where α = 0 and β only depends on things that are determined before MP r * j(I * ) , and since MP r * j(I * ) is a free variable, it follows that Pr[MP s 1 = MP t 1 ] = 2 -n . If query r * is encipher, ty r = Enc, then all the variables PPP r * i , i ∈ I * , are free variables, and again we have Pr[MP s = MP t ] ≤ 2 -n . As an immediate corollary from the last three claims we have Corollary 15 For any two distinct variables MP s j , MP t j ′ ∈ D, Pr[MP s j = MP s j ′ ] ≤ 2 -n . 2</figDesc><table><row><cell></cell><cell>PPP s i ⊕</cell><cell>PPP t i</cell><cell>(13)</cell></row><row><cell cols="4">m t i=1 lastFull s i=1 PPP s PPP t i ⊕ h(T s ) ⊕ i ⊕ Y lastFull t m s i=1 PPP s i i=1 i ⊕ Y lastFull s PPP t i=1 PPP s i ⊕ lastFull t i=1 PPP t i i = lastFull t PPP s i=1 PPP t i and therefore MP s ∈E i≤lastFull t ,i / ∈E 1 = Y s ⊕ Y t ⊕ i=1 1 ⊕ MP t MP s i≤lastFull s ,i / ∈E PPP s i ⊕ i≤lastFull t ,i / ∈E PPP t i = Y s ⊕ Y t ⊕ i≤lastFull s ,i / ∈E PPP s i ⊕ i≤lastFull t ,i / ∈E PPP r[t,i] i = things-that-were-determined-before-query-s ⊕ i≤lastFull s ,i / ∈E PPP s i i≤lastFull s ,i / ∈E PPP r[s,i] i ⊕ i≤lastFull t ,i / ∈E PPP r[t,i] i (∈ E}, r  *  def = max(R),   i∈I  *  s PPP r[s,i] i ⊕ i≤lastFull s ,i / ∈(E∪I  *  s ) PPP r[s,i] i   ⊕   PPP r[t,i] i ⊕ PPP r[t,i] i   i∈I  *  1 ⊕ i≤lastFull s ,i / i∈I  *  t i≤lastFull t ,i / ∈(E∪I  *  t ) Thus we get = things-that-were-determined-before-query-r  *  ⊕ PPP r  *  (12) (14) (15) (16)</cell></row><row><cell>I  *  s</cell><cell>def = { i ≤ lastFull s | i / ∈ E, r[s, i] = r  *  },</cell><cell></cell></row><row><cell cols="2">I  *  t I  *  def def = { i ≤ lastFull t | i / ∈ E, r[t, i] = r  *  }, = I  *  s ∪ I  *  t</cell><cell></cell></row></table><note><p>s ⊕ h(T t ) ⊕ t = Y s ⊕ Y t ⊕ i</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>In EME * , the longest execution path for any input consists of at most five block encryption. If the input length is a multiple of the block length then only longest path has only four encryptions, and only three if in addition the input is shorter than n blocks.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>The maximum length of messages and associated input would have to be somewhat reduced for this to work. But for n = 128 we can still prove security for messages and associated data as long as, say, 2 120 blocks. (The upper bound is actually min(log 2</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>3, 2 n -1 -log 2 3). With the representation of F G(2 128 ) as above, we have log 2 3 ≈ 3.39 × 10 38 ≈ 2 128 -2 120 . See<ref type="bibr" target="#b13">[14]</ref>.)</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3"><p>In some cases we show that this sum depends on the choice of h in a way that ensures that it is almost always non-zero.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_4"><p>Note that CCC s i ∈ D, which means that C s i is "a new block", s = r[s, i].</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>I thank John Viaga for showing me his ABL mode of operation. I also thank Eli Biham for a discussion about the state of block ciphers for very short blocks.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">CBC MACs for arbitrary-length messages: The three-key constructions</title>
		<author>
			<persName><forename type="first">J</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2000</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1880</biblScope>
			<biblScope unit="page" from="197" to="215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A block-cipher mode of operation for parallelizable message authentication</title>
		<author>
			<persName><forename type="first">J</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT &apos;02</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Knudsen</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2332</biblScope>
			<biblScope unit="page" from="384" to="397" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">A primitive polynomial search program</title>
		<author>
			<persName><forename type="first">S</forename><surname>Duplichan</surname></persName>
		</author>
		<ptr target="http://users2.ev1.net/∼sduplichan/primitivepolynomials/primivitePolynomials.htm" />
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A construction of a cipher from a single pseudorandom permutation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Even</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Mansour</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="151" to="162" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Probabilistic encryption</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<date type="published" when="1984-04">April 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Advances in Cryptology -CRYPTO &apos;03</title>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2003/148/" />
	</analytic>
	<monogr>
		<title level="m">Full version available on the ePrint archive</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2729</biblScope>
			<biblScope unit="page" from="482" to="499" />
		</imprint>
	</monogr>
	<note>A tweakable enciphering mode</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A parallelizable enciphering mode. In The RSA conference -Cryptographer&apos;s track, RSA-CT&apos;04</title>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2003/147/" />
	</analytic>
	<monogr>
		<title level="m">Full version available on the ePrint archive</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Velrag</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">2964</biblScope>
			<biblScope unit="page" from="292" to="304" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">How to protect DES against exhaustive key search</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Earlier version in CRYPTO &apos;96</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="17" to="35" />
		</imprint>
	</monogr>
	<note>www.cs.ucdavis.edu/∼rogaway</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Tweakable block ciphers</title>
		<author>
			<persName><forename type="first">M</forename><surname>Liskov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
		<ptr target="www.cs.berkeley.edu/∼daw/" />
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO &apos;02</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2442</biblScope>
			<biblScope unit="page" from="31" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">How to construct pseudorandom permutations from pseudorandom functions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rackoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. of Computation</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1988-04">April 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">ABL mode: security without data expansion</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Mcgrew</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Viega</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
	<note>Private communication</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Luby-Rackoff: 7 rounds are enough for 2 n(1-ε) security</title>
		<author>
			<persName><forename type="first">J</forename><surname>Patarin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2003</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2729</biblScope>
			<biblScope unit="page" from="513" to="529" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The RC5 encryption algorithm</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fast Software Encryption (FSE &apos;94)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">1008</biblScope>
			<biblScope unit="page" from="86" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Efficient instantiations of tweakable block ciphers and refinements to modes OCB and PMAC</title>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<ptr target="http://www.cs.ucdavis.edu/∼rogaway/papers/" />
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
