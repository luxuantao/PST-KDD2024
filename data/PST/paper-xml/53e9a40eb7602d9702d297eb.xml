<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">TRANSFORMATION OF LOGIC PROGRAMS: FOUNDATIONS AND TECHNIQUES</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Albert0</forename><surname>Pe'itorossi</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Electronics Department</orgName>
								<orgName type="institution">University of Rome II</orgName>
								<address>
									<postCode>00133</postCode>
									<settlement>Roma</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Maurizio</forename><surname>Proietti</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Electronics Department</orgName>
								<orgName type="institution">University of Rome II</orgName>
								<address>
									<postCode>00133</postCode>
									<settlement>Roma</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">A</forename><surname>Pettorossi</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Electronics Department</orgName>
								<orgName type="institution">University of Rome II</orgName>
								<address>
									<postCode>00133</postCode>
									<settlement>Roma</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">TRANSFORMATION OF LOGIC PROGRAMS: FOUNDATIONS AND TECHNIQUES</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">6F01F836B83B00C1FB2646BEE6905974</idno>
					<note type="submission">Received May 1993; accepted December 1993.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:23+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present an overview of some techniques which have been proposed for the transformation of logic programs. We consider the so-called "rules + strategies" approach, and we address the following two issues: the correctness of some basic transformation rules w.r.t. a given semantics and the use of strategies for guiding the application of the rules and improving efficiency. We will also show through some examples the use and the power of the transformational approach, and we will briefly illustrate its relationship to other methodologies for program development.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Program transformation is a very important methodology for software development. The basic idea consists in dividing the program development activity into a sequence of small, easy steps. The programmer starts with a problem specification written in some formal language.</p><p>This specification is then manipulated and transformed into an executable program which in turn in transformed, maybe in several steps, with the objective of increasing efficiency. Subsequent program manipulations, such as compilation and code optimization, can also be viewed as an application of some ad hoc transformation techniques. The basic ideas of the program transformation methodology were introduced in the early 1970s for validating various techniques, such as those which remove recursion in favor of iteration <ref type="bibr">[33,</ref><ref type="bibr">141]</ref>. However, the formalization of program transformation was done some years later <ref type="bibr">[27]</ref> and its extensive use is strongly related to the development of functional and logic languages, because in those languages we can perform program manipulations using simple tools, such as equational reasoning and logical deduction <ref type="bibr">[29,</ref><ref type="bibr">71]</ref>.</p><p>In this paper we will focus our attention on the transformation of logic programs into equivalent, more efficient programs. We will not consider in detail the problem of transforming specifications written in richer logical languages into executable logic programs. This problem is often addressed within the area of program synthesis [461, although in the case of logic programming the borderline between "synthesis" and "transformation" is very thin. We will also not consider those techniques which improve program performances by transforming logic programs into lower level languages by translating the programs into WAM code and then optimizing that code.</p><p>We will mainly be concerned with the so-called unfold/fold program transformations based on the "rules + strategies" approach. This approach consists in starting from an initial program, say P,,, and then applying one or more elementary transformation rules. Thus, we get a sequence P,,, . . . , P,, of programs. We want the final program P, to have the same meaning as the initial one, and this objective can be formalized by the equation Sem(P,) = Sem(P,) for some given semantics function Sem. This is normally achieved by considering transformation rules which are semantics preserving, that is, for any given programs P and Q, Sem(P) = Sem(Q&gt; holds if Q can be derived from P by a single application of one of the rules.</p><p>We usually want P,, to be more efficient that P,,. This efficiency improvement is not ensured by an undisciplined use of the transformation rules. This is the reason why we need to introduce some transfomation strategies, that is, metarules which prescribe suitable sequences of applications of transformation rules. In logic programming there are many notions of efficiency which have been used. They are related either to the size of the proofs or to the machine model. For each strategy we will briefly explain the sense in which the program efficiency is improved, and we refer the reader to the original papers for more detailed information.</p><p>In Section 2, we introduce, in an informal way, the unfold/fold transformation rules for logic programs and, in Section 3, we review some correctness results for these rules w.r.t. various semantics functions.</p><p>In Section 4, we consider some basic strategies for program transformation and we show, through some examples, how they can be used to improve efficiency. We also give an overview of many related techniques.</p><p>In Section 5, we briefly present partial evaluation and program specialization. In Section 6, we finally analyze the relationship between program transformation and some other methodologies for program development, such as program analysis and synthesis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">A PRELIMINARY EXAMPLE</head><p>The "rules -I-strategies" approach to program transformation was first introduced in Burstall and <ref type="bibr">Darlington [27]</ref> for functional programs considered as sets of recursive equations. This approach is based on the use of two elementary transformation rules: unfoZding and folding.</p><p>The unfolding rule consists in replacing, in the right hand side of a given equation, an instance of the left hand side of an equation, say El, by the corresponding instance of the right hand side of El. The application of the unfolding rule can be viewed as a symbolic computation step. It corresponds to the replacement rule used in Kleene ([801, Chapter XI&gt; for the computation of recursive functions.</p><p>The folding rule consists in replacing, in the right hand side of a given equation, an instance of the right hand side of an equation, say E2, by the corresponding instance of the left hand side of E2. Folding can be viewed as the inverse of unfolding, in the sense that if we perform an unfolding step followed by a folding step, we get back the initial equation. Vice versa, unfolding can be viewed as the inverse of folding.</p><p>To the reader who is not familiar with transformation methodology, the usefulness of inverting a symbolic computation step to improve program efficiency might look somewhat obscure. However, as we will see in Section 4, the folding rule allows us to modify the recursive structure of programs and, by doing so, we will often be able to achieve substantial efficiency improvements. Every transformation process is meaningful only if we specify what is kept unchanged during the transformation itself. In the case of functional programs, the unfolding and folding rules preserve the least lixpoint semantics in the following sense: the program P,, derived from a given initial program P,, after some unfolding and folding steps computes a function which is less defined than or equal to the one computed by PO <ref type="bibr">[82]</ref>.</p><p>We can formalize the relationship between the functional programs P, and P,, by introducing a semantics function Sem whose codomain is the set of partial functions ordered by inclusion.</p><p>In this formalization we have that Sem(PJ 2 Sem(P,J. Thus, in order to preserve the computed function, we need to ensure also that Sem(P,) c Sem(P,), which implies that the derived program P,, terminates at least as often as the initial program P,.</p><p>Notice that one could have that Sem(P,) 2 Sem(P,) holds and Sem(P,) c_ Sem(PJ does not hold. Let us consider, for instance, the program {f(O) = 0, f(n + l)e= f(n)], w ic h' h computes the constant function 0 for rz r 0. If we fold the second equation using itself, then we get the program {f(O) = 0, f&lt;n + 1) * f(n + l)} whose least lixpoint is the function, call it g, such that g(O) = 0 and g(n) is undefined for n &gt; 0.</p><p>The unfold/fold transformation approach was first adapted to logic programs by <ref type="bibr">Tamaki and Sato [1301.</ref> In that paper it was assumed that an unfolding step is a (symbolic) <ref type="bibr">SLD-resolution</ref> step and folding is the inverse of unfolding. The notion of inverse, like in the functional case, has to be understood in the sense that an unfolding step followed by the corresponding folding step (and vice versa) gives us back the initial program.</p><p>If, from a program PO, we derive by unfold/fold transformations a program P,, then the least Herbrand model <ref type="bibr">[49]</ref> of P, is contained in the least Herbrand model of PO. In this sense we say that the unfold/fold transformations preserve soundness. In general they do not preserve completeness, that is, the least Herbrand model of PO may not be contained in the least Herbrand model of P,. In order to preserve completeness, one has to comply with some extra conditions <ref type="bibr">[130]</ref>. The discussion on the various semantics which are preserved by unfold/fold transformations will be the objective of the next section. Let us now consider a preliminary example where we will see the unfold/fold rules for transforming logic programs in action. In this example we will also see the use of one extra transformation rule, called the deJinition rule, and the use of a transformation strategy, called tupling. We stress the point that we need strategies for driving the application of the transformation rules and improving efficiency, because, since folding is the inverse of unfolding, we may end up with a final program which is equal to the initial program.</p><p>Let us consider the following logic program PO for computing the average value A of the elements of a list L: where div(S, N, A) holds iff A = S/N and sum(H, S, Sl) holds iff Sl = H + S.</p><p>Both length(L, N) and sumlist(L, S) visit the same list L, and we can avoid this double visit by applying the tupling strategy which suggests the introduction of the following clause for the new predicate newp: 6. newp(L, N, S) + length(L, N), sumlist(L, S&gt;.</p><p>By adding clause 6 to PO, we get a new program P, which is equivalent to Pr, w.r.t. all predicates occurring in the initial program P,,, in the sense that each ground atom q(. . . ), where q is a predicate occurring in P,,, belongs to the least Herbrand model of PO iff q(. . . ) belongs to the least Herbrand model of P,. In order to avoid the double occurrence of the list L in the body of clause 1, we now fold it by using clause 6, that is, we replace "length(L, N), sumlist(L, S)," which is an instance of the body of clause 6, with the corresponding instance "newp(L, N, S)" of the head of clause 6. Thus, we get:</p><p>If. average(L, A) + newp(L, N, S), div(S, N, A). This folding step is the inverse of unfolding newp in the body of clause If. However, if we use the program made out of clauses lf, 2, 3,4,5, and 6, we do not avoid the double visit of the list L, because newp is still defined in terms of the individual predicates length and sumlist. A gain in efficiency is possible if we derive a recursive definition of newp in terms of newp itself.</p><p>This recursive definition can be obtained as follows. We first unfold clause 6 w.r.t. length(L, N), that is, we derive the following two resolvents of clause 6 using clauses 2 and 3, respectively: We can now fold clause 10 using clause 6 and we get:</p><p>10f. newp([ H IT], s(N), Sl) + newp(T, N, S&gt;, sum(H, S, Sl&gt;.</p><p>At this point we may assume that the transformation process is completed. In the final program made out of clauses lf, 9, lOf, 2, 3, 4, and 5, the double visit of the input list L is avoided and, thus, the efficiency is improved. The initial and final programs have the same least Herbrand model semantics w.r.t. the predicates average, length, and sumlist.</p><p>The crucial step in the above program transformation which improves the program performance is the introduction of clause 6 defining the new predicate newp. In the literature that step is referred to as a eureka step, and the predicate newp is also called a eureka predicate. It can easily be seen that eureka steps cannot, in general, be mechanically performed, because they require a certain degree of ingenuity. There are, however, very many cases in which the synthesis of eureka predicates can be done in an automatic way and this is the reason why, in practice, the use of program transformation methodology turns out to be very powerful.</p><p>In the following sections we will present in detail the various transformation rules and the semantics they preserve, and we will also present the various transformation strategies. In this context we will consider the problem of making eureka steps and we will see that it can often be solved on the basis of syntactical properties of the program to be transformed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">UNFOLD/FOLD RULES FOR LOGIC PROGRAMS</head><p>We now present some of the most relevant transformation rules which have been considered</p><p>in the literature, and we discuss the restrictions one should impose on their use depending on the semantics one would like to preserve.</p><p>The notion of program we will use in this paper is very similar to the notion of normal programs [891 and it is defined as follows.</p><p>We assume that all our programs are written using symbols taken from a fixed language L. The Herbrand universe and the Herbrand base are constructed out of L, independently of the programs. This assumption is mainly motivated by the fact that it is often useful to disallow the Herbrand base to change while transforming programs.</p><p>An atom is a formula of the form p(t ,, . . . , t,), where p is a predicate symbol of arity y1 taken from L and t 1,. . . , t, are terms constructed out of variables, constants, and function symbols in L. A literal is either a positive literal, that is, an atom, or a negative literal, that is, a formula of the form -, A, where A is an atom.</p><p>A normal clause is a formula of the form H + L,, . . . , L,, where the head H is an atom and the body L,,..., L, is a (possibly empty) sequence (not a set) of literals not necessarily distinct. In particular, if L, f L,, the clauses H + L,, L, and H + L,, L, are different (even though their semantics may be the same). The head and the body of a normal clause C are denoted by hd(C) and bd(C), respectively.</p><p>Commas will be used to denote the associative concatenation of sequences of literals. Thus, Hc(L~,...,L,), <ref type="bibr">(L,+~,...,L,)</ref> is equal to H&amp;L ,,..., L,,L,+l ,..., L,.</p><p>A normal goal is a formula of the form + L,, . . . , L,, where L,, . . ., L, is a (possibly empty) sequence of literals. If n = 1 and L, is an atom, then a normal goal is said to be atomic. When no ambiguity arises, we will feel free to identify the notion of goal with that of sequence of literals.</p><p>A normal program is a sequence (not a set) of normal clauses. Normal clauses, normal goals, and normal programs are called definite clauses, definite goals, and definite programs, respectively, if no negative literals occur in them. The qualifications "normal" and "definite" will often be omitted when they are irrelevant or understood from the context.</p><p>Given the programs P, = (C,, . . . , C, &gt; and P2 = ( D,, . . . , 0, &gt;, the concatenation (C l,...,Cr,D,,..., 0,) of P, and P2 is denoted by P,@P,.</p><p>When denoting programs we will feel free to omit angle brackets and commas if they are understood from the context. The set of variables occurring in a term (or literal or sequence of literals or clause) T is denoted by vars(T). We assume that the variables occurring in the clauses can be freely renamed, as is usually done for bound variables in quantified formulas.</p><p>This is required to avoid clashes of names, like, for instance, when performing SLDNF-resolution steps. The program transformation process starting from a given initial program PO can be viewed as a sequence of programs PO,. . . , P,, called transformation sequence, such that program Pk+ 1, with 0 I k I n -1, is obtained from Pk by the application of a transformation rule, which may depend on PO,. . . , Pk. During the process of program transformation, we need to take into account the semantics which is preserved. For the semantics of a normal program we explicitly consider its dependency on the input goal, also called quev, and, thus, we define a semantics for a set Programs of normal programs and a set Queries of atomic queries, to be a function Sem: Programs X Queries + (D, 5 1, where (D, 5 &gt; is a partially ordered set. For instance, if P is a program in the set Programs of definite programs and Q is a query +A in the set Queries of atomic queries, then we may take Sem( P, Q) to be the set of instances of A which belong to the least Herbrand model of P. In this case the set D is the powerset of the Herbrand base of the language of Programs and the ordering I is set inclusion. We say that two programs P, and P2 are equivalent w.r.t. Sem iff, for all queries Q in Queries, Sem(P,, Q) = Sem( P2, Q).</p><p>We now introduce our formal notion of correctness of a transformation sequence w.r.t. a generic semantics function. In what follows, by "correctness" we will mean "total correctness." In the remaining part of this Section 3 we present the basic transformation rules and their relevant properties. These rules are collectively called unfold/fold rules and they are a straightforward generalization of those presented in <ref type="bibr">Tamaki and Sato [130]</ref>. In their presentation we will refer to the transformation sequence P O,. . . , Pk. We assume that the variables of the clauses which are involved in each transformation rule are suitably renamed so that they do not have variables in common.</p><p>We need the following notions. Given a predicate p occurring in a program P, the definition of p in P is the subsequence of all clauses in P whose head predicate is p.</p><p>A predicate p depends on a predicate q in the program P iff either there exists in P a clause of the form p( 0.. &gt; + Body, such that q occurs in Body or there exists in P a predicate r such that p depends on r in P and r depends on q in P. Our folding rule is similar to the one considered in <ref type="bibr">Maher [92]</ref> and it is the inverse of the unfolding rule, in the sense that given a transformation sequence P O,...,Pk,Pk+l, where Pktl has been obtained from Pk by unfolding, there exists a transformation sequence PO,. . . , Pk, Pk+ 1, Pk, where Pk has been obtained from P k+ 1 by folding. Analogously, unfolding can be viewed as the inverse of folding. We would like to stress the point that the possibility of inverting an unfolding step by a folding step and vice versa depends on the fact that for transforming programs we can use clauses taken from any program of the transformation sequence constructed so far.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Transformation Rules</head><p>Example 2. The clauses c,: p(U)) + q(X), r(X), i-2,: p(uW&gt;) + SW&gt;, r(X) can be folded using D,: 4X, t(X)) +q(X), D,: 4X, u(X)&gt; + s(X), thereby deriving</p><formula xml:id="formula_0">C: p(Y) +a(X,Y),r(X).</formula><p>Notice that by unfolding clause C using D, and D,, we get again clause C, and C,.</p><p>The folding rules considered in <ref type="bibr">Tamaki and Sato [130,</ref><ref type="bibr">131]</ref> and <ref type="bibr">Kawamura and Kanamori [78]</ref> are instances of the above rule. In particular, the folding rule given in <ref type="bibr">Tamaki and Sato [130]</ref> for definite programs can be presented in the context of normal programs as follows.</p><p>R3. <ref type="bibr">T&amp;S-Folding.</ref> Let Pk be the program (E,, . . ., E,,C, E,, ,,. . . , E,) and let D be a clause in the program Pj, with 0 5 j 5 k. Suppose also that:  By applying the T&amp;S-folding rule, the derived program Pk+ 1 differs from program Pk because of the replacement of exactly one clause (that is, C&gt; by another one (that is, E).</p><p>It is the case that by applying the T&amp;S-folding rule to clause C using a clause D of Pj and then unfolding the resulting clause using D, we obtain again (a variant of) C. To get this relationship between T&amp;S-folding and unfolding, the presence of condition 2 in R3 is essential, as shown by the following example.</p><p>Example 3. Let C be p(X) + q(X) and let D be r + q(Y). Suppose that D is the only clause in Pj with head r. Clauses C and D satisfy conditions 1 and 3 of the T&amp;S-folding rule, but they do not satisfy condition 2 because Y does not occur in the head of I + q(Y), 8 = {Y/X), and X occurs in the head of C. By unfolding the clause p(X) + Y using Pj, we get p(X) + q(Y), which is not a variant of C.</p><p>It is not the case, however, that by applying a T&amp;S-folding step to a clause, say Cl, we can always get back (a variant of&gt; a given clause, say C, even if Cl has been obtained from C by performing an unfolding step using one clause only. This definition rule is similar to the one in <ref type="bibr">Maher [92]</ref> and it is more general than the definition rule considered in <ref type="bibr">Tamaki and Sato [132]</ref>, where only one nonrecursive new clause can be introduced (see R15 below).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R5. Definition Elimination. We may get program Pk,, be deleting from program</head><p>Pk all clauses of the definition of a predicate q such that q does not occur in P, and no predicate different from q depends on q in Pk.</p><p>The definition elimination rule can be viewed as an inverse of the definition introduction rule (module the name of the predicate which has been eliminated). It has been presented in <ref type="bibr">Maher [91,</ref><ref type="bibr">921 and also in Bossi and Cocco [14]</ref> where it was called restriction. The relation = defined in rule R6 is an equivalence relation. Our goal replacement rule has been adapted from various versions presented in <ref type="bibr">Tamaki and Sato [132,</ref><ref type="bibr">133]</ref>, <ref type="bibr">Maher [91-931, Gardner and Shepherdson [661, and Bossi et al. 1161</ref>. In order to cover different cases, our presentation of rule R6 is parametric w.r.t. the semantics function Sem. Let us assume that, for any definite program P and atomic query +A, Sem(P, +A) is the set of instances of A which belong to the least Herbrand model of P. The replacement law "append(V, X, W), append(W, Z, Y &gt; = append(X, L, M), append( K, M, Y)" (which expresses a weak form of associativity of append) is valid w.r.t. Sem and Pk, Indeed, if we consider the two clauses D,:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R6. Goal Replacement</head><formula xml:id="formula_1">p( X, Y) + append( V, X, W) , append( W, Z, Y), D,: p(X,Y) cappend(X,L,M),append(K,M,Y),</formula><p>we have that Sem(P,@(D,),</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>+p(X,Y)) = Sem(P,@(D,&gt;, +p(X,Y)).</head><p>Thus, by goal replacement of "append(V, X, W), append( W, Z, Y&gt;" in C, we derive the clause sublist ( N, X, Y) + length( X, N), append( X, L, M) , append( K, M, Y) .</p><p>The validity of a replacement law is, in general, undecidable. However, if we use totally correct transformation rules only, then for any transformation sequence, we need to prove a replacement law only once. Indeed, if S = T is valid w.r.t. a semantics Sem and program P, then S = T is valid w.r.t. Sem and Q for every program Q derived from P by using totally correct transformation rules.</p><p>In order to prove the validity of a replacement law, there are some ad hoc proof methods depending on the specific semantics which is considered (see Section 6).</p><p>A simple method which is parametric w.r.t. the chosen semantics is based on unfold/fold transformations. It was introduced by Kott for recursive equation programs <ref type="bibr">[83]</ref> and its application to logic programs is described in Boulanger and Bruynooghe</p><p>[18] and <ref type="bibr">Proietti and Pettorossi [1151.</ref> Given the replacement law S = T, we consider the two clauses D, and D,, which are defined from S and T as specified above, and we construct two correct transformation sequences P@(D,), . . ., P, and PC&amp;D,),..., P,, for some final program P,. Thus, Sem(P@(Ds), +p(X, ,..., X,&gt;) = Sem(P,, +p(X, ,..., X,)1 = SemU'@(D,), +p(X,,..., X,)1, and the validity of S = T w.r.t. Sem and P is proved. For instance, the validity of the replacement law considered in Example 5 can be proved as shown in the following example. p(X,Y) tappend(X,L,M),append(K,M,Y).</p><p>In order to prove that Sem(P,@(D,), +p(X,Y)) = Sem(P,@(D,), +p(X,Y))</p><p>we will construct two transformation sequences, the first one starting from Pk@( D,) and the second one starting from Pk@(DT).</p><p>Their correctness w.r.t. suitable semantics functions will be shown in Section 3.2. As a consequence, the replacement law "append(V, X, WI, append(W, Z, Y) = append(X, L, M), append( K, M, Y)" is valid w.r.t. those semantics functions and program Pk.</p><p>The first transformation sequence starting from Pk@( D,) is constructed as Then we fold clause 03 using clause D, and we derive D3f: p(X,[HIT2]) +p(X,7'2).</p><p>Thus, from Pk@( D,) we derive the final program of the transformation sequence, which is Pk@( Dl, D3f).</p><p>The second transformation sequence starts from P,@(D,).</p><p>We first unfold clause D, w.r.t. append(K, M, Y). We derive two clauses: *p(X,u).</p><p>Thus, the final program of this transformation sequence is Pk@( 04, D5f &gt;, which is equal to P,@(Dl, D3f &gt; up to variable renaming.</p><p>We finally present the clause replacement transformation rule. Similarly to the goal replacement rule, we have chosen a presentation which is parametric w.r.t. the semantics function Sem, so that we can give a uniform account of the different rules considered in the literature <ref type="bibr">[14,</ref><ref type="bibr">66,</ref><ref type="bibr">[91]</ref><ref type="bibr">[92]</ref><ref type="bibr">[93]</ref><ref type="bibr">112,</ref><ref type="bibr">132]</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Semantics Preserving Transfomzations for Definite Programs</head><p>We now consider programs without negative literals in the bodies of their clauses and we discuss the correctness of the transformation rules w.r.t. various semantics functions.</p><p>We will first review the correctness properties of unfold/fold transformations w.r.t. both the least Herbrand model and the computed answer substitution semantics. We then take into account semantics functions related to program termination, such as the finite failure semantics and the answer substitution semantics computed by the depth-first search strategy of Prolog.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1.">LEAST HERBRAND</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MODEL.</head><p>In this section we assume that the semantics function is based on the concept of least Herbrand model of a definite program. This function, call it Semn , has type Programs x Queries * (D, 5 &gt;, where Pro- grams is the set of definite programs, Queries is the set of atomic queries, and (D, 5 &gt; is the powerset of the Herbrand base ordered by set inclusion. As already mentioned, when considering least Herbrand models of programs, we assume that we are given a fixed language L, so that the Herbrand base does not change during the transformation sequences.</p><p>In particular, if we introduce a predicate, say p, not occurring in a given program, by applying rule R4, then we assume that p is in L.</p><p>Semn(P, +A) is defined as the set of atoms in the least Herbrand model of P which are instances of A.</p><p>Let us now consider the following instances of the goal and clause replacement rules, whose correctness w.r.t. Sem, can easily be checked. The above five replacement rules R&amp;-R12 will collectively be called boolean rules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R8. Goal Rearrangement. We get</head><p>Notice that rules R&amp;R11 are implicitly used when considering programs as sets of clauses, and bodies of clauses as sets of literals. On the contrary, as already mentioned, in this paper we consider programs as sequences of clauses and bodies of clauses as sequences of literals, and we have to make an explicit use of rules R8-Rll, when needed. Our choice is motivated by the fact that some instances of these rules are not correct when considering the computed answer substitution semantics (see Section 3.2.2) or the pure Prolog semantics (see Section 3.2.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2 (Tamaki and Sato [130]). Every transformation sequence constructed by using the rules of unfolding, definition introduction, definition elimination, and clause replacement is totally correct w.r.t. Sem,.</head><p>PROOF.</p><p>By the soundness and completeness of SLD-resolution, we get the total correctness of unfolding. Nothing can be said about the total correctness of a transformation sequence P O,. . . , P, containing folding and goal replacement steps different from R8 and R9. Indeed, for Pk and Pk + , , with 0 I k &lt;n, it may happen that either Sem,(P,, +A)</p><p>&lt; Semn(Pk+ i, +A) or Semn(Pk, +A) &gt; Sem,(P,+,, +A), where &lt; means 5 and f .</p><p>For instance, consider the following transformation sequence:</p><p>PO: p+9 4+,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PI: P+P q +</head><p>(by folding, or goal replacement, since p = q is valid in P,) :</p><p>p2: P+4 q + (by unfolding using the clause p t q in P,) . Notice that the construction of the transformation sequence P,, Q,, . . . , Qk, PO should be independent of the construction of the transformation sequence P",P,,...,P,-1, P,,. This independence condition is crucial because, in general, we can derive a new program by using clauses occurring in a program which is not the last one of the transformation sequence at hand. Thus, it may be the case that there exists a transformation sequence P,, P,, . . . , P,_ ,, P,,, . . . , PO, but there is no transformation sequence P,, Q,, . . . , Qk, PO, that is, P,,, P,, . . . , P,_ 1, P, is not reversible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 5. Let Sem be a semantics function and let R be a set of transformation rules which are partially correct w.r.t. Sem. If a transformation sequence constructed using R is reversible, then it is totally correct w.r.t. Sem.</head><p>In general, it is hard to check whether or not a transformation sequence is reversible. However, we have that the clause replacement rule is reversible w.r.t. itself (as a simple consequence of its definition), and rules R13 and R14, which we will introduce below, are reversible w.r.t. any set of rules including {Rl,R2, R6). Therefore, by Theorems 3 and 5, every transformation sequence P,,, P, obtained by applying rule R13 or rule R14 to a given program PO is totally correct w.r.t. Sem,.</p><p>These rules R13 and R14 are instances of the folding and goal replacement rules, respectively. As already mentioned, in general folding is not a totally correct rule w.r.t. Sem. and, thus, it is not reversible w.r.t. the set of rules made out of unfolding, folding, definition introduction, definition elimination, and boolean rules RS-R12, which are partially correct w.r.t. Semu. An analogous statement holds if we refer to T&amp;S-folding instead of folding. In rule R13 we have indicated some sufficient conditions which make the folding rule a reversible rule. These conditions are particularly useful because they can be syntactically checked. In what follows, by an application of the reversible folding rule, we will mean an application of rule R13, rather than an application of the folding rule which produces a reversible transformation sequence. Unfortunately, the reversibility restriction to the folding rule seriously limits its power. For instance, for the derivation of the recursive definition of the predicate average in the example of Section 2, we have performed a folding step which is not a reversible folding. The following example shows that the set of rules consisting of unfolding and reversible folding is strictly less powerful than the set consisting of unfolding and (totally correct) folding. P, can be obtained from P,, by a folding step (which is a T&amp;S-folding step). This folding step is totally correct because PO and P, are equivalent w.r.t. Sem,. On the other hand, it is impossible to derive P, from PO by using unfolding and reversible folding only. Indeed, if we apply unfolding or reversible folding to any clause in P,,, we get again PO. In what follows we will feel free to say "reversible goal replacement," instead of "Sem-reversible goal replacement," when the semantics function Sem is understood from the context.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R13. Reversible</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R14. Reversible Goal</head><p>Example 9. Consider again the programs PO and P, of Example 8. The folding step which produces P, from P, can also be viewed as a goal replacement step, because p = q, r is valid w.r.t. Sem. and PO. Since p = q, r is valid also w.r.t. Sem, and P,, the transformation step from P,, to P, can be viewed as an application of the SemH-reversible goal replacement rule and, therefore, it is correct w.r.t. Sem,.</p><p>As a summary of the above considerations, we have the following result. We have seen that the reversible folding rule R13 has the advantage of being a totally correct transformation rule, but, as already mentioned, it is a weak rule (see Example 8). In order to overcome this limitation, we now present a more powerful folding rule which is not an instance of R13 and yet is totally correct w.r.t. Sem,. The correctness of this new rule is ensured by an easily verifiable condition on the transformation sequence. Let us first notice that by performing a folding step, we may introduce recursive clauses from nonrecursive clauses and some infinite computations may replace finite computations, thereby affecting the semantics of the program and loosing total correctness.</p><p>A simple example of this undesired introduction of infinite computations is self-folding, where all clauses in a predicate definition can be folded using themselves. For instance, the definition p +-q of a predicate p can be replaced (using T&amp;S-folding) by p +p. This inconvenience can be avoided by ensuring that "enough" unfolding steps have been performed before folding, so that "going backward in the computation" (as folding does) does not prevail over "going forward in the computation" (as unfolding does). This idea is the basis of various techniques in which total correctness is ensured by counting the number of unfolding and folding steps performed during the transformation sequence <ref type="bibr">[3,</ref><ref type="bibr">17,</ref><ref type="bibr">75,</ref><ref type="bibr">77,</ref><ref type="bibr">82]</ref>. For the presentation of the powerful folding rule we promised above, we need the following assumptions <ref type="bibr">[124]</ref>. We assume that all predicate symbols occurring in each program of a transformation sequence P,,, . . . , P,, are partitioned into the set Pred,,, of new predicates and the set Pred.,, of old predicates. New predicates are the ones which either occur in the head of exactly one clause of PO, and not elsewhere in PO, or they are in the head of clauses introduced by applying the T &amp; S-definition rule (see below). The distinction between new and old predicates could be generalized in a way similar to the one presented in <ref type="bibr">Tamaki and Sato [1331,</ref> where the set of predicates of the initial program is partitioned into an arbitrary number of levels so that the level of a predicate symbol in the body of a clause is not greater than the level of the head of the clause. Notice that due to T&amp;S-folding steps, a new predicate may occur in the body of a clause whose head has an old predicate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R1.5. T&amp;S-Definition</head><p>In order to describe some conditions which ensure the total correctness of T&amp;S-folding (see Theorem 8 below), we need to take into account whether or not an atom has been generated by unfolding during a transformation sequence. This motivates the introduction of the following notion which we describe in the case of normal programs because we also need to use it later in Section 3. One can easily show that inherited literals defined in <ref type="bibr">Seki [124]</ref> are exactly the literals which are not fold-allowing according to Definition 7. The hypothesis that no T&amp;S-folding step is performed after a definition elimination step is needed to prevent a T&amp;S-folding step being applied using a clause with a head predicate whose definition has been eliminated. This point is illustrated by the following example. (by T&amp;S-folding).</p><p>According to our definition, newp is a new predicate and p is an old one. Thus, hypotheses (i) and (ii) of Theorem 8 are fulfilled. However, the transformation sequence is not correct w.r.t. Sem,.</p><p>Notice that when we T&amp;S-fold clause C w.r.t. a sequence of atoms in bd(C), no atom in that sequence is required to be fold-allowing.</p><p>Theorem 8 can be used to show the correctness of the transformation process presented in Section 2, where average is the only new predicate. Unfortunately, Theorem 8 does not ensure the correctness of a transformation sequence where we allow general Semn-reversible goal replacement steps. However, we may construct transformation sequences containing both Semn-reversible goal replacement steps and folding steps which are not instances of R13, by concatenating several transformation sequences, each of them being proved correct either by Theorem 6 or by Theorem 8.</p><p>The reader may find in <ref type="bibr">Tamaki and Sato [132,</ref><ref type="bibr">133]</ref> and Gardner and Shepherdson [66] some other restricted forms of the folding and goal replacement rules which are correct w.r.t. Sem,.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2.">COMPUTED ANSWER SUBSTITUTIONS.</head><p>We now consider the semantics function Sem based on the notion of computed answer substitutions [891, which captures the procedural behavior of definite programs more accurately than the least Herbrand model semantics.</p><p>Two substitutions 71 and 8 are said to be equal modulo renaming iff there exists a renaming substitution p such that 77 is equal to the restriction of tip to the domain of 6. In what follows we will always consider substitutions modulo renaming.</p><p>The computed answer substitution semantics is a function Sem,,: Programs X Queries --) (D, I), where Programs is the set of definite programs, Queries is the + q(t(4Z)) + .</p><p>By deleting an occurrence of q(X) in the body of the first clause, we get P2 : P(X) c q(X) 4(f(K a&gt;&gt; + 4(+A) + *</p><p>The substitution {X/t(a, a)} belongs to Sem,,(P,, + p(X)) and not to Sem,(P,, +p(X)).</p><p>Let us consider now the program</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P: p(X) + p(a) +-.</head><p>The clause p(a) +-is subsumed by p(X) t . However, if we delete p(a) + , the Semc'4 semantics is not preserved, because (X/a} is no longer a computed answer substitution for the query +-p(X).</p><p>There are particular cases where the deletion of duplicate goals and the deletion of subsumed clauses are correct w.r.t. Sem,, and indeed the following two rules are correct w.r.t. Sem,.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>, P,, be a transformation sequence constructed by using the following transformation rules: unfolding, T&amp;S-folding, T&amp;S-definition, definition elimination, goal rearrangement, deletion of duplicate ground goals, clause rearrangement, deletion of duplicate clauses, and deletion of clauses with finitely failed body. Suppose that no T&amp;Sfolding step is performed after a definition elimination step. Suppose also that we apply T&amp;S-folding to a clause C using a clause D only if (i&gt; hd(D) has a new predicate and (ii) either hd(C) has an old predicate or</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>. , P,, be a transformation sequence of definite programs constructed by using the transformation rules: unfolding, reversible folding, definition introduction, definition elimination, reversible goal replacement (in particular, rules R8 and R9), and clause replacement (in particular, rules RIQ, Rll, and Rl2).</head><p>Then PO,..., P, is correct w.r.t. Sem,,.</p><p>Notice that, since fairness of  is a sufficient condition for obtaining a finitely failed SLD-tree, if there exists one, the preservation of fairness ensures the total correctness of a transformation sequence w.r.t. SEM,,. Unfortunately, if we allow folding steps which are not reversible foldings, it may be the case that a folding step affects the fairness of SLD-derivations, because as we will show below, it imposes a "synchronized" evaluation of a sequence of atoms. Thus, given a program P, and a query Q, by applying folding steps which are not reversible, we may derive a program P2 such that a fair SLD-derivation for Q using Pz encodes an unfair SLD-derivation for Q using P,.  </p><formula xml:id="formula_2">Let</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 12 (Correctness of T&amp;S-folding w.r.t. Sem,, [124]). Let PO,. . . , P,, be a transformation sequence of definite programs constructed by using the following transformation rules: unfolding, T&amp;S-folding, T&amp;S-dejkition, definition elimination, and boolean rules. Suppose that no T&amp;S-folding step is per$ormed after a definition elimination step. Suppose also that we apply T&amp;S-folding to a clause C using a clause D only if (i) hd( D) has a new predicate and (ii&gt; either hd(C) has an old predicate or all atoms of bd(C) w.r.t. which T&amp;S-folding steps</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.4.">PURE PROLOG.</head><p>In this section we consider the case where a definite program is evaluated using a Prolog evaluator. Its control strategy can be described as follows. The SLD-tree for a given program and a given query is constructed by using the left-to-right rule for selecting the atom w.r.t. which SLD-resolution should be applied in a given goal. In this SLD-tree, the sons of a given goal are ordered from left to right according to the order of the clauses used for performing the corresponding SLD-resolution step. Thus, we have an ordered SLD-tree which is visited in a depth-first manner. The use of the Prolog control strategy has two consequences:</p><p>(i) the answer substitutions are generated in a fixed order, possibly with repetitions, and (ii) there may be some answer substitutions which cannot be obtained in a finite number of computation steps, because in the depth-first visit they are "after" branches of infinite length. Therefore, the completeness of SLD-resolution is lost. We will define a semantics function Sem,,,,,, by taking into consideration the generation order, the multiplicity, and the "finite time computability" of the answer substitutions.</p><p>Thus, given a program P and a query Q, we consider the ordered SLD-tree T constructed as specified above. The left-to-right ordering of the brother nodes in T determines the left-to-right ordering of the branches and leaves.</p><p>If T is finite, then Sem,,,,,,(P, Q) is the sequence of the computed answer substitutions (module renaming) corresponding to the nonfailed leaves of T in the left-to-right order. If T is infinite, we consider a (possibly infinite) sequence F of computed answer substitutions (module renaming), each substitution being associated with a leaf of T. F is obtained by visiting from left to right the nonfailed leaves which are on branches to the left of the leftmost infinite branch. There are two cases: either F is infinite, in which case Sem,,,,,,(P, Q) is F, or F is finite, in which case Sem Pro,og(P, Q) is F followed by the symbol I , which is called the undefined substitution. All substitutions different from I are said to be defined. <ref type="figure">Thus,</ref><ref type="figure">Sem,</ref><ref type="figure">,</ref><ref type="figure">,</ref><ref type="figure">,</ref><ref type="figure">,</ref><ref type="figure">,</ref><ref type="figure"></ref> is defined as a function from Programs X Queries to (D, s), where Programs and Queries are the sets of definite programs and atomic queries, respectively.</p><p>(D, I) is the set SubstSeq of finite or infinite sequences of defined substitutions and finite sequences of defined substitutions followed by the undefined substitution I . Similar approaches to the semantics of Prolog can be found in <ref type="bibr">Jones and Mycroft [74]</ref>, Debray and Mishra <ref type="bibr" target="#b36">[38]</ref>, <ref type="bibr">Deville [44]</ref>, and <ref type="bibr">Baudinet [7]</ref>.</p><p>The sequence consisting of the substitutions Oi, 8,, . . . is denoted by (8,, 8,, . . . &gt;, and the concatenation of two sequences S, and S, in SubstSeq is denoted by S,@S, and is defined as the usual monoidal concatenation of finite or infinite sequences, with the extra property ( I )@S = ( I &gt;.</p><p>Example 13. Consider the following three programs: The order 5 over SubstSeq expresses a less defined than or equal to relation between sequences which can be introduced as follows. For any two sequences of substitutions S, and S,, the relation S, I S, holds iff either S, = S, or S, = S,@ ( I ) and S, = S,@S,, for some S, and S, in SubstSeq. For instance, ( I &gt; 5 S for any (possibly empty) sequence S and for all substitutions nl, q2, n3 with n1 Z I and v2 z I, (TV, I &gt; I (q,v2,v3).</p><p>The sequences (TV) and (v1,v2) are not comparable w.r.t. the order I . Unfortunately, most transformation rules presented in the previous sections are not even partially correct w.r.t. Sem,,,,,,. Indeed, it is easy to see that the We also have that the use of the folding rule does not always preserve Sem,,,,,,. In order to overcome this inconvenience, several researchers have proposed restricted versions of the unfolding and folding rules [112,1181. The following rules R18 and R19 are two instances of the unfolding rule which can be shown to be totally correct w.r.t. Sem,,,,,,. We have that the goal replacement rule is partially correct w.r.t. Sem,,,,,, and so is the T&amp;S-folding rule if we allow the use of clauses of the current program only. Thus, we can state a result which is analogous to Theorems 6, 9, and 11 for Sem,, Sem,,, and Sem,,, respectively. The following example shows that in Theorem 14 we cannot replace "the leftmost atom" by "an atom."</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RIS. Leftmost</head><p>Example 17. Let us consider the initial program</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P(): P +q(X),r(X) q(X) + fail r(X) -r(X).</head><p>We have that (i) p is a new predicate and q, r, and fail are old predicates and (ii) the occurrences of q(X) and r(X) in the first clause are not fold-allowing. By deterministic non-left-propagating unfolding of p + q(X), r(X) w.r.t. r(X), we get the following program which is equal to P,,: p,:</p><p>P +q(X),r(X) q(X) * fail r(X) +-r(X).</p><p>Now, the occurrence of r(X) in the first clause is fold-allowing.</p><p>If we fold the first clause of P, using that same clause, we get P,:</p><p>P.-P q(X) + fail r(X) +r(X).</p><p>P, is not equivalent to PO w.r.t. Sem,,,,,,. Indeed, we have that Sem Prolog( P,, ) +p) = ( &gt;, Sem Pro,&amp;% CP) = ( <ref type="formula">1</ref>).</p><p>In this paper we have considered only the case of pure Prolog, where the SLD-resolution steps have no side effects. Properties preserved by unfold/fold rules when transforming Prolog programs with side effects, including cuts, can be found in <ref type="bibr">Deville [44]</ref>, <ref type="bibr">Sahlin [118]</ref>, and <ref type="bibr">Prestwich [109]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Semantics Preserving Transformations for Normal Programs</head><p>In this section we consider the case where the bodies of the clauses contain negative literals. There is a large number of papers dealing with transformations that preserve the various semantics which have been proposed for logic programs with negation. In particular, some restricted forms of unfolding and folding have been shown to be correct w.r.  <ref type="bibr">[93,</ref><ref type="bibr">125,</ref><ref type="bibr">138]</ref>. For limitations of space, we will report here only on the results concerning the following three semantics [89]: (i) success set, (ii&gt; finite failure set, and (iii) Clark's completion.</p><p>The success set semantics for normal programs, denoted Sems,, is a function from Programs x Queries to (D, s), where Programs is the set of normal programs, Queries is the set of atomic queries, and (D, I), is the powerset of the set of (possibly not ground) atoms ordered by set inclusion. By definition we have that Sem,,(P, +A) = (B I B is an instance of A and there exists an SLDNF-refutation for P and +B).</p><p>The finite failure semantics for normal programs, denoted Sem,,, has the same domain and codomain of Sem,, . By definition we have that Sem,,(P, +A) = {B 1 B is an instance of A and there exists a finitely failed SLDNF-tree for P and t B}. For the correctness of a transformation sequence w.r.t. Sem,, and Sem,, there are results which are analogous to Theorem 12. Indeed, the statement of that theorem is valid if we replace "definite programs" by "normal programs" and we consider any of the two semantics Sems, or Sem,,.</p><p>Notice also that the hypotheses for the version of Theorem 12 for normal programs and Sem,, are more restrictive than the hypotheses of Theorem 8 for definite programs and Sem,. This is due to the fact that in order to preserve the success set of normal programs, we may need to preserve their finite failure sets as well, because the evaluation of positive goals may require the evaluation of negative goals.   P(X) *q(X) P(X) + 7 q(succ(X)) q(X) + q(succ(succ( X))) 3</p><p>whose completion is (equivalent to)</p><p>Comp(P,): vX( P(X) -q(X) V ~q(succ(X)))</p><p>VX(q(X) f, q( succ( succ( X))) )</p><p>together with the axioms of CET.</p><p>We have that VXp(X&gt; is a logical consequence of Comp(P,,). On the other hand, VXp(X&gt; is not a logical consequence of Comp(P,). Indeed, let us consider the interpretation Z whose universe is the set of integers, p(x) holds iff q(x) holds iff x is an even integer, and succ is the successor function.</p><p>Z is a model of Comp( PI&gt; whereas it is not a model of VXp( X).</p><p>We may restrict the use of the unfolding rule to make it totally correct w.r.t.</p><p>Semc,,, by requiring that during a transformation sequence no self-unfolding steps are performed, that is, we never unfold a clause using itself (and possibly other clauses).</p><p>Indeed, if program P, is derived from program PO by performing an unfolding step which is not self-unfolding, then the transformation sequence PO, P, is reversible (w.r.t. any set of rules including Rl and R13), because we may get PO from P, by reversible folding (rule R13). Thus, by Theorems 5 and 15, we have that the unfolding rule is totally correct w.r.t. Semcomp.</p><p>As a consequence, we have the following result, where by reversible unfolding, we mean an unfolding step which is not self-unfolding. We have that r is a logical consequence of CornlAP,,). On the contrary, r is not a logical consequence of Comp(P,). Indeed, the interpretation where p is false, q is true, and r is false is a model of Comp(P,&gt;, but not of r. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>It should be noted that in</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">STRATEGIES FOR TRANSFORMING LOGIC PROGRAMS</head><p>The transformation process should be directed by some metarules, which we call strategies, because, as we have seen in the previous section, the transformation rules have inverses, and thus, they allow for final programs which are equal to the initial programs. Obviously, we are not interested in such useless transformations. In this section we present an overview of some transformation strategies which have been proposed in the literature.</p><p>They are used, in particular, for solving one of the most crucial problems of the transformation methodology, that is, the use of the definition rule for the introduction of the so-called eureka predicates. In some examples below we will construct transformation sequences by using both T&amp;S-folding and reversible goal replacement not in accord with the hypotheses of Theorems 6 and 8. In these examples, however, the correctness w.r.t. Sem, continues to hold, as the reader may check by referring to <ref type="bibr">Tamaki and Sato [132,</ref><ref type="bibr">133]</ref>.</p><p>In order to simplify our presentation, we will usually avoid the use of rule R8 (goal rearrangement) and rule R9 (deletion of duplicate goals). If we allow the use of boolean rules, then the concatenation of sequences of literals and the concatenation of sequences of clauses are associative, commutative, and idempotent.</p><p>Therefore, in that case, when dealing with collections of literals or programs, we will feel free to use set-theoretic notations, such as { ... ] and U instead of ( *.a) and @.</p><p>Before presenting the technical details of the transformation strategies, we would like to give an informal explanation of the main ideas which justify their use. We are given an initial program and we want to apply the transformation rules to improve its efficiency. In order to do so, we usually need a preliminary analysis of the initial program by which we discover that the evaluation of a goal, say A , , . . . , A,, in the body of a program clause is inefficient because it evokes some redundant computations. For example, by analyzing the initial program P, given in Section 2, we may discover that the evaluation of the conjunction of atoms "length(L, N), sumlist(l, S)" in the body of the clause The efficiency improvements due to the unfoldings can be iterated at each level of recursion and, thus, they become computationally significant only if we find a recursive dejinition of newp. In that case, the multiple traversals of the input will be avoided for any given list. This recursive definition can often be achieved by performing a folding step using the clause N introduced by tupling. In our case, by folding we get 10f. newp([HIT], s(N), Sl) + newp(T, N, S), sum(H, S, Sl) and, indeed, this recursive clause together with clause 9 avoids multiple traversals of any input list.</p><p>In some unfortunate cases we may not be able to perform the desired final folding steps and derive the recursive definition of newp. In those cases we may use some auxiliary strategies and we may introduce some extra eureka predicates which allow us to perform the required folding steps. Two of those auxiliary strategies are the loop absorption and generalization strategies described in Section 4.1.</p><p>In <ref type="bibr">Darlington [34]</ref>, the expression "need for folding" is introduced to refer to the need to perform the final folding steps for improving program efficiency. This need plays an important role in the program transformation methodology, and it can be regarded as a metastrategy.</p><p>It is the need for folding that often suggests the suitable strategy to apply at each step of the derivation.</p><p>Need for folding in program transformation is related to similar ideas in the field of automated theorem proving [19] and program synthesis 1461, where inductive proofs and inductive synthesis tactics are driven by the need to apply an inductive hypothesis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Basic Transformation Strategies</head><p>We now describe some of the basic strategies which have been introduced in the literature for transforming logic programs. They are tupling, loop absorption, and generalization.</p><p>The basic ideas underlying these strategies come from the early days of program transformation and they were already present in <ref type="bibr">Burstall and Darlington [27]</ref>. The tupling strategy was formally defined by <ref type="bibr">Pettorossi [106]</ref>, where it was used for tupling together different function calls which require common subcomputations or visit the same data structure.</p><p>The name "loop absorption" was introduced by Proietti and <ref type="bibr">Pettorossi [ill]</ref> to indicate a strategy which derives a new predicate definition when a goal is recurrently evaluated in the program to be transformed. This strategy is present in various forms in a number of different transformation techniques, such as the above-mentioned tupling, supercompilation [136], compiling control [23], as well as various techniques for partial evaluation (see Section 5). Finally, the generalization strategy has its origin in the automated theorem proving context <ref type="bibr">[19]</ref>, where it is used to generate a new generalized conjecture to allow the application of an inductive hypothesis. The tupling, loop absorption, and generalization strategies will be used in this paper as building blocks to describe a (nonexhaustive) number of more complex transformation techniques. For a formal description of the strategies and their possible mechanization, we now introduce the notion of unfolding tree, which represents the process of unfolding a given clause using a given program. This notion is also related to the notion of symbolic trace tree of <ref type="bibr">Bruynooghe et al. [231,</ref><ref type="bibr">where,</ref><ref type="bibr">however,</ref><ref type="bibr">goal replacement</ref> is not taken into account.</p><p>Definition 1% Let P be a program and let C be a clause. An unfolding tree for (P,C) is a (finite or infinite) nonempty labeled tree such that:</p><p>(i) the root is labeled by the clause C; In an unfolding tree we also have the usual relations of descendant node (or clause) and ancestor node (or clause).</p><p>Given a program P and a clause C, the construction of an unfolding tree for (P,C&gt; is nondeterministic.</p><p>In particular, during the process of constructing an unfolding tree, we need to decide whether or not a node should have son-nodes, and in case we decide that son-nodes should be constructed by unfolding, we need to choose the atom w.r.t. which unfolding step should be performed. These choices can be realized by using a function defined as follows.</p><p>Definition 18. An unfolding selection rule (or u-selection rule, for short) is a function that, given an unfolding tree and one of its leaves, tells us whether or not to unfold the clause in that leaf and in the affirmative case, tells us the atom w.r.t. which that clause should be unfolded. We now formally introduce the tupling, loop absorption, and generalization strategies.</p><p>Sl. Tupling. Let A,, . . . , A,, with n 2 1, be some atoms occurring in the body of a clause C of a given initial program. We introduce a new predicate newp defined by a clause T of the form newp(X, ,..., X,) +A, ,..., A,, where Xi,..., X, are the linking variables of A,, . . . , A, in C. We then look for the recursive definition of the eureka predicate newp by performing some unfolding steps followed by suitable folding steps using clause T. We finally fold clause C w.r.t. the atoms A,, . . . , A, using clause T.</p><p>The tupling strategy is often applied when A,, . . . , A, share some variables. The program improvements which can be achieved by using this strategy are based on the fact that we need to evaluate only once the subgoals which are common to the computations determined by the tupled atoms A,, . . . , A,. By tupling, we can also avoid multiple visits of data structures and the construction of intermediate bindings.  <ref type="figure">,</ref><ref type="figure">A,</ref><ref type="figure">,</ref><ref type="figure">,</ref>, for a given substitution 0, and {X1,..., X,} is a superset of the variables which are necessary to fold C using a clause whose body is GenA 1,. . . , GenA,. We then fold C using G and we get H+genp(X ,,..., X,)O,B, ,..., B,.</p><p>We finally look for the recursive definition of the eureka predicate genp.</p><p>A suitable form of the clause G introduced by generalization can often be obtained by matching clause C against one of its descendants, say D, in the unfolding tree which is considered during program transformation (see Example 23 below). In particular, we will consider the case where the following four conditions hold:</p><p>1. D is the clause K + E,, . . . , E,, F,, . . . , F, and D has been obtained from C by applying no transformation rule, except for R8 and R9, to B,, . . . , B,. 2. E 1,. . . , Em is not an instance of A,, . . . , A,. 3. The goal GenA 1,. . . , GenA, is the most specific generalization of A,, . . . , A, and E1,...,E,. 4. {X,, . . .) X,} is the minimum subset of vars(Gewl,, . . . , Gewl,) which is necessary to fold both C and D using a clause whose body is GenA,, . . . , Gewl,.</p><p>Notice that if conditions 1, 3, and 4 hold and E,, . . . , E,,, is an instance of A ,, . . . , A,, then loop absorption is applicable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Techniques Which Use Basic Transfomation Strategies</head><p>In this section we will present some techniques for improving program efficiency by using the tupling, loop absorption, and generalization strategies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">COMPILING</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CONTROL.</head><p>One of the advantages of logic programming over conventional imperative programming is that by writing a logic program, one may separate the "logic" part of an algorithm from the "control" part <ref type="bibr">[85]</ref>. By doing so, the correctness of an algorithm w.r.t. a given specification is often easier to prove. Obviously, we are then left with the problem of providing an efficient control.</p><p>Unfortunately, the standard top- We consider here a transformation technique, called compiling control 1231, which follows a different approach. Instead of enhancing the naive Prolog evaluator using a better (and often more complex) control strategy, we transform the given program so that the derived program behaves under the naive evaluator as the given program would behave under an enhanced evaluator. The main advantage of the compiling control technique is that we can use relatively simple evaluators which have small and efficient compilers.</p><p>The compiling control approach can also be followed to "compile" bottom-up and mixed evaluation strategies <ref type="bibr">[43,</ref><ref type="bibr">120]</ref> as well as lazy evaluation and coroutining <ref type="bibr">[lOO]</ref>. In this paper we only show the use of the compiling control technique in the case where the control to be "compiled" is a computation rule different from the left-to-right Prolog rule. In this case, by applying compiling control, one can improve <ref type="bibr">generate-and-test</ref> programs by simulating a computation rule which selects test predicates as soon as the relevant data are available.</p><p>A similar idea also has been investigated in the area of functional programming, within the so-called filter promotion strategy <ref type="bibr">[9,</ref><ref type="bibr">34]</ref>. Some other transformation techniques for improving generate-and-test logic programs which are closely related to the compile control technique and the filter promotion strategy can be found in <ref type="bibr">Seki and Furukawa [126]</ref>, <ref type="bibr">Brough and Hogger [21]</ref>, and Tdff and Prestwich we mean that for a query in Q, the SLD-tree, say T,, constructed by using P, and the computation rule C, is equal to the SLD-tree, say T,, constructed by using P2 and the left-to-right computation rule if (i) we look at T, and Tz as directed trees with leaves labeled by "success" or "failure" and arcs labeled by most general unifiers, and (ii&gt; we possibly replace nonbranching paths of T, by single arcs, each of which is labeled by the composition of the most general unifiers labeling the corresponding path to be replaced. Thus, when comparing the trees T, and T2, we disregard the goals in the nodes.</p><p>Basic forms of compiling control can be formulated as follows. Given a program P,, a set Q of queries, and a computation rule C, compiling control derives the new program P2 by first constructing a suitable unfolding tree, say T, and then applying the loop absorption strategy. (Some more complex forms of compiling control require the use of generalization strategies possibly more powerful than S3.) Without loss of generality, we assume that every query in Q is of the form + q( ... &gt; and in P, there exists only one clause, say R, whose head predicate is q. (We can use the T&amp;S-definition rule to comply with this condition.)</p><p>The root clause of T is R, and new nodes are generated by using a suitable u-selection rule. It is required that the unfolding tree T constructed from P,, Q, and C satisfy the condition that each SLD-tree generated by a query in Q using the program P, and the computation rule C is a concretization tree T, which is derived from T as follows.</p><p>Let q( -.a &gt; be unifiable with hd(R) via a substitution 13. Ty is derived from T by (8 deleting each node (and the subtree rooted in that node) whose clause head is not unifiable with hd(R)B, (ii) replacing, for each remaining node, the clause in that node, An unfolding tree T starting from the clause q(X) -+ r(X), s(X) is as depicted in Figure <ref type="figure" target="#fig_2">1</ref>, where (as we will also do in all figures) we have underlined the atoms which have been selected for unfolding.</p><p>Figure <ref type="figure">2</ref> shows the concretization tree Ty of the tree T for the query + q(b)</p><p>and the substitution 8 = {X/b}.</p><p>Notice that, in general, the unfolding tree T may correspond to an infinite set of concretization trees (because Q may be infinite). Thus, T itself may be an infinite tree and, in this case, the compiling control technique is applied by looking for a finite-graph representation Example 22 (Common subsequences). Let sequences be represented as lists of items. We assume that subseq(X, Y) holds iff X is a subsequence of Y in the sense that X can be obtained from Y by deleting some (possibly not contiguous) elements.</p><p>Suppose that we want to verify whether or not a sequence X is a common subsequence of the two sequences Y and Z. The following program Csub does so by first verifying that X is a subsequence of Y, and then by verifying that X is a subsequence of Z.</p><p>q(X) + r(X), SW) -</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>/I\</head><p>q(a) + s(a) q(X) + t(X). SW q(X) + u(X), s(X) -</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I</head><p>/\-I- where csub(X, Y, Z) holds iff X is a subsequence which is common to both Y and Z.</p><p>Let Q be the set of queries { + csub(X, sl, $2) I sl and s2 are ground lists and X is an unbound variable} and let the computation rule C be the following: if the body of the clause to be unfolded is subseqcw, x&gt;, subseqcy, z) and w is a proper subterm of y, then C selects the atom subseqcy, z) else C selects the leftmost atom in the body.</p><p>We first construct the infinite unfolding tree T corresponding to Csub, Q and C. A finite-graph representation of T is depicted in Figure <ref type="figure">3</ref>, where dashed arrows denote identifications of nodes. The tree T has as its root clause 1, which is the only clause whose head unifies with csub(X, sl, ~2).</p><p>We leave to the reader the task of verifying that for every query + csub(X, sl, ~2) in Q, the SLD-tree rooted in + csub(X, sl, ~2) and constructed by using the computation rule C is a concretization tree of T. Since the body of clause 10 is an instance of the body of clause 6, we apply the loop absorption strategy. We introduce a eureka predicate newcsub by the clause The final program is made out of clauses 8, 6f, 7f, 12f, and 13f.</p><p>Let us now compare the SLD-tree, say T,, for Csub, a query +-csub(X, sl, ~2) in Q, and the computation rule C, with the SLD-tree, say T2, for the final program, the query + csub(X, sl, ~21, and the left-to-right computation rule. The trees T, and T, are equal except that (i) if a node of T, is labeled by a goal of the form 2 susu;q( ... ), subseq( .a. &gt;, then th e corresponding node of T2 is labeled by either ... ) or + newcsub( ... 1, and ("1 u some paths of T, have been replaced according to the rewritings shown in Figure <ref type="figure" target="#fig_5">4</ref> for any unbound variable X and ground lists tl and t 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2.">COMPOSING PROGRAMS.</head><p>A popular style of programming, which can be called compositional, consists of decomposing a given goal in smaller and easier subgoals, then writing pieces of programs which solve these smaller subgoals, and finally, composing the various pieces together. The compositional style of programming is often helpful for writing programs which can be understood easily and proved correct w.r.t. their specifications.</p><p>Unfortunately, this programming style often produces inefficient programs because the composition of the various subgoals does not take into account the interactions which may occur among the evaluations of these subgoals. For instance, let us consider a logic program with a clause of the form P(X) -s(X,Y),4Y), where in order to solve the goal p(X), we are required to solve q(X, Y) and r(Y).</p><p>The binding of the variable Y is not explicitly needed because it does not occur in the head of the clause. If the construction and the destruction of that binding are expensive, then our program is likely to be inefficient.</p><p>Similar problems occur when the compositional style of programming is applied for writing programs in other programming languages different from logic. In imperative languages one may construct several procedures which are then combined together by using various kinds of sequential or parallel composition operators. In functional languages, the small subgoals in which a given goal is decomposed are solved by means of individual functions which are then combined by using function application or tupling. There are various papers in the literature which present techniques for improving the efficiency of the evaluation of programs written according to the compositional style of programming.</p><p>Similarly to the case discussed in Section 4.2.1, two approaches have been followed: (1) the improvement of the evaluator by using, for instance, garbage collection, memoization, and various forms of laziness and coroutining, and ( <ref type="formula">2</ref>) the transformation of the given program into a semantically equivalent program which can be more efficiently evaluated by a nonimproved evaluator.</p><p>In and composing simpler programs. The method presented in <ref type="bibr">Proietti and Pettorossi [113]</ref> may be used for deriving programs without unnecessary variables. A variable X of a clause C is said to be unnecessary if at least one of the following two conditions holds: (1) X occurs more than once in the body of C (in this case we say that X is a shared variable);</p><p>(2) X does not occur in the head of C (in this case we say that X is an existential variable). Since unnecessary variables often determine multiple traversals of data structures and construction of intermediate data structures, the results of unnecessary variable elimination are often similar to those of loop fusion. In the following example we recast loop fusion and unnecessary variable elimination in terms of the basic strategies presented in Section 4.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 23 (Minimal leaf replacement).</head><p>Suppose that we are given a binary tree, say InTree, whose leaves are labeled by numbers. We want to obtain another tree, say OutTree, of the same shape with all its leaves replaced by their minimal value. This can be done by first computing the minimal leaf value, say Min, of InTree, and then again visiting InTree for replacing its leaves by Min. A program which realizes this algorithm is as follows:</p><p>1. mintree(InTree, OutTree) 6 minleaves(InTree, Min), replace(Min, InTree, OutTree), 2. minleaves(tip(iV), N) + , 3. minleaves(tree(l, R), Min) + minleaves(l, MinL), minleaves(R, MinR), min(MinL, MinR, Min), 4. replace(M, tip(N), tip(M)) + , 5. replace(Min, tree(InL, InR), tree(OutL, OutR)) + replace(Min, InL, OutL), replace(Min, InR, OutR),</p><p>where min(M1, M2, M) holds iff M is the minimum number between Ml and M2.</p><p>We would like to derive a program which traverses InTree only once. This could be done by applying the loop fusion method and obtaining a new program where the computations corresponding to minleaves and replace are performed by one predicate only. The same results can be achieved by avoiding the shared variables whose bindings are binary trees and, in particular, the variable InTree in clause 1.</p><p>To this aim we may apply the tupling strategy to the predicates minleaves and replace which share the argument InTree. Since the atoms to be tupled constitute the whole body of clause 1 defining the predicate mintree, we do not need to introduce a new predicate and we only need to look for the recursive definition of the predicate mintree. After some unfolding steps, we get 6. mintree(tip(N), tip(N)) + , 7. mintree(tree(InL, InR),tree(OutL, OutR)) + minleaves(InL, MinL), minleaves(InR, MinR), min(MinL, MinR, Min), replace(Min, InL, OutL), replace(Min, InR, OutR).</p><p>As suggested by the tupling strategy, we may now look for a fold of the goal "minleaves(InL, MinL), replace(Min, InL, OutL)" using clause 1. Unfortunately, no matching is possible because this goal is not an instance of "minleaves(InTree, Min), replace(Min, InTree, OutTree)." Thus, we apply the generalization strategy and we introduce the clause 8. genmintree(InTree, Ml, M2, OutTree) + minleaves(InTree, Ml), replace(M2, InTree, OutTree), whose body is the most specific generalization of the two goals to be folded, that is, "minleaves(InL, MinL), replace(Min, InL, OutL)" and the body of clause 1. By folding clause 1 we get If. mintree(InTree, OutTree) + genmintree(InTree, Min, Min, OutTree).</p><p>We are now left with the problem of finding the recursive definition of the predicate genmintree introduced in clause 8. This is an easy task because we can perform the unfolding steps corresponding to those leading from clause 1 to clauses 6 and 7, and then we can use clause 8 for folding. After these steps, we get the final program:</p><p>If. mintree(InTree, OutTree) + genmintree(InTree, Min, Min, OutTree), 9. genmintree(tip(N), N, M, tip(M)) + , 10. genmintree(tree(InL, InR), Ml, M2, tree(OutL, OutR)) + genmintree(InL, MLl, M2, OutL), genmintree(InR, MRl, M2, OutR), min(ML1, MRl, Ml).</p><p>This program performs the desired tree transformation in one visit. Indeed, let us consider the evaluation of a query of the form + mintree(t, T), where t is a ground binary tree and T is an unbound variable. During the visit of the input tree t, the predicate genmintree both computes the minimal leaf value Ml and replaces the leaves using the unbound variable M2. The instantiation of M2 to the minimal leaf value is performed by the unification of the variables Ml and M2 due to clause If of our final program.</p><p>Notice also that no shared variable whose binding is a binary tree occurs in the clauses defining mintree and genmintree. Thus, we have been successful in eliminating unnecessary variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3.">CHANGING DATA REPRESENTATIONS.</head><p>The choice of appropriate data structures is usually very important for the design of efficient programs. In essence, this is the meaning of Wirth's motto "algorithms + data structures = programs" <ref type="bibr">[146]</ref>.</p><p>However, it is sometimes difficult to identify the data structures which allow a very efficient execution of our algorithms before actually writing the programs. Moreover, complex data structures may complicate correctness proofs.</p><p>Program transformation has been proposed as a methodology for providing appropriate data structures in a dynamic way <ref type="bibr">([104]</ref>, Chapter 8): first the programmer writes a preliminary version of the program implementing a given algorithm using simple data structures, and then he transforms their representations while preserving program semantics and improving efficiency.</p><p>The transformational design of data structures in the framework of logic programming is considered in <ref type="bibr">[99]</ref> where programs which manipulate trees are derived.</p><p>Another example of transformational change of data representations is the transformation of logic programs which use lists into equivalent programs which use difference-Zists. <ref type="bibr">Difference-lists</ref> are data structures which are sometimes used for implementing algorithms that manipulate sequences of elements. The advantage of using difference-lists is that the concatenation of two sequences represented as difference-lists can often be performed in constant time, while the concatenation of standard lists takes linear time w.r.t. the length of the first list.</p><p>A difference-list can be though of as a pair (L, R) of lists, denoted by L \R, such that there exists a third list X for which the concatenation of X and R is L <ref type="bibr">[30]</ref>. In that case we say that X is represented by the difference-list L\R.</p><p>Obviously, a single list can be represented by many difference-lists.</p><p>Programs that use lists are often simpler to write and understand than the equivalent programs which make use of difference-lists. Several (semi)automatic methods for the transformation of programs which use lists into programs which use difference-lists have been proposed in the literature <ref type="bibr">[20,</ref><ref type="bibr">69,</ref><ref type="bibr">94,</ref><ref type="bibr">115,</ref><ref type="bibr">147]</ref>.</p><p>The problem of obtaining programs which use difference-lists, instead of lists can be formulated as follows. Let p(X,Y) be a predicate defined in a program P, where Y is a. list. We want to define the new predicate diff_p(X, L \R) which holds iff p(X, Y&gt; holds and Y is represented by the difference-list L \ R. Let us assume that the concatenation of lists is defined in P by means of a predicate append(X, Y, 2) which holds iff the concatenation of X and Y is Z. Then the desired transformation can often be achieved by applying the T&amp;Sdefinition rule and introducing the following definition for the predicate diff_p 11441:</p><formula xml:id="formula_3">D: diff_p(X, L\R) +p(X,Y),append(Y,R,L).</formula><p>Then we have to look for a recursive definition of the predicate diff_p, which should depend neither on p nor on append.</p><p>This can be done, as clarified by the following example, by starting from clause D and performing some unfolding and goal replacement steps, based on the associativity property of append, followed by folding steps using D.</p><p>We can then express p in terms of diff_p by observing that in the least Herbrand model of P U {II}, diff_p(X, Y\ </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">append([HIT],</head><p>L,[HITLI) + append@, L,TL).</p><p>Given a list L of length n, the answer to the query + reverse(L, RI is obtained in O(n') SLD-resolution steps. Indeed, for the evaluation of reverse(L, RI, clause 2 is invoked IZ -1 times. Thus, n -1 calls to append are generated, and the evaluation of each of those calls requires O(n) SLD-resolution steps. The above program can be improved by using a difference-list for representing the second argument of reverse. This is motivated by the fact that, by clause 2, the list which appears as the second argument of reverse is constructed by the predicate append and, as already mentioned, concatenation of difference-lists can be much more efficient than concatenation of lists. We start off by applying the T&amp;S-definition rule and introducing the clause Notice that this last folding step is an application of T&amp;S-folding and it is not an instance of the reversible folding rule (R13). Its correctness is not ensured by Theorem 8 because the transformation sequence corresponding to the above derivation is constructed by using the goal replacement rule. This folding step, however, is correct w.r.t. Semn as shown in <ref type="bibr">Tamaki and Sato [1311.</ref> Our which defines the eureka prediate diff_p. This eureka predicate can also be viewed as the invention of an accumulator variable, in the sense of the accumulation strategy <ref type="bibr">[9]</ref>. Indeed, as indicated in Example 24, the third argument of difi__rev(X, L\R) can be viewed as an accumulator which at each SLD-resolution step stores the result of reversing the list visited so far.</p><p>In the following example, we show that the invention of accumulator variables can be derived by using the basic strategies described in Section 4.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 25 (Inventing difference-lists by generalization).</head><p>Let us consider again the initial program of Example 24. We would like to derive a program for list reversal which does not use the append predicate. We can do so by applying the tupling strategy to clause 2 (because of the shared variable Rl) and introducing a eureka predicate new -rev: N: new_rev( T, H, R) +-reverse( T, Rl),append( Rl, [ H], R).</p><p>As suggested by the tupling strategy, we then look for a recursive definition of new-rev by performing unfolding and goal replacement steps followed by folding steps using N. We have the additional requirement that the recursive definition of new-rev should not contain any call to append. This requirement can be fulfilled if the final folding steps are performed w.r.t. a conjunction of the atoms of the form " reverse( * * * ), append( . . * )" and no other calls to append occur in the folded clauses.</p><p>The unfolding tree generated by some unfolding and goal replacement steps starting from clause N are depicted in Figure <ref type="figure" target="#fig_7">5</ref>.</p><p>Let us now consider clause N4 in the unfolding tree of Figure <ref type="figure" target="#fig_7">5</ref>. If we were able to fold it using the root clause N, we would have obtained the required recursive definition of new-rev. Unfortunately, that folding step is not possible because the argument [Hl, H] of the call of append in clause N4 is not an instance of [HI in N (even if we rename the variables of the clauses).</p><p>Since N4 is a descendant of N, we are in a situation where we can apply the generalization strategy. By doing so we introduce a new eureka predicate gen_rev defined by the clause Gl: gen-rev(T1, X,Y, R) +reverse(Tl,R2),append(R2,[XIY],R), where the bd(G1) is the most specific generalization of bd(N) and bd(N1).</p><p>The recursive definition of gen_rev can be found by replaying the transforrnation steps which lead from N to N4 in the unfolding tree. We get the following program: The final program, which is made out of clauses 1, 2f, G2, and G3, has a computational behavior similar to the program derived in Example 24. In particular, the third argument of gen_rev is used as an accumulator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Overview of Other Techniques</head><p>In this section we would like to give a brief account of some more techniques which have been presented in the literature for improving the efficiency of logic programs by using transformation methods. rules which are not predefined; on the contrary, they depend on the structure of the programs derived during the transformation process.</p><p>The schema-based approach to program transformation is complementary to the strategy-based approach and it consists in providing a catalogue of predefined transformations of program schemata.</p><p>A program schema is an abstraction of a program, where some terms, conjunctions of literals, and clauses are replaced by metavariables. If a schema S is an abstraction of a program P, then we say that P is an instance of 5. Two schemata S, and Sz are equivalent (w.r.t. a given semantics function Sem) iff for all the values of the metavariables the corresponding instance P, and Pz are equivalent (w.r.t. Sem). The transformation of a schema S, into a schema S, is correct (w.r.t. Sem) iff S, and S, are equivalent (w.r.t. Sem). Usually we are interested in a schema transformation if each instance of the derived schema is more efficient than the corresponding instance of the initial schema.</p><p>Given an initial program P,, the schema-based program transformation technique works as follows. We first choose a schema S, which is an abstraction of P,, then we choose a transformation of schema S, into schema S, in a given catalogue of correct schema transformations, and finally we instantiate S, to get the transformed program P2.</p><p>The problem of proving the equivalence of program schemata has been addressed within various contexts (see, for instance, Paterson and Hewitt [1051, <ref type="bibr">Walker and Strong [141],</ref><ref type="bibr">and Huet and Lang [72]</ref>). Some methodologies for developing logic programs using program schemata are proposed in <ref type="bibr">Deville and Burnay [451,</ref><ref type="bibr">Kirschenbaum et al. [79]</ref>, and <ref type="bibr">Fuchs and Fromherz [55]</ref> and some examples of logic program schema transformations can be found in <ref type="bibr">Brough and Hogger [20,211 and Seki and Furukawa [1261.</ref> The schema transformations presented in these papers are useful for recursion removal (see below) and for reducing nondeterminism in generate-and-test programs (see Section 4.2.1).</p><p>The main advantage of the schema-based approach over the strategy-based approach is that the application of a schema transformation can be performed in constant time; however, the choice of a suitable schema transformation in the catalogue of the available transformations does require some extra time. On the other hand, one of the drawbacks of the schema-based approach is the space requirements and the fact that when the program to be transformed is not an instance of any schema in the catalogue, then no action can be performed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RECURSION REMOVAL.</head><p>Recursion is the main control structure for declarative (functional or logic) programs. Unfortunately, the extensive use of recursively defined procedures may lead to inefficiency in time and space. In the case of imperative programs, some program transformation techniques that remove recursion in favor of iteration have been studied, for instance, in Paterson and Hewitt <ref type="bibr">[105]</ref> and <ref type="bibr">Walker and Strong [1411.</ref> In logic programming languages, where no iterative constructs are available, recursion removal can be understood as the derivation of tail-recursive clauses from recursive clauses. A definite clause is said to be recursiue iff its head predicate also occurs in an atom of its body. A recursive clause is said to be tail-recursiue iff it is of the form where L is a conjunction of atoms. (For simplicity reasons in presenting this issue, we restrict ourselves to definite programs.) A program is said to be tail-recursive iff all its recursive clauses are tail-recursive.</p><p>The elimination of recursion in favor of iteration can be achieved in two steps. First the given program is transformed into an equivalent, tail-recursive program, and then the derived tail-recursive program is executed in an efficient, iterative way by using an ad hoc compiler optimization, called tail-recursion optimization (see <ref type="bibr">Bruynooghe [22]</ref> for a detailed description and the applicability conditions in the case of Prolog implementations).</p><p>Tail-recursion optimization (also called last-call optimization) makes sense only if we assume the left-to-right computation rule, so that, for instance, when the clause p(t) + L, p(u) is invoked, the recursive call p(u) is the last call to be evaluated.</p><p>In principle, any recursive clause can be transformed into a tail-recursive clause by simply rearranging the order of the atoms in the body. This transformation is correct w.r.t. Sem, (see rule R8). However, goal rearrangements can increase the amount of nondeterminism, thus spoiling the efficiency improvements due to tail-recursion optimization.</p><p>Moreover, goal rearrangements do not preserve Prolog semantics (see Section 3.2.4), and tail-recursion optimization is usually applied to Prolog.</p><p>Thus, many researchers have elaborated more complex transformation strategies for obtaining tail-recursion without increasing the nondeterminism. We would like to mention the following three approaches.</p><p>The first approach consists in transforming almost-tail-recursive clauses into tail-recursive ones <ref type="bibr">[6,</ref><ref type="bibr">35,</ref><ref type="bibr">36]</ref>  This transformation by itself does not improve efficiency. However, it allows us to use a specialized version of the Warren abstract machine [143] and to perform further efficiency improving transformations <ref type="bibr" target="#b38">[40,</ref><ref type="bibr">101]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ANNOTATIONS AND MEMOING.</head><p>In this paper we have mainly considered transformations which do not make use of the extralogical features of logic languages, like cuts, asserts, delay declarations, etc. In the literature, however, there are various papers which deal with transformation rules which preserve the operational semantics of full Prolog (see Section 3. The derived clauses are more efficient than the initial clauses and behave like an if-then-else statement. Prolog program transformations based on the insertion of cuts are reported in <ref type="bibr">Sawamura and Takeshima [1211, Debray and Warren [391, and Deville [44]</ref>. Other techniques which introduce annotations for the evaluator are related to the automatic generation of deluy declarations [97,1451, which procrastinate calls to predicates until they are suitably instantiated.</p><p>The last kind of annotation techniques which has been used for improving program efficiency is the so-called memoization <ref type="bibr">[96]</ref>. Results of previous computations are stored in a table together with the program itself, and when a query has to be evaluated, that table is looked up first. This technique has been implemented in logic programming by enhancing the SLDNF-resolution compiler through <ref type="bibr">tabulations [141]</ref> or by using the "assert" predicate for the run-time updating of the programs [129].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">PARTIAL EVALUATION AND PROGRAM SPECIALIZATION</head><p>Partial evaluation (also called partial deduction in the case of logic programming) is a program transformation technique which allows us to derive a new program from an old one when part of the input data is known at compile time. This technique, which can be considered as an application of Kleene's s-m-n theorem ([go], Chapter IX), has been extensively applied in the field of imperative and functional language <ref type="bibr">[10,</ref><ref type="bibr">50,</ref><ref type="bibr">59,</ref><ref type="bibr">73]</ref> and first used in logic programming by Komorowski</p><p>[81] (see also <ref type="bibr">Venken [139]</ref>, Gallagher</p><p>[60], <ref type="bibr">Safra and Shapiro [117]</ref>, <ref type="bibr">Takeuchi [128]</ref>, <ref type="bibr">Takeuchi and Furukawa [131]</ref>, and <ref type="bibr">Ershov et al. [51]</ref> for early papers on partial deduction, with special emphasis on the problem of partially evaluating metainterpreters).</p><p>The resulting program may be more efficient than the initial program because by using the partially known input, it is possible to avoid some run-time computations which are performed at compile time.</p><p>Partial evaluation can be viewed as a particular case of program specialization [122], which is aimed at transforming a given program by exploiting the knowledge of the context where that program is used. This knowledge can be expressed as a precondition which is satisfied by the input values of the program. Not much work has been done in the area of logic program specialization, apart from the particular case of partial deduction. Noteworthy exceptions are <ref type="bibr">Bossi et al. [15]</ref> and various papers by <ref type="bibr">Gallagher and others [47,</ref><ref type="bibr">64,</ref><ref type="bibr">65]</ref>. In the latter papers, the use of the abstract interpretation methodology has a crucial role. Within this methodology it is possible to represent and manipulate a possibly infinite set of input values which satisfy a given precondition, by considering, instead, an element of a finite abstract domain.</p><p>Abstract interpretation can be used before and after the application of program specialization during the so-called preprocessing phase and postprocessing phase, respectively.</p><p>During the preprocessing phase, using abstract interpretations, we may collect information that depends on the control flow, such as groundness of arguments and determinancy of predicates. This information can then be exploited to direct the specialization process. Examples of this preprocessing are the binding time analysis performed by the Logimix partial evaluator of    and the atom A =p(X, a). Let us use the unfolding strategy U which performs unfolding steps starting from the query cp(X, a) until each leaf of the SLDNF-tree is either a success or a failure or it has predicate p. We get the tree depicted in Figure <ref type="figure" target="#fig_8">6</ref>. By collecting the goals and the substitutions corresponding to the leaves of that tree, we have the set of resultants: P([ 14 c 7 P([fWl,a) +p(T,a), which constitute the partial evaluation PA of P w.r.t. A. The clauses for q have been discarded because p does not depend on q in the derived program.</p><p>If we use the program PA, the evaluation of an instance of the query +p(X, a&gt; is more efficient than the evaluation using the initial program, because the calls to the predicate q need not be computed and some failure branches are avoided.</p><p>The notion of partial evaluation of a program w.r.t. an atom can be extended to the evaluation w.r.t. a set S of atoms by considering the set union of all resultants of the atoms in S. Theorem 22 below establishes the correctness of partial evaluation. First we need the following definitions.</p><p>Dejinition 20. Given a set R of normal clauses and a set S of atoms, we say that R is S-closed iff an atom in R with predicate symbol occurring in S is an instance of an atom in S.</p><p>Dejinition 21. Given a set S of atoms, we say that S is independent iff no two atoms in S have a common instance. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 22 (Correctness of partial evaluation [901). Given a normal program P and an independent set S of atoms, let us consider a partial evaluation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Then for every atomic query + A such that A is an instance of an atom in S and Ps is S-closed, we have that:</head><p>(i) Sem,,(P, +A) = Sem,s(P,, +A), (ii) Sem,,(P, + A) = Sem,,(P,, + A).</p><p>This theorem can be extended to the case of computed answer substitution semantics and normal queries <ref type="bibr">[90]</ref>.</p><p>In and the set S of atoms {p, q(X),q(a)} which is not independent. A partial evaluation of Q w.r.t. S is the following program Q,:  This process corresponds to the application of some unfolding steps, and since efficiency gains are obtained without using the folding rule, it may seem that this is an exception to the "need for folding" metastrategy of Section 4. However, in order to guarantee the correctness of the partial evaluation of a given program P w.r.t. a set of atoms S, for each element of S we are required to find an SLDNF-tree whose leaves contain instances of atoms in S (see the closedness condition), and, as the reader may easily verify, this requirement exactly corresponds to the "need for folding." Conversely, the second approach based on the unfold/fold rules, does not require the closedness and independence conditions, but, as we show in Example 28 below, we need to perform some final folding steps using the clauses D,, . . . , 0, corresponding to the atoms in S. In this second approach, the use of the renaming technique for structure specialization [B, 631, which is often required in the first approach, is not needed, as indicated by the following example. In this example we derive by unfold/fold essentially the same program obtained by renaming in <ref type="bibr">Gallagher [62]</ref>. For other issues concerning the use of folding during partial evaluation, the reader may refer to Owen <ref type="bibr">[102]</ref>. We now present an example of derivation of a partial evaluation of a program by applying the unfold/fold transformation rules and the loop absorption strategy. whose body is the atom w.r.t. which the partial evaluation should be performed. As usual when applying the definition rule, the name of the head predicate is a new symbol, newpl in our case. Then we construct the unfolding tree for (M, clause 5) using the u-selection rule which unfolds the leftmost positive atom, if any. The u-selection rule terminates the construction of the unfolding tree when for each clause C at a leaf of the tree at hand we have that (i) the predicates match and match1 do not occur in bd(C), or (ii&gt; C is a clause with finitely failed body, or (iii) all atoms in bd(C) with predicate match or match1 can be folded using one of the definitions introduced so far. The u-selection rule also terminates the construction of the unfolding tree when we can apply the loop absorption strategy, that is, an atom in the body of a clause at a leaf L is an instance of an atom in the body of a clause occurring in an ancestor node of L.</p><p>By using this u-selection rule, we get the tree depicted in  One of the most relevant motivations for developing the partial evaluation methodology is that it can be used for compiling programs and for deriving compilers from interpreters via the Futamura projections technique i-591. For this last application it is necessary that the partial evaluator be self-applicable, that is, able to partially evaluate itself. The interested reader may refer to <ref type="bibr">Jones et al. [73]</ref> for a general overview and to Fujita and Furukawa ]57], <ref type="bibr">Fuller and Abramsky [581,</ref><ref type="bibr">Mogensen and Bondorf [97]</ref>, and <ref type="bibr">Gurr [68]</ref> for more details on the problem of self-applicability of partial evaluators in the logic languages Prolog and Giidel.</p><p>Partial evaluation has also been used in the area of deductive databases for deriving very efficient techniques for recursive this direction can be found in <ref type="bibr">Bry [26]</ref>. query optimization. Some results in</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED METHODOLOGIES FOR PROGRAM DEVELOPMENT</head><p>From what we have presented, it should be clear that program transformation is a methodology for program development which is very much related to various fields of theoretical computer science and software engineering. Here we want to briefly indicate some of the techniques and methods which are used in those fields which are of some relevance to the transformation methodology and its application.</p><p>Let us begin by considering some of the analysis techniques by which the programmer may investigate various properties of the programs at hand. Those properties may then be used for improving efficiency by applying transformation methods. Program properties which are often useful for program transformation concern, for instance, the flow of computation, the use of data structures, the propagation of bindings, the sharing of information among arguments, the termination for a given class of queries, the groundness and freeness of arguments, and the functionality (or determinacy) of a predicate.</p><p>Perfect knowledge about these properties is, in general, impossible to obtain, because of undecidability limitations. However, it is often the case that approximate reasoning can be carried out by using abstract interpretation techniques <ref type="bibr">[37]</ref>, which make use of finite interpretation domains where information can be obtained by a finite amount of computation. The interpretation domains vary accord- strategies. Very much related to these methodologies for the analysis of programs are the methods for the proof of properties of programs. They have been used for program verification and, in particular, for making sure that a given set of clauses satisfies a given specification or a given first order formula is true in a chosen semantic domain. These proofs may be used to drive the application of suitable instances of the goal replacement rule. Many proof techniques can be found in the literature, in particular, in the field of theorem proving and computer aided deduction.</p><p>Among the techniques which have been used for logic programs and can be adapted to program transformation, we may recall those in <ref type="bibr">Drabent and Maluszynski [48]</ref>, <ref type="bibr">Bossi and Cocco [13]</ref>, and Deransart</p><p>[41]. The field of program transformation partially overlaps with that of program synthesis. Indeed, if we consider the given initial program as a program specification, then the final program derived by transformation can be considered as an implementation of such specification. However, it is usually understood that program synthesis differs from program transformation because the specification is a somewhat implicit description of the program to be derived. Such implicit description often does not allow us to get the desired program by simple manipulations, like the one obtainable by standard transformation rules. Moreover, it is often the case that the specification language differs from the executable language in which the final program should be written. This language barrier can be overcome by using transformation rules, but we think these techniques go beyond the area of traditional program transformation and more precisely belong to the field of logic program synthesis for which we refer to <ref type="bibr">Deville and Lau [46]</ref>.</p><p>Finally, we would like to mention that the transformation and specialization techniques considered in this paper have been partially extended to concurrent logic programs [137] and constraint logic programs [70].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSIONS</head><p>We have looked at the theoretical foundations of the so-called "rules + strategies" approach to logic program transformation.</p><p>We established a unified framework to consider and compare the various rules which have been proposed in the literature. That framework is parametric with respect to the semantics which is preserved during transformation.</p><p>We have presented various sets of transformation rules and the corresponding correctness results w.r.t. the following semantics: the least Herbrand model, the computed answer substitutions, the finite failure, and the pure Prolog semantics. We have also considered the case of normal programs and, using the proposed framework, we presented the rules which preserve finite failure, success set, and Clark's completion semantics. Our presentation could have been extended by considering various other semantics for normal programs available in the literature, but space limitations prevented us from doing so. We have also presented a unified framework in which it is possible to describe some of the most significant methods which have been proposed for the transformation of logic programs. We have singled out a few strategies, such as the tupling, the loop absorption, and the generalization strategies, and we have shown that the basic techniques related to compiling control, program composition, change of data representation, partial evaluation, and program specialization can be viewed as suitable applications of those strategies. An area of further investigation is the characterization of the power of the transformation rules and strategies, both in the "completeness" sense, that is, their capability to derive equivalent programs, and in the "complexity" sense, that is, their capability to derive programs which are more efficient than those given. No conclusive results are available in these directions.</p><p>A line of research that can be pursued in the future is the integration of tools, like abstract interpretations, proof of properties, and program synthesis, within the "rules + strategies" approach to program transformation.</p><p>The impact of the transformational methodology in the practice of logic program development is still small. However, it is recognized that the automation of transformation techniques and their use in a system for software development is of crucial importance.</p><p>There is a growing interest in the mechanization of transformation strategies, the production of interactive tools for implementing program transformers, and the development of optimizing compilers which make use of the transformation techniques. The importance of the transformation methodology will substantially increase by extending its theory and applications to the case of complex logic languages which include features like constraints, parallelism, concurrency, and object-orientation.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>1. average(L, A) +-length(L, NJ, sumlist(L, S), div(S, N, A) 2. length([ I, 0) + 3. length([H(T], s(N)) * length(T, N) 4. sumlist([ ],O&gt; + 5. sumlist([H]T], Sl) + sumlist(T, S), sum(H, S, Sl)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>7. newp([ 1, 0, S&gt; + sumlist([ I, S&gt; 8. newp([HIT], s(N), S) + length(T, N), sumlist([HlTl, S&gt;. We then unfold clauses 7 and 8 w.r.t. sumlist([ I, S&gt; and sumlist([H ITI, S), respectively, and we get: 9. newp([ I, 0,O) + 10. newp([HIT], s(N), Sl) + length(T, N), sumlist(T, Sk sum(H, S, Sl&gt;.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Definition 1 (</head><label>1</label><figDesc>Correctness of a transformation sequence). Let Sem: Programs X Queries + (D, I&gt; be a semantics function. A transformation sequence PO,. . . , P,, of programs in Programs is partially correct w.r.t. Sem iff for each query Q in Queries, containing only predicate symbols which occur in P,,, we have that Sem(P,,Q) I Sem(P,,Q). PO ,..., P,, is totally correct w.r.t. Sem iff Sem(P,, Q) = Sem(P,, Q&gt;. A transformation rule is partially correct (totally correct) w.r.t. Sem iff for any transformation sequence PO,. . . , Pk which is partially correct (totally correct) w.r.t. Sem and for any program Pk+ , obtained from Pk by an application of that rule, we have that the transformation sequence PO,. . . , Pk, Pk + 1 is partially correct (totally correct) w.r.t. Sem. Obviously, if P,,, . . . , Pk and P,,, . . . , P, are partially correct (totally correct) transformation sequences, also their concatenation PO,. . . , P,, is partially correct (totally correct).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Example 1 .</head><label>1</label><figDesc>Rl. Unfolding.Let Pk be the program (E,, . . ., E,, C, E,, , ,. . . , E,) and let C be the clause H + F, A, G, where A is a positive literal and F and G are (possibly empty) sequences of literals. Suppose that: 1. (D 1,. . . , D, &gt;, with II &gt; 0, is the subsequence of all clauses in a program 5, with 0 &lt;j I k, such that A is unifiable with hd(D,),. . .,hd(D,,), with most general unifiers 19i,. . . ,13,, respectively, and 2. Ci is the clause (H + F,bd(Di&gt;,G)O,, for i = 1,. . . , n. If we unfold C w.r.t. A using D,, . . . , D,, in Pi, we derive the clauses C,, . . . unfolding steps we will often use a simpler terminology, like, for instance, "to unfold C w.r.t. A using Pj." The unfolding rule corresponds to the application of SLD-resolution to clause C with the selection of the positive literal A and the input clauses D,, . . . , D,,. Some early forms of unfolding used in logic programming can be found in Clark and Sickel [29], Hogger [71], and Komorowski [811 in the context of program synthesis and partial evaluation. We do not consider here the unfolding of a clause w.r.t. a negative literal, like the one in Kanamori and Horiuchi [76] and Gardner and Shepherdson [661. However, that kind of unfolding can be expressed in terms of the goal replacement and clause replacement rules introduced below. Suppose that C =p(X) +q(t(X)&gt;,r(X) is a clause in Pk and the definition of q in Pj, with 0 &lt;j 5 k, consists of the following clauses: q(a) + , qMbN +, q(tb&gt;&gt; + r(a). Then, by unfolding C w.r.t. q(t(X&gt;&gt; using Pj, we derive the two clauses p(b) -r(b), which are substituted for C in Pk to obtain Pk+l. R2. Folding. Let Pk be the program (E,, . . . , E,, C,, . . . , C,, E,, ,, . . . , E,) and let (D i,. . . ,D,&gt; be a subsequence of clauses in a program 4, with 0 &lt;j 5 k. Suppose that there exists a positive literal A such that, for i = 1,. . . , n: 1. hd(D,) is unifiable with A via a most general unifier oi, 2. C, is the clause (H * F, bd(Di), G)f$, where F and G are sequences of literals, and 3. for any clause D of pl not in the sequence (D,, . . ., D,,), hd(D) is not unifiable with A. If we fold C,, . . . ,C, using D,, . . . , D,, in Pi, we derive the clause H + F, A,G, call it C, and we get the new program Pk+ 1 = (E,, . . . , E,,C, E,+,, . . . , Es&gt;.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>1 .</head><label>1</label><figDesc>C is the clause H + F, bd(D)8, G, such that F, bd(D)8, and G are sequences of literals, 2. 8 restricted to the set vars(bd(D)) -vars(hd(D)) is a variable renaming whose image has an empty intersection with the set vars(H, F, hd(D)8, G), and 3. the predicate symbol of hd(D) occurs in Pj only once, that is, in the head of the clause D (thus, D is not recursive).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Example 4 .</head><label>4</label><figDesc>Let C be the clause p(X) *r(X) and let D be the clause r(t(X&gt;&gt; + q(X). From program (C, D), by unfolding C using D, we get the clause C, = pMX&gt;&gt; + q(X). There are only two ways of applying the T&amp;S-folding rule to Cl.The first way is to use clause Cl itself, thereby getting the clause p(t(X)) +p(t(X)).The second way is to use clause D and if we do so, we get the clause pMX&gt;) + r(t(X)&gt;. In neither case do we get a variant of C. Obviously, from the program (Cl, D) we can get again the program (C, D&gt; by the general folding rule R2. R4. Definition Introduction (or Definition for short). We may get program Pk+ , by concatenating program Pk with a sequence of clauses{ p( '0. &gt; +-Body, I i = 1 , . . . , n) such that the predicate symbol p does not occur in PO,. . . , Pk.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>. A replacement law is a pair S = T, where S and T are sequences of literals. Let {Xi,. . . , XJ be the set vars(S&gt; n vars(T), and let us consider the following two clauses: where p is any new predicate symbol. We say that S = T is valid w.r.t. the semantics Sem and program Pk iff Sem()). Let C = H + F, S, G be a clause in Pk such that: 1. S = T is a valid replacement law w.r.t. Sem and Pk, and 2. vars(H, F,G) n vars(S) = vars(H, F, G) n vars(T) = {X,, . . . , X,1.By replacement of S in C using S = T we derive the clause H + F, T, G, call it R, and we get Pk+ , by replacing C by R in Pk.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Example 5 .</head><label>5</label><figDesc>Let us consider the following clauses in Pk: C: sublist( N, X, Y) + length( X, N), append( V, X, W), append( W, 2, Y), append([ I,L,L) +, append([HlT],L,[HlTL])+ append(T, L,TL).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Example 6 .</head><label>6</label><figDesc>Consider again program Pk of Example 5 and the clauses D,: p( X, Y) + append( I/, X, W) , append( W, 2, Y) , D,:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>follows. We unfold clause D, w.r.t. append(V, X, WI and we derive the two T,X,Tl),append(Tl,Z,T2).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>p(X, DWl&gt; + append(X, L, M), append(T, M, 17). By folding clause D5 using clause D,, we get D5f: p(X,[fW])</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>Pki 1 from Pk by replacing the goal G, H in a clause of Pk by the goal H, G using the replacement law G, H = H, G. R9. Deletion of Duplicate Goals. We get Pk+ 1 from Pk by replacing the goal G,G in a clause of Pk by the goal G using the replacement law G, G = G. From rules R8 and R9 it follows that the body of a clause can be considered as a set of atoms. (Recall that we have already assumed that the comma is associative.) RlO. Clause Rearrangement. We get Pk+ , by replacing the sequence of clauses (C, D&gt; in Pk by (D,C&gt;. Rll. Deletion of Subsumed Clauses. A clause C is subsumed by D iff there exist a substitution 8 and a sequence of atoms S such that hd(C) = hd(D)O and bd(C) = bd(D)8, S. We get Pk+, by deleting from Pk a clause which is subsumed by another clause in Pk. Obviously, rule Rll allows us to delete duplicate clauses. R12. Deletion of Clauses with Finitely Failed Body. Let C be a clause in Pk of the form H+Ar ,..., A,,L,B, ,..., B, with m, n 2 0. If L has a finitely failed SLD-tree in Pk, then we say that C has a finitely failed body in Pk and we get P k+l by deleting C from Pk.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>Folding. A folding step of clauses C,, . . . , C, in Pk using D,, . . . , D,, in program Pj is said to be a reversible folding iff j = k and {C,, . . . , C,,} n {D i,. . . , D,J = 0. Let C be the clause derived by applying reversible folding to clauses C,, . . . , C, in Pk using D,, . . . , D,, and let Pk, Pk+l be the resulting transformation sequence. We also have that Pk+l, Pk is a transformation sequence, because D,, . . . , D, are in Pk+,, and by unfolding C using D,, . . . , D,, in Pk+ ,, we get Pk again. Example 7. By reversible folding from the program PO:Notice that by unfolding the first clause of P, w.r.t. s, we get again PO.Various instances of the reversible folding rule have been proposed[66,91,921.   </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Example 8 .</head><label>8</label><figDesc>Let us consider the following two programs:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>Replacement, Let C be a clause in Pk and let S = T be a valid replacement law w.r.t. the semantics Sem and program Pk. The replacement of S in C using S = T is said to be a Sem-reversible goal replacement if S = T is valid w.r.t. Sem and the derived program Pk+ ,. Suppose that by replacement of S in C using S = T we derive a clause R and we get the program Pk+ 1 = (Pk -(C}) u (R) and S = T is valid w.r.t. Sem and P k+ 1. The T = S is valid w.r.t. Sem and Pk+ 1, and by replacement of T in R using T = S, we get Pk again. Thus, the conditions indicated in R14 are sufficient to ensure that goal replacement is reversible w.r.t. {R14}. Similarly to the case of folding, by an application of the reversible goal replacement rule, we will mean an application of the rule R14. Rules R8 and R9 are particular instances of Semu -reversible goal replacements.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Theorem 6 (</head><label>6</label><figDesc>Maher 1911). Let P,, . . ., P,, be a transformation sequence of definite programs, constructed by using the following transformation rules: unfolding, reversible folding, definition introduction, definition elimination, Sem,-reversible goal replacement (including R8 and R9), and clause replacement (including RIO, Rll, and R12). Then P,,, . . . , P,, is correct w.r.t. the semantics Sem,.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>.</head><label></label><figDesc>Given a transformation sequence P,,, . . . , Pk, we may get a new program Pk+ 1 by adding to program Pk a clause H + Body such that: 1. the predicate of H does not occur in P,,, . . . , Pk, and 2. Body is made out of literals with old predicates occurring in PO, . . . , Pk.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head></head><label></label><figDesc>3.Definition 7 (Fold-allowing occurrences of literals). Let P,,, . . . , P,, be a transformais,R8-R12).Let D be a clause in P, with 0 &lt;i sn. Case i = 0. An occurrence of a literal L in bd(D) is fold-allowing iff L is positive and hd(D) has an old predicate. For each clause C in P, which is not involved in the derivation from Pi_ 1 to Pi, each literal of bd(C) in Pi is fold-allowing iff the same literal of bd(C) in Z'_ , is fold-allowing. Suppose that D has been derived by unfolding a clause C in P,_ I w.r.t. a positive literal A. Thus, C and D are of the form H + B,, . . . , Elk, A, B k+ 1,. . . , B, and (H + B,, . . . , B,, bd(E), Bk+ 1,. . . , B,M, respectively, where E is a clause such that hd(E) is unifiable with A via a most general unifier 8. In D the literals occurring in bd(E)B are fold-allowing and, for r=l ,..a, m, the literal B,0 is fold-allowing iff B, in bd(C) is fold-allowing. Suppose that D has been derived by T&amp;S-folding C in Pi_ 1. Thus, C and D are of the form H-B, ,..., Bk,bd(E)B,Bk+I,B, and H-B1 ,..., B,, hd(EM, Bk+,,. . ., B,, respectively, for a clause E and a substitution 8. In bd(D) the literal hd(E)B is fold-allowing and for r = 1,. . . , m, the literal B, is fold-allowing iff B, in bd(C) is fold-allowing. Suppose that D has been derived by applying the T&amp;S-definition rule. Then no literal in bd(D) is fold-allowing. Suppose that D has been derived by applying rule R8 (goal rearrangement) to C in Pi_,. Thus, C and D are of the form H+B,,...,Bk_l, Bk,Bk+1,Bk+2,...,Bm and HcB~,...,B~~,,B~+~,B~,B~+~,...,B~, respectively. For r = 1,. . . , m, the literal B, in bd(D) is fold-allowing iff B, in bd(C) is fold-allowing. Suppose that D has been derived by applying rule R9 (deletion of duplicate goals) to C in Pi_1. Thus, C and D are of the form H bd(D) the literal L is fold-allowing iff at least one occurrence of L in bd(C) is fold-allowing. For r = 1,. . ., m, the literal B, in bd(D) is fold-allowing iff B, in bd(C) is fold-allowing. 7. Suppose that P, has been derived from Pi_ 1 by applying rule RlO (clause rearrangement). Thus, they are of the form . . . , C,, C,, . . . and . . . . C,,C,,..., respectively. For j = 1,2, each literal occurring in bd(C,) in Pi is fold-allowing iff the same literal occurring in bd(Cj) in Pip, is fold-allowing.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Theorem 8 (</head><label>8</label><figDesc>Correctness of T&amp;S-folding w.r.t. Sem, [132]). Let P,,, . . . , P,, be a transformation sequence of definite programs, constructed by using the following transformation rules: unfolding, T&amp;S-folding, T&amp;S-definition, definition elimination, and boolean rules. Suppose that no T&amp;S-folding step is per&amp;ormed after a definition elimination step. Suppose also that we apply T&amp;S-folding to a clause C using a clause D only if (i) hd(D) has a new predicate and (ii) either hd(C) has an old predicate or at least one atom in bd(C) is fold-allowing. Then PO,. . . , P,, is correct w.r.t. the semantics Sem,.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Example 10 .</head><label>10</label><figDesc>Let us consider the transformation sequence PC9 p +fail qc,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head></head><label></label><figDesc>set of atomic queries, and (D, I) is the powerset of the set of all substitutions (modulo renaming) ordered by set inclusion. By definition, we have that Sem,.(P, +A) = {O I there exists an SLD-refutation of +A with computed answer substitution 0). By soundness and completeness of SLD-resolution, we have that the equivalence w.r.t. Sem, implies the equivalence w.r.t Semn. However, the converse is not true. For instance, consider the two programs piWe have that P, and P2 have the same least Herbrand model {p(a)}. However, Sem,(P,, +p(X)) = {{X/a)}, while Sem,,(P,, +p(X)&gt; = (1 L(X/d, where { } is the identity substitution. Various researchers have addressed the problem of proving the correctness of some transformation rules w.r.t. Semc. [13,17,78]. It can easily be shown that the boolean rules R&amp;R12 preserve the Sem,, semantics with the exception of rule R9 (deletion of duplicate goals) and rule Rll (deletion of subsumed clauses), as is shown in the following example. Example 11. Let us consider the program p,: P(X) +4tw~qtx) qww)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>R16.</head><label></label><figDesc>Deletion of Duplicate Ground Goals. We get program Pk+ 1 from program Pk by replacing a ground goal G,G in a clause of Pk using the replacement law G,G=G. This rule is an instance of the Sem ,-reversible goal replacement rule. R17. Deletion of Duplicate Clauses. We get program Pk+ 1 by replacing the sequence of clauses (C, C &gt; in program Pk by (C &gt;. For the correctness of a transformation sequence w.r.t. Sem, we have the following results, corresponding to Theorems 6 and 8, respectively. Theorem 9. Let PO,. . . , P,, be a transformation sequence of definite programs, constructed by using the following transformation rules: unfolding, reuersible folding, definition introduction, definition elimination, reversible goal replacement RI4 (in particular, rules R8 and R16), and clause replacement R7 (in particular, rules RIQ, Rl2, and R17). Then P, ,..., P,, is correct w.r.t. Sem,,. Theorem 10 (Correctness of T&amp;S-folding w.r.t. Sem,, [ 13,781). Let P,, . . .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head></head><label></label><figDesc>at least one atom in bd(C) is fold-allowing. Then P,, . . . , P,, is correct w.r.t. the semantics Sem,,. 3.2.3. Finite Failure. In Theorems 6, 8, 9, and 10 we have shown that the set of atomic consequences of a program and the set of answer substitutions that are computed by a program are preserved by a number of transformations. However, the use of the rules according to the hypotheses of Theorem 8 may transform a finitely failing program into an infinitely failing program (and vice versa), as shown by the following example. Example 12. Let us consider the transformation sequence where p is the only new predicate: -folding the first clause). This transformation sequence satisfies the conditions stated in Theorem 8, but PO finitely fails for the query +p(b), while P2 does not. In order to reason about the preservation of finite failure during program transformation, we now consider the semantics function Sem,, from Programs X Queries to (D, s), where Programs is the set of definite programs, Queries is the set of atomic queries, and (D, I&gt; is the powerset of the set of (possibly not ground) atoms ordered by set inclusion. By definition, Sem,,(P, + A) = {B 1 B is an instance of A and there exists a finitely failed SLD-tree for P and + B). One can easily show the partial correctness of our transformation rules Rl and R4-R14 w.r.t. Sem,, . (Example 10 shows that rules R2 and R3, together with definition elimination, are not partially correct w.r.t. Sem,,.) Thus, similarly to the cases of Semn and Sem,,, we have the following result, basically due to Maher [9Il. Theorem 11. Let PO,. .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head></head><label></label><figDesc>us consider, for instance, program P, of Example 12 and the infinite sequence of goals +p(b), -p(b), . . . , which describes the fair SLD-derivation for the program P, and the query +p(b). Since the folding step which produced Pz from P, replaces "q(b), r(b)" by "p(b)," this derivation can be viewed as an encoding of the unfair SLD-derivation for Pby always selecting for SLD-resolution the atom r(b). The following Theorem 12 is a modification of Theorem 8. Its proof is based on the fact that unfair SLD-derivations cannot be introduced if all atoms replaced in a folding step have previously been derived by unfolding. This condition is not fulfilled by the folding step shown in Example 12 because in the body of the clause p(b) + q(b), r(b) in P,, the atom q(b) has not been derived by unfolding, or in the sense of Definition 7, q(b) is not fold-allowing.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head></head><label></label><figDesc>are performed are fold-allowing. Then PO, . . . , P,, is correct w.r.t. the semantics Sem,,.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head></head><label></label><figDesc>application of a boolean rule may affect the order, or the multiplicity, or the finite time computability of the computed answer substitutions. An unfolding step may affect the order of the computed answer substitutions as well as the termination of a program, as is shown by the following examples. Example 14. By unfolding w.r.t. r(Y) the first clause of the program PO: The order of the computed answer substitutions is changed. Indeed, we have that SemP,O,cl,(4l~ +P(XJ)) = &lt;{X/G'/&amp; {X/a,Y/bI, {X/b,W&amp; {X/b,Vb}) Se%o,og(PI&gt; +P(XJ)) = ({X/O'/a}, {X/bJ'/&amp; {X/G'/b), {X/b,Y/b}). Example 15. By unfolding w.r.t. r the first clause of the program less defined than PO. Indeed, we have that Sem Prolog( PII Y +p&gt; =&lt;{ I,{ },..A Sem Prolo&amp; p, 7 +p) = (I&gt;. Example 16. By unfolding w.r.t. r(X) the first clause of the program PO: P +q(X),r(more defined than PO. Indeed, we have that Sem Prolog(% CP) = ( 1 ), Sem Prolog( pi 7 +p) = ( &gt;.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head></head><label></label><figDesc>Unfolding. A leftmost unfolding step of clause C consists of an unfolding step of C w.r.t. the leftmost atom of its body. R19. Deterministic Non-Left-Propagating Unfolding. The unfolding of a clause H + F, A, G w.r.t. the atom A is deterministic non-left-propagating iff (i) there exists one clause D such that A is unifiable with hd(D) via a most general unifier 8 and (ii) H + F is a variant of (H + F)B. Also the definition introduction, definition elimination, and clause replacement rules are totally correct w.r.t. Sem,,,,,,.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_28"><head>Theorem 13 .</head><label>13</label><figDesc>Let P,, . .. , P,, be a transformation sequence of definite programs constructed by using the transformation rules: leftmost unfolding, deterministic non-left-propagating unfolding, T&amp;S-folding, definition introduction, definition elimination, reuersible goal replacement, and clause replacement. Suppose that each T&amp;S-folding is an instance of the reversible folding rule R13. Then PO,. .., P,, is correct w.r.t. SemProlog.For the case of T&amp;S-folding which is not an instance of reversible folding, we have the following result, which is analogous to Theorems 8, 10, and 12 and is based on the fact that an application of the leftmost unfolding rule is "a step forward in the computation" using the left-to-right computation rule.Theorem 14 (Correctness of T&amp;S-folding w.r.t SemProlog[112]). Let PO,. . . , P,, be a transformation sequence of definite programs constructed by using the following transformation rules: leftmost unfolding, deterministic non-left-propagating unfolding, T&amp;S-folding, T&amp;S-definition, and definition elimination. Suppose that no T&amp;S-folding step is petformed after a definition elimination step. Suppose also that we apply T&amp;S-folding to a clause C using a clause D only if (i) hd(D) has a new predicate and (ii) either hd(C) has an old predicate or the leftmost atom of bd(C) is fold-allowing. Then P,, , . . . , P,, is correct w.r.t. the semantics SemProlog.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_29"><head></head><label></label><figDesc>Now we consider a definition of the semantics function based on the completion of a normal program. This function is from Programs x Queries to (D, 0, where Programs is the set of normal programs, Queries is the set of atomic queries, and (D, I) is the powerset of the set of (possibly not ground) atoms ordered by set inclusion. By definition we have that Semc,,r(P, +A) = {B 1 B is an instance of the atom A and the universal closure of B is a logical consequence of the completion Camp(P) of the program P}. The partial correctness of the unfolding and folding rules can easily be established, as illustrated by the following example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_30"><head>q</head><label></label><figDesc>in p -q A 7 r of Comp(P,&gt; by (s A t) V (s A u) and then applying the distributive and associative laws. Since q -(s At) V (s A u) holds in Comp(P,,&gt;, we have that Comp(P,) is a logical consequence of Comp( PO). From P,, by folding the definition of p using the definition of v in P, itself, we get from Comp(P,) by first using the associative, commutative, and distributive laws for replacing the formula p -(s A t A 7 r&gt; V (s A u A -T r) by p -(t V u) A (s A 7 r), and then replacing t v u by v. Since v c, t V u holds in Comp(P,), we have that Comp(P,) is a logical consequence of Comp( P,&gt;. In general, if a program Pk+ 1 can be obtained from a program Pk by folding steps which use clauses in Pk only or by unfolding steps, then Comp(P,+ r) can be obtained from Comp(P,) by one or more replacements of a formula F by a formula G such that F -G is a logical consequence of Comp(P,). Thus, Comp( Pk + 1 &gt; is a logical consequence of Comp( Pk &gt;.A similar statement holds if Pk+ 1 can be obtained from Pk by applying the goal replacement rule or the clause replacement rule. Thus, we have the following result, analogous to Theorem 3 for Sem n . Theorem 1.5 (Partial correctness of transformations w.r.t. Sem,,,,). Let PO,. . . , P,, be a transformation sequence constructed by using rules RI-R12. Suppose that each folding step is per$ormed by using clauses in the current program only. Then P ", . . . , P,, is partially correct w.r.t. the semantics SemComp. Unfortunately, the unfolding rule is not totally correct w.r.t. Sem,,,, as shown by the following example adapted from Maher [92]. Example 19. Let us consider the program PO: P(X) + q(axioms of Clark's equality theory (CET) [4, 28, 891. CET is a first order complete (and hence decidable) equality theory which axiomatizes the identity relation on the Herbrand universe. By unfolding of the last clause of Pa, we get P,:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_31"><head>Theorem 16 .</head><label>16</label><figDesc>Let P,,, . . . , P,, be a transformation sequence constructed by using the transfomzation rules: reversible unfolding, reversible folding, definition introduction, definition elimination, reversible goal replacement, and clause replacment. and P, are equivalent w.r.t. Sem,,. Let us now consider the completions of P,, and P2, respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_32"><head></head><label></label><figDesc>Example 20, PO is equivalent to Pz w.r.t. other two-valued or three-valued semantics for normal programs such as the already mentioned Fitting's and Kunen's extensions of Clark's completion, perfect model, stable model, and well-founded model semantics. The reader may find various correctness results of T&amp;S-folding w.r.t. these semantics in Sato [1181 and Seki[123,124].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_33"><head></head><label></label><figDesc>The reader may refer toFeather [53],Partsch [104],Deville [44], and Pettorossi and Proietti [lo81 for a treatment of transformation strategies for functional and logic programs.For simplicity reasons, we only consider the case of definite programs with the least Herbrand model semantics Semn. We will use in our examples the following rules, whose correctness w.r.t. Sem, is ensured when they are used according to the hypotheses of Theorems 6 and 8: unfolding (Rl), T&amp;S-folding (R3), T&amp;Sdefinition (R15), definition elimination (R5), reversible goal replacement (R14), and boolean rules (R8-R12).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_34"><head></head><label></label><figDesc>it determines a double traversal of the list L. In order to improve the performance of program PO, we can apply the technique which consists in introducing a new predicate, say newp, by means of a clause, say N, with body A,, . . . , A,. This initial transformation step has been formalized as an application of the tupling strategy (see Section 4.1). We then unfold clause N one or more times, thereby generating some new clauses. This process can be viewed as a symbolic evaluation of a query which is an instance of A,, . . . , A,. This unfolding may give us the opportunity to improve the performance of our program, because, for instance, we may delete some clauses with finitely failed body, thus avoiding failures at run time, or we may delete duplicate atoms, thus avoiding repeated computations, and so on. With reference to the example of Section 2, we recall that by unfolding clause 1 w.r.t. length and sumlist, we derived the clauses 9. newp([ I, O,O&gt; + , 10. newp([HITl, s(N), Sl) * length(T, N),sumlist(T, S), sum(H, S, Sl), which avoid multiple traversals of the input list when it is empty.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_35"><head>(</head><label></label><figDesc>ii) if it4 is a node labeled by a clause D, then: either M has no sons, or it4 has n (2 1) sons labeled by the clauses D,,. . . ,D, obtained by unfolding D w.r.t. an atom of its body using P, or M has one son labeled by a clause obtained by goal replacement from D.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_36"><head></head><label></label><figDesc>Definition19. GivenaclauseCoftheform H+-A,,...,A,,B,,...,B,,thelinking variables of the sequence of atoms A,,. . . , A, in C are the variables in vars(A,,..., A,) f' vars(H, B,, . . . , B,).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_37"><head></head><label></label><figDesc>S2. Loop Absorption. Suppose that a nonroot clause C in an unfolding tree has the form H-A, ,..., A,,B, ,..., B,,, and the body of a descendant D of C contains (as a subsequence of atoms) an instance (A,, . . . , A,&gt;0 of A,, . . . , A,,, for some substitution 0. Suppose also that the clauses in the path from C to D have been generated by applying no transformation rule, except for R8 and R9, to B 1,. . . , B,. We introduce a new predicate defined by the following clause A: newp(X, ,..., X,) +A ,,..., A,, where {X,, . . . , X,} is the minimum subset of vars(A,, . . . , A,) which is necessary to fold both C and D using a clause whose body is A,, . . . , A,. (See point 2 of R3 for the conditions on IX,, . . . , X,} and 8 which should be satisfied to allow folding.) We fold clause C using clause A and we then look for the recursive definition of the eureka predicate newp. This can be done by performing the unfolding steps corresponding to the steps which lead from clause C to clause D and then folding using clause A again. S3. Generalization. Given a clause C of the form H + A,, . . . , A,,,, B,, . . . , B,, we define a new predicate genp by a clause G of the form genp( X,, . . . , X,) + GenA,, . . ., GenA,, where (GenA,, . . . , GenA,)B =A,, . . .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_38"><head></head><label></label><figDesc>[1351. The problem of "compiling" a given computation rule C can be described as follows: given a program P, and a set Q of queries, we want to derive a new program P2 which, for any query in Q, is equivalent to P, w.r.t. Semn and behaves under the left-to-right computation rule as P, does under the rule C [23,421. By "equal behavior,"</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_39"><head></head><label></label><figDesc>say .D, by + bd(D)p, where p is the most general unifier of hd(R)B and hd(D), and, finally, (iii) adding the root + q( ... 10. Example 21. Let us consider the program P,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_40"><head>(</head><label></label><figDesc>if any) of T itself. In our Example 22 below, this representation is obtained by identifying any two nodes Ni and N2 iff N2 is a descendant of Ni and the body of the clause in N2 is an instance of the body of the clause in Ni (see dashed arrows of Figure 3). This finite-graph representation will allow us to apply the loop absorption strategy w.r.t. the clauses corresponding to each pair of identified nodes, and we will get the final program, where the given computation rule has been "compiled." In general, the construction of the unfolding tree T from the given program P,, the set Q of queries, and the computation rule C can be viewed as the evaluation of an "abstract query" which represents the whole set Q by using the program P, and the rule C. We will not give here the formal notion of abstraction which may allow us to effectively construct the tree T, and we refer to Cousot and Cousot [321, where abstract interpretation techniques are presented.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_41"><head>FIGURE 1 .</head><label>1</label><figDesc>FIGURE 1. The unfolding tree T for</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_42"><head></head><label></label><figDesc>FIGURE3. An unfolding tree T for (Csub, csub(X, Y, 2) + subseq(X, Y&gt;, subseq(X, 2)) using the computation rule C.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_43"><head></head><label></label><figDesc>140], and tupling [106, 1071. (See also Feather [531 and Partsch 11041 for a survey.) For logic programs, two main methods have been considered: loop fusion [36] and unnecessary variuble elimination [1131. The aim of loop fusion is to transform a program for computing a predicate, which is defined as the composition of two independent recursive predicates, into a program where the computations corresponding to these two predicates are performed by one predicate only. The benefits one may expect from loop fusion are the avoidance of multiple traversals of data structures and the avoidance of the construction of intermediate data structures. The transformational methods for composing logic programs are closely related to methods for logic program construction [88, 1281, where complex programs are developed by enhancing</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_44"><head>[ 1 )</head><label>1</label><figDesc>holds iff p(X, Y) holds. Thus, in our transformed program, the clauses for the predicate p can be replaced by the single clause reversal using difference-lists). Let us consider the following program for reversing a list: 1. reverse([ 1, [ I) +-. 2. reverse([HIT], R) + reverse(T, Rl),append(Rl,[H], RI. 3. append([ 1, L, L) + .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_45"><head></head><label></label><figDesc>The recursive definition of diff_rev can easily be derived as follows. We unfold clause Dl w.r.t. reverse(X, Y) and we reverse(7', Rl),append( Rl,[H],Y), append( Y, R, L) . By unfolding, clause 02 is replaced by 04: diff_rev([ 1, R/R) +. By using the unfold/fold proof method described in Section 3.1, we can prove the validity of the replacement law F: append(Rl,[H],Y),append(Y,R,L) =append(Rl,[fflR],L) w.r.t. Sem, and the current program made out of clauses 03, 04, 1, 2, 3, and 4. Thus, we apply the goal replacement rule to clause 03 and we get D5: diff_rev( [ HIT], L\R) + reverse(T,Rl),append(Rl,[HIR],L). The above step is an application of the reversible goal replacement rule because law F is valid also w.r.t. the program we have obtained by this replacement step. We now fold D5 using Dl and we get 06: diff-rev([H(T],L\R) +diff_rev(T,L\[HIR]), which, together with clause 04, provides the desired recursive definition of diff_rev.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_46"><head></head><label></label><figDesc>final program which uses difference-lists is obtained by replacing the clauses defining reverse by the single clause (see clause E above) 07: reverse( X, Y) + diff_rev( X, Y\ [ I). The derived program (made out of clauses 04, 06, and 07) takes O(n) SLD-resolution steps for reversing a list of length n. A crucial step in the derivation of programs which use difference-lists is the introduction of the clause of the form D: diff_p(X, L\R) +p(X,Y),append(Y, R, L),</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_47"><head>G2</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_48"><head></head><label></label><figDesc>FIGURE 5. An unfolding tree for the reverse program.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_49"><head>For</head><label></label><figDesc>by using unfold/fold rules. A clause is said to be almost-tail-recursive   iff it is of the form where L is a conjunction of atoms and R, called the tail-computation, is a conjunction of atoms whose predicates do not depend on p. Usually, the tail-computation contains calls to "primitive" predicates, such as the ones for computing concatenation of lists, and arithmetic operations, such as addition and multiplication of integers. The transformation methods considered inDebray [35,36]  andAzibi [6]  are closely related to the ones considered byArsac and Kodratoff [5]  for functional programs. They use the generalization strategy and some replacement laws which are valid for the primitive predicates, like, for instance, associativity of list concatenation, associativity and commutativity of addition, and distributivity of multiplication over addition. The second approach is based on schema transformation[ll, 20,211, where some almost-tail-recursive program schemata are shown to be equivalent to tail-recursive schemata.The third approach consists in transforming a given program into a binary one, that is, a program whose clauses have only one atom in their bodies[134]. This transformation method is applicable to all programs and it is in the style of continuation-based transformations for functional programs [ 1391. The transformation works by adding to each predicate an extra argument (representing the so-called continuation), which encodes the next goal to be evaluated.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_50"><head></head><label></label><figDesc>2.4), and there are also some transformation strategies which work by inserting extralogical predicates into a given Prolog program to improve efficiency by taking advantage of suitable properties of the evaluator. These strategies are related to some techniques which were first introduced in the case of functional programs and are referred to as program unnotations [123]. In the case of Prolog, a typical technique which produces annotated programs consists in adding a cut operator ! in a point where the execution of the program can be performed in a deterministic way. For instance, the two Prolog clauses p(X) +-C,BodyL p(X) + not(C),Body2 can be transformed (if C has no side-effects) into p(X) + C, !,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_51"><head></head><label></label><figDesc>and the determinacy analysis performed byMixtus [1181.   During the postprocessing phase, abstract interpretations may be used to improve the program obtained by the specialization process, as indicated, for instance, inGallagher [62], where it is shown how one can get rid of the so-called useless clauses.The idea of partial evaluation can be presented as follows[90]. Let us consider a normal program P and an atomic query +A. We construct a finite SLDNF-tree for P u { + A} containing at least one nonroot node. For this construction we use an unfolding strategy U, which tells us the atoms which should be unfolded and when to terminate the construction of the tree. The notion of unfolding strategy is analogous to the one of u-selection rule (see Section 4.11, but it applies to goals, instead of clauses. We then construct the set of clauses lABi+-G,li=l,..., n}, called resultants, obtained by collecting from each nonfailed leaf on the SLDNF-tree, the goal + Gi and the corresponding computed answer substitution 13~. A partial evaluation of P w.r.t. the atom A is the program PA obtained from P by first replacing the clauses of P which constitute the definition of the predicate symbol, say p, occurring in A by the set of resultants {A 0, + Gi I i = 1,. . . , n), and then keeping only the definitions of the predicates on which p depends. The generation of jinite SLDNF-trees can be performed within general frameworks for dealing with termination of unfolding as described inBruynooghe et al.  1241 and Bol 1121.    </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_52"><head>Example 26 .</head><label>26</label><figDesc>Let us consider the following program P:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_53"><head>FIGURE 6 .</head><label>6</label><figDesc>FIGURE 6. An SLDNF-tree of P U { *p(X, a)} using U.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_54"><head></head><label></label><figDesc>Example 26, the correctness of program PA that results from the partial evaluation process follows from Theorem 22, because for the singleton {p(X, a)}, the independence property trivially holds. The closedness property also holds because p([ l,a),p([HITl, &gt; a , and p(T, a) are all instances of p(X, a). The closedness and independence hypotheses cannot be dropped from Theorem 22, as is shown by the following example. Example 27. Suppose we want to partially evaluate the following program P: p(a) +p(bL P(b) + w.r.t. the atom p(a). We can derive the resultant p(a) +-p(b). Thus, a partial evaluation of P w.r.t. p(a) is the program P,, p(a) +p(bL obtained by replacing the definition of p in P by the resultant p(a) *p(b). P, is not {p(a)}-closed and we have that Sem,s(P,, +p(a&gt;&gt; = 0, while Sem,,(P,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_55"><head></head><label></label><figDesc>S-closed and Sem,,(Q,, +p) = {p}, while Sem,s(Q, +p) = 0, because the unique SLDNF-derivation for Q U { -p} flounders. Various strategies have been proposed in the literature for computing, from a given program P and atomic query + A, the set S of atoms with the independence and closedness properties required by Theorem 22 [8,24,61,951. Some of the strategies require generalization steps and the use of abstract interpretations. Other techniques for partial evaluation and program specialization are based on the unfold/fold rules [15,56,109,113,1171. By using those techniques, given a program P and a set of atoms S = (A,, . . . , A,), for i = 1,. . . , m, we introduce a new predicate newp, defined by D;: newp,( X,, . . ., X,,) *Ai, where X1,..., X, are the variables occurring in Ai.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_56"><head></head><label></label><figDesc>3. matchl([AIPs],[AITs], P,T) + matchl(Ps,Ts, P,T), 4. matchl([AIPs],[BITs], P,[ClTI) + T(A =B),matchl(P,T, P,T), where the pattern P and the string T are represented as lists, and match(P, T) holds iff the pattern P occurs in the string T. a, a, bl, X&gt;. In order to do so, we first introduce the definition 5. newpl(X) + match([ a, a, b], X)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_57"><head></head><label></label><figDesc>FIGURE 7. h unfolding tree for (M,newpl(X) 6 matchk a, bl, XI).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_58"><head>FIGURE 8 .</head><label>8</label><figDesc>FIGURE 8. An unfolding tree for (M,newp2(X) + matchl([a, a, bl, X,[a, a, bl, X)).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_59"><head></head><label></label><figDesc>ing to the property to be analyzed and the degree of information one would like to obtain to mention (i) compiling control (see Section 4.2.11, where the information about the flow of computation is used for generating the unfolding tree, (ii) the specialization method of Gallagher and Bruynooghe [641, which is based on a technique for approximating the set of all possible calls generated during the evaluation of a given class of queries, (iii) various techniques which insert cuts on the basis of a determinacy information (see Section 4.31, and (iv&gt; various techniques implemented in the Spes system 121 in which mode analysis is used to mechanize several transformation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Pk U Pk + , , we have that Sem( Pk, Q) = Sem( Pk + , , Q).</figDesc><table><row><cell cols="2">tion of the clause replacement</cell><cell>rule is, in general, undecidable.</cell><cell>However, in the</cell></row><row><cell>following</cell><cell cols="2">Section 3.2 we will show some useful instances</cell><cell>of this rule whose</cell></row><row><cell>applicability</cell><cell cols="2">condition can be tested in an effective way.</cell></row><row><cell cols="4">R7. Clause Replacement. From Pk = ( E,, . . . , E,, C,, . . . , C,, E,, 1,. . . , E,) we get</cell></row><row><cell cols="2">P k+l = (E1,...,E,,D,,...,D,,E,+1,...</cell><cell cols="2">, E, &gt; if for every query Q containing</cell></row><row><cell cols="2">only predicates occurring in</cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="2">The applicability</cell><cell>condi-</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>p) &lt; Sem,(P,, -p). However, the reader may verify that by applying the folding rule or the goal replacement</head><label></label><figDesc></figDesc><table><row><cell cols="5">Thus, we have derived the program P2 equal to program PO.</cell><cell></cell></row><row><cell>We have that Sem,(P,,</cell><cell>-p)</cell><cell>&gt; Sem,(P,,</cell><cell>+p)</cell><cell>and Sem,(P,,</cell><cell>-</cell></row></table><note><p>rule to the program Pk of a transformation sequence P,, . . . , Pk, we derive clauses which are true in the least Herbrand model of P,,. Thus, we have the following result, which generalizes the result of Tamaki and Sato [1321, which was stated for a</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>weaker version of the transformation rules. Theorem 3 (Partial correctness of transformations w.r.t. Sem,). Every transformation sequence constructed by using the rules RI-R12 is partially correct w.r.t. the semantics Sem n .</head><label></label><figDesc></figDesc><table><row><cell cols="2">From Theorem</cell><cell cols="3">3 it follows that if there exist a transformation</cell><cell>sequence</cell></row><row><cell>PO,P,,...,P,-1,</cell><cell cols="2">P,, constructed</cell><cell>by using the set of rules Rl-R12</cell><cell>and a transforma-</cell></row><row><cell>tion sequence P</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>,,, Q,, . . . , Qk, PO, with k 2 0, constructed</head><label></label><figDesc>by using the same set of rules, then both sequences are totally correct w.r.t. Sem,. This property suggests the introduction of the notion of</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>reversible transformation sequence, which can</head><label></label><figDesc>be stated w.r.t. any set R of transformation rules.</figDesc><table><row><cell cols="2">Definition 4. Let R be a set of transformation</cell><cell>rules. A transformation</cell><cell>sequence</cell></row><row><cell>po,pi,...,p,-1,</cell><cell cols="3">P, is said to be reversible w.r.t. R iff there exists a transforma-</cell></row><row><cell>tion sequence P</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>,,, Q,, . . . , Qk, P,,, with k 2 0, which</head><label></label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell>can be constructed</cell><cell>by using</cell></row><row><cell>the same set R.</cell><cell></cell><cell></cell></row><row><cell>A transformation</cell><cell cols="3">rule which belongs to R is said to be reversible w.r.t. R iff</cell></row><row><cell>every transformation</cell><cell>sequence</cell><cell>PO,</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>P, obtained</head><label></label><figDesc></figDesc><table /><note><p>by applying that rule to any given program PO is reversible w.r.t. R.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>t. various semantics, such as the success set and finite</figDesc><table><row><cell cols="3">failure set semantics</cell><cell cols="2">[66,124,127],</cell><cell>Clark's completion</cell><cell>[28,66,127],</cell><cell>Fitting's and</cell></row><row><cell>Kunen's</cell><cell cols="2">three-valued</cell><cell>extensions</cell><cell></cell><cell>of Clark's completion</cell><cell>[ 16,54,86,119],</cell><cell>perfect</cell></row><row><cell cols="2">model semantics</cell><cell cols="2">[92,116,124],</cell><cell cols="2">stable model semantics</cell><cell>[67,931, and well-founded</cell></row><row><cell cols="2">model semantics</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>Example 18. Let us consider the program</figDesc><table><row><cell>PO:</cell><cell>p+q,Tr</cell><cell></cell><cell>q+s,t</cell><cell>q+s,u</cell><cell>v+t</cell><cell>v+-U</cell><cell>s+</cell><cell>u+</cell></row><row><cell cols="2">whose completion</cell><cell>is</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">Comp( PO) :</cell><cell>p*qA</cell><cell>7r</cell><cell cols="2">q++(sAt)v(sAu)</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>v-tvu</cell><cell>s</cell><cell>u</cell><cell>7r</cell><cell>7 t.</cell><cell></cell></row></table><note><p>By unfolding the first clause of PO w.r.t. q, we get P,: p+s,t7r p+s,u,7r q+s,t q CS,U v+-t v+li S+-U+whose completion is Comp(P,):</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We express our warm gratitude to M. Bruynooghe, J. P. Gallagher, M. Leuschel, M. J. Maher, T. Sato, H. Seki, and the anonymous referees for their helpful suggestions and comments. Many thanks also to 0. Aioni and M. Gaspari for their careful reading of a previous draft of the paper.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work has been partially supported by Progetto Finalizzato Sistemi Informatici e Calcolo Parallel0 of CNR under grant 89.00026.69, by Esprit Project Compulog II, and by MURST 40%.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<orgName type="collaboration">matchl</orgName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">+ -</forename></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="16" to="18" />
			<pubPlace>La,HITl) REFERENCES</pubPlace>
		</imprint>
	</monogr>
	<note>t matchl([a,a,bl</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Autolap: A System for Transforming Logic Programs</title>
		<author>
			<persName><forename type="first">K</forename><surname>Aerts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Van Besien</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
		<respStmt>
			<orgName>Department of Electronics, University of Rome II</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Spes: A System for Logic Program Transformation</title>
		<author>
			<persName><forename type="first">F</forename><surname>Alexandre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Bsayes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Finance</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Qucrc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Logic Programming and Automated Reasoning &amp;PAR &apos;921</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the International Conference on Logic Programming and Automated Reasoning &amp;PAR &apos;921<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">624</biblScope>
			<biblScope unit="page" from="445" to="447" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Unfold/Fold Transformations Preserving Termination Properties, in: Proceedings of PLILP &apos;92</title>
		<author>
			<persName><forename type="first">T</forename><surname>Amtoft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">631</biblScope>
			<biblScope unit="page" from="187" to="201" />
			<date type="published" when="1992">1992</date>
			<publisher>Springer</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Introduction to Logic Programming</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Apt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Van Leeuwen</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="493" to="576" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Some Techniques for Recursion Removal From Recursive Functions</title>
		<author>
			<persName><forename type="first">J</forename><surname>Arsac</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Kodratoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="295" to="322" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">TREQUASI: Un Sysdme Pour la Transformation Automatique de Programmes PROLOG Recursifs en Quasi-ItCratifs</title>
		<author>
			<persName><forename type="first">N</forename><surname>Azibi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
			<pubPlace>Centre d&apos;orsay, France</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Universite de Paris-Sud</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Proving Termination Properties of Prolog Programs: A Semantic Approach</title>
		<author>
			<persName><forename type="first">M</forename><surname>Baudinet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Program</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="1" to="29" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A Partial Evaluation Procedure for Logic Programs</title>
		<author>
			<persName><forename type="first">K</forename><surname>Benkerimi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Lloyd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1990 North American Conference on Logic</title>
		<meeting>the 1990 North American Conference on Logic<address><addrLine>Austin, TX; Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="343" to="358" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The Promotion and Accumulation Strategies in Transformational Programming</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Bird</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="487" to="504" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Source-to-Source Transformations of Logic Programs</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bjorner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Ershov</surname></persName>
		</author>
		<author>
			<persName><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Partial Evaluation and Mixed Computation, IFIP TC2 Workshop on Partial and Mixed Computation, Gammel Averrues</title>
		<editor>
			<persName><forename type="first">N</forename><forename type="middle">D</forename></persName>
		</editor>
		<meeting><address><addrLine>Denmark; North-Holland, Amsterdam; Bloch, C.; Bol, R.</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier Science Publishers</publisher>
			<date type="published" when="1984">1988. 1984. 1993</date>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="25" to="46" />
		</imprint>
		<respStmt>
			<orgName>Department of Applied Mathematics, Weizmann Institute of Science, Rehovot, Israel</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Masters Thesis</note>
	<note>Loop Checking in Partial Deduction</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Verifying Correctness of Logic Programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Cocco</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of TAPSOFT 89</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>TAPSOFT 89<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="96" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Basic Transformation Operations for Logic Programs which Preserve Computed Answer Substitutions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Cocco</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Program</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="47" to="87" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A Method for Specializing Logic Programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Cocco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dulli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="253" to="302" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Transforming Normal Programs by Replacement</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Cocco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Etalle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd International Workshop on Metaprogramming in Logic (Meta &apos;92)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Pettorossi</surname></persName>
		</editor>
		<meeting>the 3rd International Workshop on Metaprogramming in Logic (Meta &apos;92)<address><addrLine>Uppsala, Sweden; New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">649</biblScope>
			<biblScope unit="page" from="265" to="279" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">On Safe Folding</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Cocco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Etalle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of PLILP &apos;92</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>PLILP &apos;92<address><addrLine>Leuven, Belgium; New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">631</biblScope>
			<biblScope unit="page" from="172" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Deriving Unfold/Fold Transformations of Logic Programs Using Extended OLDT-based Abstract Interpretation</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boulanger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bruynooghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symbolic Comput</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="495" to="521" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Proving Theorems about LISP Functions</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Boyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Moore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="129" to="144" />
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Compiling Associativity into Logic Programs</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Brough</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Hogger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Program</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="345" to="359" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Grammar-Related Transformations of Logic Programs</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Brough</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Hogger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">New Generation Comput</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="115" to="134" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The Memory Management of Prolog Implementations</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bruynogghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic Programming</title>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Clark</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S.-A</forename><surname>Tdrnlund</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Academic</publisher>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="83" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Compiling Control</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bruynooghe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>De Schreye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Krekels</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Program</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1&amp;2</biblScope>
			<biblScope unit="page" from="135" to="162" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A General Criterion for Avoiding Infinite Unfolding During Partial Deduction of Logic Programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bruynooghe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>De Schreye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Martens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">New Generation Comput</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="47" to="79" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Deduction Revision by Intelligent Backtracking</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bruynooghe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Pereira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Zmplementations of Prolog</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Campbell</surname></persName>
		</editor>
		<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<publisher>Ellis Horwood</publisher>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="253" to="266" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Query Evaluation in Recursive Data Bases: Bottom-Up and Top-Down Reconciled</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st International Conference on Deductive and Object-Oriented Databases</title>
		<meeting>the 1st International Conference on Deductive and Object-Oriented Databases<address><addrLine>Kyoto, Japan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A Transformation System for Developing Recursive Programs</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Burstall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Darlington</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="44" to="67" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Negation as Failure</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Clark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic and Data Bases</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Gallaire</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Minker</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Plenum Press</publisher>
			<date type="published" when="1978">1978</date>
			<biblScope unit="page" from="293" to="322" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Predicate Logic: A Calculus for Deriving Programs</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sickel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th International Joint Conference on Artificial Intelligence</title>
		<meeting>the 5th International Joint Conference on Artificial Intelligence<address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="419" to="420" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A First Order Theory of Data and Programs</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-A</forename><surname>Tarnlund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Znformation Processing &apos;77</title>
		<meeting>Znformation Processing &apos;77<address><addrLine>North-Holland, Amsterdam</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="939" to="944" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<author>
			<persName><forename type="first">A</forename><surname>Cortesi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>File</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Winsborough</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Comparison of Abstract Interpretations</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">623</biblScope>
			<biblScope unit="page" from="521" to="532" />
		</imprint>
	</monogr>
	<note>Proceedings of the Nineteenth ZCALP</note>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction of Approximation of Fixpoints, 4th POPL</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cousot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cousot</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="238" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A Semantic Approach to Automatic Program Improvement</title>
		<author>
			<persName><forename type="first">J</forename><surname>Darlington</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="1" to="46" />
			<date type="published" when="1972">1972. 1981</date>
			<pubPlace>Edinburgh, UK; Darlington, J.</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Artificial Intelligence, Edinburgh University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
	<note>An Experimental Program Transformation System</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Optimizing Almost-Tail-Recursive Prolog Programs</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Debray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IFZP International Conference on Functional Programming Languages and Computer Architecture</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the IFZP International Conference on Functional Programming Languages and Computer Architecture<address><addrLine>Nancy, France; New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1985">1985</date>
			<biblScope unit="volume">201</biblScope>
			<biblScope unit="page" from="204" to="219" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Unfold/Fold Transformations and Loop Optimization of Logic Programs</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Debray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SZGPLAN &apos;88, Conference on Programming Language Design and Implementation</title>
		<meeting>SZGPLAN &apos;88, Conference on Programming Language Design and Implementation<address><addrLine>Atlanta, Georgia, SIGPLAN Not</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="297" to="307" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Debray</surname></persName>
		</author>
		<title level="m">Special Issue on Abstract Interpretation, J. Logic Program</title>
		<imprint>
			<biblScope unit="page">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Denotational and Operational Semantics for Prolog</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Debray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mishra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Program</title>
		<imprint>
			<biblScope unit="page" from="561" to="591" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Functional Computations in Logic Programs</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Debray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Warren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="451" to="481" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">On the Transformation of a Prolog Program to a More Efficient Binary Program</title>
		<author>
			<persName><forename type="first">B</forename><surname>Demoen</surname></persName>
		</author>
		<idno>41. 42. 43. 44. 45</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of LOPSTR &apos;92, Workshops in Computing</title>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">K</forename><surname>Lau</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Clement</surname></persName>
		</editor>
		<meeting>LOPSTR &apos;92, Workshops in Computing<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="242" to="252" />
		</imprint>
	</monogr>
	<note>Logic Program Synthesis and Transfomtation</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Proof Methods of Declarative Properties of Logic Programs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Deransart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of TAPSOFT &apos;89</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>TAPSOFT &apos;89<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="207" to="226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">On the Transformation of Logic Programs with Instantiation Based Computation Rules</title>
		<author>
			<persName><forename type="first">D</forename><surname>De Schreye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bruynooghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symbolic Comput</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="125" to="154" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Compiling Bottom-Up and Mixed Derivations into Top-Down Executable Logic Programs</title>
		<author>
			<persName><forename type="first">D</forename><surname>De Schreye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sablon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bruynooghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Automated Reasoning</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="337" to="358" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">Logic Programming: Systematic Program Deuelopment</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Deville</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page">338</biblScope>
			<pubPlace>Addison-Wesley, Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Generalization and Program Schemata</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Deville</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Burnay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of NACLP&apos;89</title>
		<meeting>NACLP&apos;89</meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="409" to="425" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">A</forename></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Proie'i-Ii</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Logic Program Synthesis</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Deville</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-K</forename><surname>Lau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Program</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="321" to="350" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Logic Program Synthesis and Transformation</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>De Waal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Gallagher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of LOPSTR &apos;91, Workshops in Computing</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Clement</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K.-K</forename><surname>Lau</surname></persName>
		</editor>
		<meeting>LOPSTR &apos;91, Workshops in Computing<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="205" to="221" />
		</imprint>
	</monogr>
	<note>Specialization of a Unification Algorithm</note>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Inductive Assertion Method for Logic Programs</title>
		<author>
			<persName><forename type="first">W</forename><surname>Drabent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Maluszynski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="page" from="133" to="155" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">The Semantics of Predicate Logic as a Programming Language</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Van Emden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kowalski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">I. ACM</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="733" to="742" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">On the Partial Computation Principle</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Ershov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="38" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Ershov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Special Issue: Workshop on Partial Evaluation and Mixed Computation</title>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="volume">6</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">A System for Assisting Program Transformation</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Feather</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="20" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">A Survey and Classification of Some Program Transformation Techniques</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Feather</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IFIP TC2 / W.G.2.1 Working Conference</title>
		<editor>
			<persName><forename type="first">L</forename><forename type="middle">G L T</forename><surname>Meertens</surname></persName>
		</editor>
		<meeting>the IFIP TC2 / W.G.2.1 Working Conference<address><addrLine>Bad Tiilz, Germany; North-Holland, Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier Science Publishers</publisher>
			<date type="published" when="1986">1986. 1987</date>
			<biblScope unit="page" from="165" to="195" />
		</imprint>
	</monogr>
	<note>Program Specification and Transformation</note>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">A Kripke-Kleene Semantics for Logic Programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fitting</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Program</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="295" to="312" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Schema-Based Transformations of Logic Programs</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">E</forename><surname>Fuchs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P J</forename><surname>Fromherz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic Program Synthesis and Transformation, Proceedings of LOPSTR &apos;91, Workshops in Computing</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Clement</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K.-K</forename><surname>Lau Teds</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="111" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">An Algorithm for Partial Evaluation with Constraints</title>
		<author>
			<persName><forename type="first">H</forename><surname>Fujita</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICOT</title>
		<imprint>
			<date type="published" when="1987">1987</date>
			<pubPlace>Japan</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Memorandum TM-0367</note>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">A Self-Applicable Partial Evaluator and Its Use in Incremental Compilation</title>
		<author>
			<persName><forename type="first">H</forename><surname>Fujita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Furukawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">New Generation Comput</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="91" to="118" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Mixed Computation of Prolog Programs</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Fuller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Abramsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">New Generation Comput</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2,3</biblScope>
			<biblScope unit="page" from="119" to="141" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Partial Evaluation of Computation Process-An Approach to a Compiler-compiler</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Futamura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Syst., Comput., Controls</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="45" to="50" />
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Transforming Programs by Specializing Interpreters</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Gallagher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventh European Conference on Artificial Intelligence (ECAI &apos;861</title>
		<meeting>the Seventh European Conference on Artificial Intelligence (ECAI &apos;861</meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="109" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<monogr>
		<title level="m" type="main">A System for Specializing Logic Programs</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Gallagher</surname></persName>
		</author>
		<idno>TR-91-32</idno>
		<imprint>
			<date type="published" when="1991-11">November 1991</date>
		</imprint>
		<respStmt>
			<orgName>University of Bristol</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b61">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Gallagher</surname></persName>
		</author>
		<title level="m">Proceedings of PEPM &apos;93 ACM SIGPLAN Symposium on Partial Evaluation and Semantics Based Program Manipulation</title>
		<meeting>PEPM &apos;93 ACM SIGPLAN Symposium on Partial Evaluation and Semantics Based Program Manipulation<address><addrLine>Copenhagen, Denmark</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="88" to="98" />
		</imprint>
	</monogr>
	<note>Tutorial on Specialization of Logic Programs</note>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Some Low-Level Source Transformations for Program Specialization</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Gallagher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bruynooghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Meta &apos;90 Workshop on Metuprogramming in Logic</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Bruynooghe</surname></persName>
		</editor>
		<meeting>Meta &apos;90 Workshop on Metuprogramming in Logic<address><addrLine>Leuven, Belgium</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="229" to="244" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">The Derivation of an Algorithm for Program Specialisation</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Gallagher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bruynooghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">New Generation Comput</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="305" to="333" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Gallagher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Codish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shapiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Specialization of Prolog and FCP Programs Using Abstract Interpretation</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="159" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Unfold/Fold Transformations of Logic Programs</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Gardner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Shepherdson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computational Logic, Essays in Honor of Alan Robinson</title>
		<editor>
			<persName><forename type="first">J.-L</forename><surname>Lassez</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename></persName>
		</editor>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="565" to="583" />
		</imprint>
	</monogr>
	<note>Plotkin teds</note>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">The Stable Model Semantics for Logic Programming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gelfond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lifschitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifih International Conference and Symposium</title>
		<meeting>the Fifih International Conference and Symposium<address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="1070" to="1080" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Gurr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hansson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-A</forename><surname>Tarnlund</surname></persName>
		</author>
		<title level="m">A Self-Applicable Partial Evaluator for the Logic Programming Language Giidel</title>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Clark</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S.-A</forename><surname>Tarnlund</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Academic</publisher>
			<date type="published" when="1982">1993. 1982</date>
			<biblScope unit="page" from="117" to="122" />
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Bristol, UK</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
	<note>Logic Programming</note>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Towards the Partial Evaluation of CLP Languages</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Hickey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Partial Evaluation and Semantics Based Program Manipulation (PEPM &apos;911</title>
		<meeting>the ACM Symposium on Partial Evaluation and Semantics Based Program Manipulation (PEPM &apos;911<address><addrLine>New Haven, CT, SIGPLAN Not</addrLine></address></meeting>
		<imprint>
			<date>19911</date>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="43" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Proving and Applying Program Transformation Expressed with Second-Order Patterns</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Hogger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Huet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Lang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Znform</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="31" to="55" />
			<date type="published" when="1978">19811. 1978</date>
		</imprint>
	</monogr>
	<note>J. ACM</note>
</biblStruct>

<biblStruct xml:id="b70">
	<monogr>
		<title level="m" type="main">Partial Eoaluation and Automatic Program Generation</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">D</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">K</forename><surname>Gomard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sestoft</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Prentice-Hall</publisher>
			<biblScope unit="page">415</biblScope>
			<pubPlace>Englewood Cliffs, NJ</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Stepwise Development of Operational and Denotational Semantics for Prolog</title>
		<author>
			<persName><forename type="first">N</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mycroft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1984 International Symposium on Logic Programming</title>
		<meeting>the 1984 International Symposium on Logic Programming<address><addrLine>Atlantic City, NJ</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="289" to="298" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Unfold/Fold Transformation of Logic Programs with Counters</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kanamori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Fujita</surname></persName>
		</author>
		<idno>179</idno>
	</analytic>
	<monogr>
		<title level="j">ICOT</title>
		<imprint>
			<date type="published" when="1986">1986</date>
			<pubPlace>Tokyo</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Construction of Logic Programs Based on Generalized Unfold/Fold Rules</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kanamori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Horiuchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourth International Conference on Logic Programming</title>
		<meeting>the Fourth International Conference on Logic Programming<address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="744" to="768" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Derivation of Logic Programs from Implicit Definition</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kanamori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Maeji</surname></persName>
		</author>
		<idno>TR-178</idno>
	</analytic>
	<monogr>
		<title level="j">ICOT</title>
		<imprint>
			<date type="published" when="1986">1986</date>
			<pubPlace>Tokyo, Japan</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Preservation of Stronger Equivalence in Unfold/Fold Logic Program Transformation</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kawamura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kanamori</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">75</biblScope>
			<biblScope unit="page" from="139" to="156" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<monogr>
		<title level="m" type="main">Skeletons and Techniques for Prolog Programming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kirschenbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lakhotia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Sterling</surname></persName>
		</author>
		<idno>TR 89-170</idno>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
		<respStmt>
			<orgName>Case Western Reserve University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b77">
	<monogr>
		<title level="m" type="main">Zntroduction to Metamathematics</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Kleene</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1971">1971</date>
			<pubPlace>North-Holland, Amsterdam</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Partial Evaluation as a Means for Inferencing Data Structures in an Applicative Language: A Theory and Implementation in the Case of Prolog</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Komorowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Ninth ACM Symposium on Principles of Programming Languages</title>
		<meeting>the Ninth ACM Symposium on Principles of Programming Languages<address><addrLine>Albuquerque, NM</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="255" to="267" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<monogr>
		<title level="m" type="main">About Transformation System: A Theoretical Study, 3eme Collogue Intemational sur la Programmation</title>
		<author>
			<persName><forename type="first">L</forename><surname>Kott</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1978">1978</date>
			<publisher>Dunod</publisher>
			<biblScope unit="page" from="232" to="247" />
			<pubPlace>Paris</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">The McCarthy&apos;s Recursion Induction Principle: &quot;Oldy&quot; but &quot;Goody</title>
		<author>
			<persName><forename type="first">L</forename><surname>Kott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Calcolo</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="59" to="69" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<monogr>
		<title level="m" type="main">Unfold/Fold Program Transformation, Algebraic Methods in Semantics</title>
		<author>
			<persName><forename type="first">L</forename><surname>Kott</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
			<publisher>Cambridge University Press</publisher>
			<biblScope unit="page" from="411" to="434" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">Algorithm = Logic + Control</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Kowalski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="424" to="436" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">Negation in Logic Programming</title>
		<author>
			<persName><forename type="first">K</forename><surname>Kunen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Program</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="289" to="308" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Kursawe</surname></persName>
		</author>
		<title level="m">Pure Partial Evaluation and Instantiation</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Bjomer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Ershov</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><forename type="middle">D</forename><surname>Jones</surname></persName>
		</editor>
		<meeting><address><addrLine>North-Holland, Amsterdam</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="283" to="298" />
		</imprint>
	</monogr>
	<note>Partial Evaluation and Mixed Computation</note>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">Composing Recursive Logic Programs with Clausal Join</title>
		<author>
			<persName><forename type="first">A</forename><surname>Lakhotia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Sterling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">New Generation Comput</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="211" to="226" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">Partial Evaluation in Logic Programming</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Lloyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Lloyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Shepherdson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Logic Programming</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1987">1987. 1991</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="217" to="242" />
		</imprint>
	</monogr>
	<note>nd ed.</note>
</biblStruct>

<biblStruct xml:id="b87">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Maher</surname></persName>
		</author>
		<title level="m">Correctness of a Logic Program Transformation System</title>
		<imprint/>
	</monogr>
	<note>Research</note>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">A Transformation System for Deductive Database Modules with Perfect Model Semantics</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Ibm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Watson Research Center ; Maher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th Conference on Foundations of Software Technology and Theoretical Computer Science</title>
		<title level="s">Lecture Notes in Com-93</title>
		<meeting>the 9th Conference on Foundations of Software Technology and Theoretical Computer Science<address><addrLine>Bangalore, India</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
	<note>Report RC 13496</note>
</biblStruct>

<biblStruct xml:id="b89">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Full version in IBM Research Report RC 15062</title>
		<title level="s">also in Theoretical Computer Science</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1989">1989. 1993</date>
			<biblScope unit="volume">110</biblScope>
			<biblScope unit="page" from="377" to="403" />
		</imprint>
	</monogr>
	<note>puter Science 405</note>
</biblStruct>

<biblStruct xml:id="b90">
	<analytic>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Maher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Reasoning About Stable Models (and other Unstable Semantics)</title>
		<imprint>
			<publisher>Watson Research Center</publisher>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<analytic>
		<title level="a" type="main">Difference-List Transformation for Prolog</title>
		<author>
			<persName><forename type="first">K</forename><surname>Marriot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sondergaard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">New Generation Comput</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="125" to="177" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title level="a" type="main">Sound and Complete Partial Deduction with Unfolding Based on Well-Founded Measures</title>
		<author>
			<persName><forename type="first">B</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>De Schreye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bruynooghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Fifth Generation Computer Systems</title>
		<meeting>the International Conference on Fifth Generation Computer Systems</meeting>
		<imprint>
			<publisher>Ohmsha Ltd. 10s Press</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="473" to="480" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<analytic>
		<title level="a" type="main">Memo Functions and Machine Learning</title>
		<author>
			<persName><forename type="first">D</forename><surname>Michie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">218</biblScope>
			<biblScope unit="page" from="19" to="22" />
			<date type="published" when="1968">1968</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b94">
	<analytic>
		<title level="a" type="main">Logimix: A Self-Applicable Partial Evaluator for Prolog</title>
		<author>
			<persName><forename type="first">T</forename><surname>Mogensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bondorf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic Program Synthesis and Transformation, Proceedings of LOPSTR &apos;92, Workshops in Computing</title>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">K</forename><surname>Lau</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Clement</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="214" to="227" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b95">
	<analytic>
		<title level="a" type="main">Negation and Control in Prolog</title>
		<author>
			<persName><forename type="first">L</forename><surname>Naish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">238</biblScope>
			<date type="published" when="1985">1985</date>
			<publisher>Springer</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b96">
	<analytic>
		<title level="a" type="main">Prolog Program Transformations and Tree Manipulation Algorithms</title>
		<author>
			<persName><forename type="first">H</forename><surname>Nakagawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Program</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="77" to="91" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b97">
	<analytic>
		<title level="a" type="main">A Technique for Doing Lazy Evaluation in Logic</title>
		<author>
			<persName><forename type="first">S</forename><surname>Narain</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Program</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="259" to="276" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b98">
	<monogr>
		<author>
			<persName><forename type="first">U</forename><forename type="middle">W</forename><surname>Neumerkel</surname></persName>
		</author>
		<title level="m">Specialization of Prolog Programs with Partially Static Goals and Binarization</title>
		<meeting><address><addrLine>Wien, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
		<respStmt>
			<orgName>Technical University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b99">
	<analytic>
		<title level="a" type="main">Issues in the Partial Evaluation of Meta-Interpreters</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gwen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Meta-Programming in Logic Programming</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Abramson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Rogers</surname></persName>
		</editor>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="319" to="339" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b100">
	<analytic>
		<title level="a" type="main">Finite Differencing of Computable Expressions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Paige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Koenig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="402" to="454" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b101">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">A</forename><surname>Partsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Hewitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename></persName>
		</author>
		<title level="m">Comparative Schematology, Conference on Concurrent Systems and Parallel Computation Project MAC</title>
		<meeting><address><addrLine>New York; Woods Hole, Mass</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1970">1990. 1970</date>
			<biblScope unit="page" from="119" to="127" />
		</imprint>
	</monogr>
	<note>Specification and Transformation of Programs</note>
</biblStruct>

<biblStruct xml:id="b102">
	<analytic>
		<title level="a" type="main">Transformation of Programs and Use of Tupling Strategy</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pettorossi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Znformatica &apos;77</title>
		<meeting>Znformatica &apos;77<address><addrLine>Bled, Yugoslavia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1977">1977</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page">6</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b103">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Pettorossi</surname></persName>
		</author>
		<title level="m">Methodologies for Transformations and Memoing in Applicative Languages</title>
		<meeting><address><addrLine>Edinburgh, UK</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
		</imprint>
		<respStmt>
			<orgName>Edinburgh University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b104">
	<analytic>
		<title level="a" type="main">Rules and Strategies for Program Transformation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pettorossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Proietti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">State-of-the-Art Report on Formal Program Development</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>Rio de Janeiro, Brazil; New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">755</biblScope>
			<biblScope unit="page" from="263" to="304" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b105">
	<analytic>
		<title level="a" type="main">Logic Program Synthesis and Transformation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Prestwich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of LOPSTR &apos;92, Workshops in Computing</title>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">K</forename><surname>Lau</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Clement</surname></persName>
		</editor>
		<meeting>LOPSTR &apos;92, Workshops in Computing<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="199" to="213" />
		</imprint>
	</monogr>
	<note>An Unfold Rule for Pure Prolog</note>
</biblStruct>

<biblStruct xml:id="b106">
	<analytic>
		<title level="a" type="main">Online Partial Deduction of Large Programs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Prestwich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ACM SZGPZ.,Aht Symposium on Partial Evaluation and Semantics-Based Program Manuptdation (PEPM &apos;93)</title>
		<meeting>ACM SZGPZ.,Aht Symposium on Partial Evaluation and Semantics-Based Program Manuptdation (PEPM &apos;93)<address><addrLine>Copenhagen, Denmark; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="111" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b107">
	<analytic>
		<title level="a" type="main">Construction of Efficient Logic Programs by Loop Absorption and Generalization</title>
		<author>
			<persName><forename type="first">M</forename><surname>Proietti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pettorossi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Meta &apos;90</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Bruynooghe</surname></persName>
		</editor>
		<meeting>Meta &apos;90<address><addrLine>Leuven, Belgium</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="57" to="81" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b108">
	<analytic>
		<title level="a" type="main">Semantics Preserving Transformation Rules for Prolog</title>
		<author>
			<persName><forename type="first">M</forename><surname>Proietti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pettorossi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Partial Evaluation and Semantics Based Program Manipulation (PEPM &apos;91)</title>
		<meeting>the ACM Symposium on Partial Evaluation and Semantics Based Program Manipulation (PEPM &apos;91)<address><addrLine>New Haven, CT, SZGPLAN Not</addrLine></address></meeting>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="274" to="284" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b109">
	<monogr>
		<title level="m" type="main">Unfolding-Definition-Folding</title>
		<author>
			<persName><forename type="first">M</forename><surname>Proietti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pettorossi</surname></persName>
		</author>
		<imprint>
			<pubPlace>This Order, for</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b110">
	<monogr>
		<title level="m" type="main">Avoiding Unnecessary Variables in Logic Programs</title>
		<editor>J. Maluszynski and M. Wirsing</editor>
		<imprint>
			<biblScope unit="volume">114</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b111">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd International Symposium on Programming Language Implementation and Logic Programming (PLILP &apos;91)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 3rd International Symposium on Programming Language Implementation and Logic Programming (PLILP &apos;91)<address><addrLine>Passau, Germany; New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<biblScope unit="volume">528</biblScope>
			<biblScope unit="page" from="347" to="358" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b112">
	<analytic>
		<title level="a" type="main">The Loop Absorption and the Generalization Strategies for the Development of Logic Programs and Partial Deduction</title>
		<author>
			<persName><forename type="first">M</forename><surname>Proietti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pettorossi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Program</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="123" to="161" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b113">
	<analytic>
		<title level="a" type="main">Synthesis of Programs from Unfold/Fold Proofs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Proietti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pettorossi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic Program Synthesis and Transformation</title>
		<editor>
			<persName><forename type="first">Y</forename><surname>Deville</surname></persName>
		</editor>
		<meeting><address><addrLine>Louvain-la-Neuve; New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
	<note>Belgium Workshops in Computing</note>
</biblStruct>

<biblStruct xml:id="b114">
	<analytic>
		<title level="a" type="main">On the Declarative Semantics of Stratified Deductive Databases and Logic Programs</title>
		<author>
			<persName><forename type="first">T</forename><surname>Przymusinsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Deductive Databases and Logic Programming</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Minker</surname></persName>
		</editor>
		<meeting><address><addrLine>Los Altos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="193" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b115">
	<analytic>
		<title level="a" type="main">Meta Interpreters for Real</title>
		<author>
			<persName><forename type="first">S</forename><surname>Safra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shapiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Information Processing</title>
		<editor>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Kugler</surname></persName>
		</editor>
		<meeting>Information Processing<address><addrLine>North-Holland, Amsterdam</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="page" from="271" to="278" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b116">
	<monogr>
		<title level="m" type="main">An Automatic Partial Evaluator for Full Prolog</title>
		<author>
			<persName><forename type="first">D</forename><surname>Sahlin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991-03">March 1991</date>
		</imprint>
		<respStmt>
			<orgName>SICS, Sweden</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b117">
	<analytic>
		<title level="a" type="main">An Equivalence Preserving First Order Unfold/Fold Transformation System</title>
		<author>
			<persName><forename type="first">T</forename><surname>Sato</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="page" from="10557" to="10584" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b118">
	<analytic>
		<title level="a" type="main">Deterministic Transformation and Deterministic Synthesis</title>
		<author>
			<persName><forename type="first">T</forename><surname>Sato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Tamaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Future Generation Computers</title>
		<imprint>
			<date type="published" when="1988">1988</date>
			<pubPlace>North-Holland, Amsterdam</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b119">
	<analytic>
		<title level="a" type="main">Recursive Unsolvability of Determinacy, Solvable Cases of Determinacy and their Application to Prolog Optimization</title>
		<author>
			<persName><forename type="first">H</forename><surname>Sawamura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Takeshima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Logic Programming</title>
		<meeting>the Symposium on Logic Programming<address><addrLine>Boston; New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="200" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b120">
	<analytic>
		<title level="a" type="main">Program Improvement by Internal Specialization</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">L</forename><surname>Scherlis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th ACM Symposium on Principles of Programming Languages</title>
		<meeting>the 8th ACM Symposium on Principles of Programming Languages<address><addrLine>Williamsburg, VA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1981">1981</date>
			<biblScope unit="page" from="41" to="49" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b121">
	<analytic>
		<title level="a" type="main">Using Annotations to Make Recursive Equations Behave</title>
		<author>
			<persName><forename type="first">J</forename><surname>Schwarz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng. SE</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="21" to="33" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b122">
	<analytic>
		<title level="a" type="main">Unfold/Fold Transformation of Stratified Programs, meor</title>
		<author>
			<persName><forename type="first">H</forename><surname>Seki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="page" from="107" to="139" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b123">
	<analytic>
		<title level="a" type="main">Unfold/Fold Transformation of General Logic Programs for the Well-Founded Semantics, Special Issue on Partial Deduction</title>
		<author>
			<persName><forename type="first">H</forename><surname>Seki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Program</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">1&amp; 2</biblScope>
			<biblScope unit="page" from="5" to="23" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b124">
	<analytic>
		<title level="a" type="main">Notes on Transformation Techniques for Generate and Test Logic Programs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Seki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Furukawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Logic Programming</title>
		<meeting>the Symposium on Logic Programming<address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="215" to="223" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b125">
	<analytic>
		<title level="a" type="main">Unfold/Fold Transformations of Logic Programs</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Shepherdson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Structure Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="143" to="157" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b126">
	<analytic>
		<title level="a" type="main">Composing Prolog Meta-Interpreters</title>
		<author>
			<persName><forename type="first">L</forename><surname>Sterling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lakhotia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifth International Conference on Logic Programming</title>
		<meeting>the Fifth International Conference on Logic Programming<address><addrLine>Seattle, WA; Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="386" to="403" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b127">
	<analytic>
		<title level="a" type="main">The Art of Prolog</title>
		<author>
			<persName><forename type="first">L</forename><surname>Sterling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shaprio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Affinity between Meta Interpreters and Partial Evaluation</title>
		<editor>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Kugler</surname></persName>
		</editor>
		<meeting><address><addrLine>Cambridge, MA; North-Holland, Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1986">1986. 1986</date>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="page" from="279" to="282" />
		</imprint>
	</monogr>
	<note>Proceedings of Information Processing</note>
</biblStruct>

<biblStruct xml:id="b128">
	<analytic>
		<title level="a" type="main">Partial Evaluation of Prolog Programs and Its Application to Meta Programming</title>
		<author>
			<persName><forename type="first">A</forename><surname>Takeuchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Furukawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Information Processing</title>
		<editor>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Kugler</surname></persName>
		</editor>
		<meeting>Information Processing<address><addrLine>North-Holland, Amsterdam</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="page" from="279" to="282" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b129">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Tamaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sato</surname></persName>
		</author>
		<title level="m">Unfold/Fold Transformation of Logic Programs</title>
		<editor>
			<persName><forename type="first">S.-A</forename></persName>
		</editor>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b130">
	<monogr>
		<author>
			<persName><surname>Tarnlund</surname></persName>
		</author>
		<title level="m">Proceedings of the 2nd International Conference on Logic Programming</title>
		<meeting>the 2nd International Conference on Logic Programming<address><addrLine>Uppsala, Sweden</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="127" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b131">
	<monogr>
		<title level="m" type="main">A Generalized Correctness Proof of the Unfold/Fold Logic Program Transformation</title>
		<author>
			<persName><forename type="first">H</forename><surname>Tamaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sato</surname></persName>
		</author>
		<idno>No. 86-4</idno>
		<imprint>
			<date type="published" when="1986">1986</date>
			<pubPlace>Japan</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Ibaraki University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b132">
	<analytic>
		<title level="a" type="main">Elementary Logic Programs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Tarau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Boyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd International Symposium on Programming Language Implementation and Logic Programming (PLILP &apos;90)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Deransart</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Maluszykski</surname></persName>
		</editor>
		<meeting>the 3rd International Symposium on Programming Language Implementation and Logic Programming (PLILP &apos;90)<address><addrLine>Linkoping, Sweden; New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<biblScope unit="volume">456</biblScope>
			<biblScope unit="page" from="159" to="173" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b133">
	<analytic>
		<title level="a" type="main">Meta-Programming for Reordering Literals in Deductive Databases</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Trhff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Prestwich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd International Workshop on Metaprogramming in Logic (Meta &apos;921</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Pettorossi</surname></persName>
		</editor>
		<meeting>the 3rd International Workshop on Metaprogramming in Logic (Meta &apos;921<address><addrLine>Uppsala, Sweden; New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">649</biblScope>
			<biblScope unit="page" from="280" to="293" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b134">
	<analytic>
		<title level="a" type="main">The Concept of a Supercompiler</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">F</forename><surname>Turchin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="292" to="325" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b135">
	<analytic>
		<title level="a" type="main">Transformation Rules for GHC Programs</title>
		<author>
			<persName><forename type="first">K</forename><surname>Ueda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Furukawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Fifth Generation Computer Systems, ICOT, Tokyo</title>
		<meeting>the International Conference on Fifth Generation Computer Systems, ICOT, Tokyo</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="582" to="591" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b136">
	<analytic>
		<title level="a" type="main">Unfounded Sets and Well-Founded Semantics for General Logic Programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schlipf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Principles of Database Systems</title>
		<meeting>the Symposium on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="221" to="230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b137">
	<analytic>
		<title level="a" type="main">A Prolog Meta-Interpretation for Partial Evaluation and Its Application to Source-to-Source Transformation and Query Optimization</title>
		<author>
			<persName><forename type="first">R</forename><surname>Venken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ECAZ &apos;84</title>
		<editor>
			<persName><forename type="first">T</forename><forename type="middle">O</forename><surname>Shea</surname></persName>
		</editor>
		<meeting>ECAZ &apos;84<address><addrLine>Pisa, Italy, North-Holland, Amsterdam</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="91" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b138">
	<analytic>
		<title level="a" type="main">Deforestation: Transforming Programs to Eliminate Trees</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">L</forename><surname>Wadler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ESOP &apos;88</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>ESOP &apos;88<address><addrLine>Nancy, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="volume">300</biblScope>
			<biblScope unit="page" from="344" to="358" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b139">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Walker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">R</forename><surname>Strong</surname></persName>
		</author>
		<title level="m">Proceedings of the 4th Annual ACM Symposium on Theory of Computing</title>
		<meeting>the 4th Annual ACM Symposium on Theory of Computing<address><addrLine>Denver, CO</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1972">1972</date>
			<biblScope unit="page" from="18" to="34" />
		</imprint>
	</monogr>
	<note>Characterization of Flowchartable Recursions</note>
</biblStruct>

<biblStruct xml:id="b140">
	<analytic>
		<title level="a" type="main">Continuation-Based Program Transformation Strategies</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="164" to="180" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b141">
	<monogr>
		<title level="m" type="main">An Abstract Prolog Instruction Set</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H D</forename><surname>Warren</surname></persName>
		</author>
		<idno>309</idno>
		<imprint>
			<date type="published" when="1983">1983</date>
			<publisher>SRI International</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b142">
	<analytic>
		<title level="a" type="main">Memoing for Logic Program</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Warren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="93" to="111" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b143">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Wiggins</surname></persName>
		</author>
		<title level="m">Negation and Control in Automatically Generated Logic Programs</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b144">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd International Workshop on Metaprogramming in Logic (Meta &apos;92)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Pettorossi</surname></persName>
		</editor>
		<meeting>the 3rd International Workshop on Metaprogramming in Logic (Meta &apos;92)<address><addrLine>Uppsala, Sweden; New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">649</biblScope>
			<biblScope unit="page" from="250" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b145">
	<monogr>
		<title level="m" type="main">Algorithms + Data Structures = Programs</title>
		<author>
			<persName><forename type="first">N</forename><surname>Wirth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1976">1976</date>
			<publisher>Prentice-Hall, Inc</publisher>
			<pubPlace>Englewood Cliffs, NJ</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b146">
	<analytic>
		<title level="a" type="main">An Automatic Difference-List Transformation Algorithm for Prolog</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">W</forename><surname>Grant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 1988 European Conference on Artificial Intelligence (ECAI &apos;88)</title>
		<meeting>1988 European Conference on Artificial Intelligence (ECAI &apos;88)<address><addrLine>Pitman, London</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="320" to="325" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
