<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Breaking the MapReduce stage barrier</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2011-09-10">10 September 2011</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Abhishek</forename><surname>Verma</surname></persName>
							<email>verma7@illinois.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>201 North Goodwin Avenue</addrLine>
									<postCode>61801-2302</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>201 North Goodwin Avenue</addrLine>
									<postCode>61801-2302</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Brian</forename><surname>Cho</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>201 North Goodwin Avenue</addrLine>
									<postCode>61801-2302</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>201 North Goodwin Avenue</addrLine>
									<postCode>61801-2302</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Nicolas</forename><surname>Zea</surname></persName>
							<email>nicolas.zea@gmail.com</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>201 North Goodwin Avenue</addrLine>
									<postCode>61801-2302</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>201 North Goodwin Avenue</addrLine>
									<postCode>61801-2302</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Indranil</forename><surname>Gupta</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>201 North Goodwin Avenue</addrLine>
									<postCode>61801-2302</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>201 North Goodwin Avenue</addrLine>
									<postCode>61801-2302</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Roy</forename><forename type="middle">H</forename><surname>Campbell</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>201 North Goodwin Avenue</addrLine>
									<postCode>61801-2302</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>201 North Goodwin Avenue</addrLine>
									<postCode>61801-2302</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>201 North Goodwin Avenue</addrLine>
									<postCode>61801-2302</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Breaking the MapReduce stage barrier</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2011-09-10">10 September 2011</date>
						</imprint>
					</monogr>
					<idno type="MD5">63E98AAB7E3E740B88DFA276DFD71AFB</idno>
					<idno type="DOI">10.1007/s10586-011-0182-7</idno>
					<note type="submission">Received: 20 July 2011 / Accepted: 11 August 2011 /</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:00+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The MapReduce model uses a barrier between the Map and Reduce stages. This provides simplicity in both programming and implementation. However, in many situations, this barrier hurts performance because it is overly restrictive. Hence, we develop a method to break the barrier in MapReduce in a way that improves efficiency. Careful design of our barrier-less MapReduce framework results in equivalent generality and retains ease of programming. We motivate our case with, and experimentally study our barrier-less techniques in, a wide variety of MapReduce applications divided into seven classes. Our experiments show that our approach can achieve better job completion times than a traditional MapReduce framework. This is due primarily to the interleaving of I/O and computation, and forgoing disk-intensive work. We achieve a reduction in job completion times that is 25% on average and 87% in the best case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Keywords MapReduce • Data-intensive computing</head><p>This is an extended version of our IEEE Cluster 2010 paper <ref type="bibr" target="#b23">[25]</ref>.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Inspired by the map and reduce primitives present in functional languages, Google proposed MapReduce <ref type="bibr" target="#b6">[7]</ref>. The MapReduce framework simplifies the development of largescale distributed applications on clusters of commodity machines. It has become widely popular, e.g., Google uses it internally to process more than 20 PB per day <ref type="bibr" target="#b6">[7]</ref>. Yahoo!, Facebook and others use Hadoop, an open-source implementation of MapReduce <ref type="bibr" target="#b0">[1]</ref>.</p><p>The MapReduce model has become popular because a programmer can harness the processing power of large data centers for very large parallel tasks in a simple way. The programmer only needs to write the logic of a Map function and a Reduce function. This eliminates the need to implement fault-tolerance and low-level memory management in the program; the MapReduce framework takes care of these concerns for general programs.</p><p>The MapReduce framework divides the program execution into a Map and a Reduce stage. In the first stage, each machine in the cluster executes a Map function on a distinct portion of the input data. The Map execution produces records that consist of a key and value. Map output is transferred to Reducers according to key. For each key, the complete set of records produced across multiple machines in the Map stage are transferred to the Reducer assigned to that key. In current implementations of MapReduce, a barrier exists that prevents the Reduce stage from starting until all records from the Map stage have been transferred to their respective Reducers. The barrier ensures that all relevant records are available when computing the Reduce function.</p><p>In this paper, we break the barrier between stages in MapReduce. The result is a barrier-less version of MapReduce, which can have significantly improved performance. At the same time, we take special care to maintain the simplicity and generality of the MapReduce framework. To this end, we investigate a broad set of categories of MapReduce programs, differing in the structure and the memory usage of the Reduce function. Based on these observations, we develop memory management techniques that are general and yet require minimal additional effort by the MapReduce programmer.</p><p>Our main contributions are as follows:</p><p>1. We present techniques for supporting general purpose applications in a barrier-less MapReduce framework. 2. For seven different categories of MapReduce algorithms, we show how they can be converted to their barrier-less forms. 3. We identify and address the memory management concerns that arise from removing the barrier. 4. Our experience with implementing various barrier-less algorithms shows there is minimal additional programmer effort. 5. We experimentally evaluate the benefit of converting algorithms to their barrier-less version. Our results show an average improvement of 25% (and 87% in the best case) in job completion times. 6. By reviewing the job execution, we observe that the improvement is due to interleaving of I/O and computation, as well as forgoing disk-intensive work.</p><p>In this paper, we focus on the Hadoop framework because of its open source nature. However, our contributions are not limited to this particular instance. The technique of using write-local read-remote data transfer with a stage barrier is also used in Google's MapReduce, as well as related parallel processing frameworks such as Dryad <ref type="bibr" target="#b15">[16]</ref>. Barrier-less implementations of these frameworks will also benefit from the techniques described in our paper.</p><p>The rest of the paper is structured as follows. We first examine the role of the MapReduce barrier in Sect. 2. In Sect. 3, we then discuss the new design of Hadoop MapReduce framework after breaking the barrier. We observe that this improves performance in many cases, but can present a memory management problem. In Sect. 4, we investigate the memory usage patterns of MapReduce applications, and produce a categorization based on the structure of the Reduce function. Based on these observations, in Sect. <ref type="bibr" target="#b4">5</ref> we develop new techniques that are able to manage memory for general applications while breaking the barrier. In Sect. 6, we present experimental results that show a significant improvement in Hadoop performance when these techniques are applied. We then discuss related work in Sect. 7 and finally conclude in Sect. 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Motivation: MapReduce barrier</head><p>The execution of a MapReduce program is divided into a Map stage and a Reduce stage. The MapReduce framework writes the Map output locally at each machine and then aggregates the relevant records at each Reducer by remotely reading from the Mappers. This process of transferring data is called the Shuffle stage. In current open source MapReduce implementations (e.g., Hadoop), the Shuffle stage contains a distributed barrier.</p><p>The Reducer reads the relevant records from many Map nodes. These entries are not in a sorted order, and are buffered at the Reducer. The barrier is reached when the Reducer has received all Map output. The Reducer then sorts the buffered entries, effectively grouping them together by key. Finally, the Reduce function is applied to each group of entries with the same key, one by one.</p><p>The barrier is useful for several reasons, most prominent being to provide simplicity and efficiency by allowing the Reduce function to atomically operate on all records for a particular key. This in turn means that once a key is processed all partial results for that key can be disposed of and the output may be written.</p><p>However, despite these apparent advantages, we argue that removing the barrier is, in many practical cases, much more efficient. When we remove the barrier, execution of our Reduce function no longer needs to wait for all records to be remotely read and grouped by key. Instead, the Reduce function can be immediately invoked on each input entry, as it becomes available. This relaxation can significantly improve the efficiency of the Reduce task execution.</p><p>More concretely, by removing the barrier, we are able to perform work at Reducers during two waiting intervals before the Reduce operations are executed: (1) the time interval between remote read of the first and last records, and (2) the time taken for sorting the records. Instead of waiting for remote reads to finish, our framework interleaves the network I/O with the computation of the Reduce function. Our framework forgoes the disk-intensive operation of sorting records altogether for most algorithms. Both of these waiting intervals are sensitive to heterogeneity that is inherent in clusters. Clusters with commodity hardware often show differences in performance between machines, and they have oversubscribed links between machines. The time it takes to read all records depends on the relative speed between the Mapper nodes and the speed of data transfer from the Mapper nodes to Reducer nodes. This can further extend the first interval of waiting. The time consumed by diskintensive operations in the second interval is sensitive to the relative disk speeds across each node. The barrier-less model removes these intervals, thus improving performance.</p><p>As a consequence of removing both waiting intervals, the records in the barrier-less model are no longer sorted in key order. Our investigation of seven classes of MapReduce applications summarized in Table <ref type="table" target="#tab_0">1</ref> (detailed in Sect. 4) reveals that, in practice, a significant number of applications do not require the full key sorting provided by the MapReduce framework. The main role of sorting by key is to group records with the same key together. Grouping is necessary in traditional MapReduce, because it requires all records for a key to be present when the Reduce function is executed.</p><p>The barrier-less approach removes this requirement, and the Reduce function is run on records one by one. This approach raises an important problem: partial results for each key must be maintained.</p><p>Our investigation shows that the number of partial results that must be maintained differs widely across MapReduce applications (see column "Size of partial results" in Table <ref type="table" target="#tab_0">1</ref>). Thus, for the barrier-less model to work with general MapReduce applications, we require techniques for maintaining and updating these partial results. Before we develop these techniques in detail (see Sect. 5), we first describe the structure and usage of our basic framework for barrier-less MapReduce.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Breaking the barrier</head><p>In this section, we describe our implementation of barrierless MapReduce, and illustrate how to modify an existing MapReduce application to be used in this framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Barrier-less Hadoop implementation</head><p>We implemented barrier-less MapReduce by modifying the open-source Hadoop implementation. The original Hadoop implementation employs a barrier as described in the previous section. In order to break the barrier, we had to incorporate two primary design decisions: (1) bypass the batched sorting mechanism, and (2) modify the invocation of the Reduce function so that it can be called with a single record (instead of a key and all values corresponding to it).</p><p>Hadoop's Shuffle stage is implemented by transferring batches of records from Mappers to Reducers. Each Mapper buffers its processed records. When all local processing is finished the Mapper sorts the records by key, a step that partitions the records to be transferred to each Reducer. If the buffer grows larger than the memory available, it is spilled to disk and later merge-sorted. Each Reducer retrieves the batch of records from each Mapper only after it has completed. When all records from every Mapper are received by the Reducer it merge-sorts them. This step of sorting groups all records together.</p><p>For barrier-less MapReduce, we pipeline the record transfer and Reduce execution at the single record level, instead of batching. There are two potential benefits to pipelining. First, we make it possible to interleave network I/O of the record transfer with CPU computation. Second, we avoid the need to spill the intermediate data to disk when the size of batched records grows beyond memory.</p><p>In our implementation, the Reducer uses one asynchronous thread per Mapper to retrieve records, as soon as they are available. These records are stored into a single buffer, and a separate thread executes the Reduce function on the records in the buffer in a first-in first-out manner. The Reduce function called in this manner is only passed a single key/value record, as opposed to a key and all its corresponding values in the original Hadoop. This subtle difference in the framework compared to original Hadoop slightly changes the way applications are implemented, as we show with an example in Sect. 3.2.</p><p>However, these changes do not affect other aspects of the execution of Hadoop. In other words, assignment of tasks, fault-tolerance, scheduling, etc., are handled in the same way as original Hadoop.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Barrier-less WordCount</head><p>As previously mentioned, when executed with barrier-less Hadoop, the Reduce function does not have the guarantee of atomically receiving all records for a given key. Therefore, the application must be modified to handle records one by one. To do this, a programmer must code, in addition to the Map and Reduce function, a custom run function that makes calls to the Reduce function. In the original Hadoop, the run function invokes the Reduce function once per key. For barrier-less Hadoop, the run function invokes the Reduce function once per entry, and the programmer additionally specifies in this function how partial results are stored and reused across Reduce invocations.</p><p>In the rest of this section, we present a concrete example of the difference between an application coded for the original and barrier-less MapReduce frameworks. For this, we use the WordCount application provided with the Hadoop distribution. The original program is shown in pseudo-code form in Algorithm 1. In the Map function, each output entry is simply a word and a count of 1. In the Reduce function, the number of output entries with the same key is counted. The run function, which is part of the Hadoop framework, ensures that the Reduce function is called once for each key, with all the values as input.</p><p>To run WordCount without a barrier, the programmer has to modify the Reduce and run functions as presented in Algorithm 2. The run function calls Reduce on each entry that is received. In other words, the Reduce function no longer assumes that all values for a key are passed in at once. This implies that the Reducer must maintain partial results for every key it has received. For our purposes, we use the TreeMap data structure from java.util, which is internally implemented as Red-Black trees <ref type="bibr" target="#b12">[13]</ref>. A TreeMap can quickly access partial results while maintaining key ordering. As a record (which is a key/value pair) arrives, the run function reads the previous partial result, and passes it to the Reduce function. The Reduce function performs the computation, and stores the new result back into place. Once there are no more records and all the Reduce invocations have completed, the output is generated by the run function.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> shows the system-wide progress of the Word-Count program with and without a barrier on the same cluster. (Details of the experimental setup are provided in Sect. 6.) The y-axis represents the number of CPU cores executing at each stage. In the original MapReduce, we can see the barrier in the delay between the Map tasks finishing at 155 seconds and the Reduce function invocations beginning at 170 seconds. In the barrier-less version though, the combined Shuffle and Reduce stage begins at 50 seconds, when the first Mappers begin to complete. We refer to the time gap between when the first Mappers complete and when the  In barrier-less MapReduce, there is no distinct barrier between Shuffle and Reduce. Instead, each Reducer works on individual records as the Shuffle process pulls them in. Because these two stages are combined and interleaved, we see an improvement in job completion time. We observe that the job finishes within 160 seconds, or only 10 seconds after the final Map task completes. This is a 30% improvement in the job completion time for WordCount. This benefit arises because we can perform meaningful work in the form of Reduce operations during the mapper slack time, in which the barrier version is performing the shuffle/sort operation. At the same time, since our modifications were non-invasive, the correctness and the completeness of the MapReduce execution is not compromised.</p><p>Finally, we observe that depending on the application, the amount of memory consumed at each Reducer by partial results may vary. In the worst case the number of partial results may become very large and cause the Reducer to run out of memory. This motivates the development of new memory management techniques that can prevent overflows and we address this in Sect. 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Classifying reduce operations</head><p>In order to understand the implications of breaking the barrier in the general case, we need to understand concrete MapReduce applications. Hence, we performed a case study of a wide variety of published MapReduce applications and investigated how to break the barrier for each of them. The applications we studied were the following: MapReduce example benchmarks <ref type="bibr" target="#b6">[7]</ref>; machine learning benchmarks <ref type="bibr" target="#b4">[5]</ref>; statistical machine translation <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b8">[9]</ref>; optimization algorithms <ref type="bibr" target="#b22">[24]</ref>; finance algorithms <ref type="bibr" target="#b2">[3]</ref>; and similarity scoring <ref type="bibr" target="#b9">[10]</ref>.</p><p>We classified the Reduce operations performed in these applications. The result is a list of seven types: Identity, Sorting, Aggregation, Selection, Post-reduction processing, Cross-key operations and Single reducer aggregations. This information is summarized in Table <ref type="table" target="#tab_0">1</ref>. In the rest of this section, we present our classification. For each type, we discuss a representative application and how partial results must be stored and updated during execution in barrier-less MapReduce.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Identity</head><p>Identity operations are Reduce operations that perform little to no explicit work. An example of an Identity operation is a Distributed Grep application <ref type="bibr" target="#b6">[7]</ref>. The Map function emits a line of text if it matches a pattern. The Reduce function is merely used to write the final output.</p><p>Identity operations are the simplest kind of Reduce operation. They do not require the Reduce input to be sorted by key. There is also no need to keep partial results for any keys, because the results are written immediately as final output. Hence, there is no difference between implementing this operation for original and for barrier-less MapReduce.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Sorting</head><p>This is the only prominent kind of operation we found that requires a strict ordering on the output keys. For sorting operations, the Reduce operation must write output that is in a sorted order. This is a popular application, e.g., a sort implemented in Hadoop holds the record for the fastest sort of 100 TB of data <ref type="bibr" target="#b18">[19]</ref>.</p><p>The implementation of a sorting operation is dependent on whether or not a barrier is present. With a barrier, the implementation of a sorting operation is identical to an Identity operation. The MapReduce framework itself, rather than the Reduce operation, does the job of sorting the output by key. If sorting by value is also required, a secondary sort operation is easily performed using custom grouping and comparison operations. However, this is not the case when the barrier is broken.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Effect of no barrier:</head><p>To implement a sorting operation without a barrier, the data must be sorted in the Reduce function, typically through the use of an ordered data structure like a Red-Black tree. None of the partial results can be emitted until all the values have been seen and completely sorted. Thus, in the worst case each Reducer must maintain a data structure of size O(records), the total number of records executed at the Reducer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Aggregation</head><p>We classify aggregation operations as those that are commutative and distributive-they include addition and multiplication. They perform an operation on all the values associated with a key, and emit an aggregated value as output. Since the operations are commutative, the ordering of the keys is not required.</p><p>An example is the WordCount application from Sect. 3. For each key, the entries that contain the count of the key are summed up into the aggregate word count. In the original version, the Reduce function is invoked with a key and all of its associated values. Hence, it can aggregate them and emit the final count immediately.</p><p>Effect of no barrier: For the barrier-less version, a running aggregate result must be maintained for each key. Thus, the Reducers must maintain O(keys) state for storing the partial results. The Reducer outputs the results only when all the keys and their associated values have been processed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Selection</head><p>Selection operations are those that select a subset of the values associated with a key. Examples include finding the max, min, median, or top k values.</p><p>With a barrier present, while sorting keys the framework can also allow the developers to sort values as well (e.g., Hadoop's secondary sort). Given such an ordering, the Reduce function can trivially select the values of interest. For example, when finding a minimum, the Reducer can select and output the first value for every key.</p><p>In our barrier-less implementation, we bypass the sort operation, so these operations must be performed on a running basis. For example, a running minimum (or minimum k values) can be kept and updated as new values arrive. Therefore, the barrier-less version of a selection operation maintains a per-key context with the currently selected values, and emits the final output once all values have been processed.</p><p>To investigate selection algorithms, we implemented a k-Nearest Neighbors algorithm. This is a classic algorithm that reads in two sets of data, a training set and an experimental set, and finds the k values in the training set closest to each value in the experimental set. It was first presented in <ref type="bibr" target="#b11">[12]</ref> and is often used in statistical analysis applications, such as finding pairwise similarity <ref type="bibr" target="#b9">[10]</ref>.</p><p>The distance between an experimental value (E) and the training value (T ) is defined as the absolute value of their difference (|E -V |). It is necessary to compare each experimental value to every training value. The barrier version's Map function emits a tuple (E, |E -V |) for the key, and an integer T for the value. A secondary sort is performed, sorting by the |E -V | value in the key, but grouping by E. Then, in the Reducer, the first k values are emitted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Effect of no barrier:</head><p>The barrier-less version maintains a k-value-per-key context, stored as a TreeMap (a Red-Black tree implementation in Java) of linked lists. The Mapper emits an integer E as the key and a tuple (T , |E -V |) as the value. There is no need to emit a tuple as before, since a sort is not performed. Now, for each key, the Reducer maintains a size-k ordered linked list, and decides if the most recently received (E, |E -V |) tuple belongs in the list, based on the |E -V | value within the tuple. If this is the case, it is inserted into the appropriate location within the ordered linked list, evicting the tuple with the largest distance if the linked list size exceeds k. Once all value tuples have been processed for a key, the contents of the linked list (namely the top k E values), are emitted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Post-reduction processing</head><p>In post-reducer processing operations, the Reduce operation works in two steps. First, the entries with a key are processed and inserted into a temporary data structure. When all the entries for a key have been processed, a post-processing operation is applied on the temporary data structure to get the final output for the key.</p><p>An example application is the one used at Last.fm to track the number of unique users that listen to each track of music in the service <ref type="bibr" target="#b24">[26]</ref>. Entries of the input data consists of a userId and trackId (and other information). The trackId is the key of the record. The number of unique users per track is counted in two steps. In the processing stage, the userId of each record is added into a data structure that does not hold duplicate values e.g., the code presented in <ref type="bibr" target="#b24">[26]</ref> uses a Java Set. Then the post-processing step counts the total number of entries in the data structure.</p><p>Effect of no barrier: With a barrier, the temporary data structure will grow with the maximum number of records with a certain key. This in itself could be a large amount of data. However, when the barrier is broken, the structure can grow even larger. The temporary data structure for each key must be maintained, in a partial result structure such as a TreeMap. The total amount of partial results can grow to O(records).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Cross-key operations</head><p>Typically a Reduce function processes its keys independent of the other Reduce functions. However, in cross key operations, the Reduce function can depend on other keys, for example the previous k keys. This can be implemented by maintaining a window of k previously seen keys, operating over them and emitting the final output. Since Reduce does not depend on other keys, it can terminate after emitting its output.</p><p>To investigate cross-key operations, we use the example of genetic algorithms; in particular we use <ref type="bibr" target="#b22">[24]</ref>. Each individual (I ) is represented as a key and the Mapper computes the fitness (F ) of each individual and emits the tuple (I, F ). The Reducer maintains a window of previously seen individuals and when the window is full, performs the selection and crossover operations of the genetic algorithm and finally emits the individuals as output.</p><p>Effect of no barrier: Only partial results for the window containing the previous k keys need to be maintained. When a partial result is removed from the window, it is written as a final result. Thus, the memory requirement for storing partial results is O(k).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.7">Single reducer aggregation</head><p>Single reducer aggregations involve the use of a single Reducer to aggregate the outputs from multiple Mappers. This is generally used for determining measures of central tendency or dispersion where global knowledge of all the Map outputs is required.</p><p>We study single reducer aggregations through a Monte Carlo simulation that computes the Black-Scholes option pricing value ( <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b10">11]</ref>). Each Mapper performs complex floating point operations like exponentiation according to the Black-Scholes formula and the Reducer computes the average and standard deviation of all the values computed by the Mappers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Effect of no barrier:</head><p>The average operation can be incrementally computed by maintaining a running sum of the values and performing a division at the end. In order to calculate the standard deviation along with the average, the Mapper emits the square of the value along with the value itself. The Reducer maintains a running sum of the squares of the values along with a running sum and a count of the values. Let x 1 , x 2 , . . . , x N be the values whose mean is x. The standard deviation is computed as follows:</p><formula xml:id="formula_0">σ = 1 N N i=1 (x i -x) 2 = 1 N N i=1 x 2 i -2 x N i=1 x i + N x2 = 1 N N i=1 x 2 i -x2</formula><p>As only the running sums have to be saved, only O(1) memory is required for storing the partial results at the Reducer. Since summations are commutative operations, ordering of the keys is not required.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Managing memory overflows</head><p>As noted in Sect. 3, an important change in our barrier-less MapReduce framework is the need to manage the storage of partial results. Depending on the category of the Reduce operation involved (see Sect. 4), the partial result memory complexity can be up to O(records), growing to the number of records executed at the Reducer. For large datasets, which MapReduce caters to, this can quickly overflow the in-memory capacity at a server. For instance, the line "Inmemory TreeMap" in Fig. <ref type="figure" target="#fig_1">2</ref> shows the amount of heap space used by a Reducer in a MapReduce job which performs a WordCount on a 16 GB dataset. The used memory increased, until the Reducer ran out of available heap space. An OutOfMemory exception was thrown and the job was killed around 80 s.</p><p>In order to address these memory overflow problems, we explore two possible memory management solutions: a disk spill and merge scheme and an off-the-shelf disk-spilling key/value store.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Disk spill and merge</head><p>In the disk spill and merge scheme, we define a memory threshold. If memory usage for partial results reaches this threshold, it is spilled to a newly created file on disk. When all records have been processed, the spilled files are merged using a merge function defined by the programmer.</p><p>During the course of execution at a Reducer, the memory threshold may be reached multiple times, creating many spill files. Thus, partial results for a single key may be spilled onto multiple different spill files. After all invocations of the Reduce function at a Reducer are finished, all the partial results for a single key must be merged together.</p><p>The disk spill and merge scheme is designed to allow the merge to be performed efficiently. Partial results are sorted by key as they are moved to a spill file. Then the merge phase merges all the partial results for each key in a straightforward manner, similar to an external merge-sort. For every local spill file, the first partial result is loaded into the memory and stored in a buffer. Spill files containing the globally lowest key are then repeatedly read from until the lowest key's partial results are all loaded into memory. Once all partial results for a key have been merged, the result can be written as the final output. The next globally lowest key is found and processed in the same fashion, until all keys have been processed.</p><p>The method of merging results of each key depends on the application and the data structure that stores the partial results. Thus, the programmer supplies the merge function. This function is functionally similar to the combiner method of MapReduce (as specified in <ref type="bibr" target="#b6">[7]</ref>), but may be customized if more complex methods are required for maintaining partial results.</p><p>The effect of using Disk Spill and Merge is shown in Fig. <ref type="figure" target="#fig_1">2</ref>. In our implementation, we maintain a count of records in the partial result data structure to estimate the memory usage. We spill to and read from disk by using Java's serialize/deserialize interface. The line "Spill and Merge" shows that the partial results data structure is kept below the memory threshold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Disk spilling key/value store</head><p>Instead of flushing the entire contents of the memory to a file on the disk, the partial results can be maintained in a key/value store that has the capability of spilling to disk. Every invocation of the Reduce function fetches the previous partial result from the key/value store, processes the current input and then stores the result back into the key/value store. This read-modify-update cycle is carried out for all the inputs to the Reducer. The key/value store is capable of evicting some records out of memory and spilling to disk according to policies like Least Recently Used (LRU), whenever it runs out of memory.</p><p>We experimented with different key/value stores such as BerkeleyDB <ref type="bibr" target="#b17">[18]</ref>, Tokyo Cabinet [23] and MongoDB <ref type="bibr" target="#b16">[17]</ref>. Among these, BerkeleyDB (Java Edition) exhibited the highest raw read and write throughput in terms of operations per second. Hence, we chose it as the key/value system to run our experiments. We configured BerkeleyDB for performance without guaranteeing fault-tolerance of the data, because the MapReduce framework takes care of these concerns. The transaction log buffers were maintained in memory and only written to stable storage when BerkeleyDB determines that they are full or it is out of main memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Qualitative comparison</head><p>The disk spill and merge approach has the advantage of avoiding the thrashing of in-memory data, unlike Berke-leyDB's caching scheme. Similarly, because it is intended specifically for managing partial result storage, it is more lightweight and efficient than a generic disk-spillable key/ value store. On the other hand, it will not be able to take advantage of any prior knowledge of the distribution of keys, as it treats each of them equally. Therefore, in situations where certain keys are significantly more common than others, unnecessary spilling may occur. BerkeleyDB, like most key/value stores, performs caching and pre-fetching of common entries, in order to minimize reading from disk, and can therefore exploit temporal locality. We compare these approaches quantitatively in Sect. 6.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Experimental evaluation</head><p>In this section, we evaluate the performance characteristics of our implementation of barrier-less MapReduce. Our implementation is based on Hadoop 0.20. We measured the improvement over the original Hadoop 0.20 for the seven classes of applications described in Sect. <ref type="bibr" target="#b3">4</ref>.</p><p>We performed our experiments on 16 nodes from the Cloud Computing Testbed (CCT) <ref type="bibr" target="#b14">[15]</ref> running 64 bit Cent OS 5.4 operating system. Each node has dual Intel Quad cores, 16 GB RAM and a single 1 TB hard disk. The nodes are connected together with a Gigabit Ethernet switch. A single node was configured to be the JobTracker and the NameNode and the other 15 nodes were used as slaves. The replication factor of the distributed file system was set to 3 and the default chunksize was 64 MB. The number of Mappers and Reducers per node was set to 4, in order to utilize all the 8 cores on each node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Improvement with input data size</head><p>We experimentally evaluated the improvements in the job completion times for six applications in the following subsections. These applications correspond to the seven classes described in Sect. 4. (We omit the Identity class because the original and barrier-less versions are identical.) Figure <ref type="figure" target="#fig_2">3</ref> shows the job completion times for various benchmarks with and without barrier.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.1">Sort</head><p>Our barrier-less sort is implemented in a similar manner to our WordCount implementation, in order to avoid consuming memory for duplicate keys. We use a Red-Black tree implementation (Java TreeMap) to store a per-key count value. This count value is incremented, when a duplicate key is encountered. When we output the results, we emit the duplicates of the key count number of times. This is a degenerate case, because in the original MapReduce, both Mappers and Reducers perform no work. The comparison between the original and the barrier-less MapReduce versions becomes a competition between the two sorting mechanisms. In this case the original merge sort is faster than performing insertions into a Red-Black Tree. As a result, we observed slight slowdowns in the barrier-less version, up to 9% in the 8 GB case, and going down to 2% for the 16 GB case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.2">WordCount</head><p>The WordCount application involves the aggregation operation of summing the count of the word occurrences. Despite the relatively small amount of non-sorting work performed in this benchmark, we observed that the barrier-less approach results in an average of 15% decrease in job completion times. Although the work performed in the barrierless WordCount is essentially the same as in the barrier-less Sort, WordCount has more room for improvement due to the extra aggregation work the original version performs. This shows that, although Reducers performing no work may not see gains from our barrier-less system, even work as simple as aggregation can see notable gains. However, this improvement did not increase proportionally with the size of the dataset, since writing the output to the distributed file system is the bottleneck. Nevertheless, we observed an average decrease of 18% in job completion times. This improvement slowly increased as the dataset size was increased, since the number of Map rounds increased, thereby increasing mapper slack. In addition, the experimental values must be unique while training set values need not be. Therefore, the number of keys did not grow at the same rate as the number of values, resulting in less per-key data. This nature of the data affects performance as it results in relatively lesser memory overhead for the barrier-less version.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.4">Last.fm unique listens</head><p>The calculation of unique listens uses post-reduction processing. The application counts the unique number of users that listen to a track. We ran our experiments on a dataset that generated track listens, uniformly at random across 50 users and 5000 tracks. For varying sizes of input data, we consistently observed a 20% decrease in job completion time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.5">Genetic Algorithms</head><p>Genetic Algorithms are used to exemplify cross-key operations. The genetic algorithm required no change to perform barrier-less calculation, as no per-key data had to be maintained. The algorithm in both the original and the barrier-less In this experiment (Fig. <ref type="figure" target="#fig_3">4</ref>), we executed a genetic algorithm with a population of 50 million individuals per mapper and varied the dataset size by increasing the number of mappers. The number of Reducers was set to 40. We observed that the performance is limited by the time spent in writing intermediate data to the local disk or the output to the distributed filesystem. This resulted in a benefit of about 15%, which stays relatively constant as the dataset size increases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.6">Black-Scholes options pricing</head><p>The calculation of options pricing using Black-Scholes involves using a single reducer aggregation to calculate the mean and standard deviation. In this experiment, we executed a million iterations of the Black-Scholes algorithm per mapper. Black-Scholes, similar to genetic algorithms, has a constant amount of memory in use at the Reducer (O(1) with relation to the input dataset size). However, unlike genetic algorithms, the output data is also constant in size since it is just a single running average and standard deviation. Figure <ref type="figure" target="#fig_3">4</ref> shows that our approach resulted in an average benefit of about 56%, which continued to increase as the number of iterations increased. The maximum improvement in completion time observed was 87%. This is the best performance of our approach across all application classes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.7">Comparing improvement across applications</head><p>Black-Scholes showed the largest improvement, due to the O(1) memory overhead and output dataset size. The other benchmarks had improvements that stayed consistent around the 20% mark, which was the common case due to the limitations imposed by mapper slack and time spent writing to disk. In addition, sort was observed to be our worst case with a small performance loss on average. In order to better understand the reason behind the improvement in overall completion time for barrier-less MapReduce, we take an in-depth look at the execution of two of the applications, WordCount and Genetic Algorithm. We chose these applications because they showed improvements closest to the average.</p><p>In Fig. <ref type="figure" target="#fig_5">6</ref>, we plot a CDF of the duration of each task in the Reduce stage, for both original MapReduce and barrier-less MapReduce. The task duration denotes the duration from when the first byte is received at the Reduce task from a Map task, to when the Reduce task emits its final byte of output. We make two observations about the improvement in overall completion time. First, the median Reduce task completion time is smaller for barrier-less MapReduce. For WordCount, up to the 95th percentile, the gap is between 20 to 30 seconds, while for Genetic Algorithm, up to the 90th percentile, the gap is between less than 5, to around 10 seconds. Secondly, the original MapReduce contains outlier Reduce tasks that have significantly longer completion times than other Reduce tasks. In contrast, we do not see any significant outliers in barrier-less MapReduce. Due to this, there is a large gap between the Reduce tasks with the longest completion times: the gap for WordCount is more than 40 seconds, while for Genetic Algorithm it is almost 25 seconds.</p><p>These factors are also visibly present in Fig. <ref type="figure">7</ref>, where we plot the end time for each Reduce task, i.e., when the final byte of output is emitted, counting from the start of the entire MapReduce job.</p><p>Figures <ref type="figure">8</ref> and<ref type="figure">9</ref> plot the start and duration for each individual Map and Reduce task. For original MapReduce, the Reduce stage is separated into Shuffle, Sort (not to be confused with the Sort application), and Reduce function execution. Shuffle execution is dominated by network I/O, Sort   ond, Sort appears to be the main cause for the outliers of the original Reduce-this is likely caused by heterogeneity of disk I/O performance within the cluster.</p><p>The variation in Reduce execution time for Genetic Algorithm is likely due to the involved computation being more complex. We observe high variance in the duration for both Map and Reduce function execution for the original tasks. This effect is also observed in the barrier-less setting, where the end times of the Reduce tasks in Genetic Algorithm have more variance than WordCount.</p><p>Thus, we conclude that for the Genetic Algorithm and WordCount applications, any outliers arising from our setting are eliminated by using a barrier-less approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Improvement with number of Reducers</head><p>In order to understand the sensitivity to the number of Reducers, we varied the Reducer count in Fig. <ref type="figure" target="#fig_4">5</ref> and observed the improvement as the count rose from 30 to 70 (which is 10 more than the number of available CPU cores for Reducers). This illustrates the effect of applications or systems with an irregular amount of Reducers, for example if nodes fail in the middle of computation.</p><p>Our results show that although job completion time decreased as the compute utilization increased (as the number of Reducers reached the compute capacity of 60), our improvement over the barrier version decreased somewhat. When the number of Reducers surpassed the amount of compute resources available (70 Reducers running on 60 cores), the job completion time increased, but our improvement also increased.</p><p>The reason for our scheme having a larger improvement when the system is underutilized (for example when there are only 30 Reducers), is that each Reducer has to shuffle respectively more data than in the fully utilized case. This means that the shuffle time is larger, and the mapper slack, during which the barrier-less version can perform meaningful work, is also larger. As the utilization becomes more full, the mapper slack decreases, limiting, but not removing, the benefit gained from breaking the barrier. On the other hand, once the system becomes over-saturated (the 70 Reducer case), a new round of Reducers is needed, which must themselves undergo a shuffle stage, once again increasing the mapper slack. In other words, the benefit of switching to a barrier-less framework is closely tied to the amount of mapper slack in the runtime.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Cluster heterogeneity</head><p>We go a step further and induce more heterogeneity, by placing multiple Mappers and Reducers on a designated overloaded machine. This setup emulates heterogeneity caused by different loads on cluster machines, e.g. which is typical in a virtualized data center <ref type="bibr" target="#b26">[28]</ref>.</p><p>In these experiments, we look at the effect of cluster heterogeneity on barrier-less MapReduce and compare it to original MapReduce. Some heterogeneity is already present in our cluster despite it being composed of machines with originally identical specifications. We go a step further and induce more heterogeneity, by overloading machines with more Mappers and Reducers. Our 16 machine cluster has 1 master and 15 workers. We vary the number of worker machines n from 15 to 13, with the following configuration: n -1 machines each have 4 map and 4 reduce slots while the nth (designated) machine has (16n) * 4 map and (16n) * 4 reduce slots. This causes the nth machine to be overloaded.</p><p>Figure <ref type="figure" target="#fig_7">10</ref> shows the execution time of WordCount with 15, 14, and 13 worker machines, i.e., when the designated machine is configured with 4, 8, and 12 Mappers and an equal number of Reducers respectively. This mimics, for example, a virtualized cluster where heterogeneity can be Fig. <ref type="figure" target="#fig_0">11</ref> Lanes plot of WordCount processing 7.5 GB on 13 heterogeneous machines caused by many virtual machines being run on a single machine. When the input dataset processed is 7.5 GB, the entire intermediate data is kept in memory for both barrier-less and original MapReduce. We see a large difference (54%) in execution time in the case of the 13 worker machines. We observe that increasing the heterogeneity from 14 to 13 worker machines leads to 58% worse performance for original MapReduce, but only 27% worse performance for barrier-less MapReduce.</p><p>In order to understand the cause for this improvement, Fig. <ref type="figure" target="#fig_0">11</ref> shows the start and duration of each task when Word-Count is run on 13 worker machines. In this configuration, one of the machines is configured with 12 Mappers and 12 Reducers, while the other 12 machines are configured with 4 Mappers and 4 Reducers. We observe that the duration of the map tasks on the overloaded machines is longer in original MapReduce. This is because the overloaded machines have too little available memory per task, and thus the Mappers must buffer their records on disk. These Map outliers, coupled with the barrier, force the Reduce function execution to be delayed. In contrast, barrier-less Mappers are not required to buffer all records because they transfer records immediately. Thus, disk I/O time is saved resulting in the overloaded Map outliers finishing earlier than their original counterparts. Also, because there is no barrier, the Reduce function execution is interleaved with the network transfer, resulting in the combined Shuffle and Reduce finishing shortly after the final outlier Mapper. As a result of the combination of these factors, we observe that the entire job completes in our barrier-less MapReduce implementation before even the Map stage is completed in original MapReduce.</p><p>When the input dataset size is increased to 55 GB, the amount of intermediate data processed per Reducer increases above the available memory limit and the disk spill and merge technique is used in the barrier-less version, while the original version uses an external MergeSort. In Fig. <ref type="figure" target="#fig_1">12</ref> WordCount with different memory management techniques with increasing number of Reducers this case, we observe that the difference (27%) is smaller when the disk spill and merge technique is used instead of keeping the intermediate results entirely in memory, because disk I/O is required.</p><p>Thus, we conclude that our barrier-less implementation reduces variation in task completion times and thus helps in reducing the performance degradation due to some types of heterogeneity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Memory management techniques</head><p>We compared the different memory management techniques described in Sect. 5. Figure <ref type="figure" target="#fig_1">12</ref> shows a plot of the job completion times for WordCount with and without a barrier, while varying the number of Reducers. The disk spill and merge scheme performed slightly worse than storing the partial results in memory. However, as the number of Reducers was decreased below 25, the in-memory technique resulted in an out of memory exception and the job was killed. The spill and merge technique continued to perform better than  the original MapReduce. BerkeleyDB on the other hand, performed poorly on the WordCount. Even though we could observe about 30,000 inserts per second into the database, this was not enough throughput to keep up with the millions of small records handled at each Reducer. This result shows that off-the-shelf key/value stores may not be a suitable option for MapReduce workloads.</p><p>Figure <ref type="figure" target="#fig_8">13</ref> shows a comparison with increasing dataset size. It can be seen that as the dataset increases, both the disk spill and merge, and the in-memory barrier-less versions, outperformed the original version. Again, the BerkeleyDB key/value store can not keep up with the high frequency of record accesses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6">Programmer effort</head><p>Table <ref type="table" target="#tab_3">2</ref> summarizes the programmer effort required, in terms of lines of code, to convert the MapReduce applications into their barrier-less counterparts. The code for sorting in the original case is very short due to the use of the Identity Mapper and the Identity Reducer, since the framework does the job of sorting. However, we had to add more functionality in the Reduce function of the barrier-less ver-sion. WordCount, k-Nearest Neighbors and Post Processing required small changes to compute and update the partial results. For Black-Scholes and the genetic algorithm, the only change required was that a flag for barrier-less execution be turned on.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related work</head><p>MapReduce has been widely used for processing large data because of its simple model that is applicable to "embarrassingly parallel" problems-such as log processing. Current research looks to push MapReduce by using it to solve harder problems. These include machine learning <ref type="bibr" target="#b4">[5]</ref>, statistical machine translation <ref type="bibr" target="#b3">[4]</ref><ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref><ref type="bibr" target="#b8">[9]</ref>, optimization <ref type="bibr" target="#b22">[24]</ref>, finance <ref type="bibr" target="#b2">[3]</ref>, and similarity scoring <ref type="bibr" target="#b9">[10]</ref>. MapReduce is a logical choice because it allows the problems to be solved on a loosely coupled set of machines, with less effort than producing custom parallel processing code. However, MapReduce does not always give the most efficient parallel processing implementation. In this paper, we looked at the stage barrier in MapReduce and showed how breaking it may result in making MapReduce more efficient for general MapReduce problems.</p><p>We are not the first to investigate the transition between the Map and Reduce stages. In MapReduce Online <ref type="bibr" target="#b5">[6]</ref>, data is pushed by Mappers and merge-sorted by Reducers at a finer granularity. This has two main advantages. First, this effectively overlaps (pipelines) the stages, resulting in faster runtime. Our work can similarly benefit from such an optimization. Second, this allows early partial results (snapshots) to be computed to approximate the correct result. Each snapshot must be computed independently of others and furthermore, previous snapshots do not help in computing subsequent results. In contrast, by storing partial results we are able to decrease the time needed to compute the actual final result.</p><p>Similar techniques like incremental updates of materialized views <ref type="bibr" target="#b13">[14]</ref>, hash-based joins <ref type="bibr" target="#b7">[8]</ref>, etc. have been explored by the parallel database community. However, such techniques can only be applied to a select group of operators, while our technique can be applied to many arbitrary MapReduce programs. Also, MapReduce programs benefit from scalability and fault tolerance at the cost of some performance overhead as compared to parallel DBs. There is a considerable amount of debate on MapReduce vs parallel databases <ref type="bibr" target="#b21">[22]</ref>. Pavlo et. al <ref type="bibr" target="#b19">[20]</ref> perform a comparison of MapReduce and parallel databases for large scale data analysis and demonstrate the overhead of materializing the intermediate data in MapReduce.</p><p>Improving the efficiency of MapReduce has been of recent interest to the systems community. Much of the research presented has required changes to the MapReduce API <ref type="bibr" target="#b25">[27]</ref>. Other work has aimed to be completely transparent to the programmer <ref type="bibr" target="#b26">[28]</ref>. Our work is a combination of both categories. We have preserved the baseline MapReduce API, while empowering the programmer to improve performance by relaxing assumptions in the Reduce function.</p><p>Dryad <ref type="bibr" target="#b15">[16]</ref> is a distributed platform that has been developed at Microsoft to provide large-scale, parallel, faulttolerant execution of processing tasks. The techniques in this paper can likely be applied to break the barrier in a similar way to the MapReduce barrier. Because Dryad is a closed system, we were not able to make modifications to apply these techniques.</p><p>There has been recent interest in dealing with outliers in MapReduce clusters. The Longest Approximate Time to End (LATE) scheduling algorithm <ref type="bibr" target="#b26">[28]</ref> was designed to provide better performance in the face of outliers. The algorithm shows improved performance in virtualized, heterogeneous clusters. The Mantri system <ref type="bibr" target="#b1">[2]</ref> is also designed to target MapReduce outliers to improve performance. The system uses real-time progress reports to detect outliers early in their lifetime, and takes corrective action depending on the cause of the outlier and the available resources in the cluster. While not the main goal, our barrier-less implementation is shown to reduce outliers and their effect on job completion time, in homogeneous conditions and under some types of heterogeneity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>This paper demonstrated that general purpose MapReduce frameworks without a barrier are feasible, and they can result in significant performance benefits. By intelligently managing memory and identifying which forms of Reduce functions see the most benefit, our experiments with Hadoop demonstrate speedups of up to 87% for well-suited applications, and an average of 25% for more typical applications. This is because our barrier-less MapReduce framework allows the interleaving of network I/O and computation while keeping disk usage to a minimum. At the same time, our approach preserves the fault tolerance of the original MapReduce model, and has similar ease of programming. Our work opens up new avenues. Memoization, an optimization similar to DryadInc <ref type="bibr" target="#b20">[21]</ref> becomes feasible in the barrier-less model.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1</head><label>1</label><figDesc>Fig. 1 Progress of MapReduce which performs a word count on a 3 GB Wikipedia data set</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2</head><label>2</label><figDesc>Fig. 2 WordCount over a 16 GB dataset with 10 Reducers. Having the complete TreeMap in memory leads to out of memory error. Spill and merge uses less memory and the job completes successfully. Partial results threshold is 240 MB</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3</head><label>3</label><figDesc>Fig. 3 Comparison of different benchmarks: Sort, WordCount (WC), k-Nearest Neighbor (KNN) and Post Processing (PP) with and without barrier, with increasing dataset sizes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4</head><label>4</label><figDesc>Fig.<ref type="bibr" target="#b3">4</ref> Genetic Algorithms (GA) and Black Scholes (BS) with and without barrier, varying the number of Mappers</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5</head><label>5</label><figDesc>Fig.<ref type="bibr" target="#b4">5</ref> Genetic Algorithms with and without barrier, varying the number of reducers</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6</head><label>6</label><figDesc>Fig. 6 CDF of Reduce task duration</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 7 Fig. 8 Fig. 9</head><label>789</label><figDesc>Fig. 7 CDF of end times of Reduce tasks</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 10</head><label>10</label><figDesc>Fig.<ref type="bibr" target="#b9">10</ref> WordCount performance on heterogeneous machines processing 7.5 GB (left) and 55 GB input dataset (right)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 13</head><label>13</label><figDesc>Fig.<ref type="bibr" target="#b12">13</ref> WordCount with different memory management techniques with increasing dataset size</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1</head><label>1</label><figDesc>Sort and Memory requirements of MapReduce Jobs. Records and keys denote the total number of records and keys (executed at a single Reducer)</figDesc><table><row><cell>Application</cell><cell>Key sort</cell><cell>Size of</cell></row><row><cell>(Reduce Classification)</cell><cell>required</cell><cell>partial results</cell></row><row><cell>Distributed Grep</cell><cell>No</cell><cell>O(1)</cell></row><row><cell>(Identity)</cell><cell></cell><cell></cell></row><row><cell>Sort</cell><cell>Yes</cell><cell>O(records)</cell></row><row><cell>(Sorting)</cell><cell></cell><cell></cell></row><row><cell>Word Count</cell><cell>No</cell><cell>O(keys)</cell></row><row><cell>(Aggregation)</cell><cell></cell><cell></cell></row><row><cell>k-Nearest Neighbors</cell><cell>No</cell><cell>O(k  *  keys)</cell></row><row><cell>(Selection)</cell><cell></cell><cell></cell></row><row><cell>Last.fm unique listens</cell><cell>No</cell><cell>O(records)</cell></row><row><cell>(Post-reduction processing)</cell><cell></cell><cell></cell></row><row><cell>Genetic Algorithms</cell><cell>No</cell><cell>O(window_size)</cell></row><row><cell>(Cross-key operations)</cell><cell></cell><cell></cell></row><row><cell>Black Scholes (Single</cell><cell>No</cell><cell>O(1)</cell></row><row><cell>Reducer Aggregation)</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Algorithm 1 Original WordCount function map(key, value):</head><label></label><figDesc></figDesc><table><row><cell>// key: document name</cell></row><row><cell>// value: document contents</cell></row><row><cell>for each word in value do</cell></row><row><cell>Emit intermediate (word, 1)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>end for function reduce(key, values, context):</head><label></label><figDesc></figDesc><table><row><cell>// key: a word</cell></row><row><cell>// values: a list of counts</cell></row><row><cell>result ← 0</cell></row><row><cell>for each v in values do</cell></row><row><cell>result ← result + v</cell></row><row><cell>end for</cell></row><row><cell>Write (key, result) to context</cell></row><row><cell>function run():</cell></row><row><cell>while context has more keys do</cell></row><row><cell>key ← current key from context</cell></row><row><cell>values ← current values from context</cell></row><row><cell>reduce(key, values, context)</cell></row><row><cell>end while</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Algorithm 2</head><label>2</label><figDesc>Barrier-less WordCount Changes made to Algorithm 1 are boldfaced</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>and italicized. function reduce(key, values, context):</head><label></label><figDesc></figDesc><table><row><cell>// key: a word</cell></row><row><cell>// values: a list of counts</cell></row><row><cell>result ← 0</cell></row><row><cell>for each v in values do</cell></row><row><cell>result ← result + v</cell></row><row><cell>end for</cell></row><row><cell>Insert (key, result) in the TreeMap</cell></row><row><cell>function run():</cell></row><row><cell>Create a new TreeMap</cell></row><row><cell>while context has more keys do</cell></row><row><cell>key ← current key from context</cell></row><row><cell>values ← current values from context</cell></row><row><cell>if TreeMap does not contain key then</cell></row><row><cell>Insert (key, 0) in the TreeMap</cell></row><row><cell>end if</cell></row><row><cell>reduce(key, values, context)</cell></row><row><cell>end while</cell></row><row><cell>//</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>After all the reduce invocations are done for each (key, value) in TreeMap do Write (key, value) to context end for</head><label></label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 2</head><label>2</label><figDesc>Programmer effort, in terms of LOC required to convert MapReduce applications to their barrier-less versions</figDesc><table><row><cell>Application</cell><cell cols="2">Lines of code (LOC)</cell><cell></cell></row><row><cell></cell><cell>Original</cell><cell>Barrier-less</cell><cell>% increase</cell></row><row><cell>Sort</cell><cell>28</cell><cell>95</cell><cell>240%</cell></row><row><cell>WordCount</cell><cell>73</cell><cell>88</cell><cell>20%</cell></row><row><cell>k-Nearest Neighbors</cell><cell>195</cell><cell>208</cell><cell>10%</cell></row><row><cell>Post Processing</cell><cell>73</cell><cell>91</cell><cell>25%</cell></row><row><cell>Genetic Algorithm</cell><cell>532</cell><cell>533</cell><cell>0%</cell></row><row><cell>Black-Scholes</cell><cell>251</cell><cell>252</cell><cell>0%</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements This material is based on research sponsored in part, by the Air Force Research Laboratory and the Air Force Office of Scientific Research under agreement number FA8750-11-2-0084, and National Science Foundation Grants CCF #0964471 and IIS #0841765.</p><p>We would like to thank the anonymous reviewers for their valuable feedback that has helped improve the quality of the paper.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<ptr target="http://hadoop.apache.org" />
		<title level="m">Apache hadoop</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Reining in the outliers in map-reduce clusters using mantri</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ananthanarayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kandula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Greenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Saha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Harris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th USENIX Conference on Operating Systems Design and Implementation, OSDI&apos;10</title>
		<meeting>the 9th USENIX Conference on Operating Systems Design and Implementation, OSDI&apos;10<address><addrLine>Berkeley</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The pricing of options and corporate liabilities</title>
		<author>
			<persName><forename type="first">F</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Scholes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Polit. Econ</title>
		<imprint>
			<biblScope unit="volume">81</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="637" to="654" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Large language models in machine translation</title>
		<author>
			<persName><forename type="first">T</forename><surname>Brants</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Popat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Och</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning (EMNLP-CoNLL)</title>
		<meeting>of the Joint Conference on Empirical Methods in Natural Language essing and Computational Natural Language Learning (EMNLP-CoNLL)</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="858" to="867" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Map-reduce for machine learning on multicore</title>
		<author>
			<persName><forename type="first">C</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Bradski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Olukotun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems (NIPS)</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="281" to="288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Online aggregation and continuous query support in mapreduce</title>
		<author>
			<persName><forename type="first">T</forename><surname>Condie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Conway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Alvaro</surname></persName>
		</author>
		<author>
			<persName><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Elmeleegy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sears</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NSDI&apos;10: Seventh USENIX Symposium on Networked Systems Design and Implementation. USENIX Association</title>
		<meeting><address><addrLine>Berkeley</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Mapreduce: Simplified data processing on large clusters</title>
		<author>
			<persName><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ghemawat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the USENIX Symposium on Operating Systems Design and Implementation (OSDI)</title>
		<meeting>of the USENIX Symposium on Operating Systems Design and Implementation (OSDI)</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="137" to="149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Multiprocessor hash-based join algorithms</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dewitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gerber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of VLDB Conference</title>
		<meeting>of VLDB Conference<address><addrLine>Princeton</addrLine></address></meeting>
		<imprint>
			<publisher>Citeseer</publisher>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Fast, easy, and cheap: construction of statistical machine translation models with mapreduce</title>
		<author>
			<persName><forename type="first">C</forename><surname>Dyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cordova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mont</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Third Workshop on Statistical Machine Translation (StatMT)</title>
		<meeting>of the Third Workshop on Statistical Machine Translation (StatMT)<address><addrLine>Stroudsburg</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="199" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Pairwise document similarity in large collections with mapreduce</title>
		<author>
			<persName><forename type="first">T</forename><surname>Elsayed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Oard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Annual Meeting of the Association for Computational Linguistics on Human Language Technologies (HLT)</title>
		<meeting>of the Annual Meeting of the Association for Computational Linguistics on Human Language Technologies (HLT)<address><addrLine>Stroudsburg</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="265" to="268" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Mithra: multiple data independent tasks on a heterogeneous resource architecture</title>
		<author>
			<persName><forename type="first">R</forename><surname>Farivar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Verma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Campbell</surname></persName>
		</author>
		<idno type="DOI">10.1109/CLUSTR.2009.5289201</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE International Conference on Cluster Computing and Workshops (CLUSTER)</title>
		<meeting>of IEEE International Conference on Cluster Computing and Workshops (CLUSTER)</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Discriminatory analysis, nonparametric discrimination: Consistency properties</title>
		<author>
			<persName><forename type="first">E</forename><surname>Fix</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hodges</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">USAF School of Aviation Medicine</title>
		<imprint>
			<date type="published" when="1951">1951</date>
			<pubPlace>Randolph Field, Texas</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech. rep.</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A dichromatic framework for balanced trees</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">J</forename><surname>Guibas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sedgewick</surname></persName>
		</author>
		<idno type="DOI">10.1109/SFCS.1978.3</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of Symposium on Foundations of Computer Science</title>
		<meeting>of Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1978">1978</date>
			<biblScope unit="page" from="8" to="21" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Maintenance of materialized views: problems, techniques, and applications</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Mumick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bull. Tech. Commun</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<ptr target="http://cloud.cs.illinois.edu/" />
		<title level="m">Illinois Cloud Computing Testbed</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Dryad: distributed data-parallel programs from sequential building blocks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Isard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Budiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Birrell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fetterly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of European Conference on Computer Systems (Eu-roSys)</title>
		<meeting>of European Conference on Computer Systems (Eu-roSys)</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="59" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<ptr target="http://www.mongodb.org" />
		<title level="m">Mongodb</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Berkeley db</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Olson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Bostic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Seltzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the USENIX Annual Technical Conference (ATEC)</title>
		<meeting>of the USENIX Annual Technical Conference (ATEC)<address><addrLine>Berkeley</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page">43</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">O</forename><surname>O'malley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Murthy</surname></persName>
		</author>
		<ptr target="http://sortbenchmark.org/Yahoo2009.pdf" />
		<title level="m">Winning a 60 second dash with a yellow elephant</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A comparison of approaches to largescale data analysis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pavlo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Paulson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rasin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Dewitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Madden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<ptr target="http://database.cs.brown.edu/sigmod09/benchmarks-sigmod09.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proc. of the ACM SIGMOD International Conference</title>
		<meeting>of the ACM SIGMOD International Conference</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">DryadInc: Reusing work in large-scale computations</title>
		<author>
			<persName><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Budiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Isard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Workshop on Hot Topics in Cloud Computing</title>
		<meeting>of Workshop on Hot Topics in Cloud Computing</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">MapReduce and parallel DBMSs: friends or foes?</title>
		<author>
			<persName><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dewitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Madden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Paulson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pavlo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rasin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="64" to="71" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Scaling genetic algorithms using mapreduce</title>
		<author>
			<persName><forename type="first">A</forename><surname>Verma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Llora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Campbell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of International Conference on Intelligent Systems Design and Applications</title>
		<meeting>of International Conference on Intelligent Systems Design and Applications</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Breaking the MapReduce stage barrier</title>
		<author>
			<persName><forename type="first">A</forename><surname>Verma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Zea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Campbell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE International Conference on Cluster Computing (CLUSTER)</title>
		<meeting>of IEEE International Conference on Cluster Computing (CLUSTER)</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="235" to="244" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Hadoop: The Definitive Guide</title>
		<author>
			<persName><forename type="first">T</forename><surname>White</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Reilly Media, Sebastopol</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Map-reduce-merge: simplified relational data processing on large clusters</title>
		<author>
			<persName><forename type="first">H</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dasdan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hsiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Parker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 2007 ACM SIGMOD International Conf. on Management of data</title>
		<meeting>of the 2007 ACM SIGMOD International Conf. on Management of data</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Improving mapreduce performance in heterogeneous environments</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zaharia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Konwinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Joseph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the USENIX Symposium on Operating Systems Design and Implementation (OSDI</title>
		<meeting>of the USENIX Symposium on Operating Systems Design and Implementation (OSDI</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
