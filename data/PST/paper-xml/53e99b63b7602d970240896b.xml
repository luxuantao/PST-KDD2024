<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Theory and Practice of First-Class Prompts</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">Indiana University</orgName>
								<address>
									<addrLine>Lindley Hall 101 Bloomington</addrLine>
									<postCode>47405</postCode>
									<region>IN</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">The Theory and Practice of First-Class Prompts</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">CE24509388839A406A4A8082754CAA52</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:59+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The modified X,-C-calculus</head><p>The term set A7 of the original X,-C-calculus is defined inductively over a set of algebraic constants, Con&amp; and a set of variables, Vars:</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>An analysis of the X,-C-calculus and its problematic relationship to operational equivalence leads to a new control facility: the promp&amp; application.</p><p>With the introduction of promptapplications, the control calculus becomes a traditional calculus all of whose equations imply operational equivalence. In addition, prompt-applications enhance the expressiveness and efficiency of the language. We illustrate the latter claim with examples from such distinct areas as systems programming and tree processing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">A Problem of the X,-Ccalculus</head><p>The X,-C-calculus [2, 43 is a conservative extension of <ref type="bibr">Plotkin's &amp;-calculus [ll]</ref> for reasoning about imperative control operations in call-by-value languages. The theory satisfies modified versions of the Church-Rosser and the Curry-Feys Standardization Theorem. Furthermore, the standardization procedure yields the same answers for programs as the evaluation function of an ap:propriate abstract machine. However, the calculus also has a major deficiency: equality in the calculus does no2 imply operational equality on the machine. That is, two expressions that are equal "This work was partly supported by an IBM Fellowship and Dan FEedman's NSF grant (DCR 85 01277). Author's cursent &amp;dress:</p><p>Rice University, Herrman Brown Hall, Houston, TX   77251-1892   Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the. ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specfic permission.</p><p>@ 1988 ACM-O-89791-252-7/88/0001/0180 $1.50 180 in the calculus do not necessarily behave equivalently in all program contexts. The problem can be fixed with a meta-theorem that distinguishes theorems in the theory as operational equalities, yet, this is not a desirable situation.</p><p>In this paper, we present a different and more promising solution.</p><p>It is baaed on a new linguistic facility for constraining the extent of control operations: the prompt-application.</p><p>The introduction of prompt-applications transforms the control calculus into a truly traditional calculus, an.d, in addition, prompt-applications are a practical tool for a broad variety of programming paradigms. We illustrate the latter claim with examples from such distinct areas as systems programming and tree processing.</p><p>In the next section, we formalize the original X,-C-calculus and the concept of a first-class prompt facility.</p><p>We then show that the extended calculus is consistent and that there is a standard reduction function.</p><p>Based on this, we define an operational semantics and show that theorems in the calculus directly imply operational equivalence. The third section contains an abstract stack-machine for the extended language and a brief discussion of the implementation cost. Section 4 is a collection of programming examples, which illustrates the expressive power of prompt-applications.</p><p>The fifth section is an overview of related work. In the conclusion, we analyze the contribution of language calculi to the systematic analysis of programming :languages. sions have their original semantics: constants stand for basic and functional constants from some kind of algebraic domain, variables are placeholders, Aabstractions represent call-by-value procedures, and combinations denote function applications.</p><p>As usual, the variable 3: in the abstraction Xt.M is called the bound variable; a variable that is not bound by some X is free. An expression with no free variables is called closed. Programs in this language are closed expressions. Like <ref type="bibr">Barendregt [1:26]</ref>, we identify terms that are identical modulo bound variables, and we assume that free and bound variables cannot interfere with each other. The substituion of a free variable 2: by N in a term M is denoted by M[z := N].</p><p>The new expression type is called 3-application,' its subterm is an 3-argument.</p><p>An 3-application transforms the current control state into a functional abstr&amp;ion, which we call continuation.2</p><p>Next, the 3-application applies its argument to this continuation, thus providing the 3-argument with total power over the rest of the computation.</p><p>In particular, if the corresponding actions are to be performed at all, the 3-argument must invoke this continuation.</p><p>The equational theory is specified with a set of term relations for the evaluation of expressions. Constants, variables, and X-abstractions require no further evaluation and are appropriately referred to as values. For the evaluation of an application of a function constant to a basic constant, we assume the existence of an interpretation 6 on the set of constants:</p><p>S: FuncConst x BasicConst -w Closed-A-Values.</p><p>The b-reduction for constant applications is:</p><formula xml:id="formula_0">6: fa - b(f, a).</formula><p>The evaluation of an application of a X-abstraction to a value is determined by the ,&amp;value relation:</p><formula xml:id="formula_1">p: (A;c.M)V - M[z: := V] provided V is a value.</formula><p>That is, an application whose first part is an abstraction and whose second part is a value is reduced to a term that is like the function body with all occurrences of the abstracted variable replaced by the value.</p><p>The meaning of 3-applications is determined by two reductions and a special computation relation. The reductions are:</p><formula xml:id="formula_2">3L: (3M)N - 3(Ak.A!r(Am.k(nzlv))),</formula><p>'3-is a generalized version of Iswim's J [s], Reynolds's escape <ref type="bibr" target="#b12">[13]</ref>, and Scheme's <ref type="bibr" target="#b11">[12]</ref> call/cc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2WARNING:</head><p>This usage is inconsistent with Schemeterminology.</p><p>3Jr: V(3'M) -3(Ak.M(Am.k(Vm)))</p><p>provided V is a value.</p><p>The purpose of these reductions is to push an 3-application to the root of a term and to encode the context of the 3-application as an abstraction. Once the 3-application has reached the root, the computation relation 3'M D kf(h.z)</p><p>eliminates the 3-application by applying the 3argument to the identity function, a representation of the empty context. The computation rule is denoted with D instead of the customary -because it can only be applied to the root: an unrestricted use would make the calculus inconsistent.</p><p>The nature of 3-applications and continuations is best illustrated with examples. Consider the program (1+(3(Xd.O))).</p><p>It evaluates to 0 after the 3-application erases the call to l+: The problem of this calculus is the separation of computation and reduction relations. Since computation relations can only be applied at the root of a term, an equation that is based on the compulalion relation does not imply operational equivalence. More precisely, even if two terms are computationally equivalent, there are generally program contexts that can distinguish the two expressions. A typical example is the pair of terms 3(Ad.O) and 0. Although equivalent according to the computation relation, they behave differently in practically all contexts.</p><p>Whereas the former aborts a computation when evaluated, the second one simply evaluates to 0.</p><p>A possible and obvious fix is the introduction of a unique top-level marker # for identifying the root of a program. Then the computation relation can be replaced by a reduction relation:</p><formula xml:id="formula_3">#3: (# (3M)) - (# (M(Xx.x))).</formula><p>However, this solution pushes the semantic division into the language syntax and does not eliminate the complications of its predecessor: equations for #contained terms cannot predict the behavior of these terms in arbitratry contexts. A true solution must go further: #-applications must become a new kind of first-class construct that can occur anywhere in the program text.</p><p>The term language AFF# for the modified calculus is a minor extension of A3:</p><p>L ::= a: 1 Xz.M 1 MN I3M 1 #M.</p><p>Programs are now identified as the set of closed #applications. Formally, the X,-C-calculus is defined as the congruence relation =c; informally, we refer to the entire set of relations as X,-C-calculus.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Remark</head><p>Remark.</p><p>There are normal forms that, are not values and values that are not normal forms:, e.g., T(Az.z) and ~y.(~z.~x)(Xz.zz). End</p><p>Unlike its predecessor, this calculus has the ordinary Church-Rosser Property: <ref type="figure">, -c</ref> satisfies the diamond property. All arguments must be extended to cover the two new reductions, #F and #V. Informally, we can argue along the following lines. Suppose the standard reduction sequence from #P to Q is needed. This sequence can be obtained with the old standardization procedure by replacing all computation steps with #p-reductions.</p><formula xml:id="formula_4">Theorem (Church-Rosser for X,-C). The (mod- ified) X,-C-calculus is Church-Rosser, i.e.</formula><p>If Q is of the form #&amp;I, then we have obtained the required standard reduction sequence. Otherwise Q is a value. In this case, the tail of the reduction sequence is a transformation of a value inside of a #-application.</p><p>By using a #"-step as early as possible, we standardize the reduction sequence. All other standardization steps stay the same. 0 The Standardization Theorem implies that a program has a value if and only if we can reduce it to a value by always reducing the leftmost-outermost redex:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary (Standard evaluation).</head><p>If M has a value, i.e., there is a value Usuch that A,-C I-M = U, then the transitive-refiexive closure of the standard reduction function relates M to a value V:</p><formula xml:id="formula_5">MI-+;, V.</formula><p>In other words, the standard reduction function associates a unique value with a program and can thus be construed as an abstract machine semantics. Based on this, we define the following evaluation function: Definition.</p><p>(The eval,-function)</p><p>The (partial) evaluation function eval, maps the program M to a value v:</p><p>eval</p><formula xml:id="formula_6">, (M) = V if M-i, V.</formula><p>This evaluation function is equivalent to a programmer's perception of an interpreter.</p><p>It characterizes the observable behavior of programs and thus determines an operational equivalence relation on programs and terms. The formalization of this equivalence relation follows <ref type="bibr">Plotkin's [ll]</ref> corresponding work on the X,-calculus.</p><p>Operational equivalence equates two terms if one can replace the other in any arbitrary program context without affecting the final value of the program. In order to make this definition effective, we restrict our attention to basic constants as answers. This is also justified by the fact that a function is generally considered as an intermediate result for subsequent computations.</p><p>Putting this together, we get: Operational equivalence is indeed omni-present in the work of a programmer. For any kind of program transformation, e.g., for making a program shorter, faster, better Hooking, etc., the operational semantics of the program must be preserved: the two versions must be operationally equivalent.</p><p>Because of this, it is necessary to have an equational theory for reasoning systematically about operational equivalences. The modified X,-C-calculus is such a theory. Theorems in the calculus imply operational equivalence for the terms according to the evaluation function: IfM = N is safe, M NC N.</p><p>Proof.</p><p>The proof is an adaptation of the corresponding proof for the old calculus <ref type="bibr">[2]</ref>. 0</p><p>It follows from this theorem that the XV-C-calculus can be consistently extended with safe equations. That is, safe equations can be added to the set of axioms of the X,-C-calculus.</p><p>When 'we rely on such additional axioms, we write A,-C""f" I-M = N, indicating that the enriched calculus proves the theorem on the right-hand side.</p><p>Thus far, we have seen that prompt-applications simplify the control calculus and establish the desired relationship to the operational semantics. We henceforth refer to the modified calculus as the AU-Ccalculus. The next challenge is to demonstrate that prompt-applications can easily be implemented and that they constitute a useful progrannming concept.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">An Abstract</head><p>Machine Semant its</p><p>The operational semantics of A3 is based on the CEK-machine.</p><p>The CEK-machine is a state transition system. It resembles Landin's SECD-machine <ref type="bibr" target="#b7">[9]</ref>, but is also close in spirit to denotational semantics. An extension to AF# is straightforward.</p><p>The CEK-states are triples of control strings, environments, and control structures. A control string is either a hF#-term or the unique symbol $. The environment component is a finite map that assigns values to the free variables of the control string. Finally, the control structure is a stack-based encoding of the rest of the computation.</p><p>The initial configuration for the evaluation of a program M is (M,Q, (stop)).</p><p>A machine yields the value U if it stops in the terminal state ($, 0, ((stop) ret (V, p))) and U results from (V, p) by recursively replacing all free variables in V by their environment value in p.</p><p>The transition function for the X-calculus-subset is straightforward.</p><p>The first three transition rules Teturn syntactic values as semantic values to the continuation: b,P, 4 5% (L 0, (K ret Q))</p><p>(1)</p><p>(2, f-3 f4 CEK (L 0, (K ret P(Z)&gt;&gt; (2) (Xz.M, p, K) 25 (L0, (K ret &amp;.M, p))&gt; (3)</p><p>A constant is returned without any further ado, a variable's value is looked up in the current environment, and a &amp;abstraction defines a closure, i.e., a pairing of the abstraction with the current environment.</p><p>When the CEK-transition function encounters a combination, it evaluates the two components from left to right. To this end, the continuation is extended with the argument part and the current environment:</p><p>(MN, P, 4 c* (M, P, (K arg N ~1). ( <ref type="formula">4</ref>)</p><p>The evaluation then continues with the function part.</p><p>Once the function part is reduced to a semantic value, the machine resumes the evaluation of the argument by exchanging the control-string and environment registers with the top of the control stack: (L 0, ((6 =g iv P) ret F)) 9</p><p>W, P, (Kfun F)).</p><p>(5) The last two rules for the X-calculus-subset explain the effect of an application.</p><p>If both parts are constants, the machine continues according to the Sfunction:</p><p>(t, 0, ((6 fun f) ret a&gt;) CFf (L 0, (K ret W, a)&gt;&gt;.</p><p>(6) Otherwise, if the function value is a closure, the evaluation continues with an evaluation of the abstraction body in an extended closure environment that maps the parameter to the argument value: (L0, ((6 fun b.M, P)&gt; ret V)) CEK (M,p[z := V], K). ( <ref type="formula">7</ref>) Upon encountering a #-application, the CEKmachine must evaluate the #-argument and, furthermore, it must guarantee that the current control stack is intact upon completion of the sub-evaluation. This is achieved by marking the control stack:</p><p>(#M, P, 4 CE W, P, (K mark)). ( <ref type="formula">8</ref>)</p><p>All functions that manipulate the stack must respect this mark.</p><p>The mark is removed after the subevaluation terminates: (L0, ((K m=k) ret VI) cEK (I, 0, (rcret V)). ( <ref type="formula">9</ref>)</p><p>As described in Section 2, an 3-application transforms the control state into a value that corresponds to a functional abstraction. This transformation must account for stack markers since they determine the accessible part of the control stack. Our way to accomplish this is to modify the stack-copy (@) and the stack-erase (e) function such that they stop at a marker: @(stop) is undefined @("w3 NP) = (@K:argNp) @(/cfun F) = ($KfunF) @(IC mark) = (stop) and BWP) is undefined 0(K:arg Np) = 9~: e(6funF) = @K @(K:mark) = (remark).</p><p>Given this, we can define the transition rule for 3-applications by (3M, A 4 CEK (My, PIY := (P, @)I, e4, <ref type="bibr" target="#b8">(10)</ref> where y is a fresh variable. In other words, the 3argument is applied to a new kind of value-a pclosure-that represents the currently accessible control state. In order to make this definition work, we need a transition for specifying the result of applying a p-closure to a value. A function-like behavior for such applications is achieved by appending the p-closure to the current continuation: (L 0, ((Kffun (PI w)) ret V)) '3 (t, 0, (K @ 4 ret V)), ( <ref type="formula">11</ref>) where the stack-append operation (Q) is defined by tc@ (stop)</p><p>= )E K@((rc'argN p) = (rc:@darg N p) /c @ (n'fun V) = (/c @ dfua V). if (M, 0, (stop)) ?Z+ ($,0, ((stop) ret V)).</p><p>Unload is specified by: Unload((V, p)) E V[q := Unload(p(z:l))]</p><p>. . . for the free variables 21,. . . in V.</p><p>The correctneris of the machine is captured in:</p><formula xml:id="formula_7">Theorem (Correspondence II).</formula><p>For all programs M E &amp;F# and basic values a E Consd</p><p>Proof.</p><p>The proof follows the original one: each machine component is incorporated into the control string component by a natural transformation.</p><p>The environment is eliminated in favor of substitutions, evaluation contexts replace the control structures. The correctness of each transformation can be shown by a comparison of the evaluation processes. 0</p><p>The CEK-machine can easily be translated into an efficient implementation for ordinary machines. The prompt-applic.ation poses no problem at all. It simply marks the control stack. When a value is returned and the top of the control stack is marked, this mark is eliminated.</p><p>The modifications to the stack-erasing and stackmoving opera.tions are more difficult to translate. Both must now recognize and acount for the mark as an artificial end of the stack. For a fast realization a search for this mark should be avoided. A possible solution is to lceep the addresses of the marks in a separate stack register. Then stack-erasing is equivalent to moving a pointer from the top of this mark-stack to a register, and the stack-move operation can be realized as a sin,gle move instruction on many l..,chines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Programming with Prompt-Applications</head><p>As we have seen in the preceding two sections, prompt-applications totally constrain the extent of control actions.</p><p>Hence, they are applicable when a program must restrict the behavior of subcomputations.</p><p>Such situations frequently occur in large systems and interactive language implementations. Beyond this, the new construct is helpful in situations where a part of the continuation must be eliminated or saved for later use. In the following three subsections we illustrate these theoretical arguments with examples.</p><p>For the sub-sections, we assume that our toy language is embedded in a language like Scheme <ref type="bibr" target="#b11">[12]</ref> (or any other Algolesque language that supports the required constructs). This means in particular that the set of primitives includes such arithmetic and listprocessing functions as cons, car, +, 'I;, . . ., and that we use such syntactic forms as if, begin, and iterate with their usual semantics.3</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Constraining Control</head><p>In large systems it is often crucial that a service routine has a single exit point. If the underlying implementation language provides for unrestricted transfer of control, this is difficult to guarantee. Consider the specific case of a parameterized file-access handler that is responsible for closing files affter a programspecified read-or write-action has taken place. Assuming the existence of files and related operations like open, close, etc., the code for such a procedure is approximately X~f~,,,.(begin</p><formula xml:id="formula_8">(P fopen&gt; (cl- fopen)),</formula><p>where p is the program-specified procedure for reading and/or writing from file J Unfortunately, this code is insecure in a language with aborts, jumps, and other control operations. If p transfers control to the outside, the file f is left open and. another call to the file-access handler will cause an error.</p><p>Without a #-facility, the correct behavior is difficult to enforce. It requires a rather complicated unwind-protect structure for keeping track of domains that a program cannot leave without further action <ref type="bibr">[5,</ref><ref type="bibr">6]</ref>. In the extended language, the procedure call (pf) is simply embedded in a #-application: This guarantees that any imperative transfer of control by p can only erase the part of the continuation within the #-application: control is bound to return to the prompt. Thus, the file is proplerly closed upon termination of the program-specified code p and the file-access routine cannot be corrupted.</p><p>Another example that belongs in the same category is the implementation of an interactive interpreter or compiler. In such language environments, the object language relies on operations in the implementation language.</p><p>With prompt-applications, this can also work for control operations.</p><p>Take, for example, the operation error. If error were imported into an object language naively, an invocation of error in an obejct-program would terminate an evaluation loop like LOOP E (iterate L (exp (prompt-read ' -))</p><p>(if (eq? exp 'exit) 'good-bye (begin (evaluate exp base-environment)</p><formula xml:id="formula_9">(L (prompt-read ' -))))).</formula><p>This is, of course, undesirable, and therefore, controloperations must be treated differently from ordinary primitive operations.</p><p>The solution is again based on the introduction of a prompt-application.</p><p>The vulnerable application is (evaluate exp base-environment) and it must be pro tected from control-operations in exp: (if (eq? exp 'exit) 'good-bye (begin</p><p>The iterate-loop almost literally implements the informal description. If the tree is a leaf, it applies the enumeration procedure e to the leaf; otherwise, the recursive procedure is applied to every list element from left to right. This is accomplished with the listprocessing function for-each, which applies a function f (for effect only) to all elements of a list 1.</p><p>With a generic schema like the above, it is straightforward to realize a variety of different tree walks. For example, a pre-order print function is realized by PrintPreOrder g (Enumerate writeln).</p><p>Similarly, the routine can be used for generating an updating function that alters information in (selected) leafs:</p><p>Update g (Enumerate update).</p><p>A more interesting and challenging example is a tree walk that returns a leaf at a time and a function for enumerating the rest of the tree when appropriate.</p><p>In this program, the prompt-application guarantees that no matter what the object-program does, the evaluation-loop will safely continue, e.g., the invocation of error would abort the rest of the computation for exp but would also return to the evaluation-loop as desired. This is equally true for the import of such operations as halt, J <ref type="bibr" target="#b6">[8]</ref>, call/cc <ref type="bibr" target="#b11">[12]</ref>, or T.</p><p>(# (evaluate exp base-environment)) Such a procedure is useful in situations where the el-</p><formula xml:id="formula_10">(L (prompt-read ' -+))))).</formula><p>ements of a tree are successively fed into a different computation and/or the information in the rest of the tree may not be needed. The enumeration step now immediately returns a pair of results: the leaf and the function. On one hand, this additional function specifies what the application of the enumeration function would do to the same tree without the current leaf; on the other hand, it is precisely what the current invocation of the pre-order traversal procedure would have to do in order to complete its computation. Put differently, the desired second component of the enumeration step is the part of the continuation that describes the extent of the rest of the tree walk.</p><p>This new enumeration procedure is yet another instantiation of the above schema in a language with prompt-and F-applications.</p><p>If the procedure call is embedded in a prompt-application, the second component of the stream can be constructed with an Fapplication.</p><p>The first step is thus to embed the application of Enumerate in a prompt-application:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.2</head><p>Recursive Programming with Prompt-Applications Besides providing a means for constraining control, prompt-applications also enhance the expressive power of recursive programming languages. A typical example of a recursive task is a tree walk. Consider a multi-ary B*-tree, which is either a (n information) leaf or a list of multi-ary B*-trees. A pm-order traversal of such a tree can be specified by: if the tree is a leaf, enumerate it; otherwise, apply the algorithm to all elements in the list of subtrees from left to right.</p><p>Abstracting from the particular enumeration procedure at a leaf, the algorithm can be formalized as:  As discussed in the preceding section, the #-application only marks the control stack and does not require any further action. When the function must escape, the stack is only erased to the next marker. Hence, this second version of function-exits manipulates the control structure only when necessary and only to the extent necessary. It is practically equivalent to catch and throw in Common Lisp <ref type="bibr" target="#b14">[14]</ref> or exit-statements in other Algolesque languages.</p><p>Remark.</p><p>The correctness of this transformation can be verified with a simple derivation in the calculus. Prompt-applications are new for the theoretical investigations of programming language control facilities, but, to some extent, they are known in the realm of practical programming.</p><p>In principle, the prompt-application is a generalization of the Lispfacility errorset <ref type="bibr">[lo]</ref>. The function errorset evaluates an application until it successfully terminates or an error occurs. In the first case, errorset resumes its continuation with a list of the result, in the second case, it returns NIL. In the same manner, the prompt-application generalizes the catchconstruct in Common Lisp <ref type="bibr" target="#b14">[14]</ref>. Whereas a catch only intercepts one kind of abortive action, a promptapplication catches all. Clearly, a prompt-application can simulate a catch as a syntactic abbreviation with a simple message-passing protocol. The inverse is impossible.</p><p>The novelty of our approach with respect to practical work is to explore the presence of promptapplications in languages with full power over evaluation control.</p><p>In general, such languages do not provide the means for totally constraining control. Considering the examples in the preceding section, we believe that this is a design omission.</p><p>An exception to the above rule is the programming language GL <ref type="bibr">[7]</ref>. It contains both powerful imperative control operations and a construct with the capabilities of a prompt-application.</p><p>It has an operation CurCont for accessing the current continuation and two operations for invoking continuations: continue and fork. The operation continue replaces the current control stack with the one that is encoded by the invoked continuation, i.e., it realizes the invoking of continuations as in Iswim or Scheme. The operation fork evaluates a continuation like a subexpression, except that this sub-expression can not manipulate the control stack below the point of invocation. In other words, a fork-statement uses an implicit prompt-application for invoking a continuation.</p><p>Due to the implicit occurrence, it is difficult in GL to isolate the prompt-facility as a separate programming abstraction.</p><p>In X,-C, on the other hand, the programmer can exploit and reason about the concept of restricted control independently.</p><p>As demonstrated above with the tree-processing example, this may led to novel applications of prompt-and control-facilities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>In the preceding sections, we discussed a facility for constraining the extent of control operations. Its introduction was motivated by theoretical difficulties in the theory of control. The new facility solved the theoretical problem, and, even more important, it turned out to be a pract,ical programming tool. The development of the prompt-application again illustrated the practica1 relevance of the analysis of programming language calculi. Besides the present example with the non-theorem as its starting point, this analysis already led to the concept of F-applications through a simplification of the reductions and computations for call/cc <ref type="bibr">[3]</ref>. A further analysis of calculi for imperative operations will certainly yield more systematic insight into the istructure and design of programming languages.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>, 3(Ad.V) where d does not occur in the value V behaves like an abort operation that returns V. The conventional goto is a straightforward generalization of abort.If we replace the value V with an arbitrary expression M, the term S(Xd.M) first eliminates the current state and then installs M as the new one.When a continuation is applied, it acts like an ordinary function. It performs the encoded rest of the computation and, unless an 3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>. A program M in A3 corresponds to a program #M in AF#. End Since programs should reduce to proper values, we need an additional reduction relation for returning an evaluated #other words, # corresponds to a promp&amp;,and we therefore call (:#M) a prompt-application. With this modification, the X,-C-calculus becomes a calculus in the traditional sense: Definition. (The new &amp;-C-calculus)The basic notion of reduction c collects all of the above relations:The one-step c-reduction, -cfor the transitive-reflexive closure of the one-step c-reduction. The c-congruence is defined as:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Proof. From our previous work[2]  we know that is Church-Rosser. Furthermore, it is obvious that cl'= #3U#" is Church-Rosser, and also that the recductions based on c' and c" commute. Given this, iit follows from the Hindley-Rosen Lemma [1:64] that, the reduction -= satisfies the diamond property. lJ Furthermore, the modified calculus has the usual standardization procedure for equations. For every (one-way) derivation, there exists a standard derivation based on the leftmost-outermost reduction strategy. A convenient way of defining leftmost-outermost reductions is based on the concept of an evaluation context: Definition. (Conleats and evaluation contexts) Con-2ezcls are terms with a hole. Let C[ ] range over the set of contexts and let [ ] denote the hole. Then we can define the set of contexts inductively by: Cl 1 ::= [ 3 I AZ-CL I I MC[ 1 I Cl IM I F'cl 1 I #CL 1. If C[ ] is a context, then C[M] is the term where the hole is filled with the term M. The filling of a context may capture free variables in the fill-in term. Evaluation contexts are special contexts whose hole is not inside a X-abstraction or an F-application. More precisely, the path from the root to the hole leads through applications and #-applications only and the terms to the left of the path are values: Cl I ::= [ 1 I VC[ 1 I cl. IM I #CL I, where M is an arbitrary term and V is a value. The concept of an evaluation context precisely captures the notion of leftmost-outermost: if P is a Credex and C[ ] is an evaluation context, then P is the unique leftmost-outermost redex in C[P]. Given this, it is straightforward to define a standard reduction function and a set of standard reduction sequences. The former reduces the leftmost-outermost redex of a given term, the latter combines a series of terms that are related by standard reduction steps, possibly by omitting the reduction of some leftmost-outermost redexes: Definition. (Standard reduction function and standard reduction sequences) The standard reduction function maps M to N, Mw,, N, if there are P, Q, and an evaluation context C[ ] such that (P, &amp;I E c, and M=C[P], NzC[Q]. Standard reduction sequences, abbreviated SRS-S, are defined by: 1. all constants and variables are SRS-s; 2. if Ml,..., Mm i,s an SRS and Nl,...,N, is an SRS, then the followingare SRS-s: Az.Ml,. . . ,Xz.Mm, FMI,...,TM,,,, #Ml,. -. , #Mm, and MINI ,..., kf,,,N~,..., M,,,N,,; 3. if MI--+,, Ml and MI,. . . , Mm is an SRS, then M,Ml,..., M,,, is an SRS. The Standardization Theorem can now be formulated Z&amp;S: Theorem (Standardization for A,,-C). M-,N if and only if there is a standard reduction sequence L1, . . . , LI such that M E LI and LI -N. Proof. A full-fledged proof requires an adaptation of the standardization proof for the original reductionbased X,-C-subcalculus.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>zc N, if for any context C[ ] such that C[M] and C[N] are programs, eval, is undefined on both, or it is defined on both and if one of the programs yields a basic constant, then the value of the other is the same basic constant.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>-C t M = N then M zc 11'. The converse does not hold.Proof.The proof is eactly the same as the one for the &amp;-calculus[11:144]. If X,-C l-M = N, then A,-C I-C[M] = C[N]. Hence, if eval,(C[M]) is defined, so is euol,(C[N])(though they may not be the same). Finally, if one of the values is a basic constant, the other must be the same basic constant by the Church-Rosser Theorem. 0The Correspondence Theorem manifests the major theoretical improvement to the control calculus. Only a restricted version holds for the original XV-C-calculus, namely, a version for the reduction-based subcalculus. :For proving operational equivalences in the old calculus, we needed the additional notion of safe (computational) theorems. Safe theorems are characterized by derivations that are independent of their concrete evaluation context, and this independence guarantees the operational equivalence on the machine.In the new &amp;-C-calculus the set of safe equations plays a more traditional role. It is a consistent extension of the calculus and thus relates to the &amp;-C-Calculus like a X-theory to the &amp;calculus. The definition of a safe equation directly carries over from the old calculus: Definition. (Safe equations) An equation M = N is safe if the calculus proves all theorems of the form L-C I-(#C[M]) = (#C[.N]) where C[ ] is an arbitrary evaluation context. The adequacy of safe equations is encapsulated in the last theorem of this section: Theorem (Safe-ness).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>For a comparison</head><label></label><figDesc>of this machine semantics with the standard reduction semantics, we abstract from the transition function with a CEK-evaluation junction: Definition: (The ev&amp;EK-function) The (partial) evaluation function eVdCEK maps programs to vdues according to the transition function: e?M&amp;ZEK(M) = Unload(V)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Qfopen .(k&amp; (#(P fopen &gt;) (cl~ose fopen)).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>is to design an enumeration procedure e that pairs the current leaf with the current continuation of the tree walk. This procedure must approximately look like df e = N.F(Xr.(cons 1 . . .r.. .)). -The remaining question is what to return as the second component of the pair. The continuation r is This new schema for the implementation of functionexits is more efficient.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>The functions II, and II2 are extensionally equivalent in the extended &amp;-C-calculus: Proposition. Let L be a list of numbers. If lIr is correct, then A,-Csafe I-(HI L) = (Hz L). Proof. The correctness of III implies that (II, L) = n is a safe equation for any list L and some number n. zero?(car I)) (T(Xd.(E 0))) (*(car O(~(cdr 0)))))))</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>All of these syntactic forms can be construed as abbrevia tions of A-expressions: see Appendix.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgement. Dan Friedman and Carolyn Talcott read early drafts of the paper and suggested several improvements. Perry Wagel's quest for a nonlazy enumeration of trees inspired Enumerate2. Mitch Wand pointed out the kinship of errorset and #.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>a function that will resume the tree walk when invoked on an arbitrary argument. In order to perserve the invariant that this tree walk is always run in a prompt-application, we must encapsulate r in an abstraction:</p><p>Finally, since the argument to r is actually irrelevant, we can put the prompt-application in a null-ary function and use NIIL as the dummy value: In the absence of prompt-applications, the formalization of this tree walk becomes more complicated. It requires an implementation schema where Enumerate acts like a coroutine with respect to the rest of the program, i.e., it stores away the continuation of the main program upon every resumption for use in e. The important difference is that the prompt-free solution contains recurring programming patterns. Such patterns clearly call for an appropriate abstraction that hides the details of grabbing partial continuations.</p><p>The prompt-application is the correct fundamental atbstraction for reasoning and programming with parts of the current continuation.</p><p>Remark. Enumerate2 is a typical example of a function that makes practical use of first-class continuations in the absence of assignments.</p><p>Indeed, it is also an example of the usefulness of continuations for stream-progra.mming <ref type="bibr" target="#b7">[9]</ref>. Given a lazy cons, i.e., an abbreviation B la (cons$ a d) ii (consa (A().d)), the function Ekumerate:! can be recast as </p><p>In other words, the function Enumerate2 transforms a multi-ary B'*-tree into a list whose rest is computed when necessary. With a lazy programming language, the same algorithm could be expressed as: Enumerate2 P Xi.(iterate L (i 1) (if (leaf?t) t (apply awnd$ (ma@ Lt)))).</p><p>However, this function is not an instantiation of the tree-walk programming schema. Although the algorithm is intuitively a variant of the single-step enumeration, lazy programming forces a rewriting of the Enumerate-function to lit this particular need. Also, depending on the management of continuations by the implementation, the F-#-based version avoids the overhead of the lazy version: because for-each is used for effect only, it does not require the expensive allocation of extraneous cons-cells. E:nd Unfortunately, this simulation of function-exits manipulates the control structure extensively.</p><p>It first accesses the continuation of II, a second time when it eliminats the recursive unfoldings, of II to return 0, and, because there is no indication as to the extent of the manipulation, the escape-jump requires the removal and re-installation of most of the current control stack. Depending on the implementation of continuations and continuation access, operations, this can become expensive.</p><p>With a #-application, we can instead mark the entrance point with a prompt, and when an escape-exit becomes necessary, the partial continuation is erased: </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The Lambda Calculus: Its Syntax and Semantics. rev</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">P</forename><surname>Barendregt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Studies in Logic and the Foundations of Mathematics 103</title>
		<meeting><address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>North-Holland</publisher>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">The Calculi of Lambda-v-CS-Conversion: A Syntactic Theory of Control and State in Imperative Higher-Order Programming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Felleisen</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Beyond continuations</title>
		<author>
			<persName><forename type="first">M</forename><surname>Felleisen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Friedman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Duba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">And</forename><forename type="middle">J</forename><surname>Merrill</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
		<respStmt>
			<orgName>Indiana University Computer Science Department</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A syntactic theory of sequential clontrol</title>
		<author>
			<persName><forename type="first">M</forename><surname>Felleisen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Friedman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kohl-Becker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">And</forename><forename type="middle">B</forename><surname>Duba</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Cornput. Sci</title>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Embedding continuations in procedural objects</title>
		<author>
			<persName><forename type="first">C</forename><surname>Haynes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Friedman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Dynamic binding in Scheme, unpublished manuscript, 1984, MIT. JOHNSON, 1G.F. GL-A language and environment for interactively experimenting with denotational definitions</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">!</forename><surname>Hanson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lamping</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGPLAN &apos;87 Symposium on Iniierpreters and Interpretive Techniques SIGPLAN</title>
		<meeting>SIGPLAN &apos;87 Symposium on Iniierpreters and Interpretive Techniques SIGPLAN</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="165" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The next 700 programming languages</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Landin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="157" to="166" />
			<date type="published" when="1966">1966</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The mechanical evaluation of expressions</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Landin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. J</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="308" to="320" />
			<date type="published" when="1964">1964</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Lisp 1.5 .Programmer&apos;s Manual. sec</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mccartby</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1965">1965</date>
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Call-by-name, call-by-value, and the X-calculus</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Plotkin</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="125" to="159" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m">The revised3 report on the algorithmic language Scheme. SIG-PLAN Notices</title>
		<editor>
			<persName><forename type="first">Rees</forename><forename type="middle">J W</forename><surname>Clinger</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="37" to="79" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Definitional interpreters for higher-order programming languages</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Reynolds</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc</title>
		<meeting>null</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m">ACM Annual Conference</title>
		<imprint>
			<date type="published" when="1972">1972</date>
			<biblScope unit="volume">71</biblScope>
			<biblScope unit="page" from="7" to="740" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Common Lisp-The Language</title>
		<author>
			<persName><forename type="first">G</forename><surname>Steele</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984">1984</date>
			<publisher>Digital Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
