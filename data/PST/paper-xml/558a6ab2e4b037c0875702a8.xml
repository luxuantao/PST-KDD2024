<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">SemCast: Semantic Multicast for Content-based Data Dissemination †</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Olga</forename><surname>Papaemmanouil</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Brown University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Uğur</forename><surname>Çetintemel</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Brown University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">SemCast: Semantic Multicast for Content-based Data Dissemination †</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">B2FDF3CABE0FFD46035A5FA9B940E905</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We address the problem of content-based dissemination of highly-distributed, high-volume data streams for stream-based monitoring applications and large-scale data delivery. Existing content-based dissemination approaches commonly rely on distributed filtering trees that require filtering at all brokers on the tree. We present a new semantic multicast approach that eliminates the need for content-based filtering at interior brokers and facilitates fine-grained control over the construction of efficient dissemination trees. The central idea is to split the incoming data streams (based on their contents, rates, and destinations) and then spread the pieces across multiple channels, each of which is implemented as an independent dissemination tree. We present the basic design and evaluation of SemCast, an overlay-network based system that implements this semantic multicast approach. Through a detailed simulation study and realistic network topologies, we demonstrate that SemCast significantly improves the efficiency of dissemination compared to traditional approaches.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>There is a host of existing and newly-emerging applications that involve high-volume, real-time streaming data. Examples of such stream-based applications include network monitoring, large-scale environmental monitoring, real-time financial services and networked games <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b5">5]</ref>.</p><p>Many stream-based applications are inherently distributed and involve data sources and consumers that are geographically dispersed. As a result, there is a need for data streams to be routed, usually based on their contents, from their sources to the destinations where they will be consumed. Such content-based routing differs from traditional IP-based routing in that routing is based on the data being transmitted rather than any routing information attached to it. In this model, sources generate data streams according to application-specific schemas, with no particular destinations associated with them. Thus, the destinations are independent of the producers of the messages and are instead identified by the consumers' interests, which are commonly expressed through declarative specifications called profiles <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b15">15]</ref>. Profiles are usually specified as query predicates over application schemas. The goal of a content-based routing system is to efficiently identify and route the relevant data to each consumer.</p><p>In this paper, we present SemCast, an overlay-network system that performs distributed content-based routing of highly-distributed, high-volume data streams. SemCast creates a number of semantic multicast channels for disseminating streaming data. Each channel is implemented as an independent dissemination tree of brokers (i.e., application-level routers) and is defined by a specific content expression (i.e., predicate). Sources forward each incoming message to one or more channels. Destinations listen to one or more channels that collectively cover their profiles.</p><p>The key advantages of SemCast are twofold. First, SemCast requires content-based filtering only at the source and destination brokers. As each incoming message enters the network, it is mapped and forwarded to a specific channel(s). As a result, the routing at each interior broker only involves reading a channel identifier and forwarding the message to the corresponding channel. This approach eliminates the need to perform expensive content-based filtering at interior brokers. In this respect, SemCast radically differs from the traditional contentbased routing approaches (e.g., <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b6">6,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b15">15]</ref>) that commonly rely on distributed filtering trees that require filtering at each level.</p><p>Even though a large body of work has focused on optimizing local filtering using intelligent data structures <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b18">18]</ref>, filtering times in the presence of a large number of profiles are typically in the order of tens of milliseconds or even higher, depending on the expressiveness of the data/profile model and the number of profiles <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b7">7]</ref>. As a result, forwarding costs can easily dominate overall dissemination latencies, as well as excessively consume broker processing resources. This "per-message-overhead" problem becomes more pronounced when data need to be compressed for transmission (typically employed when transmitting XML data streams <ref type="bibr" target="#b20">[20]</ref>), as each broker will then have to incur the cost of decompression and recompression. Furthermore, data may also be encrypted for security reasons (e.g., in financial feeds, networked games etc.). In these scenarios, there will be an additional overhead for encryption/decryption at each broker. The only straightforward way to eliminate these overheads is to eliminate the need to perform content-based filtering, which is the approach SemCast takes.</p><p>Second, SemCast semantically splits the incoming data streams and sends each sub-stream through a different dissemination channel. This approach makes the system quite efficient and flexible, because multiple bandwidthefficient dissemination trees can be created, optionally based on the QoS (Quality-of-Service) expected by the clients of the system.</p><p>On the other hand, existing approaches commonly rely on predetermined overlay topologies, assuming that an acyclic undirected graph (e.g., a shortest path tree) of the entire broker network is determined in advance <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b6">6]</ref>. As we demonstrate, these approaches fail to recognize many opportunities for creating better optimized dissemination trees. Moreover, as shown by recent work <ref type="bibr">[8,</ref><ref type="bibr" target="#b17">17]</ref>, using multiple trees can significantly increase the efficiency and effectiveness of data dissemination.</p><p>In the SemCast approach, a cost model is used to perform channelization; i.e., deciding how many channels to use as well as the contents and destinations of each channel. The model uses (1) stream contents and rates, (2) profile characteristics, and (3) network locations of the message destinations. Each channel is implemented as a multicast tree, and clients subscribe to the channels by joining the corresponding trees. The system gathers statistics in order to adapt to changes in the profile and stream characteristics. Using statistical as well as syntactic information (i.e., profile containment relationships), SemCast periodically revises its channelization decisions, striving to improve the overall efficiency of the system.</p><p>In this paper, we provide a detailed description of SemCast and its semantic, cost-based channelization model. Using realistic network topologies and workloads, we compare the SemCast approach to the representatives of traditional content-based routing approaches through a detailed simulation study. Our results show that SemCast not only reduces the processing load on the brokers, but also significantly reduces the overall bandwidth requirements of the system.</p><p>The rest of the paper is structured as follows. In Section 2, we present the basic design and architecture of SemCast. Section 3 outlines the algorithmic challenges and presents our semantic, cost-based channelization approach. In Section 4, we discuss our heuristics for latency-aware dissemination tree construction. In Section 5, we present experimental results that characterize the efficiency of SemCast and representatives of traditional content-based dissemination approaches. Section 6 briefly discusses prior related work. Finally, Section 7 concludes with a brief summary of our contributions and directions for future research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">System model</head><p>Data and profile model SemCast is based on a content-based publish/subscribe model where clients declaratively express their data needs by specifying predicate-based expressions called profiles. SemCast can work with either relational or XML data. Profiles are expressed using simple predicates over the relational schema in the former case, and using a query language (e.g., XPath <ref type="bibr" target="#b23">[23]</ref>) in the latter case.</p><p>Each client profile is optionally also associated with a QoS specification that expresses the client's service expectations <ref type="bibr" target="#b5">[5]</ref>, typically as a constraint on a specific metric of interest. The only QoS metric addressed in this paper is staleness, which measures the end-to-end delay between the time a message is "injected" into the system and the time it is delivered to the client.</p><p>Components SemCast consists of a set of servers (a.k.a. brokers or nodes) organized into an applicationlevel overlay network, which is illustrated in Figure <ref type="figure" target="#fig_0">1</ref>. Publishers are the producers of data and interact with the system through source brokers (or simply sources). Subscribers are the final destinations of data and are connected to the system through gateway brokers. Each client can maintain connections with more than one gateway broker. Brokers that are not at the "edges" of the system (i.e., those with no publishers or subscribers connected to them) are called interior brokers. The coordinator node is responsible for performing channelization and managing the dissemination channels. It communicates with the sources and the gateway brokers in order to inform them about the content of the existing channels. For simplicity of exposition, we assume throughout the paper that there is a single coordinator. In Section 3.1.5, we discuss how to distribute coordinator functionality across multiple nodes to improve the availability and scalability of the system. Some brokers of the overlay network serve as rendezvous points. A rendezvous point is responsible for at least one channel in the sense that it serves as the root of the corresponding dissemination tree.</p><p>Channel expressions The content of each channel is defined by a channel expression, which is basically a combination of disjunctions and conjunctions of client profiles. A profile is assigned to a channel if the channel expression overlaps with the profile. In Section 3, we describe the form of the content expressions and explain how they are derived from the client profiles. For a given channel, the corresponding dissemination tree includes all the gateway brokers that have at least one client whose profile is assigned to the channel.</p><p>Basic data-flow The coordinator periodically makes channelization decisions and forwards to each source (1) the channel to rendezvous point assignments and (2) the content expression for each channel. Sources receive incoming messages and match them against these expressions to decide which channel(s) to forward them. Once a message is received by a rendezvous point, it is efficiently disseminated, over the corresponding dissemination tree, to the relevant gateway brokers. Due to the potential overlap among the channels, a rendezvous point can receive the same message multiple times, through different channels, and is also responsible for eliminating duplicates. Each (interior) broker maintains a simple routing table whose entries map channel identifiers to the descendant brokers in the underlying dissemination tree(s). Upon receipt of a message addressed to a specific channel, only a simple lookup is performed on the channel's identifier and the message is forwarded to the returned descendant list.</p><p>Each gateway broker maintains a local filtering table mapping its subscribers' profiles to their IP addresses. It also maintains a mapping of channels to its subscribers. Received messages from a channel are matched against the profiles of the subscribed clients and are forwarded only to the interested ones. This local filtering ensures that end clients do not receive irrelevant data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Content-based channelization</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Overview</head><p>We now discuss the problem of content-based channelization of data streams. The problem requires addressing the following questions: (1) how many channels to create, (2) the contents of each channel, and (3) which channels each broker should listen to. SemCast utilizes a cost-model that uses profile semantics, stream statistics, and network characteristics. Because these factors may change over time, SemCast periodically reevaluates its channelization decisions.</p><p>SemCast has two primary operational goals while performing channelization. First, SemCast ensures that there are no false exclusions: the assignment of profiles to channels and the channel expressions guarantee that every message will be delivered to all the clients with matching profiles. Second, SemCast strives to minimize the runtime cost: the cost metric we use here is the overall bandwidth consumed by the system.</p><p>To minimize the run-time cost, SemCast's algorithms strive to:</p><p>• eliminate content redundancy by minimizing the overlap among channel contents. • create cost-efficient dissemination trees using an incremental, distributed tree construction algorithm (inspired by Steiner trees <ref type="bibr" target="#b22">[22]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Channelization algorithm</head><p>SemCast leverages the knowledge of "overlap" among profileswe say that two profiles overlap if the intersection of the set of messages both match is non empty. Assigning overlapping profiles to the same channel allows the common matching messages to be forwarded only once, through the same dissemination tree, thereby eliminating redundant transmissions. As a second optimization, SemCast attempts to include as part of each dissemination tree only the brokers with overlapping profiles.</p><p>As we describe below, SemCast relies on both syntactic and statistical information to identify overlapping profiles. An extreme case of profile overlap arises in the form containment relationshipsa profile P 1 covers (or contains) a profile P 2 if and only if all messages that match P 2 also match P 1 . SemCast discovers containment hierarchies among the profiles, where each profile has as its ancestor a profile that covers it, and as descendants profiles that are covered by it.</p><p>SemCast periodically reorganizes the channels' content and membership to reflect the latest statistics in the system. This reorganization includes two phases.</p><p>First, SemCast constructs containment hierarchies using both syntactical similarities among profiles and statistics on the stream rates and profile overlap. These hierarchies form the basis of our channelization decisions: each hierarchy is a good candidate for serving as a dissemination channel, because of the overlap among the constituent profiles. However, creating channels solely based on containment information will miss further optimization opportunities as partial overlaps among profiles are ignored. The second phase of the reorganization addresses this issue by identifying partially overlapping profiles and placing them in the same channel in order to further reduce the run-time cost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Statistical information</head><p>SemCast strives to adapt to changes in the rate of the incoming messages and the overlap among profiles. To implement this approach, source brokers continuously collect information about the profiles' selectivity in a selectivity matrix. We define the selectivity of a profile as the set of messages matching this profile. On each reorganization phase, the coordinator gathers these statistics from each source broker, creating the global selectivity matrix. Moreover, it creates a profile overlap matrix to calculate the partial overlap between profiles.</p><p>Selectivity matrix This structure is implemented as a sliding window on a sample of the incoming messages and is maintained by each source broker.</p><p>Each row refers to a message and each column to a different profile. For each sampled message, the profiles matching this message are identified and the corresponding entries are set to one. The size of this window (i.e., number of rows) should be large enough to collect statistics with high confidence. Samples are given weights based on an exponential decay function. Thus, decisions are biased to favor more recent statistics. This matrix can be efficiently stored as a bit vector.</p><p>The selectivity matrix provides us with information about the set of messages each profile has matched during the timeframe of the sliding window. Based on this information, we can easily estimate the message rates (per profile) and the overlap among profiles.</p><p>Profile overlap matrix We now define a partial overlap metric between profiles. Given two profiles P i and P j , we say that P i k-overlaps with P j , denoted P i ⊆ k P j , if the ratio of the number of messages matching P j and P i to that matching P i is k. Obviously if k=1, then P j contains (or covers) P i , and the set of messages matching P i is a subset of those matching P j .</p><p>SemCast computes an overlap matrix using the selectivity matrix. Specifically, each entry, O ij , of the overlap matrix represents the overlap value for the profiles P i and P j ; i.e., O ij =k, if P i ⊆ k P j .</p><p>In the next section, we describe how the overlap information is used in the reorganization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Construction of containment hierarchies</head><p>The reorganization phase attempts to move the system to a configuration with lower run-time cost. Placing two profiles, one more general than the other, on the same channel does not necessarily lead to a reduction in cost, especially if the overlapping part is very small, or if the non-overlapping part has high rate.</p><p>In order to make the right decision, SemCast places overlapping profiles under the same channel, if this could lead to improvement of bandwidth consumption. To achieve that, we use a cost model to identify if two profiles, where one is covered by the other, should be assigned to the same channel.</p><p>The cost of SemCast, in terms of bandwidth consumption, is determined by three factors:</p><p>• The set of semantic channels S, in the system; • The expected dissemination rate of a channel, r i , i∈S.</p><p>This rate is defined as the number of messages that are transmitted through this channel per unit time; and • The edges in the dissemination tree implementing each of the channels, E i , i ∈S. Given this notation, we define the cost of a channel c i , with profiles {P 1 , …, P n } assigned to it, as:</p><formula xml:id="formula_0">1 ({ ,..., ) } i i n i e E c c P P r ∈ = = ∑ (1),</formula><p>We can now define the cost of SemCast as the sum of the cost of all channels, c i , i∈S:</p><formula xml:id="formula_1">i i S c ∈ ∑ .</formula><p>Containment relations To create the containment hierarchies, SemCast first identifies the containment relations based on the syntax of the profiles. Existing algorithms for identifying containment relations can be found in <ref type="bibr" target="#b6">[6]</ref>, in the case of relational data, and in <ref type="bibr" target="#b24">[24]</ref>, in the case of XML data.</p><p>Second, SemCast uses the overlap matrix to extend the syntax-based hierarchies as follows. We identify as additional roots profiles those not covered by any other profile; i.e., in the overlap matrix, a root profile P j should have a single '1' in the j-th column, at the entry O jj . Each non-root profile P i may have multiple "candidate parents", which are those that contain P i (can be identified using the syntax-based containment algorithm), as well as those that matched a superset of the messages that matched P i , in the current sampling window; i.e., in the overlap matrix, the candidate parents P j of P i are those having O ji =1, i ≠ j.</p><p>Among all of P i 's candidate parents, we identify the one that gives the most cost reduction (computed based on a simple cost model that we define below), if assigned to the same channel with P i . This parent is the one that has the highest percentage of overlap with P i and the lowest rate for the non-overlapping part with P i .</p><p>In Figure <ref type="figure">2</ref>, we show a simple example of the containment hierarchies that exist among seven profiles. Table <ref type="table" target="#tab_0">1</ref> shows a possible overlap matrix for these profiles. Here, P 6 has two candidate parents, P 1 and P 4 . P 4 is eventually chosen to be the parent of P 6 because it shares a higher percentage of messages with P 6 .</p><p>Cost model We now describe the details of the cost model used for non-root profiles to pick their parent from among all candidate parents. For each non-root profile P child , we compute the cost of two scenarios. First, we compute the cost of assigning P child as a root to a new hierarchy:</p><formula xml:id="formula_2">( ) ({ ) } parent child c H c P + .</formula><p>where H parent refers to the set of profiles in the hierarchy rooted by P parent . Furthermore, for each candidate parent P parent , we compute the cost of assigning P child to H parent :</p><formula xml:id="formula_3">( { ) } parent child c H P ∪</formula><p>We then identify and apply the lowest-cost scenario.</p><p>Cost approximation To estimate the cost of the above scenarios, we use the cost formula <ref type="bibr" target="#b1">(1)</ref>. Thus, we need to identify the rate of messages matching the profiles involved in each scenario and the number of edges in the dissemination tree that spans all the corresponding gateway brokers. The rate of the matching messages can be derived from the selectivity matrix.</p><p>In order to be able to use formula (1) we need to estimate the number of edges in a dissemination tree spanning a given set of gateway brokers. To achieve this, we assume the corresponding gateway brokers connect to the dissemination tree in random order. The first broker is assumed to be connected to the rendezvous point through a shortest path. The consequent brokers connect to the closest one of the gateway brokers already attached to the tree. The coordinator calculates the shortest paths between two brokers, using location information collected from the brokers during run-time.</p><p>Channel content expressions Some containment relations derived during a reorganization phase are based on the selectivity history. However, relying only on statistical information can lead to false containment relations. Therefore, to preserve the no-false-exclusion property, SemCast represents the root expression of each hierarchy as a disjunction of the profiles in the hierarchy. Thus, if profiles P i , i=1,…,k, are assigned to the hierarchy H, the root expression of the hierarchy is:</p><formula xml:id="formula_4">1 2 ... k E P P P = ∨ ∨ ∨ .</formula><p>Moreover, SemCast assigns a profile that is not present in any containment hierarchy, either because its selectivity is zero or because no syntactic containment information could be derived, to a new channel. This assures that all profiles are assigned to at least one channel. In this way, every client interested in these profiles can subscribe to the corresponding channels and therefore receive all relevant messages. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.3">Hierarchy merging</head><p>Even though periodic re-evaluation of the containment hierarchies and channel reorganization can improve the efficiency of the system, a small degree of containment among profiles could result in a large volume of redundant messages. The reason is that containment hierarchies cannot identify profiles with only partial overlap, and, thus, the reorganization phase would assign them to different channels, increasing the overall bandwidth consumption.</p><p>To address this problem, SemCast places different containment hierarchies with significant partial overlap in the same channel. However, perhaps counter to intuition, such a merging of hierarchies may not necessarily reduce redundant transmissions. Even though the messages common to both hierarchies will now be transmitted only once, the uncommon messages will be forwarded to the destinations not interested in them. For this reason, SemCast merges the common parts of two hierarchies and forwards their uncommon parts through two "noise channels" if this operation is expected to decrease the bandwidth consumption.</p><p>Specifically, if two hierarchies with root expressions E i and E j are merged, then three channels with the following content expressions and destinations are created:</p><formula xml:id="formula_5">1. E i ∧ E j and D(E i ) ∩D(E j ),</formula><p>2. E i ¬ E j and D(E i ), and 3. E j ¬ E i and D(E j ), where D(E) represents the set of gateway brokers having at least one client interested in one or more of the profiles that appear in expression E. The first channel above contains the content common to both hierarchies. The second and third channels are the noise channels that carry content assigned to only one of the hierarchies.</p><p>Cost model To implement the merging operation, SemCast makes a pair-wise comparison of the root profiles using the overlap matrix: if there is partial overlap between P j and P i , i.e., P i ⊆ k P j or P j ⊆ k P i where k&gt;0, then we compute the cost of the current configuration:</p><formula xml:id="formula_6">( ) ( ) i j c H c H + ,</formula><p>and compare it with the cost of the configuration after the hierarchies are merged and the noise channels created:</p><formula xml:id="formula_7">( ) ( ) ( ) i j i j c H H c N c N ∩ + + .</formula><p>We define the cost of a noise channel, N i , as:</p><p>( )</p><formula xml:id="formula_8">e E i c N r ∈ = ∑ ,</formula><p>where E is the set of edges of the dissemination tree that spans the gateway brokers whose clients have the profiles in hierarchy H i , and r is the expected dissemination rate of the noise channel N i . This latter value denotes the number of messages matching the profile set of hierarchy H i , but not the profile set of H j , per unit time. To estimate the number of edges in the dissemination tree, we follow the same procedure as in the case of hierarchy construction. Among all pair-wise merging operations, we identify and apply the one that provides the highest cost benefit. We continue considering pair-wise merging operations among the new merged hierarchies and the non-merged ones, until no further cost reduction can be achieved. The noise channels are not considered for further merging (in Section 5, we study an alternative approach that also considers the noise channels for merging). Since this merge procedure has exponential cost, it is stopped after a fixed number of iterations or a specific time period.</p><p>Once the merging procedure terminates, a new set of channels is created to reflect the new set of hierarchies (non-merged and merged ones). Brokers are informed by the coordinator about the new channels to which they should subscribe to, while sources receive the new channel lists and the corresponding content expressions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.4">Subscription management</head><p>In this section, we describe how SemCast handles subscription and unsubscription requests. Upon receipt of a new profile from a client, the gateway broker sends the profile to the coordinator. Using a syntax-based containment algorithm, the coordinator checks if an existing channel covers the profile. If a covering channel exists, then the profile is simply assigned to this channel. If there is no covering channel, a new channel is created for the profile. In either case, the gateway broker is notified of the decision, and joins the corresponding dissemination tree.</p><p>If a client wants to remove its subscription, it sends a request to its gateway broker. The broker identifies the channel from which this subscription is satisfied, and removes the subscription from its local filtering table.</p><p>Unless there are more clients interested in receiving messages from that channel, the gateway broker removes itself from the channel and the corresponding dissemination tree by sending an unsubscription request to its parent in the dissemination tree. When a broker receives such a request from one of its peers, it checks whether it has any more descendents in the tree. If all of its children have been removed from this channel, it also removes itself and forwards the request one hop closer to the source. Once a channel is left with no gateway brokers, it is removed from the system by the coordinator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.5">Multiple coordinators</head><p>The functionality of the coordinator can be easily distributed to improve the scalability and availability of the system. If multiple coordinators exist, each will be responsible for maintaining information (i.e., containment hierarchies, channel expressions) related to a specific subset of the attributes appearing in the profiles. If a channel expression or a containment hierarchy contains profile expressions including more than one attribute, this information will be maintained in each one of the coordinators responsible for these attributes. Gateway brokers will forward their subscription requests to a coordinator among the ones responsible for the attributes appearing in a profile. In the reorganization phase, the coordinators synchronize their data, and one of them is elected to perform channelization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.6">Filtering cost of content expressions</head><p>After hierarchy construction and merging operations, the channel content expressions can have one of the following forms:</p><p>1. </p><formula xml:id="formula_9">i k j m E E E E ∧ ∧ ¬ ∧ ∧</formula><p>, for the noise channels. For correctness, all SemCast's sources need to maintain a list with the content expressions of every channel available in the system. Every incoming message must then be matched against these expressions and be forwarded to the appropriate channels. The filtering cost at the source can be reduced by using a centralized filtering engine (e.g., <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b7">7]</ref>). Since each distinct profile will appear in at least one content expression, the filtering engine is used to match the incoming messages against all distinct profiles.</p><p>Once we determine all the profiles the incoming message matches, we then need to identify the corresponding channels. Therefore, the content expression of each channel, which can be in one of the forms shown above, should be evaluated efficiently. This procedure boils down to an evaluation of a set of Boolean expressions, one for each channel. To improve the time of expression evaluation, an algorithm like UNISON <ref type="bibr" target="#b21">[21]</ref> can be used. This algorithm performs fast evaluation of arbitrary Boolean expressions in software with small execution time and memory space requirements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Dissemination tree construction</head><p>SemCast relies on a distributed and incremental approach to create two types of dissemination trees, lowcost or delay-bounded trees, which we describe in the rest of this section.</p><p>Low-cost trees SemCast attempts to organize nodes with similar interests in the same dissemination tree. Moreover, the tree construction heuristics strive to create dissemination trees that include a small number of internal brokers, since these brokers are not interested in the disseminated information. Thus, the main idea of the low cost heuristic is to connect one gateway broker to the closest one in the same semantic channel. In this way, dissemination trees will mainly include brokers interested in the same content, avoiding messages forwarding to an increased number of internal brokers.</p><p>To implement this approach, a gateway broker receives from the coordinator the list of the current destinations in the channel to which it wishes to connect. The broker then finds the min-cost path to each destination and connects to the channel through the closest one. Join requests are sent all the way from this gateway broker to the first node in the tree and the routing tables of the brokers on this route are updated to reflect the new tree structure. This approach proceeds in a way similar to how Steiner trees are constructed (e.g., <ref type="bibr" target="#b22">[22]</ref>), although it is distributed and works in an incremental manner.</p><p>Delay-bounded trees SemCast can create delaybounded dissemination trees if clients indicate latency expectations. Since a gateway broker serves multiple clients, it has to determine the proper target latency value based on the expectations of all its clients. We here assume that the gateway broker has decided a latencybound for each of the channels it listens to according to some policy.</p><p>The gateway broker first finds a connection node in the dissemination tree using the low-cost heuristic described above. All brokers continuously track their "distance" from the root of the channels they maintain. Thus, upon the receipt of a delay-bounded join request, the brokers can estimate if they can satisfy the latency constraint. If the connection node realizes that it will not be able to meet the latency constraint tagged to the join request, it will forward the join request to its parent in the channel. If the parent, which is not necessarily a gateway broker for the channel, can satisfy the latency bound, then the gateway broker connects to the channel through the shortest path to the parent. This process will continue until either a broker that is sufficiently close to the root is found or it is decided that the constraint cannot be met. In the latter case, the client will be notified and, optionally, the gateway broker will be connected through the shortest path to the root.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Experimental evaluation</head><p>We now describe our performance evaluation that characterizes the efficiency of SemCast, comparing it against representatives of traditional content-based filtering approaches, using detail simulations over realistic network topologies.</p><p>Simulation setup In the simulation, we used an overlay network of brokers, where the topologies are random graphs generated with GT-ITM <ref type="bibr" target="#b26">[26]</ref>. In the experiments, we used networks of up to 600 broker nodes and 7000 clients.</p><p>In order to control the impact of profile similarities, we used a parameter called the profile selectivity factor, which determines the number of distinct profiles in the profile set. Specifically, a selectivity factor of x gives us a set of 1/x% distinct profiles. Thus, the higher the selectivity factor is, the smaller the set of distinct profiles is. Note that partial overlap or containment relationships may still exist among distinct profiles. Other simulation parameters of importance are described in the text wherever appropriate.</p><p>Each client picks its profile randomly from the profile set and then chooses a single gateway broker to connect, again randomly. To distinguish between edge nodes and internal nodes, the number of gateway brokers is fixed at 20% of the network size, unless stated otherwise. Each message publisher also connects to a single source broker that it randomly chooses, and forwards all its messages to that broker. The coordinator picks the rendezvous point for each channel, also at random.</p><p>Metrics Bandwidth efficiency is a key goal for all large-scale networked systems. We thus use the overall bandwidth consumed by the broker network as our primary evaluation metric. We also present results on the size of the filtering tables at each broker, in order to characterize the processing cost required for message filtering.</p><p>Studied dissemination approaches We simulated several approaches for content-based stream dissemination. First, we simulated a Unicast (UC) approach, where messages are filtered at the source brokers and are forwarded to the interested parties using shortest paths. This approach models the delivery scheme used by a centralized filtering system (such as XFilter <ref type="bibr" target="#b3">[3]</ref>). Second, we simulated an approach that models a conventional distributed publish-subscribe system (e.g., <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b15">15]</ref>). In this model, profiles are propagated and aggregated up to the root over shortest paths from each client to the source. In this way, a predicate-based filtering tree is created on top of a shortest-path spanning tree of the broker network. Filter-based routing tables are placed at each broker and messages are matched at each hop against the filters in the filtering table to determine the next hop(s) towards the clients. We refer to this algorithm as SPT (Shortest Path Tree).</p><p>Besides the alternative approaches, we also simulated three different versions of SemCast in order to gain more insight on the effects of our merging and tree construction heuristics. SemCast-NoiseMerge is an extension of SemCast where the noise channels are also considered for merging along with hierarchies. SemCast-Merge is another variant where the merging operations do not create any noise channels, but only one channel containing the profiles of the two participant hierarchies. Finally, SemCast-O is identical to SemCast except that it employs a centralized Steiner-tree construction algorithm <ref type="bibr" target="#b22">[22]</ref>, which uses global knowledge of all the profiles and the destinations for each channel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Basic performance</head><p>Disjoint profiles We first study the case when there is no partial overlap among the profiles. In this scenario, SemCast does not execute its second phase that merges partially-overlapping containment hierarchies. Thus, different merging heuristics do not come into play and all SemCast's variants perform the same. The only exception is SemCast-O, which uses a different tree construction algorithm.</p><p>Figure <ref type="figure">3</ref> shows the cost degradation (i.e., extra bandwidth consumption) of the UC, SPT, and SemCast over SemCast-O, for 600 nodes and 7000 profiles.</p><p>SemCast performs very close to SemCast-O, incurring up to only 6.4% extra cost on the average. This result reveals that SemCast's distributed tree construction heuristic performs reasonably close to an optimized, centralized algorithm (SemCast-O is omitted from the rest of the results, as it always slightly outperforms SemCast). Note that the scale on the x-axis is non-uniform. SPT performs better than UC but worse than SemCast. SPT incurs an extra 23% overhead on the average, whereas UC incurs an average increase of 41%.</p><p>In the remainder of the experiments, we use a selectivity factor of two, as this setting pretty much coincides with the knees of the curves of all approaches, and therefore serves as a good representative value.</p><p>Overlapping profiles We now turn to cases that involve partial overlap among profiles. We use a parameter called matching probability to control the degree of profile overlap. We define average profile overlap as the average partial overlap over all profile pairs. We study SemCast's bandwidth efficiency as a function of the aggregated profile overlap, which represents the average overlap between any two gateway brokers' "interests". Specifically, for each gateway broker, we computed the cumulative set of messages matching the local profiles and calculated the average partial overlap between these sets over all gateway brokers' pairs. Figure <ref type="figure" target="#fig_2">4</ref> shows how the aggregated profile overlap changes as we increase the average matching probability.</p><p>Figure <ref type="figure">5</ref> shows the cost improvement of SemCast and UC compared with SPT for increasing aggregated profile overlap values. The results show that SemCast always performs better that SPT and UC, even in the presence of partial overlap.</p><p>The poor efficiency of UC regardless of profile overlap (Figure <ref type="figure">3</ref> and Figure <ref type="figure">5</ref>) is not surprising since UC requires every message to follow an independent (shortest) path to its destinations. SPT eliminates some of this redundancy, due to the filtering at each broker. However, the gateway brokers are connected to the source broker through predefined paths. The construction of the network's spanning tree does not take into account common interests among clients. Thus, SPT uses paths from the source to the gateway brokers including brokers not interested in the same messages. SemCast strives to minimize this message redundancy by placing on the same dissemination tree only the brokers interested in receiving the same messages. Our algorithm identifies the set of gateway brokers interested in the same content, while our tree construction heuristic connects them using a low-cost dissemination tree. Thus, SemCast can achieve  a cost reduction up to 50% over SPT. These results reveal the significant advantages of the multi-tree semantic multicast approach over the single-tree distributed filtering-based approaches. Figure <ref type="figure">5</ref> also shows that the advantage of SemCast over SPT decreases as the profile overlap increases, when profiles partially overlap. Although SemCast attempts to eliminate all redundancy through its merge operation, some message redundancy is still present in the system due to the overlap among the channels that partially overlap but are not merged. As the profile overlap increases, this overlap also increases, increasing the message redundancy and thus the bandwidth consumption. However, even when all the profiles match the same set of messages and a single tree is created, SemCast performs better than SPT. The reason is that SemCast creates an approximation of a Steiner tree, including only the brokers interested in the messages, while SPT uses a shortest path spanner of the entire broker network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">SemCast's variations</head><p>Figure <ref type="figure">6</ref> shows the extra cost incurred by SemCast-Merge and SemCast-NoiseMerge over the plain SemCast approach. Both SemCast's variants perform worse than SemCast for all overlap values. Figure <ref type="figure" target="#fig_3">7</ref> provide complementary information by plotting the number of channels constructed by the three approaches. These results provide more insight on two important issues that we address in SemCast: (1) whether to create noise channels, and (2) whether to include these channels in the merging process.</p><p>Initially, when the profile overlap is low, all approaches create the same number of channels and incur similar run-time costs. As the overlap increases (between 25% and 95%), SemCast-Merge merges some of the containment hierarchies. However, the number of channels remains almost constant. As the partial overlap increases so does the bandwidth consumption due to the increase in redundant messages. SemCast is able to avoid part of this redundancy by creating the noise channels, thus proving the benefits of the noise channels. Clearly, the construction of noise channels increases the number of channels compared with SemCast-Merge. Once the profile overlap is sufficiently high (i.e., above 95%), it becomes possibly for SemCast-Merge to merge more profitably, without creating much "noise", and improve its performance. Figure <ref type="figure" target="#fig_3">7</ref> clearly shows that when the profile overlap is high, most of the profiles are placed on the same channel.</p><p>We also observe that, beyond a 10% profile overlap, both SemCast and SemCast-NoiseMerge start creating noise channels, the reason why they both create more channels than SemCast-Merge. It also seems that the merging of noise channels is not beneficial, since SemCast-NoiseMerge has higher cost than SemCast for most of the shown overlap range (i.e., 25%-95% profile overlap).</p><p>It is also clear that there is a tradeoff between the number of channels and overall bandwidth consumptioncreating more channels with less overlap can decrease run-time costs significantly, at the expense of an increase in the total number of channels that need to be stored and maintained. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">Other results</head><p>Profile Selectivity Figure <ref type="figure" target="#fig_4">8</ref> shows percentage cost improvement of SemCast over SPT, for three selectivity values: 1 (Low), 2 (Medium), and 4 (High). We see that higher selectivity factors result in higher cost improvement for SemCast when compared with SPT. The reason is that high selectivity values result in fewer distinct profiles in the profile set, and thus the content redundancy problem occurs to a lesser extent.</p><p>Network size We now investigate the scalability of SemCast as a function of the number of brokers in the system. Figure <ref type="figure">9</ref> compares SemCast with SPT for different network sizes, while keeping the number of profiles per broker fixed. The results show that, the larger the network size, the higher the improvement SemCast achieves. On the contrary, the unicast approach performs worse as the network size increases (not shown).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Latency-aware dissemination</head><p>We now study the efficiency of SemCast for delaybounded dissemination. For simplicity, we assume that all subscribers express the same latency bounds and no partial overlap exists among profiles. Latency is abstractly measured by the number of broker hops each message takes, from the rendezvous point to the destination gateway broker(s). We ran our low-cost heuristic and delay-bounded heuristic using the same set of profiles. For the latter case, however, we varied the latency expectations of our subscribers.</p><p>Figure <ref type="figure" target="#fig_0">10</ref> shows the tradeoff between bandwidth efficiency and dissemination latencies by plotting the penalty over the unbounded-latency case, as a function of latency bounds, for three different network sizes. As we relax the latency bounds, the penalty diminishes. The cost increase due to the latency constraints typically does not go beyond 10%, even with low profile selectivity factors. The implication is that even in the presence of tight latency bounds, SemCast is still able to achieve lower bandwidth consumption than SPT (since the difference between SPT and SemCast is always above 10%).</p><p>We also measured the depth of the dissemination trees and observed that, for an overlay network of 600 brokers, SemCast creates trees that are on the average 2-2.5 hops deeper than the corresponding trees in SPT. Thus, if latency is crucial, SemCast can use the latency bounding techniques to effectively create shorter trees at the expense of increased bandwidth consumption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Processing cost benefits</head><p>One of the main advantages of SemCast is that it eliminates the need for content-based filtering at intermediate brokers. In SemCast, messages are filtered only at two network locations: (1) at the source brokers, to identify the channels each message should be forwarded to, and (2) at the gateway brokers, to send only the matching messages to each client. The need for filtering at the gateway brokers may not be obvious. Even though the gateway broker knows, for each of its clients, the channel(s) to which the client is assigned, those channel(s) likely carry messages irrelevant to the client.</p><p>Since we are not studying matching algorithms, for experimentation purposes, we choose to use the number of profiles that need to be maintained and matched against incoming messages as an indirect but representative measure of the processing requirements of different approaches. Table <ref type="table" target="#tab_3">2</ref> shows the number of profiles that need to be maintained by SemCast, at gateway brokers, as The table also shows the number of profiles placed at the non-root brokers of the tree constructed by SPT. The number of profiles in the source of SemCast is similar to that at the source of SPT, so they are not included in the table.</p><p>In SPT, the number of profiles at the source is quite high. The reason is that, in our profile set, there are not many containment relations among the profiles, so most of the subscriptions are propagated upstream until they reach the source. However, as we move closer to the clients, the average number of profiles at the brokers decreases significantly. In SemCast, the amount of filtering performed at the gateway brokers is very small. These results indicate that the processing benefits at SemCast could be significant. This allows SemCast to scale up to high data rates, or from another perspective, require much less processing horsepower for the same data rates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Related work</head><p>Filtering systems A large body of work has focused on optimizing centralized filtering using intelligent data structures. For instance, XFilter <ref type="bibr" target="#b3">[3]</ref> and YFilter <ref type="bibr" target="#b14">[14]</ref> convert queries to finite-state machine representations and create matching algorithms for fast location and evaluation of profiles. In <ref type="bibr" target="#b11">[11]</ref>, a space-efficient index structure, which decomposes tree patterns into collections of substrings and index them using a trie, was proposed to improve filtering efficiency. The focus of SIFT <ref type="bibr" target="#b25">[25]</ref> was also on the efficient filtering of data against attributevalue-based client subscriptions.</p><p>None of these approaches addressed networked dissemination. SemCast can use these approaches for efficient content-based filtering at its source and gateway brokers.</p><p>Content-based routing Unlike SemCast, existing approaches for content-based networking do not address the issue of constructing application-level dissemination networks. Gryphon <ref type="bibr" target="#b4">[4]</ref> assumes that the best paths connecting the brokers are known a priori. Likewise, Siena <ref type="bibr" target="#b6">[6]</ref> also assumes that an acyclic spanning tree of the brokers is given.</p><p>More recently, XRoute <ref type="bibr" target="#b10">[10]</ref> and ONYX <ref type="bibr" target="#b15">[15]</ref> introduced efficient solutions for content-based publish/subscribe for XML data and XPath-based profiles. These systems primarily focused on efficient distributed filtering, whereas SemCast's focus is on networked dissemination. As with the SPT approach that we studied, these systems have the disadvantage of requiring contentbased filtering at the intermediate brokers. Moreover, our results showed that creating multiple dissemination trees, instead of sending all the information through a single tree, decreases the overall bandwidth consumption, even when there is low profile overlap.</p><p>Content-based routing was also studied in <ref type="bibr" target="#b16">[16]</ref>. This work refers to routing path queries, which are path expressions in an XPath-like query language, among nodes in P2P system storing XML documents. Here, the peers with similar content are clustered, and nodes are organized in a hierarchical structure, enabling fast content-driven searches.</p><p>Finally, another key difference of SemCast from previous approaches is that it leverages knowledge of stream statistics as well as profile and network characteristics in order to optimize and adapt its operation. To the best of our knowledge, previous solutions relied primarily on containment relationships identified through syntactic analysis.</p><p>Application-level multicast Many recent research proposals (e.g., <ref type="bibr" target="#b9">[9,</ref><ref type="bibr" target="#b27">27]</ref>) employ application-level multicast for efficiently delivering data to multiple receivers. Members of a multicast group typically selforganize into an overlay topology, over which dissemination trees are created. These approaches assume a traditional multicast model, where all members of the multicast group have exactly the same interests. In our context, constructing a different multicast group for each distinct profile is not a scalable solution. To avoid this scalability problem, SemCast uses containment and partial overlap relationships in the profile set, and thus can place in the same multicast channel clients with similar profiles.</p><p>Similar to SemCast, SplitStream <ref type="bibr">[8]</ref> aims to achieve high-bandwidth data dissemination by striping content across various multicast trees. However, SplitStream does not address profile-based dissemination or channelization. Bullet <ref type="bibr" target="#b17">[17]</ref> uses an overlay construction algorithm for creating a mesh over any distribution tree, improving the bandwidth throughput of the participants. As a result, SemCast can utilize the techniques introduced in this work to improve its bandwidth efficiency.</p><p>XML-based filtering using application-level overlays was investigated in <ref type="bibr" target="#b20">[20]</ref>. This work used multiple interior brokers on the overlay for redundant transmission of messages in order to reduce loss rates and delivery latencies.</p><p>Channelization The channelization problem was first studied in <ref type="bibr" target="#b2">[2]</ref> in the context of simple traffic flows and a fixed number of channels. The problem was shown to be NP-complete. In our model, the fact that the number of multicast groups is not fixed, and is dependent on the overlap among the receivers' interests, makes the problem more even harder. Topic-based semantic multicast was introduced in <ref type="bibr" target="#b12">[12]</ref>. In this work, users express their interests by indicating a specific topic area. Similarity ontologies are then used to discover more general topics served by existing channels. This work does not consider content-based routing, and the focus is not on minimizing bandwidth consumption. Finally, a preliminary design of our semantic multicast approach was presented earlier <ref type="bibr" target="#b19">[19]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusions &amp; future work</head><p>We described a novel semantic multicast system, called SemCast, which takes a radically different approach to content-based dissemination of data streams. The key idea is to split the data streams based on their contents, rates, and destinations, and spread the pieces across multiple channels, each implemented as an independent application-level dissemination tree. Because even simpler forms of the channelization problem are NPcomplete, we use a practical, efficient cost-based approach that leverages the knowledge of profile, stream, and network characteristics.</p><p>The primary advantages of the SemCast approach over traditional approaches are that (1) it does not require content-based filtering of streams at interior brokers of the overlay network, and (2) it facilitates fine-grained control over the construction of efficient dissemination trees. We argued and quantitatively demonstrated through simulations that, in addition to reducing the processing load on the system, SemCast exhibits significantly better bandwidth efficiency, compared to traditional approaches.</p><p>There are two immediate directions for future work. First, we are designing batched and priority-driven dissemination techniques to improve system throughput and effectiveness. Second, we are incorporating storage and ad hoc query functionality into SemCast.</p><p>We are currently in the process of building a SemCast prototype to verify the practicality of the basic approach and to demonstrate the claimed performance benefits through deployment on PlanetLab.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Basic SemCast system model</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Figure 3. Relative bandwidth efficiency for different approaches</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Profile overlap for varying matching probability values</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 7 .</head><label>7</label><figDesc>Figure 5. Relative bandwidth efficiency for varying profile overlap values</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 8 .</head><label>8</label><figDesc>Figure 9. Relative bandwidth efficiency for different network sizes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 . Overlap matrix</head><label>1</label><figDesc></figDesc><table><row><cell>P 1</cell><cell>P 1 1</cell><cell cols="2">P 2 P 3 0 0</cell><cell>P 4 0</cell><cell cols="2">P 5 P 6 1 1</cell><cell>P 7 0</cell></row><row><cell>P 2 P 3 P 4</cell><cell>0 0 0</cell><cell>1 1 1</cell><cell cols="3">0.4 0.5 0 1 0.6 0 1 1 0</cell><cell>0 0 1</cell><cell>0 0 1</cell></row><row><cell>P 5 P 6</cell><cell cols="2">0.8 0 0.2 0</cell><cell>0 0</cell><cell cols="2">0 0.4 0 1</cell><cell>0 1</cell><cell>0 1</cell></row><row><cell>P 7</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell cols="2">0.2 0</cell><cell>0.5 1</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Containment hierarchy from Table 1</head><label></label><figDesc></figDesc><table><row><cell></cell><cell>P 4 P 4</cell><cell>P 1 P 1</cell></row><row><cell>P 3 P 3</cell><cell>P 6 P 6</cell><cell>P 5 P 5</cell></row><row><cell>P 2 P 2</cell><cell>P 7 P 7</cell><cell></cell></row><row><cell>Figure 2.</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 . Profiles on local filtering tables (N=600, P=3000, profile selectivity factor = 2)</head><label>2</label><figDesc></figDesc><table><row><cell>Aggregated</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Profile</cell><cell>0.02</cell><cell>0.03</cell><cell>0.05</cell><cell>0.08</cell></row><row><cell>overlap</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>SPT (at hop 1)</cell><cell cols="2">5.75% 8.45%</cell><cell cols="2">10.79% 15.48%</cell></row><row><cell>SPT (at hop 2)</cell><cell cols="2">3.11% 6.44%</cell><cell>5.88%</cell><cell>9.59%</cell></row><row><cell>SemCast (at gateway)</cell><cell cols="2">0.19% 0.45%</cell><cell>0.33%</cell><cell>0.59%</cell></row></table></figure>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"> †  <p>This work is supported in part by the National Science Foundation under grant IIS-0325838.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Aurora: A Data Stream Management System (Demo)</title>
		<author>
			<persName><forename type="first">D</forename><surname>Abadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Channelization problem in large scale data dissemination</title>
		<author>
			<persName><forename type="first">M</forename><surname>Adler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICNP&apos;01</title>
		<imprint>
			<date type="published" when="2001-11">November 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Efficient Filtering of XML Documents for Selective Dissemination of Information</title>
		<author>
			<persName><forename type="first">M</forename><surname>Altinel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">An Efficient Multicast Protocol for Content-Based Publish-Subscribe Systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Banavar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDCS</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Monitoring Streams: A New Class of Data Management Applications</title>
		<author>
			<persName><forename type="first">D</forename><surname>Carney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Design and Evaluation of a Wide-Area Event Notification Service</title>
		<author>
			<persName><forename type="first">A</forename><surname>Carzaniga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="332" to="383" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Forwarding in a Content-Based Network</title>
		<author>
			<persName><forename type="first">A</forename><surname>Carzaniga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Wolf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">SplitStream: High-bandwidth content distribution in cooperative environments</title>
		<author>
			<persName><forename type="first">M</forename><surname>Castro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">SCRIBE: A large-scale and decentralized application-level multicast infrastructure</title>
		<author>
			<persName><forename type="first">M</forename><surname>Castro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in communications (JSAC)</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">8</biblScope>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A Scalable Protocol for Content-Based Routing in Overlay Networks</title>
		<author>
			<persName><forename type="first">C.-Y</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Felber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NCA</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Efficient Filtering of XML Documents with XPath Expressions</title>
		<author>
			<persName><forename type="first">C.-Y</forename><surname>Chan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB Journal, Special Issue on XML</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="354" to="379" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Semantic multicast: intelligently sharing collaborative sessions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Dao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys (CSUR)</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">2es</biblScope>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">YFilter: Efficient and Scalable Filtering of XML Documents (Demo)</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Diao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Query Processing for High-Volume XML Message Brokering</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Diao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Towards an Internet-Scale XML Dissemination Service</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Diao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Content-based Routing of Path Queries in Peer-to-Peer Systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Koloniari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Pitoura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Bullet: High Bandwidth Data Dissemination Using an Overlay Mesh</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kostic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Exploiting IP Multicast in Content-Based Publish-Subscribe Systems</title>
		<author>
			<persName><forename type="first">L</forename><surname>Opyrchal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Middleware</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Semantic Multicast for Content-Based Stream Dissemination</title>
		<author>
			<persName><forename type="first">O</forename><surname>Papaemmanouil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Cetintemel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WebDB</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Mesh-Based Content Routing using XML</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Snoeren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The Unison algorithm: fast evaluation of Boolean expressions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Sosic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TODAES</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">An Approximate Solution for the Steiner Tree Problem in Graphs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Takahashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Matsuyama</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1980">1980</date>
			<publisher>Mathematica Japonica</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">XML Path Language (XPath) 1</title>
		<author>
			<persName><surname>W3c</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">.0. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Containment for XPath fragments under DTD constraints</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">T</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Efficient Dissemination of Information on the Internet</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">W</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Garcia-Molina</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Data Eng. Bull</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="48" to="54" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">How to Model an Internetwork</title>
		<author>
			<persName><forename type="first">E</forename><surname>Zegura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INFOCOM96</title>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Bayeux: An Architecture for Scalable and Fault-tolerant Wide-area Data Dissemination</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">Q</forename><surname>Zhuang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NOSSDAV</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
