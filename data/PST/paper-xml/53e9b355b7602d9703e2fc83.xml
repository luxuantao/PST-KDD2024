<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Exploiting Choice: Instruction Fetch and Issue on an Implementable Simultaneous Multithreading Processor</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Dean</forename><forename type="middle">M</forename><surname>Tullsen</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Susan</forename><forename type="middle">J</forename><surname>Eggers</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Joel</forename><forename type="middle">S</forename><surname>Emer</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Digital Equipment Corporation University of Washington</orgName>
								<address>
									<addrLine>77 Reed Road Seattle</addrLine>
									<postBox>Box 352350</postBox>
									<postCode>HLO2-3/J3, 98195-2350, 01749</postCode>
									<settlement>Hudson</settlement>
									<region>WA, MA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Henry</forename><forename type="middle">M</forename><surname>Levy</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jack</forename><forename type="middle">L</forename><surname>Lo</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Rebecca</forename><forename type="middle">L</forename><surname>Stamm</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Digital Equipment Corporation University of Washington</orgName>
								<address>
									<addrLine>77 Reed Road Seattle</addrLine>
									<postBox>Box 352350</postBox>
									<postCode>HLO2-3/J3, 98195-2350, 01749</postCode>
									<settlement>Hudson</settlement>
									<region>WA, MA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Dept of Computer Science and Engineering</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Exploiting Choice: Instruction Fetch and Issue on an Implementable Simultaneous Multithreading Processor</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T13:10+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Simultaneous multithreading is a technique that permits multiple independent threads to issue multiple instructions each cycle. In previous work we demonstrated the performance potential of simultaneous multithreading, based on a somewhat idealized model. In this paper we show that the throughput gains from simultaneous multithreading can be achieved without extensive changes to a conventional wide-issue superscalar, either in hardware structures or sizes. We present an architecture for simultaneous multithreading that achieves three goals: (1) it minimizes the architectural impact on the conventional superscalar design, ( <ref type="formula">2</ref>) it has minimal performance impact on a single thread executing alone, and (3) it achieves significant throughput gains when running multiple threads. Our simultaneous multithreading architecture achieves a throughput of 5.4 instructions per cycle, a 2.5-fold improvement over an unmodified superscalar with similar hardware resources. This speedup is enhanced by an advantage of multithreading previously unexploited in other architectures: the ability to favor for fetch and issue those threads most efficiently using the processor each cycle, thereby providing the "best" instructions to the processor.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Simultaneous multithreading (SMT) is a technique that permits multiple independent threads to issue multiple instructions each cycle to a superscalar processor's functional units. SMT combines the multiple-instruction-issue features of modern superscalars with the latency-hiding ability of multithreaded architectures. Unlike conventional multithreaded architectures <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b22">23]</ref>, which depend on fast context switching to share processor execution resources, all hardware contexts in an SMT processor are active simultaneously, competing each cycle for all available resources. This dynamic sharing of the functional units allows simultaneous multithreading to substantially increase throughput, attacking the two major impediments to processor utilization -long latencies and limited per-thread parallelism. Tullsen, et al., <ref type="bibr" target="#b26">[27]</ref> showed the potential of Proceedings of the 23rd Annual International Symposium on Computer Architecture, Philadelphia, PA, May, 1996 an SMT processor to achieve significantly higher throughput than either a wide superscalar or a multithreaded processor. That paper also demonstrated the advantages of simultaneous multithreading over multiple processors on a single chip, due to SMT's ability to dynamically assign execution resources where needed each cycle.</p><p>Those results showed SMT's potential based on a somewhat idealized model. This paper extends that work in four significant ways. First, we demonstrate that the throughput gains of simultaneous multithreading are possible without extensive changes to a conventional, wide-issue superscalar processor. We propose an architecture that is more comprehensive, realistic, and heavily leveraged off existing superscalar technology. Our simulations show that a minimal implementation of simultaneous multithreading achieves throughput 1.8 times that of the unmodified superscalar; small tuning of this architecture increases that gain to 2.5 (reaching throughput as high as 5.4 instructions per cycle). Second, we show that SMT need not compromise single-thread performance. Third, we use our more detailed architectural model to analyze and relieve bottlenecks that did not exist in the more idealized model. Fourth, we show how simultaneous multithreading creates an advantage previously unexploitable in other architectures: namely, the ability to choose the "best" instructions, from all threads, for both fetch and issue each cycle. By favoring the threads most efficiently using the processor, we can boost the throughput of our limited resources. We present several simple heuristics for this selection process, and demonstrate how such heuristics, when applied to the fetch mechanism, can increase throughput by as much as 37%.</p><p>This paper is organized as follows. Section 2 presents our baseline simultaneous multithreading architecture, comparing it with existing superscalar technology. Section 3 describes our simulator and our workload, and Section 4 shows the performance of the baseline architecture. In Section 5, we examine the instruction fetch process, present several heuristics for improving it based on intelligent instruction selection, and give performance results to differentiate those heuristics. Section 6 examines the instruction issue process in a similar way. We then use the best designs chosen from our fetch and issue studies in Section 7 as a basis to discover bottlenecks for further performance improvement. We discuss related work in Section 8 and summarize our results in Section 9. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Instruction</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">A Simultaneous Multithreading Processor Architecture</head><p>In this section we present the architecture of our simultaneous multithreading processor. We show that the throughput gains provided by simultaneous multithreading are possible without adding undue complexity to a conventional superscalar processor design.</p><p>Our SMT architecture is derived from a high-performance, outof-order, superscalar architecture (Figure <ref type="figure" target="#fig_0">1</ref>, without the extra program counters) which represents a projection of current superscalar design trends 3-5 years into the future. This superscalar processor fetches up to eight instructions per cycle; fetching is controlled by a conventional system of branch target buffer, branch prediction, and subroutine return stacks. Fetched instructions are then decoded and passed to the register renaming logic, which maps logical registers onto a pool of physical registers, removing false dependences. Instructions are then placed in one of two instruction queues. Those instruction queues are similar to the ones used by the MIPS R10000 <ref type="bibr" target="#b19">[20]</ref> and the HP PA-8000 <ref type="bibr" target="#b20">[21]</ref>, in this case holding instructions until they are issued. Instructions are issued to the functional units out-of-order when their operands are available. After completing execution, instructions are retired in-order, freeing physical registers that are no longer needed.</p><p>Our SMT architecture is a straightforward extension to this conventional superscalar design. We made changes only when necessary to enable simultaneous multithreading, and in general, structures were not replicated or resized to support SMT or a multithreaded workload. Thus, nearly all hardware resources remain completely available even when there is only a single thread in the system. The changes necessary to support simultaneous multithreading on that architecture are: multiple program counters and some mechanism by which the fetch unit selects one each cycle, a separate return stack for each thread for predicting subroutine return destinations, per-thread instruction retirement, instruction queue flush, and trap mechanisms, a thread id with each branch target buffer entry to avoid predicting phantom branches, and a larger register file, to support logical registers for all threads plus additional registers for register renaming. The size of the register file affects the pipeline (we add two extra stages) and the scheduling of load-dependent instructions, which we discuss later in this section.</p><p>Noticeably absent from this list is a mechanism to enable simultaneous multithreaded scheduling of instructions onto the functional units. Because any apparent dependences between instructions from different threads are removed by the register renaming phase, a conventional instruction queue (IQ) designed for dynamic scheduling contains all of the functionality necessary for simultaneous multithreading. The instruction queue is shared by all threads and an instruction from any thread in the queue can issue when its operands are available.</p><p>We fetch from one program counter (PC) each cycle. The PC is chosen, in round-robin order, from among those threads not already experiencing an I cache miss. This scheme provides simultaneous multithreading at the point of issue, but only fine-grain multithreading of the fetch unit. We will look in Section 5 at ways to extend simultaneous multithreading to the fetch unit. We also investigate alternative thread priority mechanisms for fetching.</p><p>A primary impact of multithreading on our architecture is on the size of the register file. We have a single register file, as threadspecific logical registers are mapped onto a completely shared physical register file by the register renaming. To support eight threads, we need a minimum of 8*32 = 256 physical integer registers (for a 32-register instruction set architecture), plus more to enable register renaming. Access to such a large register file will be slow, almost certainly affecting the cycle time of the machine.</p><p>To account for the size of the register file, we take two cycles to read registers instead of one. In the first cycle values are read into a buffer closer to the functional units. The instruction is sent to a similar buffer at the same time. The next cycle the data is sent to a functional unit for execution. Writes to the register file are treated similarly, requiring an extra register write stage. Figure <ref type="figure" target="#fig_1">2</ref> shows the pipeline modified for two-phase register access, compared to the pipeline of the original superscalar.</p><p>The two-stage register access has several ramifications on our architecture. First, it increases the pipeline distance between fetch and exec, increasing the branch misprediction penalty by 1 cycle.  queue and exec increases the period during which wrong-path instructions remain in the pipeline after a misprediction is discovered (the misqueue penalty in Figure <ref type="figure" target="#fig_1">2</ref>). Wrong-path instructions are those instructions brought into the processor as a result of a branch misprediction. Those instructions consume instruction queue slots, renaming registers and possibly issue slots, all of which, on an SMT processor, could be used by other threads. This pipeline does not increase the inter-instruction latency between most instructions. Dependent (single-cycle latency) instructions can still be issued on consecutive cycles, for example, as long as inter-instruction latencies are predetermined. That is the case for all instructions but loads. Since we are scheduling instructions a cycle earlier (relative to the exec cycle), load-hit latency increases by one cycle (to two cycles). Rather than suffer this penalty, we schedule load-dependent instructions assuming a 1-cycle data latency, but squash those instructions in the case of an L1 cache miss or a bank conflict. There are two performance costs to this solution, which we call optimistic issue. Optimistically issued instructions that get squashed waste issue slots, and optimistic instructions must still be held in the IQ an extra cycle after they are issued, until it is known that they won't be squashed.</p><p>The last implication of the two-phase register access is that there are two more stages between rename and commit, thus increasing the minimum time that a physical register is held by an in-flight instruction. This increases the pressure on the renaming register pool.</p><p>We assume, for each machine size, enough physical registers to support all active threads, plus 100 more registers to enable renaming, both for the integer file and the floating point file; i.e., for the single-thread results, we model 132 physical integer registers, and for an 8-thread machine, 356. We expect that in the 3-5 year time-frame, the scheme we have described will remove register file access from the critical path for a 4-thread machine, but 8 threads will still be a significant challenge. Nonetheless, extending our results to an 8-thread machine allows us to see trends beyond the 4thread numbers and anticipates other solutions to this problem. The number of registers available for renaming determines the number of instructions that can be in the processor between the rename stage and the commit stage.</p><p>This architecture allows us to address several concerns about simultaneous multithreaded processor design. In particular, this paper shows that: Instruction scheduling is no more complex than on a dynamically scheduled superscalar.</p><p>Register file data paths are no more complex than in the superscalar, and the performance implications of the register file and its extended pipeline are small. The required instruction fetch throughput is attainable, even without any increase in fetch bandwidth.</p><p>Unmodified (for an SMT workload) cache and branch prediction structures do not thrash on that workload.</p><p>Even aggressive superscalar technologies, such as dynamic scheduling and speculative execution, are not sufficient to take full advantage of a wide-issue processor without simultaneous multithreading.</p><p>We have only presented an outline of the hardware architecture to this point; the next section provides more detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Hardware Details</head><p>The processor contains 3 floating point functional units and 6 integer units; four of the six integer units also execute loads and stores. The peak issue bandwidth out of the two instruction queues is therefore nine; however, the throughput of the machine is bounded by the peak fetch and decode bandwidths, which are eight instructions per cycle. We assume that all functional units are completely pipelined. Table <ref type="table" target="#tab_1">1</ref> shows the instruction latencies, which are derived from the Alpha 21164 <ref type="bibr" target="#b7">[8]</ref>.</p><p>We assume a 32-entry integer instruction queue (which handles integer instructions and all load/store operations) and a 32entry floating point queue, not significantly larger than the HP PA-8000 <ref type="bibr" target="#b20">[21]</ref>, which has two 28-entry queues.</p><p>The caches (Table <ref type="table" target="#tab_2">2</ref>) are multi-ported by interleaving them into banks, similar to the design of Sohi and Franklin <ref type="bibr" target="#b25">[26]</ref>. We model lockup-free caches and TLBs. TLB misses require two full memory accesses and no execution resources. We model the memory subsystem in great detail, simulating bandwidth limitations and access conflicts at multiple levels of the hierarchy, to address the concern that memory throughput could be a limiting condition for simultaneous multithreading. Each cycle, one thread is given control of the fetch unit, chosen from among those not stalled for an instruction cache (I cache) miss. If we fetch from multiple threads, we never attempt to fetch from threads that conflict (on an I cache bank) with each other, although they may conflict with other I cache activity (cache fills).</p><p>Branch prediction is provided by a decoupled branch target buffer (BTB) and pattern history table (PHT) scheme <ref type="bibr" target="#b3">[4]</ref>. We use a 256entry BTB, organized as four-way set associative. The 2K x 2-bit PHT is accessed by the XOR of the lower bits of the address and the global history register <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b29">30]</ref>. Return destinations are predicted with a 12-entry return stack (per context).</p><p>We assume an efficient, but not perfect, implementation of dynamic memory disambiguation. This is emulated by using only part of the address (10 bits) to disambiguate memory references, so that it is occasionally over-conservative.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Methodology</head><p>The methodology in this paper closely follows the simulation and measurement methodology of <ref type="bibr" target="#b26">[27]</ref>. Our simulator uses emulationbased, instruction-level simulation, and borrows significantly from MIPSI <ref type="bibr" target="#b21">[22]</ref>, a MIPS-based simulator. The simulator executes unmodified Alpha object code and models the execution pipelines, memory hierarchy, TLBs, and the branch prediction logic of the processor described in Section 2.</p><p>In an SMT processor a branch misprediction introduces wrongpath instructions that interact with instructions from other threads. To model this behavior, we fetch down wrong paths, introduce those instructions into the instruction queues, track their dependences, and issue them. We eventually squash all wrong-path instructions a cycle after a branch misprediction is discovered in the exec stage. Our throughput results only count useful instructions.</p><p>Our workload comes primarily from the SPEC92 benchmark suite <ref type="bibr" target="#b6">[7]</ref>. We use five floating point programs (alvinn, doduc, fpppp, ora, and tomcatv) and two integer programs (espresso and xlisp) from that suite, and the document typesetting program TeX. We assign a distinct program to each thread in the processor: the multiprogrammed workload stresses our architecture more than a parallel program by presenting threads with widely varying program characteristics and with no overlap of cache, TLB or branch prediction usage. To eliminate the effects of benchmark differences, a single data point is composed of 8 runs, each T * 300 million instructions in length, where T is the number of threads. Each of the 8 runs uses a different combination of the benchmarks.</p><p>We compile each program with the Multiflow trace scheduling compiler <ref type="bibr" target="#b16">[17]</ref>, modified to produce Alpha code. In contrast to <ref type="bibr" target="#b26">[27]</ref>, we turn off trace scheduling in the compiler for this study, for two reasons. In our measurements, we want to differentiate between useful and useless speculative instructions, which is easy with hardware speculation, but not possible for software speculation with our system. Also, software speculation is not as beneficial on an architecture which features hardware speculation, and in some cases is harmful. However, the Multiflow compiler is still a good choice for our compilation engine, because of the high quality of the loop unrolling, instruction scheduling and alignment, and other optimizations, as well as the ease with which the machine model can be changed. The benchmarks are compiled to optimize single-thread performance on the base hardware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Performance of the Base Hardware Design</head><p>In this section we examine the performance of the base architecture and identify opportunities for improvement. Figure <ref type="figure" target="#fig_3">3</ref> shows that with only a single thread running on our SMT architecture, the throughput is less than 2% below a superscalar without SMT support. The drop in throughput is due to the longer pipeline (described in Section 2) used by the SMT processor. Its peak throughput is 84% higher than the superscalar. This gain is achieved with virtually no tuning of the base architecture for simultaneous multithreading. This design combines low single-thread impact with high speedup for even a few threads, enabling simultaneous multithreading to reap benefits even in an environment where multiple processes are running only a small fraction of the time. We also note, however, that the throughput peaks before 8 threads, and the processor utilization, at less than 50% of the 8-issue processor, is well short of the potential shown in <ref type="bibr" target="#b26">[27]</ref>.</p><p>We make several conclusions about the potential bottlenecks of this system as we approach 8 threads, aided by Figure <ref type="figure" target="#fig_3">3</ref> and Table <ref type="table" target="#tab_4">3</ref>. Issue bandwidth is clearly not a bottleneck, as the throughput represents a fraction of available issue bandwidth, and our data shows that no functional unit type is being overloaded. We appear to have enough physical registers. The caches and branch prediction logic are being stressed more heavily at 8 threads, but we expect the latency-hiding potential of the additional threads to make up for those drops. The culprit appears to be one or more of the following three problems: (1) IQ size -IQ-full conditions are common, 12 to 21% of cycles total for the two queues; (2) fetch throughputeven in those cycles where we don't experience an IQ-full condition, our data shows that we are sustaining only 4.2 useful instructions fetched per cycle (4.5 including wrong-path); and (3) lack of parallelism -although the queues are reasonably full, we find fewer  than four out of, on average, 27 instructions per cycle to issue. We expect eight threads to provide more parallelism, so perhaps we have the wrong instructions in the instruction queues.</p><p>The rest of this paper focuses on improving this base architecture. The next section addresses each of the problems identified here with different fetch policies and IQ configurations. Section 6 examines ways to prevent issue waste,and Section 7 re-examines the improved architecture for new bottlenecks, identifying directions for further improvement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">The Fetch Unit -In Search of Useful Instructions</head><p>In this section we examine ways to improve fetch throughput without increasing the fetch bandwidth. Our SMT architecture shares a single fetch unit among eight threads. We can exploit the high level of competition for the fetch unit in two ways not possible with singlethreaded processors: (1) the fetch unit can fetch from multiple threads at once, increasing our utilization of the fetch bandwidth, and (2) it can be selective about which thread or threads to fetch from. Because not all paths provide equally useful instructions in a particular cycle, an SMT processor can benefit by fetching from the thread(s) that will provide the best instructions. We examine a variety of fetch architectures and fetch policies that exploit those advantages. Specifically, they attempt to improve fetch throughput by addressing three factors: fetch efficiency, by partitioning the fetch unit among threads (Section 5.1); fetch effectiveness, by improving the quality of the instructions fetched (Section 5.2); and fetch availability, by eliminating conditions that block the fetch unit (Section 5.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Partitioning the Fetch Unit</head><p>Recall that our baseline architecture fetches up to eight instructions from one thread each cycle. The frequency of branches in typical instruction streams and the misalignment of branch destinations make it difficult to fill the entire fetch bandwidth from one thread,  even for smaller block sizes <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b23">24]</ref>. In this processor, we can spread the burden of filling the fetch bandwidth among multiple threads. For example, the probability of finding four instructions from each of two threads should be greater than that of finding eight from one thread.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Number of Threads</head><p>In this section, we attempt to reduce fetch block fragmentation (our term for the various factors that prevent us from fetching the maximum number of instructions) by fetching from multiple threads each cycle, while keeping the maximum fetch bandwidth (but not necessarily the I cache bandwidth) constant. We evaluate several fetching schemes, which are labeled alg.num1.num2, where alg is the fetch selection method (in this section threads are always selected using a round-robin priority scheme), num1 is the number of threads that can fetch in 1 cycle, and num2 is the maximum number of instructions fetched per thread in 1 cycle. The maximum number of total instructions fetched is always limited to eight. For each of the fetch partitioning policies, the cache is always 32 kilobytes organized into 8 data banks; a given bank can do just one access per cycle.</p><p>RR.1.8 -This is the baseline scheme from Section 4. Each cycle one thread fetches as many as eight instructions. The thread is determined by a round-robin priority scheme from among those not currently suffering an I cache miss. In this scheme the I cache is indistinguishable from that on a single-threaded superscalar. Each cache bank has its own address decoder and output drivers; each cycle, only one of the banks drives the cache output bus, which is 8 instructions (32 bytes) wide.</p><p>RR.2.4, RR.4.2 -These schemes fetch fewer instructions per thread from more threads (four each from two threads, or two each from four threads). If we try to partition the fetch bandwidth too finely, however, we may suffer thread shortage,where fewer threads are available than are required to fill the fetch bandwidth.</p><p>For these schemes, multiple cache addresses are driven to each cache data bank, each of which now has a multiplexer before its address decoder, to select one cache index per cycle. Since the cache banks are single-ported, bank-conflict logic is needed to ensure that each address targets a separate bank. RR. buses, each four instructions wide, while RR.4.2 has four output buses, each two instructions wide. For both schemes, the total width of the output buses is 8 instructions (identical to that in RR.1.8), but additional circuitry is needed so each bank is capable of driving any of the multiple (now smaller) output buses, and is able to select one or none to drive in a given cycle. Also, the cache tag store logic must be replicated or multiple-ported in order to calculate hit/miss for each address looked up per cycle.</p><p>Thus, the hardware additions are: the address mux; multiple address buses; selection logic on the output drivers; the bank conflict logic; and multiple hit/miss calculations. The changes required for RR.2.4 would have a negligible impact on area and cache access time. The changes for RR.4.2 are more extensive, and would be more difficult to do without affecting area or access time. These schemes actually reduce the latency in the decode and rename stages, as the maximum length of dependency chains among fetched instructions is reduced by a factor of 2 and 4, respectively.</p><p>RR.2.8 -This scheme attacks fetch block fragmentation without suffering from thread shortage by fetching eight instructions more flexibly from two threads. This can be implemented by reading an eight-instruction block for each thread (16 instructions total), then combining them. We take as many instructions as possible from the first thread, then fill in with instructions from the second, up to eight total. Like RR.2.4, two addresses must be routed to each cache bank, then multiplexed before the decoder; bank-conflict logic and two hit/miss calculations per cycle are necessary; and each bank drives one of the two output buses. Now, however, each output bus is eight instructions wide, which doubles the bandwidth out of the cache compared to any of the previous schemes. This could be done without greatly affecting area or cycle time, as the additional bussing could probably be done without expanding the cache layout. In addition, logic to select and combine the instructions is necessary, which might or might not require an additional pipe stage. Our simulations assume it does not.</p><p>Figure <ref type="figure" target="#fig_4">4</ref> shows that we can get higher maximum throughput by splitting the fetch over multiple threads. For example, the RR.2.4 scheme outperforms RR.1.8 at 8 threads by 9%. However, better maximum throughput comes at the cost of a 12% single-thread penalty; in fact, RR.2.4 does not surpass RR.1.8 until 4 threads. The RR.4.2 scheme needs 6 threads to surpass RR.1.8 and never catches the 2-thread schemes, suffering from thread shortage.</p><p>The RR.2.8 scheme provides the best of both worlds: fewthreads performance like RR.1.8 and many-threads performance like RR.2.4. However, the higher throughput of this scheme puts more pressure on the instruction queues, causing IQ-full conditions at a rate of 18% (integer) and 8% (fp) with 8 threads.</p><p>With the RR.2.8 scheme we have improved the maximum throughput by 10% without compromising single-thread performance. This was achieved by a combination of (1) partitioning the fetch bandwidth over multiple threads, and (2) making that partition flexible. This is the same approach (although in a more limited fashion here) that simultaneous multithreading uses to improve the throughput of the functional units <ref type="bibr" target="#b26">[27]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Exploiting Thread Choice in the Fetch Unit</head><p>The efficiency of the entire processor is affected by the quality of instructions fetched. A multithreaded processor has a unique ability to control that factor. In this section, we examine fetching policies aimed at identifying the "best" thread or threads available to fetch each cycle. Two factors make one thread less desirable than another. The first is the probability that a thread is following a wrong path as a result of an earlier branch misprediction. Wrong-path instructions consume not only fetch bandwidth, but also registers, IQ space, and possibly issue bandwidth. The second factor is the length of time the fetched instructions will be in the queue before becoming issuable. We maximize the throughput of a queue of bounded size by feeding it instructions that will spend the least time in the queue. If we fetch too many instructions that block for a long time, we eventually fill the IQ with unissuable instructions, a condition we call IQ clog. This restricts both fetch and issue throughput, causing the fetch unit to go idle and preventing issuable instructions from getting into the IQ. Both of these factors (wrong-path probability and expected queue time) improve over time, so a thread becomes more desirable as we delay fetching it.</p><p>We define several fetch policies, each of which attempts to improve on the round-robin priority policy using feedback from other parts of the processor. The first attacks wrong-path fetching, the others attack IQ clog. They are:</p><p>BRCOUNT -Here we attempt to give highest priority to those threads that are least likely to be on a wrong path. We do this by counting branch instructions that are in the decode stage, the rename stage, and the instruction queues, favoring those with the fewest unresolved branches.</p><p>MISSCOUNT -This policy detects an important cause of IQ clog. A long memory latency can cause dependent instructions to back up in the IQ waiting for the load to complete, eventually filling the queue with blocked instructions from one thread. This policy prevents that by giving priority to those threads that have the fewest outstanding D cache misses.</p><p>ICOUNT -This is a more general solution to IQ clog. Here priority is given to threads with the fewest instructions in decode, rename, and the instruction queues. This achieves three purposes: (1) it prevents any one thread from filling the IQ, <ref type="bibr" target="#b1">(2)</ref>   priority to threads that are moving instructions through the IQ most efficiently, and (3) it provides a more even mix of instructions from the available threads, maximizing the parallelism in the queues. If cache misses are the dominant cause of IQ clog, MISSCOUNT may perform better, since it gets cache miss feedback to the fetch unit more quickly. If the causes are more varied, ICOUNT should perform better. IQPOSN -Like ICOUNT, IQPOSN strives to minimize IQ clog and bias toward efficient threads. It gives lowest priority to those threads with instructions closest to the head of either the integer or floating point instruction queues (the oldest instruction is at the head of the queue). Threads with the oldest instructions will be most prone to IQ clog, and those making the best progress will have instructions farthest from the head of the queue. This policy does not require a counter for each thread, as do the previous three policies.</p><p>Like any control system, the efficiency of these mechanisms is limited by the feedback latency resulting, in this case, from feeding data from later pipeline stages back to the fetch stage. For example, by the time instructions enter the queue stage or the exec stage, the information used to fetch them is three or (at least) six cycles old, respectively.</p><p>Both the branch-counting and the miss-counting policies tend to produce frequent ties. In those cases, the tie-breaker is round-robin priority.</p><p>Figure <ref type="figure" target="#fig_5">5</ref> shows that all of the fetch heuristics provide speedup over round-robin. Branch counting and cache-miss counting provide moderate speedups, but only when the processor is saturated with many threads. Instruction counting, in contrast, produces more significant improvements regardless of the number of threads. IQ-POSN provides similar results to ICOUNT, being within 4% at all times, but never exceeding it.</p><p>The branch-counting heuristic does everything we ask of it. It reduces wrong-path instructions, from 8.2% of fetched instructions to 3.6%, and from 3.6% of issued instructions to 0.8% (RR.1.8 vs.</p><p>BRCOUNT.1.8 with eight threads). And it improves throughput by as much as 8%. Its weakness is that the wrong-path problem it solves is not large on this processor, which has already attacked the problem with simultaneous multithreading. Even with the RR scheme, simultaneous multithreading reduces fetched wrong-path instructions from 16% with one thread to 8% with 8 threads.</p><p>Cache miss counting also achieves throughput gains as high as 8% over RR, but in general the gains are much lower. It is not particularly effective at reducing IQ clog, as we get IQ-full conditions 12% of the time on the integer queue and 14% on the floating point queue (for MISSCOUNT.2.8 with 8 threads). These results indicate that IQ clog is more than simply the result of long memory latencies.  <ref type="table">4</ref>: Some low-level metrics for the round-robin and instruction-counting priority policies (and the 2.8 fetch partitioning scheme).</p><p>The instruction-counting heuristic provides instruction throughput as high as 5.3 instructions per cycle, a throughput gain over the unmodified superscalar of 2.5. It outperforms the best round-robin result by 23%. Instruction counting is as effective at 2 and 4 threads (in benefit over round-robin) as it is at 8 threads. It nearly eliminates IQ clog (see IQ-full results in Table <ref type="table">4</ref>) and greatly improves the mix of instructions in the queues (we are finding more issuable instructions despite having fewer instructions in the two queues). Intelligent fetching with this heuristic is of greater benefit than partitioning the fetch unit, as the ICOUNT.1.8 scheme consistently  Table <ref type="table">4</ref> points to a surprising result. As a result of simultaneous multithreaded instruction issue and the ICOUNT fetch heuristics,we actually put less pressure on the same instruction queue with eight threads than with one, having sharply reduced IQ-full conditions. It also reduces pressure on the register file (vs. RR) by keeping fewer instructions in the queue.</p><p>BRCOUNT and ICOUNT each solve different problems, and perhaps the best performance could be achieved from a weighted combination of them; however, the complexity of the feedback mechanism increases as a result. By itself, instruction counting clearly provides the best gains.</p><p>Given our measurement methodology, it is possible that the throughput increases could be overstated if a fetch policy simply favors those threads with the most inherent instruction-level parallelism or the best cache behavior, thus achieving improvements that would not be seen in practice. However, with the ICOUNT.2.8 policy, the opposite happens. Our results show that this scheme favors threads with lower single-thread ILP, thus its results include a higher sample of instructions from the slow threads than either the superscalar results or the RR results. If anything, then, the ICOUNT.2.8 improvements are understated.</p><p>In summary, we have identified a simple heuristic that is very successful at identifying the best threads to fetch. Instruction counting dynamically biases toward threads that will use processor resources most efficiently, thereby improving processor throughput as well as relieving pressure on scarce processor resources: the instruction queues and the registers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Unblocking the Fetch Unit</head><p>By fetching from multiple threads and using intelligent fetch heuristics, we have significantly increased fetch throughput and efficiency. The more efficiently we are using the fetch unit, the more we stand to lose when it becomes blocked. In this section we examine schemes that prevent two conditions that cause the fetch unit to miss fetch opportunities, specifically IQ-full conditions and I cache misses. The two schemes are:</p><p>BIGQ -The primary restriction on IQ size is not the chip area, but the time to search it; therefore we can increase its size as long as we don't increase the search space. In this scheme, we double the sizes of the instruction queues, but only search the first 32 entries for issue. This scheme allows the queues to buffer instructions from the fetch unit when the IQ overflows.</p><p>ITAG -When a thread is selected for fetching but experiences a cache miss, we lose the opportunity to fetch that cycle. If we do the I cache tag lookups a cycle early, we can fetch around cache misses: cache miss accesses are still started immediately, but only nonmissing threads are chosen for fetch. Because we need to have the fetch address a cycle early, we essentially add a stage to the front of the pipeline, increasing the misfetch and mispredict penalties. This scheme requires one or more additional ports on the I cache tags, so that potential replacement threads can be looked up at the same time.</p><p>Although the BIGQ scheme improves the performance of the round-robin scheme (not shown), 1.5-2% across the board, Figure <ref type="figure" target="#fig_7">6</ref> shows that the bigger queues add no significant improvement to the ICOUNT policy. In fact, it is actually detrimental for several thread configurations. This is because the buffering effect of the big queue scheme brings instructions into the issuable part of the instruction queue that may have been fetched many cycles earlier, using priority information that is now out-of-date. The results indicate that using up-to-date priority information is more important than buffering.</p><p>These results show that intelligent fetch heuristics have made the extra instruction queue hardware unnecessary. The bigger queue by itself is actually less effective at reducing IQ clog than the ICOUNT scheme. With 8 threads, the bigger queues alone (BIGQ,RR.2.8) reduce IQ-full conditions to 11% (integer) and 0% (fp), while instruction counting alone (ICOUNT.2.8) reduces them to 6% and 1%. Combining BIGQ and ICOUNT drops them to 3% and 0%.</p><p>Early I cache tag lookup boosts throughput as much as 8% over ICOUNT. It is most effective when fetching one thread (ICOUNT.1.8, where the cost of a lost fetch slot is greater). However, it improves the ICOUNT.2.8 results no more than 2%, as the flexibility of the 2.8 scheme already hides some of the lost fetch bandwidth. In addition, ITAG lowers throughput with few threads, where competition for the fetch slots is low and the cost of the longer misprediction penalty is highest. Using a combination of partitioning the fetch unit, intelligent fetching, and early I cache tag lookups, we have raised the peak performance of the base SMT architecture by 37% (5.4 instructions per cycle vs. 3.9). Our maximum speedup relative to a conventional superscalar has gone up proportionately, from 1.8 to 2.5 times the throughput. That gain comes from exploiting characteristics of a simultaneous multithreading processor not available to a singlethreaded machine.</p><p>High fetch throughput makes issue bandwidth a more critical resource. We focus on this factor in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Choosing Instructions For Issue</head><p>Much as the fetch unit in a simultaneous multithreading processor can take advantage of the ability to choose which threads to fetch, the issue logic has the ability to choose instructions for issue. A dynamically scheduled single-threaded processor may have enough ready instructions to be able to choose between them, but with an SMT processor the options are more diverse. Also, because we higher throughput than a single-threaded superscalar processor, the issue bandwidth is potentially a more critical resource, so avoiding issue slot waste may be more beneficial.</p><p>In this section, we examine issue priority policies aimed at preventing issue waste. Issue slot waste comes from two sources, wrong-path instructions (resulting from mispredicted branches) and optimistically issued instructions. Recall (from Section 2) that we optimistically issue load-dependent instructions a cycle before we have D cache hit information. In the case of a cache miss or bank conflict, we have to squash the optimistically issued instruction, wasting that issue slot.</p><p>In a single-threaded processor, choosing instructions least likely to be on a wrong path is always achieved by selecting the oldest instructions (those deepest into the instruction queue). In a simultaneous multithreading processor, the position of an instruction in the queue is no longer the best indicator of the level of speculation of that instruction, as right-path instructions are intermingled in the queues with wrong-path.</p><p>The policies we examine are OLDEST FIRST, our default issue algorithm up to this point, OPT LAST and SPEC LAST, which only issue optimistic and speculative instructions (more specifically, any instruction behind a branch from the same thread in the instruction queue), respectively, after all others have been issued, and BRANCH FIRST, which issues branches as early as possible in order to identify mispredicted branches quickly. The default fetch algorithm for each of these schemes is ICOUNT.2.8.</p><p>The strong message of Table <ref type="table" target="#tab_7">5</ref> is that issue bandwidth is not yet a bottleneck. Even when it does become a critical resource, the amount of improvement we get from not wasting it is likely to be bounded by the percentage of our issue bandwidth given to useless instructions, which currently stands at 7% (4% wrong-path instructions, 3% squashed optimistic instructions). Because we don't often have more issuable instructions than functional units, we aren't able to and don't need to reduce that significantly. The SPEC LAST scheme is unable to reduce the number of useless instructions at all, while OPT LAST brings it down to 6%. BRANCH FIRST actually increases it to 10%, as branch instructions are often loaddependent; therefore, issuing them as early as possible often means issuing them optimistically. A combined scheme (OPT LAST and BRANCH FIRST) might reduce that side effect, but is unlikely to have much effect on throughput.</p><p>Since each of the alternate schemes potentially introduces multiple passes to the IQ search, it is convenient that the simplest mechanism still works well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Where Are the Bottlenecks Now?</head><p>We have shown that proposed changes to the instruction queues and the issue logic are unnecessary to achieve the best performance with this architecture, but that significant gains can be produced by moderate changes to the instruction fetch mechanisms. Here we examine that architecture more closely (using ICOUNT.2.8 as our new baseline), identifying likely directions for further improvements.</p><p>In this section we present results of experiments intended to identify bottlenecks in the new design. For components that are potential bottlenecks, we quantify the size of the bottleneck by measuring the impact of relieving it. For some of the components that are not bottlenecks, we examine whether it is possible to simplify those components without creating a bottleneck. Because we are identifying bottlenecks rather than proposing architectures, we are no longer bound by implementation practicalities in these experiments.</p><p>The Issue Bandwidth -The experiments in Section 6 indicate that issue bandwidth is not a bottleneck. In fact, we found that even an infinite number of functional units increases throughput by only 0.5% at 8 threads.</p><p>Instruction Queue Size -Results in Section 5 would, similarly, seem to imply that the size of the instruction queues was not a bottleneck, particularly with instruction counting; however, the schemes we examined are not the same as larger, searchable queues, which would also increase available parallelism. Nonetheless, the exper-iment with larger (64-entry) queues increased throughput by less than 1%, despite reducing IQ-full conditions to 0%.</p><p>Fetch Bandwidth -Although we have significantly improved fetch throughput, it is still a prime candidate for bottleneck status. Branch frequency and PC alignment problems still prevent us from fully utilizing the fetch bandwidth. A scheme that allows us to fetch as many as 16 instructions (up to eight each from two threads), increases throughput 8% to 5.7 instructions per cycle. At that point, however, the IQ size and the number of physical registers each become more of a restriction. Increasing the instruction queues to 64 entries and the excess registers to 140 increases performance another 7% to 6.1 IPC. These results indicate that we have not yet completely removed fetch throughput as a performance bottleneck.</p><p>Branch Prediction -Simultaneous multithreading has a dual effect on branch prediction, much as it has on caches. While it puts more pressure on the branch prediction hardware (see Table <ref type="table" target="#tab_4">3</ref>), it is more tolerant of branch mispredictions. This tolerance arises because SMT is less dependent on techniques that expose singlethread parallelism (e.g., speculative fetching and speculative execution based on branch prediction) due to its ability to exploit inter-thread parallelism. With one thread running, on average 16% of the instructions we fetch and 10% of the instructions we execute are down a wrong path. With eight threads running and the ICOUNT fetch scheme, only 9% of the instructions we fetch and 4% of the instructions we execute are wrong-path.</p><p>Perfect branch prediction boosts throughput by 25% at 1 thread, 15% at 4 threads, and 9% at 8 threads. So despite the significantly decreased efficiency of the branch prediction hardware, simultaneous multithreading is much less sensitive to the quality of the branch prediction than a single-threaded processor. Still, better branch prediction is beneficial for both architectures. Significant improvements come at a cost, however; a better scheme than our baseline (doubling the size of both the BTB and PHT) yields only a 2% gain at 8 threads.</p><p>Speculative Execution -The ability to do speculative execution on this machine is not a bottleneck, but we would like to know whether eliminating it would create one. The cost of speculative execution (in performance) is not particularly high (again, 4% of issued instructions are wrong-path), but the benefits may not be either.</p><p>Speculative execution can mean two different things in an SMT processor, (1) the ability to issue wrong-path instructions that can interfere with others, and (2) the ability to allow instructions to issue before preceding branches from the same thread. In order to guarantee that no wrong-path instructions are issued, we need to delay instructions 4 cycles after the preceding branch is issued. Doing this reduces throughput by 7% at 8 threads, and 38% at 1 thread. Simply preventing instructions from passing branches only lowers throughput 1.5% (vs. 12% for 1 thread). Simultaneous multithreading (with many threads) benefits much less from speculative execution than a single-threaded processor; it benefits more from the ability to issue wrong-path instructions than from allowing instructions to pass branches.</p><p>Memory Throughput -While simultaneous multithreading hides memory latencies effectively, it is less effective if the problem is memory throughput, since it does not address that problem. For that reason, our simulator models memory throughput limitations at multiple levels of the cache hierarchy, and the buses between them. With our workload, we never saturate any single cache or bus, but in some cases there are significant queueing delays for certain levels of the cache. If we had infinite bandwidth caches (i.e., the same cache latencies, but no cache bank or bus conflicts), the throughput would only increase by 3%.</p><p>Register File Size -The number of registers required by this machine is a very significant issue. While we have modeled the effects of register renaming, we have not set the number of physical registers low enough that it is a significant bottleneck. In fact, setting the number of excess registers to infinite instead of 100 only improves 8-thread performance by 2%. Lowering it to 90 reduces performance by 1%, and to 80 by 3%, and 70 by 6%, so there is no sharp drop-off point. The ICOUNT fetch scheme is probably a factor in this, as we've shown that it creates more parallelism with fewer instructions in the machine. With four threads and fewer excess registers, the reductions were nearly identical.  However, this does not completely address the total size of the register file, particularly when comparing different numbers of threads.</p><p>An alternate approach is to examine the maximize performance achieved with a given set of physical registers. For example, if we identify the largest register file that could support the scheme outlined in Section 2, then we can investigate how many threads to support for the best performance. The tradeoff arises because supporting more hardware contexts leaves fewer (excess) registers available for renaming. The number of renaming registers, however, determines the total number of instructions the processor can have in-flight. It is difficult to predict the right register file size that far into the future, but in Figure <ref type="figure" target="#fig_9">7</ref> we illustrate this type of analysis by finding the performance achieved with 200 physical registers. That equates to a 1-thread machine with 168 excess registers or a 4-thread machine with 72 excess registers, for example. In this case there is a clear maximum point at 4 threads.</p><p>In summary, fetch throughput is still a bottleneck in our proposed architecture. It may no longer be appropriate to keep fetch and issue bandwidth in balance, given the much greater difficulty of filling the fetch bandwidth. Also, register file access time will likely be a limiting factor in the number of threads an architecture can support.</p><p>A number of other architectures have been proposed that exhibit simultaneous multithreading in some form. Tullsen, et al., <ref type="bibr" target="#b26">[27]</ref> demonstrated the potential for simultaneous multithreading, but did not simulate a complete architecture, nor did that paper present a specific solution to register file access or instruction scheduling. This paper presents an architecture that realizes much of the potential demonstrated by that work, simulating it in detail.</p><p>Hirata, et al., <ref type="bibr" target="#b12">[13]</ref> present an architecture for a multithreaded superscalar processor and simulate its performance on a parallel ray-tracing application. They do not simulate caches or TLBs and their architecture has no branch prediction mechanism. Yamamoto, et al., <ref type="bibr" target="#b28">[29]</ref> present an analytical model of multithreaded superscalar performance, backed up by simulation. Their study models perfect branching, perfect caches and a homogeneous workload (all threads running the same trace). Yamamoto and Nemirovsky <ref type="bibr" target="#b27">[28]</ref> simulate an SMT architecture with separate instruction queues and up to four threads. Gulati and Bagherzadeh <ref type="bibr" target="#b10">[11]</ref> model a 4-issue machine with four hardware contexts and a single compiler-partitioned register file.</p><p>Keckler and Dally <ref type="bibr" target="#b13">[14]</ref> and Prasadh and Wu <ref type="bibr" target="#b18">[19]</ref> describe architectures that dynamically interleave operations from VLIW instructions onto individual functional units.</p><p>Daddis and Torng <ref type="bibr" target="#b5">[6]</ref> plot increases in instruction throughput as a function of the fetch bandwidth and the size of the dispatch stack, a structure similar to our instruction queue. Their system has two threads, unlimited functional units, and unlimited issue bandwidth.</p><p>In addition to these, Beckmann and Polychronopoulus <ref type="bibr" target="#b2">[3]</ref>, Gunther <ref type="bibr" target="#b11">[12]</ref>, Li and Chu <ref type="bibr" target="#b15">[16]</ref>, and Govindarajan, et al., <ref type="bibr" target="#b9">[10]</ref> all discuss architectures that feature simultaneous multithreading, none of which can issue more than one instruction per cycle per thread.</p><p>Our work is distinguished from most of these studies in our dual goals of maintaining high single-thread performance and minimizing the architectural impact on a conventional processor. For example, two implications of those goals in our architecture are limited fetch bandwidth and a centralized instruction scheduling mechanism based on a conventional instruction queue.</p><p>Most of these studies either model infinite fetch bandwidth (with perfect caches) or high-bandwidth instruction fetch, each context fetching from a private cache. However, Hirata, et al., and Daddis and Torng both model limited fetch bandwidth (with zero-latency memory), using round-robin priority, our baseline mechanism; neither model the instruction cache, however. Gulati and Bagherzadeh fetch from a single thread each cycle, and even look at thread selection policies, but find no policy with improvement better than intelligent round robin.</p><p>Also, only a few of these studies use any kind of centralized scheduling mechanism: Yamamoto, et al., model a global instruction queue that only holds ready instructions; Govindarajan, et al., and Beckmann and Polychronopoulus have central queues, but threads are very restricted in the number of instructions they can have active at once; Daddis and Torng model an instruction queue similar to ours, but they do not couple that with a realistic model of functional units, instruction latencies, or memory latencies. Gulati and Bagherzadeh model an instruction window composed of fourinstruction blocks, each block holding instructions from a single thread.</p><p>The M-Machine <ref type="bibr" target="#b8">[9]</ref> and the Multiscalar project <ref type="bibr" target="#b24">[25]</ref> combine multiple-issue with multithreading, but assign work onto processors at a coarser level than individual instructions. Tera <ref type="bibr" target="#b1">[2]</ref> combines LIW with fine-grain multithreading.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Summary</head><p>This paper presents a simultaneous multithreading architecture that: borrows heavily from conventional superscalar design, requiring little additional hardware support, minimizes the impact on single-thread performance, running only 2% slower in that scenario, and achieves significant throughput improvements over the superscalar when many threads are running: a 2.5 throughput gain at 8 threads, achieving 5.4 IPC.</p><p>The fetch improvements result from two advantagesof simultaneous multithreading unavailable to conventionalprocessors: the ability to partition the fetch bandwidth over multiple threads, and the ability to dynamically select for fetch those threads that are using processor resources most efficiently.</p><p>Simultaneous multithreading achieves multiprocessor-type speedups without multiprocessor-type hardware explosion. This architecture achieves significant throughput gains over a superscalar using the same cache sizes,fetch bandwidth, branch prediction hardware, functional units, instruction queues, and TLBs. The SMT processor is actually less sensitive to instruction queue and branch prediction table sizes than the single-thread superscalar, even with a multiprogrammed workload.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Our base simultaneous multithreading hardware architecture.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: The pipeline of (a) a conventional superscalar processor and (b) that pipeline modified for an SMT processor, along with some implications of those pipelines.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Instruction throughput for the base hardware architecture.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Instruction throughput for the different instruction cache interfaces with round-robin instruction scheduling.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Instruction throughput for fetching based on several priority heuristics, all compared to the baseline round-robin scheme. The results for 1 thread are the same for all schemes, and thus not shown.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Instruction throughput for the 64-entry queue and early I cache tag lookup, when coupled with the ICOUNT fetch policy. outperforms RR.2.8.Table4points to a surprising result. As a result of simultaneous multithreaded instruction issue and the ICOUNT fetch heuristics,we actually put less pressure on the same instruction queue with eight threads than with one, having sharply reduced IQ-full conditions. It also reduces pressure on the register file (vs. RR) by keeping fewer instructions in the queue.BRCOUNT and ICOUNT each solve different problems, and perhaps the best performance could be achieved from a weighted combination of them; however, the complexity of the feedback mechanism increases as a result. By itself, instruction counting clearly provides the best gains.Given our measurement methodology, it is possible that the throughput increases could be overstated if a fetch policy simply favors those threads with the most inherent instruction-level parallelism or the best cache behavior, thus achieving improvements that would not be seen in practice. However, with the ICOUNT.2.8 policy, the opposite happens. Our results show that this scheme favors threads with lower single-thread ILP, thus its results include a higher sample of instructions from the slow threads than either the superscalar results or the RR results. If anything, then, the ICOUNT.2.8 improvements are understated.In summary, we have identified a simple heuristic that is very successful at identifying the best threads to fetch. Instruction counting dynamically biases toward threads that will use processor resources most efficiently, thereby improving processor throughput as well as relieving pressure on scarce processor resources: the instruction queues and the registers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Instruction throughput for machines with 200 physical registers and from 1 to 5 hardware contexts.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Second, it takes an extra cycle to write back results, requiring an extra level of bypass logic. Third, increasing the distance between</figDesc><table><row><cell></cell><cell></cell><cell cols="5">mispredict penalty 6 cycles</cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="3">misfetch penalty 2 cycles</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>Fetch</cell><cell>Decode</cell><cell>Rename</cell><cell>Queue</cell><cell cols="2">Reg Read</cell><cell>Exec</cell><cell>Commit</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="5">register usage 4 cycle minimum</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>(a)</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="3">mispredict penalty 7 cycles</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="3">misfetch penalty 2 cycles</cell><cell cols="5">misqueue penalty 4 cycles</cell><cell></cell></row><row><cell>Fetch</cell><cell>Decode</cell><cell>Rename</cell><cell>Queue</cell><cell cols="2">Reg Read</cell><cell>Reg Read</cell><cell>Exec</cell><cell>Reg Write</cell><cell>Commit</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="4">register usage 6 cycle minimum</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>(b)</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 : Simulated instruction latencies</head><label>1</label><figDesc></figDesc><table><row><cell cols="3">Instruction Class</cell><cell cols="2">Latency</cell></row><row><cell cols="2">integer multiply</cell><cell></cell><cell cols="2">8,16</cell></row><row><cell cols="3">conditional move</cell><cell>2</cell><cell></cell></row><row><cell cols="2">compare</cell><cell></cell><cell>0</cell><cell></cell></row><row><cell cols="2">all other integer</cell><cell></cell><cell>1</cell><cell></cell></row><row><cell cols="2">FP divide</cell><cell></cell><cell cols="2">17,30</cell></row><row><cell cols="2">all other FP</cell><cell></cell><cell>4</cell><cell></cell></row><row><cell cols="2">load (cache hit)</cell><cell></cell><cell>1</cell><cell></cell></row><row><cell></cell><cell>ICache</cell><cell cols="2">DCache</cell><cell>L2</cell><cell>L3</cell></row><row><cell>Size</cell><cell>32 KB</cell><cell cols="2">32 KB</cell><cell cols="2">256 KB 2 MB</cell></row><row><cell>Associativity</cell><cell>DM</cell><cell cols="2">DM</cell><cell>4-way</cell><cell>DM</cell></row><row><cell>Line Size</cell><cell>64</cell><cell>64</cell><cell></cell><cell>64</cell><cell>64</cell></row><row><cell>Banks</cell><cell>8</cell><cell>8</cell><cell></cell><cell>8</cell><cell>1</cell></row><row><cell>Transfer time</cell><cell>1 cycle</cell><cell>1</cell><cell></cell><cell>1</cell><cell>4</cell></row><row><cell cols="2">Accesses/cycle var (1-4)</cell><cell>4</cell><cell></cell><cell>1</cell><cell>1/4</cell></row><row><cell>Cache fill time</cell><cell>2 cycles</cell><cell>2</cell><cell></cell><cell>2</cell><cell>8</cell></row><row><cell>Latency to</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>next level</cell><cell>6</cell><cell>6</cell><cell></cell><cell>12</cell><cell>62</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 : Details of the cache hierarchy</head><label>2</label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 : The result of increased multithreading on some low- level metrics for the base architecture.</head><label>3</label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 5 : Instruction throughput (instructions per cycle) for the issue priority schemes, and the percentage of useless instructions issued when running with 8 threads.</head><label>5</label><figDesc></figDesc><table><row><cell>Issue</cell><cell></cell><cell cols="3">Number of Threads</cell><cell></cell><cell cols="2">Useless Instructions</cell></row><row><cell>Method</cell><cell>1</cell><cell>2</cell><cell>4</cell><cell>6</cell><cell>8</cell><cell cols="2">wrong-path optimistic</cell></row><row><cell>OLDEST</cell><cell cols="5">2.10 3.30 4.62 5.09 5.29</cell><cell>4%</cell><cell>3%</cell></row><row><cell>OPT LAST</cell><cell cols="5">2.07 3.30 4.59 5.09 5.29</cell><cell>4%</cell><cell>2%</cell></row><row><cell>SPEC LAST</cell><cell cols="5">2.10 3.31 4.59 5.09 5.29</cell><cell>4%</cell><cell>3%</cell></row><row><cell>BRANCH FIRST</cell><cell cols="5">2.07 3.29 4.58 5.08 5.28</cell><cell>4%</cell><cell>6%</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We would like to thank Tryggve Fossum for his support of this work and for numerous suggestions. And we would like to thank Bert Halstead and Rishiyur Nikhil for several valuable discussions, and the referees for their helpful comments. We would also like to thank John O'Donnell from Equator Technologies, Inc. for access to the source for the Multiflow compiler.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This research was supported by ONR grants N00014-92-J-1395 and N00014-94-1-1136, NSF grants CCR-9200832 and CDA-9123308, NSF PYI Award MIP-9058439, the Washington Technology Center, Digital Equipment Corporation, and fellowships from Intel and the Computer Measurement Group.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">APRIL: a processor architecture for multiprocessing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">H</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kranz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kubiatowicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">17th Annual International Symposium on Computer Architecture</title>
				<imprint>
			<date type="published" when="1990-05">May 1990</date>
			<biblScope unit="page" from="104" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The Tera computer system</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alverson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Callahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Cummings</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Koblenz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Porterfield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Supercomputing</title>
				<imprint>
			<date type="published" when="1990-06">June 1990</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Microarchitecture support for dynamic scheduling of acyclic task graphs</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Beckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Polychronopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">25th Annual International Symposium on Microarchitecture</title>
				<imprint>
			<date type="published" when="1992-12">December 1992</date>
			<biblScope unit="page" from="140" to="148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Fast and accurate instruction fetch and branch prediction</title>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grunwald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">21st Annual International Symposium on Computer Architecture</title>
				<imprint>
			<date type="published" when="1994-04">April 1994</date>
			<biblScope unit="page" from="2" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Optimization of instruction fetch mechanisms for high issue rates</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Conte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">N</forename><surname>Menezes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Mills</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Patel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">22nd Annual International Symposium on Computer Architecture</title>
				<imprint>
			<date type="published" when="1995-06">June 1995</date>
			<biblScope unit="page" from="333" to="344" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The concurrent execution of multiple instruction streams on superscalar processors</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Daddis</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">C</forename><surname>Torng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Parallel Processing</title>
				<imprint>
			<date type="published" when="1991-08">August 1991</date>
			<biblScope unit="page" from="76" to="83" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">New CPU benchmark suites from SPEC</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Dixit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">COMPCON</title>
				<imprint>
			<date type="published" when="1992">Spring 1992. 1992</date>
			<biblScope unit="page" from="305" to="310" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">An overview of the 21164 AXP microprocessor</title>
		<author>
			<persName><forename type="first">J</forename><surname>Edmondson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rubinfield</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hot Chips VI</title>
				<imprint>
			<date type="published" when="1994-08">August 1994</date>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The M-Machine multicomputer</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fillo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Keckler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Dally</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Carter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Gurevich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">S</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">28th Annual International Symposium on Microarchitecture</title>
				<imprint>
			<date type="published" when="1995-11">November 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Design and peformance evaluation of a multithreaded architecture</title>
		<author>
			<persName><forename type="first">R</forename><surname>Govindarajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Nemawarkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lenir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">First IEEE Symposium on High-Performance Computer Architecture</title>
				<imprint>
			<date type="published" when="1995-01">January 1995</date>
			<biblScope unit="page" from="298" to="307" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Performance study of a multithreaded superscalar microprocessor</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gulati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Bagherzadeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Second International Symposium on High-Performance Computer Architecture</title>
				<imprint>
			<date type="published" when="1996-02">February 1996</date>
			<biblScope unit="page" from="291" to="301" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Superscalar performance in a multithreaded microprocessor</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">K</forename><surname>Gunther</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993-12">December 1993</date>
		</imprint>
		<respStmt>
			<orgName>University of Tasmania</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An elementary processor architecture with simultaneous instruction issuing from multiple threads</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hirata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kimura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Nagamine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Mochizuki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nishimura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Nakase</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nishizawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">19th Annual International Symposium on Computer Architecture</title>
				<imprint>
			<date type="published" when="1992-05">May 1992</date>
			<biblScope unit="page" from="136" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Processor coupling: Integrating compile time and runtime scheduling for parallelism</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Keckler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Dally</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">19th Annual International Symposium on Computer Architecture</title>
				<imprint>
			<date type="published" when="1992-05">May 1992</date>
			<biblScope unit="page" from="202" to="213" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Interleaving: A multithreading technique targeting multiprocessors and workstations</title>
		<author>
			<persName><forename type="first">J</forename><surname>Laudon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Horowitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Sixth International Conference on Architectural Support for Programming Languages and Operating Systems</title>
				<imprint>
			<date type="published" when="1994-10">October 1994</date>
			<biblScope unit="page" from="308" to="318" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">The effects of STEF in finely parallel multithreaded processors</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Chu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">First IEEE Symposium on High-Performance Computer Architecture</title>
				<imprint>
			<date type="published" when="1995-01">January 1995</date>
			<biblScope unit="page" from="318" to="325" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The multiflow trace scheduling compiler</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Lowney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Freudenberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Karzes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">D</forename><surname>Lichtenstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Nix</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Odonnell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Ruttenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Supercomputing</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="51" to="142" />
			<date type="published" when="1993-05">May 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Combining branch predictors</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mcfarling</surname></persName>
		</author>
		<idno>TN-36</idno>
		<imprint>
			<date type="published" when="1993-06">June 1993</date>
			<publisher>DEC-WRL</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A benchmark evaluation of a multi-threaded RISC processor architecture</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Prasadh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-L</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Parallel Processing</title>
				<imprint>
			<date type="published" when="1991-08">August 1991</date>
			<biblScope unit="page" from="84" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m">Microprocessor Report</title>
				<imprint>
			<date type="published" when="1994-10-24">October 24 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m">Microprocessor Report</title>
				<imprint>
			<date type="published" when="1994-11-14">November 14 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Measuring limits of fine-grained parallelism</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">G</forename><surname>Sirer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Senior Independent Work</title>
				<imprint>
			<date type="published" when="1993-06">June 1993</date>
		</imprint>
		<respStmt>
			<orgName>Princeton University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Architecture and applications of the HEP multiprocessor computer system</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">J</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPIE Real Time Signal Processing IV</title>
				<imprint>
			<date type="published" when="1981">1981</date>
			<biblScope unit="page" from="241" to="248" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Limits on multiple instruction issue</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Horowitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Third International Conference on Architectural Support for Programming Languages and Operating Systems</title>
				<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="290" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Multiscalar processors</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Sohi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">E</forename><surname>Breach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">N</forename><surname>Vijaykumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">22nd Annual International Symposium on Computer Architecture</title>
				<imprint>
			<date type="published" when="1995-06">June 1995</date>
			<biblScope unit="page" from="414" to="425" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">High-bandwidth data memory systems for superscalar processors</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Sohi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Franklin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fourth International Conference on Architectural Support for Programming Languages and Operating Systems</title>
				<imprint>
			<date type="published" when="1991-04">April 1991</date>
			<biblScope unit="page" from="53" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Simultaneous multithreading: Maximizing on-chip parallelism</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Tullsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Eggers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Levy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">22nd Annual International Symposium on Computer Architecture</title>
				<imprint>
			<date type="published" when="1995-06">June 1995</date>
			<biblScope unit="page" from="392" to="403" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Increasing superscalar performance through multistreaming</title>
		<author>
			<persName><forename type="first">W</forename><surname>Yamamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Nemirovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference on Parallel Architectures and Compilation Techniques</title>
				<imprint>
			<date type="published" when="1995-06">June 1995</date>
			<biblScope unit="page" from="49" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Performance estimation of multistreamed, superscalar processors</title>
		<author>
			<persName><forename type="first">W</forename><surname>Yamamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Serrano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Talcott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Wood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Nemirosky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Twenty-Seventh Hawaii International Conference on System Sciences</title>
				<imprint>
			<date type="published" when="1994-01">January 1994</date>
			<biblScope unit="page" from="195" to="204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Alternative implementations of twolevel adaptive branch prediction</title>
		<author>
			<persName><forename type="first">T.-Y</forename><surname>Yeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Patt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">19th Annual International Symposium on Computer Architecture</title>
				<imprint>
			<date type="published" when="1992-05">May 1992</date>
			<biblScope unit="page" from="124" to="134" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
