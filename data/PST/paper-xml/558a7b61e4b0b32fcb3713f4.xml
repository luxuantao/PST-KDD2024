<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Deriving Petri Nets from Finite Transition Systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Jordi</forename><surname>Cortadella</surname></persName>
							<email>jordic@lsi.upc.es</email>
						</author>
						<author>
							<persName><roleName>Senior Member, IEEE</roleName><forename type="first">Michael</forename><surname>Kishinevsky</surname></persName>
						</author>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Luciano</forename><surname>Lavagno</surname></persName>
							<email>lavagno@polito.it</email>
						</author>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Alexandre</forename><surname>Yakovlev</surname></persName>
							<email>alex.yakovlev@newcastle.ac.uk</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Software</orgName>
								<orgName type="institution" key="instit1">Technical University of Catalonia</orgName>
								<orgName type="institution" key="instit2">Jordi Girona Salgado s/n</orgName>
								<address>
									<addrLine>Campus Nord. Modul C6</addrLine>
									<postCode>08034</postCode>
									<settlement>Barcelona</settlement>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Intel Corporation</orgName>
								<address>
									<addrLine>JFT-104, 2111 NE 25th Ave</addrLine>
									<postCode>97124-5961</postCode>
									<settlement>Hillsboro</settlement>
									<region>OR</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Dipartimento di Elettronica</orgName>
								<orgName type="institution">Politecnical di Torino</orgName>
								<address>
									<addrLine>C. Duca degli Abruzzi 24</addrLine>
									<postCode>10129</postCode>
									<settlement>Torino</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department">Department of Computing Science</orgName>
								<orgName type="institution">University of Newcastle upon Tyne</orgName>
								<address>
									<addrLine>Claremont Road</addrLine>
									<postCode>NE1 7RU</postCode>
									<settlement>Claremont Tower, Newcastle upon Tyne</settlement>
									<country key="GB">U.K</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Deriving Petri Nets from Finite Transition Systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">6FB1103A4EC5934DF4BE678B275A095E</idno>
					<note type="submission">received 12 June 1996; revised 5 Aug. 1997.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:54+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Petri Nets</term>
					<term>transition systems</term>
					<term>concurrent systems</term>
					<term>asynchronous systems</term>
					<term>synthesis</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper presents a novel method to derive a Petri Net from any specification model that can be mapped into a statebased representation with arcs labeled with symbols from an alphabet of events (a Transition System, TS). The method is based on the theory of regions for Elementary Transition Systems (ETS). Previous work has shown that, for any ETS, there exists a Petri Net with minimum transition count (one transition for each label) with a reachability graph isomorphic to the original Transition System. Our method extends and implements that theory by using the following three mechanisms that provide a framework for synthesis of safe Petri Nets from arbitrary TSs. First, the requirement of isomorphism is relaxed to bisimulation of TSs, thus extending the class of synthesizable TSs to a new class called Excitation-Closed Transition Systems (ECTS). Second, for the first time, we propose a method of PN synthesis for an arbitrary TS based on mapping a TS event into a set of transition labels in a PN. Third, the notion of irredundant region set is exploited, to minimize the number of places in the net without affecting its behavior. The synthesis method can derive different classes of place-irredundant Petri Nets (e.g., pure, free choice, unique choice) from the same TS, depending on the constraints imposed on the synthesis algorithm. This method has been implemented and applied in different frameworks. The results obtained from the experiments have demonstrated the wide applicability of the method.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>ETRI nets <ref type="bibr" target="#b47">[48]</ref>, <ref type="bibr" target="#b40">[41]</ref> are a widespread formalism to model concurrent systems. By labeling transitions with symbols from a given alphabet, transitions can be interpreted as the occurrence of events or the execution of tasks in a system. Labeled Petri Nets have been used in numerous applications: design and specifications of asynchronous circuits <ref type="bibr" target="#b52">[53]</ref>, <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b33">[34]</ref>, <ref type="bibr" target="#b31">[32]</ref>, resource allocation in operating systems and distributed computation <ref type="bibr" target="#b54">[55]</ref>, analysis of concurrent programs <ref type="bibr" target="#b49">[50]</ref>, performance analysis and timing verification <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b51">[52]</ref>, and high-level design <ref type="bibr" target="#b22">[23]</ref>. Petri Nets are popular due to their inherent ability to express concurrency, choice and causality between events in a system, without explicit enumeration of global states.</p><p>Although checking properties of Petri Nets could be difficult in general, for some subclasses of Petri Nets there are efficient verification algorithms. In this paper, we will deal with safe Petri Nets (a place cannot contain more than one token). Safe nets have high expressive power, in particular every finite state system can be expressed as a safe labeled PN. On the other hand, safe nets are also well suited for verification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">State-Based vs. Event-Based Models</head><p>State-based models, like FSMs <ref type="bibr" target="#b21">[22]</ref>, <ref type="bibr" target="#b32">[33]</ref> and burst-mode automata <ref type="bibr" target="#b42">[43]</ref>, are often used for formal specification and verification of complex systems. Furthermore, the formal semantics of event-based models, like CSP <ref type="bibr" target="#b27">[28]</ref> and CCS <ref type="bibr" target="#b36">[37]</ref>, <ref type="bibr" target="#b37">[38]</ref>, are defined in terms of states. The drawback of state-based models is that they represent causality, concurrency, and conflict relations between events in terms of state sequences or state configurations (e.g., state diamonds). For more succinct representation, it is very important to identify the set of causality relations, concurrent events, and conflict conditions implicit in the state-based representation because they carry useful information for the designer or/and design algorithms.</p><p>In this paper, we present a method which, given a finite state model, called Transition System (TS) in the sequel, synthesizes a safe, place-irredundant Petri Net with a reachability graph that is bisimilar to the original TS. By moving from a TS representation of the system to a PN model which exhibits the same behavior we simplify the representation of concurrency and causality of the system.</p><p>The synthesis method provides a technique for transforming specifications. Given a model which can be mapped into a TS, we can derive a PN which is bisimilar to the initial model of the process. In such a way we can create a tool which automatically translates CSP, CCS, FSM, Burstmode machines, and other models into labeled Petri Nets. We can also use this tool to transform Petri Nets themselves, aiming at optimality under some criterion (place count, transition count, number of places, PN graph complexity, etc.) or for deriving a net belonging to a given class (pure, free choice, unique choice, etc.). This opens up an avenue for building interactive tools where a designer has the possibility to play with a PN-like specification, performing equivalent transformations of PNs, and/or transformations of other specifications into PNs under different design constraints and optimization criteria. Fig. <ref type="figure" target="#fig_0">1</ref> shows our framework for synthesizing PNs and transforming specifications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Applications of the Method</head><p>There are well-known algorithms (see, e.g., <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b31">[32]</ref>, <ref type="bibr" target="#b0">[1]</ref>) to extract a finite-state representation of the sequential behavior of a synchronous or asynchronous circuit. But, a really user-friendly interaction can be achieved only by presenting the designer a timing diagram-like PN that represents the same behavior, with explicit causality. Section 5.1 contains an example of how different synthesis options (like minimizing transitions, choosing one specific subclass of PN, and so on) result in different degrees of readability of the synthesized PN.</p><p>In the same vein, FSM-based formal verification systems ( <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b21">[22]</ref>, <ref type="bibr" target="#b32">[33]</ref>) provide information about property check failures in the form of one specific execution path in a finite state representation. This may not always be meaningful, as it may contain redundant information. Explicitly extracting a set of such paths (in the form of a finite state system) and presenting a Petri Net-like representation for it would greatly help the designer in the difficult task of finding out where the problem really lies.</p><p>Apart from interaction with the designer, which is a major motivation for this work, we also address the issue of extracting explicit causal relations in order to be able to apply analysis and synthesis techniques which rely on explicit causality and concurrency information ( <ref type="bibr" target="#b44">[45]</ref>, <ref type="bibr" target="#b28">[29]</ref>). In <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b14">[15]</ref>, we showed that regions, sets of states corresponding to places in PNs, are tightly connected with properties that must be preserved across the state encoding process for asynchronous circuits. Hence, regions and their intersections can be efficiently used for state signal insertion and, therefore, for synthesis of digital circuits in general.</p><p>Moreover, classical techniques for Petri Net composition ( <ref type="bibr" target="#b50">[51]</ref>) are based on the creation of a "cross-product" between transitions with the same label. Suppose that two PNs N 1 and N 2 , with n and m transitions labeled with the same name, respectively, are composed. The resulting net has m ¿ n transitions with the same label, even though some of these are not really needed (i.e., there exists a smaller PN representing the same composed behavior). Section 5.1 describes this application more in detail, with examples.</p><p>Reference <ref type="bibr" target="#b49">[50]</ref> shows that PNs can be useful for analysis of concurrent programs. There, a PN is derived from a task flow-graph for an Ada program. No efficient technique for deriving a PN is used. We think that our technique for synthesis of PNs can provide an efficient machinery for the analysis of concurrent programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Related Work</head><p>The concept of regions was introduced in <ref type="bibr" target="#b23">[24]</ref> (and developed in <ref type="bibr" target="#b41">[42]</ref>, <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b39">[40]</ref>) as a fundamental link between state-based and event-based specifications. A comprehensive review of the theory of regions can be found in <ref type="bibr" target="#b3">[4]</ref>. "State" in safe Petri Nets is distributed among places: Each state is a set of marked places, and each place is marked in a set of states that form the corresponding region. A region in a Transition System is exactly a set of states, such that transitions coming in and going out of it "mimic" the PN firing behavior.</p><p>These papers provide the formal framework for our contribution, but suffer from a series of problems:</p><p>• Their contribution was mainly category-theoretical, aimed at obtaining a canonical representation of the PN, with many places (actually, as many places as could be added without changing the behavior of the net). On the other hand, we strive to minimize the number of places in order to make the final Petri Net easier for the designer to understand. This problem was also tackled in <ref type="bibr" target="#b20">[21]</ref>, aiming at deriving a place-irredundant Petri Net, but not at minimizing the number of places. Two open problems are formulated in <ref type="bibr" target="#b20">[21]</ref>:</p><p>1) if the existence of an optimal net can be characterized in terms of the TSs and 2) if there always exists at most one optimal net which could be considered canonical. Our paper gives a positive answer to the first problem and a negative answer to the second problem. • They did not address the problem of merging and splitting "equivalent" labels, which model the same event, but must be split in order to yield a valid or/and efficient Petri Net. We, for the first time, provide a method for label splitting which seems to satisfactorily solve the problem.<ref type="foot" target="#foot_0">1</ref> • They were limited to elementary TSs, which are quite restricted, while we can handle the full class of TSs by means of transition splitting. • They produce a PN with an RG isomorphic to the TS, which appears to be too strong a degree of correspondence. Our method extends this result to excitationclosed TSs (ECTS), which include not only ETSs, but also all those TSs that have bisimilar ETS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Contributions</head><p>In this paper, we present an algorithm for generating a complete set of minimal regions (which are analogous to prime implicants in Boolean minimization) and, further, for removing redundant regions (which is similar to generating a prime irredundant cover in Boolean minimization). We can either generate all irredundant nets and take the minimum one among them (an exact minimization of places in PNs) or we can heuristically select a minimal prime and place-irredundant net if searching for the minimum is too time consuming. We use different cost functions for minimization of PNs, depending on whether the designer requires minimizing the number of places, transitions, or arcs in the PN graph. We can also restrict the resulting PN to belong to a specific subclass (e.g., free-choice) if required by the designer, as shown in Section 5.</p><p>Our technique of global optimization is complementary to the local optimization and reduction technique that is based on applying a set of local rules for replacing a more complex fragment of a PN with a simpler one, while preserving certain semantic, behavioral, or structural properties <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b53">[54]</ref>, <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b40">[41]</ref>, <ref type="bibr" target="#b19">[20]</ref>. In fact, as discussed in Section 4.5, we apply those structural reduction techniques in order to reduce the complexity of the TS representation when we derive the TS from a PN with the objective of optimizing it.</p><p>It is known <ref type="bibr" target="#b2">[3]</ref> that, for ETS, the complexity of synthesis of PNs is polynomial in the size of the TS. However, direct application of methods from <ref type="bibr" target="#b2">[3]</ref> would require explicit enumeration of states of the TS. To avoid explicit enumeration, we have defined synthesis conditions (called excitation closure conditions) in a form that allows us to use symbolic techniques based on Reduced Ordered Binary Decision Diagrams for representing sets of states and checking synthesis conditions. Thus, many real-life examples with large TSs become manageable. For nonexcitation closed TSs, an additional amount of computation is required for splitting labels and calculating minimal regions for the TS after splitting. In the worst case of complete splitting, there is one label per arc and, hence, the number of minimal regions is equal to the number of states.</p><p>The paper is organized as follows. Section 2 formally introduces Transition Systems, Petri Nets, and regions. Section 3 introduces the new definitions and theoretical results required by our synthesis algorithm. Section 4 describes the synthesis algorithms in detail and formally proves their correctness. It also provides a number of modifications to the basic method. Section 5 presents applications and some experimental results. Section 6 concludes the paper. Due to lack of space, all statements in Sections 3 and 4 (except for Theorem 3.3 which is fully proven) are only given with only informal proofs. The details can be found in the technical report <ref type="bibr" target="#b16">[17]</ref>, which is the extended version of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">MODELS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Transition Systems</head><p>A transition system (TS) is a quadruple <ref type="bibr" target="#b41">[42]</ref> TS = (S, E, T, s in ), where S is a nonempty set of states, E is a set of events, T µ S E S is a transition relation, and s in is an initial state. The elements of T are called the transitions of TS and will be often denoted by s s e instead of (s, e, s). A transition system is finite if S and E are finite. In the sequel, only finite transition systems will be considered. A TS is called deterministic if for each state s and each label a there can be at most one state s such that s s a . Otherwise, a TS is called nondeterministic.</p><p>The transitive closure of the transition relation T is called the reachability relation between states and is denoted by T*. In other words, state s is reachable from state s if there is a (possibly empty) sequence of transitions from T: s = (s, e 1 , s 1 ), ..., (s k , e k , s). Two states, s and s, are confluent if there is a state s which is reachable both from s and s <ref type="bibr" target="#b29">[30]</ref>. Note that, according to the definition of reachability, s can coincide with s or s.</p><p>Every transition system TS = (S, E, T, s in ) is assumed to satisfy the following axioms: A.1) No self-loops: "(s, e, s) ¶ T : s ¡ s; A.2) Every event has an occurrence: "e ¶ E : $(s, e, s) ¶ T; A.3) Every state is reachable from the initial state:</p><formula xml:id="formula_0">" ¶ * s S s s in : .</formula><p>An additional axiom is assumed in <ref type="bibr" target="#b41">[42]</ref> (no multiple arcs between pairs of states):</p><formula xml:id="formula_1">"(s, e 1 , s 1 ), (s, e 2 , s 2 ) ¶ T : [s 1 = s 2 AE e 1 = e 2 ].</formula><p>This axiom is required in <ref type="bibr" target="#b41">[42]</ref> so that behavior-preserving morphisms between TSs can be partially defined. A partial mapping implies that some of the "twin" events which do not satisfy the above axiom become nonobservational. This can lead to discrepancies between the behaviors of the original and mapped TSs. In our framework of applications, we are only interested in transformations and equivalences of TSs in which events are totally mapped.</p><p>Therefore, the above axiom can be safely omitted (see Definitions 2.4, 2.5, and 2.6 for further details).</p><p>A TS can be represented by an arc-labeled directed graph. A simple example of a TS without cycles is shown in Fig. <ref type="figure" target="#fig_1">2a</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Petri Nets</head><p>A Petri Net <ref type="bibr" target="#b47">[48]</ref>, <ref type="bibr" target="#b40">[41]</ref> is a quadruple N = (P, T, F, m 0 ), where P is a finite set of places, T is a finite set of transitions, F µ (P T) ʜ (T P) is the flow relation, and m 0 is the initial marking. A transition t ¶ T is enabled at marking m 1 if all its input places are marked. An enabled transition t may fire, producing a new marking m 2 with one less token in each input place and one more token in each output place</p><formula xml:id="formula_2">(m m t 1 2</formula><p>). A PN expressing the same behavior as the TS from Fig. <ref type="figure" target="#fig_1">2a</ref> is shown in Fig. <ref type="figure" target="#fig_1">2b</ref>.</p><p>The sets of input and output places of transition t are denoted by •t and t•. The sets of input and output transitions of place p are denoted by •p and p•. The set of all markings of N reachable from the initial marking m 0 is called its Reachability Set.</p><p>A labeled PN is a PN with a labeling function l : T A which puts into correspondence every transition of the net with a symbol (called label) from the alphabet A. If no two transitions have the same label (unique labeling), then each transition in the net can be uniquely identified by its label. In such a case, we can use the label as the name of the transition. The Reachability Graph (RG) of a PN is a transition system in which the set of states is the Reachability Set, the events are the transitions of the net and a transition (m 1 , t, m 2 ) exists if and only if m m t 1 2</p><p>. (A formal definition of RG is given in Section 2.5).</p><p>One can easily check that the RG in Fig. <ref type="figure" target="#fig_1">2c</ref>, derived from the PN in Fig. <ref type="figure" target="#fig_1">2b</ref>, is isomorphic to the TS (Fig. <ref type="figure" target="#fig_1">2a</ref>).</p><p>A net is called safe if no more than one token can appear in a place. Safe nets are especially widely used in many applications, since they have simple verification algorithms <ref type="bibr" target="#b24">[25]</ref> and simple semantics. A net is called a pure net if (p, t) ¶ F implies that (t, p) • F, i.e., for each transition t the following condition is satisfied: t• ʝ •t = ®. A net is called simple if no two transitions t 1 and t 2 have the same sets of input and output places (i.e., "t 1 , either</p><formula xml:id="formula_3">t 2 •t 1 ¡ •t 2 or t 1 • ¡ t 2 •).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Regions</head><p>Let S be a subset of the states of a TS, S µ S. If s • S and s ¶ S, then we say that transition s s a enters S. If s ¶ S and s • S, then transition s s a exits S. Otherwise, transi- tion s s a does not cross S. In particular, if s ¶ S and s ¶ S, then the transition is said to be internal to S, and if s • S and s • S, then the transition is external to S. DEFINITION 2.1. Let TS = (S, E, T, s in ) be a TS. Let S µ S be a subset of states and e ¶ E be an event. </p><formula xml:id="formula_4">$ ¶ ¶ ¢ $ ¶ • ¢ $ ¶ • Á ¶ ¢ $ ¶ ¶ Á •<label>: , , , , : , , , , : , , , : . ¢</label></formula><p>0 5 0 5 0 5 0 5 0 5 0 5 0 5 0 5</p><p>The notion of a region is central for the synthesis of PNs. Intuitively, each region corresponds to a place in the synthesized PN, so that there is a one-to-one correspondence between states of the region and markings of the PN in which this place has a token. <ref type="bibr">DEFINITION 2.2 (region)</ref>. A set of states r µ S in TS = (S, E, T, s in ) is called a region if the following two conditions are satisfied for each event e ¶ E:</p><p>1) enter(e, r) AE Àin(e, r) Á Àout(e, r) Á Àexit(e, r) 2) exit(e, r) AE Àin(e, r) Á Àout(e, r) Á Àenter(e, r)</p><p>A region is a subset of states with which all transitions labeled with the same event e have exactly the same "entry/exit" relation. This relation will become the predecessor/successor relation in the Petri Net. The event may either always be an enter event for the region (Case 1 in the previous definition), or always be an exit event (Case 2), or never "cross" the region's boundaries (each transition labeled with e is internal or external to the region if the antece- dents of neither Case 1 nor Case 2 hold). The transition corresponding to the event will be successor, predecessor or unrelated with the corresponding place, respectively. Let us consider the TS shown in Fig. <ref type="figure" target="#fig_1">2</ref>. The set of states r 3 = {s 2 , s 3 , s 6 } is a region, since all transitions labeled with a and with b enter r 3 , and all transitions labeled with c exit r 3 .</p><p>On the other hand, {s 2 , s 3 } is not a region since transition , does not. Similar violations of the region conditions exist for two transitions labeled with a. However, there are no violations for c since both transitions labeled with c exit this set of states.</p><p>Each TS has two trivial regions: the set of all states, S, and the empty set. Further on we will always consider only nontrivial regions. The set of nontrivial regions of TS will be denoted by R TS . For each state s ¶ S, we define the set of nontrivial regions containing s, denoted by R s .</p><p>A region r is a preregion of event e if there is a transition labeled with e which exits r. A region r is a postregion of event e if there is a transition labeled with e which enters r. The set of all preregions and postregions of e is denoted with °e and e°, respectively. By definition, it follows that if r ¶ °e, then all transitions labeled with e exit r. Similarly, if r ¶ e°, then all transitions labeled with e enter r. Let r and r be regions of a TS. A region r is said to be a subregion of r iff r ´ r. A region r is a minimal region if there is no other region r which is a subregion of r.</p><p>There are eight nontrivial regions in the TS from Fig. <ref type="figure" target="#fig_1">2</ref>: r 1 = {s 1 , s 3 , s 5 }; r 2 = {s 1 , s 2 , s 4 }; r 3 = {s 2 , s 3 , s 6 }; r 4 = {s 1 , s 4 , s 5 }; r 5 = {s 1 , s 2 , s 3 }; r 6 = {s 4 , s 5 , s 6 }; r 7 = {s 2 , s 4 , s 6 }; r 8 = {s 3 , s 5 , s 6 }. All of these regions are minimal. Preregions and postregions are defined as follows: °a = {r 1 , r 4 }; °b = {r 2 , r 4 }; °c = {r 3 , r 5 }; a° = {r 3 , r 7 }; b° = {r 3 , r 8 }; c° = {r 4 , r 6 }.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Properties of Regions</head><p>The following propositions state a few important properties of regions <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b41">[42]</ref>, <ref type="bibr" target="#b16">[17]</ref>. PROPERTY 2.1. If r and r are two different regions such that r is a subregion of r, then rr is a region.</p><p>PROPERTY 2.2. A set of states, r, is a region, if and only if its coset r S r =is a region, where S is a set of all states of the TS.</p><p>PROPERTY 2.3 <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b16">[17]</ref>. Every region can be represented as a union of disjoint minimal regions.</p><p>Property 2.1 has been mentioned in <ref type="bibr" target="#b5">[6]</ref> for the subclass of elementary TSs. We generalize it for the complete class of TSs. Property 2.2 was given in <ref type="bibr" target="#b41">[42]</ref>. Property 2.3 is a stronger refinement of the corresponding property from <ref type="bibr" target="#b5">[6]</ref>, which shows that any region can be viewed as a linear combination of minimal regions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Elementary Transition Systems</head><p>Some of the results given in this section were formerly presented for elementary nets <ref type="bibr" target="#b41">[42]</ref>. Their extension to Petri Nets is straightforward and discussed in <ref type="bibr" target="#b16">[17]</ref>. In the sequel, we will reformulate for Petri Nets the major previous results on elementary nets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.1">Axioms for Elementary Transition Systems</head><p>A transition system TS = (S, E, T, s in ) is called elementary <ref type="bibr" target="#b41">[42]</ref> (ETS) if it satisfies, in addition to (A1)-(A3), the following two axioms about regions: The TS shown in Fig. <ref type="figure" target="#fig_3">3a</ref> is a cyclic elementary TS, while Fig. <ref type="figure" target="#fig_3">3b</ref> shows a nonelementary TS. The forward closure property is violated for events a and b. Let us consider event a. The only minimal preregion of a is region {s 1 , s 3 , s 5 ,</p><formula xml:id="formula_5">A.4) State separation property: "s, s ¶ S : [R s = R s AE s = s]; A.5) Forward closure property: " ¶ " ¶ µ AE ! " $ # s S e E e R</formula><formula xml:id="formula_6">s 7 }. Therefore o a R s µ 7</formula><p>, but there is no transition labeled with a from s 7 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DEFINITION 2.3 (Reachability Graph</head><formula xml:id="formula_7">). Let N = (P, E, F, m 0 ) be a PN. The reachability graph of N is the TS RG(N) = (S N , E N , T N , m 0 ), where S N µ 2 P , T N µ 2 P E 2 P such that:</formula><p>1) S N is the Reachability Set of N, with each state represented as the set of places marked in the corresponding marking, 2   2. Since we are only considering safe and pure Petri Nets, places can have at most one token. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2) T m e m m m S m m</head><p>N</p><formula xml:id="formula_8">N e = ¶ Á {( , , )| , } , 3) E N = {e|e ¶ E Á $(m, e, m) ¶ T N }.</formula><p>It was shown in <ref type="bibr" target="#b41">[42]</ref> that the RG of a PN is always an elementary TS and vice versa, i.e, if a TS is elementary, then a PN with a reachability graph isomorphic to the TS can be constructed. The procedure given by <ref type="bibr" target="#b41">[42]</ref>  </p><formula xml:id="formula_9">= ¶ Á ¶ Á ¶ ¶ Á ¶ Á ¶ def , , . 0 5 J L 0 5 J L o U o THEOREM 2.1. Let TS = (S, E, T, s in ) be an ETS. The reachability graph of N R E F R TS TS TS s in = ( , , ,</formula><p>) obtained by the algorithm of saturated PN synthesis is isomorphic to TS.</p><p>Intuitively, the net has as many places as nontrivial regions. Each preregion (postregion) of an event is a predecessor (successor) place of the corresponding transition. All places that correspond to regions that cover the initial state must be marked in the initial marking.</p><p>A PN which is synthesized following this procedure is called a saturated net, since all regions are mapped into the corresponding places. Any ETS has a unique saturated net; however, it has a lot of redundancy. As shown in <ref type="bibr" target="#b5">[6]</ref>, it is enough to consider only minimal regions. The net constructed from all minimal regions is also unique and is called a minimal saturated net. We will go two steps further and will first synthesize a place-irredundant PN and, then, a place-minimal PN, still preserving bisimilarity between its RG and the ETS.</p><p>Another important drawback of the procedure described in <ref type="bibr" target="#b41">[42]</ref> is that axioms (A4) and (A5) do not provide an efficient algorithm for checking elementarity, since they require the derivation of all regions of a TS and checking elementarity conditions for each individual state. Our procedure is specifically aimed at deriving minimal regions by using simplified elementarity checks, that admit an efficient implementation.</p><p>Finally, the synthesis method presented in <ref type="bibr" target="#b41">[42]</ref> produces a PN with an RG isomorphic to the TS. Our method extends this result to excitation-closed TSs (ECTS), which cover not only ETSs, but also all those TSs that have some bisimilar ETS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Split-Morphism, Isomorphism, and Bisimilarity</head><p>The following notions will be used for comparing behavior of TSs and PNs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DEFINITION 2.4 (Split-morphism). Let TS S E T s in</head><formula xml:id="formula_10">1 1 1 1 1 = ( , , , )</formula><p>and TS S E T s in</p><formula xml:id="formula_11">2 2 2 2 2 = ( , , , ) be two TSs. A split-morphism h from TS 1 to TS 2 is a pair (h S , h E ) of</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>total mappings, h S being bijective and h E being surjective, h S S h E E</head><formula xml:id="formula_12">S E : : 1 2 1 2 which satisfies (s, e, s) ¶ T 1 Ã (h S (s), h E (e), h S (s)) ¶ T 2 . DEFINITION 2.5 (Isomorphism). A split-morphism h = (h S , h E ) from TS 1 to TS 2 is an isomorphism if h E is bijective.</formula><p>Two TSs are said to be isomorphic (split-morphic) if there exists an isomorphism (split-morphism) between them (from one to the other).</p><p>The concept of split-morphism will be used when an event is represented by different instances in a TS. Later on, when deriving Petri Nets, this splitting will result in different transitions with the same label. . Intuitively, Conditions 1a) and 2a) define a simulation of TS 1 by TS 2 . Two TSs are said to be bisimilar if they can simulate each other, i.e., there exists a bisimulation between them. DEFINITION 2.7 (Auto-bisimulation and bisimilar states <ref type="bibr" target="#b1">[2]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DEFINITION 2.6 (Bisimulation [2]). Let TS S E T s in</head><formula xml:id="formula_13">1 1 1 1 = ( , ,</formula><p>Let TS = (S, E, T, s in ) be a TS. An auto-bisimulation of TS is a bisimulation between TS and itself. Two states s 1 , s 2 ¶ S are bisimilar if s 1 Rs 2 for some auto-bisimulation of TS.</p><p>The relation "is bisimilar to" is an equivalence relation and partitions all TSs into equivalence classes. A TS is said to be minimal if no other element in its equivalence class has a set of states with smaller cardinality, in other words: DEFINITION 2.8 (Minimal TS). A TS is said to be minimal if it contains no different states, s 1 and s 2 , which are bisimilar. The work presented in this paper is based on transformations between split-morphic or bisimilar TSs. These notions of equivalence provide stronger conditions than language equivalence in general ( <ref type="bibr" target="#b36">[37]</ref>). This implies, for example, that deadlock and liveness properties will be preserved for a PN generated from the TS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">EXCITATION CLOSED TRANSITION SYSTEMS</head><p>In this section, we define the concept of ECTS based on the notion of excitation regions, which are the sets of states corresponding to the transitions of a PN.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Excitation Regions and Switching Regions</head><p>While regions in a TS are related to places in the corresponding PN, an excitation region <ref type="bibr" target="#b31">[32]</ref> (ER) for event a is a maximal set of states in which transition a is enabled. Therefore, excitation regions are related to transitions of the PN. Similarly to ERs, we define switching regions as sets of states reached immediately after the occurrence of an event.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DEFINITION 3.1 (Excitation and switching regions). A set of</head><p>states S is called an excitation region for event a, denoted by ER(a), if it is a maximal set of states such that for every state s ¶ S there is a transition s a . A set of states S is called a switching region for event a, SR(a), if it is a maximal set of states such that for every state s ¶ S there is a transition a s .</p><p>In the TS from Fig. <ref type="figure" target="#fig_1">2a</ref>, ER(a) = {s 1 , s 5 } and SR(a) = {s 2 , s 6 }.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Excitation Closure</head><p>In this section, we introduce a new class of TSs, excitationclosed transition systems, and show their relationship with ETSs. We prove two important theorems which create a formal foundation for our synthesis framework. These theorems taken together state that for any excitation-closed TS there is an ETS that is bisimilar to the original TS. 3 The practical importance of this result will be illustrated further, by showing an efficient way of checking the excitation closure condition. We now establish a correspondence between ETSs and ECTSs. For this we introduce the notion of region-based state equivalence, and define a region-separated TS as a TS minimized with respect to that equivalence. DEFINITION 3.3 (Region-based state equivalence). Let TS = (S, E, T, s in ) be an ECTS and let 5 be the binary relation on S defined as follows:</p><p>3. Due to lack of space, the proofs have been omitted. They can be found in <ref type="bibr" target="#b16">[17]</ref>.</p><formula xml:id="formula_14">s s R R s s 1 2 1 2 5 Ã = def .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Clearly, 5 is an equivalence relation. For each s ¶ S, we denote by [s] the equivalence class of s. For each S µ S, we denote by [S] the set of equivalence classes of the states in S.</head><p>Given an ECTS and the set of all equivalence classes, [S] = {p 1 , ¤, p k }, with respect to 5, it is possible to construct a minimized version of the ECTS such that, for each equivalence class of states p j ¶ [S], there will be exactly one corresponding state in the new TS. We will denote the new state corresponding to p j as s[p j ]. Slightly abusing the notation, the set of states corresponding to all equivalence classes of S µ S is denoted as [S] and the whole set of the new states as [S]. DEFINITION 3.4 (Region-separated TS). Let TS = (S, E, T, s in ) be an ECTS. A region-separated TS is defined as follows:  <ref type="figure">5b</ref>, where the equivalent states have been merged. This minimized TS is now an ETS with a behavior bisimilar to the reachability graph of the Petri Net shown in Fig. <ref type="figure">5c</ref>.</p><formula xml:id="formula_15">TS 5 = ([S], E, T 5 , s[p in ]),</formula><p>The next theorem shows that the region-separated TS is a (partly) minimized version of a ECTS with respect to bisimulation. THEOREM 3.1. Let TS = (S, E, T, s in ) be an ECTS. Then, TS and the corresponding region-separated TS, TS 5 , are bisimilar.</p><p>The proof outline is given in the Appendix.</p><p>The following theorem establishes a connection between ETS and ECTS in both directions. THEOREM 3.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1) If a TS is elementary, then it is excitation-closed.</head><p>2) Let TS = (S, E, T, s in ) be an ECTS. Then, TS 5 is elementary. The proof outline is given in the Appendix. As follows from Theorem 3.2.1, each ETS is an ECTS. On the other hand, Theorems 3.1 and 3.2.2, show that, for each ECTS, an elementary bisimilar TS can be constructed by mapping all region-equivalent states into one state. This procedure corresponds to classical state minimization of finite automata. However, this relation with classical state minimization is not straightforward and will be analyzed more in detail in Section 3.5. For example, Fig. <ref type="figure">6a</ref> shows a nondeterministic TS which is excitation closed, but not elementary, since, e.g., output states of transitions labeled with a are not separated by regions. The corresponding TSR is obtained by merging two pairs of region-equivalent states and is elementary (Fig. <ref type="figure">6b</ref>). An important observation can be made. Any ETS is deterministic <ref type="bibr" target="#b41">[42]</ref>. However, a nondeterministic TS can be an ECTS when it has a bisimilar ETS. Fig. <ref type="figure">6</ref> depicts an example illustrating this fact.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Minimality</head><p>This subsection focuses on minimality of TSs. Recall (Section 2.6) that a TS is minimal if all its states are unique in terms of their posthistory, i.e., no two distinct states of the TS are bisimilar to each other. Our main goal here is to show the conditions under which region-based equivalence R of states coincides with bisimulation-based equivalence R. These conditions are based on the notion of confluence. The following important properties are related to minimality. The proof of this theorem is given in the Appendix.</p><p>Let TS = (S, E, T, s in ) be an ECTS, then the following properties (proven in <ref type="bibr" target="#b16">[17]</ref>) hold:</p><p>• If TS is minimal, then TS is elementary.</p><p>• If TS is minimal, then it is isomorphic to the regionseparated TS, TS 5 . • If every pair of bisimilar states of S is confluent, then TS 5 is minimal.</p><p>The last property implies that by constructing a regionseparated TS one implicitly minimizes the TS for all confluent states. For example, the region-separated TS in Fig. <ref type="figure" target="#fig_6">4c</ref> on the right is a minimized version of the ECTS from Fig. <ref type="figure" target="#fig_6">4c</ref> on the left. The relationship with state minimization for nonconfluent states will be discussed in Section 3.5. Fig. <ref type="figure" target="#fig_11">7d</ref> shows an example of an excitation closed TS, which is not minimal, since states marked with 2 and with ® are bisimilar. Note that these states are not confluent. After minimizing the TS, Fig. <ref type="figure" target="#fig_11">7e</ref> is obtained, which is not excitation closed. The excitation closure condition is violated for event f.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Place-Irredundant Petri Nets</head><p>The above theory provides an efficient framework to derive Petri Nets from transition systems. The main differences from the work presented in <ref type="bibr" target="#b41">[42]</ref> are the following:</p><p>• The check for elementarity (that must be done once for each state) is reduced to a check for excitation closure (that must be done once for each event; events in a concurrent model are in general much fewer than states). • Excitation closure guarantees the existence of a bisimilar ETS with a one-to-one correspondence between regions. The ETS will be minimal for all those pairs of bisimilar states that are confluent.</p><p>Therefore, given an ECTS, one obtains a PN whose RG is bisimilar to the ECTS by only calculating the minimal regions of the ECTS. Furthermore, the method can not only derive a Petri Net, but also minimize its reachability graph if all the bisimilar states are confluent.  A minimal saturated net can be redundant. Many places can still be removed from it while still preserving the bisimilarity between its RG and the ETS. By analogy with logic minimization, a saturated net is like the set of all implicants for a Boolean function, while a minimal saturated net is like the set of all prime implicants. Our goal is to provide a method for constructing an irredundant net with minimal regions, which is similar to an irredundant cover of prime implicants <ref type="bibr" target="#b8">[9]</ref>. Unfortunately, the analogue of Quine and McCluskey's result does not hold in this case, i.e., there exist ECTSs for which any minimum corresponding PN requires using at least one nonminimal region. An example of such a case is given in Section 3.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Minimal regions</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Regions containing states</head><formula xml:id="formula_16">= = = = = = = = = = , ,<label>, , , , , , , , , , &lt;</label></formula><formula xml:id="formula_17">A &lt; A &lt; A &lt; A &lt; A &lt; A &lt; A &lt; A (a) (b) (c)</formula><p>It was proven in <ref type="bibr" target="#b5">[6]</ref> that the RG of a minimal saturated net is isomorphic to the RG of the saturated net. Here, we provide a method to build a place-irredundant net from an ECTS and prove that the RG of the place-irredundant net is bisimilar to the ECTS. Similar related work for ETSs was presented in <ref type="bibr" target="#b20">[21]</ref>. The proof is trivial. Fig. <ref type="figure" target="#fig_11">7</ref> shows a minimal saturated PN (Fig. <ref type="figure" target="#fig_11">7a</ref>) and its RG (Fig. <ref type="figure" target="#fig_11">7b</ref>). Regions r0, r1, r2, and r3 are enough to guarantee the excitation closure of the RG and a place-irredundant PN can be obtained (Fig. <ref type="figure" target="#fig_11">7c</ref>) with a bisimilar RG (Fig. <ref type="figure" target="#fig_11">7d</ref>). Note that, in the initial PN region, r4 is a preregion for event d. The RG in Fig. <ref type="figure" target="#fig_11">7d</ref> is a partly minimized version of RG (Fig. <ref type="figure" target="#fig_11">7b</ref>), however, it is not minimal. A minimal RG can be neither elementary nor excitation closed (Fig. <ref type="figure" target="#fig_11">7e</ref>). By removing redundant regions one can perform an implicit partial state minimization for nonconfluent states. However, complete minimization of such states can destroy elementarity and excitation closure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Place-Minimal Petri Nets</head><p>In this section, we define a link between place-minimal nets and minimal sets of regions and further establish a relation between irredundant sets of minimal regions and minimal sets of regions. <ref type="bibr">DEFINITION</ref>  The relationship between minimal nets and minimal sets of regions is similar to that between irredundant nets and irredundant sets of regions. It can be stated as follows: The proof is trivial. As discussed in Section 3.4, a place-irredundant PN can be always obtained using an irredundant set of minimal regions. In that respect, minimal regions resemble prime implicants in Boolean minimization. However, a minimal set of regions does not necessarily contain minimal regions only. Fig. <ref type="figure" target="#fig_12">8</ref> shows a transition system (on the left) and a place-irredundant net, corresponding to the (unique) irredundant set of minimal regions (in the middle). However, a place-minimal safe pure net (on the right) can be obtained from the place-irredundant net by merging two minimal regions, which are denoted in the TS with dotted lines, into one nonminimal region.</p><p>The relationship between irredundant sets of minimal regions and minimal sets of regions is given by the following theorem. DEFINITION 3.9 (Min-expansion of regions). Let R be a set of regions of a TS. A set of regions R is called a minexpansion of R if 1) for any region r, r ¶ R, the following conditions hold:</p><formula xml:id="formula_18">a) if r is a minimal region, then r ¶ R. b) if r is a nonminimal region and r = r 1 ʜ r 2 ¤ ʜ r k ,</formula><p>where r 1 , ¤, r k are disjoint minimal regions, then</p><formula xml:id="formula_19">r • R and r 1 ¶ R, ¤, r k ¶ R.</formula><p>2) for any region r, r ¶ R, there exists a region r ¶ R such that a) if r is a minimal region, then r = r b) if r is a nonminimal region and r = r</p><formula xml:id="formula_20">1 ʜ r 2 ¤ ʜ r k ,</formula><p>where r 1 , ¤, r k are disjoint minimal regions, then there exists i such that r = r i . THEOREM 3.7 (Minimal set of regions). Let R be a minimal set of regions of an ECTS. Then, any min-expansion of R is an irredundant set of regions. This theorem shows that a place-minimal net can always be obtained from one of the irredundant sets of minimal regions by merging some of the disjoint minimal preregions into nonminimal preregions.</p><p>Based on the equivalences for TSs and PNs presented in this section, the framework depicted in Fig. <ref type="figure" target="#fig_13">9</ref> and described in the next section can be devised for the synthesis of PNs.</p><p>• Initially, the labels of a TS are split to obtain a splitmorphic ECTS. Next, all minimal preregions that are predecessors of some event are generated to derive a minimal saturated PN. This restriction to event predecessors only is due to our region generation mechanism and has been shown to be sufficient in practice to obtain good results using a reasonable amount of computation time. • Then, an irredundant subset of preregions is calculated and a place-irredundant PN obtained. • Finally, by merging minimal preregions, further minimization of regions can be obtained. Exploring all place-irredundant nets can be computationally very expensive. Hence, we use only a greedy place merging starting from a place-irredundant net, thus yielding a quasi-place-minimal PN.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">PETRI NET SYNTHESIS</head><p>The skeleton of the algorithm for synthesis of a PN is given by the pseudocode of function Petri Net synthesis shown in Fig. <ref type="figure" target="#fig_15">10</ref>. The input of this algorithm is a TS. The output is a PN whose RG is bisimilar to the TS. Here, we only give a rough sketch of the procedures. Further details on the methods used in the current implementation to represent and manipulate TSs efficiently are given in Section 4.5.  The function generate_min_preregions generates all minimal preregions for one event. The function find_irredundant_cover produces an irredundant set of regions. From this set, a place-irredundant net is generated. This function is discussed in Section 4.2. The function split_labels performs the splitting of labels if the initial TS is not an ECTS. This function is discussed in Section 4.3. The function map_to_PN is the final step for constructing a PN from the set of regions, which has been described in Section 2.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Generation of Minimal Preregions</head><p>The generation of preregions of an event e is based on the fact that any preregion must cover the ER(e). Starting from ER(e), any event with an illegal crossing relation is legalized by adding new states to a set of states containing ER(e) until it becomes a region. An exhaustive search through all the possible legalizations guarantees that all minimal preregions that are predecessors of some event will eventually be found.</p><p>The following lemmas, proven in <ref type="bibr" target="#b16">[17]</ref>, are the basis for the generation of preregions. LEMMA 4.1 (Violation of region conditions). Let TS = (S, E, T, s in ) be a TS. Let r ´ S be a subset of states such that r is not a region. Then, there exists an e ¶ E such that at least one of the following predicates holds:</p><p>1) in(e, r) Á [enter(e, r) Â exit(e, r)] 2) enter(e, r) Á exit(e, r) 3) out(e, r) Á enter(e, r) 4) out(e, r) Á exit(e, r) LEMMA 4.2 (Essential states to become a region). Let TS = (S, E, T, s in ) be a TS. Let r ´ S be a set of states such that r is not a region. Let r µ S be a region such that r ´ r. Let e ¶ E be an event that violates some of the conditions for r to be a region. The following predicates hold: Note that the asymmetry between in and out is due to the fact that we always expand a set of states to become a region, starting from "minimal" seeds that are excitation regions.</p><p>The pseudocode for the function gener-ate_min_preregions is shown in Fig. <ref type="figure" target="#fig_15">10</ref>. PROPOSITION 4.1. The function generate_min_preregions generates all minimal preregions of the ECTS that are predecessors of some TS event.</p><p>The restriction to predecessor regions is not so severe because our excitation closure condition is based only on predecessors of a given event. This means that we can find a PN equivalent to any ECTS by looking only at predecessor regions. We can lose with respect to minimality, but efficient implementation is currently more of concern than exact minimization.</p><p>Note also that, for Predicates 3 and 43 of Lemma 4.2, two expansions are possible. The algorithm generate_min_ preregions expands the set of states in both directions, thus implicitly generating a binary exploration tree as shown in Fig. <ref type="figure" target="#fig_17">12</ref>. The search tree is, however, reduced in a few ways: • If the same set of states is generated more than once, only one branch of the tree is explored. • If a region is generated during the exploration, then the search along this branch is immediately bounded. This is sound, since the search tree is monotonic in the following sense: each parent vertex of the tree is a subset of the child vertex. Hence, it is not possible to generate minimal regions along the branches starting from another minimal region. • If the target of the procedure is just to produce an irredundant set of regions, then the excitation closure for a given event is checked on-the-fly and the search is stopped as soon as it is satisfied. This mechanism can be used to produce a locally optimal solution even for very large TSs.</p><p>The complexity of region generation is known to be polynomial in the size of the TS <ref type="bibr" target="#b2">[3]</ref>, which gives an upper bound on the size of the search tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Irredundant Sets of Regions</head><p>Let R be a set of regions such that both the excitation closure condition and the event effectiveness condition hold (the set of all minimal preregions of an ECTS satisfies these two conditions). Note that if R satisfies the event effectiveness condition, and some regions are removed from R so that the excitation closure condition still holds, then the event effectiveness condition remains satisfied. Therefore, we need to monitor only the excitation closure condition, while removing redundant regions. We will illustrate how an irredundant set of places can be calculated by means of the example of Fig. <ref type="figure" target="#fig_16">11</ref>. Table <ref type="table">1</ref> presents all minimal preregions of the TS.</p><p>As a preliminary step, essential regions are calculated. A region r is essential if there exists a state s and an event e such that r ¶ °e, s • r and, for all r ¶ °e, r ¡ r, we have s ¶ r (i.e., r is the only region that removes from the intersection of preregions a state in which e is not enabled). For example, for event c, we have °c = {r 0 , r 1 }; ER(c) = {s 2 , s 6 } = r 0 ʝ r 1 .</p><p>In this case, both r 0 and r 1 are essential, since none of them can be removed from °c without violating its excitation closure. Similarly, we can deduce that r 2 , r 4 , and r 8 are also essential (r 2 and r 4 are essential for d and r 8 for a, b). Thus, we have four nonessential regions: r 3 , r 5 , r 6 , and r 7 .</p><p>Next, for each event with nonessential preregions (e and f in the example), all minimal covers are implicitly generated. To reduce the complexity of the problem, essential regions are assumed to be implicitly included in each cover.</p><p>For event e, we have two minimal covers: {r 6 } and {r 3 , r 7 }. For event f, we also have two minimal covers: {r 7 } and {r 5 , r 6 }. Finding a minimum cost cover can be posed as finding a minimum cost solution of a Boolean equation describing the covering conditions <ref type="bibr" target="#b48">[49]</ref>, <ref type="bibr" target="#b35">[36]</ref>. The equation corresponding to the example is as follows:</p><p>(r 6 + r 3 ¿ r 7 ) ¿ (r 7 + r 5 ¿ r 6 ) = 1.</p><p>A cost must be assigned to each region, according to the objective function to be minimized, which depends on the application. For example, if we want to minimize the total number of places and arcs (a heuristic measure of the "simplicity" of the PN), then we can assign to each place p a cost of</p><formula xml:id="formula_21">|•p| + |p•| + 1</formula><p>If we want to minimize only the number of places and obtain a place-minimal PN, then the cost of each place is 1.</p><p>In our case, cost(r 3 ) = cost(r 5 ) = 3; cost(r 6 ) = cost(r 7 ) = 4</p><p>and two minimum-cost covers exist: {r 3 , r 7 } and {r 5 , r 6 } (the former is shown in Fig. <ref type="figure" target="#fig_32">11c</ref>). There is another possible solution ({r 6 , r 7 }), but it has nonminimum cost. The existence of two place-minimal nets for this example gives a negative answer to a question posed in <ref type="bibr" target="#b20">[21]</ref>: whether there always exists at most one optimal net which could be considered canonical. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Label Splitting</head><p>The set of minimal preregions of an event a is calculated by gradually expanding ER(a) to obtain sets of states that do not violate the "entry-exit" relationship. When the excitation closure is not fulfilled (see Definition 3.2), i.e., r ER a r a ¶ ¡ o I 0 5, some events must be split to make the TS elementary. The strategy to split events is as follows. During the expansion of ER(a) toward the preregions of a, several sets of states are explored. We focus our attention on sets of states S such that ER a S r r a 0 5 µ</p><p>´ ¶o</p><formula xml:id="formula_22">I .</formula><p>For each of these sets of states, the number of events that violate the region conditions are calculated. Finally, the set that has the least number of "bad" events is selected. If several sets have the same number of "bad" events, the smallest one is selected. The selected set of states is then forced to be a region. Informally, this is done by splitting the labels of those events that do not fulfill the region conditions. This strategy guarantees that the new intersection of preregions is closer to ER(a).</p><p>An example is depicted in Figs. <ref type="figure" target="#fig_32">12a</ref> and<ref type="figure" target="#fig_32">12b</ref> for the preregions of event c. Initially, ER(c) = {s 2 , s 5 } is taken for expansion. Next, two possible legalizations for event b are considered. Further expansions are applied until all branches of the search tree find a region. In this case, regions covering states in SR(c) have been also explored (this type of regions are also valid in case a nonpure PN is sought, as explained in Section 4.4). The example also illustrates how all branches will eventually be pruned, in the worst case, when covering the whole set of states. Let us call r the intersection of the regions found in the expansion. We have r = {s 1 , s 2 , s 3 , s 4 , s 5 , s 6 , s 7 } ʝ {s 2 , s 3 , s 5 , s 6 } = {s 2 , s 3 , s 5 , s 6 }.</p><p>The strategy for label splitting will take all those explored sets r such that {s 2 , s 5 } µ r ´ r.</p><p>All three states explored before finding regions are good candidates. However, the set {s 2 , s 5 } is the best one by the fact that only one event violates the crossing conditions and it makes the intersection of pre-regions smaller (closer to ER). Thus, event b is split into two new events (b 1 and b 2 ) for {s 2 , s 5 } to become a region. The new TS is split-morphic with respect to the original one and is now an ECTS. The corresponding PN is shown in Fig. <ref type="figure" target="#fig_32">12d</ref> and its RG in Fig. <ref type="figure" target="#fig_32">12e</ref>. Note that it contains one state less than the original TS, due to the implicit minimization for bisimilar confluent states s4 and s7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Modifications of the Basic Synthesis Method</head><p>The above synthesis method can be easily adapted to synthesize different classes of PNs, as sketched below.</p><p>nonpure nets: For any event e, the algorithm also explores minimal regions r such that ER(e) ʜ SR(e) µ r. These regions correspond to self-loop places in the PN and can contribute to fulfill the excitation closure condition. free-choice nets: A net is said to be free choice if for any place p such that |p</p><formula xml:id="formula_23">•| &gt; 1, t ¶ p• implies that |•t| = 1.</formula><p>Informally, when a place is a choice, it must be the only predecessor of its successor transitions <ref type="bibr" target="#b26">[27]</ref>. This property can be enforced by splitting labels until all choice regions become the only preregions of their postevents. unique-choice nets: A net is said to be unique choice when all the choice places are free (as in free-choice nets) or when no pair of successor transitions can be enabled simultaneously. As an example, all PNs shown in Fig. <ref type="figure" target="#fig_23">14</ref> are unique-choice nets. The method to synthesize uniquechoice nets is similar to the one for free-choice nets. SM-decomposable nets: A state machine (SM) is a subnet composed of a subset of places of a net and all their predecessor and successor transitions, with the condition that any transition of the subnet has only one predecessor place and one successor place <ref type="bibr" target="#b26">[27]</ref>. A net is SMdecomposable if each place of the net belongs to some state machine. The synthesis of SM-decomposable PNs is based on the observation that any set of disjoint regions covering all states of a TS, i.e., a partition of the set of states into regions, corresponds to an SM in the PN <ref type="bibr" target="#b4">[5]</ref>. unsafe nets: Based on the theory presented in <ref type="bibr" target="#b2">[3]</ref> and incorporating label splitting to extend the method to any class of TS <ref type="bibr" target="#b30">[31]</ref>.</p><p>Further details on the synthesis of different classes of PNs can be found in <ref type="bibr" target="#b16">[17]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Symbolic Representation with Binary Decision Diagrams</head><p>In this section, we briefly explain how sets of states can be represented by means of Boolean functions and efficiently manipulated by using Binary Decision Diagrams (BDDs) <ref type="bibr" target="#b34">[35]</ref>, <ref type="bibr" target="#b9">[10]</ref>. As an example, it will be shown how traversal of the reachability set of markings can be done symbolically using BDDs.</p><p>Given the set P of places of a PN, a set M of (safe) markings over P can be represented by its characteristic function, denoted c M , that is a Boolean function that evaluates to 1 for each marking in M. In particular, the set of reachable markings of a PN in which a place p i is marked will be denoted by c i .</p><p>A BDD is a directed acyclic graph with one root and two leaf nodes (0 and 1). Each nonleaf node is labeled with a Boolean variable and has two outgoing arcs with labels 0 and 1. A BDD represents a Boolean function as follows: Each variable assignment has a corresponding path that goes from the root node to one of the leaf nodes. The label of the leaf node is the value of the function for that assignment. As an example, the BDD depicted in Fig. <ref type="figure" target="#fig_32">13b</ref> represents the function . Note that the function has 20 minterms and that each of them corresponds to a reachable marking of the function. Here are some examples of how the markings (represented as sets of marked places) are encoded: We refer the reader to <ref type="bibr" target="#b9">[10]</ref> for further details on how to manipulate Boolean functions efficiently by means of BDDs. With such a representation, the basic operations on sets of states (union, intersection, complement) can be mimicked as Boolean operations on Boolean functions (or, and, not). Moreover, such functions can have a compact representation. In <ref type="bibr" target="#b45">[46]</ref>, some examples are shown in which graphs with 10 18 states can be represented with BDDs having 10 3 nodes by using very naive encodings (one Boolean variable per place). Starting from a simple example of a PN specification shown in Fig. <ref type="figure" target="#fig_32">13a</ref> we will explain the following steps.</p><formula xml:id="formula_24">f v v v v v v ( , , ) 2 3 4 2 3 4 = + corresponding to (a) (b) place v 0 v 1 v 2 v 3 v 4 p 0 0 0 - - - p 1 0 1 - - - p 2 1 0 - - - p 3 1 1 - - - p 4 - - 0 0 - p 5 - - 0 1 - p 6 - - 1 0 - p 6 , p 7 - - - - 0 p 8 - - -<label>- 1 (c)</label></formula><formula xml:id="formula_25">0 1 0 1 1 1 1 1 0 0 0 0 1 0 1 1 5 8<label>3 6 , , , , , , , , , , , , , , , 2 7 &lt;</label></formula><p>• Selection of encoding variables for representing markings of individual places. Instead of the simplest naive encoding, one variable per place, we use a more dense encoding based on state machine decomposition of the original PN. • Traverse the reachability space of the net starting from the initial marking until the fixed point is reached. The traversal is done symbolically, using the BDD representation of Boolean characteristic functions for sets of markings and the transition relation of the net. • As a result of the computation we will get a BDD representation of the characteristic function of the reachability set. This function has the encoding variables as its arguments. • Given this function we show how different operations with sets of markings can be performed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.1">Encoding</head><p>The dense encoding used for the markings of the PN of Fig. <ref type="figure" target="#fig_18">13</ref> is based on the observation that the sets of places P 1 = {p 0 , p 1 , p 2 , p 3 }, P 2 = {p 4 , p 5 , p 6 }, and P 3 = {p 6 , p 7 , p 8 } define three state machines, SM1, SM2, and SM3, of the PN <ref type="bibr" target="#b26">[27]</ref>, <ref type="bibr" target="#b19">[20]</ref> with the following sets of transitions T 1 = {t 1 , t 2 , t 3 , t 4 }, T 2 = {t 1 , t 5 , t 6 }, and T 3 = {t 5 , t 6 , t 7 }, respectively. This information can be structurally obtained by using algebraic methods <ref type="bibr" target="#b19">[20]</ref>. State machines correspond to place-invariants of the PN and preserve their token count in all reachable markings. Given the initial marking of the net, at most one of the places of each state machine will be marked at each marking. Thus, the following encoding can be proposed: two Boolean variables (v 0 and v 1 ) can be used to encode the token in M 1 , two Boolean variables (v 2 and v 3 ) for M 2 . Only one Boolean variable (v 4 ) is sufficient for M 3 , since M 2 already uniquely encodes p 6 (v 2 = 1 Ã p 6 has a token) and only places p 7 and p 8 must be distinguished. The table in Fig. <ref type="figure" target="#fig_32">13c</ref> proposes an encoding for the places that leads to the following characteristics functions for places: </p><formula xml:id="formula_26">place, p c p place, p c p p 0 v v 0 1 p 1 v v 0 1 p 2 v v 0 1 p 3 v 0 v 1 p 4 v v 2 3 p 5 v v 2 3 p 6 v v 2 3 p 7 v v v</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.2">Transition Function and Reachable Markings</head><p>The methods used for deriving the transition function and calculating the reachable markings of a PN are similar to those used for reachability analysis and equivalence checking of finite state machines <ref type="bibr" target="#b25">[26]</ref>.</p><p>For calculating the transition function, let us first introduce the characteristic functions for two important sets related to a transition t ¶ T: Function E(t) (ASM(t)) states that all input (output) places of transition t contain a token. For example, for transition t 1 in Fig. <ref type="figure" target="#fig_32">13a   E</ref> </p><formula xml:id="formula_27">E enabled ASM all successors marked t V t t V</formula><formula xml:id="formula_28">t V V v v v v p p 1 0 1 2 3 0 4 2 7 0 5 0 5 = = c c and ASM t V V v v v v p p 0 5 0 5 0 5 = = c c 1 5 0 1 2 3 .</formula><p>Let M N be the set of all possible markings of a PN N. The transition function of a Petri Net is a function</p><formula xml:id="formula_29">d N M M N N T : 2 2</formula><p>that transforms, for each transition, t, a set of markings M into a new set of markings M one-step reachable from M by firing transition t:</p><formula xml:id="formula_30">= = ¶ $ ¶ % &amp; ' ( ) * M M t m M m M m m N N t d , : ,<label>0 5 2 1 1 2 .</label></formula><p>We illustrate the calculation of the transition function with an example (for a more detailed explanation of the algorithms, see <ref type="bibr" target="#b45">[46]</ref>). Assume that, in the example of Fig. <ref type="figure" target="#fig_32">13a</ref>, we calculate M = d N (M, t 1 ) given the set of markings: M = {{p 0 , p 4 , p 7 }, {p 0 , p 4 , p 8 }, {p 3 , p 6 }} represented by the characteristic Boolean function: First, by calculating</p><formula xml:id="formula_31">M v v v v v v v v v</formula><formula xml:id="formula_32">M E t v v v v ¿ = ( ) 1 0 1 2 3 ,</formula><p>one selects those markings from M in which t 1 is enabled. After that, we determine all literals that are logically implied by the characteristic functions of input places of transition t 1 , i.e., places p 0 and p 4 . The following implications hold:</p><formula xml:id="formula_33">c p v 0 0 AE , c p v 0 1 AE , c p v 4 2</formula><p>AE , and c p v</p><formula xml:id="formula_34">4 3</formula><p>AE . All implied literals should be cofactored from function M ¿ E(t). 4 The result is</p><formula xml:id="formula_35">( ( )) M E t v v v v ¿ ¢ 0 1 2 3</formula><p>1. Informally, this corresponds to re-</p><formula xml:id="formula_36">4. The cofactor of f(v 1 , ¤, v i , ¤, v n ) with respect to literal v i , denoted by f v i , is f(v 1 , ¤, 1, ¤, v n ) and with respect to literal v f i v i , , is f(v 1 , ¤, 0,¤, v n ).</formula><p>The notion of cofactor can be generalized to a product of literals, e.g.,</p><formula xml:id="formula_37">f f v v v v i , ( ) 2 1 2 = [10].</formula><p>moving predecessor places of t 1 from the characteristic function. The final step is adding successor places of t 1 into the characteristic function, which is done by calculating conjunction of the previous result with ASM(t 1 ):</p><formula xml:id="formula_38">M E t ASM t v v v v v v v v ¿ ¿ = 0 5 2 7 2<label>7</label></formula><formula xml:id="formula_39">0 1 2 3 1 0 1 2 3 .</formula><p>This result is the characteristic function of M, which can be considered as a Boolean version of the marking equation of the PN. The existential quantification of t from the above formula gives the set of markings d N (M) reachable by firing any one enabled transition from a marking in M. 5  In such a way, starting from the initial marking, by iterative application of the transition function we calculate the characteristic function of the reachability set until the fixed (free-choice), (h) (P 1 P 2 )\{a} (minmized), (i) (P 1 P 2 )\{a} (free choice).</p><formula xml:id="formula_40">5. The existential abstraction of f(v 1 , ¤, v i , ¤, v n ) with respect to v i is $ = + v v v i i i f f f ( ) [10]. (a) (b) (c) (d) (e) (f) (g) (h) (i) (j)</formula><p>point in calculation is reached. The resulting function for the reachability set for the example considered above is</p><formula xml:id="formula_41">f v v v v v v ( , , )<label>2 3 4 2 3 4</label></formula><p>= + . All calculations are done using a BDD representation of the corresponding characteristic Boolean functions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.3">Minimal Preregions and Excitation Closure</head><p>As an example of the type of operations that can be performed with BDDs, we give some further details on the calculation of minimal preregions and excitation closure.</p><p>Given a set of states and a transition function, successor and predecessor states reachable in one step from the given set can be obtained by applying the direct and inverse transition function, respectively. This is the main operation performed in the function expand_states (see Fig. <ref type="figure" target="#fig_15">10</ref>) to legalize events according to the conditions of Lemma 4.2 and obtain minimal preregions.</p><p>Checking the excitation closure for an event after the set of minimal preregions has been obtained is now reduced to calculating their intersection (Boolean AND operation) and checking its equivalence to the ER of the event. 6   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">APPLICATIONS</head><p>The methodology presented in this paper has its main application in the area of analysis and synthesis of concurrent systems. Representing a concurrent system with an eventbased model (Petri Net) instead of a state-based model (transition system) has some clear advantages:</p><p>• The relations between events are explicit in the model.</p><p>• The representation is usually much more succinct and does not suffer from the state explosion problem.</p><p>6. Checking equivalence is a constant time operation in most BDD packages.</p><p>• Some properties can be verified at the structural level, without requiring the enumeration of the states of the system.</p><p>PN synthesis, since it starts from a state-based representation and reconstructs the relations, obviously applies mostly to the first aspect. Several applications of this reconstruction have been outlined in Section 1. In this section, we illustrate the usefulness of the method in two synthesis approaches:</p><p>top-down approach: A system is synthesized by composing specifications of communicating subsystems. bottom-up approach: A system is analyzed by composing fragments corresponding to components.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Top-Down Approach: Petri Net Composition</head><p>PN synthesis can be applied to the derivation of specifications obtained by the composition of processes. The semantics of composition is defined as follows: Let us have two processes, each with an alphabet that labels its events (the alphabets may not be disjoint). The composition of the processes is another process that models their concurrent behavior synchronizing on pairs of events with the same label. We refer the reader to <ref type="bibr" target="#b36">[37]</ref>, <ref type="bibr" target="#b56">[57]</ref>, <ref type="bibr" target="#b50">[51]</ref> for a more formal definition of composition.</p><p>The methods known so far to compose PNs are structural <ref type="bibr" target="#b50">[51]</ref>, <ref type="bibr" target="#b56">[57]</ref>, <ref type="bibr" target="#b18">[19]</ref>, i.e., they derive a new PN by combining nodes of the original PNs. These methods may, however, introduce redundancy in the resulting PN because they are conservative when calculating the pairs of synchronizing transitions. Moreover, they do not allow one to obtain, e.g., a Free-Choice composed PN, even when this is possible.</p><p>Fig. <ref type="figure" target="#fig_23">14</ref> depicts an example of how PN synthesis can be used for the synthesis of concurrent systems by composition of subsystems. The example obtains a system from two concurrent processes, P 1 and P 2 , that synchronize through a common event a. By composing TSs and eventually hiding the nonobservable events of the communication, different PNs can be derived. Fig. <ref type="figure" target="#fig_23">14</ref> shows specifications for P 1 ʈ P 2 and (P 1 ʈ P 2 )\{a} (after hiding event a).</p><p>For each case, two different PNs are obtained: one by minimizing the number of transitions of the PN and the other by forcing the net to be free choice. Each case pursues different goals. The former attempts to find the most succinct representation for the system by minimizing the transition and place count of the PN. The latter attempts to minimize the flow relation of the PN, i.e., the number of arcs, in order to find a more readable representation from the point of view of the designer, at the expense of losing optimality in the transition and place counts. Note that the free-choice nets 7 of the example have multiple transitions with the same label, produced by the extra label splitting required to force the free-choice conditions.</p><p>Minimal place and transition counts can be better for manipulating nets by automatic synthesis tools, whereas more readable representations, such as free-choice nets, may be 7. In fact, the resulting nets are Marked Graphs, since they contain no choice places. better for design frameworks with a high interaction with the designer. All the PNs shown in the figure have been obtained automatically by the synthesis tool petrify <ref type="bibr" target="#b15">[16]</ref>.</p><p>This approach allows one to create an efficient link between high-level languages, such as CSP or CCS, and Petri Nets. Through the modeling of the language constructs with basic primitives and the composition of such primitives, a netlist of communicating subsystems can be obtained <ref type="bibr" target="#b55">[56]</ref>. A Petri Net for the whole system can be derived by composing the Petri Nets that model the behavior of the basic primitives. Such an approach has been used in <ref type="bibr" target="#b46">[47]</ref> to synthesize asynchronous circuits from CSP-like descriptions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">Efficiency of PN Synthesis</head><p>Table <ref type="table" target="#tab_7">2</ref> describes the results of the application of our algorithms to the minimization of labeled Petri Nets. The examples (taken from the set of standard benchmarks for asynchronous control circuits <ref type="bibr" target="#b33">[34]</ref>) correspond to specifications of asynchronous circuits that have been produced manually by system designers. P, T, F, and M are the numbers of places, transitions, arcs, and markings, respectively.  The table illustrates the trade-off between succinctness and readability of the PNs. We have used the ratio arcs/node as a measure of (un)readability. The results show that significant reductions in the number of nodes can be obtained (35 percent less nodes, 1.73 arcs/node on average). If priority is given to readability (free-choice nets), satisfactory reductions are still achieved (10 percent less nodes, 1.18 arcs/node on average). Note also that the number of markings is sometimes reduced, since equivalent states can be merged. Fig. <ref type="figure" target="#fig_24">15</ref> depicts the synthesized PNs for one of the examples of Table <ref type="table" target="#tab_7">2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Bottom-Up Approach: Analysis of Concurrent Systems</head><p>PN synthesis can also be used for the analysis of systems. Table <ref type="table" target="#tab_8">3</ref> describes the results of the application of our algorithms to the synthesis of Petri Nets from TSs obtained from speed-independent circuits (all examples are described in <ref type="bibr" target="#b31">[32]</ref>). This can be used to produce a user-readable description of the functionality of a circuit in the form of a timing diagram-like labeled Petri Net (a Signal Transition Graph, STG). Another potential application is to optimize the input to direct synthesis methods that have been devised for Petri Nets using both synchronous and asynchronous circuit design techniques ( <ref type="bibr" target="#b38">[39]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b43">[44]</ref>). Fig. <ref type="figure" target="#fig_25">16</ref> illustrates one of the examples shown in Table <ref type="table" target="#tab_8">3</ref> (a4_tflo1). Initially, a TS is derived by calculating all reachable states of the circuit (symbolic techniques can be used here). A Petri Net capturing the behavior of all gate outputs can be obtained by synthesis (Fig. <ref type="figure" target="#fig_32">16b</ref>). Finally, since the user is probably only interested in the observable behavior of the circuit, a projection of the TS onto the observable signals can be done and a simplified Petri Net can be obtained (Fig. <ref type="figure" target="#fig_32">16c</ref>). The simplified Petri Net can now be used to resynthesize the circuit and generate different implementations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Application to Large Transition Systems</head><p>The manipulation of the state space by means of BDDs enables synthesis of Petri Nets with large reachability graphs. We have chosen one scalable example to illustrate this fact (see Fig. <ref type="figure" target="#fig_26">17</ref>). It is an n stage pipeline with forward synchronization through events b i b i+1 and backward synchronization through events c i c i+1 . Fig. <ref type="figure" target="#fig_32">17a</ref> depicts a five-stage pipeline. In general, the Petri Net has 6n places, 4n transitions, and 12n arcs, n being the number of stages.</p><p>The minimization of the Petri Net is not trivial (see Fig. <ref type="figure" target="#fig_32">17b</ref>) since, besides the regular structure derived from the pipeline, it requires some extra places (shadowed in the figure) for the proper initialization of the firing sequences.  Petri Net. The rest of the running time is used to calculate the reachability graph and find a good encoding for the final synthesis step. 8 The reported BDD sizes correspond to the characteristic function of the reachable states after having found an efficient encoding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSIONS</head><p>Petri Nets are an appropriate formalism to describe the behavior of systems with concurrency, causality, and conflicts between events. For this type of systems, the method presented in this paper allows one to transform different models (CSP, CCS, FSMs, PNs) into a unique formalism for which synthesis, analysis, composition, and verification tools can be built. Synthesizing Petri Nets from state-based models is a task of reverse engineering that abstracts the temporal dimension from a flat description of the sequences of events produced by the system. The synthesis method discovers the actual temporal relations among the events. The cooperation among the notions of ETS, region, and excitation region in the same method has been crucial to derive efficient algorithms.</p><p>One can ask about the real need to generate a flat description (a TS) from compact models (CSP, CCS, or even PNs) that can describe temporal relations in a natural way. An alternative way of doing so would be to obtain PNs by means of syntax-directed translation from those models. We have shown some experiments that illustrate the interest in 8. The tool petrify attempts to improve the encoding of the reachability space after the latter has been calculated. Although this helps making the forthcoming steps more efficient, it becomes the dominant part of the running time in some cases.</p><p>going through transition systems. The results on synthesis from an STG into an STG showed how the behavioral descriptions proposed by the designers can be usually made more compact (some temporal relations are not easy to describe and designers are often tempted to derive an FSMlike description). The discussion about PN composition also showed that previous composition methods can produce redundant specifications. Much simpler descriptions can be obtained by first generating a TS, removing internal events (not relevant to the external behavior of the system), and deriving a PN.</p><p>Generating a TS from a high-level description (such as CSP) may suffer from the state explosion problem, thus making manipulations at the TS level tedious or even impractical. For this reason, we have chosen to use a symbolic (BDDbased) representation of the TS. Even though BDDs do not always guarantee compactness, we have observed that the regular interleaving of events manifested by highly concurrent systems is well-captured by symbolic representations.</p><p>This work has been mainly motivated by the activities carried out by the authors in the area of asynchronous circuits. However, the method for PN synthesis presented here can be equally applied for optimization of control structures of parallel programs <ref type="bibr" target="#b49">[50]</ref> or manufacturing systems <ref type="bibr">[58]</ref>. The wide applicability of the method opens new possibilities to create a framework with tools for synthesis, analysis, and verification in which the designer can freely choose and mix different specification formalisms. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX: PROOFS OF THE MAIN STATEMENTS</head><p>Proof of Theorem 3.1</p><p>The following two lemmas proven in <ref type="bibr" target="#b16">[17]</ref>  </p><formula xml:id="formula_42">s i Rs[p j ] Ã s i ¶ p j .</formula><p>From Definition 2.6 and the construction of TS 5 , it follows that R is a bisimulation between TS and TS 5 : 2) From the definition of TS 5 , it follows that, for an ECTS, r is a region of TS Ã [r] is a region of TS 5 .</p><formula xml:id="formula_43">• (i</formula><p>Since there is a one-to-one correspondence between regions of TS and TS 5 , it immediately follows that excitation closure and event effectiveness are preserved in TS 5 . Hence, (A5) also holds. was the first exit transition for r on s.</p><p>2) s" ¶ r, i.e., r does not cross s before s".</p><p>This case is easily reduced to the previous one. place is marked, there is always some predecessor place that is not marked. Therefore, the net is contactfree <ref type="bibr" target="#b41">[42]</ref> and, thus, behaves as a PN.</p><p>We will also denote by (•e) I and (•e) TS the set of input places of event e in N I and N TS , respectively.</p><p>We will first prove that: , , , , .</p><p>The proof for the definition of T I immediately implies those for S I and E I . Thus, we will prove that s e s T s e s T s s I s s I</p><formula xml:id="formula_44">I 1 2 1 2 1 1 2 2</formula><p>, , , , AE . Therefore, the hypothesis also holds for n + 1.</p><p>Ä By induction on the length n of the shortest sequence that leads to s 1 . As above, it holds for n = 0.</p><p>Assume that there is a sequence s s I and the hypothesis also holds for n + 1. Now, the bisimilarity between TS and RG(N I ) can be proved by defining a bisimulation R between S and S I as follows:</p><formula xml:id="formula_45">sRs s s I def Ã = -.</formula><p>The conditions for R to be a bisimulation can be trivially proved and are left for the reader. o</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. A framework for synthesizing PNs and transforming specifications.</figDesc><graphic coords="2,116.95,60.99,330.83,183.94" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. An example of Transition System (a), a corresponding PN (b), and its RG (c).</figDesc><graphic coords="4,227.42,62.97,108.06,120.56" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Examples of elementary (a) and nonelementary (b) TSs.</figDesc><graphic coords="5,296.78,60.99,90.68,164.15" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4</head><label>4</label><figDesc>Fig. 4 illustrates the notions of isomorphism, splitmorphism, and bisimulation between TSs. The splitmorphism of Fig. 4b maps two different instances of an event (a 1 and a 2 ) onto the same event (a).The work presented in this paper is based on transformations between split-morphic or bisimilar TSs. These notions of equivalence provide stronger conditions than language equivalence in general (<ref type="bibr" target="#b36">[37]</ref>). This implies, for example, that deadlock and liveness properties will be preserved for a PN generated from the TS.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>DEFINITION 3 . 2 (A. 4 )A. 5 )</head><label>3245</label><figDesc>Excitation-closed TS (ECTS)). A transition system TS = (S, E, T, s in) is called excitation-closed if it satisfies the following two axioms: Excitation closure: For each event a: Event effectiveness: For each event a: °a ¡ ®.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. (a) Isomorphism, (b) Split-morphism, (c) Bisimulation.</figDesc><graphic coords="7,91.38,62.10,84.25,79.46" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>THEOREM 3 . 3 .</head><label>33</label><figDesc>Let TS = (S, E, T, s in ) be an ETS. If TS is not minimal, then for any pair of bisimilar states, s 1 , s 2 ¶ S, s 1 and s 2 are not confluent.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 5 .Fig. 6 .</head><label>56</label><figDesc>Fig. 5. (a) Nonelementary ECTS, (b) Bisimilar ETS after merging region-based equivalent states, (c) Petri Net after synthesis of the ETS.</figDesc><graphic coords="8,137.93,135.91,86.71,94.90" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>THEOREM 3 . 4 .. 1 .THEOREM 3 . 5 .</head><label>34135</label><figDesc>Let TS = (S, E, T, s in ) be an ETS and let N saturated net obtained by the algorithm "saturated PN synthesis" from Section 2.5.1. Let I µ R TS be a subset of regions of TS and let I = R TS -I be such that the excitation closure condition is satisfied without I: Let N I = (I, E, F I , s I ) be a net where s F TS -{(r, e), (e, r)|r ¶ I}. Then, RG(N I ) is bisimilar to TS. The proof outline of this theorem is given in the Appendix. The converse of Theorem 3.4 is trivially true, i.e., if I µ R TS does not satisfy the excitation closure condition for event e, then RG(N I ) is not bisimilar to the TS. Discrepancy in behavior will occur in any state from r There exists a subset I µ R TS such that I contains only minimal preregions and RG(N I ) is bisimilar to TS. Next, we state a relationship between irredundant sets of regions and place-irredundant nets. DEFINITION 3.5. (Place-irredundant net). A labeled Petri Net is place-irredundant if no place can be removed from it without losing the bisimilarity of the RG. DEFINITION 3.6 (Irredundant set of regions). Let TS be a Transition System. A set of regions R is called redundant if there is a region r ¶ R such that R -{r} still satisfies the excitation closure condition. Otherwise, R is called irredundant. Let N I = (I, E, F I , s I ) be a safe pure PN obtained from an ETS TS, as described by Theorem 3.4. If I is an irredundant set of regions, then N I is place-irredundant.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. (a) Minimal saturated PN, (b) RG with each state labeled with the indices of the marked places, (c) place-redundant PN, (d) bisimilar RG, (e) minimal nonelementary and not excitation closed TS.</figDesc><graphic coords="9,37.30,60.99,502.13,132.21" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. ECTS, its place-irredundant and place-minimal net.</figDesc><graphic coords="10,89.43,67.03,147.71,147.71" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Framework for the synthesis of PNs from TSs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>1 )</head><label>1</label><figDesc>in(e, r) Á [enter(e, r) Â exit(e, r)] AE {s|$s ¶ r : (s, e, s) ¶ T Â (s, e, s) ¶ T} µ r 2) enter(e, r) Á exit(e, r) AE {s|$s ¶ r : (s, e, s) ¶ T Â (s, e, s) ¶ T} µ r 3) out(e, r) Á enter(e, r) AE [{s|$s ¶ r : (s, e, s) ¶ T} µ r] Â [{s|$s • r: (s, e, s) ¶ T} µ r] 4) out(e, r) Á exit(e, r) AE [{s|$s ¶ r : (s, e, s) ¶ T} µ r] Â [{s|$s • r : (s, e, s) ¶ T} µ r].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. Pseudocode for the algorithm to synthesize Petri Nets.</figDesc><graphic coords="11,108.11,60.99,360.54,263.03" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. (a) Transition system. (b) Minimal saturated net. (c) Place-irredundant net. TABLE 1 ALL MINIMAL PREREGIONS OF THE TRANSITION SYSTEM DEPICTED IN FIG. 11A preregion events preregion events preregion events r 0 = {s 2 , s 5 , s 6 } c r 1 = {s 2 , s 4 , s 6 } c,e r 2 = {s 2 , s 3 , s 5 } d r 3 = {s 2 , s 3 , s 4 } e r 4 = {s 3 , s 5 , s 7 } d,f r 5 = {s 5 , s 6 , s 7 } f r 6 = {s 3 , s 4 , s 7 } e,f r 7 = {s 4 , s 6 , s 7 } e,f r 8 = {s 1 } a,b</figDesc><graphic coords="12,83.56,60.99,397.62,122.91" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. (a) TS, (b) expansion tree for preregions of event c, (c) split-morphic ECTS, (d) PN, (e) RG of the PN.</figDesc><graphic coords="13,156.13,234.90,114.63,163.96" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Fig. 13 .</head><label>13</label><figDesc>Fig. 13. (a) Petri Net, (b) BDD representing the set of reachable markings, and (c) place encoding.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head></head><label></label><figDesc>Note that, since variable v 4 has value 0 both for places p 6 and p 7 and its characteristic function c p 6 depends only on variables corresponding to the second state machine, SM2, the characteristic function for p 7 is</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>Fig. 14 .</head><label>14</label><figDesc>Fig. 14. Synchronized composition of transition systems and synthesis of minimized and free-choice Petri Nets (for simplicity, 1-input/1-output places are represented by a transition-transition arc). (a) P 1 , (b) P 2 , (c) P 1 P 2 , (d) (P 1 P 2 )\{a}, (e) P 1 , (f) P 2 , (f) P 1 P 2 (minimized), (g) P 1 P 2</figDesc><graphic coords="16,39.68,279.46,485.38,175.35" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>Fig. 15 .</head><label>15</label><figDesc>Fig. 15. rcv-setup: (a) Initial Petri Net, (b) Petri Net with minimum transition count, and (c) minimized free-choice PN.</figDesc><graphic coords="18,212.87,60.99,180.38,281.54" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head>Fig. 16 .</head><label>16</label><figDesc>Fig. 16. (a) Speed-independent circuit (initially, A = Q = U1 = 0, B = Q1 = U = Y = Y1 = 1), (b) Petri Net with bisimilar behavior, (c) Petri Net describing the observable behavior (+ andindicate rising and falling transitions of the signals).</figDesc><graphic coords="19,227.79,60.99,161.35,322.44" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head>Fig. 17 .</head><label>17</label><figDesc>Fig. 17. (a) Five-stage pipeline, (b) minimized Petri Net, (c) experimental results.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head>2 PROOF . 1 ).</head><label>21</label><figDesc>a, i b) trivially hold, since R is a surjective mapping from S onto [S]. • (ii a): Assume that (s 1 , e, s 2 ) ¶ T. Let s 1 ¶ p 1 and s 2 ¶ p 2 . Since TS is an ECTS, p 1 and p 2 are different classes. s[p 1 ] and s[p 2 ] are the only states related with s 1 and s 2 , respectively and, by the construction of TS 5 , (s[p 1 ], e, s[p 2 ])) ¶ T 5 . • (ii b): Assume that (s[p 1 ], e, s[p 2 ]) ¶ T 5 . Then, for each s 1 ¶ p 1 , there exists (s 1 , e, s 2 ) ¶ T such that s 2 ¶ p 2 (this is ensured by Lemmas 6.1 and 6.2). o Proof of Theorem 3.It was proven in [17] (Lemma 3.1) that if the state separation property (A4) is satisfied for a TS, then the event effectiveness property (A5) holds. Hence, we need to prove excitation closure (A4). Due to (A5), "e ¶ E intersection r r e ¶ o I is de- fined since °e ¡ ®. By definition of preregion, Let e be an arbitrary event and let state s belong to r r e ¶ o I . Then, for any region r ¶ °e : s ¶ r. Hence, the left part of the implication of the axiom A5, o e R s µ , holds. By assumption, the TS is elementary, hence, the right part of the implication must hold and, therefore, s e . Hence, s ¶ GER(e). Therefore, the TS is excitation-closed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_28"><head></head><label></label><figDesc>Really, the following conditions are true: °e ¡ ® and " event e ¶ E and a state s ¶ S and let us assume that o e R s µ . Then, "r ¶ °e AE r ¶ R s and, hence, "r ¶ °e AE s ¶ r. From the latter, we deduce that s r e ¶ ¶ o I . Then, by the excitation closure condition, we have s ¶ GER(e); hence, s e . (A4) is directly enforced by the definition of the set of states of TS 5 . Therefore, TS 5 is elementary. o Proof of Theorem 3.3 PROOF. Let us actually prove a stronger statement, assuming only that the TS satisfies state separation (A4). Assume the opposite, i.e., axiom A4 is satisfied and there is a pair of bisimilar states s and s', s ¡ s', for which the confluence condition is satisfied. It follows from axiom A4 that there is a region r such that r ¶ R s and r • R s' . Due to the confluence condition, the following condition holds: There is a state s" ¶ S and two sequences of transitions s, s' ¶ T* such that s s s s Á leading from s, labeled, e.g., with e 3 , which exits region r. This transition must occur before s</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_29"><head></head><label></label><figDesc>Indeed, since r • R s' then the boundaries of r must cross s', a sequence leading from s' to s". We can then use coregion r S r = -(a region complementary to r). Region r crosses s' and must include state s' by the definition of complementary region. Thus, in both cases, we have reached contradiction, and, therefore, s = s' must be true. o Proof of Theorem 3.4 PROOF. Let RG(N I ) = (S I , E I , T I , s I ). By Theorem 2.1, RG(N TS ) is isomorphic to TS. Therefore, and for the sake of simplicity in the notation, we will assume TS to be the RG of N TS with S µ R TS . Since N TS is a saturated net, if r ¶ e°, then r e ¶ o . Hence, for any transition, if some successor</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_31"><head>AEs 1 .AE</head><label>1</label><figDesc>By induction on the length, n, of the shortest sequence that leads to s 1 from s in . Initially, we have that s in ¶ S and s I ¶ S I . Therefore, it holds for n = 0. Assume that there is a sequence of events s s in s 1 of length n. By the induction hypothesis s s I Since (•e) I = (•e) TS -I' and = - . According to the firing rules of a PN and = -</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_32"><head>1 in</head><label>1</label><figDesc>, s 1 is also a set of preregions of e in TS such that ( ) TS and, therefore, it follows that e is enabled in s 1 in N(TS). Again, according to the firing rules of a PN and the fact that = -</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>This is denoted by s s</figDesc><table><row><cell>s</cell></row><row><cell>or simply by</cell></row><row><cell>s s</cell></row></table><note><p>* if the sequence is not important. We also write s e , s s , e s , and s s if there is a state s ¶ S such that s s e , s s s , s s e , or s s s , correspondingly. Each state is reachable from itself, since we allow empty sequences in the definition.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>r 1 , r 2 , r 4 , r 5 and there is no other state which is covered by the same set of regions (see Section 2.3 for the list of all regions). To illustrate axiom (A5), let us consider event a. For two states, s 1 and s 5 , condition o a R s µ</head><label></label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell>: o</cell><cell>s</cell><cell>s</cell><cell>e</cell></row><row><cell cols="5">(A4) implies that two different states must belong to dif-</cell></row><row><cell cols="5">ferent sets of regions. (A5) implies that if state s is included</cell></row><row><cell cols="5">in all preregions of event e, then e must be enabled in s. It is</cell></row><row><cell cols="5">easy to see that the TS shown in Fig. 2 is elementary, since</cell></row><row><cell cols="5">all axioms (A1)-(A5) are satisfied. For example, state s 1 is</cell></row><row><cell cols="5">separated from any other state (axiom (A4)). This state is</cell></row><row><cell>included into regions 1 and o a R s µ</cell><cell>5</cell><cell cols="3">holds. Both states can have an exit</cell></row><row><cell cols="5">arc labeled by event a. Hence, Axiom (A5) is satisfied.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>For each region r i ¶ R TS , generate a place r i ; • Place r i contains a token in the initial marking iff the corresponding region r i contains the initial state of the ETS s in ; • The flow relation is as follows: e ¶ r i • iff r</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>to synthe-</cell></row><row><cell>size a PN, N</cell><cell>TS</cell><cell>= (</cell><cell>R E F R TS TS s in , , ,</cell><cell cols="2">), from an ETS, TS = (S, E,</cell></row><row><cell cols="2">T, s F TS</cell><cell></cell><cell>r e r R TS</cell><cell>e E r</cell><cell>e</cell></row><row><cell></cell><cell></cell><cell></cell><cell>e r r R TS</cell><cell cols="2">e E r e</cell></row></table><note><p><p><p>in ), is as follows:</p>Algorithm: saturated PN synthesis</p>• For each event e ¶ E, generate a transition labeled with e in the PN; • i is a preregion of e and e ¶ •r i iff r i is a postregion of e, i.e.,</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>Fig. 5a depicts a nonelementary TS in which two pairs of states, {s 0 , s 4 } and {s 1 , s 5 } are region-based equivalent. The set of all equivalence classes of states is [S] = {p 1 , p 2 , p 3 , p 4 } = {{s 0 , s 4 }, {s 1 , s 5 }, {s 2 }, {s 3 }} and p in = p 1 . The corresponding region-separated TS is shown in Fig.</figDesc><table /><note><p><p><p>where [S] is defined above,</p>(s[p 1 ], e, s[p 2 ]) ¶ T 5 Ã $s 1 ¶ p 1 , s 2 ¶ p 2 : (s 1 , e, s 2 ) ¶ T and s in ¶ p in .</p>It is easy to show that T 5 is well-defined, i.e., if (s[p 1 ], e, s[p 2 ]), then "s 1 ¶ p 1 $s 2 ¶ p 2 : (s 1 , e, s 2 ) ¶ T and vice versa.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>3.7 (Place-minimal net). A labeled Petri Net is place-minimal if any other bisimilar PN contains a greater or equal number of places.</figDesc><table /><note><p><p>DEFINITION 3.8  </p>(Minimal set of regions). Let TS be a Transition System. A set of regions R is called minimal if it is irredundant and any other irredundant set of regions contains a greater or equal number of regions.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>TABLE 2 RESULTS</head><label>2</label><figDesc>ON SYNTHESIS MINIMIZED PNS AND FREE-CHOICE PNS</figDesc><table><row><cell>example</cell><cell></cell><cell cols="2">initial PN</cell><cell></cell><cell></cell><cell cols="2">minimized PN</cell><cell></cell><cell cols="3">minimized FC PN</cell><cell>CPU</cell></row><row><cell></cell><cell>P</cell><cell>T</cell><cell>F</cell><cell>M</cell><cell>P</cell><cell>T</cell><cell>F</cell><cell>M</cell><cell>P</cell><cell>T</cell><cell>F</cell><cell>( s e c s )</cell></row><row><cell>alloc-outbound</cell><cell>17</cell><cell>18</cell><cell>36</cell><cell>17</cell><cell>13</cell><cell>14</cell><cell>37</cell><cell>16</cell><cell>16</cell><cell>17</cell><cell>34</cell><cell>0.1</cell></row><row><cell>clock</cell><cell>10</cell><cell>10</cell><cell>20</cell><cell>10</cell><cell>8</cell><cell>5</cell><cell>26</cell><cell>10</cell><cell>10</cell><cell>10</cell><cell>20</cell><cell>0.1</cell></row><row><cell>dff (*)</cell><cell>20</cell><cell>20</cell><cell>44</cell><cell>20</cell><cell>8</cell><cell>8</cell><cell>29</cell><cell>10</cell><cell>10</cell><cell>14</cell><cell>28</cell><cell>0.7</cell></row><row><cell>espinalt</cell><cell>27</cell><cell>25</cell><cell>57</cell><cell>27</cell><cell>19</cell><cell>20</cell><cell>52</cell><cell>26</cell><cell>26</cell><cell>24</cell><cell>54</cell><cell>1.1</cell></row><row><cell>f a i r _ a r b</cell><cell>1 3</cell><cell>2 0</cell><cell>4 0</cell><cell>1 3</cell><cell>1 1</cell><cell>1 0</cell><cell>3 1</cell><cell>1 3</cell><cell>1 3</cell><cell>2 0</cell><cell>4 0</cell><cell>0 . 2</cell></row><row><cell>future</cell><cell>30</cell><cell>28</cell><cell>60</cell><cell>36</cell><cell>18</cell><cell>16</cell><cell>38</cell><cell>36</cell><cell>30</cell><cell>28</cell><cell>60</cell><cell>1.1</cell></row><row><cell>gcd-ra (*)</cell><cell>66</cell><cell>58</cell><cell>136</cell><cell>3,240</cell><cell>43</cell><cell>40</cell><cell>110</cell><cell>3,090</cell><cell>64</cell><cell>56</cell><cell>136</cell><cell>27.3</cell></row><row><cell>intel_div3</cell><cell>8</cell><cell>8</cell><cell>16</cell><cell>8</cell><cell>8</cell><cell>6</cell><cell>2 3</cell><cell>8</cell><cell>8</cell><cell>8</cell><cell>1 6</cell><cell>0 . 1</cell></row><row><cell>intel_edge</cell><cell>28</cell><cell>36</cell><cell>72</cell><cell>28</cell><cell>17</cell><cell>25</cell><cell>111</cell><cell>25</cell><cell>24</cell><cell>32</cell><cell>64</cell><cell>6.5</cell></row><row><cell>isend (*)</cell><cell>56</cell><cell>44</cell><cell>116</cell><cell>53</cell><cell>20</cell><cell>19</cell><cell>89</cell><cell>36</cell><cell>39</cell><cell>36</cell><cell>100</cell><cell>8.1</cell></row><row><cell>lin_edac93</cell><cell>14</cell><cell>12</cell><cell>28</cell><cell>20</cell><cell>10</cell><cell>8</cell><cell>22</cell><cell>20</cell><cell>14</cell><cell>12</cell><cell>28</cell><cell>0.3</cell></row><row><cell>master-read</cell><cell>36</cell><cell>26</cell><cell>72</cell><cell>8,932</cell><cell>33</cell><cell>26</cell><cell>66</cell><cell>8,932</cell><cell>33</cell><cell>26</cell><cell>66</cell><cell>5.7</cell></row><row><cell>pe-rcv-ifc</cell><cell>43</cell><cell>38</cell><cell>96</cell><cell>46</cell><cell>20</cell><cell>20</cell><cell>105</cell><cell>36</cell><cell>37</cell><cell>32</cell><cell>87</cell><cell>5.6</cell></row><row><cell>pulse</cell><cell>12</cell><cell>12</cell><cell>24</cell><cell>12</cell><cell>7</cell><cell>6</cell><cell>20</cell><cell>12</cell><cell>12</cell><cell>12</cell><cell>24</cell><cell>0.1</cell></row><row><cell>rcv-setup</cell><cell>14</cell><cell>15</cell><cell>32</cell><cell>14</cell><cell>10</cell><cell>10</cell><cell>34</cell><cell>11</cell><cell>11</cell><cell>12</cell><cell>26</cell><cell>0.2</cell></row><row><cell>vme_read (*)</cell><cell>41</cell><cell>32</cell><cell>84</cell><cell>255</cell><cell>32</cell><cell>27</cell><cell>114</cell><cell>251</cell><cell>38</cell><cell>30</cell><cell>92</cell><cell>9.7</cell></row><row><cell>vme_write (*)</cell><cell>49</cell><cell>36</cell><cell>100</cell><cell>821</cell><cell>38</cell><cell>31</cell><cell>139</cell><cell>817</cell><cell>46</cell><cell>34</cell><cell>112</cell><cell>20.8</cell></row><row><cell>Total</cell><cell>484</cell><cell>438</cell><cell cols="2">1,033 13,552</cell><cell>315</cell><cell>291</cell><cell cols="2">1,046 13,349</cell><cell>431</cell><cell>403</cell><cell>987</cell><cell></cell></row><row><cell>Reduction</cell><cell>1.00</cell><cell>1.00</cell><cell>1.00</cell><cell>1.00</cell><cell>0.65</cell><cell>0.66</cell><cell>1.01</cell><cell>0.99</cell><cell>0.89</cell><cell>0.92</cell><cell>0.96</cell><cell></cell></row><row><cell>arcs/node</cell><cell></cell><cell>1.12</cell><cell></cell><cell></cell><cell></cell><cell>1.73</cell><cell></cell><cell></cell><cell></cell><cell>1.18</cell><cell></cell><cell></cell></row><row><cell cols="3">((*) silent events hidden before synthesis)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>TABLE 3 SYNTHESIS</head><label>3</label><figDesc>OF PETRI NETS FROM SPEED-INDEPENDENT CIRCUITS</figDesc><table><row><cell>circuit</cell><cell>signals</cell><cell>states</cell><cell>places</cell><cell>transitions</cell><cell>arcs</cell><cell cols="2">markings CPU (secs)</cell></row><row><cell>unsafe</cell><cell>5</cell><cell>22</cell><cell>17</cell><cell>12</cell><cell>46</cell><cell>22</cell><cell>0.7</cell></row><row><cell>a4_tflo1</cell><cell>8</cell><cell>20</cell><cell>17</cell><cell>16</cell><cell>40</cell><cell>20</cell><cell>0.2</cell></row><row><cell>a_10_dr2</cell><cell>50</cell><cell>9,408</cell><cell>93</cell><cell>100</cell><cell>336</cell><cell>9,408</cell><cell>1,582.4</cell></row><row><cell>a_11_sen</cell><cell>19</cell><cell>85</cell><cell>38</cell><cell>38</cell><cell>93</cell><cell>85</cell><cell>4.6</cell></row><row><cell>dags55</cell><cell>19</cell><cell>130</cell><cell>33</cell><cell>38</cell><cell>187</cell><cell>130</cell><cell>54.9</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>The final Petri Net has 4n + 4 places, 3n transitions, and 10n + 8 arcs.</figDesc><table /><note><p>It is worth noting that small BDDs (e.g., 1,117 nodes) can represent large state spaces (e.g., 2.2 10 17 states). From the total CPU time reported in the table of results, only a small fraction (about 10 percent) is used to synthesize the final</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>are required for the proof. LEMMA 6.1. Let TS = (S, E, T, s in ) be an ECTS and let s 1 , s 2 ¶ S be two states such that R R Let TS = (S, E, T, s in ) be an ECTS and let s 1 , s 2 ¶ S be two states such that R R</figDesc><table><row><cell>$  ¶ s 1</cell><cell>S s e s 1 1 : , , 2 7</cell><cell cols="2">s 1  ¶ Ã $  ¶ s = . Then, for each event e  ¶ E, 2  ¶ T s S s e s T 2 2 2 : , , 2 7 .</cell></row><row><cell cols="3">LEMMA 6.2. s 1 s e s T s e s = 1 1 2 2 , , , ,  ¶ Á 2 7 2</cell><cell>7</cell><cell>s  ¶ AE . Then, for each event e  ¶ E, 2 T R R s s 1 2 = .</cell></row><row><cell cols="4">PROOF (sketch). Let R be the following binary relation be-</cell></row><row><cell cols="2">tween S and [S]:</cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>See Section 5.1 for an example of how label splitting can be used also to increase the readability of the synthesized PN, by forcing it to belong to the subclass known as free-choice.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS AND SYNTHESIS TOOL</head><p>We are grateful to Marta and Maciej Koutny, who directed us towards the existing literature about regions. The theory in this paper has been implemented in petrify, a tool for the synthesis of Petri Nets and asynchronous circuits (available at http://www.lsi.upc.es/~jordic/petrify). This work has been supported in part by Acid-WG (ESPRIT 21949) and CICYT (grant TIC95-0419), by EPSRC (visiting fellowship grants GR/J72486 and GR/J78334, and research grant GR/J52327), and MURST (project "VLSI Architectures").</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Automata, Languages, and Programming: 17th Ann</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Colloquium, Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">443</biblScope>
			<biblScope unit="page" from="16" to="20" />
			<date type="published" when="1990-07">July 1990</date>
		</imprint>
		<respStmt>
			<orgName>Warwick Univ</orgName>
		</respStmt>
	</monogr>
	<note>Automata for Modeling Real-Time Systems</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Arnold</surname></persName>
		</author>
		<title level="m">Finite Transition Systems</title>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
	<note>Fig. 18. Illustration to the proof of Property 3.3</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Polynomial Algorithms for the Synthesis of Bounded Nets</title>
		<author>
			<persName><forename type="first">E</forename><surname>Badouel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bernardinello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Darondeau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">915</biblScope>
			<biblScope unit="page" from="364" to="383" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Theory of Regions</title>
		<author>
			<persName><forename type="first">E</forename><surname>Badouel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Darondeau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Third Advance Course on Petri Nets</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Application and Theory of Petri Nets</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bernardinello</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">691</biblScope>
			<biblScope unit="page" from="89" to="105" />
			<date type="published" when="1993">1993</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
	<note>Synthesis of Net Systems</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">On Synchronic Structure of Transition Systems</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bernardinello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>De Michelis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Petruni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Workshop Structures in Concurrency Theory (STRICT)</title>
		<meeting>Int&apos;l Workshop Structures in Concurrency Theory (STRICT)</meeting>
		<imprint>
			<date type="published" when="1995-05">May 1995</date>
			<biblScope unit="page" from="69" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Transformations and Decompositions of nets</title>
		<author>
			<persName><forename type="first">G</forename><surname>Berthelot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">W</forename><surname>Reisig</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Brauer</surname></persName>
		</editor>
		<editor>
			<persName><surname>Rozenberg</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="page" from="359" to="376" />
			<date type="published" when="1987-02">Feb. 1987</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
	<note>Advances in Petri Nets</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">High Level Synthesis of Synchronous Parallel Controllers</title>
		<author>
			<persName><forename type="first">K</forename><surname>Bilinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Dagless</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 17th Int&apos;l Conf. Applications and Theory of Petri Nets</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>17th Int&apos;l Conf. Applications and Theory of Petri Nets<address><addrLine>Osaka, Japan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-06">June 1996</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="346" to="365" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Logic Minimisation Algorithms for VLSI Synthesis</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bryaton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984">1984</date>
			<publisher>Kluwer Academic</publisher>
			<pubPlace>Hingham, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Symbolic Boolean Manipulation with Ordered Binary-Decision Diagrams</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bryant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="293" to="318" />
			<date type="published" when="1992-09">Sept. 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Practice of Petri Nets in Manufacturing</title>
		<author>
			<persName><forename type="first">F</forename><surname>Di Cesare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Harhalakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Proth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">B</forename><surname>Vernadat</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Chapman &amp; Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Synthesis of Self-Timed VLSI Circuits from Graph-Theoretic Specifications</title>
		<author>
			<persName><forename type="first">T.-A</forename><surname>Chu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987-06">June 1987</date>
			<publisher>Massachusetts Inst. of Technology</publisher>
		</imprint>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A Language for Compositional Specification and Verification of Finite State Hardware Controllers</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE</title>
		<meeting>IEEE</meeting>
		<imprint>
			<date type="published" when="1991-09">Sept. 1991</date>
			<biblScope unit="volume">79</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Complete State Encoding Based on the Theory of Regions</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cortadella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kishinevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kondratyev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lavagno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yakovlev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Symp. Advanced Research in Asynchronous Circuits and Systems</title>
		<meeting>Int&apos;l Symp. Advanced Research in Asynchronous Circuits and Systems</meeting>
		<imprint>
			<date type="published" when="1996-03">Mar. 1996</date>
			<biblScope unit="page" from="36" to="47" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Methodology and Tools for State Encoding in Asynchronous Circuit Synthesis</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cortadella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kishinevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kondratyev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lavagno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yakovlev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design Automation Conf</title>
		<meeting>Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1996-06">June 1996</date>
			<biblScope unit="page" from="63" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Petrify: A Tool for Manipulating Concurrent Specifications and Synthesis of Asynchronous Controllers</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cortadella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kishinevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kondratyev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lavagno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yakovlev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEICE Trans. Information and Systems</title>
		<imprint>
			<biblScope unit="volume">80</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="315" to="325" />
			<date type="published" when="1997-03">Mar. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Deriving Petri Nets from Finite Transition Systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cortadella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kishinevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lavagno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yakovlev</surname></persName>
		</author>
		<idno>UPC-DAC-1996-19</idno>
		<ptr target="ftp://ftp.ac.upc.es/pub/reports/DAC/1996/UPC-DAC-1996-19.ps.Z" />
		<imprint>
			<date type="published" when="1996-06">June 1996</date>
		</imprint>
		<respStmt>
			<orgName>Dept. of Computer Architecture, Universitat Politècnica de Catalunya</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Verification of Sequential Machines Using Boolean Functional Vectors</title>
		<author>
			<persName><forename type="first">O</forename><surname>Coudert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Berthet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Madre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. IFIP Int&apos;l Workshop Applied Formal Methods for Correct VSLI Design, L. Claesen</title>
		<imprint>
			<biblScope unit="page" from="111" to="128" />
			<date type="published" when="1989-11">Nov. 1989</date>
			<pubPlace>Leuven, Belgium</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A Communicating Petri Net Model for the Design of Concurrent Asynchronous Modules</title>
		<author>
			<persName><forename type="first">G</forename><surname>Jong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design Automation Conf</title>
		<meeting>Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1994-04">Apr. 1994</date>
			<biblScope unit="page" from="49" to="55" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Free-Choice Petri Nets</title>
		<author>
			<persName><forename type="first">J</forename><surname>Desel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Esparza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Cambridge Tracts in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<date type="published" when="1995">1995</date>
			<publisher>Cambridge Univ. Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The Synthesis Problem of Petri Nets</title>
		<author>
			<persName><forename type="first">J</forename><surname>Desel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Reisig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="297" to="315" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Trace Theory for Automatic Hierarchical Verification of Speed-Independent Circuits</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Extended State Diagrams and Reactive Systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Drusinsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Dr. Dobb&apos;s J</title>
		<imprint>
			<biblScope unit="page" from="72" to="80" />
			<date type="published" when="1994-10">Oct. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Partial (Set) 2-Structures, Parts I II</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ehrenfeucht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rozenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="315" to="368" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Decidability Issues for Petri Nets</title>
		<author>
			<persName><forename type="first">J</forename><surname>Esparza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Nielsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Petri Nets Newsletter</title>
		<imprint>
			<biblScope unit="volume">94</biblScope>
			<biblScope unit="page" from="5" to="23" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Logic Synthesis and Verification Algorithms</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Hachtel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Kluwer Academic</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Analysis of Production Schemata by Petri Nets</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hack</surname></persName>
		</author>
		<idno>TR 94</idno>
	</analytic>
	<monogr>
		<title level="s">Project MAC, Massachusetts Inst. of Technology</title>
		<imprint>
			<date type="published" when="1972">1972</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Communicating Sequential Processes</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="page" from="666" to="677" />
			<date type="published" when="1978-08">Aug. 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Bounded Delay Timing Analysis of a Class of CSP Programs with Choice</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hulgaard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Burns</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Symp. Advanced Research in Asynchronous Circuits and Systems</title>
		<meeting>Int&apos;l Symp. Advanced Research in Asynchronous Circuits and Systems</meeting>
		<imprint>
			<date type="published" when="1994-11">Nov. 1994</date>
			<biblScope unit="page" from="2" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A Fundamental Theorem of Asynchronous Parallel Computation</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Keller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="103" to="112" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Synthesis of General Petri Nets</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kishinevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cortadella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kondratyev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lavagno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yakovlev</surname></persName>
		</author>
		<idno>57</idno>
	</analytic>
	<monogr>
		<title level="j">IEICE</title>
		<imprint>
			<date type="published" when="1996-05">May 1996</date>
			<pubPlace>Japan</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Kishinevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kondratyev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Taubin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Varshavsky</surname></persName>
		</author>
		<title level="m">Concurrent Hardware: The Theory and Practice of Self-Timed Design</title>
		<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<publisher>John Wiley and Sons</publisher>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Analysis of Discrete Event Coordination</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Kurshan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Algorithms for Synthesis and Testing of Asynchronous Circuits</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lavagno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Kluwer Academic</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Representation of Switching Functions by Vinary Decision Programs</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">Y</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bell System Technical J</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="985" to="999" />
			<date type="published" when="1959">1959</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Minimization of Symbolic Relations</title>
		<author>
			<persName><forename type="first">B</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int&apos;l Conf. Computer-Aided Design</title>
		<meeting>IEEE Int&apos;l Conf. Computer-Aided Design<address><addrLine>Santa Clara, Calif</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990-11">Nov. 1990</date>
			<biblScope unit="page" from="88" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A Calculus of Communication Systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">92</biblScope>
			<date type="published" when="1980">1980</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<title level="m">Communication and Concurrency</title>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Petri Nets and Speed-Independent Design</title>
		<author>
			<persName><forename type="first">D</forename><surname>Misunas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="page" from="474" to="481" />
			<date type="published" when="1973-08">Aug. 1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Petri Nets and Step Transition Systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mukund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int&apos;l J. Foundations of Computer Science</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="443" to="478" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Petri Nets: Properties, Analysis and Applications</title>
		<author>
			<persName><forename type="first">T</forename><surname>Murata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE</title>
		<meeting>IEEE</meeting>
		<imprint>
			<date type="published" when="1989-04">Apr. 1989</date>
			<biblScope unit="volume">77</biblScope>
			<biblScope unit="page" from="541" to="580" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Elementary Transition Systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Nielsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rozenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Thiagarajan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">96</biblScope>
			<biblScope unit="page" from="3" to="33" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Automatic Synthesis of Locally-Clocked Asynchronous State Machines</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Nowick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Computer-Aided Design</title>
		<meeting>Int&apos;l Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1991-11">Nov. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Oldfield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Dorf</surname></persName>
		</author>
		<title level="m">Field-Programmable Gate Arrays: Reconfigurable Logic for Rapid Prototyping and Implementation of Digital Systems</title>
		<imprint>
			<publisher>John Wiley and Sons</publisher>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Polynomial Algorithms for the Synthesis of Hazard-Free Circuits from Signal Transition Graphs</title>
		<author>
			<persName><forename type="first">E</forename><surname>Pastor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cortadella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Computer-Aided Design</title>
		<meeting>Int&apos;l Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1993-11">Nov. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Petri Net Analysis Using Boolean Manipulation</title>
		<author>
			<persName><forename type="first">E</forename><surname>Pastor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Roig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cortadella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Badia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th Int&apos;l Conf. Application and Theory of Petri Nets</title>
		<meeting>15th Int&apos;l Conf. Application and Theory of Petri Nets<address><addrLine>Zaragoza, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994-06">June 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Combining Process Algebras and Petri Nets for the Specification and Synthesis of Asynchronous Circuits</title>
		<author>
			<persName><forename type="first">M</forename><surname>Peña</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cortadella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Symp. Advanced Research in Asynchronous Circuits and Systems</title>
		<meeting>Int&apos;l Symp. Advanced Research in Asynchronous Circuits and Systems</meeting>
		<imprint>
			<date type="published" when="1996-03">Mar. 1996</date>
			<biblScope unit="page" from="222" to="232" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m" type="main">Kommunidation mit Automaten</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Petri</surname></persName>
		</author>
		<idno>IIM Nr. 3</idno>
		<imprint>
			<date type="published" when="1962">1962</date>
			<pubPlace>Bonn, Germany</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Institut für Instrumentalle Mathematik</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report Schriften des</note>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">A Direct Determination of the Irredundant Forms of a Boolean Function from the Set of Prime Implicants</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">R</forename><surname>Petrick</surname></persName>
		</author>
		<idno>AFCRC-TR-56-110</idno>
		<imprint>
			<date type="published" when="1956-04">Apr. 1956</date>
			<pubPlace>Air Force Cambridge Research Center, Cambridge, Mass</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Graph Models for Reachability Analysis of Concurrent Programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Pezzé</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">N</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Young</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Software Eng. and Methodology</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="171" to="213" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title level="m" type="main">Net-Based Modeling of Communicating Parallel Processes with Applications to VLSI Design</title>
		<author>
			<persName><forename type="first">I</forename><surname>Reicher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yoeli</surname></persName>
		</author>
		<idno>532</idno>
		<imprint>
			<date type="published" when="1988">1988</date>
			<pubPlace>Technion, Haifa, Israel</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title level="m" type="main">Representing and Modeling Digital Circuits</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">G</forename><surname>Rokicki</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
		<respStmt>
			<orgName>Stanford Univ.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Signal Graphs: From Self-Timed to Timed Ones</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">Y</forename><surname>Rosenblum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Yakovlev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Int&apos;l Workshop Timed Petri Nets, Torino</title>
		<imprint>
			<date type="published" when="1985">1985</date>
			<pubPlace>Italy</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">Las Redes de Petri en la Automática y la Informática</title>
		<author>
			<persName><forename type="first">M</forename><surname>Silva</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
			<publisher>AC</publisher>
			<pubPlace>Spain</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Madrid</note>
	<note>in Spanish</note>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title level="m" type="main">Operating Systems</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Tsichritzis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1974">1974</date>
			<publisher>Academic Press</publisher>
			<pubPlace>London</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Handshake Circuits: An Asynchronous Architecture for VLSI Programming</title>
		<author>
			<persName><forename type="first">K</forename><surname>Van Berkel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int&apos;l Series Parallel Computation</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<date type="published" when="1993">1993</date>
			<publisher>Cambridge Univ. Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Petri Nets, Algebras, Morphisms, and Compositionality</title>
		<author>
			<persName><forename type="first">G</forename><surname>Winskel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="197" to="238" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
