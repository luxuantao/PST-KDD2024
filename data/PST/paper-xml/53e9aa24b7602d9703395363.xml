<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Delaying Physical Register Allocation Through Virtual-Physical Registers</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Teresa</forename><surname>Monreal</surname></persName>
							<email>tmonreal@posta.unizar.es</email>
						</author>
						<author>
							<persName><forename type="first">Antonio</forename><surname>Gonzblez</surname></persName>
							<email>antonio@ac.upc.es</email>
							<affiliation key="aff1">
								<orgName type="department">Departament d&apos;Arquitectura de Computadors Universitat Politkcnica de Catalunya</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mateo</forename><surname>Valero</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jod</forename><surname>Gonzblez</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Departament d&apos;Arquitectura de Computadors Universitat Politkcnica de Catalunya</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Victor</forename><surname>Vifialst</surname></persName>
							<email>victor@posta.unizar.es</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Departamento de Informatica e Ing. de Sistemas Centro PolitCcnico Superior -Univ. de Zaragoza</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Delaying Physical Register Allocation Through Virtual-Physical Registers</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T13:16+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Register file access time represents one of the critical delays of current microprocessors, and it is expected to become more critical as future processors increase the instruction window size and the issue width. This paper present a novel physical register management scheme that allows for a late allocation (at the end of execution) of registers. We show that it can provide significant savings in number of registers and thus, it can significantly shorter the registerfile access time. The approach is based on virtualphysical registers, which we presented in a previous work, extended with a new register allocation policy. This policy consists of an on-demand allocation in order to maximize the register usage, combined with a stealing mechanism that prevents older instruction from being delayed by younger ones. This shortens the average number of cycles that each physical register is allocated, and allows for an early execution of instructions since they can obtain a physical register for its destination earlier than with the conventional scheme. Early execution is especially beneficial for branches and memory operations, since the former can be resolved earlier and the latter can prefetch their data in advance.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Dynamically-scheduled superscalar processors exploit instruction-level parallelism (ILP) by overlapping the execution of instructions in an instruction window. In spite of being able to execute instructions out-of-order, the amount of ILP that current superscalar processors can exploit is significantly constrained by data dependences, especially for non-numeric codes. The number of instructions that can be executed in parallel is highly dependent on the instruction window size and thus, wide issue processors require a large instruction window <ref type="bibr">[15]</ref>. However, a large instruction window has some implications in other critical parts of the microarchitecture, such as the complexity of the issue logic <ref type="bibr">[lo]</ref> and the size of the physical register file <ref type="bibr">[3]</ref>. In this work we are concerned with the latter problem.</p><p>The access time of a register file is significantly affected by its size, as well as its number of ports <ref type="bibr">[3]</ref>. Since the current trend of increasing the issue width and the instruction window size has direct consequences on the number of ports and registers respectively, it is very likely that the register file access time will become one of the longest delays of forthcoming microprocessors. In this case, it will determine the clock cycle and thus, it will have a severe impact on the processor performance, unless it is pipelined.</p><p>However, pipelining a register file is not trivial and besides, it has significant effects on the processor. In particular, a multi-stage register file increases the branch misprediction penalty and requires extra levels of bypass logic [ 141. Both issues, are critical for the performance of superscalar processors.</p><p>On the other hand, current superscalar processors require many more registers than those strictly necessary to store the values of a program. This is due to the fact that registers are allocated too early and released too late. Every instruction allocates a physical register for its destination operand much before its result is available (at decode), and this register is released much after its last consumer commits (when the following instruction with the same logical destination register commits). In this paper, we focus on the waste due to the former factor. Figure <ref type="figure" target="#fig_0">1</ref> shows the average number of physical registers used by a superscalar processor (written+non-written), and the number of registers that are actually wasted because of the early allocation (non-written). We assume here a processor with 160 physical registers in each file. For other details about the evaluation framework refer to Section 4.1. On average, the early allocation of registers increases the register requirements by 45% for integer and by 40% for FP; for some programs such as li it is responsible for an 53% average increase and in some particular cycles of the execution this figure can be as much as 500%.</p><p>This paper focuses on a novel register management scheme that allows the processor to delay the allocation of physical registers until the values that they store are available (at the end of the execution stage). We proposed this scheme in previous work <ref type="bibr">[4]</ref> [5] and referred to it as virtual-physical registers. We observed on that work that the approach to allocating physical registers was critical to performance. In this paper, we present a novel register allocation approach that outperforms the former scheme. We show that virtual-physical registers with this allocation scheme provide a significant saving in physical registers.</p><p>For instance, we show that for 5 SpecFP95 benchmarks, a virtual-physical register organization with 77 FP registers achieves about the same performance as a conventional register organization with 101 registers, in terms of instructions committed per cycle (IPC). Note that if the processor cycle is determined by the register file access time, the reduction in number of registers will imply an increase in instruction throughput. The rest of this paper is organized as follows. Section 2 reviews the virtual-physical register renaming scheme. The new allocation policy for this scheme is presented in Section 3. Section 4 discusses the performance of the proposed approach. Finally, Section 5 outlines some related work and Section 6 summarizes the main conclusions of this work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Virtual-Physical Registers</head><p>The virtual-physical register architecture is motivated by the fact that instructions do not require a storage location for their results until they are available. However, current dynamic register renaming schemes allocate such a storage in the decode stage, much earlier than the result is available.</p><p>The reason is that a physical register is used for two different purposes: to store a value and as an identifier of the result, in order to keep track of dependences. Only the latter objective requires the register to be allocated at decode. Thus, the allocation of a storage location can be delayed if the processor uses another artifact to keep track of dependences. Such an artifact is what we call virtual- physicaf registers (VP registers for short). VP registers are merely tags and do not require any physical storage. When an instruction is decoded, its destination logical register is mapped to a VP register obtained from a pool of free VP registers. Later on, when the instruction is in the last cycle of the execution stage, the VP register is mapped to a physical register taken from the pool of free physical registers. When an instruction commits, the VP and physical registers allocated by the previous instruction with the same logical destination register are released to their respective free pools.</p><p>This register management scheme requires two map tables: the general map table (GMT), which indicates for each logical register its latest VP association and the latest physical mapping of this VP register, if any, and the physical map table (PMT), which denotes for each VP register its latest physical mapping, if any. More details about the operation of this approach can be found in <ref type="bibr">[4] [5]</ref>.</p><p>Since VP registers are just tags, a processor should typically be provided with the maximum required amount, namely the number of logical registers plus the maximum number of instructions in-flight. However, the physical register file should be dimensioned to the smallest size that provides a performance not much lower than an infinite number of registers in order to keep its access time low. It is thus not guaranteed that every instruction in-flight finds a free physical register when it finishes the execution stage. Therefore, the policy used to allocate physical registers to instructions is critical to performance.</p><p>In fact, a conventional renaming scheme could be defined as a scheme that allocates the available physical registers in program order and forces the processor to stall the decoding of instructions when it runs out of physical registers. The virtual-physical register scheme could achieve the same behavior with an adequate policy for register allocation, i.e., by allocating physical registers to the oldest instructions in the window, with the additional advantage that it does not require the decode of instruction to be stalled when physical registers have been used up. However, other allocation policies are possible, and may be more effective.</p><p>When an instruction finishes its execution and there is not any free physical register, the instruction is kept in the instruction queue and executed later on, with the expectation that some physical registers will have been freed in the meantime. However, if this instruction was the oldest instruction in the window, no instruction would commit and thus, no physical register would be freed. To avoid this deadlock situation the allocation policy proposed in <ref type="bibr">[4]</ref> guarantees that a given number of oldest instructions in the window (NRR) will obtain a register when they reach the write-back stage, where NRR is an implementation parameter. In other words, that allocation scheme assigns NRR registers to the oldest instructions in the window that have a destination operand, whereas the rest of physical registers are allocated on-demand, that is, they are assigned to the instructions that first reach the write-back stage. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">A New Register Allocation Approach for Virtual-Physical Registers</head><p>We realized in our previous work that the performance of the processor was very sensitive to the value of NRR. The optimal value of NRR for different programs is quite distinct, and even for a single program, varying the value of NRR across different sections of the execution may provide significant benefits. Such a scheme for a dynamic tuning of the NRR parameter was concluded to be critical and this is what has motivated this work. For instance, Figure <ref type="figure" target="#fig_1">2</ref> shows the IPC for li and upplu when NRR is varied from 1 to 32, assuming 64 physical registers in each file. Other details about the evaluation framework can be found in section 4.1. Note that the optimal value for NRR for li is 16 whereas for upplu it is 32.</p><p>For the whole benchmark suite, the value of NRR that has the best average performance is 32, which is its maximum value for 64 physical registers. A virtualphysical scheme with maximum NRR is conceptually similar to the renaming scheme of the Power3, as discussed in Section 5, and it is one of the schemes that we use for comparison in this work.</p><p>Note that in fact this previous register allocation scheme is not the only approach that may guarantee a deadlock avoidance. On the other hand, finding the optimal register allocation policy seems to be an unsolvable problem even with a perfect knowledge of future register references. We have then to rely on some heuristics that try to approximate such an optimal scheme. The approximation we propose is based on the following two rules: l Registers should be allocated to the instructions that can use them earlier. In this way, the average number of unused registers is minimized. l Given any two instructions, if the execution of one of them should be delayed by the lack of registers, the most appropriate candidate is the youngest instruction, since delaying the execution of the oldest would delay its commit, which in turn would also delay the commit of the youngest one. These two criteria can be met by the following scheme. Every instruction allocates a physical register in the last cycle of the execution stage (just before write-back) if there are free registers. This meets the first criterion since registers will be allocated by the instructions that first finish execution. If an instruction reaches the last cycle of the execution stage and there is not any free physical register, it is checked whether there is any younger instruction that has already allocated a register. If this is the case, it is better to stall the younger instruction rather than the older one, based on the second criterion. As suggested in <ref type="bibr">[7]</ref>, this can be achieved by stealing the register allocated by the younger instruction and assigning it to the older one. If there are more than one younger instruction with a register already allocated, the youngest one will be chosen. We refer to this register allocation scheme as on-Demand with Stealing from Younger (DSY).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Implementing the DSY Register Allocation Scheme</head><p>Identifying whether there is a younger instruction with an allocated register is done by inspecting the reorder buffer, searching for any younger entry with the executioncomplete bit set. If several are found, the youngest one is chosen. Let us refer to the instruction that demands a register as i,, and to the instruction from which the register is stolen as iz. The VP register identifier alIocated by iz is obtained from the reorder buffer (this additional field in the reorder buffer is an overhead of the virtual-physical policy) and the physical register identifier is obtained from the PMT table. Let us refer to the VP destination register of i,, the VP destination register of i, and the physical destination register of iz as VP,, VP, and P, respectively (see Figure <ref type="figure" target="#fig_2">3</ref>.a). When i, steals the physical register of i,, the PMT table is updated to reflect that now VP1 is mapped to P2 and VP, is not longer associated to P2 (see Figure <ref type="figure" target="#fig_2">3</ref>.b).</p><p>The instruction i, must be re-executed in the future. A simple approach to achieving this is to keep instructions in the instruction queue until they retire, with a flag that indicates whether they have been issued. By marking i, as not issued, the issue logic will choose it again for issue in the future (Figure <ref type="figure" target="#fig_2">3</ref>.~).</p><p>Since i2 has been executed in the past, the consumers of VP2 (i.e. instructions with a source operand renamed to VP,) have marked this operand as ready. However, it is not ready anymore since its associated physical register has been stolen. Turning this operand into not ready can be done by using the buses that are used to awake instructions, as described below.</p><p>In a conventional processor, when an instruction completes execution t, it broadcasts the identifier of its physical destination register to all the entries in the instruction queue. Every entry checks if any of its source operand identifiers correspond to the broadcast one, and those that match are marked as ready. For virtual-physical registers, each entry in the instruction queue identifies each source operand by means of both a VP register and a physical register identifiers. When an instruction completes, both the VP and physical identifiers of the destination register are broadcast to the instruction queue. Each entry compares the VP identifiers of its source operands against the broadcast one, and in case of a match, the broadcast physical identifier is copied in the corresponding field of the matching operand, and this operand is marked as ready. On the other hand, when the physical destination register of an instruction is stolen, its corresponding VP tag (VP, in the example) is broadcast to the instruction queue in order to mark as NOT ready any matching source operand (Figure <ref type="figure" target="#fig_2">3</ref>.~).</p><p>Note that some of the instructions that have VP2 as a source operand may have been issued at the time when this operand becomes not ready. These instructions have read a correct source operand and thus, the result that they will produce will be correct. At the time they finish, if there are free physical registers they will be able to store their result and dependent instructions will be allowed to be issued. However, instruction i, will eventually be executed again and will allocate a new physical register (let us denote it by P3) for its destination. At that moment, the VP2 and P3 identifiers will be broadcast to the instruction queue, and those instructions that consume VP2 will copy the new physical mapping and will be re-issued if not yet completed (i.e. it has been executed and allocated a physical register for its destination). The same happens to consumers of these re-issued instructions: they will be'issued no matter if they have already been issued in the past.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Implicit Benefits of the DSY scheme</head><p>As described above, the DSY scheme may cause multiple executions of some instructions and all the re-executions of the same instruction will produce the same result. In this section, we point out that these multiple executions 1. In fact, it is done some cycles before in order to overlap the latency of the issue and read logic with the last cycles of the execution.</p><p>implicitly have a very positive effect on the control speculation mechanism as well as the data cache memory.</p><p>Among the multiple times that an instruction is executed, all of them except the last one could be regarded as premature executions, that would not occur at that time if the processor allocated physical registers from oldest to youngest instructions. Indeed, the physical register of an instruction i is stolen only when in the instruction window there are more instructions older than it that require a physical register. A conventional renaming mechanism would assign all physical registers to the older instructions and instruction i would have not even been fetched. On the other hand, with virtual-physical registers, this instruction gets a physical register because it finishes execution earlier than some older instructions. However, when an older instruction completes its execution and finds no free physical registers, it steals the register from i, which forces its later re-execution.</p><p>The preliminary execution of some instructions have two important benefits: l A preliminary execution of a branch instruction will validate its prediction and in case of misprediction, the instructions of the wrong path will be squashed and the fetching from the correct path will be started immediately. In the conventional renaming scheme, such validation would occur much later, since the instruction would be delayed by the lack of registers. l A preliminary execution of a load instruction that misses in cache would fire the fetching of the data. When the instruction is definitely re-executed this data element may be already in cache and result in a cache hit. In other words, the early (preliminary) execution of memory instructions acts as a small-distance data prefetching scheme, hiding the memory latency of some cache misses. Finally, note that the latency as well as resource consumption of re-executed instructions can be significantly reduced by means of a reuse mechanism [ 1 I]. Instructions that are to be re-executed could keep their results in a reuse buffer and later on, when physical registers are available, these results could be directly copied into the new physical registers. In this way, re-executed instructions would not increase the contention in the functional units. In the analysis presented in this paper, such an instruction reuse mechanism is not considered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4, Performance Evaluation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Experimental Framework</head><p>The virtual-physical register renaming approach has been evaluated by means of a cycle-based timing simulator of a dynamically-scheduled processor derived from the SimpleScalar ~3.0 tool set 121. The sim-outorder simulator has been modified to include physical register files (integer and FP) where the results of all instructions are stored (instead of temporarily storing them in the RUU and moving them to the architected register file at commit). This is the approach used by some current microprocessors such as the MIPS R 10000 and the Alpha 21264. The main parameters of the microarchitecture we use in our simulations are presented in Table <ref type="table" target="#tab_0">1</ref>. We refer lo such microarchitecture as a conventional processor. Then, the simulator has been extended to include the proposed virtualphysical renaming, leaving the remaining architectural parameters unchanged. We used ten benchmarks from the Spec95 suite: five integer programs (compress, gee, go, li and per-l) and five FP programs (mgrid, romcatv, a&amp;u, swim and hydro2d). All programs were simulated to completion, excepting tomcarv, for which the initial part that reads a huge input file was skipped. Table <ref type="table" target="#tab_1">2</ref> lists the inputs and the number of executed instructions. The programs were compiled with the Compaq/Alpha Fortran and C compilers with the maximum optimization level (-05). Figure <ref type="figure" target="#fig_3">4</ref> shows the average number of instruction committed per cycle (IPC) for each benchmark as well as the harmonic mean for integer and FP programs, assuming 64 physical registers in both the integer and FP files. Three different register management schemes are compared: the conventional one (conv), virtual-physical registers with the original register allocation policy (VP-ori), and virtual- physical registers with the DSY allocation policy presented in this paper (vp-dsy). We can observe that the benefits of virtual-physical registers for FP codes are much more significant than for integer programs. This is an expected result since FP programs in general cause a much higher register pressure. The virtual-physical organization significantly outperforms the conventional organization, providing an average speed-up of 5% and 24% for integer and FP codes respectively. The difference between the original and the DSY allocation policies is noticeable, DSY provides an average speedup of 2% and 7% for integer and FP codes respectively.</p><p>For the DSYconfiguration, the percentage of instructions that have their destination physical register stolen is 5.26% for integer programs and 11.76% for FP codes, which results in a 9.79% and a 57.75% of instructions re-executed respectively. This is due to the different behavior of these applications. FP programs exhibit more ILP and a low branch miss rate, and thus the instruction window is usually tilled up. Thus the VP scheme can assign physical registers to instructions far away from the oldest instructions in the window, increasing the ILP extracted and thus the performance, at the expense of a higher number of reexecutions. On the other hand, integer applications experience a much higher branch miss ratio, which implies that the instruction window cannot be completely filled up, and then, the VP scheme cannot yield so much performance benefits by exploiting ILP.</p><p>Figure <ref type="figure" target="#fig_4">5</ref> shows the impact of preliminary executions of load instructions. It depicts the percentage of loads that miss in cache and among them, the percentage that have been re- executed. We can observe that FP applications experience a reasonable degree of prefetch (28% on average), especially the tomcatv, which also obtains the best speedup (it reexecutes the 35% of loads that miss in cache).</p><p>Analyzing the effect of a varying number of registers on the processor performance may be more interesting than just looking at a particular register file size. In general a processor designer would be interested in finding the best trade-off between number of registers and performance.</p><p>Figure <ref type="figure" target="#fig_5">6</ref> illustrates how the processor performance varies as a function of the number of physical registers for both the conventional and the virtual-physical organization. For the latter, the original register allocation policy as well as the DSY one are shown. Virtual-physical registers with DSY allocation is always better than virtual-physical registers with the original allocation policy, which in turn is better than the conventional renaming scheme. Note also that the difference among the three schemes is more significant for PP codes and increases as the number of physical registers decreases. We can observe that virtual-physical registers can provide significant savings in number of registers. A candidate design point for the number of registers to be implemented in a processor would be the lowest number of registers that provides a performance close to that of an infinite size register file (i.e. as many registers as reorder buffer entries plus number of logical registers). For instance, if we could afford about 10% IPC degradation with respect to the maximum IPC, we would choose 61 integer and 101 FP registers for the conventional scheme, whereas for virtual-physical registers 45 and 77 would suffice respectively. This implies a saving of 26% and 24% respectively, which directly translates in savings in the register file access time and area, since both are significantly affected by the number of registers [3].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Related Work</head><p>Register renaming is an old concept that first appeared in the FP unit of the IBM 360/91 <ref type="bibr">[13]</ref>. Nowadays it is used by all dynamically scheduled processors. Different schemes basically differ in the organization of the storage location for the register values. Some processors keep noncommitted values in the reorder buffer and copy these values to the register file at commit (e.g. Intel P6 [6]); others  have a register file for non-committed values and another for committed results (e.g. PowerPC 620 [9]); finally, some processors have a single register file (one for integer and another for FP) that holds both non-committed and committed data (e.g. Alpha 2 1264 <ref type="bibr" target="#b0">[8]</ref>). The virtual-physical organization that we have proposed in this paper can be applied to the two last schemes and we have assumed the last one for the presented evaluation.</p><p>The virtual-physical register renaming scheme presented in this paper builds upon the approach that we presented in <ref type="bibr">[4]</ref>. The main contribution of this paper is a novel register allocation scheme that allocates physical registers at the end of the execution stage, using an on-demand policy with stealing from younger instructions.</p><p>Another approach for delaying the allocation of physical registers was proposed by <ref type="bibr">Wallace and Bagherzadeh [ 161.</ref> Their motivation was to have a multiple-banked organization with just one write port per bank. Delaying the allocation of physical registers until result write time allowed the processor to avoid conflicts in the banks. Their scheme had the same type of deadlock hazard as virtualphysical registers have. Their solution was based on shifting the processor to a special mode when the oldest instruction was unable to issue or complete. In this special mode, only the oldest instruction was allowed to execute and its result was stored in the register that this instruction would release at commit. Note that this is very similar to our former approach with one reserved register (NRR=I). In fact, this scheme does not reserve any register, but uses one that is sure to be released right away.</p><p>Finally, the Power3 implements what they call virtual renaming [ 1] [ 121. Like the PowerPC 620 [9], this processor has two register files: one for committed values, which is referred to as architected register file, and another for noncommitted values that is called rename buffers. In this processor, there are 16 rename buffers for integer and 24 for FP data. However, an operand is identified by one bit more than those required by a rename buffer identifier. This additional bit is called the virtual bit. This allows up to two in-flight instructions to use the same rename buffer for its result. The older assignment is considered to be the 'real' one whereas the younger is called the 'virtual' one. They are distinguished by the value of the virtual bit. Only instructions with real operands (source and destinations) are allowed to be issued. When an instruction commits, its destination rename buffer is switched from real to virtual, and that of the younger instruction that uses the same physical buffer is switched from virtual to real. The processor allows up to 32 instructions in-flight (due to the size of the reorder buffer) but, unlike our proposal, only the 16/24 oldest instructions with an integer/FP destination register respectively are allowed to be issued. In fact, these scheme is conceptually very similar to our original proposal when the number of reserved registers is set to the number of rename buffers.</p><p>To summarize, Wallace and Bagherzadeh and the Power3 schemes represent two extreme points in the design space. The former allocates physical registers almost on demand, with the exception of the oldest instruction, whereas the latter assigns all physical buffers to the oldest instructions that have a destination operand. The former can execute instruction far beyond the actual commit point much earlier than the latter. However, when the oldest instructions run out of registers, the former scheme has very low performance since instructions are executed sequentially. Our proposal, virtual-physical registers with DSY allocation, can be as aggressive as the latter, but when it realizes that old instructions are progressing slowly due to the lack of registers, it steals some registers from the younger instructions and give them to the older ones.</p><p>An orthogonal approach to reducing the register pressure was proposed by Jourdan et al. <ref type="bibr">[7]</ref>. Their scheme takes advantage of instruction repetition. The idea is to identify instructions that produce the same result and allocate the same physical register for all of them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions</head><p>In this paper we have presented a novel register renaming scheme that allows for the late allocation of physical registers. In particular, physical registers are allocated at the end of the execution stage, rather than at decode time as conventional processors do. The direct advantage of this scheme is a significant reduction in the register pressure. For instance, we have evaluated that it can provide a 26% and 24% reduction in the number of integer and FF' registers, and achieve the same IPC rate as a conventional scheme. This reduction in number of registers translates into a shorter access time to the register file, which is likely to be a critical issue of forthcoming microprocessors, and thus, it may significantly increase performance.</p><p>The proposed scheme has also important indirect advantages. In particular, it allows branches to be resolved earlier and load/store instructions to prefetch their data. In addition, the re-execution of instructions caused by the stealing feature can be done very effectively by means of a reuse mechanism.</p><p>The novel register allocation policy has been shown to be more effective than previous proposals for late register allocation. The on-demand allocation with stealing from the younger provides maximum look-ahead when ILP is limited but this look-ahead never penalizes older instructions.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Register usage (written + non-written) and register waste (non-written) due to early allocation.</figDesc><graphic url="image-67.png" coords="2,83.75,53.02,197.00,162.72" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Effect of varying NRR for two particular programs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Example of vbtual-physical renaming with DSY allocation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Performance of the virtual-physical renaming versus the conv. scheme for a 64 physical registers. Two different register allocation policies are shown for virtualphysical renaming: the original and the DSY.</figDesc><graphic url="image-167.png" coords="5,315.00,43.45,207.00,191.04" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Percentage of loads that miss on cache and their data is prefetched through re-execution.</figDesc><graphic url="image-201.png" coords="6,77.50,47.79,211.00,79.20" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Performance as a function of number of physical registers for the conv. register organization and the virtualphysical scheme with the two different allocation policies.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Processor microarchitectural parameters</figDesc><table><row><cell></cell><cell></cell><cell>X ,nstruc,,ons</cell><cell>(up to 2 taken branches)</cell></row><row><cell>Funcuonal</cell><cell>units</cell><cell cols="3">8 Slmnle ml f I ): 4 in1 mull (7): 6 slmnle FP (4): 4 FP muIt 141: .</cell></row><row><cell>(lalency)</cell><cell></cell><cell cols="2">4 FP div (16); 4 load/store</cell></row><row><cell cols="4">Load/Store queue 64 entries with store-load forwardmp</cell></row><row><cell cols="2">Iasue mechanism</cell><cell>out-of-order</cell><cell>issue. Loads may cxecule</cell><cell>when pr~v wxe</cell></row><row><cell></cell><cell></cell><cell cols="2">addrcsscs UC known</cell></row><row><cell cols="2">PhysxA repslcrs</cell><cell cols="2">4X-160 int /4X-I 60 FP</cell></row><row><cell cols="2">LI D-cache</cell><cell>32 KB.</cell><cell></cell></row></table><note>2.way XL-;~ss~xx~~ve, 64 byte Imes. 1 cycle hll ,,me L2 unified cache 1 MB. 2.way s~I-~s~~A~vc. 64 hytc lines. I2 cycles hit wne Main memory infinite size. 50 cycles wxss time Comma wdlh x I"SV"CIIO"S</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 .</head><label>2</label><figDesc>Benchmarks</figDesc><table><row><cell>I Propram</cell><cell>I</cell><cell></cell><cell>Input</cell><cell></cell><cell cols="2">I #dyn. inst. (M) 1</cell></row><row><cell>compress</cell><cell></cell><cell></cell><cell cols="2">4OOCQ.e 223 I</cell><cell>I</cell><cell>170</cell></row><row><cell>gee</cell><cell>[</cell><cell></cell><cell>genrec0g.i</cell><cell></cell><cell></cell><cell>145</cell></row><row><cell>eo c</cell><cell>I I</cell><cell></cell><cell>YY</cell><cell></cell><cell>I I</cell><cell>146</cell></row><row><cell>II</cell><cell>1</cell><cell></cell><cell cols="2">7 queens</cell><cell></cell><cell>243</cell></row><row><cell>nerl</cell><cell>I</cell><cell></cell><cell>scrabhl.in</cell><cell></cell><cell>I</cell><cell>47</cell></row><row><cell>m&amp;rid</cell><cell></cell><cell>test (modifymg</cell><cell cols="2">the two first lines to 5 and IX)</cell><cell></cell><cell>16')</cell></row><row><cell>tOmCat"</cell><cell></cell><cell></cell><cell>LCSL</cell><cell></cell><cell></cell><cell>IYI</cell></row><row><cell>applu</cell><cell></cell><cell>tram (modlfymg</cell><cell>del.5~.03</cell><cell>and nx=ny=n~l3)</cell><cell></cell><cell>3Y8</cell></row><row><cell>swim</cell><cell></cell><cell></cell><cell>uain</cell><cell></cell><cell></cell><cell>431</cell></row><row><cell>hydro2d</cell><cell>1</cell><cell cols="2">test (modifying</cell><cell>ISlEP=I)</cell><cell></cell><cell>472</cell><cell>1</cell></row><row><cell cols="5">4.2. Performance Statistics</cell><cell></cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Acknowledgments</head><p>This work has been supported by contracts CYCIT TIC98-0511 and ESPRIT 24942, by the Programa Europa de Investigacibn (CA1 CONS1 + D), by the grant 1996FI-03039-APDT, and by the CEPBA.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Bose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Moreno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Burger</surname></persName>
		</author>
		<author>
			<persName><surname>Austin</surname></persName>
		</author>
		<idno>1342</idno>
		<title level="m">The SimpleScalar Tool Set ~2.0</title>
				<imprint>
			<date type="published" when="1997-06">June 1999. June 1997</date>
		</imprint>
		<respStmt>
			<orgName>University of &apos;Wisconsin-Madison ; CS Department</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technizal report</note>
	<note>Private communication</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Register File Considerations in Dynamically Scheduled Processors</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">1</forename><surname>Farkas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Jouppi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Chow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of2nd. Int. Symp. on High-Pe$ormance Computer Architecture</title>
				<meeting>of2nd. Int. Symp. on High-Pe$ormance Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="40" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Virtual-Physical Registers</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Gonzilez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><surname>Vajero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE 4th. Int. Symp. on High-Petformance Computer Architecture</title>
				<meeting>IEEE 4th. Int. Symp. on High-Petformance Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="175" to="184" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Virtual Registers</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Gonzblez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Valero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Gonzalez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of int. Conf on High-Performance Computing</title>
				<meeting>of int. Conf on High-Performance Computing</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="364" to="369" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Intel&apos;s P6 Uses Decoupled Superscalar Desian</title>
		<author>
			<persName><forename type="first">L</forename><surname>Gwennap</surname></persName>
		</author>
		<idno>. DD. 9-15. Fei. 1995</idno>
		<imprint/>
	</monogr>
	<note type="report_type">Micronrocksor Report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">.k No;; Renaming Scheme to Exploit Value Temporal Locality through Physical Register Reuse and Unifi-c&amp;n</title>
		<author>
			<persName><forename type="first">S</forename><surname>Joirdan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. -of 3lst~lnt. .?ymp. onicroarchitecture</title>
				<meeting>-of 3lst~lnt. .?ymp. onicroarchitecture</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="216" to="225" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The Alpha 21264 Microprocessor</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Kessler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="24" to="36" />
			<date type="published" when="1999-03">March 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The PowerPC 620 Microprocessor: &apos;A High-Performance Superscalar RISC Microprocessor</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">T</forename><surname>Levitan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><surname>Tu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 40th. IEEE Computer Society International Conference</title>
				<meeting>of 40th. IEEE Computer Society International Conference</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="285" to="314" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Complexity-Effective Superscalar Processors</title>
		<author>
			<persName><forename type="first">A</forename><surname>Palacharla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Jouppi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Smith</surname></persName>
		</author>
		<idno>LID. 206-2 18</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of 24th. Int. Symp. on Comnuter Architecture</title>
				<meeting>of 24th. Int. Symp. on Comnuter Architecture</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Dynamic &apos;Instruction Reuse</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sod&amp;</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Sohi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 24th. Int. Symp. on Computer Architecture</title>
				<meeting>of 24th. Int. Symp. on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="94" to="205" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">IBM&apos;s Power3 to Replace P2SC</title>
		<author>
			<persName><surname>I21 P Song</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997-11">Nov. 1997</date>
			<biblScope unit="page" from="23" to="27" />
		</imprint>
	</monogr>
	<note>Microprocessor Report, I I( 15</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">An Efficient Algorithm for Exploiting Multiple Arithmetic Units</title>
		<author>
			<persName><surname>R&amp;l</surname></persName>
		</author>
		<author>
			<persName><surname>Tomasulo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Journal ofResearch and Development, I l(l)</title>
		<imprint>
			<biblScope unit="page" from="25" to="33" />
			<date type="published" when="1967-01">Jan. 1967</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Exploiting Choice: Instruction Fetch and Issue on an Implementable Simultaneous Multithreading Processor</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Tullsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 25th. Int. Symp. on Computer Architecture</title>
				<meeting>of the 25th. Int. Symp. on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="191" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Limits of Instruction-Level Parallelism</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>I51</surname></persName>
		</author>
		<author>
			<persName><surname>Wall</surname></persName>
		</author>
		<idno>WRL 9316</idno>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
		<respStmt>
			<orgName>Digital Western Research Laboratory</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A Scalable Register File Architecture for Dynamicalty Scheduled Processors</title>
		<author>
			<persName><forename type="first">S</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Bagherzadeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1996</title>
				<meeting>1996</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Co@ on Parallel Architectures and Compilation Techniques</title>
		<imprint>
			<biblScope unit="page" from="79" to="184" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
