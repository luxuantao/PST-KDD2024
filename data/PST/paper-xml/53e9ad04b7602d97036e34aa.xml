<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">QoS Routing: The Precomputation Perspective Ý</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ariel</forename><surname>Orda</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Electrical Engineering Technion</orgName>
								<orgName type="department" key="dep2">Institute of Technology</orgName>
								<address>
									<postCode>32000</postCode>
									<settlement>Haifa</settlement>
									<country>Israel, Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alexander</forename><surname>Sprintson</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Electrical Engineering Technion</orgName>
								<orgName type="department" key="dep2">Institute of Technology</orgName>
								<address>
									<postCode>32000</postCode>
									<settlement>Haifa</settlement>
									<country>Israel, Israel</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">QoS Routing: The Precomputation Perspective Ý</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">9E5F6E14D2C5E9FBB4414BED0F71C5DC</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:33+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>QoS</term>
					<term>Routing</term>
					<term>Precomputation</term>
					<term>Hierarchical networks</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A major algorithmic challenge posed by QoS routing is the need to promptly identify a suitable path upon a connection request, while at the same time ensure that the selected path is satisfactory, both in terms of the connection's QoS requirements, as well as in terms of the global utilization of network resources. In many practical cases, a precomputation scheme offers a suitable solution to the problem: a background process prepares a data base, which enables to identify a suitable path upon each connection request, through a simple, fast, procedure.</p><p>While much work has been done in terms of path selection algorithms, the precomputation perspective got little attention. Simplistic adaptations of standard algorithms turn to be inefficient. Accordingly, we consider the precomputation perspective, focusing on two major settings of QoS routing. The first is the (practically important) special case where the QoS constraint is of the "bottleneck" type, e.g. a bandwidth requirement, and network optimization is sought through hop minimization. For this setting, the standard Bellman-Ford algorithm offers a straightforward precomputation scheme. However, we show that, by exploiting the typical hierarchical structure of large-scale networks, one can achieve a substantial improvement in terms of computational complexity. Then, we turn to consider the more general setting of "additive" QoS constraints (e.g., delay) and general link costs. As the routing problem becomes NP-hard, we focus on -optimal approximations, and derive a precomputation scheme that offers a major improvement over the standard approach.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Broadband integrated services networks are expected to support multiple and diverse applications, with various quality of service (QoS) requirements. Accordingly, a key issue in the design of broadband architectures is how to provide the resources in order to meet the requirements of each connection, and, moreover, how to meet that goal in a networkwide efficient manner. The establishment of efficient QoS routing schemes is, undoubtedly, one of the major building blocks in such architectures. Indeed, QoS routing has been the subject of several studies and proposals (see, e.g. <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b15">[16]</ref> and references therein). It has been recognized that the establishment of an efficient QoS routing scheme poses several complex challenges.</p><p>QoS routing is, in general, a complex problem, due to several reasons. One complication is the need to deal with several QoS requirements, each potentially imposing some constraints on the path choice. Then, beyond the need to address the requirements of individual connections, QoS routing needs to consider also the global use of network resources, since meeting the requirements of a QoS request implies the reservation of sufficient resources, e.g., bandwidth, along the selected path. Finally, the identity of the required ("optimal") path is connection-dependent, yet executing the path search procedure for each connection may turn out to be computationally prohibitive. Nonetheless, the above obstacles notwithstanding, QoS routing is facilitated in many practical settings by the following. First, while a connection may pose several QoS requirements, it turns out that these often translate mainly into a bandwidth requirement <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b2">[3]</ref>. Bandwidth, in turn, belongs to the class of "bottleneck" path requirements, which are much easier to handle than "additive" requirements, such as delay, loss and jitter <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b13">[14]</ref>. As for global network optimization, often it turns out that much can be achieved by employing the simple criterion of hop minimization <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b3">[4]</ref>; indeed, a consequence of the need to reserve resources such as bandwidth on each link of the connection's path is that, with fewer hops one consumes fewer resources. As a result, hop-constrained path optimization has emerged as an important problem in several recent proposals for IP-oriented QoS routing protocols <ref type="bibr" target="#b6">[7]</ref>. Luckily, hop minimization turns out to be an optimization criterion that is relatively easy to handle. Lastly, to avoid having to perform a separate path computation for each new Ý This research was supported by the Consortium for Wideband Communications, administered by the Israeli Ministry of Industry and Com- merce.</p><p>request, several proposed QoS routing protocols are based on precomputing paths for all possible QoS requirements <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b3">[4]</ref> as a background process, hence considerably reducing the computational load upon each connection request.</p><p>The above observations form the foundations of the present study. In particular, we focus on path precomputation, taking the view that it is a highly desirable, and at times necessary property, of an efficient QoS routing scheme. As shall be demonstrated, many of the algorithmic tools that are often proposed as building blocks for QoS routing were not designed with path precomputation in mind, and better solutions can be found when this property is required. This requirement, namely to efficiently precompute optimal paths for a whole range of (QoS) requirements, effectively opens a new area of research. A first step in that direction has been done in <ref type="bibr" target="#b8">[9]</ref>, which investigated the problem of precomputing paths of maximal bandwidth for each possible hop-count value; that problem was termed there as Problem All-Hops (AHOP). While a trivial solution to that problem is offered by the standard Bellman-Ford shortest-path scheme <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b8">[9]</ref> presented an algorithm whose worst-case bound is lower; yet, the improvement is achieved only in dense (high connectivity) topologies, while communication networks usually have a sparse topology. On the other hand, it has been observed that exploiting the particular topological structure of large-scale broadband networks can often facilitate the establishment of more efficient solutions to (QoS) routing problems <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b15">[16]</ref>. Accordingly, in this study we consider the hierarchical structure that is typical of large-scale networks, and indeed obtain solutions for Problem AHOP which offer a substantial improvement, in terms of computational complexity, upon the standard (Bellman-Ford's) scheme. Then, we turn our attention to the harder case of additive QoS requirements (such as delay, jitter and packet loss) and general (additive) path optimization criteria, beyond hop minimization. The respective problem becomes a variant of the Restricted Shortest Path (RSP) problem, which is known to be NP-hard <ref type="bibr" target="#b7">[8]</ref>. Some general approximation schemes that are -optimal have been proposed (see, e.g., <ref type="bibr" target="#b11">[12]</ref> and references therein). However, those schemes have not been designed with precomputation in mind, and, consequently, are not adequate when precomputation is sought. Accordingly, in the present study we establish an approximation scheme that offers both efficient solutions as well as efficient performance, for precomputing "optimal" (minimum cost) paths for all possible values of an additive QoS requirement.</p><p>The rest of the paper is organized as follows. First, in Section II we formulate the network model and formally state the problems that we consider. Next, in Section III we consider the problem of hop minimization with bottleneck QoS constraints in hierarchical networks: first, in Subsection III-A, we formulate the concept of hierarchical topologies; then, we present and analyze our precomputation scheme, which is composed of two phases: the first,"background", phase is considered in Subsection III-C, while the second, "on-demand", phase is considered in Subsection III-D. The scheme is compared with other (standard) alternatives in Subsection III-E, and its advantages are discussed. Section IV concerns extension of our BH-HIE scheme to handle "all-to-all" (rather than "one-to-all") routing problems. In Section V-B we discuss application of our findings in an environment, such as PNNI's, where nodes are presented with only an aggregated image of the (real) topology. Next, in Section VI we analyze "dual" problems, where one is given a cost budget, and needs to determine a minimum weight path, among those that obey the budget. In Section VII we establish improved precomputation schemes for Problem BH-RSP in additional topologies of special interest, beyond the hierarchical class. Next, in Section VIII we consider additive QoS constraints and general (additive) path costs. Here too, we present and analyze a two-phase precomputation scheme, and establish its advantage over standard alternatives. Finally, conclusions appear in Section IX.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. MODEL AND PROBLEM FORMULATION</head><p>This section formulates the general model and main problems addressed in this paper. We begin with the definition of a general communication network; a definition of a specific class, namely hierarchical networks, will be introduced in the next section.</p><p>A network is represented by a directed graph ´Î µ, where Î is the set of nodes and is the set of links. Let</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>AE Î and Å</head><p>. A path is a finite sequence of nodes</p><formula xml:id="formula_0">Ô ´Ú¼ Ú ½ Ú µ, such that, for ¼ Ò ½, ´ÚÒ Ú Ò•½ µ ¾ ;</formula><p>Ô is then said to be the number of hops (or hop count) of Ô. A path is simple if all its nodes are distinct. Let À be the maximum possible hop count of any simple path Ô in which may be considered for routing purposes. Obviously, À AE ½ and it is much smaller in many typical network topologies; moreover, À is often restricted to a relatively small value by network control.</p><p>For concreteness of exposition, we consider a link state routing environment, where the source node has an image of the entire network. Each link ¾ is assigned a positive weight Û´ µ, whose significance depends on the type of considered QoS requirement. For example, when the QoS requirement is an upper bound on the end-to-end delay, the link weight is its delay; whereas when a bandwidth requirement is considered, the link weight Û´ µ is reciprocal to its available bandwidth ´ µ i.e. Û´ µ ½</p><p>´ µ . Accordingly, the path weight Ï ´Ôµ of a path Ô is defined differently for additive metrics, such as delay, than for bottleneck metrics, such as bandwidth. Specifically:</p><p>Definition 1: When link weights Û´ µ constitute an additive metric, the weight Ï ´Ôµ of a path Ô is defined as the sum of weights of its links, namely:</p><p>¯the weight of an empty path is ¼ Ï ´ µ ¼;</p><p>¯given a nonempty path Ô, Ï ´Ôµ È ¾Ô Û´ µ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2:</head><p>When link weights Û´ µ constitute a bottleneck metric, the weight Ï ´Ôµ of a path Ô is defined as the weight of its worst link, namely:</p><p>¯the weight of an empty path is ¼ Ï ´ µ ¼; ¯given a nonempty path Ô, Ï ´Ôµ Ñ Ü ¾Ô Û´ µ ;</p><p>We can define the notion of a path that is "best" when only path weights are considered, i.e.:</p><p>Definition 3: A minimum-weight path between two nodes × and is a path Ô × whose weight is no larger than that of any other path between those nodes.</p><p>Obviously, a minimum-weight path has the best performance with respect to the QoS requirement that is captured by the link weight metric; for instance, it is a path with minimum delay or maximum bandwidth. Minimum-weight paths can be efficiently found by Dijkstra's shortest-path algorithm, in Ç´AE ÐÓ AE • Å µ computational complexity <ref type="bibr" target="#b5">[6]</ref>. Alternatively, for bottleneck metrics, one can employ a binary search on the solution space, whose respective complexity is Ç´Å ÐÓ µ where is the number of different weights assigned to the network links (hence Å ). Obviously, if the minimum-weight path fails to meet the connection's QoS requirement, then so does any other path. However, when the minimum-weight path does meet the QoS requirement, it is often not the "right" choice, as it may be wasteful in terms of global network usage, e.g., it may have a large number of hops or use "expensive" links.</p><p>Therefore, the goal of QoS routing is to identify a path that satisfies a given QoS requirement while consuming as few resources as possible. Since the amount of the resources consumed on a path depends to a large extent on the number of its links, the path hop count is considered to be a good criterion for estimating the path quality in terms of global resource utilization. When the hop count criterion is not satisfactory, one can define some link cost metric ´ µ that estimates the quality of each link in terms of resource utilization; such a cost may depend on various factors, e.g., the link's available bandwidth, its location, etc. The path cost is then defined as the sum of the costs of its links, namely:</p><formula xml:id="formula_1">Definition 4: Given a path Ô its cost ´Ôµ is: ´Ôµ ¾Ô ´ µ</formula><p>In the present study we shall consider both cases of global utilization criteria, namely hop count and general (integer) link costs. Note that the former is a special case of the latter.</p><p>We are now ready to formulate the main problems that are considered in this study. Given a connection request between a source node × ¾ Î to a destination node ¾ Î with some QoS requirements, and given network utilization preferences as captured by some link costs, the goal of the QoS routing scheme is to identify a path Ô between × and , which meets the QoS requirements at minimum cost. This can be formulated as a restricted shortest path (RSP) problem:</p><p>Problem RSP (Restricted Shortest Path): Given are a source node ×, a destination node and a QoS requirement Û.</p><p>Find a path Ô from × to such that:</p><formula xml:id="formula_2">1. Ï ´ Ôµ Û, 2.</formula><p>´ Ôµ ´Ôµ for every other path Ô that satisfies the restriction Ï ´Ôµ Û, 3. there does not exist another path Ô, for which ´ Ôµ ´Ôµ and Ï ´ Ôµ Ï ´ Ôµ.</p><p>Note that the third requirement is not part of the standard definition of the RSP problem; we introduce it since, if there exist more than a single solution to the standard problem, we would typically prefer one that offers better performance. We refer to a solution of Problem RSP as a ŵ-weight constrained optimum path from s to d.</p><p>For additive weights and general costs, Problem RSP is intractable, i.e., NP-hard <ref type="bibr" target="#b7">[8]</ref>. However, there exist pseudopolynomial solutions, based on dynamic programing, which give rise to fully polynomial approximation schemes (FPAS), whose computational complexity is reasonable (see, e.g., <ref type="bibr" target="#b11">[12]</ref> and references therein).</p><p>As mentioned in the Introduction, many QoS routing problems consist of identifying, for each connection request, a path of minimum hops that still meets the connection's bandwidth requirement. In other words, the path weight is a "bottleneck" metric, and its cost is equal to its number of hops. Effectively, these problems can be formulated as variants of Problem RSP, for which (i) weights are of the bottleneck type and (ii) links have equal costs; each of these two simplifications renders Problem RSP to be tractable. A main focus of this study is to provide efficient precomputation schemes for this class of problems, whose formal definition is presented next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Problem BH-RSP (Bottleneck weight Hop cost RSP):</head><p>Given are a source node ×, a destination node and a bottleneck QoS requirement Û. Find a path Ô from × to such that: 1. Ï ´ Ôµ Û, 2. Ô Ô for every other path Ô that satisfies the restriction Ï ´Ôµ Û, 3. there does not exist another path Ô, for which Ô Ô and Ï ´ Ôµ Ï ´ Ôµ.</p><p>Here too, the last requirement was added in order to prefer, among several solutions, one that offers better performance.</p><p>As mentioned in the Introduction, QoS routing can often be considerably facilitated by means of employing a precomputation scheme, which performs the path search a priori for any possible connection request. Such a scheme comprises of two phases: the first phase (pre-)computes a suitable path for any possible QoS requirement; the second provides a (fast) solution upon each connection request 1 . The fist phase, which incurs the main computational burden, is run as a background process, which needs to be activated only upon a change in the network state. Therefore, such schemes offer a significant reduction in computational load whenever the rate of connection requests is higher than that of changes in the network state, which is the case in many practical settings. Precomputation schemes for equal link costs (i.e., minimum hops) were investigated in <ref type="bibr" target="#b1">[2]</ref> and <ref type="bibr" target="#b8">[9]</ref>, both for bottleneck as well as additive weights. <ref type="bibr" target="#b1">[2]</ref> indicated that the Bellman-Ford algorithm offers a simple precomputation scheme, by "inverting" the roles of the constraint (QoS requirement) and the optimization criterion (hops). This way, the Bellman-Ford scheme computes a minimum weight for each possible hop count; upon a connection request, then, one would choose the minimum hop value for which the corresponding path meets the connection's QoS requirement. Accordingly, we define a -hop constrained optimal path to be a path of minimum weight among all paths from a source × to a destination with hop count of at most . The All Hops Optimum Path problem was then formulated in <ref type="bibr" target="#b8">[9]</ref> as follows.</p><p>Problem AHOP (All Hops Optimal): Given are a graph ´Î µ, a source node × ¾ Î and a maximum hop count À, À AE . Find, for each hop value , ½ À, and each destination node ¾ Î , an -hop constrained optimal path between × and .</p><p>In <ref type="bibr" target="#b8">[9]</ref> it was shown that, for general topologies and additive weights, it is not possible to improve upon the Bellman-Ford solution in terms of the worst-case computational complexity. For bottleneck weights, <ref type="bibr" target="#b8">[9]</ref> provided an alternative scheme that does improve upon Bellman-Ford's, in terms of the worst-case bound; yet, when the topology is sparse, as is typically the case in communication networks, the solution of <ref type="bibr" target="#b8">[9]</ref> is inferior to Bellman-Ford's. It remained an open question whether one can propose better precomputation scheme for typical network topologies; this is the subject of Section III.</p><p>We shall also consider the precomputation perspective in the context of additive QoS requirements and general path costs. Obviously, in this case precomputation of exact solutions is intractable, since so is the basic underlying (RSP) problem. Therefore, we resort to precomputing approximated, namely -optimal, solutions; this is the subject of Section VIII.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. PRECOMPUTATION SCHEME FOR PROBLEM BH-RSP IN HIERARCHICAL NETWORKS</head><p>In <ref type="bibr" target="#b8">[9]</ref> a precomputation scheme for Problem BH-RSP was proposed, which consisted of solving Problem AHOP during the first phase. Since the solution of Problem AHOP fully precomputes all paths (for all possible bandwidth requirements), the second phase just consisted of searching for the solution in the data base produced by the first phase, according to the QoS requirement of the incoming connection request. As a result, the computational complexity incurred by the second phase was just Ç´ÐÓ À • Ô µ, where Ô is the hop count of the identified solution. We refer to this precomputation scheme as the AHOP-based scheme.</p><p>As mentioned in <ref type="bibr" target="#b8">[9]</ref>, the Bellman-Ford shortest path algorithm provides a simple scheme for solving Problem AHOP, with a computational complexity of Ç´Å Àµ; for a general (dense) topology, that bound can grow to be as large as Ç´AE ¾ Àµ. For bottleneck weight metrics (in other words, for Problem BH-RSP), <ref type="bibr" target="#b8">[9]</ref> provided an alternative scheme, whose computational complexity is Ç´AE ¾ ÐÓ AE Àµ; evidently, the latter outperforms Bellman-Ford's in dense topologies, i.e., when Å AE ¾ ÐÓ AE , but not in sparse topologies, which are the typical setting of communication networks.</p><p>It remained an open question whether one can improve upon the latter in typical network topologies. In this section we demonstrate that, by exploiting the hierarchical structure that is typical of large-scale networks, one can establish a precomputation scheme for Problem BH-RSP, which offers a significant improvement upon the above solutions.</p><p>We begin by formulating the hierarchical network model under consideration, which is inspired by the ATM PNNI recommendations <ref type="bibr" target="#b0">[1]</ref>. Next, by exploiting the properties of that model, we establish the required precomputation ½ More precisely, the first phase needs to prepare a data base, with which the second phase can easily retrieve the required path.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>scheme.</head><p>Specifically, the rest of the section is organized as follows. First, we introduce some terminology and formulate the hierarchical model. Then, we construct an auxiliary procedure, termed Procedure CLUSTER, which is a main building block of our precomputation scheme. Next, we describe the precomputation algorithm, which constitutes the first phase of our scheme, and then present Procedure FIND, which implements its second phase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Hierarchical Model Formulation</head><p>The network is represented by a graph ´Î µ and is referred to as the actual network, or the layer-1 hierarchy. We assume that the actual network has a certain hierarchical structure. In order to state the precise meaning of the last term, we need to introduce some additional terminology.</p><p>Suppose that we partition the (actual) network nodes into some disjoint set of peer groups (or clusters), and refer to each resulting peer group as to a layer-2 node. Furthermore, suppose that we repeat the above process, such that, for each ½ layer-nodes are clustered into layer-peer groups, each then becoming a layer-´ • ½µ node. We repeat this process until, for some Ã, we end up with a single layer-Ã peer group. Having performed such a (Ã-stage) partition, we say that layer-nodes that form a layer-´ • ½µ node Ú are its children, and Ú is their parent; similarly, the layerpeer group that forms a layer-´ • ½µ node Ú is referred to as the child peer group of Ú. A descendant of a node is either its child or a descendant's child.</p><p>Next, for each layer , ½ Ã, we construct layer-links, in the following way. First, we classify the actual (layer-½) links into two types: intra-cluster links, which connect between nodes of the same peer group; and intercluster links, which connect between nodes of different peer groups. We then define the set of layer-¾ links as follows. Each inter-cluster link ´Ù Úµ (of the actual network), gives rise to a corresponding layer-¾ link, which connects the parent nodes of Ù and Ú. Intra-cluster links (of the actual network) are not represented at layer ¾ Following the same process as above, each layer-¾ link is classified as either intra-cluster or inter-cluster, and layer-¿ links are then defined; the process is repeated up to the last, Ã'th layer. We have thus defined, for each , ½ Ã, sets of layer-nodes and links, which effectively form a layer-topology.</p><p>It should be noted that a node Ú of a layer ½ represents a subgraph of the actual network, to which we refer as the source graph of Ú, namely:</p><p>Definition 5: Given a layer-node Ú, ½ its source graph Ë Ú℄ is defined to be the subgraph of the actual network induced by the set of Ú's descendants.</p><p>It is convenient to define also the source graph of a peer group, namely: Definition 6: Given a peer group , its source graph Ë ℄ is defined to be the subgraph of the actual network induced by the set of descendants of all nodes Ú ¾ .</p><p>A node in Ë ℄, which has a neighbor that does not belong to Ë ℄, is called a border node. For convenience, we refer to border nodes of Ë ℄ also as border nodes of . We denote by the maximum number of border nodes in any peer group.</p><p>We are now ready to define the concept of hierarchical structure. Intuitively, it means that the network can be partitioned into peer groups, according to the above process, such that, at all layers, peer groups are relatively small (each comprises of at most Ç´ÐÓ AE µ nodes), and, at the same time, so is the number of inter-cluster links. Formally: Definition 7: A network ´Î µ is said to posses a hierarchical structure if it can be iteratively clustered into some Ã layers of peer groups, according to the process described above, such that all the following hold: 1. The number of nodes in a peer group is at least 2 and at most , where Ç´ÐÓ AE µ 2. The number of border nodes is small; specifically, there is some (fixed) value , such that the number of border nodes of each peer group is at most Note that, since there are at least ¾ nodes in each peer group, we have that Ã Ç´ÐÓ Å µ Ç´ÐÓ AE µ.</p><p>Let us illustrate the above terminology through an example. Fig. <ref type="figure">1</ref> depicts an actual, layer 1, topology, while Fig. <ref type="figure">2</ref> presents possible layer 2 and layer 3 topologies. In this example we have , Ã ¿, ¾. Networks that have a hierarchical structure shall be referred to as hierarchical networks. In this section we assume that networks belong to this class, and, furthermore, that their hierarchical structure, i.e., partition into peer groups, is given.</p><p>We can establish the following "sparsity" property of hierarchical networks: Lemma 1: In a hierarchical network Å Ç´AE ÐÓ AE µ.</p><p>Proof: For each actual (layer-1) link ¾ there exists an intra-cluster link of some peer group , which belongs to some layer-topology. Accordingly, let us count the number of intra-cluster links of all peer groups of all topologies.</p><p>Each peer group has at most ¾ intra-cluster links, and a layer-topology consists of Ç´ Ã µ peer groups. Therefore, the total number of intra-cluster links of all topologies is at most</p><formula xml:id="formula_3">¾ ¡ ´ • ¾ • • Ã ½ µ Ç´AE ¡ µ. Next, it is easy</formula><p>to verify that each intra-cluster link represents at most ¾ links of the actual network. As a result, the total number of links in is at most AE ¡ ¾ ¡ Ç´AE ÐÓ AE µ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Procedure CLUSTER</head><p>In general, the task of the first phase of a precomputation scheme is to considerably reduce the computational burden at the second phase. With hierarchical networks, this goal can be achieved by precomputing, per peer group, the "costs" of all connections that may be established across it. Algorithm BH-HIE which constitutes the first phase of our precomputation scheme, implements that idea, by sequentially calling to Procedure CLUSTER , which is described in this subsection.</p><p>Procedure CLUSTER receives, as input, some layerpeer group , and a node ×, which is one of 's border nodes.</p><p>It then (pre-)computes, for each border node Ú of and hop-count , the minimum weight -hop constrained path Ô that connects between × and Ú through the peer group; the weight of this path is stored in a ¿-dimensional array Ì , namely Ì × Ú ℄ Ï ´Ôµ. A main idea in Procedure CLUSTER is that, when applied on a layer-peer group as input, it already has available the output Ì of previous invocations on lower layer peer groups .</p><p>For the layer-½ topology, the implementation of Procedure CLUSTER is straightforward, since it essentially solves a standard Problem AHOP. For all higher layers, however, a more elaborated process is required, since each single node represents a whole subgraph of the actual network.</p><p>Consider the invocation of Procedure CLUSTER on a layerpeer group , where ½. At this stage, due to the previous invocations of the procedure, we have the following information on each node Ú ¾ : for each pair ´Ù½ Ù ¾ µ of border nodes of the child peer group Ú of Ú, and for each hop value ½ ½ we have the minimum weight value of a path with at most hops that runs between those two nodes across Ú . The procedure starts by constructing the following auxiliary graph ´ Î µ. Each node Ú ¾ is substituted in by the set of border nodes Ú of its child peer group Ú . Each such pair of border nodes is connected in by a link; in addition, each two nodes in which are connected by a link in the actual network, are also connected by a link in . Having constructed the topology of the procedure produces (through its sub-procedure INITIALIZE) a set Ë of quadruples ´Ù½ Ù ¾ Ûµ, such that Ù ½ and Ù ¾ are two connected nodes in , is a hop count value, and Û is the minimum weight value that can be supported on a path with at most hops between Ù ½ and Ù ¾ , as computed in the previous invocations of Procedure CLUSTER. The procedure then assigns "length" values Ð´ µ to the links ¾ , in the following iterative way. Initially, all lengths are considered as infinite; then, the procedure scans the set Ë by increasing order of the weight values: for each scanned quadruple ´Ù½ Ù ¾ Ûµ, the procedure sets the length of ´Ù½ Ù ¾ µ to the value of , and then updates the tree of minimum-length paths in from the source node ×; this way, the values of Ì × ¡ ¡℄ are identified. More specifically, if the change in the length of results in shortening the length between × and some border node Ú ¾ to a (smaller) value , then Ì × Ú ℄ is assigned the value of Û, i.e., the weight value of the scanned quadruple. The formal specification of Procedure CLUSTER appears in Fig. <ref type="figure">3</ref>.</p><p>We proceed to establish the following properties of the procedure. Lemma 2: Given are a layer-peer group and the (correct) values of Ì for every lower layer peer group . Then, for each border node Ú of and for each ¼ , Procedure CLUSTER identifies the minimum weight of a -hop constrained path from × to Ú in the source graph Ë ℄ of .</p><p>Proof: By way of contradiction, assume that the lemma does not hold. Then, for some border node Ú of , there </p><formula xml:id="formula_4">exists a path Ô × Ú ¼ Ú ½ Ú Ñ Ú ¾ Ë ℄,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Consider now a link</head><p>´ Ú ½ Ú µ ¾ , and a subpath Ô of Ô that corresponds to , Ô Ú ½ Ú . It is easy to verify that ´ Ú ½ Ú Ûµ ¾ Ë, where Ô and Û Ï ´Ô µ.</p><p>We need to consider two possible cases: 1. When the quadruple ´ Ú ½ Ú Ûµ is processed at line 7 of the algorithm, it holds that Ì × Ú ½ Ô ½ ℄ Ï ´Ô ½ µ. In this case, the sub-procedure propagate will be invoked at line 12 of Procedure CLUSTER with parameters ( Ú ½ Ú Û). After the invocation of PROPAGATE, Ì implies that Ì × Ú Ô ℄ Ï ´Ô µ, hence resulting in a contradiction.</p><p>2. Otherwise, consider the step of the algorithm in which Ì × Ú ½ Ô ½ ℄ was assigned the value Û´Ô ½ µ. Since the quadruple ´ Ú ½ Ú Ûµ was already processed by the loop at line 7, this update leads to a recursive invocation of the sub-procedure PROPAGATE (line 6) with parameters ( Ú ½ Ú Û), where Û Û´Ô ½ µ and, again, after this invocation, Ì × Ú Ô ℄ Ï ´Ô µ, resulting in a contradiction.</p><p>In the next lemma we analyze the complexity of Procedure CLUSTER . Lemma 3: The computational complexity of Procedure CLUSTER for a layer-peer group is Ç´ •½ µ.</p><p>Proof: First, let us count the number of elements in Ë. For each ¾ we added at most ¾ elements to Ë. We also added at most ½ elements for every pair of border nodes of the child peer group Ú for each Ú ¾ . In total, the number of elements in Ë is at most ¾ ¡ Ñ Ò´ ¾µ . This is also the complexity of the sub-procedure INITIALIZE and of lines ¾-½½ of Procedure CLUSTER .</p><p>Next, we show that sorting the elements of Ë consumes Ç´ µ running time. Note that Ë's elements are constructed from at most ¾ ¡ ordered sets, and an additional set of at most ¾ ¡ ¾ links. It is easy to verify that such a sorting can be performed by Ç´ Ñ Ò´ ¾µ ÐÓ µ steps. Finally, let us count the number of invocations of the sub-procedure PROPAGATE. This procedure is invoked times by line 12 of the cluster procedure and also is invoked recursively. Each recursive invocation implies that Ù for some Ù ¾ is increased by at least ½ Since Ù for each Ù ¾ is bounded by , the number of recursive invocations of propagate is Ç´ •½ µ. Note that a single invocation of propagate requires constant time.</p><p>We conclude that the total running time of Procedure CLUSTER is y is indeed Ç´ •½ µ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. First phase: Algorithm BH-HIE</head><p>In this subsection we describe Algorithm BH-HIE, which implements the first phase of our precomputation scheme. Algorithm BH-HIE computes, for each peer group of each layer, the best cost (in terms of number of links) for each weight value that can be supported through the peer group. Specifically, for each peer group , and considering each border node as a source node, we identify the solution of the corresponding Problem AHOP in the source graph Ë ℄ of . These solutions are then the input of Procedure FIND ,which implements the second phase of the precomputation scheme.</p><p>Algorithm BH-HIE runs across the hierarchical layers in a "bottom-up" manner. First, we process each peer group of the actual network, in the following way. Considering each border node 2 of as a source node, we invoke ¾ In this context, if the source graph of includes the source node ×, then × is also considered as one of 's border nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Procedure CLUSTER ( ×):</head><p>parameters ´Î µa layer-peer group × -a source node, which is a border node of variables Ë-a set of "node-node-hop-weight" quadruples</p><p>´ Î µthe auxiliary graph, i.e.:</p><p>for all Ú ¾ Î ´Úµ -the adjacency list for a node Ú. a for all Ú ¾ Î Ú -the minimum length of a path between × and Ú in notation Ú -the child peer group of a layer-node Ú.</p><p>´ µ -the set of border nodes of the peer group .</p><formula xml:id="formula_5">1 INITIALIZE() 2 for all Ú ¾ Î do 3 Ú • ½ 4 ´Úµ 5 × ¼ 6 Ì × × ¼℄ ¼ 7 for each ´Ú Ù Ûµ ¾ Ë by increasing order of Û do 8 if (´Ù ¡µ ¾ ´Úµ) then 9 let ´Ù µ ¾ ´Úµ ´Úµ ´ÚµÒ´Ù µ ´Úµ ´Úµ ´Ù µ PROPAGATE(Ú Ù Û); Procedure PROPAGATE (Ú Ù Û): 1 if ´ Ú • µ Ù then 2 for ´ Ú • µ to ´ Ù ½µ do 3 Ì × Ú ℄ Û 4 È × Ú ℄ Ú 5 Ù ´ Ú • µ 6 for all ´Ü µ ¾ ´Ùµ do 7 PROPAGATE(Ù Ü Û) Procedure INITIALIZE (): 1 Ë 2 Î 3 for each Ú ¾ Î do 4</formula><p>the child peer group of node Ú. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>´Úµ</head><p>´Ù Ð µ for a node Ú, where Ð is the length of the edge ´Ú Ùµ.</p><p>Fig. <ref type="figure">3</ref>. Procedure CLUSTER Procedure CLUSTER described in Subsection III-B, and store the result in the array Ì . We then iteratively apply the same process to all higher layers. The formal specification of Algorithm BH-HIE appears in Fig. <ref type="figure">4</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm BH-HIE ( ×):</head><p>parameters -actual network;</p><p>× ¾ -source node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>notation</head><p>´ µthe set of border nodes of a peer group a ; -the layer-topology; </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">• ½</head><p>In this context, if the source graph of includes ×, then × is also considered as one of 's border nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 4. Algorithm BH-HIE</head><p>We proceed to establish the following properties of Algorithm BH-HIE. Lemma 4: Algorithm BH-HIE solves Problem AHOP for all peer groups at all layers.</p><p>Proof: Straightforward by induction on topology layers and application of Lemma 2. Lemma 5: The computational complexity of Algorithm BH-HIE is Ç´AE ÐÓ ¾ AE µ Proof: Let us count the time required to process a layer-topology. Such a topology contains Ç´AE µ peer groups, for each of which the cluster procedure is invoked. Since he running time of Procedure CLUSTER is Ç´ •½ µ (by Lemma 3), a layer-topology requires Ç´AE ¡ µ Ç´AE ÐÓ AE µ operations. As there are Ã ÐÓ ´AE µ layers,the algorithm's complexity is Ç´AE ÐÓ ¾ AE µ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Second phase: Procedure FIND</head><p>We proceed to present Procedure FIND. This procedure is invoked upon each new connection request, and identifies the corresponding path, namely a path of minimum hops among the corresponding source (×) and destination ( ) that satisfy the connection's bottleneck requirement ( Û).</p><p>The procedure processes the hierarchical layers iteratively, starting from the first layer, i.e., the actual network, up to the last, Ã'th, layer. For each layer, we identify the peer group , for which the source graph Ë ℄ includes the destination node . Then, a minimum hop path from each border node of to is identified.</p><p>For this purpose we construct the following auxiliary graph . The destination node and the border nodes of the child peer groups of constitute the set of 's nodes. Every pair of border nodes ´Ú Ùµ of a child peer group of is connected by a link, whose length is assigned to be the minimum number of hops of a Û-weight constrained path between Ú and Ù in the source graph Ë ℄ of ; this value is provided by the array Ì , which was computed in the first phase. In addition, for every actual network link ´Ú Ùµ for which Û´ µ Û and which gave rise to an intra-cluster link in , we add in a link between Ú and Ù, whose length is set to ½. As a result, a minimum length path in corresponds to a minimum hop path in the source graph Ë ℄ of .</p><p>As shall be shown below, the complexity of Procedure FIND is Ç´ÐÓ ¿ AE • Ô µ where Ô in the number of links in the identified path. The formal specification of Procedure FIND appears in Fig. <ref type="figure" target="#fig_3">5</ref>.</p><p>We proceed to prove the correctness of Procedure F IND. Lemma 6: Suppose that Procedure FIND is invoked for a source ×, destination and (bottleneck) QoS constraint Û. Then, the hop count of the returned path is the minimum number of hops of a path in the actual network between × and that satisfies the QoS constraint Û.</p><p>Proof: By way of contradiction, assume that the lemma does not hold. Then, there exists a path Ô ´ µset of border nodes of peer group .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>variables</head><p>´ Î µthe auxiliary graph;</p><p>1 let be a layer-½ peer group, for which ¾ 2 remove from all links which weight is bigger than Û 3 for each border node ¾ ´ µ, identify a minimum hop pathin from to (e.g., using a Breadth First Search algorithm <ref type="bibr" target="#b5">[6]</ref>); Note that, since ´Ù Úµ is considered as an ordered pair, we distinguish between ´Ú Ùµ and ´Ù Úµ Note that there must exist an edge ´× µ ¾ , since the source node × is a border node of (recall that there is only one layer-Ã peer group). Fig. <ref type="figure" target="#fig_3">5</ref>. Procedure FIND Ã.Suppose that we traverse Ô from to ×. For ½ ,denote by Ú the first node in the traversal that is a border node of . Also, for each layer , ½ Ã we denote by the auxiliary graph constructed for this layer. Finally, we denote by Ð the length of a shortest path from Ú to × in ,as identified at line 21.</p><p>It is sufficient to prove that, for each ½ Ã, the value Ð is at most the hop count of a subpath Ô Ú of Ô. Let ß be the minimum , for which this does not hold. Consider a path Ô Ú Ú ½ in , which corresponds to the subpath Ô Ú Ú ½ of Ô. It follows that Ð´ Ôµ Ô . Thus, there exists a link</p><p>´ Ú Ùµ ¾ Ô, for which Ð´ µ is greater that the hop count of the corresponding subpath Ô Ú Ù of Ô. There are two possibilities.</p><p>1. The link corresponds to a single actual network link. In this case the link was assigned the length 1 by line 20 of the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Otherwise,</head><p>´ Ú Ùµ is a link between border nodes of a child peer group Ú for some node Ú ¾ . In this case, Ð Ô is assigned the lowest , for which it holds that Ì Ú Ú Ù ℄ Û Both cases result in a contradiction, hence the lemma follows.</p><p>We proceed to analyze the computational complexity of the procedure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 7:</head><p>The computational complexity of Procedure FIND is Ç´ Ô • ÐÓ ¿ AE µ Proof: Note that the graph contains just Ç´ÐÓ AE µ nodes and Ç´ÐÓ ¾ AE µ links at each hierarchical layer. The execution of all lines in the procedure, except from lines 16 and 17, require only a fixed number of steps per link, or Ç´ÐÓ ¾ AE µ per layer. Lines 16 and 17 may be implemented in Ç´ÐÓ Àµ running time per link, by a binary search. These lines are executed Ç´ÐÓ AE µ times for each layer, hence they incur Ç´ÐÓ AE ÐÓ Àµ steps per layer. As a result, the procedure performs Ç´ÐÓ ¾ AE µ operations per layer. Since the number of layers is Ç´ÐÓ AE µ, we need Ç´ÐÓ ¿ AE µ running time in total. In addition, we need Ç´ Ô µµ time to report the output, where Ô is the path identified by the algorithm. Thus, the time complexity of the procedure is Ç´ Ô • ÐÓ ¿ AE µ.</p><p>The above results are summarized in the following theorem.</p><p>Theorem 1: Procedure FIND provides a Ç´ Ô • ÐÓ ¿ AE µ solution to Problem BH-RSP, i.e.: given a connection request with source node ×, destination node , and (bottleneck) QoS constraint Û, and given the output of Algorithm BH-HIE, Procedure FIND identifies, in Ç´ Ô • ÐÓ ¿ AE µ steps, a path with a minimum number of hops, among all paths in the actual network between × and that satisfy the QoS constraint Û.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Discussion</head><p>In this subsection we compare between the performance of our precomputation scheme and its alternatives. Consider first the "standard" precomputation scheme proposed in <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b1">[2]</ref>, which was based on solving Problem AHOP through Bellman-Ford's shortest path algorithm.</p><p>As shown above, hierarchical networks are sparse, in the sense that Å Ç´AE ÐÓ AE µ. This implies that the standard scheme incurs a computational complexity of Ç´AE À ÐÓ AE µ for its first phase, i.e., it is Ç´À ÐÓ AE µ slower than ours. Considering the second phase, the standard scheme (as well as any other which is based on fully solving Problem AHOP in the first phase) yields a computational complexity of just Ç´ Ô • ÐÓ Àµ which is somewhat less than that of our scheme, i.e. Ç´ Ô • ÐÓ ¿ AE µ, however the difference between the two figures is not significant in general, and nonexistent when Ô is the dominating component.</p><p>Next, let us compare between our precomputation scheme, and an alternative where no precomputation is performed at all. In such a "single-phase" scheme, the required path can be identified by applying Dijkstra's shortest path algorithm, which, for Å Ç´AE ÐÓ AE µ, incurs Ç´AE ÐÓ AE µ running time. Since Ô Ç´AE µ, our scheme incurs a smaller computational complexity upon a connection request. The difference is particularly significant when the length of the identified path is significantly smaller than AE , e.g., Ô Ç´ÐÓ AE µ, which is a typical case. It is interesting to compare between the two approaches also in the related context of connection admission, where one needs to decide whether a connection request should be admitted, based on its QoS requirement and the cost it incurs; to that end, one needs to identify the (best) cost of a path over which the connection can be established, however there is no need to explicitly specify the path itself. This means that our scheme allows to obtain an admission decision upon a connection request in just Ç´ÐÓ ¿ AE µ time, whereas the "single-phase" scheme still incurs Ç´AE ÐÓ AE µ time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F. Model Relaxation</head><p>One of the properties of hierarchical networks is that the number of nodes in each peer group is at most , where Ç´ÐÓ AE µ (see III-A). This requirement may be relaxed by allowing certain peer groups to be composed from more than nodes, provided that in all peer groups the number of links on any path is Ç´ÐÓ AE µ. This relaxation does not affect the computational complexity of Ç´Å ÐÓ AE µ for the first phase of our precomputation scheme. This follows from the fact that the computational complexity of Procedure CLUSTER applied to a peer group is Ç´Å ´ µ ´ µµ, where Å ´ µ is the number of 's edges and ´ µ is an upper bound to the number of links of any path is . This, in turn, may be easily verified in a similar way as done in the Proof of Lemma 2. Note that in the relaxed model Å is not Ç´AE ÐÓ AE µ anymore, but can rather be as large as Ç´AE ¾ µ. The computation complexity of the second phase may be as much as Ç´Å µ in the worst case. However, under under certain conditions, the running time of the second phase is same as for regular (not extended model). The condition is that neither the source node × nor the destination node are descendants of node, which child peer group comprises more that nodes. Note that this restriction applies to at most ¾ ¡ ÐÓ AE peer groups out of Ç´AE µ peer groups in total.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. SOLVING ALL-TO-ALL PROBLEMS</head><p>The precomputation scheme, described above can be extended for a broad class of problems related to Problem BH-RSP. In this section we present the precomputation scheme for a variation of Problem BH-RSP, in which it is required to solve Problem BH-RSP for any two nodes in . In other words, given a bottleneck QoS constraint Û and a pair of nodes Ú × and Ú , it is required to identify the minimum hop path, among all paths from Ú × to Ú , which satisfy the QoS constrain Û. The first phase is identical to the precomputation scheme for Problem BH-RSP and is implemented by Algorithm BH-HIE. Recall that in this algorithm Procedure CLUSTER is invoked for each peer group at all layers. Since the second phase is implemented similarly to the second phase of the precomputation scheme for Problem BH-RSP, we present only a brief description. Let be a lowest layer for which there exists a peer group , for which Ú × ¾ Ë´ µ and Ú ¾ Ë´ µ where Ë´ µ is the source graph of . Let also × and be layer ´ ½µ peer groups, for which holds Ú × ¾ Ë´ × µ and Ú ¾ Ë´ µ, where Ë´ × µ and Ë´ µ are the source graphs of × and respectively. In order to identify the minimum hop path from Ú × to Ú among all paths from Ú × to Ú which satisfy a given QoS constrain Û, following steps are executed. 1. For each border node Ú of × , identify the minimum hop path, among all path from Ú × to Ú, which satisfy QoS constrain Û. 2. For each border node Ú of , identify the minimum hop path from Ú to Ú , among all paths that satisfy Û. 3. Construct the following auxiliary graph . The set of nodes in includes Ú × , Ú , border nodes of all peer groups whose parent node belongs to , and border nodes of all layer peer groups. Any two nodes Ú Û in that belong to the same peer group È of are connected by a link, whose weight is the minimum hop count of a path from Ú to Û in È , which satisfies Û. In addition there are links from Ú × to border nodes of × and from border nodes of to Ú . The weight of these links is as computed in steps 1 and 2. 4. Identify the shortest path from Ú × to Ú in . All this steps are implemented in a similar way as it done in Procedure FIND . It is easy to verify that the computation complexity of this solution is the same as that of Procedure FIND . To conclude, we presented a precomputation scheme for a variation of Problem BH-RSP problem, in which it is required to identify paths from any source to any destination; the computation complexity of our solution is Ç´AE ÐÓ AE µ for the first phase and Ç´ÐÓ ¿ AE µ for the second.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. TOPOLOGY AGGREGATION</head><p>Our discussion so far concentrated on link state protocols, which assume that a complete and accurate image of the network is available for a network node. However this approach suffers from scalability problems. In particular, as a network grows in size, a significant part of network bandwidth is consumed for maintaining topology image on every node. As a solution, the ATM forum PNNI standard <ref type="bibr" target="#b0">[1]</ref> is designed to provide a scalable representation of hierarchical topologies. According to this standard, a cluster does not reveal its internal structure to outside nodes. Instead, it supplies a summary of cost and availabilities of connections that run through that cluster. This approach is often referred to as topology aggregation. In this section we discuss a variation of our precomputation scheme for networks with topology aggregation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Network topology as seen by a node</head><p>A (proper) aggregated image is simpler than the real topology, yet it still captures its structure in the way that makes it suitable for QoS purposes. Following the ATM PNNI recommendations <ref type="bibr" target="#b0">[1]</ref>, we describe the aggregated image of a network at some node Ú. All other peer groups are omitted from the network image. We proceed define the set Ú of peer groups that are included by aggregated image of the network for a node Ú. Ú includes any peer group which source graph Ë´ µ includes Ú. Since there exists only one such a peer group for each layer,we conclude that the cardinality of Ú is at most Ç´ÐÓ AE µ. Fig. <ref type="figure">6</ref> depicts aggregated image of the topology depicted on Fig. <ref type="figure">1</ref>.</p><p>Though an aggregated image that is comprised of the set Ú is sufficient for identifying a route from Ú to a destination, it does not contain enough data for QoS routing. Consequently, we need some additional information concerning the peer groups not included in Ú . This information includes a summary of costs and availabilities of connections that run through certain peer groups. These peer groups form a set denoted by Ú . Set Ú includes every peer group , whose parent node belongs to a peer group in Ú ( itself does not belongs to Ú ). The summary for a peer group is in the form of the output that would be obtained by Procedure CLUSTER if it were applied to . In Fig. <ref type="figure">6</ref>, all peer groups belonging to Ú are marked as "clouds". It is easy to verify that the space complexity of the aggregated image is Ç´AE µ, as compared with Ç´AE ÐÓ AE µ for a non-aggregated image. v Fig. <ref type="figure">6</ref>. An aggregated image of network for a node Ú</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. A revised precomputation scheme</head><p>Only minor changes should be introduced to our precomputation scheme in order to adapt it to networks with topology aggregation. Since an aggregated image already includes precomputation results for a number of peer groups, the precomputation phase becomes easier: Procedure CLUSTER is applied only for one peer group at each layer, and not for each peer group as in Algorithm BH-HIE. As a result, its computational complexity is just Ç´AE ÐÓ AE µ for networks with topology aggregation, as compared with Ç´AE ÐÓ ¾ AE µ for hierarchical networks without aggregation. The aggregated image of a peer group ¾ Ú can be delivered to Ú from one of 's border nodes. With network aggregation, establishing a new connection with a QoS constraint Û requires additional steps, which include data exchange between source and destination nodes. Indeed, a destination node may be located in a "cloud" in the aggregated image of a source node, which corresponds to some peer group ¾ Ú . The only information that a source node needs for computing the optimal route to is the lowest cost of a path from each border node Ú of to which satisfies the QoS constraint Û. This data is also calculated at the precomputation phase, with no penalty in terms of computational complexity 3 . The data is sent from the source to destination and its size is constant (does not depend on AE ). Upon arrival of this data to the source node, a variant of Algorithm FIND , which is a straightforward simplification of Algorithm FIND , is executed; it identifies a lowest cost path from × to that satisfies Û. This procedure requires Ç´ÐÓ ¿ AE µ time. We conclude that, compared to the regular approach, the topology aggregation scheme requires less space and fewer messages, and it gives raise to a faster precomputation algorithm. Its disadvantage is that the source and destination nodes are required to exchange data before establishing the connection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. RESTRICTED BUDGET PROBLEMS</head><p>In this section we consider a class of bottleneck problems where there is a cost assigned to each network edge. Given a cost budget, it is required to identify a minimum weight path, among those that obey the budget. Certainly, this is a variation of the Restricted Shorted Path (RSP) problem, defined in Section II. The formal definition is as follows.</p><p>Problem GB-RSP (General weight Bottleneck cost RSP): Given are a network , a source node ×, a destination node and a budget . Find a path Ô from × to such that:</p><formula xml:id="formula_6">1. ´ Ôµ , 2.</formula><p>Ï ´ Ôµ Ï ´Ôµ for every other path Ô that satisfies the restriction ´Ôµ , 3. there does not exist another path Ô, for which Ï ´ Ôµ Ï ´Ôµ and ´ Ôµ</p><p>´ Ôµ.</p><p>We begin by noting the following straightforward, yet computationally expensive, scheme to solve this problem: for each possible weight Û in , we delete any each edge for which Û´ µ Û, and then execute a shortest path algorithm; with Dijkstra's shortest path algorithm, the computational complexity is Ç´Å ´Å • AE ÐÓ AE µµ. In this section we present a more efficient solution that requires just Ç´ÐÓ AE µ invocations of a shortest path algorithm. Our algorithm takes advantage of the fact that, for bottleneck metrics, a minimum cost of a path from × to whose weight is at most Û can be found by means of single invocation of a shortest path algorithm. Thus, by performing a binary search on the range of weight values, a minimum weight path among all paths from × to that obey may be found. The formal specification of the algorithm is presented on Fig. <ref type="figure">7</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 8:</head><p>The running time of Algorithm GB-RSP is Ç´´Å • AE ÐÓ AE µ ÐÓ AE µ.</p><p>¿ It requires only a straightforward addition for precomputation algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm GB-RSP ( × ):</head><p>parameters: ´Î µnetwork, × -a source node -a destination node -budget variables:</p><p>Ö Ð Ö -integers from ½ to Í , where Í is an upper bound of the cost of a path from × to .</p><formula xml:id="formula_7">1 Ö Ð ½ Ö Í 2 ½ 3 repeat forever do 4 ß 5 Ö Ð •Ö ¾ 6 if ´ ß ) then 7 return ½ 8 Let £ ¾ Û´ µ Û<label>9</label></formula><p>determine for each Ú ¾ , the minimal distance Ð´Úµ from × to Ú ( by applying AlgorithmDijkstra on ´Î £ µ)  Proof: Initially, the search range is at most Å . After the first iteration it shrinks to Å ¾, etc. As a result, the total number of iterations is Ç´ÐÓ AE µ. Since the computational complexity of each iteration is Ç´Å • AE ÐÓ AE µ, the total running time of the algorithm is Ç´Å • AE ÐÓ AE µ ÐÓ AE µ. The correctness of the algorithm follows from the fact that the cost of the solution is monotonically nonincreasing with the allowed weight. The above results are summarized in the following theorem.</p><p>Theorem 2: Algorithm GB-RSP solves GB-RSP with a computational complexity of Ç´Å • AE ÐÓ AE µ´ÐÓ AE µ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. PRECOMPUTATION SCHEME FOR PROBLEM BH-RSP IN SPECIAL TOPOLOGIES</head><p>In this section we discuss special topologies for which there exist efficient precomputation schemes for Problem BH-RSP. Our discussion is limited to the class of "one-to-one" problems, i.e., the problems with a single or limited number of destinations. We describe first the properties of such topologies that facilitate the efficiency of the precomputation scheme. Let Ô be a -hop constrained optimal path from × to and Ï ´Ôµ Û. Suppose that, for some , it holds that the weight Û of a -constrained optimal path equals to Û. In other words, relaxing the constraint to links does not yield a better path. Furthermore, there are only a limited number of values, for which the link count of -constrained optimal path from × to is . We denote the set of such values by Ë × ½ ¾</p><p>. In this section we consider topologies for which the cardinality of Ë × is bounded by some small (fixed) value . An example of such topology appears on Fig. <ref type="figure">8</ref>. For this topology the value of is ¾. We proceed to present the precomputation scheme for special topologies. In the first phase of this scheme, implemented by Algorithm BH-SPEC, we precompute for each Ú ¾ Î the -hop constrained optimal path from × to Ú for each ¾ Ë × Ú . The weights of that path are stored in an array Ï Ë × Û ½ Û ¾ Û , where Û is the weight of a -hop constrained optimal path from × to Ú. The second phase identifies for a given QoS constrain Û, the smallest Û ¾ Ï × , for which Û Û and outputs the corresponding path. The computational complexity of the first phase is Ç´Å ¡ µ or Ç´Å µ for fixed values of , and is Ç´ÐÓ AE µ for the second phase.</p><p>Each iteration of Algorithm BH-SPEC builds an auxiliary graph . is identical to , but includes only these links which weight is less or equal to Û´ µ. Then, a Breadth First Search Algorithm BFS ( <ref type="bibr" target="#b5">[6]</ref>) is applied on , which determines, for each Ú ¾ Î the minimum hop distance × Ú from × to Ú. Let be the minimum hop count of a path from × to in and let Û be the minimum weight of a hop path from × to . Then, the value of Û´ µ for the next iteration is set to the maximum value of weight in , among all weight that are less than Û.</p><p>The formal specification of Algorithm BH-SPEC appears in Fig. <ref type="figure">9</ref>. Proof: It is easy to verify that each iteration incurs Ç´Å µ, and that for each element in Ë × only a single iteration is performed.</p><formula xml:id="formula_8">Algorithm</formula><p>As stated above, the second part of the precomputation scheme identifies, for a given requirement Û, a Û-constrained optimal path from × to . We first find the smallest Û ¾ Ï × , for which Û Û. This procedure requires Ç´ÐÓ AE µ time. The output of the second phase is a path which weight is Û and link count is .</p><p>In the next lemma we prove that this path is a Û-constrained optimum path from × to .</p><p>Lemma 10: Let Û be a bottleneck constrain and Ô be a path returned by the algorithm. Then, Ô is the minimal link path among all paths from × to that satisfy the constrain Û.</p><p>Proof: Consider the values of Û´ µ over the various iterations of Algorithm BH-SPEC. Let be an iteration, in which the value of Û´ µ is minimal, but still greater than Û. The invocation of Algorithm BFS guarantees that is a minimum hop count of a path from × to that satisfies the constrain Û. We conclude our discussion in the following theorem.</p><p>Theorem 3: For the special topologies described above, there exists a precomputation scheme whose complexity is Ç´Å ¡ µ for the first phase and Ç´ÐÓ AE µ for the second.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. PRECOMPUTATION SCHEME FOR ADDITIVE METRICS</head><p>In this section we consider the routing problem with additive QoS constraints and general links costs. As mentioned in Section II, this problem is in fact the restricted shortest path Problem RSP, which, in general, is known to be NP-hard. Accordingly, we resort to precomputation schemes that offer approximate solutions to Problem RSP.</p><p>We note that a precomputation scheme can be constructed on the base of existing approximation algorithms for Problem RSP (e.g. <ref type="bibr" target="#b11">[12]</ref>), i.e., by sequentially executing them for various cost values. However, as we shall see, such a simplistic approach results in a (overly) high computational complexity. Therefore, in this section we propose a precomputation scheme that finds an -optimal solution to Problem RSP, for all possible QoS constraint values, within Ç´´Å •AE ÐÓ AE µ¡À ¡ ½ ¡ÐÓ µ computational complexity for the first phase and Ç´ÐÓ ´½ µ•ÐÓ ´Àµ•ÐÓ ÐÓ ´ µ• Ô µ for the second phase, where is an upper bound on the (additive) cost of a path, and Ô is the hop count of the identified path.</p><p>The section is organized as follows. First, we present a pseudo-polynomial solution for Problem RSP in the special case of directed acyclic graphs (DAGs). Next, based on that solution, we establish an Ç´´Å • AE ÐÓ ´AE µµ ¡À ¡ ½ ¡ÐÓ µ precomputation scheme that provides an -optimal solution for general topologies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Pseudo-polynomial Solution for Problem RSP</head><p>As a first step, we present a (computationally inefficient) pseudo-polynomial solution, Algorithm PP-RSP, which is based on a generalization of Bellman-Ford's algorithm. For the sake of simplicity, we assume that the underlying graph is a DAG; an extension to general graphs is straightforward.</p><p>The algorithm is based on dynamic programming and assumes integer costs. Given a (additive) QoS constraint Û, the algorithm starts with a zero "budget" ¼ and increments it by a value of ½ on each iteration, until a Û-weight constrained path from × to is discovered. At each iteration, the algorithm repeatedly selects the destination node Ù ¾ Î according to a topologically sorted order 4 and relaxes all links leaving Ù. The process of relaxing a link ´Ù Úµ consists of testing whether the best path to Ú found so far can be improved by going through Ù under the current budget restriction and, if so, updating the best path for node Ú.</p><p>Since for each ½ , the algorithm performs Ç´Å µ operations, its complexity is Ç´Å ¡ µ, where is an upper bound on the cost of a ( Û-weight constrained optimum) path from × to any Ú ¾ Î . The formal specification of Algorithm PP-RSP appears in Fig. <ref type="figure">10</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Polynomial Precomputation (Approximation) Scheme</head><p>We proceed to present a precomputation scheme that provides -optimal solutions for Problem RSP. First, we present a solution for DAGs, whose complexity (for the first phase) is Ç´Å À ÐÓ µ, where is an upper bound on the cost of a path, and then extend it in order to obtain an Ç´´Å • AE ÐÓ AE µÀ ÐÓ µ solution for general topologies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.1. Algorithm for directed acyclic graphs</head><p>The following algorithm is based on Algorithm PP-RSP, and it uses a cost quantization approach. Specifically, it considers only a limited number of budget values, namely ½ ½ ¾ , where AE for some AE ½.</p><p>For each node Ú ¾ Î and for each , the algorithm outputs a near-minimum weight Ï Ú ℄ of a path from × to Ú, whose cost is at most . For a fixed value of AE, the number of iteration is polynomial on the input size. On the other hand, this approach does not provide an exact solution, and the approximation ratio depends on the choice of AE. The formal specification of Algorithm RSP-DAG is presented in Fig. <ref type="figure">11</ref>.</p><p>Lemma 11: Given are a DAG a source node × and an approximation parameter . For a (arbitrary) value Û, let ÓÔØ be the cost of a Û-weight constrained optimal path from × to a (arbitrary) node Ú ¾ Î , and let  For the inductive step, we assume that ÓÔØ ¡AE holds for ½ ¾ ½ and prove that it holds for . Let us consider the execution of the loop of line 7 for ÐÓ AE ´ ½ • ´ µµ , where ´Ú ½ Ú µ. Since ½ , the value of Ï Ú ½ ½ ℄ was fixed in the loop of line 7 at either the current or a previous iteration. In both cases the value of Ï Ú ½ ½ ℄ does not change after node Ú is processed. As a result, and since Ï Ú ½ ½ ℄ Û ÓÔØ ½ , line 15 assures that Ï Ú ℄ Û ÓÔØ . Therefore, The next section extends Algorithm RSP-DAG to general graphs. This requires only minor changes to the algorithm.</p><formula xml:id="formula_9">AE ¡ ´ ½ • ´ µµ AE ¡ ´ÓÔØ ½ ¡ AE ½ • ´ µµ, for</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.2. Extension to general graphs</head><p>Recall that, in each iteration of Algorithm RSP-DAG, the graph nodes were visited in a topologically sorted order. Since such order does not exist in graphs with cycles, we process nodes according to their minimum weights from the source, using an idea similar to that of Dijkstra's shortest path algorithm. The algorithm is presented in Fig. <ref type="figure" target="#fig_0">12</ref>.</p><p>Theorem 4: Given are a general graph a source node × and an approximation parameter . For a (arbitrary) value Û, let ÓÔØ be the cost of a Û-weight constrained optimal path from × to a (arbitrary) node where is an upper bound on the cost of a path in .</p><p>Proof: The algorithm performs the same number of iterations as Algorithm RSP-DAG, i.e., Ç´½ ¡ À ÐÓ µ. It can be easily verified that each iteration incurs Ç´Å • AE ÐÓ AE µ computational complexity. We thus conclude that the computational complexity of the algorithm is Ç´½ ¡ ´Å • AE ÐÓ AE µÀ ÐÓ µ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.3. The Second Phase</head><p>Algorithm RSP-GEN constitutes the first phase of our precomputation scheme, and its output, i.e. the values Ï Ú ℄, is used by the second phase of the precomputation scheme. ´Î µ -network × ¾ -source node -approximation parameter variables:</p><p>-the "budget" for all Ú ¾ Î ÏÚ ℄ -the approximated minimum weight of a path between × and Ú whose cost is at most É -priority queue a notation -an upper bound on the cost of a path in AE ´½ ´½ ´½• µ¡À µ The priority queue É is implemented with a Fibbonacci heap <ref type="bibr" target="#b5">[6]</ref>. Two operations are supported:Add´É Ú Ûµ and Extract Min´Éµ. With Fibonacci Heaps, the amortized cost of each priority tree operation is Ç´ÐÓ Î µ <ref type="bibr" target="#b5">[6]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 12. Algorithm RSP-GEN</head><p>The second phase is invoked at a source node ×, upon a connection request between × and a destination node ¾ Î with a QoS requirement Û. The scheme then determines the minimum for which Ï ℄ Û.</p><p>This operation can be performed in Ç´ÐÓ ´½ µ • ÐÓ ´À µ • ÐÓ ÐÓ ´ µµ time by means of a binary search on the values of Ï ℄. The scheme reports the path between × and that corresponds to Ï ℄, which, by Theorem 4, is a Û-weight constrained path between × and with an -optimal cost. This path is not determined by the first phase explicitly, but can be derived from its output, in Ç´ Ô µ operations 5 . Therefore, the second phase incurs a total computational complexity of Ç´ÐÓ ´½ µ • ÐÓ ´À µ • ÐÓ ÐÓ ´ µ • Ô µ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Discussion</head><p>We described a precomputation scheme for Problem RSP that provides -optimal solutions within a computational complexity of Ç´´Å •AE ÐÓ AE µ¡ À ÐÓ µ for the first phase and Ç´ÐÓ ´½ µ•ÐÓ ´À µ•ÐÓ ÐÓ ´ µ• Ô µ for the second phase.</p><p>Compared with an alternative single-phase (i.e., "no precomputation") scheme, our scheme allows to (significantly) reduce the time required for establishing a new connection. Indeed, in a single-phase scheme This requires a mild and straightforward modification of Algorithm RSP-GEN. For simplicity of exposition, the details are omitted here.</p><p>Problem RSP should be solved for each connection request, through a standard -optimal approximation to Problem RSP <ref type="bibr" target="#b11">[12]</ref>, which incurs a computational complexity of Ç´Å À ÐÓ ÐÓ µ for DAGs, and Ç´´Å • AE ÐÓ AE µ À ÐÓ ÐÓ µ for general graphs 6 . Hence, the second phase of our scheme allows to identify an -optimal path upon a connection request ´ÐÓ AE ¡ À ¡ ÐÓ ÐÓ µ times faster.</p><p>As previously noted, a precomputation scheme can be trivially constructed on the base of existing approximation algorithms for Problem RSP, such as <ref type="bibr" target="#b11">[12]</ref>, by sequentially executing them for various cost values. The computational complexity of this solution, for a single destination, is Ç´´Å • AE ÐÓ AE µ À ÐÓ ÐÓ µ for general graphs. In order to perform the precomputation for Problem RSP , this algorithm should be invoked Ç´Ð Ó µ times per destination, with a total complexity of Ç´´Å • AE ÐÓ AE µ ¡ À ÐÓ ÐÓ ÐÓ AE µ for all destinations, which is significantly ( ÐÓ AE times) higher than that of our solution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IX. CONCLUSIONS</head><p>QoS routing poses major challenges in terms of algorithmic design. On one hand, the path selection process is a complex task, due to the need to concurrently deal with the connection's QoS requirements, as well as with the global utilization of network resources; on the other hand, connection requests need to be handled promptly upon their arrival, hence there is limited time to spend on path selection. In many practical cases, a precomputation scheme offers a suitable solution to the problem: a background process (the "first phase") prepares a data base, which enables to identify a suitable path upon each connection request, through a simple, fast, procedure (the "second phase").</p><p>While much work has been done in terms of path selection algorithms, the precomputation perspective received little attention. As was demonstrated in this paper, simplistic adaptations of standard algorithms are usually inefficient.</p><p>Accordingly, this study considered the precomputation perspective, focusing on two major settings of QoS routing. First, we considered the (practically important) special case where the QoS constraint is of the "bottleneck" type, e.g. a bandwidth requirement, and network optimization is sought through hop minimization. For this setting, the standard Bellman-Ford algorithm offers a straightforward precomputation scheme. However, we showed that, by exploiting the typical hierarchical structure of large-scale networks, one can achieve a substantial (Ç´À ÐÓ AE µ) improvement in terms of computational complexity. Then, we turned to consider the more general setting of "additive" QoS constraints (e.g., delay) and general link costs. As the routing problem is NP-hard, we focused on ¯-optimal approximations, and derived a precomputation scheme that offers a major ( ÐÓ AE ) improvement over a "standard" approach. Some topics are the subject of ongoing research. These include: (i) precomputation schemes for the (NPhard) Problem RSP, which are based on Lagrangian relaxation techniques; (ii) precomputation schemes for Problem RSP in hierarchical networks; (iii) establishing an algorithmic technique for (automatically) partitioning a hierarchical network into the corresponding peer groups.</p><p>Finally, we note that, except for unicast path selection, there are many other networking problems, such as flow optimization, spanning tree minimization, multicast tree optimization, etc., for which the precomputation perspective offers a rich ground for future research.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .Fig. 2 .</head><label>12</label><figDesc>Fig. 1. An example of a hierarchical network</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 7 .Fig. 8 .</head><label>78</label><figDesc>Fig. 7. Algorithm GB-RSP</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>ÛTheorem 5 :</head><label>5</label><figDesc>, where the values Ï Ú ℄ are the output of Algorithm RSP-GEN for , × and Ú. Then ÓÔØ ÓÔØ . Proof: Straightforward,since the algorithm is essentially similar to Algorithm RSP-DAG, except for the order by which nodes are visited during an iteration of the loop at line 7. The correctness of the algorithm follows from the fact that nodes with lower values of Ï Ú ℄ are visited first, as in Algorithm RSP-DAG. The computational complexity of Algorithm RSP-GEN is Ç´½ ¡ ´Å • AE ÐÓ AE µÀ ÐÓ µ,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Algorithm</head><label></label><figDesc>RSP-GEN ( ´Î µ × ):parameters:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>for which Ô and Ï ´Ôµ Ì × Ú ℄. Denote the first node Ù in Ô for which Ù ¾ by Ú ¼ , the second by Ú ½ , etc., up to Ú Ò Ú. The nodes Ú constitute a path in , which we denote</figDesc><table><row><cell>by Ô is a subpath of Ô. Note that for × Ú ¼ Ú ½ Ú . Let ß be a lowest value of , for which Ì × Ú Ô ℄ Ï ´Ô µ, where Ô Ú Ò ß ½ still holds Ì × Ú Ô ℄ Ï ´Ô µ.</cell><cell>×</cell><cell>Ú</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>,for which Û´ µ Û´ µ 5 invoke Algorithm BFS on , determine for each Ú ¾ , the minimal hop distance Ð´Úµ from × to Ú The computational complexity of Algorithm BH-SPEC is Ç´Å ¡ µ, where is an upper bound to cardinality of the set Ë × .</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell>BH-SPEC ( ×):</cell></row><row><cell cols="3">parameters</cell></row><row><cell></cell><cell cols="3">-actual network; × ¾ -source node. ¾ -destination node</cell></row><row><cell cols="3">variables</cell></row><row><cell></cell><cell cols="3">Û´ µ-iteration parameter</cell></row><row><cell cols="2">1 2 Û´ µ</cell><cell>½</cell><cell>½</cell></row><row><cell cols="4">3 while do 4 delete all links ¾ 6 for each Ú ¾ Î do 7 Ï ´Úµ ½</cell></row><row><cell>8 9 10</cell><cell cols="3">Ï ´×µ for each Ú ¾ Î in increasing order of Ð´Úµ do ¼ for each ´Ú Ùµ ¾ do</cell></row><row><cell>11</cell><cell></cell><cell cols="2">if Ð´Ùµ Ð´Úµ ½ then</cell></row><row><cell>12</cell><cell></cell><cell></cell><cell>Ï ´Ùµ Ñ Ò Ï ´Ùµ Ñ Ü Ï ´Úµ Û´ µ</cell></row><row><cell>13</cell><cell></cell><cell cols="2">Ð´ µ</cell></row><row><cell>14</cell><cell>Û</cell><cell cols="2">Ï ´ µ</cell></row><row><cell>15</cell><cell></cell><cell></cell><cell>• ½</cell></row><row><cell>16</cell><cell cols="3">let Û Ñ Ü ¾ Û´ µ Û</cell></row><row><cell>17</cell><cell cols="2">Û´ µ</cell><cell>Û</cell></row><row><cell></cell><cell></cell><cell></cell><cell>Fig. 9. Algorithm BH-SPEC</cell></row><row><cell cols="4">Lemma 9:</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>¡ AE . As the base step, we consider the execution of the loop of line 7 for ÐÓ AE ´ µ , where ´× Ú ½ µ. Line 15 assures that Ï Ú ½ ´ µ Û ½ . Therefore ½´ µ ¡ AE ÓÔØ ½ ¡ AE. Thus, we proved that ½ ÓÔØ ½ ¡ AE.</figDesc><table><row><cell>Û</cell><cell>ÓÔØ</cell><cell>Ï</cell><cell cols="2">´ÔÓÔØ µ,</cell><cell>ÓÔØ</cell><cell cols="4">´ÔÓÔØ µ. For a node Ú</cell><cell>½</cell><cell>let</cell><cell>½ ¾</cell><cell>Ñ Ò ÐÓ AE</cell><cell>Ï Ú ℄</cell><cell>Û</cell></row><row><cell></cell><cell cols="7">We prove by induction on that</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">•• AE ÐÓ AE 1 for all Ú ¾ Î 2 do ÏÚ ¼℄</cell><cell>½</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="3">3 Ï× ¼℄</cell><cell>¼</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">4 ¼</cell><cell>¼</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">5</cell><cell>½</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">6</cell><cell>½</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="3">7 while</cell><cell cols="2">do</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">8 9</cell><cell cols="3">Ï× ℄ for all Ú ¾ Î do ¼</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="2">ÏÚ ℄</cell><cell cols="2">ÏÚ ½℄</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="8">for each node Ù taken in topologically sorted order do for each node Ú ¾ Ù℄</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>let</cell><cell cols="2">´Ù Úµ</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="5">if´´ µ µ then ÏÚ ℄ Ñ Ò ÏÚ ℄ ÏÙ</cell><cell>Û</cell><cell>´ µ</cell><cell>Û ℄ • Û´ µ℄</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="2">´ • ½µ</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="4">AE return ÏÚ ℄</cell><cell>½ ¾</cell><cell cols="4">ÐÓ AE for each Ú ¾ Î</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">Fig. 11. Algorithm RSP-DAG</cell></row></table><note><p><p>ÓÔØ , where AE .</p>ÓÔØ </p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>´Ú ½ Ú µ, where the last inequality follows from the inductive assumption. Hence, , and since ´½ À µ À is an increasing function of À, we conclude that ´½ À µ The computational complexity of Algorithm RSP-DAG is Ç´½ ¡ Å À ÐÓ µ, where is an upper bound on the cost of a path in .Proof: Let us count the number of iterations of the algorithm's main loop (i.e.the loop beginning on line 7). Let ½• . Clearly,</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>ÓÔØ ¡ AE , since</cell></row><row><cell cols="4">ÓÔØ Let Moreover, since for ÓÔØ ½ • ´ µ, where ½• . We have proved that ´Ú ½ Ú µ. À it holds that ´½ À µ ÓÔØ ´½ À µ for ½ ´½ À µ À ½ and ÓÔØ ½ . Therefore ÓÔØ . This result implies that , i.e., ÓÔØ ÓÔØ ½• , it holds that ÓÔØ ÓÔØ and the lemma follows.</cell><cell>ÓÔØ ´½ À µ . ½ . Since</cell></row><row><cell cols="2">Lemma 12: ½ ´½ À µ</cell><cell>, thus</cell><cell>ÐÒ ÐÒ´½ À µ . Since for all Ü</cell><cell>½ it holds that</cell></row><row><cell>ÐÒ´½ • Üµ</cell><cell>Ü, we have that</cell><cell></cell><cell></cell></row></table><note><p>À ÐÒ . Each iteration of the main loop requires Ç´Å µ time,hence the complexity of the algorithm is Ç´½ ¡ Å À ÐÒ µ. Since ¾ for ½, it follows that the algorithm's complexity is Ç´½ ¡ Å À ÐÒ µ.</p></note></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Private Network-Network Interface Specification v1.0 (PNNI)</title>
		<imprint>
			<date type="published" when="1996-03">March 1996</date>
		</imprint>
	</monogr>
	<note>ATM Forum Technical Committee</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">QoS routing mechanisms and OSPF extensions</title>
		<author>
			<persName><forename type="first">G</forename><surname>Apostolopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Guérin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kamat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Orda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Przygienda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Williams</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998-12">December 1998</date>
		</imprint>
	</monogr>
	<note>Internet Draft</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Intra-Domain QoS Routing in IP Networks: A Feasibility and Cost/Benefit Analysis</title>
		<author>
			<persName><forename type="first">G</forename><surname>Apostolopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Guérin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kamat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Orda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tripathi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Network Magazine</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Quality of service based routing: A performance perspective</title>
		<author>
			<persName><forename type="first">G</forename><surname>Apostolopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Guérin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kamat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tripathi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGCOMM</title>
		<meeting>SIGCOMM<address><addrLine>Vancouver, Ontario, CANADA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-09">September 1998</date>
			<biblScope unit="page" from="17" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Load Profiling for Efficient Route Selection in Multi-Class Networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bestavros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Matta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE ICNP&apos;97</title>
		<meeting>IEEE ICNP&apos;97<address><addrLine>Atlanta, GA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-10">October 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">H</forename><surname>Cormen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<title level="m">Introduction to Algorithms</title>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">A Framework for QoS-based Routing in the Internet -RFC No. 2386. Internet RFC</title>
		<author>
			<persName><forename type="first">E</forename><surname>Crawley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Nair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Rajagopalan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sandick</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998-08">August 1998</date>
		</imprint>
	</monogr>
	<note>The last statement, regarding general graphs. does not appear in [12], but can be easily verified</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and Intractability. Freeman</title>
		<imprint>
			<date type="published" when="1979">1979</date>
			<pubPlace>San Francisco</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Computing Shortest Path for Any Number of Hops</title>
		<author>
			<persName><forename type="first">R</forename><surname>Guerin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Orda</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
	<note>Unpublished manuscript</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">QoS-based routing in networks with inaccurate state and metrics information</title>
		<author>
			<persName><forename type="first">R</forename><surname>Guérin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Orda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">QoS routing mechanisms and OSPF extensions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Guérin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Orda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd IEEE Global Internet Mini-Conference</title>
		<meeting>the 2nd IEEE Global Internet Mini-Conference<address><addrLine>Phoenix, AZ</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-12">December 1996. November 1997</date>
		</imprint>
	</monogr>
	<note>Internet Draft</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Approximation schemes for the restricted shortest path problem</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hassin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematics of Operations Research</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="36" to="42" />
			<date type="published" when="1992-02">February 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">QoS Routing in Networks with Uncertain Parameters</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Lorenz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Orda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="768" to="778" />
			<date type="published" when="1998-12">December 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Optimal Partition of QoS Requirements on Unicast Paths and Multicast Trees</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Lorenz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Orda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE INFOCOM&apos;99</title>
		<meeting>IEEE INFOCOM&apos;99<address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999-03">March 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Quality of Service Routing for Traffic with Performance Guarantees</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Steenkiste</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IWQoS&apos;97</title>
		<meeting>IWQoS&apos;97<address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-05">May 1997</date>
		</imprint>
		<respStmt>
			<orgName>Columbia University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Routing with End to End QoS Guarantees in Broadband Networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Orda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">QoS Based Routing Algorithm in Integrated Services Packet Networks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Pornavalai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Chakraborty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shiratori</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE ICNP&apos;97</title>
		<meeting>IEEE ICNP&apos;97<address><addrLine>Atlanta, GA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-10">October 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Quality-of-Service Routing for Supporting Multimedia Applications</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Crowcroft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE JSAC</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="1288" to="1234" />
			<date type="published" when="1996-09">September 1996</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
