<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Practical, Distributed Network Coordinates</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Russ</forename><surname>Cox</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">MIT Laboratory for Computer Science</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Frank</forename><surname>Dabek</surname></persName>
							<email>fdabek@lcs.mit.edu</email>
							<affiliation key="aff0">
								<orgName type="department">MIT Laboratory for Computer Science</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Frans</forename><surname>Kaashoek</surname></persName>
							<email>kaashoek@lcs.mit.edu</email>
							<affiliation key="aff0">
								<orgName type="department">MIT Laboratory for Computer Science</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jinyang</forename><surname>Li</surname></persName>
							<email>jinyang@lcs.mit.edu</email>
							<affiliation key="aff0">
								<orgName type="department">MIT Laboratory for Computer Science</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Robert</forename><surname>Morris</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">MIT Laboratory for Computer Science</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Practical, Distributed Network Coordinates</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">1DF65BBABC25CC41C1FB960C8F362FED</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:05+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Vivaldi is a distributed algorithm that assigns synthetic coordinates to Internet hosts, so that the Euclidean distance between two hosts' coordinates predicts the network latency between them. Each node in Vivaldi computes its coordinates by simulating its position in a network of physical springs. Vivaldi is both distributed and efficient: no fixed infrastructure need be deployed and a new host can compute useful coordinates after collecting latency information from only a few other hosts. Vivaldi can rely on piggy-backing latency information on application traffic instead of generating extra traffic by sending its own probe packets.</p><p>This paper evaluates Vivaldi through simulations of 750 hosts, with a matrix of inter-host latencies derived from measurements between 750 real Internet hosts. Vivaldi finds synthetic coordinates that predict the measured latencies with a median relative error of 14 percent. The simulations show that a new host joining an existing Vivaldi system requires fewer than 10 probes to achieve this accuracy. Vivaldi is currently used by the Chord distributed hash table to perform proximity routing, replica selection, and retransmission timer estimation.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Synthetic coordinate systems are an approach to predicting inter-host Internet latencies. Nodes compute synthetic coordinates such that the Euclidean distance between the synthetic coordinates of different nodes predict latency in the Internet. Thus, if a node x learns about the coordinates of a node y with which it hasn't communicated before, x doesn't have to perform an explicit measurement to determine the latency to y; instead, the Euclidean distance between x and y in the space is an accurate predictor of the latency.</p><p>The ability to predict latency without prior communication allows systems to use proximity for better performance with less measurement overhead. A coordinate system could be used to select which of a number of replicated servers to fetch a data item from; such a system is particularly helpful when the number of potential servers is large or the amount of data is small. In either case it would not be practical to first probe all the servers to find the closest, since the cost of the probes would outweigh the benefit of an intelligent choice. Content distribution and file-sharing systems such as KaZaA <ref type="bibr" target="#b9">[10]</ref>, Bit-Torrent <ref type="bibr" target="#b1">[2]</ref>, and CoDeeN <ref type="bibr" target="#b22">[23]</ref> are examples of systems that offer a large number of replica servers. CFS <ref type="bibr" target="#b4">[5]</ref> and DNS <ref type="bibr" target="#b11">[12]</ref> are examples of systems that offer modest numbers of replicas, but each piece of data is small. GNP demonstrated that it is possible to calculate synthetic coordinates, and that they can be used to predict Internet latencies <ref type="bibr" target="#b13">[14]</ref>. GNP relies on a small number <ref type="bibr" target="#b4">(5)</ref><ref type="bibr" target="#b5">(6)</ref><ref type="bibr" target="#b6">(7)</ref><ref type="bibr" target="#b7">(8)</ref><ref type="bibr" target="#b8">(9)</ref><ref type="bibr" target="#b9">(10)</ref><ref type="bibr" target="#b10">(11)</ref><ref type="bibr" target="#b11">(12)</ref><ref type="bibr" target="#b12">(13)</ref><ref type="bibr" target="#b13">(14)</ref><ref type="bibr" target="#b14">(15)</ref><ref type="bibr" target="#b15">(16)</ref><ref type="bibr" target="#b16">(17)</ref><ref type="bibr" target="#b17">(18)</ref><ref type="bibr" target="#b18">(19)</ref><ref type="bibr" target="#b19">(20)</ref> of "landmark" nodes; other nodes measure latency to the landmarks to help them choose coordinates. The choice of which nodes are used as landmarks can significantly affect the accuracy of latency predictions made by GNP.</p><p>Vivaldi is a simple, distributed, symmetric algorithm for computing synthetic coordinates that requires no landmarks and provides an accuracy similar to that of GNP. In Vivaldi, each node computes coordinates for itself. Each time a node communicates with another node, it measures the latency to that node, and then adjusts its coordinates to minimize the error between measured latencies and predicted latencies. Vivaldi requires the user to set only a single parameter, which describes how much to adjust a node's coordinates in response to one new latency sample. This parameter is largely independent of the input and can be set conservatively to ensure accuracy at the cost of convergence time.</p><p>We believe that Vivaldi's properties could make synthetic coordinates more widely applicable. Vivaldi's simplicity, accuracy, and distributed, symmetric nature align well with the requirements of peer-to-peer systems that do not inherently have special, reliable nodes that are candidates for landmarks. As an example of its applicability, we describe how Vivaldi can be used to perform proximity routing and server selection, and to set retransmission timers in the Chord DHT <ref type="bibr" target="#b20">[21]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Design</head><p>Vivaldi assigns each node synthetic coordinates in a Ddimensional space. The goal of Vivaldi is to assign coordinates so that the Euclidean distance in synthetic coordinate space between two hosts accurately predicts the round-trip latency of packet transmission between the hosts.</p><p>Vivaldi chooses coordinates by sampling the network latency between each node and a few other nodes, and adjusting the nodes' coordinates to minimize the error between the predicted and sampled latencies. We first describe a centralized algorithm to minimize the error and then generalize it to a practical, distributed algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Centralized algorithm</head><p>When formulated as a centralized algorithm, the input to Vivaldi is a matrix of real network latencies M , such that M xy is the latency between x and y. The output is a set of coordinates. Finding the best coordinates is equivalent to minimizing the error (E) between predicted distances and the supplied distances. We use a simple squared error function:</p><formula xml:id="formula_0">E = x y (M xy -dist(x, y)) 2</formula><p>where dist(x, y) is the standard Euclidean distance between coordinates of x and y.</p><p>Vivaldi uses an algorithm based on a simulation of a network of physical springs to minimize E. This algorithm was inspired by work on model reconstruction <ref type="bibr" target="#b8">[9]</ref>; it mirrors a similar recent approach using force fields <ref type="bibr" target="#b19">[20]</ref>. Conceptually, Vivaldi places a spring between each pair of nodes for which it knows the network latency, with the rest length set to that latency. The length of each spring is the distance between the current coordinates of the two nodes. The potential energy of a spring is proportional to the displacement from its rest length squared: this displacement is identical to the prediction error of the coordinates. Therefore minimizing the potential energy of the spring system corresponds to minimizing the prediction error E.</p><p>Simulating spring relaxation requires much less computation than more general optimization optimization algorithms such as the simplex algorithm (used by GNP) and produces similarly accurate results. The spring-based algorithm outperforms simplex mainly because it takes advantage of gradient information to move the solution toward a minimal error solution; simplex does not depend on such gradient information and explores the the solution space in a less directed manner.</p><p>Vivaldi simulates the physical spring system by running the system through a series of small time steps. At each time step, the force on each node is calculated and the node moves in the direction of that force. The node moves a distance proportional to the applied force and the size of the time step. Each time a node moves it decreases the energy of the system; however, the energy of the system stored in the springs will typically never reach zero since network latencies don't actually reflect an Euclidean space. Neither the spring relaxation nor the simplex algorithm is guaranteed to find the global minimal solution; both can converge to a local minimum.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Distributed calculation</head><p>In the distributed version of Vivaldi, each node simulates a piece of the overall spring system. A node maintains an estimate of its own current coordinates, starting at the origin. Whenever two nodes communicate, the two nodes measure the latency between them and exchange their current synthetic coordinates. In RPC-based systems, this measurement can be accomplished by timing the RPC; in a stream oriented system, the receiver might echo a timestamp. An application might choose to make several measurements and report the minimum (or median) to Vivaldi, however, in the current deployment of Vivaldi on the Chord distributed lookup system  (see Section 4) we report the latency of each RPC to Vivaldi without degrading performance.</p><p>Once a measurement is obtained, both nodes adjust their coordinates to reduce the mismatch between the measured latency and the coordinate distance (see Figure <ref type="figure" target="#fig_0">1</ref>). A node moves its coordinates towards a point p along the line between it and the other node. The point p is chosen to be the point which reduces the difference between the predicted and measured latency between the two nodes to zero. To avoid oscillation a node moves its coordinates only a fraction δ towards p.</p><p>A node initializes δ to 1.0 when it starts, and reduces it each time it updates its coordinates. Vivaldi starts with a large δ to allow a node to move quickly towards good coordinates, and ends up with a small δ to avoid oscillation.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> omits one detail: if two nodes have the same coordinates (the origin, for instance), they each choose a random direction in which to move.</p><p>We expect that applications using Vivaldi will contact other nodes in the ordinary course of events, and report latency information to Vivaldi after each such contact. This means that Vivaldi will not need to send any packets itself. It also means that applications must add space for Vivaldi coordinates to their packet formats. The application should ensure that all nodes sample at roughly the same rate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Evaluation</head><p>This section uses simulations to explore Vivaldi's performance, focusing on how quickly Vivaldi converges and on how well Vivaldi's coordinates predict Internet latency.</p><p>Unless otherwise noted, we perform the simulations as follows. Each simulation involves 750 nodes. Each node starts with its synthetic location at the origin. Nodes take latency samples from randomly chosen other nodes. Synthetic coordinates have 5 dimensions; more dimensions provide better accuracy, but the improvement is small after two dimensions. This result is supported by principle component analysis on the matrix of latencies (omitted here but available separately <ref type="bibr" target="#b3">[4]</ref>), and by similar observations by Ng and Zhang <ref type="bibr" target="#b13">[14]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Latency data</head><p>The Vivaldi simulations are driven by a matrix of inter-host Internet latencies; Vivaldi uses a subset of the latencies for its samples, and the full matrix is needed to evaluate the quality of Vivaldi's resulting predictions. Since deriving realistic latencies from Internet topology models is difficult, we chose to use measured latencies.</p><p>We built a tool based on the King method <ref type="bibr" target="#b7">[8]</ref> to collect a full matrix of latencies among 750 Internet DNS servers. To determine the distance between DNS server A and server B we first measure the round trip time to server A and then ask server A to recursively resolve a domain served by B. The difference in times between the two operations yields an estimate of the round trip time between A and B. We use half the round trip time as the latency.</p><p>We harvested the addresses of recursive DNS servers by extracting the NS records for IP addresses of hosts participating in a Gnutella network. If a domain is served by multiple, geographically diverse name servers, queries targeted at domain D (and intended for name server B) could be forwarded to a different name server, C, which also serves D. Our tool cannot control where queries are forwarded. To avoid this error, the list of target domains and name servers was filtered to include only those domains where all authoritative name servers are on the same subnet (i.e. the IP addresses of the name servers are identical except for the low octet).</p><p>An asynchronous tool was used to determine the N (N -1) pair-wise latencies using the King method. The final latency for a given pair was taken to be the minimum of 10 trials, in order to filter out queuing delays and misses in DNS server caches. Collecting all pairwise latencies required several hours. Figure <ref type="figure">2</ref> shows the cumulative distribution of latencies produced from this data set. Because they are name servers, the machines included in the King trace are likely to be well connected to the Internet. The servers are geographically diverse, however, and include machines in North America, Europe, and Asia. For comparison, Figure <ref type="figure">2</ref> also shows pair-wise latencies obtained by direct measurements of 192 PlanetLab hosts <ref type="bibr" target="#b0">[1]</ref>. The King data has higher median latency (100 msec) than the PlanetLab data set (75 msec); this is likely due to the fact that most PlanetLab hosts are located at North American universities with fast Internet2 connections.</p><p>We used the N (N -1) latencies produced by the King tool as the input to a packet-level peer-to-peer simulator <ref type="bibr" target="#b6">[7]</ref>. Curves plot the error after the given number of samples; the error is calculated as the median of all round-trip pair-wise differences between predicted and actual latency. The lines marked with numbers indicate performance with the given fixed δ; the bold line marked "decreasing" shows the actual algorithm's performance.</p><p>The simulator delays each RPC packet by the time specified in the King data. Each node runs an instance of Vivaldi which sends RPCs to other nodes, measures the RPCs' RTTs, and uses those RTTs to update its synthetic coordinates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Setting the timestep</head><p>The δ variable (the timestep used during the spring simulation) in Figure <ref type="figure" target="#fig_0">1</ref> affects how fast Vivaldi converges. Figure <ref type="figure">3</ref> compares Vivaldi's performance with a range of fixed δ values against the actual algorithm's slowly decreasing δ. Each curve in Figure <ref type="figure">3</ref> shows results from a simulation with a different fixed δ. Each simulation begins with all 750 nodes starting Vivaldi at the same time. The x-axis reflects how much time has passed; the units are the number of samples each node has taken. The y-axis shows median error over all pair-wise predictions. Figure <ref type="figure">3</ref> shows that small δ values (such as 0.001) result in long convergence times. Intermediate values (as large as all nodes join at once with the convergence time when a few nodes join an existing converged system. The solid line shows a node joining an already stable system: the node converges after collecting fewer than 10 samples.</p><p>0.5) result in much faster convergence at the cost of some accuracy. As δ increases, final accuracy decreases, since large δ values allow nodes to vibrate more around their "correct" positions. Very large δ values (such as 1.0) cause the system to oscillate and fail to converge. The bold line marked "decreasing" in Figure <ref type="figure">3</ref> shows the performance with a decreasing δ. The initial value is large, so the error decreases quickly. δ eventually becomes small, so the error converges to a low value and does not oscillate. Using the decreasing δ (with a minimum of 0.05), the median error drops below 20 ms after 70 samples. When δ is fixed at 0.05 from the start of the simulation, the error does not drop below 20 ms until sample 157.</p><p>Vivaldi has no user-tunable parameters other than δ. This simplicity makes the algorithm more robust and easier to deploy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Time to Convergence</head><p>Figure <ref type="figure">3</ref> also shows that when all nodes join at the same time with incorrect initial coordinates, the system converges slowly (the median error is still dropping after 500 timesteps). Many applications of Vivaldi are likely to involve new nodes joining a larger existing system; thus new nodes are likely to join a system whose Vivaldi coordinates have already converged.</p><p>Figure <ref type="figure" target="#fig_2">4</ref> shows what happens when 10 new nodes join a converged Vivaldi system of 740 nodes. The solid line shows the error for one of the 10 nodes. The dashed line shows how long 740 nodes take to converge when they all start at once. New nodes arrive at good coordinates with less than ten samples. The algorithm's large initial δ allows the new node to converge rapidly in this case. The spike in the solid line around sample three is caused by the fact that the initial δ is probably too large and allows a brief initial period of oscillation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Vivaldi Accuracy</head><p>To understand the accuracy of Vivaldi we measured the error in the prediction of each pairwise latency using a relative error metric <ref type="bibr" target="#b13">[14]</ref>: abs(measuredpredicted) min(measured, predicted) Figure <ref type="figure" target="#fig_3">5</ref> shows the distribution of relative errors between every pair of nodes for Vivaldi. The error (solid line) is measured after the system has converged. In this experiment, Vivaldi's communication pattern was not restricted; the results determine the best-case performance of Vivaldi. Also shown is the error when Vivaldi is limited to communication with 64 neighbors (dot-dash line) and 32 neighbors (dashed line). Reducing the number of neighbors a node communicates with reduces the accuracy of predictions. The median error in the unrestricted case is 14 percent; using 64 neighbors the error is 22 percent; using 32 neighbors the error is 30 percent. Determining the exact influence of communication patterns on Vivaldi's performance is an area of future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Comparison with GNP</head><p>To understand Vivaldi's performance, we perform an initial comparison to GNP by running the GNP software <ref type="bibr" target="#b12">[13]</ref> on our data sets. GNP's performance depends on the placement of landmarks in the network. To measure the effect of landmark placement, we performed 30 experiments, each with a random set of 32 landmarks. For each experiment we produced a cumulative distribution of errors; the dotted line shows the median of the values of those distributions at a given cumulative fraction. Error bars denote the highest and lowest values and a given fraction.</p><p>The variance in GNP prediction error in Figure <ref type="figure" target="#fig_3">5</ref> shows that GNP's performance depends on the appropriate placement of landmarks. It is not clear in practice how to place landmarks appropriately. The authors of GNP suggest a clustering technique that depends on a priori knowledge of the complete latency matrix, but the running time of the provided implementation of this algorithm prevented us from running it on our data sets. One of Vivaldi's advantages is symmetry: no nodes need be selected as landmarks.</p><p>Vivaldi's best performance (when nodes' communication is not restricted) is better than GNP's best performance. To better compare the two systems, we examine the error when nodes running Vivaldi communicate with 32 random neighbors (GNP was run with 32 landmarks). In this test, Vivaldi's median error (30 percent) closely matches the best median error of GNP (28 percent).</p><p>This comparison illustrates that Vivaldi's prediction error is competitive with that of GNP. A more detailed comparison of the two systems is future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Applications</head><p>We believe Vivaldi will be useful for a variety of distributed applications such as CDNs, the DNS, and file-sharing appli- cations such as KaZaA. We developed Vivaldi to assist proximity routing and server selection in the Chord <ref type="bibr" target="#b20">[21]</ref> peer-topeer lookup system. We will describe that application in detail here.</p><p>Chord uses coordinates to efficiently build routing tables based on proximity so that lookups are likely to proceed to nearby nodes. A node receives a list of candidate nodes and selects the one that is closest in coordinate space as its routing table entry; coordinates allow the node to make this decision without probing each candidate.</p><p>Chord utilizes coordinates when performing an iterative lookup. When a node n 1 initiates a lookup and routes it through some node n 2 , n 2 chooses a next hop that is close to n 1 based on Vivaldi coordinates. In an iterative lookup n 1 sends an RPC to each intermediate node in the route, so proximity to n 1 is more important than proximity to n 2 .</p><p>A new version of DHash <ref type="bibr" target="#b4">[5]</ref>, a distributed hash table built on top of Chord, uses Vivaldi to perform server selection. DHash uses erasure coding to divide blocks into a number of fragments. Only a subset of these fragments are necessary to reconstruct the original block. A node fetches a block by asking the block's successor for a list of the nodes holding the fragments, along with the coordinates of those nodes. The fetching node then fetches fragments from the nodes with the closest coordinates. If the node had to first measure the latency to each of these nodes, the extra round-trip time would probably cancel out the benefit of choosing the closest fragments.</p><p>Chord (and DHash) also use Vivaldi in their RPC system. Chord sends RPCs over UDP, so Chord must handle retransmissions. Chord often contacts other nodes just once, so it cannot profitably measure the round-trip time in order to set the RPC retransmission timer. Instead, Chord uses a small multiple of the latency predicted by Vivaldi as the initial RPC retransmission timer.</p><p>Chord and DHash required a few modifications to use Vivaldi. Whenever one node sends an RPC request or reply to another, it includes its own coordinates. The RPC system times each RPC and tells Vivaldi the measured latency and the coordinates of the other node. This allows Vivaldi to collect information without much added overhead, since the coordinates increase the size of each RPC message by just 12 bytes. In addition, whenever nodes exchange routing information about other nodes, they send along the coordinates of those other nodes as well as their IP addresses. Thus Chord always knows the coordinates of any node it is about to contact, even if it has never talked to that node before.</p><p>After we modified DHash to perform proximity routing and replica selection using Vivaldi the time required to fetch a block decreased by a factor of two when the system was run on the PlanetLab test bed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Related work</head><p>Vivaldi was inspired by GNP <ref type="bibr" target="#b13">[14]</ref>, which demonstrated that coordinates can effectively describe the latencies between hosts on the Internet. Vivaldi's contribution is a distributed algorithm that computes coordinates without landmark nodes.</p><p>IDMaps <ref type="bibr" target="#b5">[6]</ref> is a proposed infrastructure to help hosts predict Internet latency to each other. The IDMaps infrastructure consists of a few hundred or thousand tracer nodes. Every tracer measures the Internet latency to every other tracer. The tracers also measure the latency to every CIDR address prefix, and jointly determine which tracer is closest to each prefix. Then the latency between host h 1 and host h 2 can be estimated as the latency from the prefix of h 1 to that prefix's tracer, plus the latency from the prefix of h 2 to that prefix's tracer, plus the latency between the two tracers. One advantage of IDMaps over Vivaldi is that IDMaps reasons about IP address prefixes, so it can make predictions about hosts that are not even aware of the IDMaps system. Vivaldi, on the other hand, requires no separate infrastructure.</p><p>Waldvogel and Rinaldi <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b18">19]</ref> describe a spring relaxation technique to assign IDs to landmark nodes as part of the Mithos proximity-aware overlay network. A number of aspects of their algorithm require a centralized implementation.</p><p>Lighthouse <ref type="bibr" target="#b14">[15]</ref> is an extension of GNP that is intended to be more scalable. Lighthouse, like GNP, has a special set of landmark nodes. Unlike GNP, a node that joins Lighthouse does not have to query those global landmarks. Instead, the new node can query any existing set of nodes to find its coordinates relative to that set, and then optionally transform those coordinates into coordinates relative to the global landmarks.</p><p>Priyantha et al. <ref type="bibr" target="#b15">[16]</ref> describe a distributed node localization system for wireless sensor networks that uses spring relaxation. The sensors use ultrasound propagation times to measure inter-sensor distances and cooperate to derive coordinates consistent with those distances. Much of the algorithm is devoted to solving a problem that doesn't affect Vi-valdi: the fact that two non-adjacent sensors cannot measure the distance between themselves makes it hard for the system to avoid letting the coordinate space double back on itself.</p><p>Rao et. al. <ref type="bibr" target="#b16">[17]</ref> compute virtual coordinates for use in geographic forwarding in a wireless ad-hoc network. Their algorithm does not attempt to predict latencies; instead, the purpose is to make sure that directional routing works.</p><p>A number of peer-to-peer networks incorporate proximity routing <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b10">11]</ref>. We hope that many of these systems will benefit from using synthetic coordinates.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Pseudo-code for the Vivaldi update routine. update() moves the node's coordinates (my c) based on the measured latency to another node and the other node's current synthetic coordinates.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :Figure 3 :</head><label>23</label><figDesc>Figure 2: The cumulative distribution of pairwise round-trip latencies in the King data set (solid line) and the PlanetLab data set (dotted line)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: This figure compares Vivaldi's convergence time when</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Vivaldi and GNP accuracy. The solid line shows Vivaldi's accuracy when nodes' communication is unrestricted. The dashed line shows Vivaldi's accuracy when nodes are restricted to communicating with 32 neighbors. Several GNP experiments were run, each with a different set of 32 random landmarks. The dotted line denotes the median result, the error bars show the best and worst prediction errors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>// called for each new measurement. // s_c is the other host's coordinates. // s_l is the one-way latency to that host. // δ starts at 1.0.</figDesc><table><row><cell>update(s_c, s_l) {</cell></row><row><cell>// unit vector towards other host</cell></row><row><cell>Vector dir = s_c -my_c;</cell></row><row><cell>dir = dir / length(dir);</cell></row><row><cell>//Distance from spring's rest position</cell></row><row><cell>d = dist(s_c, my_c) -s_l;</cell></row><row><cell>// displacement from rest position</cell></row><row><cell>Vector x = dir * d;</cell></row><row><cell>// reduce δ at each sample</cell></row><row><cell>δ -= 0.025;</cell></row><row><cell>// but stop at 0.05</cell></row><row><cell>δ = max (0.05, δ);</cell></row><row><cell>x = x * δ;</cell></row><row><cell>// apply the force</cell></row><row><cell>my_c = my_c + x;</cell></row><row><cell>}</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions and Discussion</head><p>Vivaldi is a simple, distributed algorithm for finding synthetic coordinates that accurately predict Internet latencies. Vivaldi is fully distributed; for example, it does not require a pre-selected subset of nodes to be designated as landmarks.</p><p>Vivaldi is simple; it has only one tunable parameter. These properties make it easy to deploy Vivaldi in distributed systems: we have used Vivaldi to improve the performance of the Chord peer-to-peer lookup system.</p><p>Additional work remains to further understand and improve Vivaldi's performance. For example, we are exploring how nodes' communication patterns affect prediction accuracy. We are also interested in determining to what extent Internet latencies can be embedded in a N-dimensional Euclidean space and the reasons such an embedding is possible. Finally, we plan to modify additional distributed applications to take advantage of Vivaldi and quantify how much Vivaldi improves performance.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This research was conducted as part of the IRIS project (http://project-iris.net/), supported by the National Science Foundation under Cooperative Agreement No. ANI-0225660. Russ Cox is supported by a fellowship from the Fannie and John Hertz Foundation.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>Planetlab</surname></persName>
		</author>
		<ptr target="www.planet-lab.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="http://bitconjurer.org/BitTorrent/protocol.html" />
		<title level="m">BitTorrent</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Exploiting network proximity in peer-to-peer overlay networks</title>
		<author>
			<persName><forename type="first">Miguel</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Druschel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">C</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Antony</forename><surname>Rowstron</surname></persName>
		</author>
		<idno>MSR-TR-2002-82</idno>
		<imprint>
			<date type="published" when="2002-06">June 2002</date>
			<publisher>Microsoft Research</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Learning Euclidean coordinates for Internet hosts</title>
		<author>
			<persName><forename type="first">Russ</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Dabek</surname></persName>
		</author>
		<ptr target="www.pdos.lcs.mit.edu/˜rsc/6867.pdf" />
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Wide-area cooperative storage with CFS</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Frans</forename><surname>Frank Dabek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><surname>Karger</surname></persName>
		</author>
		<ptr target="http://www.pdos.lcs.mit.edu/chord" />
	</analytic>
	<monogr>
		<title level="m">Proc. 18th ACM Symposium on Operating Systems Principles (SOSP &apos;01)</title>
		<meeting>18th ACM Symposium on Operating Systems Principles (SOSP &apos;01)</meeting>
		<imprint>
			<date type="published" when="2001-10">October 2001</date>
		</imprint>
	</monogr>
	<note>Robert Morris, and Ion Stoica</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">IDMaps: A global Internet host distance estimation service</title>
		<author>
			<persName><forename type="first">P</forename><surname>Francis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jamin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Raz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Shavitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<date type="published" when="2001-10">October 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Peer-to-peer simulator</title>
		<author>
			<persName><forename type="first">Thomer</forename><surname>Gil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jinyang</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frans</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Morris</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
	<note>Source available at: cvs.pdos.lcs.mit.edu</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">King: Estimating latency between arbitrary Internet end hosts</title>
		<author>
			<persName><forename type="first">Krishna</forename><forename type="middle">P</forename><surname>Gummadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Saroiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><forename type="middle">D</forename><surname>Gribble</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SIGCOMM IMW</title>
		<meeting>of SIGCOMM IMW</meeting>
		<imprint>
			<date type="published" when="2002-11">2002. November 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Surface reconstruction from unorganized points</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science and Engineering, University of Washington</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<ptr target="http://www.kazaa.com/" />
		<title level="m">KaZaA media dekstop</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">OceanStore: An architecture for globalscale persistent storage</title>
		<author>
			<persName><forename type="first">John</forename><surname>Kubiatowicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Bindel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yan</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><surname>Czerwinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Eaton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Geels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ramakrishna</forename><surname>Gummadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sean</forename><surname>Rhea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hakim</forename><surname>Weatherspoon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Westley</forename><surname>Weimer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chris</forename><surname>Wells</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ben</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeedings of the Ninth international Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS 2000)</title>
		<meeting>eeedings of the Ninth international Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS 2000)<address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-11">November 2000</date>
			<biblScope unit="page" from="190" to="201" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Development of the Domain Name System</title>
		<author>
			<persName><forename type="first">P</forename><surname>Mockapetris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">J</forename><surname>Dunlap</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM<address><addrLine>Stanford, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="123" to="133" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Gnp software</title>
		<author>
			<persName><forename type="first">Eugene</forename><surname>Ng</surname></persName>
		</author>
		<ptr target="http://www-2.cs.cmu.edu/~eugeneng/research/gnp/software.html" />
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Predicting Internet network distance with coordinates-based approaches</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Eugene</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hui</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Infocom</title>
		<meeting>IEEE Infocom</meeting>
		<imprint>
			<date type="published" when="2002">2002. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Lighthouses for scalable distributed location</title>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Pias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jon</forename><surname>Crowcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steve</forename><surname>Wilbur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tim</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Salem</forename><surname>Bhatti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IPTPS</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Anchor-free distributed localization in sensor networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Priyantha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Demaine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Teller</surname></persName>
		</author>
		<idno>TR-892</idno>
		<imprint>
			<date type="published" when="2003-04">April 2003</date>
		</imprint>
		<respStmt>
			<orgName>MIT LCS</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Geographic routing without location information</title>
		<author>
			<persName><forename type="first">Ananth</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sylvia</forename><surname>Ratnasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christos</forename><surname>Papadimitriou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ion</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM MobiCom Conference</title>
		<imprint>
			<date type="published" when="2003-09">September 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Topologically-aware overlay construction and server selection</title>
		<author>
			<persName><forename type="first">Sylvia</forename><surname>Ratnasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Handley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Karp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Infocom</title>
		<meeting>IEEE Infocom</meeting>
		<imprint>
			<date type="published" when="2002">2002. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Routing and data location in overlay peer-to-peer networks</title>
		<author>
			<persName><forename type="first">Roberto</forename><surname>Rinaldi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcel</forename><surname>Waldvogel</surname></persName>
		</author>
		<idno>RZ- 3433</idno>
		<imprint>
			<date type="published" when="2002-07">July 2002</date>
		</imprint>
		<respStmt>
			<orgName>IBM</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Research Report</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Big-bang simulation for embedding network distances in Euclidean space</title>
		<author>
			<persName><forename type="first">Yuval</forename><surname>Shavitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tomer</forename><surname>Tankel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Infocom</title>
		<meeting>of IEEE Infocom</meeting>
		<imprint>
			<date type="published" when="2003-04">April 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Chord: A scalable peer-to-peer lookup protocol for internet applications</title>
		<author>
			<persName><forename type="first">Ion</forename><surname>Stoica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Liben-Nowell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Karger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Frans</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Dabek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hari</forename><surname>Balakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<biblScope unit="page" from="149" to="160" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Efficient topologyaware overlay network</title>
		<author>
			<persName><forename type="first">Marcel</forename><surname>Waldvogel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roberto</forename><surname>Rinaldi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hotnets-I</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">The Effectiveness of Request Redirecion on CDN Robustness</title>
		<author>
			<persName><forename type="first">Limin</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vivek</forename><surname>Pai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Larry</forename><surname>Peterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifth Symposium on Operating Systems Design and Implementation</title>
		<meeting>the Fifth Symposium on Operating Systems Design and Implementation<address><addrLine>Boston, MA USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-12">December 2002</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
