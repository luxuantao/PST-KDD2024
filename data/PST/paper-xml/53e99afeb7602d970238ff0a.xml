<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Serge ABITEBOUL**</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Richard</forename><surname>Hull</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Domaine de Rocquencourt</orgName>
								<address>
									<postCode>78153</postCode>
									<settlement>Le Chesnay</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of Sotithern California</orgName>
								<address>
									<postCode>90089-0782</postCode>
									<settlement>Los Angeles</settlement>
									<region>CA</region>
									<country key="US">U.S.A</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Serge ABITEBOUL**</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C4175AFEDB97AE64AF2444B818E59DB5</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:54+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>12</term>
					<term>C:7] 11 F:{D:O</term>
					<term>D:7</term>
					<term>D:12}</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A class of hierarchical structures arising in Database Systems (complex objects) and Ofice Information Systems (forms) is studied. Two formalisms for resLructuriag are presented. The first focuses on a class of algebraic cperators based on rew%e rules, and the second on structural transformations which preserve or augment data capaci+. These transfurtnations are related to a subclass of the rewrite operations which is closed under composition.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>A recent trend in the database field is to consider hierarchical data structures. Hierarchical data structures are central in the nested relational model <ref type="bibr">[2,7,f9, 20,.</ref> . .], and have been studied under the name formats [l2], and complex objects <ref type="bibr">[1,</ref><ref type="bibr">6]</ref>. These structures also arise naturally in semantic database models offering aggregation, grouping, and generalization <ref type="bibr">[3,</ref><ref type="bibr">8,</ref><ref type="bibr">11,</ref><ref type="bibr">21]</ref>. In fact, forms in Office Information Systems are similar kinds of structures <ref type="bibr">[ l&amp;22,23]</ref>. The purpose of this paper is to develop tools to manipulate typed hierarchical objects.</p><p>The focus of the paper is on typed hierarchical objects obtained using: 0 tuple constructor (aggregation), 0 set constructor (grouping), and 0 union of types (generalization). These objects and their underlying types are similar to those found in <ref type="bibr">[3,</ref><ref type="bibr">12,</ref><ref type="bibr">14]</ref>, Most other investigations have considered data structures involving the first two constructors only. The use of the third constructor permits the representation ti:.' sets of objects of possibly different types. <ref type="bibr">(In [d]</ref>, sets of objects of possibly different structures are considered without emphasizing the use of stric': typing.) Another feature of the model here is the utilization of particular constants which can serve as nonapplicable nulls; these can also be used to model boolean and other finite domains.</p><p>One of the major research problems facing tihe database field is CO understand how to manipulate hierarchical ,;tructures. Languages were already presented for typed objects built using the first two constructors <ref type="bibr">[I,</ref><ref type="bibr">2,</ref><ref type="bibr">7,</ref><ref type="bibr">13,</ref><ref type="bibr">15,</ref><ref type="bibr">2Q,</ref>, the union-of-types constructor is also considered. Most of these investigations have focused on operations to extract (selection/projection), or to combine information (union/difference), providing very limited capabilities for manipulating the structure of data (nest/unnest). The first theme of the paper is the presentation and study of an operation (called "rewrite operation") which</p><p>(1) handles objects built using the three constructors, and</p><p>(2) permits the specification of complex structural manipulations. These rewrite operations have some similarities to a central operator of the practical language described in 1171 for the nested relational model. We present some basic results on rewrite operations, and exhibit the subclass of "simple" rewrite operations which is closed under composition.</p><p>The second theme of the paper is to study the problem of data restructuring. In virtually all database models, it is possible to represent essentially the same data in different ways. This notion 0, p "data relativism" arises in a variety of contexts like database integration, view construction, form modification. It is thus crucial to understand data relativism at a fundamental level <ref type="bibr">[3,</ref><ref type="bibr">8,</ref><ref type="bibr">9,</ref><ref type="bibr">121</ref>, so that systems can effectively translate between alternative data representations.</p><p>Our study of data relativism is based on local structural transformations of types. Some of these transformations preserve data capacity, and lead to a characterization of "structural equivalence" which generalizes results of [ 121. Other transformations provide ways to augment the data capacity of a type. The effect of all these transformations can be achieved using only simple rewrite operations. If a user specifies the restructuring of the database using a sequence of transformations as defined here, the system can compute the new database state using a single rewrite operation (since simple rewrite operations are closed under composition).</p><p>The paper is organized as follows. Types are presented in Section 2 together with their corresponding objects. Section 3 introduces the rewrite operations, and a normal form for these operations. In Section 4, we show that the class of simple rewrite operations is closed under composition. Results concerning structural equivalence are presented in Section 5. Finally, augmentation is studied in Section 6. (A key lemma for Section 4 is proved in Appendix A. Motivating examples for the restrictions imposed on simple rewrite operations are gathered in Appendix B. Sketches of proofs for two results in Section 5 can be found in Appendix C.)</p><p>The purpose of this section is to motivate and formally define types and objects. We first present an example concerning two versions of information that might be stored in a personnel database. Consider the two templates shown in Fig. <ref type="figure" target="#fig_22">1</ref>. The structure of these forms is described by the types shown in Fig. <ref type="figure" target="#fig_0">2</ref>. Speaking roughly, a "type" is a tree with certain kinds of nodes. All leaf nodes of a type correspond to "basic types". This includes such types as "alpha", "g-dig", etc., and also some special type which has a one-element domain denoted by I (with a subscript). There are three kinds of internal nodes. Intuitively, x-nodes correspond to the tupie constructor; *-nodes correspond to the set constructor; finally, +-nodes correspond to the union of types (or marked union) constructor. Types s described here generalize the notion of "format" [ 121, and the types of [3] to include basic types with one-element domain. As we shall see, these types can be used to represent nonapplicable nulls, and finite domains. Furthermore, they play an important role in our study of restructuring.</p><p>As mentioned in the introduction, types can serve as a formal model for representing data structures used in various disciplines. First, types subsume the family of form structures considered in Office Automation Systems <ref type="bibr">[ l&amp;22,23]</ref>. Furthermore, as indicated in the example, this model provides the possibility of faithfully representing forms in which different parts are to be filled out under different circumstances. (On the other hand, as described here the model does not directly incorporate the occurrence of dependent fields, such as one field which is to be the sum of two other fields.) Also, types can be used to model classes of objects arising in Semantic Database Models <ref type="bibr">[3,</ref><ref type="bibr">8,</ref><ref type="bibr">11,</ref><ref type="bibr">211</ref> which incorporate aggregation, grouping, and generalization. Finally, it should be noted that the structures of nested relations correspond to types in which tuple and set constructors alternate.</p><p>We now present formal notions of type and object.</p><p>-We assume the existence of infinite sets doml , . . . , dom,, . . . of atomic values called the basic domains. These sets are all cou' table and pairwise disjoint. We also assume the existence of a particular atomic valuL, denoted 1, which is not in domi for any i. The set (1) will serve as the unique one-element domain.</p><p>We also assume the existence of an infinite set of symbols called attributes, which will be used as labels for the domains. To distinguish between infinite and oneelement domains, attributes with infinite domains are denoted with letters from the beginning of the alphabet; and attributes with one-elemerlt domain are denoted 1 with subscripts (e.g., If, lyes. . . ). Finally, we assume the existence of an infinite set of symbols called tokens which contains the set of attributes.</p><p>We use a syntactic representation for types where: square brackets ([ ;]) correspond to tuple constructors, braces ({;}) ccrrespond to set constructors, and angle brackets ((;)j correspond to union of types constructors. Formally, we have the following definitions.</p><p>Definition. A type is an expression recursively defined as follows: 0 if A is an attribute, A:domi is a (basic) type for each i; * if 1, is an attribute, 1/:{ l} is a (basic) type; 0 if P is a non-attribute token, n 2 1, PI,. . . , P, are distinct tokens, and 7', = P1:tr * . . . , Tn = P,:t, are types, then P:{ T,}, P:[ T,, . . . , Tn], and Pr( T,; . . . ; T,) are also types. If P: t is a type, then the expression t is called a structure (i.e., a structure is a type deprived of its outermost token).</p><p>When domains are understood, we omit them from the specification of types. For instance, if it is understood that the domain of A and B is doml, we can use the expression P:(Q:[A, B];lJ to denote the type P:(Q:[A:doml, B:dom,];lf:{l}) (since the domain of 1~ is by definition 11)).</p><p>In the following, we assume that the order between tokens in a tuple or union-oftypes constructor is irrelevant. For instance, we do ciot distinguish between the types P:(Q:[A:Joml, B:dom,];lf: <ref type="bibr">(l})</ref> and P:(l~:{l};Q:[B:dOriZiz A:dom,]). This motivates an alternative definition of types based on trees. Leaves of the trees denote atomic types, and are labelled by attributes. Internal nodes correspond to applications of the constructors, and are labelled by non-attribute tokens. Formally, we have this definition.</p><p>Definition. A type is a rooted tree ( V, E) where V = V+ u V.+ u Vx u V, is tire disjoint union of +-nodes, *-nodes, x-nodes, and basic nodes such that (i) a node is a basic node iff it is a leaf, and (ii) each *-node has exactly one child. The nodes of a type are labelled by tokens with the following restrictions:</p><p>(iii) a node is assigned an attribute iff it is a leaf, and (iv) distinct siblings (i.e., distinct children of the same node) are assigned distinct mkens. A domain is assigned to each leaf with the restriction that the one-element domain is assigned to each leaf labelled lf for some J:</p><p>The trees in Fig. <ref type="figure" target="#fig_0">2</ref> correspond to the types in Fig. <ref type="figure" target="#fig_19">3</ref> below. Note that some tokens are omitted in Fig. <ref type="figure" target="#fig_0">2</ref>; and basic domains are omitted in Fig. <ref type="figure" target="#fig_19">3</ref>. We will freely omit tokens when not necessary to the presentation. It should be clear that this notion of type subsumes the concept of relational database schema. An example of a relational database schema viewed as a type is given in Fig. <ref type="figure">4</ref>.</p><p>With each type, we associate a set of objects in the following way. (3) P:( }, and P:{l,:l} are the only objects of type P:{$} (where it is assumed that the basic domain associated with B, B' and B" is the set of natural numbers).</p><p>In our formalism, the convention of including tokens in objects is very strict. An advantage is that by inspection of an object, its type can (almost) be determir ed. This will be useful in in our study of restructuring. Some other investigations may want to relax this constraint. On the other hand, new constraints on the naming convention may be introduced for query purposes, e.g., enforcing that two distinct nodes should be assigned distinct tokens.</p><p>When the type is understood and an implicit ordering of siblings assumed, we can simplify the syntactic description of objects. For instance, the object of (2) can be written as <ref type="bibr">[{[13,7,105]</ref>, <ref type="bibr">[7,</ref><ref type="bibr">13,</ref><ref type="bibr">13</ref>]}, ( }]. Also, when no confusion can arise, the object lf: 1, for some index f; is simply denoted If.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Rewrite expression</head><p>In this section, we introduce the rewrite expressions on typed objects. These expressions will be essential to our study of restructuring. We also exhibit a "decomposed form" for rewrite expressions, and prove that every rewrite expression can be transformed into an equivalent decomposed one.</p><p>In order to manipulate data, we need a powerful operator. We use a notion of rule (inspired by the rules of [6]) to describe how an object should be "rewritten". Indeed, a rewrite expression will be defined using several rules, each rule corresponding to some particular shape that can be taken by the operand.</p><p>We assume the existence of an infinite set var of symbols called (unconstructed) variables. Intuitively, variables will be place holders for values. The analogue for objects are the "terms" that are now defined.</p><p>Definition. For each type T, the terms (of T) are recursively defined by (i) each object of type T is a term of T;</p><p>(ii) if T = P: t for some structure t and x is an unconstructed variable, P:x is a term of T;</p><p>(iii) if T=P:[TI,..., Tn] is a type and Xi a term of T for each i in [ 1.</p><p>. n], then P:[X*,..., X,] is a term of T; (iv) if T=P:(T,;...; T,) is a type and Xj a term of q for some j in [ 1.</p><p>. n], then P:(Xj) is a term of T; and</p><p>(v) if T = P:{ T'} is a type and Xi a term of T' for each i in [l.. n 1, then</p><formula xml:id="formula_0">P:{X,,..., X,) is a term of T. If P: v is a term, then v is a variable unconstructed if v is in vas, constructed otherwise.</formula><p>Note the strong analogy between (1) objects and values, (2) types and structures, and (3) terms and variables (see Fig. <ref type="figure">5</ref>). Note also that the definition of terms permits their specification with components of arbitrary granularity. For instance, Given il type S, a term X of S, and a variable y appearing in X, a structure t,, can be assigned to y by pattern-matching2 of X and S. The structure t,, will be called the structure of y w.r.t. X and S, or simply the structure of y if S and X are understood from the context. Rewrite rules will be used to specify object manipulation. We first present simple examples which show how rules can be used to perform simple selections and projections.</p><p>Example 3.1. Consider a type consisting of sets of Form 1 as in Section 2. The following rules can be used on such forms:</p><p>(1) renaming:</p><p>[ last_name:q first-name: y, ss# : 2, sex: w] + [nom:x, prenom:y, ss# : 2, sexe: w];</p><p>(2) ss# of persons with first name 'mary':</p><p>[ last_name:x, first-name: 6mary', ss# : 2, sex: w] + ss# : 2;</p><p>(3) persons with identical Jirst and last names:</p><p>[ last_name:x, first-name: x, ss# : 2, sex: w ] + [last_name:x, first_name:x, ss#:z, sex: w];</p><p>(4) maiden-names (of married females) : (5) nan a' of females with first name 'mary' having exactly one chili :</p><p>[last-name:x, first-name:'mary', ss#:z, . i[x, 'mary', 5 Mu), vl)l+ x.</p><p>In the previous example, rewrite rules are used to specify operations on objects. As illustrated in the next example, it is possible to use several rules to treat different options resulting from alternative structures of the operand. We also show how rewrite rules can be considered to form rewrite "expressions" which map set-valued objects to set-valued objects.</p><p>Example 3.2. Suppose that we want, for each person, the set of children of that person. In our base of forms, males are not allowed to "have" children. Thus, one rule will be required for males, and one for females:</p><formula xml:id="formula_1">r, = [x, y, 2, sex:(military_position: u)] + [x, { }], r, = [x, y, 2, sex:(female:[ u, w])] + [x, u].</formula><p>The rewrite expression, Q:rew( r, , Q), will map a set of forms into a set of pairs. We now formally present the rewrite rules and rewrite expressions. Other motivating examples are given afterwards. Recall that, as mentioned in the previous discussion, rewrite expressions are used to map set-valued objects to set-valued objects.</p><p>Definition. Let X be a term of type S. Rewrite rules and rewrite expressions from X are defined recursively in the following way:</p><p>(i) (a) If c is a basic constant in domi for some i, X + P: c is a rule from S to P:domi, (b) X + l,-: 1 is a rule from S to If, if y is a variable of structure t w.r.t. X and S, (c) X 3 P:y is a rule from S to P: t, (d) if p is a rewrite expression from Q: t to T' (and hence, t has the set structure), X + p(y) is a rule from S to T'. (1) their left-hand side can be "unified"; and</p><p>(2) their right-hand side can be "unified". The semantics of rewrite rules and expressions is given by the following definition.</p><p>Definition. An assignment is a partial mapping LY form the set of unconstructed variables to the set of values. The mapping is extended to terms, and rewrite expressions in the following way: (0) cy (0) = 0 for each object 0, (1) a(A:x) = Ax(x) for each A and unconstructed variable X, which might be used to store each employee along with his/ her children differentiated by sex. We now give a rewrite expression which maps objects of the first type into objects of the second in the natural manner. where p is as in the previous example.</p><p>Since rewrite expressions are interpreted as functions, it is natural to study compositions of these functions. As illustrated in the following example, if p and p' are rewrite expressions, p 0 p' denotes the composition of p followed by p'.</p><p>Example 3.6. Consider a type consisting of sets of Form 1 as in Section 2. Suppose that we want to distinguish "mothers", i.e., females with at least one child. Then this can be computed using p 0 p', where (Note that the outermost token of the rewrite expressions is omitted here.)</p><p>We now turn to a result showing how rewrite expressions can be put into a certain normal form called "decomposed". In particular, we show that, for each rewrite expression P:rew(A), there is an quivalent rewrite expression P:rew(A') such that all rewrite rules in A' are decomposed.</p><p>The notion of decomposed has the following particularly simple definition. Roughly speaking, a rewrite rule X + Y is decomposed if the term X (and all premises of nested rewrite rules in Y) makes explicit choices concerning which branch of each +-node to take. To articulate this more formally, we introduce two important notions. The first allows us to focus on the part of a type T lying "above" its *-nodes (see Fig. <ref type="figure">6</ref>).</p><p>Definition. The *-frontier of a type T is the set of nodes of T containing all leaves, and *-nodes of T which are not (proper) descendants of a *:-node.</p><p>The second provides a natural partitioning of the domain of T to "choices" made at the +-nodes above the *-frontier, and at nodes with underlying structure {I} (see Fig. <ref type="figure">7</ref>).  <ref type="figure">D,</ref><ref type="figure">E,</ref><ref type="figure">H,</ref><ref type="figure">K L,</ref><ref type="figure">N,</ref><ref type="figure">0</ref>). (See Fig. <ref type="figure">7</ref>.) The choice trees of T are <ref type="figure">A:( B:[ C,</ref><ref type="figure">D:{ D'},</ref><ref type="figure">A:(F:(H));</ref><ref type="figure">A:(F:(I:[J:(K:{(K,</ref> (One of these choice trees is shown in Fig. <ref type="figure">7</ref>.) Clearly, their corresponding domains are disjoint.</p><p>The following result is easily verified.</p><p>Lemma 3.7. If a term X over S is decomposed, then there is some choice tree S' of S such that {a(X)i (Y an assignment} n obj( S) c_ obj( S').</p><p>We now have the following lemma. Thus, each rewrite expression is equivalent to a decomposed rewrite expression.</p><p>Proof. Let X + Y be a rewrite rule from S to T. can assume in each rule occurring within a rewrite expression o is &amp;cc;mpose collection of variabics occurring within nested rewrite rules of Y !: the collection of variabks occurring at the outermost level of X or present an iterative cons&amp;u&amp;on for replacing unconstructed variab violate the definition of decompose3 by less complex unconstructed possibly { } or &amp;:1}), In this conskuction, we begin with the se generate sets Al, AZ, . . . . These wih have the property that re rew(X + Y)( 0') for each object Ok obj(P':{S}). If at some step some not decomposed, we replace that rule by a set of rules according to the now described.</p><p>Suppose that U+ V is a rewrite rule in Ak from S to T, and that w occurring in U which violates the definition of decomposed (i.e., w is u and either it is of structure { lJ) for some f, or it is not atomic nor of set cases arise: Letting Ak+ p = Ak -{U + V} u {U, + V,}, we now have rew(A,)( 0) = re (b) If w is of structure (Pl:sl; . . . ; P,:s,), then let Wi be an unconstru for i E [ 1.</p><p>. n], and construct rules Ui + V;-, i E [ 1. . n], from U + V by occurrence of w by (Pi: Wi). It is easily verified that for each object 0 E is an assignment ar such that cu( U) = 0 iff there is some i and some assignment ai such that ai( Ui) = 0; and in this case (u( V) = ai( Vi). It follows that, for each 0' E obj( P':(S)), . n]}, each rule is decomposed. Thus (i) holds. It is also clear that, for each 0' E obj( P':{ S}), rew(X + Y)( 0') = raw(A)( 0'). Thus (iij hoi&amp;. Since each Xi is decomposed, Lemma 3.7 implies that, for each i, there is a choice tree Si such that {Q! (Xi) 1 cu an assignment} n obj( S) E obj( Si).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>rew(U+ V)(O')=reW({Ui+ xliE[l..n]})(O').</head><p>Hence, (iii) also holds. The second sentence now follows easily from the definition of eflect of rewrite expressions. Cl Suppose in the above lemma that there is no explicit set construction in the term X, except possibly over the structure {+} for some J: It can be verified in this case that the choice trees of (iii) are distinct. At first glance, it appears in the above construction that, for each i, there is a choice tree Ti of T such that {ar ( Yi) 1 a an assignment} n obj( T) C_ obj( Ti). The following example illustrates that this need not be the case. On a given object 0 of type S, this rule yields R:{ If: 1) if there is an object of type A in 0, and yields R;{ } otherwise. This rule is decomposed, but there is no choice tree of T which contains {Q! ( Y) 1 a an assignment} n obj( T).</p><p>To conclude this section, we make two brief remarks on (1) the design of a general query language for objects, and (2) the omission of tokens in terms. 9 A calculus in the style of <ref type="bibr">[ 1,</ref><ref type="bibr">13,</ref><ref type="bibr">191</ref> can easily be designed for typed objects. An algebra in the spirit of [l] can be obtained by addin to the rewrite operations binary operations like union, intersection, difference, and cross product; and unary ones like powerset, and set collapse. 0 Some unexpected power comes from allowing the omission of tokens when they are implicit from the context. Consider the two types: where n is some positive integer. Then objects of type P can be rewritten into objects of type Q using the rule However, a precise expression of this transformation would require 2" different rules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Composition of simple rewrite operations</head><p>In this section, we introduce the "simple" rewrite operations. These operations will turn out to be central to our study of restructuring in the next two sections. We show that simple rewrite operations are closed under composition.</p><p>Speaking intuitively, the premise of an arbitrary rewrite rule acts as a filter, discriminating between objects which match the pattern of the premise and those that do not. In a simple rewrite expression, premises have very limited ability to discriminate between objects. Specifically, the most refined test that such premises can make is wneiher an object corresponds to a given choice tree or not. This intuition is realized formally by restricting the premises in a syntactic way, e.g., requiring that no repeated variables occur, and that no constants other than 1 occur.</p><p>It is convenient in this section to focus on individual rewrite rules, rather than rewrite expressions. Before providing a formal basis for this, we make a few intuitive remarks.</p><p>Suppose that X + Y is a rewrite rule from S to T (where S need not be a set type). Speaking intuitively, if 0 E obj( S) and a! is an assignment such that a!(X) = 0, then X + Y associates (u( Y) with 0. If X is arbitrary, there may be more than one a! such that a(X) = 0, in which case more than one value (Y( Y) is associated with 0. As we shall see, this never occurs for simple rewrite rules, and so each simple rewrite rule will define a (partial) single-valued function.</p><p>For technical reasons, it is convenient to include sgccial ru!es of the form X + a, where a indicates the undefined value. This is needed to ensure that simple rewrite rules are closed under composition. For example, consider the rule A: w + @(A: W) mapping A:doml to Q:(A:doml;B:dom,); and the rule @(By)+ B:y mapping Q:(A:dom,;B:dom,) to B:doml . Then, the composition of these two rules is A:w + a, which always yields the undefined value. Formally we have the following definition.</p><p>Definition. A (generalized) rewrite rule is defined as in Section 3, except that the following is added to part (i):</p><p>(i)(c) X + fl is a rule from S to T, for any type T; and each expression Y, Y,, . . . , Y, occurring in part (ii) of that definition is not permitted to be a.</p><p>At the level of rewrite expressions, rules + Sz do not affect results. ore specifically, we have the following definition.</p><p>Using this, we now have this proposition. It should be clear from the definition of rewrite expressions that their effect can be computed efficiently using parallelism. A consequence of the above proposition is that sequences of simple rewrite operations can also take full advantage of parallelism.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Equivalence preserving transformations</head><p>The last two sections of this paper focus on restructuring of types. In particular, natural local transformations on types preserving data capacity (Section 5), and augmenting it (Section 6) are introduced. A fundamental result in this section (Theorem 5.3) states that the equivalence preserving transformations are "complete" in a formal sense. In both sections, the semantics of transformations are expressed using "simple" rewrite expressions.</p><p>As noted in the introduction, data "relativism" refers to the phenomenon that two database schemas may hold essentially the same data. This arises in the important areas of user view definition, schema evolution, and schema translation. Previous work on data relativism <ref type="bibr">[2,</ref><ref type="bibr">5,</ref><ref type="bibr">8,</ref><ref type="bibr">9,</ref><ref type="bibr">10,</ref><ref type="bibr">12,</ref><ref type="bibr">161</ref> suggests that an intuitively appealing formalism for comparing the data capacity of two structures can be based on local structural manipulations. This is substantiated in particular by results in [ 121, which show that a family of six transformations and their inverses are "complete" for proving equivalence of information capacity between types for which all domains are infinite. The results of this section generalize these results to include finite domains, and relate them to the simple rewrite exprzJsions. The augmentations of the next section appear to provide a natural generalization for these transformations to increase the data capacity of types.</p><p>Before embarking on the formal development, we present a simple example which indicates how local manipulations might be applied in the context of database schema evolution. The example involves the two related types shown in Fig. <ref type="figure">8</ref>, which might be used to represent family units in some culture. Assume for a moment that in this culture, a family unit consists of either an adult female, or a married couple. (Unmarried adult males in this culture have no "legal" status.) The type shown in part (a) can represent family units under this assumption: objects of this type consist in either a female or an ordered pair, with first coordinate a female and second coordinate a male. Suppose now that a new law has been enacted within this culture, which allows women to take more than one husband. Then the type in part (b) can be used to represent family unit. It is clear in this case that existing data stored in the structure of (a) can be translated into the structure of (b). This raises the question of whether the type (a) can be transformed into the type (b) using a sequence of capacity preserving and augmenting manipulations. As shown in Fig. <ref type="figure" target="#fig_17">9</ref>, the answer to this question is affirmative. (Note that the first four transformations here preserve data capacity.) Furthermore, as implied by Theorem 6.3, the corresponding mapping on objects is realized by a single simple rewrite operation.</p><p>We now define nine structural transformations on types. As we shall see, these transformations preserve the data capacity of types. The transformatitins are presented in five groups; the first three of these are essentially trivial, while the latter two are more provocative. The transformations are first defined as they occur at the root of a type, and then generalized to permit their occurrence at an arbitrary node of a type. Three simple examples of these transformations are shown in Fig. <ref type="figure" target="#fig_22">10</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition. The capachy preserving transformations (cp-transformations) are as follows:5</head><p>Renaming cp-transforma tions :</p><p>(i) B: t is obtained from A: t by renaming.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Simple x cp-transforma tions :</head><p>(ii) replace (ix) replace P:(Q) by P:(l,;l,). Suppose now that S is a type with a node P and the type R below it., that R' is constructed from R using a cp-transformation, and that S' is constructed from S by replacing R by R" at P. Then S' is the result of applying a cp-transformation to S, written S+ S'. The reflexive, transitive closure of + is denoted by +*.</p><p>With each of these transformations, one can associate a one-one, onto function from objects to objects. 'The corresponding functions are called restructuring functions. The semantics of most restructuring functions should be obvious. For instance, m transformation (vi) maps an object P:[ 0, , Q;( R,: 0')] to the object P:(&amp;[ 0, , R3: 0'1); and 0 transformation (ix) maps the object P:{ } to P:(l,), and the object P:{IJ} to P:(P,).</p><p>Most of the restructuring functions are realized by one simple rewrite rule, as illustrated by parts (a) and (b) of the next example. In the cases of transformations (iv), (vi) and (ix), a family of simple rewrite rules is needed, as illustrated in part (c) of the example. In these cases, the family of rewrite rules is "consistent", in the sense that they operate on the domains of distinct choice trees. The straightforward proof of the following result is omitted.</p><p>Theorem 5.2. Let R and S be two set types such that R + S (respectively S+ R); then there is a simple rewrite operation p which is a bijection from dom( R) to dam(S).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Furthermore, p defines the same mapping as the restructuring function from R to S (respectively the inverse of S + R).</head><p>The next result of this section implies that the application of cp-transformations is essentially Church-Rosser, transforming each type into a "normal-form" type which is unique up to relabelling of nodes. For this, we need two definitions: the first defines the normal form for types; and the second allows us to "ignore" the internal names in types.</p><p>Definition. A type S is in normal form if:</p><p>(a) there is at most one +-node in S9 in which case the root is the +-node and it has more than one child; (b) lf is not a child of any *-node or x-node for any f; (c) no child of a x-node is a x-node; and (d) each x-node has more than one child. We now present two notions for comparing data capacity of database structures that were introduced in [ 121, namely absolute dominance and equivalence. We shall use these concepts to prove the "completeness" of our cp-transformations, thereby generalizing results of <ref type="bibr">[12]</ref> for formats.</p><p>Intuitively, absolute dominance roughly captures the intuition that natural database transformations should not "invent" data values. <ref type="bibr">(See [9]</ref> for more motivation.) To define this notion formally, we first define the "active domain" of objects.</p><p>Definition. If 0 is an object, the active domain of 0, denoted by act( 0), is the set of all atomic elements occurring in 0. Also, if T is a type and X is a set of atomic elements, then obj, ( T) denotes { 0 E obj( T) 1 act( 0) c X}. That is, obj, ( T) is the set of objects of type T built using atomic elements in X.</p><p>We now have the following definition.</p><p>Definition. Let S and T be types. Then S is dominated 'by T absolutely, denoted S b &lt; T (abs), if there is some k such that, for each finite set X satisfying6 IX n domil 2 k for each domi appearing in S or T, lo&amp; (S)l s (objx ( T)); and S is absolutely equiialent to T, denoted S -T (abs), if S G T (abs) and T s S (abs).</p><p>As a simple example, we note that P:[A:dom,, B:dom, 1s Q:(A:doml) (abs). We now present a characterization of absolute equivalence between types which demonstrates that 6 This condition is included to prevent certain combinatorial technicalities from having an impact.</p><p>(i) the collection of the nine cg-transformalions and their inverses is "complete" for absolute equivalence (Theorem 5.4), and (as a result) (ii) virtually any natural notion of equivalent data capacity is identical to it (Corollary 5.5). These generalize results in [ 121, and their proofs are sketched in Appendix C.</p><p>Theorem 5.4. Lef S, and S2 be two types. Then S1 -S, (abs) iff there is some normal form type T such that S, +* T and S, +* T.</p><p>It follows from Theorems 5.3 and 5.4 that simple rewrite operations are "complete" for absolute equivalence. Also, it is decidable whether two types are absolutely equivalent (although it appears that testing this is co-NP). Perhaps the most important implication of Theorem 5.4 is the following, which implies chat essentially all notions of capacity equivalence for types are identical to absolute equivalence. iffS-T(abs).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Structural dominance</head><p>In this section, we define "structural dominance", an intuitively appealing notion of dominance between types. This notion is based primarily on the transformations introduced in the previous section, together with three new transformations which augment data capacity. We prove that the new transformations also correspond to simple rewrite rules in a natural manner. We conclude (Theorem 6.2) that any finite sequence of transformations corresponds to a single simple rewrite operation.</p><p>To begin the formal development, we define the three data-augmenting transformations, here called "augmentations", and use them to define the general notion of structural dominance.</p><p>efinition. The three augmentations on types are defined as follows:</p><p>(x) replace P:( T,; . . . ; T,) by P:( T,; . . . ; T,;lJ for some 1,;</p><p>(xi) replace P:(l,; . . . ; 1,) by A;</p><p>(xii) replace P:(T;I&amp; by P:{ T}. For types S and T, w&amp;e S=+ T if one of the following holds:</p><p>(01) S+ T, or T+S, or @) T is the tree obtained from S by replacing a subtree S' of S by one augmentation of S'.</p><p>The relation ** is the reflexive, transitive closure of a. Finally, 0 S is structurally dominated by T, denoted S s T (struct), if S a* T; and 0 S is structurally equivalent to T, denoted S -T (struct), if S &lt; T (struct), and T s S (struct).</p><p>A straightforward application of Theorem 5.4 shows that, for each S and T, S-T (abs) iff S-T (struct).</p><p>With each of these transformations, one can associate an (augmenting) restructuring function. The semantics of these functions is now briefly presented:</p><p>(x) is the identity;</p><p>(xi) maps P:(li:l) to A:ai for each i in [ 1.</p><p>. n], and some distinct values al,. . . , a, in dam(A); and (xii) maps P:(O) to P:(O), and P:{lf:l) to P:{ }. We now state the easily verified rexuit that each restructuring function is realized by a simple rewrite expression. It remains open whether the converse of this result holds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion</head><p>In essentially ail database models, the same information can be organized in diBerent ways. This paper addresses some aspects of alternative data organizations using a hierarchical model based on constructors for tupies, sets and unions of types.</p><p>Our first contribution is the extension of theoretical results in [12] on data relativism. In particular, we extend thz structural transformations of [123 which preserve data capacity to one-element domains, and we introduce structural transformations which augment the data capacity of a structure. Such transformations may be provided to the database user or administrator intending to modify the database schema.</p><p>A second contribution is the presentation of rewrite operations to manipulate hierarchical objects. These operations provide a novel and powerful algebraic mechanism for filtering data, and simultaneously reorganizing the result of the filtering. A particular class of rewrite operations, called simple, is introduced to It now follows that the lemma is satisfied by setting 2 = R:rew(r)( w'). Cl</p><p>For the proof of Lemma A.3, we need the following easily verified result (proof omitted).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma AS. If X + Y from S to T is simple and decomposed, then there are choice trees S' and T' of S and T (respectively) such that 0 (a(X) 1 a! an assignment} n obj(S) = obj(S'); and 0 (a( Y) 1 a an assignment) n obj( T) E obj( T').</head><p>Proof t, c Lemma A.3. For this lemma, we are assuming that T is an arbitrary type with *-height S and X = Q:x is an arbitrary term (constructed from W) over T, but 2 = R:z is still assumed to be of basic type or a rewrite expression. To prove the re ,ult, we essentially perform an induction on the structure of X.</p><p>For the basis of this induction, we must consider the cases where (a) x is an unconstructed variable, (b) x is a constant of basic type, (c) X is a rewrite expression, and (d) X is a. In sase (a), since W+ X is decomposed, x is either of basic type or of set type other than {Is} for any J: If it is of basic type, then Lemma A.1 guarantees that there is an appropriate 2 If it is of set type, then T = Q:{ T'} for some type T' Z lf for any J This implies that y is a variable of set type. Letting 2 be the result of replacing all occurrences of y in 2 by Y now satisfies the lemma. Case (b) is handled by Lemma A.l, and case (c) is handled by Lemma A.2 Finally, if X =sZ, then setting 2 = fi satisfies the lemma.</p><p>Before embarking on the induction, we address the special case (which arises only if k = 1) where T is of type Q:{ lf) for some 1, We argue first that there is no rewrite expression occurring in X. (Following a line of reasoning similar to one in the proof of Lemma A.2, suppose that some rewrite expression appears in X, say rew(A')( w'). Since T is of type Q:{ I,-}, the right-hand side of rules in A' must be lp Since [ W + X] is simple, the left-hand side of rules in A' must also be of the form 1, by (iv) of the definition of simple. Thus w' has structure (l,}, which contradicts (b) of the definition of decomposed.) It follows that x is formed from the values { } and {lf}, combined usins zero or more applications of the w operation. Also, because [ Y + Z] is decomposed, Y = Q:{ } or Y = Q:{IJ}. We consider two cases. First, suppose that {lx} does not occur anywhere it X. If Y = Q:( }, then setting 2 = Z satisfies the lemma, and if Y = Q:{ lf} then 2 = a satisfies it. In the second case, { 1,) occurs somewhere in X. Then set 2 = 2 if Y = Q:{ $:l} and set 2=52 if Y=Q:{}.</p><p>Turning to the induction, we must now consider the cases where X is built using a product construction, a union of types construction, a set construction, or a set-union (u ) construction.</p><p>Suppose now that X = Q:[X,, Suppose now that T = Q:(T'} and that X = 0:(X,, . . . , Xn} for some n 3 Because we addressed the possibility T has type Q:{ } above, we assume here that T' is not of type Q:{lf) for any ecause Y+ Z is simple, this implies that y is an unconstructed set variable, and that Z is either constant (in which case set Suppose now that T is a type over domains doml, . . . , domk, that X is a set of atomic elements, and that xi = IX A domil for each i E [ 1. The significance of the characteristic functions is given by the following easily verified result.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma C.l. For types S and T, S -T (abs) z$crs = aT.</head><p>We now state the following proposition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition C.2. Let S and T be normalform types. The S is isomorphic to T i$cus = aT.</head><p>This proposition is proved after a series of four lemmas. The first three of these focus on the class of normal form types which have no +-node and which involve only one infinite domain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition.</head><p>Let doml be a fixed (infinite) domain. Then a type T is special if (i) T is in normal form;</p><p>(ii) T has no +-node; and (iii) The only infinite domain occurring in T is doml.</p><p>Note that if T is special, then the characteristic function of T can be viewed as a function over one variable.</p><p>The first lemma used in the proof of Proposition C.2 provides a basic description of the characteristic functions of special types. (The straightforward inductive proof is omitted.) Lemma C.3. Let T be a special type. If9 ht( T) = 0, then C+(X) = xm for sofne m a 0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>If h?(T) &gt; 0, then &amp;x)=xm</head><p>Xexp(q(x)+.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">l +(~~,(x))</head><p>for some n &gt; 0, some m 2 0, and some special types z with ht( q) &lt; ht( T) for each i E [ 1.</p><p>. n], and with ht( T,) = ht( T) -I.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 1. Two templates for a personal database.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Fig. 3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>efinition. For each type T, the set of objects of type T, denoted obj( T), is defined recursively by 0 for each attribute* A, obj(A:domi) = (Ax Ia in domi} and, for each index f, obj( $:{ 1)) = (lf: I}; 0 obj(P:[T;, . . . , T,]) =(P:[O,, . . . , On]lOiEobj(z) for each i in [l. .n]}; 0 obj( P:{ T'}) = { P:{O,, . . . , O,,} 1 Oi E obj( T') for each i in [ 1. . n]}; and 0 obj(P:(T,; . . . ; T,)) = { P:( Oj)I Oj E obj( ?;.) for some j in [ 1. . n]}. The set obj( T) is called the domain of T. If P: o is an object, then o is called the value of P:o (i.e., a value is an object deprived of its outermost token). To illustrate the previous two definitions, we now give examples of objects, and their corresponding types: (1) P:(B:13) and P:(R:[B:23, B':23]) are objects of type P:(B;R:[B, B']); (2) P:[Q,:(R:[B:13, B':7, B":105], R:[B:T, B':13, B":13]}, Qz:{ }] is an object of type P:[Q,:(R:[B, B', B"]}, Qg{S:[ C, C']}];</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>P:x, P:[Q1:y9 Q2:z], and P:[Q,:{R:u,, R:u2}, Q2:z] are terms of type P:[ Q1:{ R:[ B, B', B"] j, Q,:{S:[C, C']}].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Fig. 5.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>[</head><label></label><figDesc>last_name:x, first-name:y, ss#:z, sex:(female:[children: u, married:(maiden_name: u)])] + [last_name:x, maiden-name: v];</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>sex: (female: [ children: {child : u}, married: v])] + last_name:x. Omitting certain tokens, the same queries are [x, y, z, t] + [nom:x, prenom:y, ss#:z, sexe:w], [x, 'mary', 2, w] + 2, cx, x, 4 WI + C&amp; 4 5 WI, [x, y, z, ([u, (maiden_name:u)])] + [x, v],</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>(ii) (a) IfX+Y,,..., X + Yn are rules from S to T, , . . . , Tn respectively, then X+P:[Y,,..., Y,] is a rule from S to P:[ T, , . . . , T,], (b) ifX+YisarulefromSto 'T;,forsomeiin[l..n],thenX+P:(Y)is a rule from S to P:( T, ; . . . ; T,), (c) if X+ Y1,..., X + Yn are rules from S to T', then X + P:( YI , l = -9 K} is a rule from S to P:{ T'}, (d) if X+Yt,....; X -, Y, are rules from S to T and T is a set type, then x-, Y@ l l . ci Y, is a rule from S to T. A rewrite expression from S = P:(S) ts T= Q:{T'} is an ex ression of the form Q:rew( A ) where A is a nonempty set of rules from S' to T'.The previous definition enforces several restrictions on the form of rewrite expressions. For instance, consider the type S = P:[A:domi, B:(C:domi}]. Then the expression A:{ Cy} + E:y is not a rule from S since the left-hand does not correspond to S. Also, the expression rew(r, r'), where r= P:[A:x, By]+ E:x and r'= P:[A:x, B:y]+ E:y, is not a rewrite expression from S since the right-hand sides of the two rules conflict; one mapping to E :dom, , and the other to E :{ C:dom,}. Roughly speaking, a set of rules yields a rewrite expression if</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>(2) a( P:[X,, . . . 9 xnl) = p:b(m l l l 9 aLt~1, (3) (Y(P:(X)) = P:(Ly(X)), (4) a(P:{X,, . . . 9 Xl) = wwd, l l l 9 aL)l, (5)3 cY(X1 u l l ux,)=a(x,)u--ua(X,), (6) a(P:rew(A)(x))= P:{(Y(V)IU+ VGA, and aria}. Now we have the following definition. efinition. Let p = Q:rew(A) be a rewrite expression from the set-type S. We use p to denote the .vewb ite operation which maps each object 0 = P:o of type S to P(O)= Q:(PW)lf or some fl, and U + V in A, p( U) in 0). 7ilVe now present four examples of rewrite expressions. The first example illustrates th s use of several rules to obtain different treatment of alternative structures rest lting frzlrzn the union of types constructor. Example 3.3. Consider Form 1 and Form 2 of Section 2. lossless mapping from sets of forms 1 into sets of forms rewrite expression Form 2:rew({ rl, r2, r3}) where 13 It can be shown that a 2 is obtained using the r~ = Lx, Y, ~9 (MP:w)l + Lx, Y, 2, (MP: 4, (Lo), { I, (ld, (lma~e)], r2 = cx, Y, 29 (female:l&amp; (h)I)I + 1% y, 3 (hi?, (LO), v, UNA), (lf~Ina,e)], r3 = [x, y, z, (female:[ v, (maiden-name: u)])] + Ex, Y, 3 (1NA)r &amp;es), v, (24 hlakn The second example presents the utilization of union of rewrites. Example 3.4. Consider the following two types: pers: {R : [ emp, male-children: { name}, female-children: (name}]}, pers:{R:[emp, children:{child:[name, sex:{ lmale;lfemale)])]}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Pmale = child:rew(name: w + [name: w, sex:(l,,,,)]), Pfemaie = child:rew(name: w + [name: w, sex:(lf,ma,e)]), p = person:rew([emp:x, male_children:y, female_children:z] + [emp:x, children:pmale(Y) u Pfema~e(Z)l)-The third example presents the use of rewrite rules in a nested way. Example 3.5. Consider the following two types: company:{dept:[dname, pers:{R:[emp, male_children:{name}, female-children:{name}]}]), comp:{dept:[dname, pars:(R:[emp, children:{child:[name, sex:(lrnai,; which might be used to store, for each department, each employee along with his/her children, differentiated by sex. We now give a rewrite expression which maps objects of the first type into objects of the second in the natural manner. (The corresponding mapping is data preserving.) comp:rew([dname: u, pers: v] + [dname: u, pers:p( v)])</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>p = rew( [ x, y, x, (female: [ 2, v])] + [x, p"(z)]) and for p" = rew(child-name: w + I,), P' = rew(b, Ml + IX ~,I, 14 {II-) Cr W.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>Fig. 6. Frontier.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>Fig. 7. A choice tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>each rule Xi + Yi is decomposed; (ii) for each object 0' E obj( P':{ S}), Y is a rewrite rule from S to T, then of rewrite rules from S to T such that rew(X+ Y)(O')=reW((Xi+ YiliE[l. .]})(O'); and (iii) for each i E [ 1. . n], there is a choice tree Si of S such that4 (a(Xi) 1 a an assignment} n obj( S) c obj( Si 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>(a) Suppose w is a variable of structure [PI :sl, . . . , Pn:sn]. In thi an -.!nconstructed variable for i E [ 1. . n], and form U1 + VI from U -) all occurrences of w by [a, : wl, . . . f P,: w,,]. It is easily verified that 0 E obj(S), there is an assignment a! such that a( U) = 0 i8 there is cyl such that (Y*( U,) = 0; and in this case (u(V) = a,( VI). It follows Ok obj(P':{S}), rew( U + V)(O') = IfW( U, + V,)(O').</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>If w is of structure (Is} for some attribute l_,-, let w1 = ( } and w2 = { in part (b), Ui for i = I or 2 is constructed from Lr by replacing all occurr w by Wi. If w does not occur as the variable of a rewrite expression of V, then V1 and V2 can be constructed as in part (b). Suppose now that w does occur as the variable of the rewrite expression Q:rew(Z)( w), where % = {Xi + Yj Ii E [ 1. . m]}. Then Xi must be If:1 or lf:z for each j E [ 1. . k], and x is 3 constant or a term whose only variable is z for each j E [l . . m]. In this case, when replace Q:rew(Z)( w) by Q:{ }; and when constructing V2 replace Q:(Y;,..., Yk} where Vi is the result of replacing the var'%ble in It is easily verified that setting satisfies the conditions of the construction. It is clear from the construction that in the final family A = {Xi + yl: 1 i E [ 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Example 3. 9 .</head><label>9</label><figDesc>Let S= P:{Q:(A;B)} and T = R:{l,}, and consider the rewrite rule P:w+ R:rew(Q:fA:x)+ lf:l)(w).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head></head><label></label><figDesc>3 An-~,Anl; Q2U4, AZ,. . '3 An-, , &amp;I;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Proposition 4. 3 .</head><label>3</label><figDesc>Let pi be a simple rewrite operation from Ri to Ri+l for each i in [ 1. .n]. Then there exists a simple rewrite operation p such that p1 0 l l 9 0 p,, = p. Proof. Clearly it sufficies to show that there is a simple rewrite operation p such that pl op2 = p. Suppose now that p1 = Q:rew(A) maps P:(S) to Q:(T), and p2= R:rew(Z) maps Q:(T) to R:{ U}. It is easily verified that if the construction of the proof of the Decomposition Lemma is applied to a simple rewrite rule, then it yields a set of simple rewrite rules. Thus, without loss of generality we may assume that both A and C contain only decomposed, simple rewrite rules. Let A={Wi+XiliC[l..n]} and X={q+ZjIjE[l..m]}. By Lemma 4.2, there are expressions &amp; such that Wi + Zi,j is a simple rewrite rule and [ Wi + &amp;] s [Wi+Xi]O[Yj+q] for iE[l..n] andjE[l..m]. Let r={Wi~~i,iIiE[l..nJ,jE [ 1. . m] and 2i.j f a}. It easily follows that R:rew(r) is a simple rewrite expression from P:(S) to R:(U) such that R:rew(r) = (Q:rew(A)) 0 (R:rew(Z)).Cl</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>FigFig. 9 .</head><label>9</label><figDesc>Fig. 8. The polyandry example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head></head><label></label><figDesc>replace P:{( T, ; . . . ; T,)} by P:[ Q1:{ Tl}, . . . , Q,:{ T,}]. cp-transforma tions with 1: (viii) replace P:[T,, . . . , z-1, lf, 7&amp;, . . . , T*] by P:[ T,, . . . ,'K_*, r,+l,. . . , Tn];</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>Example 5. 1 .</head><label>1</label><figDesc>Consider the cp-transformation of Fig. 10. They are realized by the following rewrite rules. (a) [[x9 Yl, zl-* 1x9 Y, 21; (b) x + [pi(x), p*(x), p3(x)] where Qi is the root token of Ti for each i and p1 = rew((Q1: v) + 4, ~2 = rew((Q2: v) + 4, p3 = rew(( Q3: v) + v); and</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>Definition.</head><label></label><figDesc>Two normal-form types S and T are isomorphic (up to renaming), denoted S = T, if S can be transformed to T using only renamings. The next result states that the application of the cp-transformations is essentially Church-Rosser. (This generalizes results of [ 121; a proof is sketched in Appendix C.) Theorem 5.3. Let S be a type. Then there is a type T in normal form such that S +* T. Furthermore, if T, and T2 are normal form types such that S + * T, and S + * T2 ) then T, = T2. Also, if R is a type such that S +* R, then R +* T.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head></head><label></label><figDesc>Corollary 5.5. Let xxx-dominance be any reflexive, transitive binary relation on types such that (a) ifS+TorT+S, thenS~T(xxx),and (b) ifs&lt; T (xxx), then Ss T (abs); and let xxx-equivalence be defined from xxx-dominance in the natural manner. Then S-T(xxx)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head></head><label></label><figDesc>Theorem 6.1. Let R and S be two set types such that R 3s; then there is a simple one-to-one rewrite operation p from obj( R) to obj( S). Furthermore, p defines the same mapping as the restructuring function from R to S.Using Proposition 4.3, the next proposition follows. Tkorenn 6.2. Let R and S be two set types. If R G S (struct) (i.e., R ** S), then there exists a one-to-one simple rewrite expression p from R to S.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head>{lf}</head><label></label><figDesc>for any J and 2 is either of basic type or a rewrite expression, it follows that 2 is either a constant or a rewrite expression. In the former case, setting 2 = 2 satisfies the lemma. Now suppose that 2 is a rewrite expression. Then U = R:{ U'} for some U', and 2 = R:rew(S)(y) for some C = ( 5 + Zj 1 j E [ 1. . ml}. By the inductive assumption, for each i in [ 1. .n] and eachj in [ 1. . m], there is a variable &amp; such that [ Wi + 2id] = [ Wi + Xi] 0 [ yi + Zj]. Letting r={Wi+&amp;liE[l..n], j~[ll..m]and&amp;#R} it easily follows that [P': w'+ R:rew(T)( w')] s [P': w'+ Q:rew(A)( w')] 0 [ Q:y + R:rew(S)(y)].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head></head><label></label><figDesc>. . . , X,.,]whereX,=Qi:xiisoftypeTfori~[l..n]. ThusT=Q:iT,,..., Tn], and because [ Y + Z] is decomposed, Y = Q:[ Y1,. . . , Y,] for some terms Y = Qi:yi, i E [ 1. . n]. By assumption, either 2 = R:z where R is an attribute token and z is either a variable or a constant, or 2 = R:rew(C)(z') for some unconstructed set variable 9. If z is a constant, then define 2' = Rx. Otherwise, because Y + 2 is simple, if z (or z') occurs in Y, then it must occur in exactly one of the terms Yi. By the inductive assumption, because Xi is simpler than X, in this case, there is some 2' such that [ W+ 2'13 [ W + Xi] 0 [ Y;: + Z]. At first glance, it would seem that always holds. A subtlety here is that is is possible that [ W -+ Xi] 0 [ Yi + Z] yields a value on an object 0 in {ar ( W) 1 a an assignment} but that [ W + X] 0 [ Y + Z] does not. By Lemma AS, since each of the rules [ W + Xi] and [ q -p Z] is decomposed, Y$ ranges over the domain of a choice tree of 1;1, and Xj ranges over a subset of the domain of a choice tree of q. If there is an integer j E [ 1. l c] with j # i such that the choice trees of Xj and yi are different, then [ W + Xi] 0 [ k;-+ Z] = [ W + Cl], and more generally, [ W-, X] 0 [ Y + Z] = [ W-, iI]. Thus, we define 2 so that 2 = a if there is 8 ome j E [ 1. . n] with j # i such that the choice trees of Xi and 5 are different, and 2 = 2' otherwise. It is now easily verified that this choice of 2 satisfies the lemma. Suppose now that X = Q:(X') where X'= Q':x' is of type T'. This implies that T= Q:(T,; . . . ; T,) for some types T*, . . . , T, and z = Q': ti for some particular &amp;[l..n].Furthermore, Y=Q:(Y')where Y'isoftype qforsomej~[l..n].?flo cases arise, depending on whether i =j or not. If i = j, let 2 be chosen so that [ W+ 2]= [ W+ X'] 0 [ Y'+ 21; and if i #j, let 2 = Cl. This satisfies the lemma.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_28"><head></head><label></label><figDesc>(b) if T= lf for some 1, then Q-(X,, . . . , xk) = 1; (I-_&gt; if T=P:[T,,..., Tn], then &amp;x1 ,..., x~)=JJ'=~ a&amp; ,,..., xk); (d) if T = P:( T,; . . . ; T,), then cyT(xI, . . . , xk) =Cy=, q(x,, . . . , xk); (e) if* T= P:{T,}, then (Y&amp;, . . . , xk)=exp(a-r,(xl, @.. , q)).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_29"><head></head><label></label><figDesc>. k]. Then it is straightforward to show that lobjx (7')l = Q&amp;, . . . , q). Notation. If a! and p are functions from Nk to N, then Q! = p if there is some n suchthat cw(x,,...,x~)=~(x,,...,x~) wheneverx+n foreach i~[l..k].</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>Let P:o, and P:o, be two objects of type A:{ T}. The the union of P :ol and Ro, is defined in the obvious manner, i.e., P:o, u P:o, = P:(o, u 02).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>Abideboul, R.Hull   </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>If unconstructed variables were strictly typed, the condition would simply be {ti(Xi) 1 a an assign-ment} E Obj( Si).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_3"><p>' The result of a cp-transformation must be a type: in particular, siblings of a given node must have distinct tokens. We do not consider here this detail.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Work by this author supported in part by the Projet de Recherche CoordonnCe BD3. *** Work by this author supported in paft by the National Science Foundation Grant IST-83-26517, and IST-85-1154B. Part of this work was performed while he was visiting I.N.R.I.A.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Definition. Let p = Q:rew(A) from the set-type S, and 0 = P:o be an object of type S. Then the e&amp;c? of p on 0 is defined by dO)=Q:{B(V)lP an assignment, U + V in A, V # a, and p( U) in 0).</p><p>We now define the family of simple rewrite rules and expressions.</p><p>Definition. A simple rewrite rule is a rewrite rule X + Y (where Y may be a) such that (i) The only explicit set construction in the premise of any (possibly nested) rewrite rule is over a type of form P:{lf}; <ref type="bibr">(ii)</ref> No constants appear in the premise of any rewrite rule, except possibly 1; (iii) There are no repeated variables in the premise of any rewrite rule; and (iv) If U + lf : 1 occurs in a (possibly nested) rewrite rule for some lf, then U is of type l,q for some 1,. A rewrite expression p is simple if each rewrite rule occurring in p is simple.</p><p>Because sim;yle rewrite rules disallow nontrivial set construction in the premises, it is easily verified that the following lemma holds. if Y f 0 and there is some assignment a! such that a(X) = 0; and [X + Y]( 0) is undefined otherwise.</p><p>If two expressions f and g denote the same partial function (i.e., for each object 0 E obj(S), either both f( 0) and g( 0) are defined and f( 0) = g(O), or both are undefined), we say that f is equivalent to g, denoted f = g.</p><p>We now show that the family of simple rewrite operation is closed under composition. (Examples are given in Appendix B which show that each restriction in the definition of simple is needed in order to ensure that simple rules are composable.) To prove tire result, we use the following lemma which deals with the composition of decomposed, simple rewrite rules. Its proof is rather involved, and relegated to Appendix A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>If W+Xfrom .' J T and Y + Z from T to U are decomposed, simple rewrite rules, then there is a simple rewrite rule W + 2 such that [ W + 213 [w+X]Q[Y+Z].</head><p>focus on rewrite operations which filter exclusively on the structural characteristics of objects. A major result of the paper states that this class is closed under composition.</p><p>8ur last contribution is the exhibition of bridges between the local structural transformations, and the rewrite operations. Indeed, we prove that each transformation corresponds to a simple rewrite operation. This, together with the result on the composition of simple rewrite operations, guarantees that the effect of an arbitrary sequence of transformations can easily be computed using a single rewrite operation.</p><p>Some of the auxiliary concepts that are introduced in the paper also highlight essential aspects of the different constructors. In particular, the choice trees capture the various "shapes" which can be taken by objects of a given type. The notion of decomposed rules illustrates how the structure of an object affects the choice of a specified reorganization. Finally, the notion of normal form is a convenient tool for analysing the various alternative structures which have equivalent data capacity.</p><p>Several issues have yet to be explored:</p><p>(1)</p><p>(2)</p><p>(3)</p><p>implementation techniques taking advantages of the inherent parallelism of rewrite operations; extensions of the rewrite operations, and their integration in a general query language; the use of rewrite operations in the context of a richer data model (e.g., [ 141) allowing cycles ir, tire schema.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A</head><p>In this appendix, Lemma 4.2 is proved. The lemma is restated here for the reader's convenience.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lcnma 4.2. If W + X from S to T and Y + Z from T to U are decom_posed, simple rewrite rules, then there is a simple rewrite rule W + 2 such that [ W+ &amp;] = [W+X]o[Y+Z].</head><p>To prove Lemma 4.2, we perform an induction on the "*-height" of the type !C For the induction, we assume now that k 3 0 and state the following: Inductive Assumption: If W + X from S to T and Y + Z from T to U are decomposed, simple rewrite rules and ht( T) c k, then there is a decomposed simple rewrite rule W + 2 from S to U such that [</p><p>Note that if k = 0, then this is a vacuous assumption.</p><p>To advance the induction to types T whose * -height is k, we prove four lemmas. oughly speaking, the first three lernrnE$ perform an induction on the structure of </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>is of basic type or a rewrite expression; and (c) X is a rewrite expression. Then there is a rewrite rule W+ Z such that [ W+ &amp;] = [ W-, X] 0 [ Y + Z].</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma A.3. Suppose that W + X from S to T and Y + Zfrom T to U are decomposed, simple rewrite rules sur:h that (a) ht( T) = k; (b) Z is of basic type or a rewrite expression. Then there is a rewrite rule W+ Z such that [ W + Z] = [ W-p X) 0 [ Y + Z]. Lemma A.4 Suppose that W + X from S to T and Y -) Z from T to U are decomposed, simple rewrite rules such that (a) ht( T) = k; Then thereisarewriterule W&amp;such that [W+Z]=[W+X]o[Y+Z].</head><p>In . n] and j E [ 1.</p><p>. m], and Zi,j # a} satisfies the lemma. Finally, suppose that X = X, u l 9 l v X,,. As in the previous paragraph, 2 is either constant or a rewrite expression. If 2 is a constant, set 2 = Z Otherwise, 2 = R:rew(Z)(y) for some C. By the inductive assumption, there are variables $ such that</p><p>for ie[l.</p><p>.n].</p><p>It is now straightforward to verify that 2 = &amp; u 9 l l u 2' satisfies the conditions of the lemma. Cl roof of Lemma A.4. We now assume that T has *-height S that X is arbitrary, and that 2 is arbitrary. We prove the lemma by inducting on the structure of Z For the basis, we must consider cases where 2 is a basic constant, a basic type variable, a rewrite expression, or 0. The first three of these are taken care of by Lemma A.3, and the last is satisfied by setting 2 = a.</p><p>Referring to the definition of rewrite expression, we must now consider the cases where 2 is built using a product construction, a union-of-types construction, a set construction, or a set-union (u) construction. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Then[W+X]o[Y+Z](O) is 5fined only if 0 contains the object P':(A: aO) (and an arbitrary number of objects of type P':(B)). As above, it can be shown that there is no rule I@&amp; such that [k&amp;]=[W+X]o[Y+Z].</head><p>Also, there is no finite set A such that rew(A) = rew( W + X) 0 rew( Y + 2).</p><p>In this example, the set constant Q:{A:aO} is used. If simple rewrite rules were permitted to have constants of basic types in premises, then this family would still be closed under composition. However, there are cases where the composition of and no finite set A such that rew(A) = rew( W + X j 3 rew( Y + 2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix</head><p>In this appendix, proofs for Theorems 5.3 and 5.4 are presented. These are straightforward generalizations of results of <ref type="bibr">[12]</ref> to incorporate the one-element domains (lf) introduced in the present paper. For this reason, only sketches of the proofs are provided here Before demonstrating Theorems 5.3 and 5.4, certain functions on the natural numbers called "characteristic functions" are associated to types. In particular, fioposition C.2 below states that the characteristic functions of two normal-form types are (essentially) equal iff the two types are isomorphic. The characteristic functions are defined as follows.</p><p>efinition. Let T be a type, and let dom 1 9 . . . , domk be a listing of (infinite) domains which includes all (infinite) domains occurring in T. The characteristic function of T (relative to the listing doml, . . . , domk) is the function' aT : Nk + N defined recursively by (a) if T= P:domi, then (Y&amp;1,. . . , xk) = Xi;</p><p>' Here N denotes the set of natural numbers.</p><p>To compare characteristic functions of special types we use the following notation.</p><p>Notation. If (Y and p are functions from N to N, then Q! &lt; p if there is some n such that a(x)&lt;P(x) for each xan.</p><p>Using Lemma C.3, it is easily verified that the following lemma holds. for some I &gt; 0, some k 3 0, and some special types Si with ht(Si) G ht&lt;S) for each i E [ 1. We can now prove Theorems 5.3 and 5.4.</p><p>Proof of Theorem 5.3. Let S be a type. Note that if a type is not in normal form, then a cp-transformation can be applied to it. From this and Proposition C.7, it follows that there is a normal form T such that S +* T Suppose now that T, and T2 are normal-form types such that S +* T, and S a* T2. Then '1;: -S-T2 (abs). By Lemma C.l and Proposition C.2, it follows that T1 is isomorphic to T2 as desired. Finally, suppose that S +* R. Let T' be a normal form type such that R +* T'. Then S +* T', and so T and T' are isomorphic. Thus, T' +* T by renaming cp-transformations, and by transitivity, R +* T as desired. Cl  </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">On the power of languages for complex objects, abstract presented at the Internat. Workshop on l%eory and Applications of Nested Relations and Complex Objects</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Beeri</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="56" to="60" />
			<pubPlace>Darmstadt, Germany</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Non first normal form relations: an algebra allowing data restructuring</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Bidoit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. System. Sci</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="361" to="393" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">IFO: a formal semantic database model</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TODS</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="525" to="565" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Restructuring of complex objects and office forms, in: plot</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Internat. ConjI on Database</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="54" to="72" />
			<date type="published" when="1986">1986. 1986</date>
			<publisher>Springer</publisher>
			<pubPlace>Rome; Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Inclusion and equivalence between relational database schemata</title>
		<author>
			<persName><forename type="first">P</forename><surname>Atzeni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ausiello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Batini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Moscarini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="267" to="285" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A calculus for complex objects</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bancilhon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Khoshafian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. PODS</title>
		<meeting>PODS<address><addrLine>Boston</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="53" to="59" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Operators for non-first-normal-form relations</title>
		<author>
			<persName><forename type="first">P</forename><surname>Fisher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Thomas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">hoc. 7th Internat. Computer Software and Applications Cot&amp; Chicago</title>
		<imprint>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="464" to="475" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Data description with SDM: a semantic database model</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hammer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mcleod</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TODS</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="357" to="386" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Relative information capacity of simple relational database schemata</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput. lS</title>
		<imprint>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="856" to="886" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">A survey of theoretical research in typed complex database objects</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
		<editor>J. Paredaens, ed., Database</editor>
		<imprint>
			<date type="published" when="1987">1987</date>
			<publisher>Academic Press</publisher>
			<biblScope unit="page" from="193" to="256" />
			<pubPlace>London</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>King</surname></persName>
		</author>
		<title level="m">Semantic database modelling: survey, applications, and research issues</title>
		<imprint>
			<publisher>USC Tech. Rept</publisher>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The format model: a theory of database organization</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">K</forename><surname>Yap</surname></persName>
		</author>
		<author>
			<persName><forename type="first">;</forename><forename type="middle">B</forename><surname>Jacobs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="310" to="332" />
			<date type="published" when="1982">1984. 1982</date>
		</imprint>
	</monogr>
	<note>A ACM</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">The logical data model: a new approach to database logic</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Kuper</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
		</imprint>
		<respStmt>
			<orgName>Stanford University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A new approach to database logic</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Kuper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. PODS</title>
		<meeting>PODS</meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="86" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Motro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<title level="m">Constructing superviews, SIGMOD</title>
		<imprint>
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Designing a generalized NF2 model with SQL-type interface</title>
		<author>
			<persName><forename type="first">P</forename><surname>Pistor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Andersen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">fioc. Internat. Con$ on VLDB</title>
		<meeting><address><addrLine>Kyoto, Japan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="278" to="288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The design of Star&apos;s records processing: data processing for the noncomputer professional</title>
		<author>
			<persName><forename type="first">R</forename><surname>Purvy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Farrell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Klose</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Ofice Automation Systems I</title>
		<imprint>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="24" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Theory of non-first-normal-form relational databases, Internal rept</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">F</forename><surname>Korth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Silberschatz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
		</imprint>
		<respStmt>
			<orgName>Austin University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Data structures for an integrated data base management and information retrieval system</title>
		<author>
			<persName><forename type="first">H-J</forename><surname>Scheck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pistor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conf on VLDB</title>
		<editor>
			<persName><surname>Pr~c</surname></persName>
		</editor>
		<editor>
			<persName><surname>Internat</surname></persName>
		</editor>
		<meeting><address><addrLine>Mexico</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="197" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Database abstractions: aggregations and generalization</title>
		<author>
			<persName><forename type="first">J</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TODS</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="105" to="133" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Specification of forms prczessing and business procedures for office automation</title>
		<author>
			<persName><surname>Nc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">Y</forename><surname>Shu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">C</forename><surname>Lum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Tung</surname></persName>
		</author>
		<author>
			<persName><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Engng. SE</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="499" to="512" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Form management</title>
		<author>
			<persName><forename type="first">D</forename><surname>Tsichritzis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="453" to="478" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
