<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Randomized Dynamic Program Analysis Technique for Detecting Real Deadlocks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Pallavi</forename><surname>Joshi</surname></persName>
							<email>pallavi@cs.berkeley.edu</email>
							<affiliation key="aff0">
								<orgName type="department">EECS Department</orgName>
								<address>
									<settlement>Berkeley</settlement>
									<region>UC</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Chang-Seo</forename><surname>Park</surname></persName>
							<email>parkcs@cs.berkeley.edu</email>
							<affiliation key="aff0">
								<orgName type="department">EECS Department</orgName>
								<address>
									<settlement>Berkeley</settlement>
									<region>UC</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Koushik</forename><surname>Sen</surname></persName>
							<email>ksen@cs.berkeley.edu</email>
							<affiliation key="aff0">
								<orgName type="department">EECS Department</orgName>
								<address>
									<settlement>Berkeley</settlement>
									<region>UC</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mayur</forename><surname>Naik</surname></persName>
							<email>mayur.naik@intel.com</email>
							<affiliation key="aff1">
								<orgName type="institution">Intel Research</orgName>
								<address>
									<settlement>Berkeley</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Randomized Dynamic Program Analysis Technique for Detecting Real Deadlocks</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">55F4121CFB1DBE0DD94499EA36A5D97E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.2.5 [Software Engineering]: Testing and Debugging; D.2.4 [Software Engineering]: Software/Program Verification General Terms Languages</term>
					<term>Reliability</term>
					<term>Verification deadlock detection</term>
					<term>dynamic program analysis</term>
					<term>concurrency</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present a novel dynamic analysis technique that finds real deadlocks in multi-threaded programs. Our technique runs in two stages. In the first stage, we use an imprecise dynamic analysis technique to find potential deadlocks in a multi-threaded program by observing an execution of the program. In the second stage, we control a random thread scheduler to create the potential deadlocks with high probability. Unlike other dynamic analysis techniques, our approach has the advantage that it does not give any false warnings. We have implemented the technique in a prototype tool for Java, and have experimented on a number of large multi-threaded Java programs. We report a number of previously known and unknown real deadlocks that were found in these benchmarks.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>A common cause for unresponsiveness in software systems is a deadlock situation. In shared-memory multi-threaded systems, a deadlock is a liveness failure that happens when a set of threads blocks forever because each thread in the set is waiting to acquire a lock held by another thread in the set. Deadlock is a common form of bug in today's software-Sun's bug database at http://bugs.sun.com/ shows that 6,500 bug reports out of 198,000 contain the keyword 'deadlock'. There are a few reasons for the existence of deadlock bugs in multi-threaded programs. First, software systems are often written by many programmers; therefore, it becomes difficult to follow a lock order discipline that could avoid deadlock. Second, programmers often introduce deadlocks when they fix race conditions by adding new locks. Third, software systems can allow incorporation of third-party software (e.g. plugins); third-party software may not follow the locking dis-cipline followed by the parent software and this sometimes results in deadlock bugs <ref type="bibr" target="#b17">[17]</ref>.</p><p>Deadlocks are often difficult to find during the testing phase because they happen under very specific thread schedules. Coming up with these subtle thread schedules through stress testing or random testing is often difficult. Model checking <ref type="bibr" target="#b15">[15,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b6">6]</ref> removes these limitations of testing by systematically exploring all thread schedules. However, model checking fails to scale for large multi-threaded programs due to the exponential increase in the number of thread schedules with execution length.</p><p>Several program analysis techniques, both static <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b2">2,</ref><ref type="bibr" target="#b9">9,</ref><ref type="bibr" target="#b27">27,</ref><ref type="bibr" target="#b29">29,</ref><ref type="bibr" target="#b21">21]</ref> and dynamic <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b4">4,</ref><ref type="bibr" target="#b1">1]</ref>, have been developed to detect and predict deadlocks in multi-threaded programs. Static techniques often give no false negatives, but they often report many false positives. For example, the static deadlock detector developed by Williams et al. <ref type="bibr" target="#b29">[29]</ref> reports 100,000 deadlocks in Sun's JDK 1.4 <ref type="foot" target="#foot_0">1</ref> , out of which only 7 are real deadlocks. Type and annotation based techniques <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b10">10]</ref> help to avoid deadlocks during coding, but they impose the burden of annotation on programmers. Predictive dynamic techniques such as Goodlock <ref type="bibr" target="#b13">[13]</ref> and its improvements <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b1">1]</ref> give both false negatives and false positives. For example, in our experiments we have found that an improved Goodlock can report as many as 254 false positives for our Jigsaw web server. Being imprecise in nature, most of these tools require manual inspection to see if a deadlock is real or not. Nevertheless, these techniques are effective in finding deadlocks because they can predict deadlocks that could potentially happen during a real executionfor such a prediction, static analyses do not need to see an actual execution and dynamic analyses need to see only one multi-threaded execution.</p><p>Dynamic analysis based deadlock detection can be made precise by taking the happens-before relation <ref type="bibr" target="#b18">[18]</ref> into account. However, it has several problems. First, it reduces the predictive power of dynamic techniques-it fails to report deadlocks that could happen in a significantly different thread schedule. Second, it can perturb an execution significantly and can fail to report a deadlock that can happen when no dynamic analysis is performed.</p><p>We propose a new dynamic technique for detecting real deadlocks in multi-threaded programs, called DEADLOCKFUZZER, which combines an imprecise dynamic deadlock detection technique with a randomized thread scheduler to create real deadlocks with high probability. The technique works in two phases. In the first phase, we use an informative and a simple variant of the Goodlock algorithm, called informative Goodlock, or simply iGoodlock, to discover potential deadlock cycles in a multithreaded program. For example, iGoodlock could report a cycle of the form (t1, l1, l2, [c1, c2])(t2, l2, l1, [c 1 , c 2 ]), which says that there could be a deadlock if thread t1 tries to acquire lock l2 at program location c2 after acquiring lock l1 at program location c1 and thread t2 tries to acquire lock l1 at program location c 2 after acquiring lock l2 at program location c 1 . In the second phase, DEADLOCKFUZZER executes the program with a random schedule in order to create a real deadlock corresponding to a cycle reported in the previous phase. For example, consider the cycle (t1, l1, l2, [c1, c2])(t2, l2, l1, [c 1 , c 2 ]) again. At each program state, the random scheduler picks a thread and executes its next statement with the following exception. If t1 is about to acquire lock l2 at location c2 after acquiring lock l1 at location c1, then the random scheduler pauses the execution of thread t1. Similarly, the random scheduler pauses the execution of thread t2 if it is about to acquire lock l1 at location c 2 after acquiring lock l2 at location c 1 . In this biased random schedule, it is very likely that both the threads will reach a state where t1 is trying to acquire l2 while holding l1 and t2 is trying to acquire l1 while holding l2. This results in a real deadlock. In summary, DEADLOCKFUZZER actively controls a randomized thread scheduler based on a potential deadlock cycle reported by an imprecise deadlock detection technique.</p><p>The above technique poses the following key challenge. Phase II assumes that Phase I can provide it with precise knowledge about the thread and lock objects involved in the deadlock cycle. Unfortunately, since thread and lock objects are created dynamically at runtime, their addresses cannot be used to identify them across executions, i.e. in the above example, addresses of t1, t2, l1, l2 do not remain the same between Phase I and Phase II executions. Therefore, we need some mechanism to identify the same objects across executions. Specifically, we need a form of object abstraction such that if two dynamic objects in different executions are the same, they must have the same abstraction. For example, the label of a statement at which an object is created can be used as its abstraction. Such an abstraction of an object does not change across executions. However, an abstraction could be the same for several objects (e.g. if both l1 and l2 in the above example are created by the same statement). In this paper, we propose two techniques for computing the abstraction of an object that helps us to distinguish between different objects more precisely-the first technique is motivated by the notion of k-object-sensitivity in static analysis <ref type="bibr" target="#b20">[20]</ref> and the second technique is motivated by the notion of execution indexing <ref type="bibr" target="#b30">[30]</ref>. We show that both these abstractions are better than the trivial abstraction where all objects have the same abstraction. We also empirically show that the abstraction based on execution indexing is better than the abstraction based on k-object-sensitivity in most benchmarks.</p><p>We have implemented DEADLOCKFUZZER for multi-threaded Java programs in a prototype tool. We have applied the tool to a large number of benchmarks having a total of over 600K lines of code. The results of our experiments show that DEAD-LOCKFUZZER can create real deadlocks with high probability and DEADLOCKFUZZER can detect all previously known real deadlocks.</p><p>We make the following contributions in this paper. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Algorithm</head><p>The DEADLOCKFUZZER algorithm consists of two phases. In the first phase, we execute a multi-threaded program and find potential deadlocks that could happen in some execution of the program. This phase uses a modified Goodlock algorithm, called informative Goodlock, or simply iGoodlock, which identifies potential deadlocks even if the observed execution does not deadlock. We call the modified algorithm informative because we provide suitable debugging information to identify the cause of the deadlock-this debugging information is used by the second phase to create real deadlocks with high probability. A limitation of iGoodlock is that it can give false positives because it does not consider the happensbefore relation between the transitions in an execution. As a result the user is required to manually inspect such potential deadlocks.</p><p>The second phase removes this burden from the user. In this phase, a random thread scheduler is biased to generate an execution that creates a real deadlock reported in the previous phase with high probability. We next describe these two phases in more detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Background Definitions</head><p>We use a general and simple model of a concurrent system to describe our dynamic deadlock checking algorithm. We consider a concurrent system to be composed of a finite set of threads. Each thread executes a sequence of labeled statements. A thread communicates with other threads using shared objects. At any point during program execution, a concurrent system is in a state.</p><p>Let s0 be the initial state. A concurrent system evolves from one state to another state when a thread executes a statement. In our algorithms, we will consider the following dynamic instances of labeled program statements:</p><p>1. c : Acquire(l), denoting the acquire of the dynamic lock object l. c is the label of the statement (same for below).</p><p>2. c : Release(l), denoting the release of the dynamic lock object l.</p><p>3. c : Call(m), denoting a call to the method m.</p><p>4. c : Return(m), denoting the return from the method m.</p><p>5. c : o =new (o , T ), where the statement occurs in the body of a method m and when the this argument of m evaluates to object o , then o is the dynamic object of type T allocated by the statement.</p><p>In several languages including Java, locks are re-entrant, i.e., a thread may re-acquire a lock it already holds. In our algorithm, we ignore the execution of c : Acquire(l) or c : Release(l) statements by a thread t, if t re-acquires the lock l or does not release the lock l, respectively<ref type="foot" target="#foot_1">2</ref> . To simplify exposition, we also assume that locks are acquired and released in a nested way, i.e., if a thread acquires l2 after acquiring l1, then it has to release l2 before releasing l1. Our algorithm can easily be extended to handle languages where locks can be acquired and released in an arbitrary order.</p><p>Next we introduce some definitions that we will use to describe our algorithms. Given a multi-threaded execution σ, let Lσ be the set of lock objects that were held by any thread in the execution and Tσ be the set of threads executed in the execution. Let C be the set of all statement labels in the multi-threaded program. We next define the lock dependency relation of a multi-threaded execution as follows. <ref type="figure">L,</ref><ref type="figure">l,</ref><ref type="figure">C</ref>) ∈ Dσ iff in the execution σ, in some state, thread t acquires lock l while holding the locks in the set L, and C is the sequence of labels of Acquire statements that were executed by t to acquire the locks in L ∪ {l}. DEFINITION 2. Given a lock dependency relation D, a lock dependency chain τ = (t1, L1, l1, C1), . . . , (tm, Lm, lm, Cm) is a sequence in D * such that the following properties hold. Note that the definition of a potential deadlock cycle never uses any of the Ci's in Dσ to compute a potential deadlock cycle. Each Ci of a potential deadlock cycle provides us with information about program locations where the locks involved in the cycle were acquired. This is useful for debugging and is also used by the active random deadlock checker to determine the program locations where it needs to pause a thread.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DEFINITION 1. Given an execution σ, a lock dependency relation</head><formula xml:id="formula_0">Dσ of σ is a subset of Tσ × 2 Lσ × Lσ × C * such that (t,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">for all distinct</head><formula xml:id="formula_1">i, j ∈ [1, m], ti = tj , i.e.</formula><p>Each lock and thread object involved in a potential deadlock cycle is identified by its unique id, which is typically the address of the object. The unique id of an object, being based on dynamic information, can change from execution to execution. Therefore, the unique id of an object cannot be used by the active random checker to identify a thread or a lock object across executions. In order to overcome this limitation, we compute an abstraction of each object. An abstraction of an object identifies an object by static program information. For example, the label of a statement at which an object is created could be used as its abstraction. We describe two better (i.e. more precise) object abstraction computation techniques in Section 2.4. In this section, we assume that abs(o) returns some abstraction of the object o.</p><p>Given a potential deadlock cycle (t1, L1, l1, C1), . . . , (tm, Lm, lm, Cm) , iGoodlock reports the abstract deadlock cycle (abs(t1), abs(l1), C1), . . . , (abs(tm), abs(lm), Cm) . The active random checker takes such an abstract deadlock cycle and biases a random scheduler so that a real deadlock corresponding to the cycle gets created with high probability.</p><p>We next describe iGoodlock. Specifically, we describe how we compute the lock dependency relation during a multi-threaded execution and how we compute all potential deadlock cycles given a lock dependency relation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Computing the lock dependency relation of a multi-threaded execution</head><p>In order to compute the lock dependency relation during a multithreaded execution, we instrument the program to maintain the following three data structures:</p><p>• LockSet that maps each thread to a stack of locks held by the thread • Context that maps each thread to a stack of the labels of statements where the thread acquired the currently held locks • D is the lock dependence relation We update the above three data structures during a multi-threaded execution as follows: </p><formula xml:id="formula_2">push c to Context[t] add (t,LockSet[t], l, Context[t]) to D push l to LockSet[t] • If thread t executes the statement c : Release(l) pop from Context[t] pop from LockSet[t]</formula><p>At the end of the execution, we output D as the lock dependency relation of the execution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">Computing potential deadlock cycles iteratively</head><p>Let D k denote the set of all lock dependency chains of D that has length k. Therefore, D 1 = D. iGoodlock computes potential deadlock cycles by iteratively computing D 2 , D 3 , D 4 , . . . and finding deadlock cycles in those sets. The iterative algorithm for computing potential deadlock cycles is described in Algorithm 1. end for 14:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 iGoodlock(D)</head><formula xml:id="formula_3">1: INPUTS: lock dependency relation D 2: i ⇐ 1 3: D i ⇐ D 4: while D i = ∅ do 5: for each (t, L, l, C) ∈ D</formula><p>i ⇐ i + 1 15: end while Note that in iGoodlock(D) we do not add a lock dependency chain to D i+1 if it is a deadlock cycle. This ensures that we do not report complex deadlock cycles, i.e. deadlock cycles that can be decomposed into simpler cycles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.3">Avoiding duplicate deadlock cycles</head><p>In Algorithm 1, a deadlock cycle of length k gets reported k times. For example, if (t1, L1, l1, C1), (t2, L2, l2, C2), . . . , (tm, Lm, lm, Cm) is reported as a deadlock cycle, then (t2, L2, l2, C2), . . . , (tm, Lm, lm, Cm), (t1, L1, l1, C1) is also reported as a cycle. In order to avoid such duplicates, we put another constraint in Definition 2: the unique id of thread t1 must be less than the unique id of threads t2, . . . , tm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Phase II: The Active Random Deadlock Checking Algorithm</head><p>DEADLOCKFUZZER executes a multi-threaded program using a random scheduler. A simple randomized execution algorithm is shown in Algorithm 2. Starting from the initial state s0, this algorithm, at every state, randomly picks an enabled thread and executes its next statement. The algorithm terminates when the system reaches a state that has no enabled threads. At termination, if there is at least one thread that is alive, the algorithm reports a system stall. A stall could happen due to a resource deadlock (i.e. deadlocks that happen due to locks) or a communication deadlock (i.e. a deadlock that happens when each thread is waiting for a signal from some other thread in the set). We only consider resource deadlocks in this paper.</p><p>A key limitation of this simple random scheduling algorithm is that it may not create real deadlocks very often. DEADLOCK-FUZZER biases the random scheduler so that potential deadlock cycles reported by iGoodlock get created with high probability. The active random deadlock checking algorithm is shown in Algorithm 3. Specifically, the algorithm takes an initial state s0 and Algorithm 2 simpleRandomChecker(s0) At the end of each iteration, it may happen that the set Paused is equal to the set of all enabled threads. This results in a state where DEADLOCKFUZZER has unfortunately paused all the enabled threads and the system cannot make any progress. We call this thrashing. DEADLOCKFUZZER handles this situation by removing a random thread from the set Paused. A thrash implies that DEADLOCKFUZZER has paused a thread in an unsuitable state. DEADLOCKFUZZER should avoid thrashing as much as possible in order to guarantee better performance and improve the probability of detecting real deadlocks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Computing object abstractions</head><p>A key requirement of DEADLOCKFUZZER is that it should know where a thread needs to be paused, i.e. it needs to know if a thread t that is trying to acquire a lock l in a context C could lead to a deadlock. DEADLOCKFUZZER gets this information from iGoodlock, but this requires us to identify the lock and thread objects that are the "same" in the iGoodlock and DEADLOCKFUZZER executions. This kind of correlation cannot be done using the address (i.e. the unique id) of an object because object addresses change across executions. Therefore, we propose to use object abstraction-if two objects are same across executions, then they have the same abstraction. We assume abs(o) computes the abstraction of an object.</p><p>There could be several ways to compute the abstraction of an object. One could use the label of the statement that allocated the object (i.e. the allocation site) as its abstraction. However, that would be too coarse-grained to distinctly identify many objects. For example, if one uses the factory pattern to allocate all thread objects, then all of the threads will have the same abstraction. Therefore, we need more contextual information about an allocation site to identify objects at finer granularity.</p><p>Note that if we use a coarse-grained abstraction, then DEAD-LOCKFUZZER will pause unnecessary threads before they try to acquire some unnecessary locks. This is because all these unnecessary threads and unnecessary locks might have the same abstraction as the relevant thread and lock, respectively. This will in turn reduce the effectiveness of our algorithm as DEADLOCKFUZZER will more often remove a thread from the Paused set due to the unavailability of any enabled thread. Note that we call this situation thrashing. Our experiments (see <ref type="bibr">Section 5)</ref> show that if we use the trivial abstraction, where all objects have the same abstraction, then we get a lot of thrashing. This in turn reduces the probability of creating a real deadlock. On the other hand, if we consider too fine-grained abstraction for objects, then we will not be able to tolerate minor differences between two executions, causing threads to pause at fewer locations and miss deadlocks. We next describe two abstraction techniques for objects that we have found effective in our experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.1">Abstraction based on k-object-sensitivity</head><p>Given a multi-threaded execution and a k &gt; 0, let o1, . . . o k be the sequence of objects such that for all i ∈ [1, k-1], oi is allocated by some method of object oi+1. We define abs O k (o1) as the sequence c1, . . . , c k where ci is the label of the statement that allocated oi. abs O k (o1) can then be used as an abstraction of o1. We call this abstraction based on k-object-sensitivity because of the similarity to k-object-sensitive static analysis <ref type="bibr" target="#b20">[20]</ref>.</p><p>In order to compute abs O k (o) for each object o during a multithreaded execution, we instrument the program to maintain a map CreationMap that maps each object o to a pair (o , c) if o is created by a method of object o at the statement labeled c. This gives the following straightforward runtime algorithm for computing CreationMap. One can use CreationMap to compute abs O k (o) using the following recursive definition:</p><formula xml:id="formula_4">abs O k (o) = if k = 0 or CreationMap[o] = ⊥ abs O k+1 (o) = c :: abs O k (o ) if CreationMap[o] = (o , c</formula><p>) When an object is allocated inside a static method, it will not have a mapping in CreationMap. Consequently, abs O k (o) may have fewer than k elements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.2">Abstraction based on light-weight execution indexing</head><p>Given a multi-threaded execution, a k &gt; 0, and an object o, let mn, mn-1, . . . , m1 be the call stack when o is created, i.e. o is created inside method m1 and for all i ∈ [1, n -1], mi is called from method mi+1. Let us also assume that ci+1 is the label of the statement at which mi+1 invokes mi and qi+1 is the number of times mi is invoked by mi+1 in the context mn, mn-1, . . . , mi+1. Then abs I k (o) is defined as the sequence [c1, q1, c2, q2, . . . , c k , q k ], where c1 is the label of the statement at which o is created and q1 is the number of times the statement is executed in the context mn, mn-1, . . . , m1. The idea of computing this kind of abstraction is similar to the idea of execution indexing proposed in <ref type="bibr" target="#b30">[30]</ref>, except that we ignore branch statements and loops. This makes our indexing light-weight, but less precise.</p><p>In order to compute abs I k (o) for each object o during a multithreaded execution, we instrument the program to maintain a thread-local scalar d to track its depths and two thread-local maps CallStack and Counters. We use CallStackt to denote the CallStack map of thread t. The above data structures are updated at runtime as follows. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Examples Illustrating DEADLOCKFUZZER</head><p>Consider the multi-threaded Java program in Figure <ref type="figure">1</ref>. The program defines a MyThread class that has two locks l1 and l2 and a boolean flag. The run method of MyThread invokes a number of long running methods f1, f2, f3, f4 if flag is true and then it acquires locks l1 and l2 in order. The body of run shows a common pattern, where a thread runs several statements and then acquires several locks in a nested way. The main method creates two lock objects o1 and o2. It also creates two threads (i.e. instances of MyThread). In the first instance l1 and l2 are set to o1 and o2, respectively, and flag is set to true. Therefore, a call to start on this instance will create a new thread which will first execute several long running methods and then acquire o1 and o2 in order. A call to start on the second instance of MyThread will create a new thread which will acquire o2 and o1 in order. We have commented out lines 24 and 27, because they are not relevant for the current example-we will uncomment them in the next example.</p><p>The example has a deadlock because the locks o1 and o2 are acquired in different orders by the two threads. However, this deadlock will rarely occur during normal testing because the second thread will acquire o2 and o1 immediately after start, whereas the first thread will acquire o1 and o2 after executing the four long running methods. iGoodlock will report this deadlock as a potential one by observing a single execution that does not deadlock. If we use the abstraction in Section 2.4.2 with, say k = 10, the report will be as follows: <ref type="bibr" target="#b23">[23,</ref><ref type="bibr" target="#b1">1]</ref>, <ref type="bibr" target="#b15">[15,</ref><ref type="bibr" target="#b16">16]</ref>), ( <ref type="bibr" target="#b26">[26,</ref><ref type="bibr" target="#b1">1]</ref>, <ref type="bibr" target="#b22">[22,</ref><ref type="bibr" target="#b1">1]</ref>, <ref type="bibr" target="#b15">[15,</ref><ref type="bibr" target="#b16">16]</ref>) </p><formula xml:id="formula_5">([25, 1],</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 1. Simple Example of a Deadlock</head><p>where <ref type="bibr" target="#b25">[25,</ref><ref type="bibr" target="#b1">1]</ref>, <ref type="bibr" target="#b26">[26,</ref><ref type="bibr" target="#b1">1]</ref>, <ref type="bibr" target="#b22">[22,</ref><ref type="bibr" target="#b1">1]</ref>, <ref type="bibr" target="#b23">[23,</ref><ref type="bibr" target="#b1">1]</ref> are the abstractions of the first thread, the second thread, o1, and o2, respectively. <ref type="bibr" target="#b15">[15,</ref><ref type="bibr" target="#b16">16]</ref> denotes the context in which the second lock is acquired by each thread.</p><p>The active random deadlock checker will take this report and create the real deadlock with probability 1. Specifically, it will pause both the threads before they try to acquire a lock at line 16.</p><p>The above example shows that DEADLOCKFUZZER can create a rare deadlock with high probability. In practice, the actual probability may not be 1-DEADLOCKFUZZER can miss a deadlock because the execution could simply take a different path due to nondeterminism and that path may not exhibit a deadlock. However, in our experiments we have found that the probability of creating a deadlock is high on our benchmarks.</p><p>The above example does not show the utility of using thread and object abstractions. To illustrate the utility of object and thread abstractions, we uncomment the lines at 24 and 27. Now we create a third lock o3 and a third thread which acquires o2 and o3 in order. iGoodlock as before will report the same deadlock cycle as in the previous example. In DEADLOCKFUZZER, if we do not use thread and object abstractions, then with probability 0.5 (approx), the third thread will pause before acquiring the lock at line 16. This is because, without any knowledge about threads and objects involved in a potential deadlock cycle, DEADLOCKFUZZER will pause any thread that reaches line 16. Therefore, if the third thread pauses before line 16, then the second thread will not be able to acquire lock o2 at line 15 and it will be blocked. DEADLOCKFUZZER will eventually pause the first thread at line 16. At this point two threads are paused and one thread is blocked. This results in a thrashing (see Section 2.3). To get rid of this stall, DEADLOCKFUZZER will "un-pause" the first thread with probability 0.5 and we will miss the deadlock with probability 0.25 (approx). On the other hand, if we use object and thread abstractions, then DEADLOCKFUZZER will never pause the third thread at line 16 and it will create the real deadlock with probability 1. This illustrates that if we do not use thread and object abstractions, then we get more thrashings and the probability of creating a real deadlock gets reduced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Optimization: avoiding another potential cause for thrashing</head><p>We showed that using object and thread abstractions helps reduce thrashing; this in turn helps increase the probability of creating a deadlock. We show another key reason for a lot of thrashings using the following example and propose a solution to partly avoid such thrashings. The above code avoids explicit thread creation for simplicity of exposition. iGoodlock will report a potential deadlock cycle in this code. In the active random deadlock checking phase, if thread1 is paused first (at line 3) and if thread2 has just started, then thread2 will get blocked at line 9 because thread1 is holding the lock l1 and it has been paused and thread2 cannot acquire the lock. Since we have one paused and one blocked thread, we get a thrashing. DEADLOCKFUZZER will "un-pause" thread1 and we will miss the real deadlock. This is a common form of thrashing that we have observed in our benchmarks.</p><p>In order to reduce the above pattern of thrashing, we make a thread to yield to other threads before it starts entering a deadlock cycle. Formally, if (abs(t), abs(l), C) is a component of a potential deadlock cycle, then DEADLOCKFUZZER will make any thread t with abs(t) = abs(t ) yield before a statement labeled c where c is the bottommost element in the stack C. For example, in the above code, DEADLOCKFUZZER will make thread1 yield before it tries to acquire lock l1 at line 2. This will enable thread2 to make progress (i.e. acquire and release l1 at lines 9 and 11, respectively). thread2 will then yield to any other thread before acquiring lock l2 at line 12. Therefore, the real deadlock will get created with probability 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Implementation and Evaluation</head><p>DEADLOCKFUZZER can be implemented for any language that supports threads and shared memory programming, such as Java or C/C++ with pthreads. We have implemented DEADLOCKFUZZER for Java by instrumenting Java bytecode to observe various events and to control the thread scheduler. The implementation is a part of the CALFUZZER framework <ref type="bibr" target="#b16">[16]</ref>. DEADLOCKFUZZER can go into livelocks. Livelocks happen when all threads of the program end up in the Paused set, except for one thread that does something in a loop without synchronizing with other threads. In order to avoid livelocks, DEADLOCKFUZZER creates a monitor thread that periodically removes those threads from the Paused set that are paused for a long time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experimental setup</head><p>We evaluated DEADLOCKFUZZER on a variety of Java programs and libraries. We ran our experiments on a dual socket Intel Xeon 2GHz quad core server with 8GB of RAM. The following programs were included in our benchmarks: cache4j, a fast thread-safe implementation of a cache for Java objects; sor, a successive overrelaxation benchmark, and hedc, a web-crawler application, both from ETH <ref type="bibr" target="#b28">[28]</ref>; jspider, a highly configurable and customizable Web Spider engine; and Jigsaw, W3C's leading-edge Web server platform. We created a test harness for Jigsaw that concurrently generates simultaneous requests to the web server, simulating multiple clients, and administrative commands (such as "shutdown server") to exercise the multi-threaded server in a highly concurrent situation.</p><p>The libraries we experimented on include synchronized lists and maps from the Java Collections Framework, Java logging facilities (java.util.logging), and the Swing GUI framework (javax.swing). Another widely used library included in our benchmarks is the Database Connection Pool (DBCP) component of the Apache Commons project. Each of these libraries contains potential deadlocks that we were able to reproduce using DEAD-LOCKFUZZER. We created general test harnesses to use these libraries with multiple threads. For example, to test the Java Collections in a concurrent setting, we used the synchronized wrappers in java.util.Collections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Results</head><p>Table <ref type="table" target="#tab_7">1</ref> shows the results of our analysis. The second column reports the number of lines of source code that was instrumented. If the program uses libraries that are also instrumented, they are included in the count. The third column shows the average runtime of a normal execution of the program without any instrumentation or analysis. The fourth column is the runtime of iGoodlock (Phase I). The fifth column is the average runtime of DEADLOCKFUZZER (Phase II). The table shows that the overhead of our active checker is within a factor of six, even for large programs. Note that runtime for the web server Jigsaw is not reported due to its interactive nature.</p><p>The sixth column is the number of potential deadlocks reported by iGoodlock. The seventh column is the number of cycles that correspond to real deadlocks after manual inspection. For Jigsaw, since DEADLOCKFUZZER could reproduce 29 deadlocks, we can say for sure that Jigsaw has 29 or more real deadlocks. With the exception of Jigsaw, iGoodlock was precise enough to report only real deadlocks. The eighth column is the number of deadlock cycles confirmed by DEADLOCKFUZZER. The ninth column is the empirical probability of DEADLOCKFUZZER reproducing the deadlock cycle. We ran DEADLOCKFUZZER 100 times for each cycle and calculated the fraction of executions that deadlocked using DEAD-LOCKFUZZER. Our experiments show that DEADLOCKFUZZER reproduces the potential deadlock cycles reported by iGoodlock with very high probability. We observed that for some Collections benchmarks, DEADLOCKFUZZER reported a low probability of 0.5 for creating a deadlock. After looking into the report, we found that in the executions where DEADLOCKFUZZER reported no deadlock, DEADLOCKFUZZER created a deadlock which was different from the potential deadlock cycle provided as input to DEADLOCK-FUZZER. For comparison, we also ran each of the programs normally without instrumentation for 100 times to observe if these deadlocks could occur under normal testing. None of the runs resulted in a deadlock, as opposed to a run with DEADLOCKFUZZER which almost always went into deadlock. Column 10 shows the average number of thrashings per run. Columns 9 and 10 show that the probability of creating a deadlock decreases as the number of thrashings increases.</p><p>We conducted additional experiments to evaluate the effectiveness of various design decisions for DEADLOCKFUZZER. We tried variants of DEADLOCKFUZZER: 1) with abstraction based on kobject-sensitivity, 2) with abstraction based on light-weight execution indexing, 3) with the trivial abstraction, 4) without context information, and 5) with the optimization in Section 4 turned off. Figure <ref type="figure" target="#fig_4">2</ref> summarizes the results of our experiments. Note that the   <ref type="table" target="#tab_7">1</ref> correspond to the variant 2, where we use the light-weight execution indexing abstraction, context information, and the optimization in Section 4. We found this variant to be the best performer: it created deadlocks with higher probability than any other variant and it ran efficiently with minimal number of thrashings.</p><p>The first graph shows the correlation between the various variants of DEADLOCKFUZZER and average runtime. The second graph shows the probability of creating a deadlock by the variants of DEADLOCKFUZZER. The third graph shows the average number of thrashings encountered by each variant of DEADLOCK-FUZZER. The fourth graph shows the correlation between the number of thrashings and the probability of creating a deadlock.</p><p>The first graph shows that variant 2, which uses execution indexing, performs better than variant 1, which uses k-object-sensitivity. The second graph shows that the probability of creating a dead-lock is maximum for variant 2 on our benchmarks. The difference is significant for the Logging and DBCP benchmarks. Ignoring abstraction entirely (i.e. variant 3) led to a lot of thrashing in Collections and decreased the probability of creating a deadlock. The third graph on the Swing benchmark shows that variant 2 has minimum thrashing. Ignoring context information increased the thrashing and the runtime overhead for the Swing benchmark. In the Swing benchmark, the same locks are acquired and released many times at many different program locations during the execution. Hence, ignoring the context of lock acquires and releases leads to a huge amount of thrashing.</p><p>The first graph which plots average runtime for each variant shows some anomaly. It shows that variant 3 runs faster than variant 2 for Collections-this should not be true given that variant 3 thrashes more than variant 2. We found the following reason for this anomaly. Without the right debugging information provided by iGoodlock, it is possible for DEADLOCKFUZZER to pause at wrong locations but, by chance, introduce a real deadlock which is unrelated to the deadlock cycle it was trying to reproduce. This causes the anomaly in the first graph where the runtime overhead for Collections is lower when abstraction is ignored, but the number of thrashings is more. The runtime is measured as the time it takes from the start of the execution to either normal termination or when a deadlock is found. DEADLOCKFUZZER with our lightweight execution indexing abstraction faithfully reproduces the given cycle, which may happen late in the execution. For more imprecise variants such as the one ignoring abstraction, a deadlock early in the execution may be reproduced wrongfully, thus reducing the runtime.</p><p>The fourth graph shows that the probability of creating a deadlock goes down as the number of thrashings increases. This validates our claim that thrashings are not good for creating deadlocks with high probability and our variant 2 tries to reduce such thrashings significantly by considering context information and object abstraction based on execution indexing, and by applying the optimization in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Deadlocks found</head><p>DEADLOCKFUZZER found a number of previously unknown and known deadlocks in our benchmarks. We next describe some of them.</p><p>Two previously unknown deadlocks were found in Jigsaw. As shown in Figure <ref type="figure">3</ref>, when the http server shuts down, it calls cleanup code that shuts down the SocketClientFactory. The shutdown code holds a lock on the factory at line 867, and in turn attempts to acquire the lock on csList at line 872. On the other hand, when a SocketClient is closing, it also calls into the factory to update a global count. In this situation, the locks are held in the opposite order: the lock on csList is acquired first at line 623, and then on the factory at line 574. Another similar deadlock occurs when a SocketClient kills an idle connection. These also involve the same locks, but are acquired at different program locations. iGoodlock provided precise debugging information to distinguish between the two contexts of the lock acquires.</p><p>The deadlock in the Java Swing benchmark occurs when a program synchronizes on a JFrame object, and invokes the setCaretPosition() method on a JTextArea object that is a member of the JFrame object. The sequence of lock acquires that leads to the deadlock is as follows. The main thread obtains a lock on the JFrame object, and an EventQueue thread which is also running, obtains a lock on a BasicTextUI$BasicCaret object at line number 1304 in javax/swing/text/DefaultCaret.java. The main thread then tries to obtain a lock on the BasicTextUI$BasicCaret object at line number 1244 in javax/swing/text/DefaultCaret.java, Figure <ref type="figure">3</ref>. Deadlock in Jigsaw but fails to do so since the lock has not been released by the EventQueue thread. The EventQueue thread tries to acquire the lock on the JFrame object at line number 407 in javax/swing/RepaintManager.java but cannot since it is still held by the main thread. The program goes into a deadlock. This deadlock corresponds to a bug that has been reported at http://bugs.sun.com/view bug.do?bug id=4839713.</p><p>One of the deadlocks that we found in the DBCP benchmark occurs when a thread tries to create a PreparedStatement, and another thread simultaneously closes another PreparedStatement. The sequence of lock acquires that exhibits this deadlock is as follows. The deadlocks in the Java Collections Framework happen when multiple threads are operating on shared collection objects wrapped with the synchronizedX classes. For example, in the synchronizedList classes, the deadlock can happen if one thread executes l1.addAll(l2) concurrently with another thread executing l2.retainAll(l1). There are three methods, addAll(), removeAll(), and retainAll() that obtain locks on both l1 and l2 for a total of 9 combinations of deadlock cycles. The synchronizedMap classes have 4 combinations with the methods equals() and get().</p><p>The test cases for Java Collections are artificial in the sense that the deadlocks in those benchmarks arise due to inappropriate use of the API methods. We used these benchmarks because they have been used by researchers in previous work (e.g. Williams et al. <ref type="bibr" target="#b29">[29]</ref> and Jula et al. <ref type="bibr" target="#b17">[17]</ref>), and we wanted to validate our tool against these benchmarks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Imprecision in Goodlock</head><p>Since DEADLOCKFUZZER is not complete, if it does not classify a deadlock reported by iGoodlock as a real deadlock, we cannot definitely say that the deadlock is a false warning. For example, in the Jigsaw benchmark, the informative Goodlock algorithm reported 283 deadlocks. Of these 29 were reported as real deadlocks by DEADLOCKFUZZER. We manually looked into the rest of the deadlocks to see if they were false warnings by iGoodlock, or real deadlocks that were not caught by DEADLOCKFUZZER. For 18 of the cycles reported, we can say with a high confidence that they are false warnings reported by the iGoodlock algorithm. These cycles involve locks that are acquired at the same program statements, but by different threads. There is a single reason why all of these deadlocks are false positives. The deadlocks can occur only if a CachedThread invokes its waitForRunner() method before that CachedThread has been started by another thread. This is clearly not possible in an actual execution of Jigsaw. Since iGoodlock does not take the happens-before relation between lock acquires and releases into account, it reports these spurious deadlocks. For the rest of the cycles reported by iGoodlock, we cannot say with reasonable confidence if they are false warnings, or if they are real deadlocks that were missed by DEADLOCKFUZZER.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Related Work</head><p>We have already compared our proposed technique with several existing techniques for detecting deadlocks in multi-threaded programs. In this section, we discuss several other related approaches, and elaborate on some that we have previously mentioned.</p><p>DEADLOCKFUZZER is part of the active testing framework [16] that we have earlier developed for finding real races <ref type="bibr" target="#b25">[25]</ref> and real atomicity violations <ref type="bibr" target="#b23">[23]</ref>. We proposed RACEFUZZER <ref type="bibr" target="#b25">[25]</ref> which uses an active randomized scheduler to confirm race conditions with high probability. RACEFUZZER only uses statement locations to identify races and does not use object abstraction or context information to increase the probability of race detection. As shown in Section 5.2, simple location information is not good enough for creating real deadlocks with high probability.</p><p>Recently, several random testing techniques have been proposed <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b26">26]</ref> that introduce noise (using yield, sleep, wait (with timeout)) to a program execution to increase the possibility of the exhibition of a synchronization bug. Although these techniques have successfully detected bugs in many programs, they have a limitation. These techniques are not systematic as the primitives sleep(), yield(), priority() can only advise the scheduler to make a thread switch, but cannot force a thread switch. As such they cannot pause a thread as long as required to create a real deadlock.</p><p>More recently, a few techniques have been proposed to confirm potential bugs in concurrent programs using random testing. Havelund et al. <ref type="bibr" target="#b3">[3]</ref> uses a directed scheduler to confirm that a potential deadlock cycle could lead to a real deadlock. However, they assume that the thread and object identifiers do not change across executions. Similarly, ConTest <ref type="bibr" target="#b22">[22]</ref> uses the idea of introducing noise to increase the probability of the occurrence of a deadlock. It records potential deadlocks using a Goodlock algorithm. To check whether a potential deadlock can actually occur, it introduces noise during program execution to increase the probability of exhibition of the deadlock. Our work differs from ConTest in the following ways. ConTest uses only locations in the program to identify locks. We use context information and object abstractions to identify the run-time threads and locks involved in the deadlocks; therefore, our abstractions give more precise information about run-time objects. Moreover, we explicitly control the thread scheduler to create the potential deadlocks, instead of adding timing noise to program ex-ecution. DEADLOCKFUZZER, being explicit in controlling scheduler and in identifying objects across executions, found real deadlocks in large benchmarks with high probability.</p><p>A couple of techniques have been proposed to prevent deadlocks from happening during program execution, and to recover from deadlocks during execution. When a buggy program executes and deadlocks, Dimmunix <ref type="bibr" target="#b17">[17]</ref> records the deadlock pattern. During program execution, it tries to prevent the occurrence of any of the deadlock patterns that it has previously observed. Rx <ref type="bibr" target="#b24">[24]</ref> proposes to recover programs from software failures, including deadlocks, by rolling them back to a recent checkpoint, and re-executing the programs in a modified environment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion</head><p>Existing techniques for deadlock detection, based on static and dynamic analysis, could predict potential deadlocks, but could not verify if they were real deadlocks. Going through all of these warnings and reasoning about them manually could be time consuming. DEADLOCKFUZZER automates such verification-if a real deadlock is created by DEADLOCKFUZZER, the developer no longer needs to verify the deadlock manually. However, DEADLOCK-FUZZER is incomplete-if a deadlock is not confirmed to be real by DEADLOCKFUZZER, the developer cannot ignore the deadlock. Nevertheless, DEADLOCKFUZZER has managed to find all previously known deadlocks in large benchmarks and it has discovered previously unknown deadlocks. We believe that DEADLOCK-FUZZER is an indispensable and practical tool that complements both static and predictive dynamic analysis.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>•</head><label></label><figDesc>Initialization: for all t, both LockSet[t] and Context[t] map to an empty stack D is an empty set • If thread t executes the statement c : Acquire(l)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>•</head><label></label><figDesc>If a thread t executes the statement c : o = new (o , T ), then add o → (o , c) to CreationMap.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>For example in the above code, if o is the first object created by the execution of main, then abs I 3 (o) is the sequence [11, 1, 6, 1, 3, 1]. Similarly, if o is the last object created by the execution of main, then abs I 3 (o) is the sequence [11, 3, 7, 1, 3, 5].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>•</head><label></label><figDesc>Initialization: for all t, dt ⇐ 0 for all t and c,Counterst[dt][c] ⇐ 0 • If a thread t executes the statement c : Call(m) Counterst[dt][c] ⇐ Counterst[dt][c] + 1 push c to CallStackt push Counterst[dt][c] to CallStackt dt ⇐ dt + 1 for all c, Counterst[dt][c] ⇐ 0 • If a thread t executes the statement c : Return(m) dt ⇐ dt -1 pop twice from CallStackt • If a thread t executes the statement c : o =new(o , T ) Counterst[dt][c] ⇐ Counterst[dt][c] + 1 push c to CallStackt push Counterst[dt][c] to CallStackt abs I k (o)is the top 2k elements of CallStackt pop twice from CallStackt Note that abs I k (o) has 2k elements, but if the call stack has fewer elements, then abs I k (o) returns the full call stack.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Performance and effectiveness of variations of DEADLOCKFUZZER</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Our key contribution is an active random deadlock detecting scheduler that can create real deadlocks with high probability (we show this claim empirically) based on information provided by iGoodlock. This phase prevents us from reporting any false positives and creates real deadlocks which are useful for debugging. This relieves the manual inspection burden associated with other imprecise techniques such as Goodlock.• We propose two kinds of object abstraction techniques that help us correlate thread and lock objects between iGoodlock and the randomized scheduling algorithm.• We have implemented DEADLOCKFUZZER in a tool for Java and have discovered subtle previously known and unknown deadlocks in large applications. To the best of our knowledge, DEADLOCKFUZZER is the first precise dynamic deadlock analysis tool for Java that has been applied to large Java applications.</figDesc><table /><note><p>• We propose a simple and informative variant of the Goodlock algorithm, called iGoodlock. Unlike existing Goodlock algorithms [13, 4, 1], iGoodlock does not use lock graphs or depthfirst search, but reports the same deadlocks as the existing algorithms. Due to this modification, iGoodlock uses more memory, but reduces runtime complexity. We also attach context information with each cycle that helps in debugging and in biasing the random scheduler. iGoodlock is iterative in nature-it finds all cycles of length k before finding any cycle of length k + 1. Our experiments show that all real deadlocks in our benchmarks have length two. Therefore, if we have a limited time budget, we can run iGoodlock for one iteration so that it only reports deadlock cycles of length 2. •</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Li+1, i.e. each thread could potentially wait to acquire a lock that is held by the next thread, 4. for all distinct i, j ∈ [1, m], Li ∩ Lj = ∅, i.e., each thread ti should be able to acquire the locks in Li without waiting.</figDesc><table /><note><p>the threads t1, t2, . . . , tm are all distinct objects, 2. for all distinct i, j ∈ [1, m], li = lj , i.e. the lock objects l1, l2, . . . , lm are distinct, 3. for all i ∈ [1, m -1], li ∈ DEFINITION 3. A lock dependency chain τ = (t1, L1, l1, C1), . . . , (tm, Lm, lm, Cm) is a potential deadlock cycle if lm ∈ L1.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Cycle as inputs. It then executes the multi-threaded program using the simple random scheduler, except that it performs some extra work when it encounters a lock acquire or lock release statement. If a thread t is about to acquire a lock l in the context C, then if (abs(t), abs(l), C) is present in Cycle, the scheduler pauses thread t before t acquires lock l, giving a chance to another thread, which is involved in the potential deadlock cycle, to acquire lock l subsequently. This ensures that the system creates the potential deadlock cycle Cycle with high probability. LockSet mapping each thread to its current stack of locks 2: if there exist distinct t 1 , t 2 , . . . , tm and l 1 , l 2 , . . . , lm such that lm appears before l 1 in LockSet[tm] and for eachi ∈ [1, m -1], l i appears before l i+1 in LockSet[t i ] thenAlgorithm 3 maintains three data structures: LockSet that maps each thread to a stack of locks that are currently held by the thread, Context that maps each thread to a stack of statement labels where the thread has acquired the currently held locks, and Paused which is a set of threads that has been paused by DEADLOCKFUZZER. Paused is initialized to an empty set, and LockSet and Context are initialized to map each thread to an empty stack.DEADLOCKFUZZER runs in a loop until there is no enabled thread. At termination, DEADLOCKFUZZER reports a system stall if there is at least one active thread in the execution. Note that DEADLOCKFUZZER only catches resource deadlocks. In each iteration of the loop, DEADLOCKFUZZER picks a random thread t that is enabled but not in the Paused set. If the next statement to be executed by t is not a lock acquire or release, t executes the statement and updates the state as in the simple random scheduling algorithm (seeAlgorithm 2). If the next statement to be executed by t is c :Acquire(l), cand l are pushed to Context[t] and LockSet[t], respectively. DEADLOCKFUZZER then checks if the acquire of l by t could lead to a deadlock using checkRealDeadlock in Algorithm 4. checkRealDeadlock goes over the current lock set of each thread and sees if it can find a cycle. If a cycle is discovered, then DEADLOCKFUZZER has created a real deadlock. If there is no cycle, then DEADLOCKFUZZER determines if t needs to be paused in order to get into a deadlock state. Specifically, it checks if (abs(t), abs(l), Context[t]) is present in Cycle. If t is added to Paused, then we pop from both LockSet[t] and Context[t] to reflect the fact that t has not really acquired the lock l. If the next statement to be executed by t is c : Release(l), then we pop from both LockSet[t] and Context[t].</figDesc><table><row><cell cols="2">1: INPUTS: the initial state s 0</cell></row><row><cell cols="2">2: s ⇐ s 0</cell></row><row><cell cols="2">3: while Enabled(s) = ∅ do</cell></row><row><cell>4:</cell><cell>t ⇐ a random thread in Enabled(s)</cell></row><row><cell>5:</cell><cell>s ⇐ Execute(s, t)</cell></row><row><cell cols="2">6: end while</cell></row><row><cell cols="2">7: if Alive(s) = ∅ then</cell></row><row><cell>8:</cell><cell>print 'System Stall!'</cell></row><row><cell cols="2">9: end if</cell></row><row><cell cols="2">a potential deadlock cycle Algorithm 3 DEADLOCKFUZ Z E R(s0 ,Cycle)</cell></row><row><cell></cell><cell>∈ Cycle) then</cell></row><row><cell>13:</cell><cell>s ⇐ Execute(s,t)</cell></row><row><cell>14:</cell><cell>else</cell></row><row><cell>15:</cell><cell>pop from LockSet[t]</cell></row><row><cell>16:</cell><cell>pop from Context[t]</cell></row><row><cell>17:</cell><cell>add t to Paused</cell></row><row><cell>18:</cell><cell>end if</cell></row><row><cell>19:</cell><cell>else if Stmt = c : Release(l) then</cell></row><row><cell>20:</cell><cell>pop from LockSet[t]</cell></row><row><cell>21:</cell><cell>pop from Context[t]</cell></row><row><cell>22:</cell><cell>s ⇐ Execute(s,t)</cell></row><row><cell>23:</cell><cell>else</cell></row><row><cell>24:</cell><cell>s ⇐ Execute(s,t)</cell></row><row><cell>25:</cell><cell>end if</cell></row><row><cell>26:</cell><cell>if |Paused| = |Enabled(s)| then</cell></row><row><cell>27:</cell><cell>remove a random thread from Paused</cell></row><row><cell>28:</cell><cell>end if</cell></row><row><cell cols="2">29: end while</cell></row><row><cell cols="2">30: if Active(s) = ∅ then</cell></row><row><cell>31:</cell><cell>print 'System Stall!'</cell></row><row><cell cols="2">32: end if</cell></row><row><cell cols="2">Algorithm 4 checkRealDeadlock(LockSet)</cell></row><row><cell>3:</cell><cell>print 'Real Deadlock Found!'</cell></row><row><cell cols="2">4: end if</cell></row></table><note><p>1: INPUTS: the initial state s 0 , a potential deadlock cycle Cycle 2: s ⇐ s 0 3: Paused ⇐ ∅ 4: LockSet and Context map each thread to an empty stack 5: while Enabled(s) = ∅ do 6: t ⇐ a random thread in Enabled(s)\ Paused 7: Stmt ⇐ next statement to be executed by t 8: if Stmt = c : Acquire(l) then 9: push l to LockSet[t] 10: push c to Context[t] 11: checkRealDeadlock(LockSet) // see Algorithm 4 12: if (( abs(t), abs(l), Context[t] ) / 1: INPUTS:</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 1 .</head><label>1</label><figDesc>Experimental results. (Context + 2nd Abstraction + Yield optimization)</figDesc><table><row><cell></cell><cell cols="4">Runtime (Normalized to uninstrumented run)</cell><cell></cell><cell></cell><cell cols="6">Probability of reproducing deadlock</cell></row><row><cell>100</cell><cell cols="2">Context + 1st Abstraction</cell><cell></cell><cell></cell><cell>1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="2">Context + 2nd Abstraction</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>50</cell><cell cols="2">Ignore Abstraction Ignore Context No Yields</cell><cell></cell><cell></cell><cell>0.8</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0.6</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>15</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>10</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0.4</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>5</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0.2</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>0</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>Collections</cell><cell>Logging</cell><cell>DBCP</cell><cell>Swing</cell><cell></cell><cell cols="2">Collections</cell><cell></cell><cell>Logging</cell><cell></cell><cell>DBCP</cell><cell>Swing</cell></row><row><cell></cell><cell></cell><cell cols="2">Avg. thrashing per run</cell><cell></cell><cell></cell><cell></cell><cell cols="6">Correlation between thrashing and probability.</cell></row><row><cell>600</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Probability</cell></row><row><cell>4 6 8 10 500</cell><cell></cell><cell></cell><cell></cell><cell>Probability of reproducing deadlock</cell><cell>0.2 0.4 0.6 0.8</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>2</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>0</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0</cell><cell>2</cell><cell>4</cell><cell>6</cell><cell>8</cell><cell>10</cell><cell>12</cell><cell>14</cell><cell>16</cell><cell>18</cell><cell>20</cell></row><row><cell></cell><cell>Collections</cell><cell>Logging</cell><cell>DBCP</cell><cell>Swing</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3"># of thrashings</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>The first thread obtains a lock on a Connection object at line number 185 in org/apache/commons/dbcp/DelegatingConnection.java. The second thread obtains a lock on a KeyedObjectPool object at line number 78 in org/apache/commons/dbcp/PoolablePrepared-Statement.java. The first thread then tries to obtain a lock on the same KeyedObjectPool object at line number 87 in org/apache/commons/dbcp/PoolingConnection.java, but cannot obtain it since it is held by the second thread. The second thread tries to obtain a lock on the Connection object at line number 106 in org/apache/commons/dbcp/PoolablePreparedStatement.java, but cannot acquire it since the lock has not yet been released by the first thread. The program, thus, goes into a deadlock.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>They reduce the number of reports to 70 after applying various unsound heuristics</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>This is implemented by associating a usage counter with a lock which is incremented whenever a thread acquires or re-acquires the lock and decremented whenever a thread releases the lock. Execution of Acquire(l) by t is considered whenever the thread t acquires or re-acquires the lock l and the usage counter associated with l is incremented from 0 to 1.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We would like to thank the anonymous reviewers for their valuable comments. This research was supported in part by a generous gift from Intel, by Microsoft and Intel funding (award #20080469), by matching funding by U.C. Discovery (award #DIG07-10227), and by NSF Grant CNS-0720906.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">}} org.w3c.jigsaw.http.socket.SocketClient { 42: SocketClientFactory pool</title>
		<author>
			<persName><forename type="first">{</forename></persName>
		</author>
		<ptr target="http.httpd{384" />
	</analytic>
	<monogr>
		<title level="m">http.socket.SocketClientFactory { 130: SocketClientState csList; 574: s y n ch ro n ized boolean decrIdleCount(</title>
		<imprint>
			<biblScope unit="volume">1734</biblScope>
			<biblScope unit="page">killClients</biblScope>
		</imprint>
	</monogr>
	<note>{ 623: s y n ch ro n ized (csList) { 626: decrIdleCount()i d killClients. csList) {...}} 902: v o i d shutdown(</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Detecting potential deadlocks with static analysis and runtime monitoring</title>
		<author>
			<persName><forename type="first">R</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Stoller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Parallel and Distributed Systems: Testing and Debugging</title>
		<imprint>
			<date type="published" when="2005">2005. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Applying static analysis to large-scale, multi-threaded Java programs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Artho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Biere</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th Australian Software Engineering Conference (ASWEC&apos;01)</title>
		<meeting>the 13th Australian Software Engineering Conference (ASWEC&apos;01)</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="68" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Confirmation of deadlock potentials detected by runtime analysis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bensalem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-C</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Mounier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PADTAD&apos;06</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="41" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Scalable dynamic deadlock analysis of multi-threaded programs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bensalem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Parallel and Distributed Systems: Testing and Debugging 2005 (PADTAD&apos;05)</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Ownership types for safe programming: preventing data races and deadlocks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Boyapati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">17th ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="211" to="230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Concurrent software verification with states, events, and deadlocks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ouaknine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sharygina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sinha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Aspects of Computing</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="461" to="483" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A deadlock detection tool for concurrent java programs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Demartini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Iosif</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sisto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software -Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="577" to="603" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Multithreaded Java program test generation</title>
		<author>
			<persName><forename type="first">O</forename><surname>Edelstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Farchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Nir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ratsaby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Systems Journal</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="111" to="125" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Racerx: effective, static detection of race conditions and deadlocks</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Engler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ashcraft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">19th ACM Symposium on Operating Systems Principles (SOSP)</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="237" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Extended static checking for java</title>
		<author>
			<persName><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lillibridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Saxe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Stata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI &apos;02: Proceedings of the ACM SIGPLAN 2002 Conference on Programming language design and implementation</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="234" to="245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Model checking for programming languages using verisoft</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">24th Symposium on Principles of Programming Languages</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="174" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Runtime checking of multithreaded applications with visual threads</title>
		<author>
			<persName><forename type="first">J</forename><surname>Harrow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th International SPIN Workshop on Model Checking and Software Verification</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="331" to="342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Using runtime analysis to guide model checking of java programs</title>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th International SPIN Workshop on Model Checking and Software Verification</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="245" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Model Checking Java Programs using Java PathFinder</title>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Pressburger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. Journal on Software Tools for Technology Transfer</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="366" to="381" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">The Spin model checker</title>
		<author>
			<persName><forename type="first">G</forename><surname>Holzmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="279" to="295" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An extensible active testing framework for concurrent programs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Joshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">21st International Conference on Computer Aided Verification (CAV&apos;09)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Deadlock immunity: Enabling systems to defend against deadlocks</title>
		<author>
			<persName><forename type="first">H</forename><surname>Jula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tralamazza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zamfir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th USENIX Symposium on Operating Systems Design and Implementation (OSDI&apos;08)</title>
		<meeting>the 8th USENIX Symposium on Operating Systems Design and Implementation (OSDI&apos;08)</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Time, clocks, and the ordering of events in a distributed system</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="558" to="565" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Static detection of deadlocks in polynomial time</title>
		<author>
			<persName><forename type="first">S</forename><surname>Masticola</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
		<respStmt>
			<orgName>Rutgers University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Parameterized object sensitivity for points-to analysis for Java</title>
		<author>
			<persName><forename type="first">A</forename><surname>Milanova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rountev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ryder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Software Engineering and Methodology</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="41" />
			<date type="published" when="2005-01">Jan. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Effective static deadlock detection</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">31st International Conference on Software Engineering (ICSE&apos;09</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Deadlocks: From exhibiting to healing</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Nir-Buchbinder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tzoref</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ur</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Randomized active atomicity violation detection in concurrent programs</title>
		<author>
			<persName><forename type="first">C.-S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">16th International Symposium on Foundations of Software Engineering (FSE&apos;08)</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Rx: treating bugs as allergies-a safe method to survive software failures</title>
		<author>
			<persName><forename type="first">F</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tucek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sundaresan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP &apos;05: Proceedings of the twentieth ACM symposium on Operating systems principles</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="235" to="248" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Race directed random testing of concurrent programs</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI&apos;08)</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Testing concurrent Java programs using randomized scheduling</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Stoller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Runtime Verification (RV&apos;02)</title>
		<imprint>
			<publisher>ENTCS</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">70</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Detecting Synchronization Defects in Multi-Threaded Object-Oriented Programs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Von Praun</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
		<respStmt>
			<orgName>Swiss Federal Institute of Technology, Zurich</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Object race detection</title>
		<author>
			<persName><forename type="first">C</forename><surname>Von Praun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">R</forename><surname>Gross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">16th ACM SIGPLAN conference on Object oriented programming, systems, languages, and applications (OOPSLA)</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="70" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Static deadlock detection for Java libraries</title>
		<author>
			<persName><forename type="first">A</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Thies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ernst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECOOP 2005 -19th European Conference on Object-Oriented Programming (ECOOP&apos;05)</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="602" to="629" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Efficient program execution indexing</title>
		<author>
			<persName><forename type="first">B</forename><surname>Xin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">N</forename><surname>Sumner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN conference on Programming language design and implementation</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="238" to="248" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
