<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">MULTI: Multi-Objective Effort-Aware Just-in-Time Software Defect Prediction</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2017-08-11">August 11, 2017</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Xiang</forename><surname>Chen</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">School of Computer Science and Technology</orgName>
								<orgName type="institution">Nantong University</orgName>
								<address>
									<settlement>Nantong</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Guangxi Key Laboratory of Trusted Software</orgName>
								<orgName type="institution">Guilin University of Electronic Technology</orgName>
								<address>
									<settlement>Guilin</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="laboratory">State Key Laboratory for Novel Software Technology</orgName>
								<orgName type="institution">Nanjing University</orgName>
								<address>
									<settlement>Nanjing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yingquan</forename><surname>Zhao</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">School of Computer Science and Technology</orgName>
								<orgName type="institution">Nantong University</orgName>
								<address>
									<settlement>Nantong</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Qiuping</forename><surname>Wang</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">School of Computer Science and Technology</orgName>
								<orgName type="institution">Nantong University</orgName>
								<address>
									<settlement>Nantong</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Zhidan</forename><surname>Yuan</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">School of Computer Science and Technology</orgName>
								<orgName type="institution">Nantong University</orgName>
								<address>
									<settlement>Nantong</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Information and Software Technology</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">MULTI: Multi-Objective Effort-Aware Just-in-Time Software Defect Prediction</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2017-08-11">August 11, 2017</date>
						</imprint>
					</monogr>
					<idno type="MD5">9149DF2C68A2E9DAF0BDE3C3DA0AFA48</idno>
					<idno type="DOI">10.1016/j.infsof.2017.08.004</idno>
					<note type="submission">Received date: 19 April 2017 Revised date: 22 July 2017 Accepted date: 10 August 2017 Preprint submitted to Elsevier</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Just-in-time Defect Prediction</term>
					<term>Multi-objective Optimization</term>
					<term>Empirical Studies</term>
					<term>Search based Software Engineering</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Context: Just-in-time software defect prediction (JIT-SDP) aims to conduct defect prediction on code changes, which have finer granularity. A recent study by Yang et al. has  shown that there exist some unsupervised methods, which are comparative to supervised methods in effort-aware JIT-SDP.</p><p>Objective: However, we still believe that supervised methods should have better prediction performance since they effectively utilize the gathered defect prediction datasets. Therefore we want to design a new supervised method for JIT-SDP with better performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Method:</head><p>In this article, we propose a multi-objective optimization based supervised method MULTI to build JIT-SDP models. In particular, we formalize JIT-SDP as a multi-objective optimization problem. One objective is designed to maximize the number of identified buggy changes and another object is designed to minimize the efforts in software quality assurance activities. There exists an obvious conflict between these two objectives. MULTI uses logistic regression to build the models and uses NSGA-II to generate a set of non-dominated solutions, which each solution denotes the coefficient vector for the logistic regression.</p><p>Results: We design and conduct a large-scale empirical studies to compare</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Software defect prediction (SDP) <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b2">3]</ref> is an active research topic in current software engineering research domain. In particular, after mining software repositories (such as version control system, bug tracking system, or developer emails), we can extract numerous program modules. Then we can use metrics to measure these modules and label these modules based on the analysis of bug reports and change logs. These metrics <ref type="bibr" target="#b4">[4]</ref> are mainly designed based on the analysis of code complexity or code development process. Finally we can construct SDP models based on these gathered datasets and use the constructed models to predict potential defective modules. By identifying potentially defective modules in advance, software quality assurance (SQA) team can allocate more SQA efforts (i.e., time for designing more test cases or conducting more rigorous code inspection) on these identified modules.</p><p>According to Kamei et al. <ref type="bibr" target="#b5">[5]</ref>, previous research on SDP exists the following disadvantages: <ref type="bibr" target="#b0">(1)</ref> Predicting at the coarser granularity (such as package or file) of the program module needs more SQA efforts. (2) Once a module is predicted as defect-proness, it is difficult to find appropriate developers to localize and fix</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A C C E P T E D M A N U S C R I P T</head><p>these defects in this module. Especially for open source software, a module may be developed by multiple developers from all over the world. (3) Developers ideally want the prediction performed as early as possible so that they can still be familiar with their developed codes. To alleviate these disadvantages, researchers aimed to conduct SDP on code changes (i.e., commits to a version control system) and classified the code changes as buggy or clean. Kamei et al. <ref type="bibr" target="#b5">[5]</ref> called this process as just-in-time software defect prediction (JIT-SDP).</p><p>Previous studies have proposed different supervised methods and unsupervised methods for JIT-SDP <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b8">8,</ref><ref type="bibr" target="#b9">9,</ref><ref type="bibr" target="#b10">10]</ref>. Especially in a recent study, Yang et al. <ref type="bibr" target="#b8">[8]</ref> found that some simple unsupervised methods can perform better than previous proposed supervised methods in most cases. This conclusion contradicts our common sense (i.e., supervised methods can exploit more knowledge from the gathered datasets and then have better performance when compared with unsupervised methods). To investigate whether there is a way to improve the performance of supervised methods, we firstly apply multiobjective optimization algorithm (MOA) to JIT-SDP. This attempt is motivated by the idea of search based software engineering (SBSE) <ref type="bibr" target="#b11">[11]</ref>. Harman <ref type="bibr" target="#b11">[11]</ref> once suggested that SBSE (in particular MOA) can be potentially used to build SDP models. In practice, he suggested that these objectives can be set as prediction performance, construction cost, privacy or comprehensibility of the model.</p><p>For this problem, we mainly consider two optimization objectives. In particular, the first objective is designed from the view of benefit, it aims to maximize the number of identified buggy changes. The second objective is designed from the view of cost, it aims to minimize the efforts of SQA. It is not hard to find that there is an obvious conflict between these two objectives during the model construction phase. Generally speaking, if we want the trained model to identify more buggy changes in the training set, it will need more SQA efforts. On the contrary, if we want the trained model to reduce SQA efforts, it will miss more buggy changes. Based on the above analysis, we propose our MULTI method based on NSGA-II <ref type="bibr" target="#b12">[12]</ref>, which is a state-of-the-art multi-objective optimization algorithm. In our method, we use logistic regression to build the model. By</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A C C E P T E D M</head><p>A N U S C R I P T using NSGA-II, we can generate a set of non-dominated solutions. A solution is composed of coefficient vector and each coefficient vector can be used to construct a specific JIT-SDP model by utilizing logistic regression. After generating multiple models simultaneously, we can select appropriate models based on a specific preference (i.e., identifying more buggy changes or using less SQA efforts).</p><p>In our empirical studies, we consider six open-source projects as our experimental subjects, which cover a wide range of application domains. These projects have 227417 code changes in total. We consider two effort-aware performance metrics (i.e., ACC and P OP T ) and evaluate our method in three different model performance evaluation scenarios, such as cross-validation, cross-projectvalidation, and timewise-cross-validation. To verify the effectiveness of our proposed method, we consider 43 state-of-the-art baseline methods. In particular, 31 methods are supervised methods and the remaining 12 methods are unsupervised methods. Final results show that using ACC performance metric or P OP T performance metric, our method can perform significantly better than all the baseline methods in all the three scenarios.</p><p>The main contributions of this article can be summarized as follows:</p><p>• To the best of our knowledge, we firstly apply multi-objective optimization to JIT-SDP and propose MULTI method. This method aims to maximize the number of identified buggy changes while minimizing the efforts of software quality assurance. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>•</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Background and Related Work</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Background</head><p>Previous research on software defect prediction may not be practical for large-scale software since module granularity is often set as file or package. Some researchers aim to conduct SDP on code changes, which have smaller granularity. During the process of software development and maintenance, developers may submit code changes for a variety of reasons, such as fixing defects, extending functionality, refactoring codes, or improving system performance. In this problem, they want to classify these changes into two categories: buggy changes and clean changes. Here a buggy change means that this change will introduce one or more defects, while a clean change means that this change will not introduce any defects.</p><p>The process of JIT-SDP can be summarized as follows: (1) It first extracts code changes from software repositories (such as version control system). <ref type="bibr" target="#b1">(2)</ref> It measures these code changes based on code complexity, programmer experience, development process or text mining techniques <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b7">7]</ref>. (3) It uses SZZ algorithm <ref type="bibr" target="#b13">[13]</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Related Work</head><p>Mockus and Weiss <ref type="bibr" target="#b6">[6]</ref> firstly applied JIT-SDP to a large switching system software. They considered metrics based on the analysis of the diffusion and size</p><formula xml:id="formula_0">A C C E P T E D M A N U S C R I P T</formula><p>of a change, the type of change, and the developers' experience with the system. Kamei et al. <ref type="bibr" target="#b5">[5]</ref> considered similar metrics for the code changes and conducted large-scale empirical studies on six open-source and five commercial projects.</p><p>They found their models can achieve 68% accuracy and 64% recall on average. Moreover, they also proposed a novel method EALR, which considers efforts to test or inspect code changes. Later they <ref type="bibr" target="#b14">[14]</ref> investigated JIT-SDP in crossproject scenarios and provided suggestions to improve the performance in this scenario. Yang et al. <ref type="bibr" target="#b9">[9]</ref> proposed Deeper method, which applies deep learning to JIT-SDP. In particular, they constructed a set of new metrics from original metrics by leveraging deep belief network. Then they used logistic regression to build the model based on these new metrics. Later Yang et al also proposed a two-layer ensemble learning method TLEL which leverages decision tree and ensemble learning to improve the performance of JIT-SDP. Recently Yang et al. <ref type="bibr" target="#b8">[8]</ref> considered simple unsupervised methods for JIT-SDP and found that these unsupervised methods perform better than previous supervised methods (including EALR) in most cases under cross-validation, timewise-cross-validation, and cross-project-validation scenarios. Fu and Menzies <ref type="bibr" target="#b15">[15]</ref> revisited Yang et al.'s empirical results <ref type="bibr" target="#b8">[8]</ref> and found that not all unsupervised methods have better performance than supervised methods. Therefore they proposed OneWay method, which can automatically select the potential best method. Kim et al. <ref type="bibr" target="#b7">[7]</ref> constructed JIT-SDP models from another point of view.</p><p>They extracted features (i.e., metrics) from change log messages, source code and file names by using text mining methods. In their empirical studies on 12 open-source projects, they found their model can achieve 78% accuracy and 60% recall on average. Since using text mining methods will extract a large number of features, Shivaji et al. <ref type="bibr" target="#b16">[16]</ref> investigated multiple feature selection methods to overcome the curse of dimensionality. Final results showed that these methods can select less than 10% of the original features and the performance can be significantly improved.</p><p>A recent study by Yang et al. <ref type="bibr" target="#b8">[8]</ref> shows that some unsupervised methods can achieve better performance than supervised method. However, their finding</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A C C E P T E D M</head><p>A N U S C R I P T contradicts our common sense and we still believe that supervised methods should have better performance. In this article, we firstly apply multi-objective optimization to JIT-SDP and then propose a supervised method MULTI. To investigate the effectiveness of our proposed method, we conduct large-scale empirical studies on 6 open-source projects and compare MULTI with 43 stateof-the-art supervised and unsupervised methods. The final results show that supervised methods are still promising in effort-aware JIT-SDP. Software defect prediction is a relatively new application area of multi-objective optimization.</p><p>Canfora et al. <ref type="bibr" target="#b17">[17]</ref> once applied multi-objective optimization for cross-project defect prediction and proposed MODEP method. While in this article, we mainly applied multi-objective optimization for JIT-SDP, therefore the solved problem, selected experimental subjects, used performance metrics, and the model evaluation process are all different from their work <ref type="bibr" target="#b17">[17]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Our Proposed Method MULTI</head><p>Our research is motivated by the idea of search based software engineering (SBSE) <ref type="bibr" target="#b18">[18]</ref>. SBSE concept was first proposed by Mark Harman. It has become an active research topic in recent software engineering research. SBSE has been applied to many problems throughout the software life cycle (i.e., from requirement analysis, software design, software testing, to software maintenance). The approach is promising because it can provide automated or semi-automated solutions in complex problems with large-scale search spaces, which have multiple competing or even conflicting objectives. For SDP, Harman <ref type="bibr" target="#b11">[11]</ref> also firstly suggested that SBSE (in particular MOA) can be potentially used to build SDP models. The optimization objectives can be designed based on the analysis for predictive quality, cost, or privacy.</p><p>In this article, we use logistic regression, which is widely used in previous SDP research <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b20">20,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b22">22]</ref>, to build JIT-SDP model. The coefficient vector w =&lt; w 0 , • • • , w n &gt; of the model can be denoted as a solution for JIT-SDP.</p><p>Supposing there is n metrics to measure the code change, we use m i to denote</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A C C E P T E D M A N U S C R I P T</head><p>the i-th code change and use v i,j to denote its value on j-th metric. For this code change, we can use function y(), which is the modeling formula used in logistic regression, to estimate the defect-proneness probability of this change and this function can be set as below:</p><formula xml:id="formula_1">y(m i , w) = 1 1 + e -(w0+w1vi,1+•••+wnvi,n)<label>(1)</label></formula><p>In our article, we treat JIT-SDP as a binary classification problem. However </p><formula xml:id="formula_2">Y (m i , w) =      1 if y(m i , w) &gt; 0.5 0 if y(m i , w) ≤ 0.5<label>(2)</label></formula><p>For effort-aware JIT-SDP, we mainly consider two optimization objectives based on cost-benefit analysis when constructing models. The first objective is designed from the view of benefit. Based on a set of changes M and a solution w, it can be computed by the following formula:</p><formula xml:id="formula_3">benef it(w) = mi∈M Y (m i , w) × buggy(m i )<label>(3)</label></formula><p>Here buggy(m i ) denotes whether code change m i really has defects. If this code change has defects, its value is 1. Otherwise its value is 0.</p><p>The second objective is designed from the view of cost. Based on a set of changes M , it can be computed by the following formula:</p><formula xml:id="formula_4">cost(w) = mi∈M Y (m i , w) × SQA(m i )<label>(4)</label></formula><p>Here we use function SQA() to measure the SQA efforts on the change m i .</p><p>During the software development and maintenance phase, SQA efforts denotes the time allocated for designing more test cases or conducting more rigorous code inspection on potential faulty changes. In this article, this function is designed</p><formula xml:id="formula_5">A C C E P T E D M A N U S C R I P T</formula><p>to return the total number of LOC (lines of code) modified by a change as the SQA efforts which is suggested by Kamei et al. <ref type="bibr" target="#b5">[5]</ref>. They assume that a change, which adds or deletes more lines, will require more efforts to test or inspect than the change, which adds or deletes fewer lines.</p><p>We use a synthesized example to illustrate the computing process of these two objectives. Supposing a set of changes M , their actual class (i.e., buggy()),</p><p>their predicted class based on a specific JIT-SDP model (i.e., Y ()), and their efforts (i.e., SQA()) are shown in Table <ref type="table" target="#tab_0">1</ref>, the benefit objective of this model can be computed by (0</p><formula xml:id="formula_6">× 1 + 1 × 0 + • • • + 1 × 1)</formula><p>and the cost objective of this model can be computed by (1 Changes Actual Class Predicted Class SQA Efforts</p><formula xml:id="formula_7">× 30 + 0 × 20 + • • • + 1 × 15).</formula><formula xml:id="formula_8">c 1 0 1 30 c 2 1 0 20 • • • • • • • • • • • • c n 1 1<label>15</label></formula><p>Based on the above analysis, we can formalize JIT-SDP as a bi-objective optimization problem and then propose a novel method MULTI based on MOA.</p><p>To facilitate the subsequent description of our proposed method, we first give some definitions concerning about MOA.</p><p>Definition 1 (Pareto Dominance). Supposing w i and w j are two feasible solutions to construct JIT-SDP models, we call w i is Pareto dominance on w j , if  algorithm and the concept of crowding distance <ref type="bibr" target="#b12">[12]</ref>. After a sufficient population evolution, it will satisfy the termination criterion and converge to stable solutions. Finally it returns all the Pareto optimal solutions in the current population.</p><formula xml:id="formula_9">and only if: benef it(w i ) &gt; benef it(w j ) and cost(w i ) ≤ cost(w j ) or benef it(w i ) ≥ benef it(w j ) and cost(w i ) &lt; cost(w j )<label>Definition</label></formula><p>It is worth noting that all the Pareto optimal solutions are generated based on the training set. Then each solution (i.e., coefficient vector) can be used to construct a JIT-SDP model respectively based on logistic regression. Finally we apply these models to perform defect prediction on the testing set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Experimental Setup</head><p>To verify the effectiveness of our proposed method MULTI, we design the following three research questions.</p><p>RQ1: How about the performance of our proposed method MULTI when compared to baseline methods in cross-validation scenario?</p><p>RQ2: How about the performance of our proposed method MULTI when compared to baseline methods in cross-project-validation scenario?</p><p>RQ3: How about the performance of our proposed method MULTI when</p><formula xml:id="formula_10">A C C E P T E D M A N U S C R I P T</formula><p>compared to baseline methods in timewise-cross-validation scenario?</p><p>Here we consider two performance metrics ACC and P OP T , which are based on SQA efforts, to evaluate different methods. More details of these two metrics can be found in Section 4.2. Based on these three RQs, we want to compare our proposed method MULTI with classical baseline methods (including supervised and unsupervised methods) in three different model performance validation scenarios, which is consistent with Yang et al. <ref type="bibr" target="#b8">[8]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Experimental Subjects</head><p>In our empirical studies, we consider 6 open-source projects, which were first used by Kamei et al. <ref type="bibr" target="#b5">[5]</ref>. They considered 14 metrics based on analysis the characteristics on code change. The summarization (i.e., dimension, name, and description) of these metrics is shown in Table <ref type="table" target="#tab_1">2</ref>. These metrics have been grouped into 5 dimensions. In particular, the diffusion dimension characterizes the distribution of a change. The assumption is that a highly distributed change is more likely to be a buggy change <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b23">23]</ref>. The size dimension characterizes the size of a change. The assumption is that a complex change is expected to be a buggy change with high probability <ref type="bibr" target="#b24">[24,</ref><ref type="bibr" target="#b25">25]</ref>. The assumption of purpose dimension is that a defect-fixing change is more likely to introduce new defects <ref type="bibr" target="#b26">[26]</ref>. This history dimension assumes that a defect is more likely introduced by a change if the touched files have been modified by more developers <ref type="bibr" target="#b27">[27]</ref>.</p><p>The experience dimension assumes that experienced developers are less likely to introduce defects when modifying codes <ref type="bibr" target="#b6">[6]</ref>.</p><p>These six open-source projects are large-scale, well-known, and long-lived.</p><p>They also cover a wide range of domains. For example, bugzilla is a web-based bug tracking system, Eclipse JDT is a Java development tool, Mozilla is a widely used web browser, PostgreSQL is an object-relational database system.</p><p>All the code changes are extracted from the CVS repositories of the projects and labeled by analyzing bug reports and change logs. Table <ref type="table" target="#tab_2">3</ref> summarizes the characteristics of datasets used in our empirical studies, including project name (abbreviation), period, the number of code changes and the percent of buggy   </p><formula xml:id="formula_11">A C C E P T E D M A N U S C R I P T</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Performance Metrics</head><p>To evaluate the performance of the JIT-SDP model, we consider the SQA efforts. Similar to Kamei et al. <ref type="bibr" target="#b5">[5]</ref>, we use the code churn (i.e., the total number of lines added and deleted) to measure the SQA efforts and consider two effortaware performance metrics <ref type="bibr" target="#b28">[28,</ref><ref type="bibr" target="#b30">29]</ref>. In particular, ACC denotes the recall of buggy changes when using 20% of the entire efforts. Previous work <ref type="bibr" target="#b31">[30]</ref> shows that defect distribution in software project satisfies 20-80 principle, that is the majority of defects (about 80%) are contained in a small number of program modules (about 20% measure in LOC). This principle is partially confirmed in our used projects. For example, the LOC of buggy changes is 15.12% of the LOC of all the code changes for JDT project. P opt is the normalized version of the effort-aware performance indicator originally proposed by Mende and Koschke <ref type="bibr" target="#b30">[29]</ref>. More details of these two performance metrics can be found in <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b8">8]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Model Performance Evaluation Scenarios</head><p>In our empirical studies, we mainly consider three model performance evaluation scenarios. These scenarios are cross-validation, cross-project-validation, and timewise-cross-validation. In particular:</p><formula xml:id="formula_12">A C C E P T E D M A N U S C R I P T</formula><p>• For cross-validation scenario, we mainly consider 10×10-fold cross validation within the same project.</p><p>• For cross-project-validation, we perform JIT-SDP across different projects.</p><p>We construct models based on one project (i.e., source project) and use these models to predict the changes on another project (i.e, target project).</p><p>• For timewise-cross-validation, JIT-SDP is performed within the same project, in which the chronological order of changes based on the commit date is considered <ref type="bibr" target="#b13">[13]</ref>. Assuming the changes are divided into n parts, we first construct the models based on the changes from part i and i + 1. Then we use the constructed models to predict the changes from part i+4 and i+5.</p><p>More details of these three scenarios can be found in <ref type="bibr" target="#b8">[8]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Baseline Methods</head><p>To evaluate the effectiveness of our proposed method, we consider 43 stateof-the-art baseline methods used by yang et al. <ref type="bibr" target="#b8">[8]</ref>, including 31 supervised methods and 12 unsupervised methods.</p><p>All the supervised methods and their abbreviations are summarized in Table <ref type="table" target="#tab_3">4</ref>. Here method EALR <ref type="bibr" target="#b5">[5]</ref> uses buggy(m i )/LOC(m i ) as the dependent variable and uses linear regression to construct the models. The remaining supervised methods are used by a recent paper <ref type="bibr" target="#b19">[19]</ref> to revisit their impact on the performance of SDP. These supervised methods can be classified into 6 families. In EXP, REXP, SEXP metrics respectively. For j-th metric, it compute the defectproneness probability for i-th change m i as 1/v i,j . This means that the smaller the metric value, the higher the defect-proneness probability. Then all the changes will be ranked in descendant order according to the computed probability. These methods are motivated by ManualUp model <ref type="bibr" target="#b32">[31]</ref>. In some empirical studies, these unsupervised methods surprisedly perform well both in traditional SDP and JIT-SDP when considering SQA efforts <ref type="bibr" target="#b32">[31,</ref><ref type="bibr" target="#b33">32,</ref><ref type="bibr" target="#b8">8]</ref>. Except for these unsupervised methods proposed by Yang et al. <ref type="bibr" target="#b8">[8]</ref>, there also exist other unsupervised methods <ref type="bibr" target="#b34">[33,</ref><ref type="bibr" target="#b35">34]</ref> for SDP. However these methods are not suitable as our baseline methods. The reasons can be summarized as follows:</p><p>(1) The granularity of program modules is set as file or package in these two studies. For example, datasets NetGene and ReLink used by Nam and Kim <ref type="bibr" target="#b34">[33]</ref> set the granularity as file. While in JIT-SDP, the granularity is set as code change, which has coarser granularity. (2) Different granularity results in different metrics. For example, NetGene dataset used network and change genealogy metrics, ReLink used code complexity metrics extracted by the Understand tool <ref type="bibr" target="#b34">[33]</ref>. These metrics are different from metrics used by JIT-SDP. (3) The design of these methods <ref type="bibr" target="#b34">[33,</ref><ref type="bibr" target="#b35">34]</ref> does not consider SQA efforts on program modules, therefore these methods can not be applicable to effort-aware JIT-SDP.  For our proposed method MULTI, we make the following setting for parameters, which is typically used by MOAs for numerical problems <ref type="bibr" target="#b36">[35]</ref>: To examine whether there is a significant difference in the prediction performance between our proposed method and other baseline methods. We firstly use the Benjamini-Hochberg (BH) corrected p-value <ref type="bibr" target="#b37">[36]</ref> to examine whether a difference is statistically significant at the significance level of 0.05. If the statistical test shows a significant difference, we then use the Cliff's δ to measure the magnitude of the difference. The meaning of different Cliffs δ values and their corresponding interpretation is shown in Table <ref type="table" target="#tab_4">5</ref>. In summary, our proposed method performs significantly better/worse than a baseline method, if BH cor-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A C C E P T E D M A N U S C R I P T</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A C C E P T E D M A N U S C R I P T</head><p>rected p-value is less than 0.05 and the effectiveness level is not negligible based on Ciff's δ. The difference between our method and a baseline method is not significant if p-value is not less than 0.05 or the effectiveness level is negligible. As there is randomness variation inherent in our method, we perform 10 independent runs to get a high statistical confidence.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Analysis for RQ1</head><p>To make an analysis for RQ1, we use the Scott-Knott test <ref type="bibr" target="#b38">[37]</ref> to group all the methods into statistically distinct ranks (α=0.05). In particular, it uses hierarchical cluster analysis to partition the methods into ranks. It starts by dividing the methods into two ranks on the basis of mean performance metric values (ACC or P OP T ). If the divided ranks are statistically significantly different, then it recursively executes again within each rank to further divide the ranks. It terminates when ranks can no longer be divided into statistically distinct ranks. The result is shown in Fig. <ref type="figure">3</ref>. The dotted lines represent groups divided by using the Scott-Knott test. All methods are ordered based on their mean ranks. The distribution of P OP T and ACC at cross-validation scenario over all the six projects is shown using boxplot. The blue label denotes supervised methods and the black label denotes unsupervised methods.</p><p>From Fig. <ref type="figure">3</ref>, we can find that MULTI performs significantly better than all the baseline supervised and unsupervised methods when using ACC performance metric or P OP T performance metric. Then we further compare MULTI to baseline methods for each project. To make a fair comparison, here we firstly choose the best two supervised baseline methods and the best two unsupervised baseline methods respectively. Then we only use MULTI-M to make a comparison with these four baseline methods. The median results of these chosen methods are shown in Table <ref type="table" target="#tab_5">6</ref> and Table <ref type="table" target="#tab_6">7</ref>. The row "Average" show the average value over all the six projects. The row "W/D/L" summarizes the number of projects for which MULTI-M obtains a better, equal, and worse performance than a specific baseline method (i.e., Win/Draw/Loss analysis). If we use ACC metric, we can find our MULTI-M can identify 63.8% buggy changes on average when using only 20% efforts, which can improve 119%, 231%, 30%, and 45% when compared to EALR, Ridor, LT, and AGE. If we use P OP T metric, we can find our MULTI-M can improve 50%, 73%, 11%, and 14% on average when compared to EALR, AB+LMT, LT, and AGE. Based on "W/D/L" analysis, our</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A C C E P T E D M A N U S C R I P T</head><p>MULTI-M can perform significantly better than four chosen baseline methods on all the projects both for ACC and P OP T metrics. W/D/L -6/0/0 6/0/0 6/0/0 6/0/0</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Analysis for RQ2</head><p>The result of Scott-Knott test in cross-project scenario is shown in Fig. <ref type="figure" target="#fig_11">4</ref>. The result is also promising. Our proposed method MULTI can perform significantly better than all the baseline methods when using ACC performance metric or P OP T performance metric.</p><p>Then we further compare MULTI to baseline methods for each cross-project prediction. Here we still choose the best two supervised baseline methods and the best two unsupervised baseline methods respectively. Final results are shown in Table <ref type="table" target="#tab_7">8</ref> and Table <ref type="table" target="#tab_8">9</ref>. The "Average" is summarized in the last row. In these two tables, the first column presents specific cases of cross-project prediction.</p><p>For example, in Table <ref type="table" target="#tab_7">8</ref>, the case "BUG ⇒ COL" means that the project BUG is used as the source project to construct the model, then this model is used to predict the changes in the target project COL. For ACC metric, based on  average value, we can find that our MULTI-M can identify 73% buggy changes on average when using only 20% efforts, which can improve 178%, 390%, 43%, and 61% respectively when compared to EALR, Ridor, LT, and AGE. For P OP T metric, based on average value, we can find that our MULTI-M can improve 66%, 104%, 15%, and 18% respectively on average when compared to EALR, AB+LMT, LT, and AGE.</p><formula xml:id="formula_13">A C C E P T E D M A N U S C R I P T</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Analysis for RQ3</head><p>The result of Scott-Knott test in timewise-cross-project scenario over the six projects can be found in Fig. <ref type="figure" target="#fig_12">5</ref>. The result is consistent with previous two scenarios. we can find that MULTI performs significantly better than all the baseline methods when using ACC metric or P OP T metric. Then we further compare MULTI to baseline methods for each each project.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A C C E P T E D M</head><p>A N U S C R I P T     W/D/L -6/0/0 6/0/0 6/0/0 6/0/0 we draw effort-based cumulative lift charts of different methods in Fig. <ref type="figure" target="#fig_14">6</ref>. Here</p><formula xml:id="formula_14">A C C E P T E D M A N U S C R I P T</formula><p>x-axis shows the percentage of used SQA efforts and y-axis shows the percentage of identified buggy changes. Each line plots the cumulative lift chart for changes order by decreasing defect-proneness probability given a corresponding method. These methods are MULTI (denoted by MUTI-B and MULTI-M), the best supervised method EALR and the best unsupervised method LT. In this figure we can find that our method can assign buggy changes with less SQA efforts higher defect-proneness probability by using multi-objective optimization.</p><p>Therefore our method MULTI can get higher value of ACC and P OP T than state-of-the-art baseline methods.</p><p>In the rest of this subsection, we first compare MULTI with a simple genetic algorithm and a random search algorithm to show the challenge of JIT-SDP problem. Then we compare MULTI with OneWay method, which is recently proposed by Fu and Menzies <ref type="bibr" target="#b15">[15]</ref>.</p><p>Later we analyze the competitiveness of MULTI based on F 1 metric and perform model construction time cost analysis on MULTI.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A C C E P T E D M</head><p>A N U S C R I P T We use SIMPLE-GA to denote the simple genetic algorithm. Given a set of changes M and a solution w, the objective of this solution can be computed by the following formula:</p><formula xml:id="formula_15">0.5 × benef it(w) |M | + 0.5 × cost(w) mi∈M SQA(m i )<label>(5)</label></formula><p>Here we combine two different objectives into a single objective by taking an average (i.e., the weight of each objective is set as 0.5) and these objectives are scaled into the same range (i.e., [0,1]).</p><p>We use RANDOM to denote the random search algorithm. For each iteration, it will generate new chromosomes (i.e., solutions) ran-    <ref type="table" target="#tab_11">12</ref>.</p><p>From Table <ref type="table" target="#tab_11">12</ref>, we can find that the model construction time of MULTI method is acceptable (i.e., 20.91 seconds ∼ 98.20 seconds). Even in some cases, MULTI method has lower model construction cost than some supervised methods. For example, on BUG dataset, the model construction time of MULTI is 24.10 seconds, however for some ensemble methods BG+LMT, AB+LMT, RF+LMT, the construction time is 29.10, 31.09, and 32.96 respectively. Moreover based on the results of empirical studies, our proposed MULTI can achieve better performance than all the baseline methods. Therefore we think MULTI is applicable in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.">Threats to Validity</head><p>In this subsection, we mainly discuss the potential threats to validity of our empirical studies.</p><p>Threats to external validity are about whether the observed experimental results can be generalized to other subjects. To guarantee the representative of our empirical subjects, we chose datasets which have been widely used in previous JIT-SDP research works <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b8">8,</ref><ref type="bibr" target="#b9">9,</ref><ref type="bibr" target="#b10">10]</ref>. In addition, to guarantee the representative of the model construction algorithm, we choose logistic regression   which is also widely used in previous SDP research <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b20">20,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b22">22]</ref>.</p><p>Threats to internal validity are mainly concerned with the uncontrolled internal factors that might have influence on the experimental results. The main internal threat is the potential faults during our method implementation. To reduce this threat, we use implementation of baseline methods provided by Yang et al. <ref type="bibr" target="#b8">[8]</ref>. For our proposed method MULTI, we use test cases to verify the correctness of our implementation and we use mature third-party libraries, such as packages from Matlab and R.</p><p>Threats to construct validity are about whether the performance metrics used in the empirical studies reflect the real-world situation. We used P OP T and ACC to evaluate the performance of JIT-SDP models. These effort-aware metrics have been used in previous JIT-SDP research <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b8">8,</ref><ref type="bibr" target="#b9">9,</ref><ref type="bibr" target="#b10">10]</ref>. In addition, we also use F 1 <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b9">9,</ref><ref type="bibr" target="#b16">16,</ref><ref type="bibr" target="#b34">33]</ref> to show the competitiveness of our proposed method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusion and Future Work</head><p>In this article, we firstly formalize JIT-SDP as a multi-objective optimization problem and then propose a novel method MULTI. Large-scale empirical studies show the competitiveness of our proposed method in cross-validation, cross-project-validation, and timewise-cross-validation scenarios. These results confirm that supervised methods are still promising in effort-aware JIT-SDP.</p><p>In the future, we plan to extend our research in several ways. Firstly we want to consider more commercial projects to verify whether our conclusion can be generalized. Secondly the quality of JIT-SDP datasets needs to be improved. For example, researchers often used SZZ algorithm <ref type="bibr" target="#b13">[13]</ref> to identify buggy changes. However a recent study <ref type="bibr">[40]</ref> shows that current SZZ implementations still lack mechanisms to accurately identify buggy changes. Finally we want to optimize the performance of our method by considering other MOAs </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>We designed and performed large-scale empirical studies to investigate the performance of MULTI in three different model evaluation scenarios and compare our method with 43 state-of-the-art baseline methods. The conclusions confirm that the supervised methods are still promising in effort-ware JIT-SDP. The rest of this article is organized as follows. Section 2 introduces the background and related work for JIT-SDP. Section 3 describes our proposed method A C C E P T E D M A N U S C R I P T MULTI in detail. Section 4 reports our empirical setup, including experimental subjects, performance metrics, model performance evaluation scenarios, baseline methods and experimental design. Section 5 analyzes our empirical results and threats to validity. Section 6 concludes this article and points out some potential future work.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>to identify defect-fixing changes and then classifies the extracted code changes to buggy change and clean change. (3) Based on the gathered training dataset, it uses a specific modeling method (such as logistic regression) to construct JIT-SDP model. (4) For a new code change, it measures this change and uses a trained model to predict whether this change is clean or buggy.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>the range of the output value of function y() is [0,1]. Therefore if the value of y() is greater than 0.5, we classify the code change as buggy, otherwise we classify the code change as clean. The new function Y () can be set as below:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>2 (</head><label>2</label><figDesc>Pareto Optimal Solution). A feasible solution w is a Pareto optimal solution, if and only if there is no other feasible solution w * which is Pareto dominance on w. A C C E P T E D M A N U S C R I P T Definition 3 (Pareto Optimal Set). This set is composed by all the Pareto optimal solutions. Definition 4 (Pareto Front). The surface composed by the vectors corresponding to all the Pareto optimal solutions is called Pareto front. We use an example to interpret these definitions. Supposing MULTI method generate 7 solutions given a training set and these solutions are shown in Fig. 1. In this Figure, x-axis denotes the cost value of the solution and y-axis denotes the benefit value of the solution. Here solution B is Pareto dominance on solution E, since benef it(B) &gt; benef it(E) and cost(B) ≤ cost(E). Solutions A, B, C and D are pareto optimal solutions since there is no other solution which is Pareto dominance on them. Therefore the surface A-B-C-D constitutes Pareto front in these solutions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Interpretation for Definitions in MOA</figDesc><graphic coords="11,151.45,383.61,267.46,194.22" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>subsystems ND Number of modified directories NF Number of modified files Entropy Distribution of modified code across each file Size LA Lines of code added LD Lines of code deleted LT Lines of code in a file before the change Purpose FIX Whether or not the change is a defect fix History NDEV The number of deveopers that changed the modified files AGE The average time interval between the last and current change NUC The number of unique changes to the modified files Experience EXP Developer experience REXP Recent deveoper experience SEXP Developer experience on a sub-system A C C E P T E D M A N U S C R I P T changes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>particular, function family includes 4 methods: linear regression (EALR), simple logistic (SL), radial basis functions network (RBFNet), sequential minimal optimization (SMO). Lazy family includes only 1 method: K-nearest neighbour (Ibk), Rule family includes 2 methods: propositional rule (Jrip) and ripple down rules (Ridor). Bayes family includes only 1 method: Naive Bayes (NB). Tree family includes 3 methods: J48, logistic model tree (LMT), and random forest (RF). Ensemble family considers bagging (BG), Adaboost (AB), rotation forest (RF), and random subspace (RS) ensemble methods. In the abbreviationsA C C E P T E D M A N U S C R I P Tof the Ensemble family, BG+LMT means that this method uses LMT as the base learner and uses Bagging as the ensemble method. It is not hard to find that these methods can cover different types of supervised methods in machine learning. In our empirical studies, we use the same parameters setting used by Yang et al.<ref type="bibr" target="#b8">[8]</ref> to build these supervised methods.Unsupervised methods has attracted more interest in current SDP research. These methods do not need training set, are very simple, and have a low model construction cost. We consider 12 methods proposed by Yang et al.<ref type="bibr" target="#b8">[8]</ref>. These methods are based on NS, ND, NF, Entropy, LT, FIX, NDEV, AGE, NUC,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>For 12 unsupervised</head><label>12</label><figDesc>baseline methods, we only use changes in the testing set to construct the model. Thus can make a fair comparison among all the methods.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>( 1 )</head><label>1</label><figDesc>Population size is set as 200. (2) The range of the element in the coefficient vector is within the interval [-10000, 10000]. While in population initialization, the range is within the interval [-10, 10]. (3) The maximum number of generation is set as 400. (4) Crossover probability is set as 0.5. (5) Mutation probability is set as 1/11, here 11 is the number of metrics used in our JIT-SDP research.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>For each run, we can get a Pareto front based on the training set. Therefore after 10 independent runs, we can get 10 Pareto fronts. Supposing the i-th Pareto front has l i solutions, then the 10 Pareto fronts will have 10 i=1 l i solutions in total. We firstly use MULTI-B to gather the best result of the solutions in these 10 Pareto fronts in the given testing set. Then we use MULTI-M to gather the median result of the solutions in these 10 Pareto fronts in the given testing set. It is not hard to find that MULTI-B and MULTI-M can denote the optimal performance and the average performance of MULTI method respectively. The running process can be found in Fig. 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: The Running Process of Our Proposed Method</figDesc><graphic coords="20,118.02,540.79,334.25,93.79" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: The Result of Scott-Knott Test in Cross-project Scenario</figDesc><graphic coords="24,118.02,536.80,334.34,111.45" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: The Result of Scott-Knott Test in Timewise-cross-validation Scenario</figDesc><graphic coords="25,118.02,503.19,334.34,111.45" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Effort-based Cumulative Lift Chart of Different Methods for BUG ⇒ COL</figDesc><graphic coords="30,151.45,151.00,267.56,199.06" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>S C R I P Tdomly and then select high-quality chromosomes from old chromosomes and new chromosomes into the new population. When reaching the maximum number of generations, it returns all the Pareto optimal solutions in the current population.As there is randomness inherent in SIMPLE-GA and RANDOM, we also perform 10 independent runs. For SIMPLE-GA, we gather the result of the solution with the highest fitness value in these 10 runs. For RANDOM, we gather the result, which keeps in line with MULTI. In particular, we firstly use RANDOM-B to gather the best result of the solutions in these 10 Pareto fronts in the given testing set. Then we use RANDOM-M to gather the median result of the solutions in these 10 Pareto fronts in the given testing set. The setting for parameters (such as the population size, the maximum number of generation, the range of the element in the coefficient vector) of SIMPLE-GA and RANDOM is the same as MULTI.Final result in cross-project scenario is shown in Fig.7. The result shows that MULTI can perform significantly better than SIMPLE-GA and RANDOM when using ACC performance metric or P OP T performance metric. From the result, we can find that for JIT-SDP, using simple genetic algorithms or random search algorithms can not obtain good results and therefore we should consider more complicated search algorithms, such as MOAs used in this article. Finally, we use quality indicators to evaluate the quality of Pareto fronts generated by MOAs. These quality indicators can be classified into four categories: convergence, diversity, combination of convergence and diversity, and coverage [38]. In this article, we select Hypervolume (HV) [39] because of its popularity. HV can measure the volume in the objective space that is covered by a Pareto front, therefore it can measure both the convergence and the diversity of a Pareto front. A higher value of HV means a better quality of the Pareto front. In Fig. 8, we Comparing HV of Pareto fronts gener-A C C E P T E D M A N U S C R I P T ated by MULTI and RANDOM in Cross-validation Scenario for each dataset. Here BUG-M means the Pareto fronts generated by MULTI based on BUG dataset and BUG-R means the Pareto fronts generated by RANDOM based on BUG dataset. For each dataset, the value of HV is scaled into the range [0,1] by dividing the maximum value of HV of 20 Pareto fronts (i.e., 10 Pareto fronts generated by MULIT and 10 Pareto fronts generated by RANDOM). Final results show MULTI can generate high quality Pareto fronts than RANDOM for each dataset.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: MULTI vs RANDOM based on HV in Cross-validation Scenario</figDesc><graphic coords="33,118.02,310.76,334.32,222.88" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 9 :Figure 10 :Figure 12 :</head><label>91012</label><figDesc>Figure 9: MULTI vs OneWay in Cross-validation Scenario</figDesc><graphic coords="34,118.02,306.23,167.15,111.43" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>(</head><label></label><figDesc>such as SPEA [39]) to implement MULTI method and select appropriate quality indicators to assess the quality of Pareto fronts generated by different MOAs A C C E P T E D M A N U S C R I P T</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>A Synthesized Example to Illustrate the Computing Process of Two Objectives</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Summarization of Metrics used for JIT-SDP<ref type="bibr" target="#b5">[5]</ref> </figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 :</head><label>3</label><figDesc>Summarization of Datasets</figDesc><table><row><cell>Project(Abbreviation)</cell><cell>Period</cell><cell cols="2"># Changes % Buggy</cell></row><row><cell>Bugzilla (BUG)</cell><cell>08/1998-12/2006</cell><cell>4620</cell><cell>37%</cell></row><row><cell>Columba (COL)</cell><cell>11/2002-07/2006</cell><cell>4455</cell><cell>31%</cell></row><row><cell>Eclipse JDT (JDT)</cell><cell>05/2001-12/2007</cell><cell>35386</cell><cell>14%</cell></row><row><cell cols="2">Eclipse Platform (PLA) 05/2001-12/2007</cell><cell>64250</cell><cell>15%</cell></row><row><cell>Mozilla (MOZ)</cell><cell>01/2000-12/2006</cell><cell>98275</cell><cell>5%</cell></row><row><cell>PostgreSQ (POS)</cell><cell>07/1996-05/2010</cell><cell>20431</cell><cell>25%</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 4 :</head><label>4</label><figDesc>Overview of the supervised methods</figDesc><table><row><cell>Family</cell><cell>Method</cell><cell>Abbreviation</cell></row><row><cell></cell><cell>Linear regression</cell><cell>EALR</cell></row><row><cell>Function</cell><cell>Simple logistic Radial basis functions</cell><cell>SL RBFNet</cell></row><row><cell></cell><cell>network</cell><cell></cell></row><row><cell></cell><cell>Sequential minimal</cell><cell>SMO</cell></row><row><cell></cell><cell>optimization</cell><cell></cell></row><row><cell>Lazy</cell><cell>K-nearest neighbour</cell><cell>Ibk</cell></row><row><cell>Rule</cell><cell>Propositional rule Ripple down rules</cell><cell>Jrip Ridor</cell></row><row><cell>Bayes</cell><cell>Naive Bayes</cell><cell>NB</cell></row><row><cell></cell><cell>J48</cell><cell>J48</cell></row><row><cell>Tree</cell><cell>Logistic model tree</cell><cell>LMT</cell></row><row><cell></cell><cell>Random Forest</cell><cell>RF</cell></row><row><cell></cell><cell>Bagging</cell><cell>BG+LMT, BG+NB, BG+SL,</cell></row><row><cell></cell><cell></cell><cell>BG+SMO, and BG+J48</cell></row><row><cell>Ensemble</cell><cell>Adaboost</cell><cell>AB+LMT, AB+NB, AB+SL,</cell></row><row><cell></cell><cell></cell><cell>AB+SMO, and AB+J48</cell></row><row><cell></cell><cell>Rotation Forest</cell><cell>RF+LMT, RF+NB, RF+SL,</cell></row><row><cell></cell><cell></cell><cell>RF+SMO, and RF+J48</cell></row><row><cell></cell><cell>Random Subspace</cell><cell>RS+LMT, RS+NB, RS+SL,</cell></row><row><cell></cell><cell></cell><cell>RS+SMO, and RS+J48</cell></row></table><note><p>each metric (except for FIX). (3) To deal with the problem of class imbalance in datasets. we apply random under-sampling to the training set. In particular, we will delete clean changes randomly until the number of clean changes keeps same as the number of buggy changes. Note that we do not apply under-sampling to the testing set.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 5 :</head><label>5</label><figDesc>Cliff's δ and the Effectiveness Level<ref type="bibr" target="#b37">[36]</ref> </figDesc><table><row><cell>Cliff's δ</cell><cell>Effectiveness Level</cell></row><row><cell>|δ| &lt; 0.147</cell><cell>Negligible</cell></row><row><cell>0.147 ≤ |δ| &lt; 0.33</cell><cell>Small</cell></row><row><cell>0.33 ≤ |δ| &lt; 0.474</cell><cell>Medium</cell></row><row><cell>0.474 ≤ |δ|</cell><cell>Large</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 6 :</head><label>6</label><figDesc>MULTI-M vs Top Two Supervised and Unsupervised Methods in Cross-Validation</figDesc><table><row><cell>Scenario using ACC</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>Supervised</cell><cell></cell><cell>Unsupervised</cell></row><row><cell>Project</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="3">MULTI-M EALR Ridor</cell><cell>LT</cell><cell>AGE</cell></row><row><cell>BUG</cell><cell>0.696</cell><cell>0.407</cell><cell cols="2">0.226 0.476 0.441</cell></row><row><cell>COL</cell><cell>0.696</cell><cell>0.414</cell><cell cols="2">0.162 0.590 0.659</cell></row><row><cell>JDT</cell><cell>0.626</cell><cell>0.215</cell><cell cols="2">0.196 0.531 0.459</cell></row><row><cell>PLA</cell><cell>0.684</cell><cell>0.289</cell><cell cols="2">0.217 0.466 0.409</cell></row><row><cell>MOZ</cell><cell>0.511</cell><cell>0.148</cell><cell cols="2">0.198 0.367 0.241</cell></row><row><cell>POS</cell><cell>0.613</cell><cell>0.271</cell><cell cols="2">0.157 0.504 0.427</cell></row><row><cell>Average</cell><cell>0.638</cell><cell>0.291</cell><cell cols="2">0.193 0.489 0.439</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 7 :</head><label>7</label><figDesc>MULTI-M vs Top Two Supervised and Unsupervised Methods in Cross-Validation Scenario using P OP T</figDesc><table><row><cell></cell><cell></cell><cell>Supervised</cell><cell></cell><cell cols="2">Unsupervised</cell></row><row><cell>Project</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="3">MULTI-M EALR AB+LMT</cell><cell>LT</cell><cell>AGE</cell></row><row><cell>BUG</cell><cell>0.883</cell><cell>0.722</cell><cell>0.625</cell><cell cols="2">0.756 0.757</cell></row><row><cell>COL</cell><cell>0.880</cell><cell>0.605</cell><cell>0.371</cell><cell cols="2">0.828 0.848</cell></row><row><cell>JDT</cell><cell>0.829</cell><cell>0.514</cell><cell>0.515</cell><cell cols="2">0.777 0.744</cell></row><row><cell>PLA</cell><cell>0.853</cell><cell>0.549</cell><cell>0.511</cell><cell cols="2">0.748 0.715</cell></row><row><cell>MOZ</cell><cell>0.757</cell><cell>0.453</cell><cell>0.527</cell><cell cols="2">0.655 0.620</cell></row><row><cell>POS</cell><cell>0.843</cell><cell>0.517</cell><cell>0.361</cell><cell cols="2">0.796 0.751</cell></row><row><cell>Average</cell><cell>0.841</cell><cell>0.560</cell><cell>0.485</cell><cell cols="2">0.760 0.739</cell></row><row><cell>W/D/L</cell><cell>-</cell><cell>6/0/0</cell><cell>6/0/0</cell><cell cols="2">6/0/0 6/0/0</cell></row></table><note><p>(a) ACC (b) P OP T</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 8 :</head><label>8</label><figDesc>MULTI-M vs Top Two Supervised and Unsupervised Methods in Cross-Project</figDesc><table><row><cell>Scenario using ACC</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Source ⇒</cell><cell></cell><cell>Supervised</cell><cell></cell><cell>Unsupervised</cell></row><row><cell>Target</cell><cell cols="3">MULTI-M EALR Ridor</cell><cell>LT</cell><cell>AGE</cell></row><row><cell>BUG ⇒ COL</cell><cell>0.716</cell><cell>0.497</cell><cell cols="2">0.468 0.641 0.702</cell></row><row><cell>BUG⇒ JDT</cell><cell>0.773</cell><cell>0.281</cell><cell cols="2">0.308 0.582 0.490</cell></row><row><cell>BUG⇒ PLA</cell><cell>0.772</cell><cell>0.429</cell><cell cols="2">0.275 0.494 0.427</cell></row><row><cell>BUG⇒ MOZ</cell><cell>0.763</cell><cell>0.219</cell><cell cols="2">0.265 0.367 0.240</cell></row><row><cell>BUG⇒ POS</cell><cell>0.765</cell><cell>0.349</cell><cell cols="2">0.267 0.533 0.432</cell></row><row><cell>COL⇒ BUG</cell><cell>0.821</cell><cell>0.336</cell><cell cols="2">0.056 0.435 0.432</cell></row><row><cell>COL ⇒ JDT</cell><cell>0.828</cell><cell>0.113</cell><cell cols="2">0.051 0.582 0.490</cell></row><row><cell>COL ⇒ PLA</cell><cell>0.824</cell><cell>0.239</cell><cell cols="2">0.189 0.494 0.427</cell></row><row><cell>COL ⇒ MOZ</cell><cell>0.830</cell><cell>0.148</cell><cell cols="2">0.168 0.367 0.240</cell></row><row><cell>COL ⇒ POS</cell><cell>0.825</cell><cell>0.167</cell><cell cols="2">0.023 0.533 0.432</cell></row><row><cell>JDT ⇒ BUG</cell><cell>0.757</cell><cell>0.376</cell><cell cols="2">0.052 0.435 0.432</cell></row><row><cell>JDT ⇒ COL</cell><cell>0.721</cell><cell>0.378</cell><cell cols="2">0.077 0.641 0.702</cell></row><row><cell>JDT ⇒ PLA</cell><cell>0.733</cell><cell>0.277</cell><cell cols="2">0.184 0.494 0.427</cell></row><row><cell>JDT ⇒ MOZ</cell><cell>0.740</cell><cell>0.168</cell><cell cols="2">0.173 0.367 0.240</cell></row><row><cell>JDT ⇒ POS</cell><cell>0.749</cell><cell>0.299</cell><cell cols="2">0.020 0.533 0.432</cell></row><row><cell>PLA ⇒ BUG</cell><cell>0.768</cell><cell>0.367</cell><cell cols="2">0.084 0.435 0.432</cell></row><row><cell>PLA ⇒ COL</cell><cell>0.763</cell><cell>0.363</cell><cell cols="2">0.130 0.641 0.702</cell></row><row><cell>PLA ⇒ JDT</cell><cell>0.772</cell><cell>0.152</cell><cell cols="2">0.229 0.582 0.490</cell></row><row><cell>PLA ⇒ MOZ</cell><cell>0.780</cell><cell>0.168</cell><cell cols="2">0.207 0.367 0.240</cell></row><row><cell>PLA ⇒ POS</cell><cell>0.780</cell><cell>0.230</cell><cell cols="2">0.053 0.533 0.432</cell></row><row><cell>MOZ ⇒ BUG</cell><cell>0.592</cell><cell>0.350</cell><cell cols="2">0.075 0.435 0.432</cell></row><row><cell>MOZ ⇒ COL</cell><cell>0.572</cell><cell>0.247</cell><cell cols="2">0.104 0.641 0.702</cell></row><row><cell>MOZ ⇒ JDT</cell><cell>0.587</cell><cell>0.057</cell><cell cols="2">0.066 0.582 0.490</cell></row><row><cell>MOZ ⇒ PLA</cell><cell>0.580</cell><cell>0.173</cell><cell cols="2">0.265 0.494 0.427</cell></row><row><cell>MOZ ⇒ POS</cell><cell>0.584</cell><cell>0.135</cell><cell cols="2">0.030 0.533 0.432</cell></row><row><cell>POS ⇒ BUG</cell><cell>0.711</cell><cell>0.351</cell><cell cols="2">0.052 0.435 0.432</cell></row><row><cell>POS ⇒ COL</cell><cell>0.690</cell><cell>0.439</cell><cell cols="2">0.107 0.641 0.702</cell></row><row><cell>POS ⇒ JDT</cell><cell>0.703</cell><cell>0.159</cell><cell cols="2">0.063 0.582 0.490</cell></row><row><cell>POS ⇒ PLA</cell><cell>0.700</cell><cell>0.261</cell><cell cols="2">0.255 0.494 0.427</cell></row><row><cell>POS ⇒ MOZ</cell><cell>0.706</cell><cell>0.159</cell><cell cols="2">0.185 0.367 0.240</cell></row><row><cell>Average</cell><cell>0.730</cell><cell>0.263</cell><cell cols="2">0.149 0.509 0.454</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 9 :</head><label>9</label><figDesc>MULTI-M vs Top Two Supervised and Unsupervised Methods in Cross-Project Scenario using P OP T</figDesc><table><row><cell>Source ⇒</cell><cell></cell><cell>Supervised</cell><cell></cell><cell cols="2">Unsupervised</cell></row><row><cell>Target</cell><cell cols="3">MULTI-M EALR AB+LMT</cell><cell>LT</cell><cell>AGE</cell></row><row><cell>BUG ⇒ COL</cell><cell>0.894</cell><cell>0.701</cell><cell>0.569</cell><cell cols="2">0.858 0.868</cell></row><row><cell>BUG ⇒ JDT</cell><cell>0.923</cell><cell>0.592</cell><cell>0.599</cell><cell cols="2">0.815 0.769</cell></row><row><cell>BUG ⇒ PLA</cell><cell>0.922</cell><cell>0.695</cell><cell>0.613</cell><cell cols="2">0.770 0.740</cell></row><row><cell>BUG ⇒ MOZ</cell><cell>0.918</cell><cell>0.563</cell><cell>0.576</cell><cell cols="2">0.660 0.622</cell></row><row><cell>BUG ⇒ POS</cell><cell>0.918</cell><cell>0.603</cell><cell>0.646</cell><cell cols="2">0.810 0.762</cell></row><row><cell>COL ⇒ BUG</cell><cell>0.945</cell><cell>0.633</cell><cell>0.354</cell><cell cols="2">0.726 0.758</cell></row><row><cell>COL ⇒ JDT</cell><cell>0.945</cell><cell>0.418</cell><cell>0.276</cell><cell cols="2">0.815 0.769</cell></row><row><cell>COL ⇒ PLA</cell><cell>0.944</cell><cell>0.506</cell><cell>0.313</cell><cell cols="2">0.770 0.740</cell></row><row><cell>COL ⇒ MOZ</cell><cell>0.946</cell><cell>0.476</cell><cell>0.448</cell><cell cols="2">0.660 0.622</cell></row><row><cell>COL ⇒ POS</cell><cell>0.943</cell><cell>0.426</cell><cell>0.337</cell><cell cols="2">0.810 0.762</cell></row><row><cell>JDT ⇒ BUG</cell><cell>0.895</cell><cell>0.674</cell><cell>0.437</cell><cell cols="2">0.726 0.758</cell></row><row><cell>JDT ⇒ COL</cell><cell>0.876</cell><cell>0.564</cell><cell>0.437</cell><cell cols="2">0.858 0.868</cell></row><row><cell>JDT ⇒ PLA</cell><cell>0.883</cell><cell>0.555</cell><cell>0.402</cell><cell cols="2">0.770 0.740</cell></row><row><cell>JDT ⇒ MOZ</cell><cell>0.885</cell><cell>0.502</cell><cell>0.486</cell><cell cols="2">0.660 0.622</cell></row><row><cell>JDT ⇒ POS</cell><cell>0.891</cell><cell>0.514</cell><cell>0.324</cell><cell cols="2">0.810 0.762</cell></row><row><cell>PLA ⇒ BUG</cell><cell>0.895</cell><cell>0.685</cell><cell>0.409</cell><cell cols="2">0.726 0.758</cell></row><row><cell>PLA ⇒ COL</cell><cell>0.889</cell><cell>0.564</cell><cell>0.356</cell><cell cols="2">0.858 0.868</cell></row><row><cell>PLA ⇒ JDT</cell><cell>0.897</cell><cell>0.458</cell><cell>0.414</cell><cell cols="2">0.815 0.769</cell></row><row><cell>PLA ⇒ MOZ</cell><cell>0.899</cell><cell>0.498</cell><cell>0.511</cell><cell cols="2">0.660 0.622</cell></row><row><cell>PLA ⇒ POS</cell><cell>0.899</cell><cell>0.478</cell><cell>0.451</cell><cell cols="2">0.810 0.762</cell></row><row><cell>MOZ ⇒ BUG</cell><cell>0.806</cell><cell>0.619</cell><cell>0.438</cell><cell cols="2">0.726 0.758</cell></row><row><cell>MOZ ⇒ COL</cell><cell>0.793</cell><cell>0.482</cell><cell>0.457</cell><cell cols="2">0.858 0.868</cell></row><row><cell>MOZ ⇒ JDT</cell><cell>0.803</cell><cell>0.367</cell><cell>0.400</cell><cell cols="2">0.815 0.769</cell></row><row><cell>MOZ ⇒ PLA</cell><cell>0.799</cell><cell>0.414</cell><cell>0.416</cell><cell cols="2">0.770 0.740</cell></row><row><cell>MOZ ⇒ POS</cell><cell>0.800</cell><cell>0.382</cell><cell>0.443</cell><cell cols="2">0.810 0.762</cell></row><row><cell>POS ⇒ BUG</cell><cell>0.902</cell><cell>0.629</cell><cell>0.315</cell><cell cols="2">0.726 0.758</cell></row><row><cell>POS ⇒ COL</cell><cell>0.884</cell><cell>0.617</cell><cell>0.431</cell><cell cols="2">0.858 0.868</cell></row><row><cell>POS ⇒ JDT</cell><cell>0.897</cell><cell>0.459</cell><cell>0.400</cell><cell cols="2">0.815 0.769</cell></row><row><cell>POS ⇒ PLA</cell><cell>0.894</cell><cell>0.544</cell><cell>0.381</cell><cell cols="2">0.770 0.740</cell></row><row><cell>POS ⇒ MOZ</cell><cell>0.898</cell><cell>0.497</cell><cell>0.432</cell><cell cols="2">0.660 0.622</cell></row><row><cell>Average</cell><cell>0.889</cell><cell>0.537</cell><cell>0.436</cell><cell cols="2">0.773 0.753</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table 10 :</head><label>10</label><figDesc>MULTI-M vs Top Two Supervised and Unsupervised Methods in Timewise-Cross-</figDesc><table><row><cell cols="2">Validation Scenario using ACC</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>Supervised</cell><cell></cell><cell>Unsupervised</cell></row><row><cell>Project</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="3">MULTI-M EALR Ridor</cell><cell>LT</cell><cell>AGE</cell></row><row><cell>BUG</cell><cell>0.598</cell><cell>0.286</cell><cell cols="2">0.218 0.449 0.375</cell></row><row><cell>COL</cell><cell>0.686</cell><cell>0.400</cell><cell cols="2">0.200 0.440 0.568</cell></row><row><cell>JDT</cell><cell>0.625</cell><cell>0.323</cell><cell cols="2">0.197 0.452 0.408</cell></row><row><cell>PLA</cell><cell>0.688</cell><cell>0.305</cell><cell cols="2">0.204 0.432 0.429</cell></row><row><cell>MOZ</cell><cell>0.549</cell><cell>0.180</cell><cell cols="2">0.187 0.363 0.280</cell></row><row><cell>POS</cell><cell>0.592</cell><cell>0.356</cell><cell cols="2">0.165 0.432 0.426</cell></row><row><cell>Average</cell><cell>0.623</cell><cell>0.308</cell><cell cols="2">0.195 0.428 0.414</cell></row><row><cell>W/D/L</cell><cell>-</cell><cell cols="3">6/0/0 6/0/0 6/0/0 6/0/0</cell></row><row><cell>5.4. Discussions</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">In this subsection, we firstly use a specific case to illustrate why our proposed</cell></row><row><cell cols="5">method MULTI is promising. In this case, we use the dataset from Bugzilla as</cell></row><row><cell cols="5">the training set, and use the dataset from Columba as the testing set. Then</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>Table 11 :</head><label>11</label><figDesc>MULTI-M vs Top Two Supervised and Unsupervised Methods in Timewise-Cross-</figDesc><table><row><cell cols="2">Validation Scenario using P OP T</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>Supervised</cell><cell></cell><cell>Unsupervised</cell></row><row><cell>Project</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="3">MULTI-M EALR Ridor</cell><cell>LT</cell><cell>AGE</cell></row><row><cell>BUG</cell><cell>0.838</cell><cell>0.596</cell><cell cols="2">0.480 0.721 0.661</cell></row><row><cell>COL</cell><cell>0.885</cell><cell>0.619</cell><cell cols="2">0.429 0.732 0.786</cell></row><row><cell>JDT</cell><cell>0.828</cell><cell>0.590</cell><cell cols="2">0.443 0.709 0.685</cell></row><row><cell>PLA</cell><cell>0.859</cell><cell>0.583</cell><cell cols="2">0.476 0.717 0.709</cell></row><row><cell>MOZ</cell><cell>0.786</cell><cell>0.498</cell><cell cols="2">0.466 0.651 0.638</cell></row><row><cell>POS</cell><cell>0.837</cell><cell>0.600</cell><cell cols="2">0.398 0.742 0.731</cell></row><row><cell>Average</cell><cell>0.839</cell><cell>0.581</cell><cell cols="2">0.449 0.712 0.702</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>Table 12 :</head><label>12</label><figDesc>Model Construction Time of Different Supervised Methods (Unit: Seconds)</figDesc><table><row><cell>Method</cell><cell cols="6">BUG COL JDT PLA MOZ POS</cell></row><row><cell>MULTI</cell><cell cols="6">24.10 20.91 55.82 98.20 57.30 57.42</cell></row><row><cell>EALR</cell><cell>0.40</cell><cell>0.22</cell><cell>0.55</cell><cell>0.90</cell><cell>0.93</cell><cell>0.83</cell></row><row><cell>SL</cell><cell>0.55</cell><cell>0.55</cell><cell>1.73</cell><cell>2.84</cell><cell>1.93</cell><cell>1.43</cell></row><row><cell>RBFNet</cell><cell>0.11</cell><cell>0.09</cell><cell>0.19</cell><cell>0.28</cell><cell>0.16</cell><cell>0.17</cell></row><row><cell>SMO</cell><cell>0.37</cell><cell>0.27</cell><cell cols="3">4.44 10.51 2.74</cell><cell>6.43</cell></row><row><cell>Ibk</cell><cell>1.49</cell><cell cols="5">1.01 12.62 35.22 10.37 9.68</cell></row><row><cell>Jrip</cell><cell>0.39</cell><cell>0.21</cell><cell>0.69</cell><cell>1.71</cell><cell>2.17</cell><cell>1.30</cell></row><row><cell>Ridor</cell><cell>0.29</cell><cell>0.24</cell><cell>1.58</cell><cell>3.39</cell><cell>1.02</cell><cell>1.28</cell></row><row><cell>NB</cell><cell>0.06</cell><cell>0.05</cell><cell>0.12</cell><cell>0.17</cell><cell>0.09</cell><cell>0.10</cell></row><row><cell>J48</cell><cell>0.10</cell><cell>0.10</cell><cell>0.35</cell><cell>0.67</cell><cell>0.31</cell><cell>0.26</cell></row><row><cell>LMT</cell><cell>1.18</cell><cell cols="5">1.76 13.49 25.63 12.47 6.72</cell></row><row><cell>RF</cell><cell>1.83</cell><cell>1.42</cell><cell cols="3">6.42 10.65 5.03</cell><cell>5.26</cell></row><row><cell cols="4">BG+LMT 29.10 32.73 2.30</cell><cell>5.72</cell><cell>1.86</cell><cell>1.54</cell></row><row><cell>BG+NB</cell><cell>0.26</cell><cell>0.24</cell><cell>0.72</cell><cell>1.14</cell><cell>0.62</cell><cell>0.63</cell></row><row><cell>BG+SL</cell><cell>6.11</cell><cell cols="5">4.64 19.71 37.31 17.25 14.90</cell></row><row><cell cols="2">BG+SMO 3.19</cell><cell cols="5">2.44 41.41 1.72 27.39 57.47</cell></row><row><cell>BG+J48</cell><cell>0.78</cell><cell>0.77</cell><cell>3.51</cell><cell>8.38</cell><cell>3.11</cell><cell>3.12</cell></row><row><cell cols="4">AB+LMT 31.09 26.66 3.50</cell><cell>5.55</cell><cell>1.86</cell><cell>2.46</cell></row><row><cell>AB+NB</cell><cell>0.61</cell><cell>0.39</cell><cell>1.82</cell><cell>2.29</cell><cell>1.52</cell><cell>1.48</cell></row><row><cell>AB+SL</cell><cell>3.00</cell><cell cols="4">1.78 15.14 16.80 9.23</cell><cell>7.95</cell></row><row><cell cols="2">AB+SMO 3.36</cell><cell cols="5">1.47 18.68 1.78 25.81 18.89</cell></row><row><cell>AB+J48</cell><cell>0.58</cell><cell>0.47</cell><cell>2.05</cell><cell>4.71</cell><cell>2.10</cell><cell>2.17</cell></row><row><cell cols="4">RF+LMT 32.96 16.22 1.72</cell><cell>4.76</cell><cell>1.31</cell><cell>1.31</cell></row><row><cell>RF+NB</cell><cell>0.75</cell><cell>0.60</cell><cell>1.99</cell><cell>2.98</cell><cell>1.57</cell><cell>1.58</cell></row><row><cell>RF+SL</cell><cell>7.80</cell><cell cols="5">5.13 19.32 48.59 18.01 16.83</cell></row><row><cell>RF+SMO</cell><cell>2.28</cell><cell cols="5">1.63 25.80 1.02 16.48 39.37</cell></row><row><cell>RF+J48</cell><cell>1.27</cell><cell>0.89</cell><cell>4.90</cell><cell>8.83</cell><cell>3.91</cell><cell>3.41</cell></row><row><cell cols="7">RS+LMT 11.41 9.15 50.38 53.30 38.07 36.80</cell></row><row><cell>RS+NB</cell><cell>0.16</cell><cell>0.15</cell><cell>0.39</cell><cell>0.65</cell><cell>0.37</cell><cell>0.36</cell></row><row><cell>RS+SL</cell><cell>4.50</cell><cell cols="5">3.77 16.40 20.39 12.50 11.73</cell></row><row><cell>RS+SMO</cell><cell>2.46</cell><cell cols="5">2.53 20.63 4.22 53.64 1.64</cell></row><row><cell>RS+J48</cell><cell>0.25</cell><cell>0.21</cell><cell>0.84</cell><cell>1.78</cell><cell>0.81</cell><cell>0.71</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgment</head><p>The authors would like to thank the editors and the anonymous reviewers for their insightful comments and suggestions, which can substantially improve the quality of this work. This work is supported in part by National Natural Science Foundation of China (Grant Nos. 61202006, 61602267), Guangxi Key Laboratory of Trusted Software (Grant No. kx201610), and Open Project of State Key Laboratory for Novel Software Technology at Nanjing University (Grant No. KFKT2016B18).</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Except for ACC and P OP T performance metrics which are widely used in effort-aware JIT-SDP, we also compare MULTI using F 1 performance metric which is used in previous SDP <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b9">9,</ref><ref type="bibr" target="#b16">16,</ref><ref type="bibr" target="#b34">33]</ref> research. To be consistent with previous studies, we restrict our efforts to 20% of the entire efforts and predict these changes as buggy changes. We use precision to denote the percentage of actual buggy changes to all the predicted buggy changes, and use recall (i.e., ACC metric in this article) to denote the percentage of predicted buggy changes to all the actual buggy changes. F 1 is the harmonic mean of precison and recall. Due to the limitation of this article, we show the result of Scott-Knott test in cross-project scenario in Fig. <ref type="figure">12</ref>. From this Figure, we can find that MULTI can still perform significantly better than all the baseline methods when using F 1 metric. For F 1 metric, based on average value, we can find that our MULTI-M can improve 24%, 45%, 18%, and 9% on average when compared to the best two supervised methods (i.e., EALR and BG+J48) and the best two unsupervised methods (i.e., AGE and LT).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.4.">Model Construction Time Cost Analysis</head><p>Here we analyze the model construction time cost of MULTI. Since unsupervised methods do not need training set and are very simple (i.e., compute the defect-proness probability only by using the specific metric value), their running</p><p>For other researchers to follow our work, we provide a package 1 to repeat our empirical studies. This package includes: </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A systematic literature review on fault prediction performance in software engineering</title>
		<author>
			<persName><forename type="first">T</forename><surname>Hall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Beecham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bowes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Counsell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1276" to="1304" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Defect prediction: Accomplishments and future challenges</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kamei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shihab</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Conference on Software Analysis, Evolution, and Reengineering</title>
		<meeting>International Conference on Software Analysis, Evolution, and Reengineering</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="33" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Evaluating defect prediction approaches: A benchmark and an extensive comparison</title>
		<author>
			<persName><forename type="first">M</forename><surname>D'ambros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lanza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Robbes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Empirical Software Engineering</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">4-5</biblScope>
			<biblScope unit="page" from="531" to="577" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">C</forename><surname>C E P T E D M A N U S C R I P T</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Software fault prediction metrics: A systematic literature review</title>
		<author>
			<persName><forename type="first">D</forename><surname>Radjenovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hericko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Torkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zivkovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Software Technology</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1397" to="1418" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A large-scale empirical study of just-in-time quality assurance</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kamei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shihab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">E</forename><surname>Hassan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mockus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sinha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ubayashi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="757" to="773" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Predicting risk of software changes</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mockus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Weiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bell Labs Technical Journal</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="169" to="180" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Classifying software changes: Clean or buggy?</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J W</forename><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="181" to="196" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Effortaware just-in-time defect prediction: Simple unsupervised models could be better than supervised models</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Leung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGSOFT International Symposium on Foundations of Software Engineering</title>
		<meeting>ACM SIGSOFT International Symposium on Foundations of Software Engineering</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="157" to="168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Deep learning for just-in-time defect prediction</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Conference on Software Quality, Reliability and Security</title>
		<meeting>International Conference on Software Quality, Reliability and Security</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="17" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Tlel: A two-layer ensemble learning approach for just-in-time defect prediction</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Software Technology</title>
		<imprint>
			<biblScope unit="volume">87</biblScope>
			<biblScope unit="page" from="206" to="220" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The relationship between search based software engineering and predictive modeling</title>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Predictive Models in Software Engineering</title>
		<meeting>the International Conference on Predictive Models in Software Engineering</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">13</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A fast and elitist multiobjective genetic algorithm: Nsga-ii</title>
		<author>
			<persName><forename type="first">K</forename><surname>Deb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pratap</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Meyarivan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Evolutionary Computation</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="182" to="197" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">When do changes induce fixes?</title>
		<author>
			<persName><forename type="first">J</forename><surname>Śliwerski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Zimmermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zeller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Workshop on Mining Software Repositories</title>
		<meeting>the International Workshop on Mining Software Repositories</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="1" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Studying just-in-time defect prediction using cross-project models</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kamei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Fukushima</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mcintosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Yamashita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ubayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">E</forename><surname>Hassan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Empirical Software Engineering</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="2072" to="2106" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Revisiting unsupervised learning for defect prediction</title>
		<author>
			<persName><forename type="first">W</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Menzies</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of The joint meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering</title>
		<meeting>The joint meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Reducing features to improve code change-based bug prediction</title>
		<author>
			<persName><forename type="first">S</forename><surname>Shivaji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J</forename><surname>Whitehead</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Akella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="552" to="569" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Defect prediction as a multi-objective optimization problem</title>
		<author>
			<persName><forename type="first">G</forename><surname>Canfora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Lucia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Penta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Oliveto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Panichella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Panichella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software Testing Verification and Reliability</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="426" to="459" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Mansouri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Search-based software engineering: Trends, techniques and applications</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page">61</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Revisiting the impact of classification techniques on the performance of defect prediction models</title>
		<author>
			<persName><forename type="first">B</forename><surname>Ghotra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mcintosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">E</forename><surname>Hassan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Software Engineering</title>
		<meeting>the International Conference on Software Engineering</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="789" to="800" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Benchmarking classification models for software defect prediction: A proposed framework and novel findings</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lessmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Baesens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Mues</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pietsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="485" to="496" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Automated parameter optimization of classification techniques for defect prediction models</title>
		<author>
			<persName><forename type="first">C</forename><surname>Tantithamthavorn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mcintosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">E</forename><surname>Hassan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Matsumoto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Software Engineering</title>
		<meeting>the International Conference on Software Engineering</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="321" to="332" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">An empirical comparison of model validation techniques for defect prediction models</title>
		<author>
			<persName><forename type="first">C</forename><surname>Tantithamthavorn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mcintosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">E</forename><surname>Hassan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Matsumoto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="18" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Predicting faults using the complexity of code changes</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">E</forename><surname>Hassan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Software Engineering</title>
		<meeting>the International Conference on Software Engineering</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="78" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Use of relative code churn measures to predict system defect density</title>
		<author>
			<persName><forename type="first">N</forename><surname>Nagappan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Software Engineering</title>
		<meeting>the International Conference on Software Engineering</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="284" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A comparative analysis of the efficiency of change metrics and static code attributes for defect prediction</title>
		<author>
			<persName><forename type="first">R</forename><surname>Moser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Pedrycz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Succi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Software Engineering</title>
		<meeting>the International Conference on Software Engineering</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="181" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Predicting fault incidence using software change history</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">L</forename><surname>Graves</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">F</forename><surname>Karr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Marron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Siy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="653" to="661" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">An analysis of developer metrics for fault prediction</title>
		<author>
			<persName><forename type="first">S</forename><surname>Matsumoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Kamei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Monden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>-I. Matsumoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Nakamura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Predictive Models in Software Engineering</title>
		<meeting>the International Conference on Predictive Models in Software Engineering</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page">9</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A systematic and comprehensive investigation of methods to build and evaluate fault prediction models</title>
		<author>
			<persName><forename type="first">E</forename><surname>Arisholm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Briand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">B</forename><surname>Johannessen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Systems and Software</title>
		<imprint>
			<biblScope unit="volume">83</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="2" to="17" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title/>
		<author>
			<persName><surname>A C C E P T E D M A N U S C R I P T</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Effort-aware defect prediction models</title>
		<author>
			<persName><forename type="first">T</forename><surname>Mende</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Koschke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European Conference on Software Maintenance and Reengineering</title>
		<meeting>the European Conference on Software Maintenance and Reengineering</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="107" to="116" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Predicting the location and number of faults in large software systems</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Ostrand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J</forename><surname>Weyuker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Bell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="340" to="355" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Defect prediction from static code features: Current results, limitations, new approaches</title>
		<author>
			<persName><forename type="first">T</forename><surname>Menzies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Milton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Turhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Cukic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bener</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Automated Software Engineering</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="375" to="407" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">An in-depth study of the potentially confounding effect of class size in fault prediction</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Leung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Software Engineering and Methodology</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">51</biblScope>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Clami: Defect prediction on unlabeled datasets</title>
		<author>
			<persName><forename type="first">J</forename><surname>Nam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Conference on Automated Software Engineering</title>
		<meeting>International Conference on Automated Software Engineering</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="452" to="463" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Cross-project defect prediction using a connectivity-based unsupervised classifier</title>
		<author>
			<persName><forename type="first">F</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">E</forename><surname>Hassan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Software Engineering</title>
		<meeting>the International Conference on Software Engineering</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="309" to="320" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Evolutionary Algorithms for Solving Multi-Objective Problems</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A C</forename><surname>Coello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">B</forename><surname>Lamont</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A V</forename><surname>Veldhuizen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>Springer US</publisher>
		</imprint>
	</monogr>
	<note>Second Edition</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Controlling the false discovery rate: A practical and powerful approach to multiple testing</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Benjamini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Hochberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Royal Statistical Society. Series B (Methodological)</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="289" to="300" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Scottknott: a package for performing the scott-knott clustering algorithm in r</title>
		<author>
			<persName><forename type="first">E</forename><surname>Jelihovschi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Faria</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Allaman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TEMA (Sao Carlos)</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="17" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
