<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">NONDETERMINISM WITHIN P*</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jonathan</forename><forename type="middle">F</forename><surname>Buss</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Judy</forename><surname>Goldsmith</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Mathematics and Computer Science</orgName>
								<orgName type="institution">Dartmouth College</orgName>
								<address>
									<settlement>Hanover</settlement>
									<region>New Hampshire</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">tDepartment of Computer Science</orgName>
								<orgName type="institution">University of Waterloo</orgName>
								<address>
									<postCode>N2L 3G1</postCode>
									<region>Ontario</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Manitoba</orgName>
								<address>
									<postCode>R3T 2N2</postCode>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">NONDETERMINISM WITHIN P*</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">57ABCB46FB7E5622163CA1A639C8475C</idno>
					<note type="submission">Received by the editors October 29, 1990; accepted for publication (in revised form) March 13, 1992.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T10:35+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Classes of machines using very limited amounts of nondeterminism are studied. The P -? NP question is related to questions about classes lying within P. Complete sets for these classes are given. Key words, nondeterminism, quasilinear time, computational complexity AMS(MOS) subject classifications. 68Q15, 68Q05 1. Introduction. Traditional complexity theory gives a distinguished role to the class P of languages that are computable in polynomial time. Languages not in P are consid- ered to be computationally intractable. However, the converse assertion, that languages in P have efficient solutions, is untenable. Historically, one reason for the choice of poly- nomial time bounds was that no smaller class appears to be as robust against change of model. We consider here subclasses of P, defined (roughly) according to the exponent of the polynomial bounding the running time and also according to the small amount of nondeterminism allowed. Of particular interest is the class of languages computable in deterministic "quasilinear" time, which is less robust than P with respect to change of model, but is much closer to being a practical notion of feasible computation. We de- velop a complexity theory based on quasilinear-time many-one reducibility that is anal- ogous to the theory of polynomial-time reducibility.</p><p>We primarily consider the trade-off between time and nondeterminism. To replace nondeterminism by time in Turing machine computations is easy: one binary nondeter- ministic choice may be eliminated by doubling the time. Two fundamental questions are whether nondeterminism can be eliminated at a lower cost in time, and whether computation time can be decreased by adding nondeterminism. We define subclasses of P by limiting the time bound to fixed-degree polynomials and allowing nondeterminism over a fixed polynomial-size search space. The inclusion relationships among the classes are particular cases of the two fundamental questions. We show that sufficient separation among these classes lying inside P implies that P # NP.</p><p>Let,,f and g be integer functions. We will write "f E Q(g)" and say "f is of quasi- k order 7 if there "s a pos'tive constant k such that f E O(g log g). For any positive con- stant l, we denote by P the class of languages that can be accepted by a multitape Turing machine whose running time on inputs of length n is of quasi-order nt. For integers _&gt; 1 and m _&gt; 0, we denote by NmPt the class of languages accepted by nondetermin- istic machines in time of quasi-order n making at most m log binary nondctcrministic choices. For any m and l, NmP is contained in P,+. We will also consider the classes NP having no bound on the amount of nondeterminism. The classes P1 and NP1 have been previously studied by Schnorr [16] under the names QL and NQL.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The log n factors in the allowed time bounds have a number of important conse- quences. First, the classes are independent of the number of tapes of a multitape Turing machine. Second, quasilinear-time reducibility is transitive and preserves membership in N'Pt, for any m and I. Third, quasilinear time is large enough to admit basic al- gorithmic techniques such as sorting and multiplication. For computation of practical importance, the input size is generally less than, say, 10xz; hence log n is bounded by 40, and ignoring arbitrary logarithmic factors is no worse than ignoring arbitrary constant factors.</p><p>The notion of classifying problems according to the amount of nondeterminism required has appeared previously; see, e.g., Kintala and Fischer [13] and Wolf [17].</p><p>Alvarez, Dfaz, and Torfin, <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b7">[8]</ref> consider a hierarchy, similar to the present one, of classes lying between P and NP. Their hierarchy differs from the present one in two ways. First, any polynomial is allowed in the running times, and second, the bound on the number of nondeterministic choices that defines each class is a power of log n rather than a multiple of log n. Thus each class contains all of P, and the hierarchy does not provide a classification among computations feasible in practice.</p><p>More similar in method to the present paper is the work of Geske <ref type="bibr" target="#b8">[9]</ref>, who considers relations among classes TIME(n) and NTIME(nt), which are similar to and NP, but more restrictive. Weaker variants of our Theorems 5.1 and 5.4 are obtained.</p><p>In a related work, Kaye <ref type="bibr" target="#b11">[12]</ref> gives two logical characterizations of a family of classes L(), a &gt; 0, lying between linear time and P. Kaye's class L is precisely quasilinear time.</p><p>Gurevich and Shelah <ref type="bibr" target="#b9">[10]</ref> consider quasilinear-time reductions among various mod- els of random-access machines. They define nearly linear time, or NLT, and show that the models they consider, including Kolmogorov machines, Sch6nhage machines, and random-access Turing machines, all compute the same NLT functions in quasilinear time. They also show that the languages accepted nondeterministically by any of these machines in quasilinear time are precisely those languages accepted nondeterministically in quasilinear time by a multitape Turing machine (denoted NQL in [16], herein NP). They conjecture that the deterministic classes NLT and QL (herein P) are different.</p><p>We offer some candidate languages for this separation.</p><p>Quasilinear-time reductions have been studied in other contexts as well. Hunt and Stearns [11] define the notion of Turing-SAT-hard (n polylog n, n) in order to make pre- cise the notion that sets in NP have deterministic time and space complexity no less than that of SAT. Their definition restricts the reductions considered to quasilinear time and linear space complexity. Because the sets they consider are in NP P unless P NP, their results do not provide much insight into the classes considered here.</p><p>Abrahamson et al. <ref type="bibr" target="#b0">[1]</ref>, [2] study the complexity of families of languages parameter- ized by the size of an associated search space. The present paper concerns the complexity of individual problems, which may or may not be part of a larger family. The relationship between the two approaches is investigated in 4 below.</p><p>This paper is organized as follows. Section 2 gives some basic properties of the classes N'Pt and Pt. Section 3 shows that the classes have complete sets, and some nat- ural problems are considered as candidate complete sets. Section 4 contains a discussion of the relationship of the present work to that of Abrahamson et al. Section 5 investi- gates relationships among the various classes N'P,. Section 6 concludes with some open problems and directions for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>Preliminaries. The classes NmP can be characterized in terms ofwitnesses, anal- ogously to NP.</p><p>THEOREM 2.1. For all m and l, a set A is in N'P if and only if there is an R in Pt such that for all sngs x, x E A y [lyl &lt;_ m log n(x, y)].</p><p>The proof is left to the reader. Like most hierarchies of complexity classes, the limited-nondeterminism classes ex- hibit downward separation (upward collapse).</p><p>THEOREM 2.2. For all m and l, 1. if NP c_ Pt, then N IPk C_ Pk for all k &gt;_ l, and 2. if Nm+IP c_ Nmpt, then Nkpt C_ Nmpt for all k &gt;_ m. Proof (sketch). Suppose that NPt c_ P, and fix k &gt; and A N Pk. Let R be as guaranteed in the previous result. Let A' { xO [llk/lj-Il x A }. Then x0 A' if and onlyifj Ilxlk/l--Ixl / SY lyl &lt;log Ixl A R(x, y) if and onlyif2y lYl &lt; log Ix0 I/x R'(xO , y), where R' { (xO , y) J llxlk/'J -Ixl/ y _&lt; log Ixl/ R(x, y) }. Hence A' ( NIp/C_ P/, and thus A P. Now suppose that Nm+lPt C_ N'Pt, and fix k &gt; m + 1 and B Nkpt. There exists S such that x E B = 3y lyl &lt;-k log Ixl/ (x, y&gt; s. The latter condition is equivalent to Sy lYl &lt; (k m 1)log Ixl/X s'(x, y), where S' { (x, y) Sz z &lt; (m + 1) log Ixl/x (x, yz) S } is in Nm+IP and hence in N'Pt by assumption. Thus B Nk-XPt, which is contained in Nmpt by induction.</p><p>The hierarchy also exhibits a kind of upward separation.</p><p>THEOREM 2.3. Suppose that for all l, there is an m such that Nmp is not contained in Pt. Then P NP.</p><p>The result follows immediately from Theorem 2.4. THEOREM 2.4./f P NP, then there is an such that NPk C_ Pkt for all k. Proof. Let L be a complete set for NP with respect to quasilinear-time reductions.</p><p>(Schnorr has shown that SAT, the set of satisfiable Boolean formulas, is such a set <ref type="bibr" target="#b15">[16]</ref>.) Suppose P NP; i.e., L is in/ for some I. Let A NPk. Membership questions of length n about A are reducible in time Q(nk) to membership questions of length Q(nk) about L (using a padding argument and Schnorr's result), which are answerable in time Q(nkt) by assumption. Hence NPk C_ Pkg.</p><p>3. Complete sets. The sets N'Pt all have complete sets under quasilinear-time re- ducibility. We consider first a problem concerning acceptance by Turing machines. Let (.) be a coding function for Turing machines such that given (M), a single step of M can be simulated by a multitape Turing machine in time proportional to log I(M)I. A unary code will have the required property.</p><p>Define G { (M)#x#lJ M accepts input x within jlxl t-1 steps using at most m log Ixl nondeterministic choices }. THEOREM 3.1. For all m and l, G' is complete for Nmpt with respect to quasilinear- time reductions.</p><p>Proof (sketch). The coding convention ensures that G N'P. For A N'Pt, fix a machine M and constants r and s such that M halts in at most rn log 8 n steps, uses m log n nondeterministic choices on inputs of length n, and accepts A. Let f(x) (M)#x#lrlxl log Ixl. Then x A if and only if f(x) G', and f is computable in time in Q(n). Hence f is the desired reduction from A to G.</p><p>In some cases, complete sets for Nmpt can be obtained from NP-complete problems by bounding the size of allowable witnesses for membership. We first consider topologi- cally ordered Boolean circuits. 2 A circuit is satisfiable if some setting of the inputs results 2A circuit is topologically ordered if each gate is numbered, and the inputs to a gate all have lower numbers than the gate itself. Downloaded 11/14/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php in an output of 1. Let CSAT(k) be the set of satisfiable, topologically ordered circuits that have fewer than k log n inputs, where n is the number of gates in the circuit. (Constants 0 and 1 are not counted as inputs.) THEOREM 3.2. Forall k, CSAT(k) is complete for NkP1 with respect to quasilinear-time reductions.</p><p>Proof(sketch). The standard methods for proving the formula-satisfiability problem to be NP-complete can easily be modified to produce a circuit rather than a formula.</p><p>Schnorr <ref type="bibr" target="#b15">[16]</ref> and Cook <ref type="bibr" target="#b6">[7]</ref> have shown that the circuit (or formula) corresponding to a given input for a fixed Turing machine may be constructed in quasilinear time. In particular, the circuit has quasilinear size. Also, it is topologically ordered.</p><p>Let A NPI, and let R P be such that x A v qy [Yl &lt;k log Ix[ A (x, y) R, for all strings x. Let M accept R in quasilinear time. The circuit Cu(x) corresponding to M with input (x, y), for fixed x and undetermined y, has size quasilinear in Ix and only k log Ix[ inputs. Hence x A if and only if Cu(x) CSAT(k), and CSAT(k) is hard for NkP1.</p><p>Evaluation of a circuit at given inputs can be accomplished in quasilinear time on a Turing machine by using an algorithm of eippenger <ref type="bibr" target="#b13">[14]</ref>. Hence CSAT(k) is in Nkp.</p><p>[:]</p><p>The satisfiability problem for formulas with a limited number ofvariables, SAT(k), is perhaps easier than CSAT(k). The above proof of hardness of CSAT(k) does not apply to SAT(k), because too many auxiliary variables are required in a formula to simulate a Tur- ing machine. In the absence of a hardness proof for the restricted formula-satisfiability problem, hardness proofs for restrictions of other standard NP-complete problems are problematic. In some cases, the natural restriction is essentially as hard as the general case. For example, graph k-colorability remains NP-complete when k is fixed at .</p><p>The restricted vertex-cover problem exhibits different behaviour. Let VC(k) be the language of undirected graphs that have a vertex cover of size k. It is easy to show that VC(k) is in N-P: the first k-1 vertices of a cover can be chosen nondeterministically, and the last vertex found by a quasilinear-time search. In fact, the language VC(k) can be accepted in linear time by the following algorithm due to S. Buss [5]. Given a graph a (V, E), 1. Let U be the set of vertices of degree more than k. If IUI &gt; k, then reject; there is no cover of size k or less.</p><p>2. Let G' be the subgraph of G induced by V U. Every k-cover of (7 consists of U together with a (k IUl)-cover of G'. If G' has more than k(k IUI) edges, then reject; G' has no (k -IUI)-cover.</p><p>3. If G' has a cover of size k IU[, then accept; otherwise reject.</p><p>Steps 1 and 2 can easily be implemented in quasilinear time. If step 3 is reached, then G' has a bounded number of edges; hence step 3 requires Q(1) time. Therefore, VC(k) is in P, and a completeness proof for VC(k) would have strong consequences.</p><p>THEOREM 3.3. IfVC(k) is hard for NiP1 for some j &gt; 1, then NmP1 C_ P1 for all m.</p><p>The result follows immediately from Theorem 2.2. The k-clique problem, although often regarded as a trivial variation on the k-vertex cover problem, cannot be substituted for VC(k) in the above proof, because the condi- tion on the degrees does not hold. Thus k-clique remains as a candidate hard problem for Nk-IpI.</p><p>3Diaz and Torfin <ref type="bibr" target="#b7">[8]</ref> have shown that a variant of CSAT(k) is complete under logspace reductions for their class Bk, for each k.</p><p>4We return to the formula-satisfiability problem in 4.</p><p>Next, we consider the following problem concerning context-free grammars. Given a grammar G (N, E, P, S), does G generate any string comprising repetitions of a r* single terminal; i.e., is (G) n I,Jer.</p><p>Let UNARYGEN be the set of grammars for which the answer is yes. THEOREM 3.4. CSAT(1) &lt;qt UNARYGEN.   Proof. Let C be a circuit with n gates gl,..., g,. Assume without loss of generality that gates i with i &lt; log n are the inputs and t, is the output. Each gate gs is represented by two nonterminal symbols A s and A). There are also n terminal symbols b0,.. , b,_ each corresponding to one setting of the values of the input variables. The start symbol is A,.</p><p>The productions are determined as follows.</p><p>If 9i is an and-gate with predecessors #s and tk, use productions A As Ak and a A A' .</p><p>If g is an or-gate with predecessors g and gk, use productions A A A and A A A.</p><p>If gi is a not-gate with predecessor gs, use productions Ai A and A For 1 &lt; &lt; log n, for all j such that bit i of the binary expansion of j is 1, use Ai -b.</p><p>For 1 &lt; &lt; log n, for all j such that bit i of the binary expansion of j is 0, use The variable A s derives a unary word if and only if gs evaluates to 1, and A s derives a unary word if and only if gj evaluates to 0. LEMMA 3.5. For all 1 &lt; i &lt; n and 0 &lt; j &lt; n 1, Ai * b for some k if and only if gi evaluates to I when the input vector is the binary expansion of j. Similarly, A b for some k if and only if gi evaluates to 0 when the input vector is the binary expansion of j.</p><p>Proof. Fix j. Define the level of a gate to be the length of the longest directed path from the gate to any input. We use induction on the level of gate g. The base case is that g is an input. Then g evaluates to 1 if and only if bit of j is 1 if and only if Ai bj if and only if Ai * b s. Also gi evaluates to 0 if and only if bit i of j is 0 if and only if A b s if and only if A * b s.</p><p>Suppose that the lemma holds for all gates with level at most 1, and let g have level 1. If g is an and-gate with predecessors gil and g., then g evaluates to 1 if and only 1 and Ai. * k. for some kl if both gx and gi evaluate to I if and only if Aix * b s b s and kg. if and only if Ai * b +k.. Likewise, gi evaluates to 0 if and only if either gix or gi evaluates to 0 if and only if A:,I --** b or A. --* b for some k if and only if A * b. The cases where g is a negation gate or an or-gate are similar.</p><p>The theorem follows immediately from the lemma. The reduction given in the proof holds even if the circuit is not topologically or- dered. If the circuit is ordered, then in the resulting grammar, every appearance of each nonterminal in the left-hand side of a production occurs after every appearance of the nonterminal on the right-hand side of a production. Call a grammar satisfying this condition an ordered grammar. Let UNARYGENord be the set of ordered grammars in UNARYGEN. THEOREM 3.6. UNARYGENord is complete for N Proof. Because the reduction of the previous theorem produces an ordered grammar from an ordered circuit, UNARYGENord is hard for N 1P1.</p><p>To show that UNARYGENord is in NP, we use the following lemma.</p><p>LEMMA 3.7. The emptiness problem for ordered context-free grammars is in determin- istic quasilinear time. Proof. Call a nonterminal "true" if some terminal string can be derived from it and "false" otherwise. The grammar is then a network in the sense of Pippenger <ref type="bibr" target="#b13">[14]</ref> and thus can be evaluated in time Q(n).</p><p>[3</p><p>Let G (N, E, P, S) be an ordered grammar. Nondeterministically guess a termi- nal tr E E, using log Irl &lt;_ log IGI bits. Then eliminate all productions involving termi- nals other than or. Accept if and only if the resulting grammar generates a nonempty language.</p><p>The above algorithm places UNARYGENord in N1P1, and hence it is complete. ] 4. Families ofeolastrained-seareh prollems. Many NP-complete problems involve a parameter that defines a constraint on the associated search problem. Restriction of this parameter produces a problem whose complexity falls into one of at least three classes: (1) The restricted problem may be NP-complete; e.g., graph k-coloring, for any k &gt; 3. (2) Every fixed value of the parameter may give the same polynomial com- plexity; e.g., vertex k-cover. (3) Every fixed value of the parameter may give polynomial- time complexity, but the exponent of the polynomial may depend on k. No instances of the third case are proven, but CSAT(k), k-clique and many other problems are candi- dates. The distinction between the second and third case has been recently investigated by Abrahamson et al. <ref type="bibr" target="#b0">[1]</ref>, [2], who considered families of associated search problems.</p><p>We show here that limited nondeterminism provides an alternative to their methods.</p><p>Consider the case of CSAT(k), for k &gt; 1. These languages form an infinite collec- tion of complete sets, one for each class NkPI. It is not an arbitrary collection, however, since the complete set for NkPI can easily be determined given k. We describe this situ- ation using the concept of languagefamily. A language family is a subset of E* N. The kth slice of a family B, denoted Bk, is the language { z (z, k) E B }.</p><p>The class N*Pj (for all j &gt; 1) consists of all families B with the following properties.</p><p>The kth slice of B is a language in NkPj.</p><p>There is a quasilinear-time-computable function f such that for all k, the value of f(k) is the code of a Turing machine witnessing that the kth slice of/3 is in NP.</p><p>(An object z wimesses an existential property 3t p(y) if and only if p(z) is true. The computability requirement on f may be relaxed without changing the essential character of the definition.)</p><p>A language family (7 in N*Pj is &lt;qt-complete for N*P if the following hold.</p><p>For all k, the slice C is complete for NPj. There is a quasilinear-time-computable function f such that for all k, the value of f(k) is the code of a Turing machine witnessing that C is complete for NP (i.e., the Turing machine performs a quasilinear-time reduction from G to Ck).</p><p>For example, the family CSAT(.) { (z, k) z CSAT(k) } is complete for N*P. We draw a second example from Abrahamson et al. <ref type="bibr" target="#b1">[2]</ref>. Consider a Boolean for- mula. A partial assignment of truth values to variables in the formula may induce values on other variables if the formula is to be true. Consider a formula in conjunctive normal form with three or fewer variables per clause (3CNF). If (a V a2 V a3) is a clause, and all but one of the ai's are false, then the remaining variable is induced to assume the value true; if one variable ai is true, then the clause is true, and no additional assignment is in- duced. If this procedure can be applied iteratively until all clauses evaluate to true, then we say the original partial assignment caused the formula to unravel. Let SHORTSAT(k) be the set of 3CNF formulas/3 such that some assignment to the first k log 1/31 variables causes B to unravel. 5The definition in <ref type="bibr" target="#b1">[2]</ref> allowed arbitrary CNF formulas instead of 3CNE The difference appears to be necessary for Theorem 4.1. It does not affect the results of <ref type="bibr" target="#b0">[1]</ref>. k A formula B =/ki=l C'i in conjunctive normal form unravels in order if each initial subformula A=I C' unravels. Let SHORTSATord (k) be the set of formulas B such that some assignment to the first k log IBI variables causes/3 to unravel in order. THEOREM 4.1. SHORTSATord(k /s &lt;q-complete for NP, and SHORTSAT(k) is &lt;_q-hard for NkP, for all k.</p><p>Proof (sketch). We first show that CSAT(k) &lt;qt SHORTSATord(k ). Let F be an instance of CSAT(k). The corresponding formula qa has one variable for each gate of the circuit, and two additional variables denoted z and z2. The first k log represent the input. The connections of a gate g in F are represented in qa by a con- junction B of clauses. The conjunction B always unravels in qo, and the only unravelling induces the variable representing g to take on the value of g. The final clause of qo un- ravels if and only if the circuit evaluates to 1.</p><p>The clauses are as follows.</p><p>For each input variable x of F, the corresponding clause is (x V -x).</p><p>If g is an and-gate with predecessors a and b, then the corresponding conjunction is (-a V -b V g) A (a V-g) A (b V -g).</p><p>If t is an or-gate with predecessors a and b, then the corresponding conjunction is (a V b V ,q) A (a V q) A (-b V ,q). If/? is a not-gate with predecessor a, then the corresponding conjunction is v v If the output gate is tout, the final clause is (gout V 2:1 V 2: 2).</p><p>The reader can easily check that the formula has the required properties.</p><p>To show that SHORTSATord(k &lt;qt CSAT(k), let qo be a formula in 3CNF, with clauses {qo}= 1. Each clause o will be represented by a circuit C, whose inputs will be outputs of the circuits representing earlier clauses. We assume without loss of gener- ality that no variable appears twice in any one clause.</p><p>Consider qo v V vz V va. The corresponding circuit C will have six inputs and six outputs. The circuit C will compute the status of each literal vq (either a variable or a negated variable) and produce two corresponding output values. Output vq (1) is given value I if and only if the unravelling procedure assigns a value to v at or before clause qo. If v (1) 1, then output v (2) is given the value assigned to v.</p><p>The inputs to C are determined by the last occurrences of the variables of qa previ- ous to qo{ itself. Denote by v the last literal containing the variable of v appearing in qo before qo. The first input corresponding to vi is v (1). The second input correspond- ing to vq is v (2) if v and v are both positive or both negative literals, and is -v (2)   otherwise. The construction of C' is straightforward except for the identification of the input literals v.</p><p>If each v is found individually, the construction of the entire circuit may take quadratic time. Hence the successive occurrences of each variable must all be deter- mined at once, as follows. For each v, form a triple (, i, j), where z is the index of the variable occurring in v. Sort the triples, using the order (z, i, j) &lt; (, k, I) if and only if z &lt; or z and &lt; k. If (z, i, j) and (z, k, 1) are adjacent in the sorted list, then vt v{; form a quadruple (i, j, k, 1). Sorting these quadruples gives the required adjacency information in the order needed to construct the circuit in topological order.</p><p>The final circuit comprises all subcircuits C' and an additional output subcircuit.</p><p>The output subcircuit computes A= V= v(1) A v(2) which has value 1 if and only if the original formula q unravels in order.</p><p>The family SHORTSATord(, { (z, k) z ESHORTSATord(k } is thus complete for N*P. Proof (sketch). To determine whether a formula is in SHORTSAT(k), it suf- fices to nondeterministically guess the values of the initial k log Iql variables, and then make at most I1 passes through , inducing variables and propagating their values, l]</p><p>A language family (7 is &lt;t-hardfor N*P if the following hold.</p><p>For all k, there is a k' &gt; k such that C, is &lt;-hard for NP.</p><p>There is a quasilinear-time-computable function f such that for all k, the value of f(k) is the code of a Turing machine witnessing that Ck, is &lt;qt-hard for NP.</p><p>For example, SHORTSAT(*)= { (z, k) z SHORTSAT(k)} is &lt;qt-hard for N*P.</p><p>The family G. { (G, k) k &gt; 1 } is &lt;qt-hard for N*P, for every I. Finally, a language family C is weakly &lt;qt-completefor N*P if it is both in N*P and &lt;qt-hard for N*P. One example of a weakly complete set for N*Pi is { (x, 2k) x CSAT(k)}.</p><p>The definition of N*Pj is motivated by the work of Abrahamson t al. <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b1">[2]</ref> on their class PGT. Their work focused on families of problems in P, usually generated by parameterized problems in NP, such as SHORTSAT() and CSAT(). The class PGT is roughly equivalent to the notion "in some N*Pj and hard for some N*Pk." The ma- jor differences are that PGT includes nonuniform families and that reductions may be nonuniform; in the terms of this paper, the functions f above are not required to be computable. All of the complete families considered by Abrahamson t al., however, are uniform and are examples of families in some N*Pj and hard for some N*P. Thus, their work provided examples of sets in the classes NiPa, some of which were also hard for classes N iP. Further work on limited nondeterminism is likely to yield additional complete sets for PGT.</p><p>5. Relationships among the classes. The classes N'/ bear a strong analogy to NP; however, the analogy should not be taken too far. For example, one might conclude from Theorem 2.3 that NPz behaves as a limiting case of N'P as m goes to infinity.</p><p>This conclusion, however, can be false in the presence of an oracle. Denote by C x the class C relative to oracle X. The results of 2 hold relative to any oracle X. THEOREM 5.1. There is an oracle A such that Nmp A Pfor all m and k, and yet NpA pA.</p><p>Proof. By Theorem 2.2, we need only show that NP A pA and pA NpA. M Fix an enumeration ( i)i= of nondeterministic machines such that M runs in quasilinear time and makes at most log n nondeterminisfic choices on inputs of length n. Fix an enumeration (T} of deterministic machines such that Ti runs for at most p(n) n / i steps on inputs of length n.</p><p>We construct A to have the following two properties for all i:</p><p>C: The coding condition: For all strings x and all positive integers s, the string 02#i#x is in A if and only if MA(x) accepts within s steps. (Note that MA(x) cannot query whether 02 #i#x is in A within s steps.) D: The diagonalization condition: The language LA {1 ' y iyI n A I"y A } is not accepted by T.</p><p>The construction proceeds in stages. During stage k, all strings of length k are fixed to be in or out of A, in such a way that conditions C hold up to length k. In addition, some strings of length longer than k may be fixed to satisfy some condition Di. Because each string is fixed exactly once during the construction, the oracle A is well defined. In fact, A is computable in space n 0g').</p><p>Initially, all strings are unfixed. Set k d 1; k is the stage number, d is the current diagonalization condition, and is a lower bound on the input at which condition D a can be satisfied.</p><p>Stage k: For all strings z of length k of the form z 028 #i#z for some i, z, and s, fix z in A if M accepts z with oracle A in &lt; s steps; otherwise fix z out of A. (Note that this condition is determined by the preceding stages of the construction.) Fix all strings of length k not of the above form out of A. If k &lt; or 2 k &lt; pd(k) l+lgpa(k), then stage</p><formula xml:id="formula_0">k is complete---continue to stage k + 1.</formula><p>If k &gt; and 2 k &gt; pd(k) l+lgp(k), then a diagonalization condition can be satisfied. Simulate Td on input 1. When Td queries a string z not yet fixed, there are two cases.</p><p>1. If z O2"#i#x for some i, x, and s, then simulate M on input z for s steps, and fix z accordingly. Fix strings queried during the simulation by applying these cases recursively.</p><p>2. Otherwise, fix z out of A.</p><p>If Td accepts Ik, then fix all remaining strings of the form ly with lY] k out of A. If Td rejects 1k, then fix all remaining strings of the form ly with lY] k to be in A. In either case, set pd(k), increase d by one, and continue to stage k + 1. End of stage k.</p><p>We first show that the construction can be carried out. LEMMA 5.2. If the construction simulates Td on input 1k, then some string lky with [y[ k remains unfixed at the end of the simulation.</p><p>Proof. The parameter is an upper bound on the length of strings that have been fixed due to any diagonalization attempt prior to stage k. Because k &gt; at the start of the simulation of Td, all of the 2 k strings lky are unfixed at that time.</p><p>Let S(n) be the maximum number of strings fixed during the simulation of some MiA(x) for s steps, where 1028#i#xl n. In s steps, MA(x) queries fewer than 82 lg n strings over all of its nondeterministic computations, and each queried string has length less than n/2. Hence S(n) &lt; n2S(n/2), and S(1) 1. Therefore, S(n) &lt;_ T/,lgn.</p><p>Ta runs for at most pa(k) steps; therefore, the total number of strings queried during the simulation is at most pa(k). S(pa(k)) &lt; pd(k) l+lgpa(k) &lt; 2k. Hence some string of the form 1 with I] k remains unfixed.</p><p>LEMMA 5.3. The set A constructed as above satisfies conditions Ci and Di for all i. Proof. Each string of the form 0 8#i#z is eventually fixed in or out of A. Such a string is fixed only after the acceptance or rejection of Mia(z) within s steps is deter- mined, and is fixed according to that acceptance or rejection. Hence condition C holds for all i.</p><p>Because pd(n) l+lgpa(n) o(2'), each value of d is eventually considered at some stage k. The previous lemma ensures that condition Da is established following the com- pletion of stage k.</p><p>Conditions C together imply that N1P A P1 A, and hence N'P pA for all k and m by Theorem 2.2. Conditions D together imply that L a Informally, Theorem 5.1 shows that large amounts of nondeterminism can be useful even if small amounts are not. The reverse is also possiblea large amount of nonde- terminism may be no more advantageous than a small amount. Proof. The proof depends in a small way on the definition of an oracle machine.</p><p>There are two possibilities to be considered. If the query tape is erased following a query, define 6 0. If the query tape is not erased following a query, define i 1. Although the relativized classes depend on the model used (see <ref type="bibr" target="#b4">[5]</ref>), the necessary properties for the present proof are captured by the value of .</p><p>Let {Mt,i}t,=l be an enumeration of nondeterministic oracle machines, and let {T,i}t,-=l be an enumeration of deterministic oracle machines, such that both Mt,i and T, are clocked to run for p,i(n) n logan + i steps. We construct B to meet the following conditions:</p><p>1. Coding conditions. For all and i, for all sufficiently large z, M s t,i(z) accepts if and only if there is a string y of length (1 + 61) log Ixl such that OP,'(ll)#l#i#x#y is in B.</p><p>2. Diagonalization conditions. For all l, the language L, { x Iy lYl (1 + 61)loglxl A llZlxy E B } is not accepted by T for any i. l,i Condition 1 implies that NP c_ NP for all l, because log Izl bits of y can be guessed nondeterministically, and if 1, the remaining log Ixl bits found by exhaus- tive search in time O(n). (If a string is erased upon being queried, each query of a cod- ing string requires Q(n) steps, and the search cannot be carried out deterministically.) Condition 2 implies that L NPt s P.</p><p>Let (., .) be a pairing function from positive integers to positive integers; e.g., let &lt;/, i) (l + i + 21i 31 i + 2)/2. To start the construction, set k d b 1; k is the stage number, d the current diagonalization condition, and b the barrier so that diagonalizations do not overlap. Throughout, and will be determined by d (1, i). Once again, at stage k, all strings of length k will be fixed in or out of B.</p><p>Stage k: If possible, pick an integer k such that b &lt; k &lt; k/t, pt,i(k) &lt; klh-(1/d), and k + + (1 + 6l) log ] &gt; k. If k exists, then a diagonalization condition can be satisfied.</p><p>Otherwise, continue immediately to the coding part of the stage.</p><p>To satisfy the diagonalization condition, simulate Td on input 1i:. If Td queries a string not yet fixed, fix that string to be out of B. (This may fix a coding string. See below.) At the end of the simulation, if T (1i:) accepts, fix all strings of the form with lYl (1 + 61) log k to be out of B. If T (li:) rejects, fix all remaining strings 1 with lYl (1 + 61) logk to be in B. Set b pt,() + 1, and increase dby one.</p><p>After the diagonalization condition is considered, satisfy the possible coding con- ditions up to length k, as follows. For all unfixed strings z of length k having the form OP",(ll)#m#j#x#y for some m, j, x, and y with [Yl (1 + dim) log Ixl, fix z in B if B M,, (x) accepts and fix z out of B if MB,(x) rejects.</p><p>End of stage k.</p><p>For each fixed l, i, and d, the conditions on/ are satisfied for infinitely many values of k. Therefore, each diagonalization condition will eventually be satisfied, and Lt Npn pB for all 1.</p><p>Coding strings may be fixed during diagonalization stages. However, for each fixed rn and j, there is a bound on the size of x such that a coding string for M,,j(x) may be fixed during a diagonalization. A given coding string for M,,j may be fixed out of B during the diagonalization against at most one 7),, at some stage k. Since all strings of length less than k are fixed before stage k, the stage number satisfies k &lt; [OP",(ll)#m#j#x#y[ Q(lxlm). Note that k &lt; clxl m+1/3 for some c and all suffi- ciently long strings x. At most pt,i(])/kstrings of length k are fixed during the diag- onalization. The conditions on k imply that pt,i(e)/k 1-6 is bounded by kt+(:/a)k -: &lt; k6+(1/aO, which is less than Izl x/6" when d &gt; 3m and z is sufficiently long. Since d is nondecreasing and unbounded, each M,,j will be correctly coded for all but finitely many x, and condition 1 will be satisfied.</p><p>Therefore, the oracle B meets the required conditions.</p><p>We expect that neither oracle A nor/3 represents the unrelativized case. The fol- lowing result seems more likely.</p><p>THEOREM 5.5. There is an oracle C such that NP # NkPt C for all distinct pairs (i, j) and (k, 1). Also pC Npc.</p><p>Proof. Each class NiPj satisfies the following conditions.</p><p>1. Let X be any oracle, and let A NP c. For each string x, to test if x A requires only finite knowledge of X.</p><p>2. For all oracles X and Y that differ on only finitely many strings, NiPf c NiP.</p><p>3. For all oracles X, and for all sets A and/3 that differ on only finitely many strings,</p><p>A NP] c if and only if B NP c.</p><p>4. Let X be any oracle, and let machine M accept A in NiP c. Then there are an oracle X* and machine M* running in NiPj such that N'Pf N'pf c* * M* with oracle X* accepts the language A, and for all oracles Y and Z that differ on only finitely many strings, the language accepted by M* with oracle Y differs from the language accepted by M with oracle Z on at most finitely many strings. Conditions 1, 2, and 3 are immediate. The oracle X* of condition 4 is simply X x N.</p><p>Machine M* acts as M except that a query s is replaced by (s, n&gt;, where n is the length of the input.</p><p>These properties permit the use of a result of Poizat <ref type="bibr" target="#b14">[15]</ref>. LEMMA 5.6 <ref type="bibr">(Poizat)</ref>. Let S and 7" be two classes that satisfy conditions 1-4 above, with the same mapping X X*. Suppose that there is an oracle X such that S x 7"x. Then S a T a for all generic sets G.</p><p>Hence one may reverse the order of quantifiers in the statement of the theorem. LEMMA 5.7. Forall distinctpairs i, j) and k, 1), there is an oracle C such that NiP ukptC.</p><p>Proof (sketch). If j l, the desired oracle is the set A of Theorem 5.1, because pA pA. (An alternative proof may be obtained via a diagonalization using queries of length n mx{,} on inputs of length n.) Suppose j and i &lt; k. For an oracle C, define Lc { x xy C }. A standard diagonalization constructs a C such that Lc q PiC+y. Because Lc E NkptC, the desired result follows.</p><p>The previous lemmas imply that NP NkP c for all generic oracles C. [:]   Theorems 5.1 and 5.4 indicate that mere equality or inequality among the classes Nmpt is insufficient to determine whether P NP. It is consistent either that small amounts of nondeterminism (m log n bits) are useful, but large amounts (polynomially many bits) are no more useful, or that small amounts of nondeterminism are useless, but large amounts are quite powerful. However, additional information about the com- plexity of these classes, such as in the hypothesis of Theorem 2.3, can suffice to decide P =? NP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6.</head><p>Conclusions and open problems. We have shown several problems to be com- plete for quasilinear time with restricted nondeterminism. Satisfiability of topologically Downloaded 11/14/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php ordered circuits with k log n inputs and ordered unravelling of Boolean formulas are each complete for NkP1, and a problem concerning context-free grammars is complete for N1P1. All of these complete problems require that the input be ordered appropri- ately. The corresponding unordered problems remain hard for NkPI but do not appear to be in any class below NkP2. If random-access machines were used as the underlying model of computation instead of Turing machines, then the unordered problems would be in quasilinear time, but the hardness proofs would fail, due to our inability to simulate random access.</p><p>One motivation for this work, as yet unrealized, was to provide general lower bounds for problems of "nearly feasible" complexity. Existing lower bounds usually apply to re- stricted models of computation, such as one-tape Turing machines or constant-depth circuits, or prove only very large lower bounds, as in the proofs of hardness for exponential time. A proof that some problem fi' is hard for a particular P or NPk (k &gt; 1) is a general lower bound on the time complexity of problem S. Although S may already be known to be in P, and thus be considered "feasible," such a hardness proof would give concrete information about the practical complexity of S. The only results of this kind known to the authors are for certain pebble games <ref type="bibr" target="#b2">[3]</ref>.</p><p>This paper leaves many questions unanswered. Although the most dramatic ques- tion is whether the hypothesis of Theorem 2.3 holds, there are other, more approachable questions. There are several problems that are easily shown to be in Gurevich and Shelah's class NLT but are not known to be in QL. These include topological sort- ing, and the problem of generalized Boolean formulas (shown to be NLT-complete in <ref type="bibr" target="#b9">[10]</ref>). Providing QL algorithms for these problems, or showing that none exist (i.e., that NLT QL), would give us important information about the power of random access.</p><p>The fundamental question remains whether there are problems in P that can be computed more quickly with limited nondeterminism than without it. For instance, can one show a Q(n) deterministic lower bound for (k + 1)-clique, or for CSAT(k)?</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>THEOREM 5 . 4 .</head><label>54</label><figDesc>There is an oracle B such that Pm NIP,B and N P NPfor all Downloaded 11/14/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Downloaded 11/14/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. The authors thank A. Klapper, N. Immerman, M. Groszek, A. Peterson, W. L. Ruzzo, and A. Selman for useful discussions of this material.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The work of this author was supported in part by a grant from the Natural Sciences and Engineering Research Council (NSERC) of Canada. The work of this author was supported in part by National Science Foundation grant  </p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">On the complexity ofjdparameter problems</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Abrahamson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Ellis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Fellows</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Viata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 30th Annual Symposium on Foundations of Computer Science</title>
		<meeting>30th Annual Symposium on Foundations of Computer Science<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="210" to="215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Completeness for Families of Fixed Parameter Problems</title>
		<idno>DCS-141-IR</idno>
		<imprint>
			<date type="published" when="1990">1990</date>
			<pubPlace>Victoria, British Columbia, Canada</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Victoria</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Some combinatorial game problems require f(nk) time</title>
		<author>
			<persName><forename type="first">A</forename><surname>Adachi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Iwata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kasai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Assoc. Comput. Mach</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="361" to="376" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Complexity classes with complete problems between P and NPcomplete</title>
		<author>
			<persName><forename type="first">C</forename></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Diaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">And</forename><forename type="middle">J</forename><surname>Toran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Foundations of Computation Theory</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>Foundations of Computation Theory<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">380</biblScope>
			<biblScope unit="page" from="13" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Relativized alternation and space-bounded computation</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Buss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. System Sci</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="351" to="378" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">R</forename><surname>Buss</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>personal communication</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Shortpropositional formulas represent nondeterministic computations</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="269" to="270" />
			<date type="published" when="1987">1987/88</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Classes ofbounded nondeterminism</title>
		<author>
			<persName><forename type="first">J</forename><surname>Dlz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>To</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Systems Theory</title>
		<imprint>
			<biblScope unit="page" from="21" to="32" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Geske</surname></persName>
		</author>
		<idno>11/14/12 to 150.135.135.70</idno>
		<ptr target="http://www.siam.org/journals/ojsa.php" />
		<title level="m">Redistribution subject to SIAM license or copyright; see</title>
		<meeting><address><addrLine>Ames, IA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
		<respStmt>
			<orgName>Iowa State University</orgName>
		</respStmt>
	</monogr>
	<note>On the Structure oflntractable Sets</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Nearly linear time</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Gurevici-I And</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shelah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic at Botik &apos;89</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Meyer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Taitslin</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin, New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">363</biblScope>
			<biblScope unit="page" from="108" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The complexity of very simple Boolean formulas with applications</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">B</forename><surname>Hunt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Stearns</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="44" to="70" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Characterizing some low complexity classes using theories of arithmetic</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kaye</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
			<pubPlace>Manchester, U.K.</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Manchester</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">M. Sc. thesis</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Refining nondeterminism in relativized polynomial-time bounded computations</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M R</forename><surname>Kintala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Fischer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="46" to="53" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Fast simulation of combinational logic circuits by machines without random-access storage</title>
		<author>
			<persName><forename type="first">N</forename><surname>Pippenger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifteenth Allerton Conference on Communication, Control, and Computing</title>
		<meeting>the Fifteenth Allerton Conference on Communication, Control, and Computing</meeting>
		<imprint>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="25" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Q A/&apos;Q?</title>
		<author>
			<persName><forename type="first">B</forename><surname>Poizat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page" from="22" to="32" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Satisfiability is quasilinear complete in NQL</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Sci-Rnorr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Assoc. Comput. Mach</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="136" to="145" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Wolf</surname></persName>
		</author>
		<title level="m">Limited Nondeterminism in Parallel Models of Computation</title>
		<meeting><address><addrLine>Madison, WI</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
		<respStmt>
			<orgName>University of Wisconsin</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
