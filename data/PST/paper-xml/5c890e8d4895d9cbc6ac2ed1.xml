<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Multi-Message Private Information Retrieval: Capacity Results and Near-Optimal Schemes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><roleName>Student Member, IEEE</roleName><forename type="first">Karim</forename><surname>Banawan</surname></persName>
							<email>kbanawan@umd.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engi-neering</orgName>
								<orgName type="institution">University of Maryland</orgName>
								<address>
									<postCode>20742</postCode>
									<settlement>College Park</settlement>
									<region>MD</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><roleName>Fellow, IEEE</roleName><forename type="first">Sennur</forename><surname>Ulukus</surname></persName>
							<email>ulukus@umd.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engi-neering</orgName>
								<orgName type="institution">University of Maryland</orgName>
								<address>
									<postCode>20742</postCode>
									<settlement>College Park</settlement>
									<region>MD</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Multi-Message Private Information Retrieval: Capacity Results and Near-Optimal Schemes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">4362F2A48BF250BD32CAB4548DCC23F7</idno>
					<idno type="DOI">10.1109/TIT.2018.2828310</idno>
					<note type="submission">This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIT.2018.2828310, IEEE Transactions on Information Theory received February 5, 2017; revised December 20, 2017; accepted April 4, 2018. The editor coordinating the review of this paper and approving it for publication was A. Ramamoorthy.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:14+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Private information retrieval</term>
					<term>multi-message</term>
					<term>MDS code</term>
					<term>capacity</term>
					<term>alignment</term>
					<term>IIR filters</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We consider the problem of multi-message private information retrieval (MPIR) from N non-communicating replicated databases. In MPIR, the user is interested in retrieving P messages out of M stored messages without leaking the identity of the retrieved messages. The information-theoretic sum capacity of MPIR C P s is the maximum number of desired message symbols that can be retrieved privately per downloaded symbol, where the symbols are defined over the same field. For the case P ≥ M 2 , we determine the exact sum capacity of MPIR as</p><p>The achievable scheme in this case is based on downloading MDS-coded mixtures of all messages. For P ≤ M 2 , we develop lower and upper bounds for all M, P, N . These bounds match if the total number of messages M is an integer multiple of the number of desired messages P , i.e., M P ∈ N. In this case,</p><p>N ) M/P for N &gt; 1, and C P s = P M for N = 1. The achievable scheme in this case generalizes the single-message capacity achieving scheme to have unbalanced number of stages per round of download. For all the remaining cases, the difference between the lower and upper bound is at most 0.0082, which occurs for M = 5, P = 2, N = 2. Our results indicate that joint retrieval of desired messages is more efficient than successive use of single-message retrieval schemes even after considering the free savings that result from downloading undesired symbols in each single-message retrieval round.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>The privacy of the contents of the downloaded information from curious public databases has attracted considerable research within the computer science community <ref type="bibr" target="#b0">[1]</ref>- <ref type="bibr" target="#b3">[4]</ref>. The problem is motivated by practical examples such as: ensuring privacy of investors as they download records in a stock market, since revealing the interest in a certain record may influence its value; ensuring the privacy of an inventor as they look up existing patents in a database, since revealing what they are looking at leaks some information about the current invention they are working on; and protecting activists in oppressive regimes as they browse restricted content on the internet <ref type="bibr" target="#b1">[2]</ref>. In the classical private information retrieval (PIR) problem, a user wishes to download a certain message (or file) from N non-communicating databases without leaking any information about the identity of the downloaded message. The contents of the databases are identical. The user performs this operation by preparing and submitting queries to all databases. The databases respond truthfully with answer strings which are functions of the queries and the messages. The user needs to reconstruct the desired message from these answer strings. A trivial solution for this seemingly difficult problem is for the user to download the contents of any individual database. This solution however is extremely inefficient. The efficiency is measured by the retrieval rate which is the ratio of the number of retrieved desired message symbols to the number of total downloaded symbols, where the symbols are defined over the same field. The capacity of PIR is the maximum retrieval rate over all possible PIR schemes.</p><p>The computer science formulation of this problem assumes that the messages are of length one bit. The metrics in this case are the download cost, i.e., the sum of lengths of the answer strings, and the upload cost, i.e., the size of the queries. Most of this work is computational PIR as it ensures only that a server cannot get any information about user intent unless it solves a certain computationally hard problem <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b4">[5]</ref>. The information-theoretic re-formulation of the problem considers arbitrarily large message sizes, and ignores the upload cost. This formulation provides an absolute, i.e., informationtheoretic, guarantee that no server participating in the protocol gets any information about the user intent. Towards that end, recently, <ref type="bibr" target="#b5">[6]</ref> has drawn a connection between the PIR problem and the blind interference alignment scheme proposed in <ref type="bibr" target="#b6">[7]</ref>. Then, <ref type="bibr" target="#b7">[8]</ref> has determined the exact capacity of the classical PIR problem. The retrieval scheme in <ref type="bibr" target="#b7">[8]</ref> is based on three principles: message symmetry, symmetry across databases, and exploiting side information from the undesired messages through alignment.</p><p>The basic PIR setting has been extended in several interesting directions. The first extension is the coded PIR (CPIR) problem <ref type="bibr" target="#b8">[9]</ref>- <ref type="bibr" target="#b10">[11]</ref>. The contents of the databases in this problem are coded by an (N, K) storage code instead of being replicated. This is a natural extension since most storage systems nowadays are in fact coded to achieve reliability against node failures and erasures with manageable storage cost. In <ref type="bibr" target="#b11">[12]</ref>, the exact capacity of the MDS-coded PIR is determined. Another interesting extension is PIR with colluding databases (TPIR). In this setting, T databases can communicate and exchange the queries to identify the desired message. The exact capacity of colluded PIR is determined in <ref type="bibr" target="#b12">[13]</ref>. The case of coded PIR with colluding databases is investigated in <ref type="bibr" target="#b13">[14]</ref>. The robust PIR problem (RPIR) extension considers the case when some databases are not responsive <ref type="bibr" target="#b12">[13]</ref>. Lastly, in the symmetric PIR problem (SPIR) the privacy of the remaining records should be maintained against the user in addition to the usual privacy constraint on the databases, i.e., the user should not learn any other messages other than the one it wished to retrieve. The exact capacity of symmetric PIR is determined in <ref type="bibr" target="#b14">[15]</ref>; and the exact capacity of symmetric PIR from coded databases is determined in <ref type="bibr" target="#b15">[16]</ref>.</p><p>In some applications, the user may be interested in retrieving multiple messages from the databases without revealing the identities of these messages. Returning to the examples presented earlier: the investor may be interested in comparing the values of multiple records at the same time, and the inventor may be looking up several patents that are closely related to their work. One possible solution to this problem is to use single-message retrieval scheme in <ref type="bibr" target="#b7">[8]</ref> successively. We show in this work that multiple messages can be retrieved more efficiently than retrieving them one-by-one in a sequence. This resembles superiority of joint decoding in multiple access channels over multiple simultaneous singleuser transmissions <ref type="bibr" target="#b16">[17]</ref>. To motivate the multi-message private information retrieval problem (MPIR), consider the example in <ref type="bibr" target="#b7">[8,</ref><ref type="bibr">Section 4.3]</ref> where the number of messages is M = 3, number of databases is N = 2, and the user is interested in retrieving only P = 1 message. Here the optimal scheme retrieves 8 desired bits in 14 downloads, hence with a rate 4/7. When the user wishes to retrieve P = 2 messages, if we use the scheme in <ref type="bibr" target="#b7">[8]</ref> twice in a row, we retrieve 16 bits in 28 downloads, hence again a sum rate of 4/7. Even considering the fact that the scheme in <ref type="bibr" target="#b7">[8]</ref> retrieves 2 bits of the second message for free in downloading the first message, i.e., it actually retrieves 10 bits in 14 downloads, hence a sum rate of 5/7, we show in this paper that a better sum rate of 4/5 can be achieved by joint retrieval of the messages.</p><p>Although there is a vast literature on classical PIR in the computer science literature, only a few works exist in MPIR, such as: Reference <ref type="bibr" target="#b17">[18]</ref> proposes a multi-block (multimessage) scheme and observes that if the user requests multiple blocks (messages), it is possible to reuse randomly mixed data blocks (answer strings) across multiple requests (queries). Reference <ref type="bibr" target="#b18">[19]</ref> develops a multi-block scheme which further reduces the communication overhead. An achievable scheme for the multi-block PIR by designing k-safe binary matrices that uses XOR operations is developed in <ref type="bibr" target="#b19">[20]</ref>. Reference <ref type="bibr" target="#b19">[20]</ref> extends the scheme in <ref type="bibr" target="#b0">[1]</ref> to multiple blocks. Reference <ref type="bibr" target="#b20">[21]</ref> designs an efficient non-trivial multi-query computational PIR protocol and gives a lower bound on the communication of any multi-query information retrieval protocol. Reference <ref type="bibr" target="#b21">[22]</ref> suggests using batch codes to allow a single client to retrieve multiple records simultaneously while allowing the server computation to scale sublinearly with the number of records fetched. This idea is extended further in <ref type="bibr" target="#b22">[23]</ref> to design a PIR server algorithm that achieves sublinear scaling in the number of records fetched, even when they are requested by distinct, non-collaborating clients. These works do not consider determining the information-theoretic capacity.</p><p>In this paper, we formulate the MPIR problem with noncolluding repeated databases from an information-theoretic perspective. Our goal is to characterize the sum capacity of the MPIR problem C P s , which is defined as the maximum ratio of the number of retrieved symbols from the P desired messages to the number of total downloaded symbols. When the number of desired messages P is at least half of the total number of messages M , i.e., P ≥ M 2 , we determine the exact sum capacity of MPIR as</p><formula xml:id="formula_0">C P s = 1 1+ M -P P N</formula><p>. We use a novel achievable scheme which downloads MDS-coded mixtures of all messages. We show that joint retrieving of the desired messages strictly outperforms successive use of single-message retrieval for P times. Additionally, we present an achievable rate region to characterize the trade-off between the retrieval rates of the desired P messages.</p><p>For the case of P ≤ M 2 , we derive lower and upper bounds that match if the total number of messages M is an integer multiple of the number of desired messages P , i.e., M P ∈ N. In this case, the sum capacity is</p><formula xml:id="formula_1">C P s = 1-1 N 1-(<label>1</label></formula><formula xml:id="formula_2">N</formula><p>) M/P . The result resembles the single-message capacity with the number of messages equal to M P . In other cases, although the exact capacity is still an open problem, we show numerically that the gap between the lower and upper bounds is monotonically decreasing in N and is upper bounded by 0.0082. The achievable scheme when P ≤ M 2 is inspired by the greedy algorithm in <ref type="bibr" target="#b7">[8]</ref>, which retrieves all possible combinations of messages. The main difference of our scheme from the scheme in <ref type="bibr" target="#b7">[8]</ref> is the number of stages required in each download round. For example, round M -P + 1 to round M -1, which correspond to retrieving the sum of M -P +1 to sum of M -1 messages, respectively, are suppressed in our scheme. This is because, they do not generate any useful side information for our purposes here, in contrast to <ref type="bibr" target="#b7">[8]</ref>. Interestingly, the number of stages for each round is related to the output of a P -order IIR filter <ref type="bibr" target="#b23">[24]</ref>. This intriguing connection to IIR filtering is a result of constructing the greedy achievable scheme in <ref type="bibr" target="#b7">[8]</ref> backwards and observing the required side information needed in previous rounds. Our converse proof generalizes the proof in <ref type="bibr" target="#b7">[8]</ref> for P ≥ 1. The essence of the proof is captured in two lemmas: the first lemma lower bounds the uncertainty of the interference for the case P ≥ M 2 , and the second lemma upper bounds the remaining uncertainty after conditioning on P interfering messages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. PROBLEM FORMULATION</head><p>Consider a classical PIR setting storing M messages (or files). Each message is a vector W i ∈ F L q , i ∈ {1, • • • , M }, whose elements are picked uniformly and independently from sufficiently large field<ref type="foot" target="#foot_0">1</ref> F q . Denote the contents of message W m by the vector [w m <ref type="bibr" target="#b0">(1)</ref>, w m (2), • • • , w m (L)] T . The messages are independent and identically distributed, and thus,</p><formula xml:id="formula_3">H(W i ) = L, i ∈ {1, • • • , M } (1) H (W 1:M ) = M L (<label>2</label></formula><formula xml:id="formula_4">)</formula><p>where L is measured in q-ary bits,</p><formula xml:id="formula_5">W 1:M = (W 1 , W 2 , • • • , W M ).</formula><p>The messages are stored in N noncolluding (non-communicating) databases. Each database stores an identical copy of all M messages, i.e., the databases encode the messages via (N, 1) repetition storage code <ref type="bibr" target="#b11">[12]</ref>.</p><p>In the MPIR problem, the user aims to retrieve a subset of messages indexed by the index set</p><formula xml:id="formula_6">P = {i 1 , • • • , i P } ⊆ {1, • • • , M } out</formula><p>of the available messages, where |P| = P , without leaking the identity of the subset P. We assume that the cardinality of the potential message set, P , is known to all databases. To retrieve</p><formula xml:id="formula_7">W P = (W i1 , W i2 , • • • , W i P ), the user generates a query Q [P]</formula><p>n and sends it to the nth database. The user does not have any knowledge about the messages in advance, hence the messages and the queries are statistically independent,</p><formula xml:id="formula_8">I W 1 ,• • • ,W M ; Q [P] 1 ,• • • ,Q [P] N = I W 1:M ; Q [P] 1:N = 0 (3)</formula><p>The privacy is satisfied by ensuring statistical independence between the queries and the message index set P = {i 1 , • • • , i P }, i.e., the privacy constraint is given by,</p><formula xml:id="formula_9">I Q [i1,••• ,i P ] n ; i 1 , • • • , i P = I Q [P] n ; P = 0 (4) for all n ∈ {1, • • • , N }.</formula><p>The nth database responds with an answer string</p><formula xml:id="formula_10">A [P]</formula><p>n , which is a deterministic function of the queries and the messages, hence</p><formula xml:id="formula_11">H(A [P] n |Q [P] n , W 1:M ) = 0<label>(5)</label></formula><p>We further note that by the data processing inequality and (4),</p><formula xml:id="formula_12">I A [P] n ; P = 0, n ∈ {1, • • • , N }<label>(6)</label></formula><p>In addition, the user should be able to reconstruct the messages W P reliably from the collected answers from all databases given the knowledge of the queries. Thus, we write the reliability constraint as,</p><formula xml:id="formula_13">H(W i1 , • • • , W i P |A [P] 1 , • • • , A [P] N , Q [P] 1 , • • • , Q [P] N ) = H W P |A [P] 1:N , Q [P] 1:N = 0 (7)</formula><p>We denote the retrieval rate of the ith message by R i , where i ∈ P. The retrieval rate of the ith message is the ratio between the length of message i and the total download cost of the message set P that includes W i . Hence,</p><formula xml:id="formula_14">R i = H(W i ) N n=1 H A [P] n<label>(8)</label></formula><p>The sum retrieval rate of W P is given by,</p><formula xml:id="formula_15">P i=1 R i = H(W P ) N n=1 H A [P] n = P L N n=1 H A [P] n<label>(9)</label></formula><p>The sum capacity of the MPIR problem is given by</p><formula xml:id="formula_16">C P s = sup P i=1 R i (<label>10</label></formula><formula xml:id="formula_17">)</formula><p>where the sup is over all private retrieval schemes.</p><p>In this paper, we follow the information-theoretic assumptions of large enough message size, large enough field size, and ignore the upload cost as in <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b10">[11]</ref>- <ref type="bibr" target="#b12">[13]</ref>. A formal treatment of the capacity under message and field size constraints for P = 1 can be found in <ref type="bibr" target="#b24">[25]</ref>. We note that the MPIR problem described here reduces to the classical PIR problem when P = 1, whose capacity is characterized in <ref type="bibr" target="#b7">[8]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. MAIN RESULTS AND DISCUSSIONS</head><p>Our first result is the exact characterization of the sum capacity for the case P ≥ M 2 , i.e., when the user wishes to privately retrieve at least half of the messages stored in the databases.</p><p>Theorem 1 For the MPIR problem with non-colluding and replicated databases, if the number of desired messages P is at least half of the number of overall stored messages M , i.e., if P ≥ M 2 , then the sum capacity is given by,</p><formula xml:id="formula_18">C P s = 1 1 + M -P P N (11)</formula><p>The achievability proof for Theorem 1 is given in Section IV, and the converse proof is given in Section VI-A. We note that when P = 1, the constraint of Theorem 1 is equivalent to M = 2, and the result in <ref type="bibr" target="#b10">(11)</ref> reduces to the known result of <ref type="bibr" target="#b7">[8]</ref> for P = 1, M = 2, which is 1 1+ 1</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>N</head><p>. We observe that the sum capacity in <ref type="bibr" target="#b10">(11)</ref> is a strictly increasing function of N , and C P s → 1 as N → ∞. We also observe that the sum capacity in this regime is a strictly increasing function of P , and approaches 1 as<ref type="foot" target="#foot_1">2</ref> P → M .</p><p>The following corollary compares our result and the rate corresponding to the repeated use of single-message retrieval scheme <ref type="bibr" target="#b7">[8]</ref>.</p><p>Corollary 1 For the MPIR problem with P ≥ M 2 , the repetition of the single-message retrieval scheme of <ref type="bibr" target="#b7">[8]</ref> P times in a row, which achieves a sum rate of,</p><formula xml:id="formula_19">R rep s = (N -1)(N M -1 + P -1) N M -1<label>(12)</label></formula><p>is strictly sub-optimal with respect to the exact capacity in <ref type="bibr" target="#b10">(11)</ref>.</p><p>Corollary 1 implies that applying Sun-Jafar scheme [8] P times is suboptimal, even if the user uses the undesired symbols, which are downloaded as a byproduct of Sun-Jafar scheme, as a head start in downloading the remaining messages because in this case the user would achieve R rep s &lt; C P s . Proof: In order to use the single-message capacity achieving PIR scheme as an MPIR scheme, the user repeats the singlemessage achievable scheme for each individual message that belongs to P. We note that at each repetition, the scheme downloads extra decodable symbols from other messages. By this argument, the following rate R rep s is achievable using a repetition of the single-message scheme,</p><formula xml:id="formula_20">R rep s = C + ∆(M, P, N ) (<label>13</label></formula><formula xml:id="formula_21">)</formula><p>where C is the single-message capacity which is given by</p><formula xml:id="formula_22">C = 1-1 N 1-( 1 N ) M [8]</formula><p>, and ∆(M, P, N ) is the rate of the extra decodable symbols that belong to P. To calculate ∆(M, P, N ), we note that the total download cost D is given by D = L C by definition. Since L = N M in the single-message scheme, D =</p><formula xml:id="formula_23">N M (1-( 1 N ) M ) 1-1 N = N M +1 -N N -1</formula><p>. The single-message scheme downloads one symbol from every message from every database, i.e., the scheme downloads extra (P -1)N symbols from the remaining desired messages that belong to P, thus,</p><formula xml:id="formula_24">∆(M, P, N ) = (P -1)N (N -1) N M +1 -N = (P -1)(N -1) N M -1<label>(14)</label></formula><p>Using this in <ref type="bibr" target="#b12">(13)</ref> gives the R rep s expression in <ref type="bibr" target="#b11">(12)</ref>. Now, the difference between the capacity in <ref type="bibr" target="#b10">(11)</ref> and achievable rate in <ref type="bibr" target="#b11">(12)</ref> is,</p><formula xml:id="formula_25">C P s -R rep s = P N P (N -1) + M - (N -1)(N M -1 + P -1) N M -1 (15) = η(P, M, N ) (N M -1)(P (N -1) + M )<label>(16)</label></formula><p>It suffices to prove that η(P, M, N ) ≥ 0 for all P , M , N when P ≥ M 2 and N ≥ 2. Note,</p><formula xml:id="formula_26">η(P , M, N ) =(2P -M )N M + (M -P )N M -1 -P (P -1)N 2 + ((P -1)(2P -M ) -P )N +(M -P )(P -1)<label>(17)</label></formula><p>In the regime P ≥ M 2 , coefficients of N M , N M -1 , N 0 are non-negative. Denote the negative terms in η(•) by ν(P, N ) which is ν(P, N ) = P (P -1)N 2 + P N . We note ν(P, N ) &lt; P 2 N 2 when N &gt; 1, which is the case here. Thus, η(P,M, N )</p><formula xml:id="formula_27">≥(2P -M )N M +(M -P )N M -1 +(P -1)(2P -M )N + (M -P )(P -1) -P 2 N 2 (18) &gt;(2P -M )N M + (M -P )N M -1 -P 2 N 2 (19) =N 2 (2P -M )N M -2 + (M -P )N M -3 -P 2 (20) ≥N 2 (2P -M )2 M -2 + (M -P )2 M -3 -P 2 (21) =N 2 2 M -3 (3P -M ) -P 2 (22) ≥N 2 2 M -3 • M 2 -M 2 (23) =M N 2 2 M -4 -M<label>(24)</label></formula><p>where <ref type="bibr" target="#b20">(21)</ref> follows from the fact that (2P -M )N M -2 + (M -P )N M -3 -P 2 is monotone increasing in N ≥ 2 for M ≥ 3, and (23) follows from M 2 ≤ P ≤ M . From <ref type="bibr" target="#b23">(24)</ref>, we conclude that η(M, P, N ) &gt; 0 for all M ≥ 7, P ≥ M 2 and N ≥ 2. Examining the expression in <ref type="bibr" target="#b16">(17)</ref> for the remaining cases manually, i.e., when M ≤ 6, we note that η(M, P, N ) &gt; 0 in these cases as well. Therefore, η(M, P, N ) &gt; 0 for all possible cases, and the MPIR capacity is strictly larger than the rate achieved by repeating the optimum single-message PIR scheme.</p><p>For the example in the introduction, where M = 3, P = 2, N = 2, our MPIR scheme achieves a sum capacity of 4 5 in <ref type="bibr" target="#b10">(11)</ref>, which is strictly larger than the repeating-based achievable sum rate of 5  7 in <ref type="bibr" target="#b11">(12)</ref>. The following corollary gives an achievable rate region for the MPIR problem.</p><p>Corollary 2 For the MPIR problem, for the case P ≥ M 2 , the following rate region is achievable,</p><formula xml:id="formula_28">C = conv {(C, δ, • • • , δ), (δ, C, • • • , δ), • • • , (δ, • • • , δ, C), (C, 0, 0,• • • ,0), (0, C, 0, • • • , 0),• • • ,(0, 0, • • • , C), (0, 0, • • • , 0), C P , C P , • • • , C P<label>(25)</label></formula><p>where</p><formula xml:id="formula_29">C = 1 -1 N 1 -( 1 N ) M , C P = C P s P = N P N + (M -P ) , δ = ∆(M, P, N ) P -1 = N -1 N M -1<label>(26)</label></formula><p>and where conv denotes the convex hull, and all corner points lie in the P -dimensional space.</p><p>Proof: This is a direct consequence of Theorem 1 and Corollary 1. The corner point C, ∆(M,P,N )</p><formula xml:id="formula_30">P -1</formula><p>, ∆(M,P,N )</p><formula xml:id="formula_31">P -1 , • • • , ∆(M,P,N ) P -1 = 1-1 N 1-(<label>1</label></formula><formula xml:id="formula_32">N ) M , N -1 N M -1 , N -1 N M -1 , • • • , N -1 N M -1</formula><p>is achievable from the single-message achievable scheme. Due to the symmetry of the problem any other permutation for the coordinates of this corner point is also achievable by changing the roles of the desired messages. Theorem 1 gives the symmetric sum capacity corner point for the case of P ≥ M 2 , namely . By time sharing of these corner points along with the origin, the region in <ref type="bibr" target="#b24">(25)</ref> is achievable.</p><p>As an example for this achievable region, consider again the example in the introduction, where M = 3, P = 2, N = 2. In this case, we have a two-dimensional rate region with three corner points: ( 4 7 , 1  7 ), which corresponds to the single-message capacity achieving point that aims at retrieving W 1 ; ( 1 7 , 4  7 ), which corresponds to single-message capacity achieving point that aims at retrieving W 2 ; and ( 2 5 , 2 5 ), which corresponds to the symmetric sum capacity point. The convex hull of these corner points together with the points on the axes gives the achievable region in Fig. <ref type="figure">1</ref>. We note that in general, the rate region in Corollary 2 is merely an achievable region. The capacity region that characterizes the exact tradeoff between the retrieval rates for the P messages remains an open problem despite the optimality of the corner points. A converse argument is needed to show the optimality of time-sharing (if the rate region is indeed the capacity region).</p><p>For the case P ≤ M 2 , we have the following result, where the lower and upper bound match if M P ∈ N.</p><p>( 1 7 , 4  7 )</p><formula xml:id="formula_33">( 4 7 ,<label>1 7 )</label></formula><p>( 2 5 , 2 5 )</p><formula xml:id="formula_34">R 1 R<label>2</label></formula><p>Fig. <ref type="figure">1</ref>: The achievable rate region of M = 3, P = 2, N = 2.</p><p>Theorem 2 For the MPIR problem with non-colluding and replicated databases, when P ≤ M 2 , the sum capacity is lower and upper bounded as,</p><formula xml:id="formula_35">Rs ≤ C P s ≤ Rs<label>(27)</label></formula><p>where the upper bound Rs is given by,</p><formula xml:id="formula_36">Rs = 1 1 + 1 N + • • • + 1 N M P -1 + M P -M P 1 N M P (28) = 1 1-( 1 N ) M P 1-1 N + M P -M P 1 N M P<label>(29)</label></formula><p>For the lower bound, define r i as,</p><formula xml:id="formula_37">r i = e j2π(i-1)/P N 1/P -e j2π(i-1)/P , i = 1, • • • , P<label>(30)</label></formula><p>where j = √ -1, and denote γ i , i = 1, • • • , P , to be the solutions of the linear equations P i=1 γ i r -P i = (N -1) M -P , and</p><formula xml:id="formula_38">P i=1 γ i r -k i = 0, k = 1, • • • , P -1, then Rs is given by, Rs = P i=1 γ i r M -P i 1 + 1 ri M -1 + 1 ri M -P P i=1 γ i r M -P i 1 + 1 ri M -1 (31)</formula><p>The achievability lower bound in Theorem 2 is shown in Section V and the upper bound is derived in Section VI-B. The following corollary states that the bounds in Theorem 2 match if the total number of messages is an integer multiple of the number of desired messages.</p><p>Corollary 3 For the MPIR problem with non-colluding and replicated databases, if M P is an integer, then the bounds in</p><formula xml:id="formula_39">Sun-Jafar [8] M C P s = 1 1+ M -P P N P P = M 2 P = M C P s = 1-1 N 1-(<label>1</label></formula><formula xml:id="formula_40">N ) M/P , if M P ∈ N P = 1</formula><p>Fig. <ref type="figure" target="#fig_11">2</ref>: Summary of the state of the results.</p><p>(27) match, and hence, for<ref type="foot" target="#foot_2">3</ref> N &gt; 1</p><formula xml:id="formula_41">C P s = 1 -1 N 1 -( 1 N ) M P , M P ∈ N,<label>(32)</label></formula><p>Proof: For the upper bound, observe that if M P ∈ N, then M P = M P . Hence, <ref type="bibr" target="#b27">(28)</ref> becomes</p><formula xml:id="formula_42">Rs = 1 -1 N 1 -( 1 N ) M P<label>(33)</label></formula><p>For the lower bound, consider the case M P ∈ N. From (30),</p><formula xml:id="formula_43">1 + 1 r i M = N 1/P e j2π(i-1)/P M = N M P (34) since e j2π(i-1)M/P = 1 for M P ∈ N. Similarly, 1 + 1 ri M -P = N M P -1 . Hence, if M P ∈ N, Rs = P i=1 γ i r M -P i N M P -N M P -1 P i=1 γ i r M -P i N M P -1 (35) = N M P -N M P -1 N M P -1 (36) = 1 -1 N 1 -( 1 N ) M P<label>(37)</label></formula><p>Thus, Rs = C P s = Rs if M P ∈ N, and we have an exact capacity result in this case.</p><p>Examining the result, we observe that when the total number of messages is an integer multiple of the number of desired messages, the sum capacity of the MPIR is the same as the capacity of the single-message PIR with the number of messages equal to M P . Note that, although at first the result may seem as if every P messages can be lumped together as a single message, and the achievable scheme in <ref type="bibr" target="#b7">[8]</ref> can be used, this is not the case. The reason for this is that, we need to ensure the privacy constraint for every subset of messages of size<ref type="foot" target="#foot_3">4</ref> P . That is why, in this paper, we develop a new achievable scheme. The state of the results is summarized in Fig. <ref type="figure" target="#fig_11">2</ref>: Consider the (M, P ) plane, where naturally M ≥ P . The valid part of the plane is divided into two regions. The first region is confined between the lines P = M 2 and P = M ; the sum capacity in this region is exactly characterized (Theorem 1). The second region is confined between the lines P = 1 and P = M 2 ; the sum capacity in this region is characterized only for the cases when M P ∈ N (Corollary 3). The line P = 1 corresponds to the previously known result for the single-message PIR <ref type="bibr" target="#b7">[8]</ref>. The exact capacity for the rest of the cases is still an open problem; however, the achievable scheme in Theorem 2 yields nearoptimal sum rates for all the remaining cases with the largest difference of 0.0082 from the upper bound, as discussed next. Fig. <ref type="figure" target="#fig_8">3</ref> shows the difference of the achievable rate Rs and the upper bound Rs in Theorem 2, i.e., Rs -Rs . The figure shows that the difference decreases as N increases. This difference in all cases is small and is upper bounded by 0.0082, which occurs when M = 5, P = 2, N = 2. In addition, the difference is zero for the cases P ≥ M 2 (Theorem 1) or M P ∈ N (Corollary 3). Fig. <ref type="figure">4</ref> shows the effect of changing M for fixed (P, N ). We observe that as M increases, the sum rate monotonically  (5, 2), <ref type="bibr" target="#b9">(10,</ref><ref type="bibr" target="#b4">5)</ref>, <ref type="bibr" target="#b19">(20,</ref><ref type="bibr" target="#b2">3)</ref>.</p><p>decreases and has a limit of 5 1 -1 N . In addition, Fig. <ref type="figure">5</ref> shows the effect of changing N for fixed (P, M ). We observe that as N increases, the sum rate increases and approaches 1, as expected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. ACHIEVABILITY PROOF FOR THE CASE P ≥ M 2</head><p>In this section, we present the general achievable scheme that attains the upper bound for the case P ≥ M 2 . The scheme applies the concepts of message symmetry, database symmetry, 5 Although it seems at first that</p><formula xml:id="formula_44">C P s → 1 -1 N if M → ∞,</formula><p>we emphasize that this is true if only P = o(M ), i.e., P does not scale with M . If P = γM , then as M → ∞, we have</p><formula xml:id="formula_45">C P s = 1 1+ 1-γ γN &gt; 1 -1 N , when γ &gt; 1 2</formula><p>, and</p><formula xml:id="formula_46">C P s = 1-1 N 1-( 1 N ) 1/γ &gt; 1 -1 N , when 1 γ ≥ 2 ∈ N.</formula><p>and exploiting side information as in <ref type="bibr" target="#b7">[8]</ref>. However, our scheme requires the extra ingredient of MDS coding of the desired symbols and the side information in its second stage. We note also that, here, by message symmetry, we mean symmetry across group of messages of size P , which is realized by MDS coding.</p><p>A. Motivating Example: M = 3, P = 2 Messages, N = 2 Databases</p><p>We start with a simple motivating example in this subsection. The scheme operates over message size N 2 = 4. For sake of clarity, we assume that the three messages after interleaving their indices are</p><formula xml:id="formula_47">W 1 = (a 1 , • • • , a 4 ) T , W 2 = (b 1 , • • • , b 4 ) T , and W 3 = (c 1 , • • • , c 4 ) T . We use G 2×3 Reed- Solomon generator matrix over F 3 as G 2×3 = 1 1 1 1 2 0 (38)</formula><p>The user picks a random permutation for the columns of G 2×3 from the 6 possible permutations, e.g., in this example we use the permutation 2, 1, 3. In the first round, the user starts by downloading one symbol from each database and each message, i.e., the user downloads (a 1 , b 1 , c 1 ) from the first database, and (a 2 , b 2 , c 2 ) from the second database. In the second round, the user encodes the side information from database 2 which is c 2 with two new symbols from W 1 , W 2 which are (a 3 , b 3 ) using the permuted generator matrix, i.e., the user downloads two equations from database 1 in the second round,</p><formula xml:id="formula_48">GS 1   a 3 b 3 c 2   = 1 1 1 1 2 0   0 1 0 1 0 0 0 0 1     a 3 b 3 c 2   = a 3 + b 3 + c 2 2a 3 + b 3<label>(39)</label></formula><p>The user repeats this operation for the second database with (a 4 , b 4 ) as desired symbols and c 1 as the side information from the first database.</p><p>For the decodability: The user subtracts out c 2 from round two in the first database, then the user can decode For the privacy: Single bit retrievals of (a 1 , b 1 , c 1 ) and (a 2 , b 2 , c 2 ) from the two databases in the first round satisfy message symmetry and database symmetry, and do not leak any information. In addition, due to the private shuffling of bit indices, the different coefficients of 1, 2 and 0 in front of the bits in the MDS-coded summations in the second round do not leak any information either; see a formal proof in Section IV-C. To see the privacy constraint intuitively from another angle, we note that the user can alter the queries for the second database when the queries for the first database are fixed, when the user wishes to retrieve another set of two messages. For instance, if the user wishes to retrieve (W 1 , W 3 ) instead of (W 1 , W 2 ), it can alter the queries for the second database by changing every c 2 in the queries of the second database with c The query table for this case is shown in Table <ref type="table" target="#tab_0">I</ref> below. The scheme retrieves a 1 , • • • , a 4 and b 1 , • • • , b 4 , i.e., 8 bits in 10 downloads (5 from each database). Thus, the achievable sum rate for this scheme is 8  10</p><formula xml:id="formula_49">= 4 5 = 1 1+ M -P P N</formula><p>. If we use the single-message optimal scheme in <ref type="bibr" target="#b7">[8]</ref>, which is given in <ref type="bibr" target="#b7">[8,</ref><ref type="bibr">Example 4.3]</ref> for this specific case, twice in a row to retrieve two messages, we achieve a sum rate of 20  28 = 5 7 &lt; 4 5 as discussed in the introduction. </p><formula xml:id="formula_50">= 3, P = 2, N = 2. Database 1 Database 2 a 1 , b 1 , c 1 a 2 , b 2 , c 2 a 3 + b 3 + c 2 a 4 + b 4 + c 1 2a 3 + b 3 2a 4 + b 4 B. General Achievable Scheme</formula><p>The scheme requires L = N 2 , and is completed in two rounds. The main ingredient of the scheme is the MDS coding of the desired symbols and side information in the second round. The details of the scheme are as follows.</p><p>1) Index preparation: The user interleaves the contents of each message randomly and independently from the remaining messages using a random interleaver π m (.) which is known privately to the user only, i.e.,</p><formula xml:id="formula_51">x m (i) = w m (π m (i)), i ∈ {1, • • • , L}<label>(40)</label></formula><p>where</p><formula xml:id="formula_52">X m = [x m (1), • • • , x m (L)]</formula><p>T is the interleaved message. Thus, the downloaded symbol x m (i) at any database appears to be chosen at random and independent from the desired message subset P. 2) Round one: As in <ref type="bibr" target="#b7">[8]</ref>, the user downloads one symbol from every message from every database, i.e., the user downloads</p><formula xml:id="formula_53">(x 1 (n), x 2 (n), • • • , x M (n))</formula><p>from the nth database. This implements message symmetry, symmetry across databases, and satisfies the privacy constraint. 3) Round two: The user downloads a coded mixture of new symbols from the desired messages and the undesired symbols downloaded from the other databases. Specifically, a) The user picks an MDS generator matrix G ∈ F P ×M q , which has the property that every P × P submatrix is full-rank. This implies that if the user can cancel out any M -P symbols from the mixture, the remaining symbols can be decoded. One explicit MDS generator matrix is the Reed-Solomon generator matrix over F q , where q &gt; M , <ref type="bibr" target="#b25">[26]</ref>, <ref type="bibr" target="#b26">[27]</ref>. The matrix is constructed by choosing M distinct elements of F q . Let us denote these elements by</p><formula xml:id="formula_54">{θ 1 , θ 2 , • • • , θ M }. Then, G =        1 1 1 • • • 1 θ 1 θ 2 θ 3 • • • θ M θ 2 1 θ 2 2 3 2 • • • θ 2 M . . . . . . . . . . . . . . . θ P -1 1 θ P -1 2 θ P -1 3 • • • θ P -1 M        P ×M<label>(41)</label></formula><p>b) The user picks uniformly and independently at random the permutation matrices S 1 , S 2 , • • • , S N -1 of size M × M . These matrices shuffle the order of the columns of G to be independent of P. c) At the first database, the user downloads an MDScoded version of P new symbols from the desired set P and M -P undesired symbols that are already decoded from the second database in the first round, i.e., the user downloads P equations of the form</p><formula xml:id="formula_55">GS 1 [x i1 (N + 1) x i2 (N + 1) • • • x i P (N + 1) x j1 (2) x j2 (2) • • • x j M -P (2)] T<label>(42)</label></formula><p>where P = {i 1 , i 2 , • • • , i P } are the indices of the desired messages and P = {j 1 , j 2 , • • • , j M -P } are the indices of the undesired messages. In this case, the user can cancel out the undesired messages and be left with a P ×P invertible system of equations that it can solve to get</p><formula xml:id="formula_56">[x i1 (N + 1), x i2 (N + 1), • • • , x i P (N + 1)]</formula><p>. This implements exploiting side information as in <ref type="bibr" target="#b7">[8]</ref>. d) The user repeats the last step for each set of side information from database 3 to database N , each with different permutation matrix. e) By database symmetry, the user repeats all steps of round two at all other databases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Decodability, Privacy, and Calculation of the Achievable Rate</head><p>Now, we verify that this achievable scheme satisfies the reliability and privacy constraints.</p><p>For the reliability: The user gets individual symbols from all databases in the first round, and hence they are all decodable by definition. In the second round, the user can subtract out all the undesired message symbols using the undesired symbols downloaded from all other databases during the first round. Consequently, the user is left with a P ×P system of equations which is guaranteed to be invertible by the MDS property, hence all symbols that belong to W P are decodable.</p><p>For the privacy: At each database, for every message subset P of size P , the achievable scheme retrieves randomly interleaved symbols which are encoded by the following matrix:</p><formula xml:id="formula_57">H P =        I P 0 P 0 P • • • 0 P 0 P G 1 P 0 P • • • 0 P 0 P 0 P G 2 P • • • 0 P . . . . . . . . . . . . . . . 0 P 0 P 0 P • • • G N -1 P       <label>(43)</label></formula><p>where G n P = GS n (:, P) are the columns of the encoding matrix that correspond to the message subset P after applying the random permutation S n . Since the permutation matrices are chosen uniformly and independently from each other, the probability distribution of H P is uniform irrespective to P (the probability of realizing such a matrix is</p><formula xml:id="formula_58">(M -P )! M ! N -1</formula><p>). Furthermore, the symbols are chosen randomly and uniformly by applying the random interleaver. Hence, the retrieval scheme is private.</p><p>To calculate the achievable rate: We note that at each database, the user downloads M individual symbols in the first round that includes P desired symbols. The user exploits the side information from the remaining (N -1) databases to generate P equations for each side information set. Each set of P equations in turn generates P desired symbols. Hence, the achievable rate is calculated as, In this section, we illustrate our achievable scheme with two more basic examples. In Section IV-A, we considered the case M = 3, P = 2, N = 2. In the next two sub-sections, we will consider examples with larger M , P (Section IV-D1), and larger N (Section IV-D2).</p><p>1) M = 5 Messages, P = 3 Messages, N = 2 Databases: Let P = {1, 2, 3}, and a to e denote the contents of W 1 to W 5 , respectively. The achievable scheme is similar to the example in Section IV-A. The main difference is that in this case, we use 5 × 5 permutation matrix for S 1 and G 3×5 Reed-Solomon generator matrix over F 5 as:</p><formula xml:id="formula_59">G 3×5 =   1 1 1 1 1 1 2 3 4 0 1 4 4 1 0   (48)</formula><p>The query table is shown in Table <ref type="table" target="#tab_1">II</ref> below with the following random permutation for the columns: 2, 5, 1, 3, 4. The reliability and privacy constraints are satisfied due to the MDS property that implies that any subset of 3 messages corresponds to a 3 × 3 invertible submatrix if the remaining symbols are decodable from the other database. This scheme retrieves</p><formula xml:id="formula_60">a 1 , • • • , a 4 , b 1 , • • • , b 4 and c 1 , • • • , c 4 , hence<label>12</label></formula><p>bits in 16 downloads (8 from each database). Thus, the achievable sum rate is 12 16 = 3 4 which equals the sum capacity <ref type="bibr" target="#b10">(11)</ref>. This strictly outperforms the repetition-based achievable sum rate 18  31 in <ref type="bibr" target="#b11">(12)</ref>. </p><formula xml:id="formula_61">1 1+ M -P P N in</formula><formula xml:id="formula_62">P = 3, N = 2. Database 1 Database 2 a 1 , b 1 , c 1 , d 1 , e 1 a 2 , b 2 , c 2 , d 2 , e 2 a 3 + b 3 + c 3 + d 2 + e 2 a 4 + b 4 + c 4 + d 1 + e 1 2a 3 + c 3 + 3d 2 + 4e 2 2a 4 + c 4 + 3d 1 + 4e 1 4a 3 + c 3 + 4d 2 + e 2 4a 4 + c 4 + 4d 1 + e 1</formula><p>2) M = 4 Messages, P = 2 Messages, N = 3 Databases: Next, we give an example with a larger N . Here, the message size is N 2 = 9. With a generator matrix <ref type="bibr">[1 : 4]</ref>) to be the upper left submatrix of the previous example and two set of random permutations (corresponding to S 1 , S 2 ) as 1, 3, 2, 4, and 4, 1, 3, 2. The query table is shown in Table III below. This scheme retrieves a 1 , • • • , a 9 and b 1 , • • • , b 9 , hence 18 bits in 24 downloads (8 from each database). Thus, the achievable rate is 18  24</p><formula xml:id="formula_63">G 2×4 = G 3×5 ([1 : 2],</formula><formula xml:id="formula_64">= 3 4 = 1 1+ M -P P N</formula><p>. This strictly outperforms the repetition-based achievable scheme sum rate 7  10 in (12).</p><p>V. ACHIEVABILITY PROOF FOR THE CASE P ≤ M</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>In this section, we describe an achievable scheme for the case P ≤ M 2 . We show that this scheme is optimal when the total number of messages M is an integer multiple of the number of desired messages P . The scheme incurs a small loss from the upper bound for all other cases. The scheme generalizes the ideas in <ref type="bibr" target="#b7">[8]</ref>. Different than <ref type="bibr" target="#b7">[8]</ref>, our scheme uses unequal number of stages for each round of download. Interestingly, the number of stages at each round can be thought of as the output of an all-poles IIR filter. Our scheme reduces to <ref type="bibr" target="#b7">[8]</ref> if we let P = 1. In the sequel, we define the ith round as the download queries that retrieve sum of i different symbols. We define the stage as a block of queries that exhausts all M i combinations of the sum of i symbols in the ith round.  <ref type="figure">c,</ref><ref type="figure">d,</ref><ref type="figure">e</ref>). Instead of designing the queries beginning from the top as usual, i.e., beginning by downloading individual symbols, we design the scheme backwards starting from the last round that corresponds to downloading sums of all five messages and trace back to identify the side information needed at each round from the other database. Our steps described below can be followed through in the query table in Table <ref type="table" target="#tab_4">IV</ref>. Now, let us fix the number of stages in the 5th round to be 1 as in <ref type="bibr" target="#b7">[8]</ref> since N = 2. Round 5 corresponds to downloading the sum of all five messages and contains one combination of symbols a + b + c + d + e; please see the last line in Table <ref type="table" target="#tab_4">IV</ref>. Since we wish to retrieve (a, b), we need one side information equation in the form of c + d + e from earlier rounds. The combination c+d+e can be created directly from round 3 without using round 4. Hence, we suppress round 4, as it does not create any useful side information in our case, and download one stage from round 3 to generate one side information equation c + d + e.</p><p>In round 3, we download sums of 3 messages. Each stage of round 3 consists of   In round 2, we download sums of 2 messages. Each stage of the second round contains 5  2 = 10 equations. In each stage, we need one category of side information equations, which is a + (c, d, e) and b + (c, d, e). This necessitates two different stages of individual symbols, i.e., two stages of round 1 for each stage of round 2.</p><p>Denoting α i to be the number of stages needed for the ith round, we sum all the required stages for round 1 to be α 1 = 2 • 2 + 1 = 5 stages. Hence, the user identifies the number stages as α 1 = 5, α 2 = 2, α 3 = 1, α 4 = 0, α 5 = 1. These can be observed in the query table in Table <ref type="table" target="#tab_4">IV</ref>. Note that, we have α 1 = 5 stages in round 1 where we download individual bits; then we have α 2 = 2 stages in round 2 where we download sums of two symbols; then we have α 3 = 1 stage in round 3 where we download sums of three symbols; we skip round 4 as α 4 = 0; and we have α 5 = 1 stage of round 5 where we download sum of all five symbols. Now, after designing the structure of the queries and the number of stages needed for each round, we apply the rest of the scheme described in <ref type="bibr" target="#b7">[8]</ref>. The user randomly interleaves the messages as usual. In the first round, the user downloads one symbol from each message at each database. This is repeated α 1 = 5 times for each database. Hence, the user downloads a 1:10 , b 1:10 , c 1:10 , d 1:10 , e 1:10 from the two databases. In the second round, the user downloads sums of two messages. Each stage contains 5  2 = 10 equations. This is repeated α 2 = 2 times. For example, in database 1, user exploits c 6 , d 6 , e 6 to get a 12 , a 13 , a Therefore, as seen in Table <ref type="table" target="#tab_4">IV</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Calculation of the Number of Stages</head><p>The main new ingredient of our scheme in comparison to the scheme in <ref type="bibr" target="#b7">[8]</ref> is the unequal number of stages in each round. In <ref type="bibr" target="#b7">[8]</ref>, the scheme is completed in M rounds, and each round contains only 1 stage only when N = 2. To generalize the ideas in Section V-A and calculate the number of stages needed per round, we use Vandermonde's identity</p><formula xml:id="formula_65">M i = P k=0 P k M -P i -k<label>(49)</label></formula><p>The relation in (49) states that any combination of i objects from a group of M objects must have k objects from a group of size P and i-k objects from a group of size M -P . In our context, the first group is the subset of the desired messages and the second group is the subset of the undesired messages. Then, the relation can be interpreted in our setting as follows:</p><p>In the ith round, the M i combinations of all possible sums of i terms can be sorted into P + 1 categories: The first category (i.e., k = 0), contains no terms from the desired messages, the second category contains 1 term from the desired messages and i -1 terms from the undesired messages, etc. The relation gives also the number of query subgroups of each category P k and the number of queries in each subgroup M -P i-k . Let us consider the following concrete example for clarification: Consider that we have 6 messages denoted by (a, b, c, d, e, f ), and the desired group to be retrieved is (a, b). Consider round 4 that consists of all combinations of sums of 4 symbols. From Vandermonde's identity, we know that   The number of queries of this group is 4  2 corresponding to all combinations of 2 undesired symbols.</p><p>Back to the calculation of the number of stages: To be able to cancel the undesired symbols from an i-term sum, the user needs to download these undesired symbols as side information in the previous rounds. Hence, round i requires downloading P 1 stages in round (i -1), P 2 stages in round (i-2), etc. Note that these stages need to be downloaded from the remaining (N -1) databases. Then, each database needs to download 1</p><formula xml:id="formula_66">N -1 P 1 stages in round (i -1), 1 N -1 P 2 stages in round (i -2), etc.</formula><p>From this observation, we can trace back the number of stages needed at each round. Denote α i to be the number of stages in round i. Fix the number of stages in the last round (round M ) to be α M = (N -1) M -P stages. This choice ensures that the number of stages in any round is an integer. Note that in round M , the user downloads a sum of all M messages, this requires side information in the form of the sum of the undesired M -P messages. Hence, we suppress the rounds M -P + 1 through M -1 since they do not generate useful side information. Note that the side information equations in round M at each database are collected from the remaining (N -1) databases. Then, the number of stages in round (M -P ) should be (N -1) M -P -1 . Therefore, we write</p><formula xml:id="formula_67">α M = (N -1) M -P (50) α M -1 = • • • = α M -P +1 = 0 (51) α M -P = 1 N -1 α M = 1 N -1 P i=1 P i α M -P +i (52)</formula><p>Now, in round (M -P ), each stage requires P 1 stages from round (M -P -1), P 2 stages from round (M -P -2), and so on so forth, and these stages are divided across (N -1) databases. Continuing with the same argument, for each round, we write</p><formula xml:id="formula_68">α M -P -1 = 1 N -1 P 1 α M -P = 1 N -1 P i=1 P i α M -P -1+i (53) α M -P -2 = 1 N -1 P 1 α M -P -1 + 1 N -1 P 2 α M -P = 1 N -1 P i=1 P i α M -P -2+i<label>(54)</label></formula><p>. . .</p><formula xml:id="formula_69">α k = 1 N -1 P i=1 P i α k+i<label>(55)</label></formula><p>Interestingly, this pattern closely resembles the output of an IIR filter y[n] <ref type="bibr" target="#b23">[24]</ref>, with the difference equation,</p><formula xml:id="formula_70">y[n] = 1 N -1 P i=1 P i y[n -i]<label>(56)</label></formula><p>and with the initial conditions y[-P ] = (N -1) M -P , y[-</p><formula xml:id="formula_71">P + 1] = • • • = y[-1] = 0.</formula><p>Note that the only difference between the two seemingly different settings is the orientation of the time axis. The calculation of the number of stages is obtained backwards in contrast to the output of this IIR filter. Hence, we can systematically obtain the number of stages at each round by observing the output of the IIR filter characterized by ( <ref type="formula" target="#formula_70">56</ref>), and mapping it to the number of stages via</p><formula xml:id="formula_72">α k = y[(M -P ) -k].</formula><p>We note that for the special case P = 1, the number of stages can be obtained from the first order filter y</p><formula xml:id="formula_73">[n] = 1 N -1 y[n-1]. The output of this filter is y[n] = (N -1) M -2-n . Then, the number of stages in round k is α k = y[M -1-k] = (N -1) k-1</formula><p>, which is exactly the number of stages used in <ref type="bibr" target="#b7">[8]</ref>; in particular if N = 2, then α k = 1 for all k.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. General Achievable Scheme</head><p>1) Index preparation: The user interleaves the contents of each message randomly and independently from the remaining messages using a random interleaver π m (.) which is known privately to the user only, i.e.,</p><formula xml:id="formula_74">x m (i) = w m (π m (i)), i ∈ {1, • • • , L}<label>(57)</label></formula><p>2) Number of stages: We calculate the number of stages needed in each round. This can be done systematically by finding the output of the IIR filter characterized by,</p><formula xml:id="formula_75">y[n] = 1 N -1 P i=1 P i y[n -i]<label>(58)</label></formula><p>with the initial conditions y[-P ] = (N -1) M -P , y[-P</p><formula xml:id="formula_76">+ 1] = • • • = y[-1] = 0.</formula><p>The number of stages in round i is α i = y[(M -P )i] as discussed in Section V-B. 3) Initialization: From the first database, the user downloads one symbol from each message that belongs to the desired message set P. The user sets the round index to i = 1. 4) Message symmetry: In round i, the user downloads sums of i terms from different symbols from the first database.</p><p>To satisfy the privacy constraint, the user should download an equal amount of symbols from all messages. Therefore, the user downloads the remaining M -P i combinations in round i from the undesired symbol set P. For example: In round 1, the user downloads one symbol from every undesired message with a total of M -P 1</p><p>= M -P such symbols. 5) Repetition of stages: In the first database, the user repeats the operation in round i according to the number of calculated stages α i . This in total results in downloading α i M -P i undesired equations, and α i M i -M -P i desired equations. 6) Symmetry across databases: The user implements symmetry across databases by downloading α i M -P i new undesired equations, and α i M i -M -P i new desired equations from each database. These undesired equations will be used as side information in subsequent rounds. For example: In round 1, each database generates α 1 (M -P ) undesired equations in the form of individual symbols. Hence, each database can exploit up to α 1 (N -1)(M -P ) side information equations from other (N -1) databases. 7) Exploiting side information: Until now, we did not specify how the desired equations are constructed. Since each stage in round i can be categorized using Vandermonde's identity as in the previous section, we form the desired equations as a sum of the desired symbols and the undesired symbols that can be decoded from other databases in the former (i -1) rounds. If the user sums two or more symbols from P, the user downloads one new symbol from one message only and the remaining symbols from P should be derived from other databases. Thus, in round (i + 1), the user mixes one symbol of P with the sum of i undesired symbols from round i. This should be repeated for all P 1 desired symbols. Then, the user mixes each sum of 2 desired symbols with the sum of (i -1) undesired symbols generated in the (i -1)th round. This should be repeated for all the P 2 combinations of the desired symbols, and so on. 8) Repeating steps: Repeat steps 4, 5, 6, 7 by setting i = i+1 until i = M -P -1. 9) Last round: We note that rounds M -P + 1 to M -1 do not generate useful side information. Hence, α</p><formula xml:id="formula_77">M -P +1 = • • • = α M -1 = 0.</formula><p>In round M , which corresponds to summing all M messages, the user mixes P symbols from P (only one of them is new and the remaining are previously decoded from the other (N -1) databases) and M -P undesired symbol mixture that was generated in round (M -P ). 10) Shuffling the order of queries: After preparing the query table, the order of the queries are shuffled uniformly, so that all possible orders of queries are equally likely regardless of P.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Decodability, Privacy, and Calculation of the Achievable Rate</head><p>Now, we verify that the proposed scheme satisfies the reliability and privacy constraints.</p><p>For the reliability: The scheme is designed to download the exact number of undesired equations that will be used as side information equation at subsequent rounds in other databases. <ref type="foot" target="#foot_4">6</ref> Hence, each desired symbol at any round is mixed with a known mixture of symbols that can be decoded from other databases. Note that if the scheme encounters the case of having a mixture of desired symbols, one of them only is chosen to be new and the remaining symbols are downloaded previously from other databases. Thus, the reliability constraint is satisfied by canceling out the side information.</p><p>For the privacy: The randomized mapping of message bits and the randomization of the order of queries guarantees privacy as in <ref type="bibr" target="#b7">[8]</ref>. It can be checked that when we fix the queries for one database, we can adjust the queries for the remaining databases such that the user can decode any P subset of messages. This is true since all combinations of messages are generated by our scheme.</p><p>To calculate the achievable rate: From Vandermonde's identity M i = P p=0 P p M -P i-p , round i requires downloading P p stages in round (i-p). These stages should be downloaded from the remaining (N -1) databases. Hence, as shown in the previous section, the number of stages at each round is calculated as the output of an IIR filter whose inputoutput relation is given in (56) with the initial conditions y[-P ] = (N -1) M -P , y[-P</p><formula xml:id="formula_78">+ 1] = • • • = y[-1] = 0,</formula><p>with the conversion of time index of the filter to the round index of the schemes as α i = y[(M -P )i]. These initial conditions imply that the user downloads (N -1) M -P stages the last round that corresponds to downloading the sum of all messages. The (P -1) rounds before the last round are suppressed because we only need to form sums of (M -P ) messages to be used in the last round. Now, to calculate the number of stages for round i, we first solve for the roots of the characteristic equation of (56) <ref type="bibr" target="#b23">[24]</ref>,</p><formula xml:id="formula_79">r P - 1 N -1 P i=1 P i r P -i = 0<label>(59)</label></formula><p>which is equivalent to</p><formula xml:id="formula_80">r P - r P N -1 P i=1 P i r -i = 0<label>(60)</label></formula><p>which further reduces to</p><formula xml:id="formula_81">r P - r P N -1 1 + 1 r P -1 = 0<label>(61)</label></formula><p>using the binomial theorem. Simplifying (61), we have</p><formula xml:id="formula_82">N r P -(r + 1) P = 0<label>(62)</label></formula><p>By applying the bijective mapping t = N 1/P • r r+1 , (62) is equivalent to t P = 1. The roots for this equation are the normal roots of unity, i.e., t k = e j2π(k-1)/P , k = 1, • • • , P , where j = √ -1. Hence, the roots of the characteristic equation are given by,</p><formula xml:id="formula_83">r k = t k N 1/P -t k = e j2π(k-1)/P N 1/P -e j2π(k-1)/P , k = 1, • • • , P<label>(63)</label></formula><p>Thus, the complete response of the IIR filter is given by y[n] = P i=1 γ i r n i , where γ i are constants that result from solving the initial conditions, i.e., γ = (γ 1 , • • • , γ P ) T is the solution of the system of equations,</p><formula xml:id="formula_84">     r -P 1 r -P 2 • • • r -P P r -P +1 1 r -P +1 2 • • • r -P +1 P . . . . . . • • • . . . r -1 1 r -1 2 • • • r -1 P           γ 1 γ 2 . . . γ P      =      (N -1) M -P 0 . . . 0     <label>(64)</label></formula><p>Now, we are ready to calculate the number of stages α k in round k. Since α k = y[(M -P )k] by construction, then</p><formula xml:id="formula_85">α k = P i=1 γ i r M -P -k i (65)</formula><p>In round k, the user downloads sums of k symbols. The user repeats this round for α k stages. Each stage contains all the combinations of any k symbols which there are M k of them. Hence, the total download cost D is,</p><formula xml:id="formula_86">D = M k=1 M k α k (66) = M k=1 P i=1 M k γ i r M -P -k i (67) = P i=1 γ i r M -P i M k=1 M k r -k i (68) = P i=1 γ i r M -P i 1 + 1 r i M -1<label>(69)</label></formula><p>Considering the undesired equations: in round k, the user downloads all combinations of the (M -P ) undesired messages which there are M -P k of them. Therefore, similar to the above calculation, the total number of undesired equations U is,</p><formula xml:id="formula_87">U = P i=1 γ i r M -P i 1 + 1 r i M -P -1<label>(70)</label></formula><p>Hence, the achievable rate Rs is</p><formula xml:id="formula_88">Rs = D -U D<label>(71)</label></formula><formula xml:id="formula_89">= P i=1 γ i r M -P i 1 + 1 ri M -1 + 1 ri M -P P i=1 γ i r M -P i 1 + 1 ri M -1<label>(72)</label></formula><p>which is (31) in Theorem 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Further Examples for the Case</head><formula xml:id="formula_90">P ≤ M 2</formula><p>In this section, we illustrate our proposed scheme with a few additional basic examples. In Section V-A, we considered the case M = 5, P = 2, N = 2. In the next three sub-sections, we consider three more examples. In the example in Section V-E1, the ratio M P is exactly equal to 2, thus, both the achievable scheme here and the achievable scheme in Section IV can be used; we comment about the differences and advantages of both schemes. In the example in Section V-E2, we present the case of a larger N for the example in Section V-A. In the example in Section V-E3, we present a case with larger M , P and N .</p><p>1) M = 4 Messages, P = 2 Messages, N = 2 Databases: The first step of the achievable scheme is to identify the number of stages needed for each round of download. The IIR filter in (56) that determines the number of stages reduces in this case to</p><formula xml:id="formula_91">y[n] = 2y[n -1] + y[n -2]<label>(73)</label></formula><p>with the initial conditions y</p><formula xml:id="formula_92">[-2] = 1, y[-1] = 0. The number of stages in round k is α k = y[2 -k].</formula><p>Since M is small, we can calculate the output iteratively without using the canonical filter output as,</p><formula xml:id="formula_93">α 4 = y[-2] = 1 (74) α 3 = y[-1] = 0 (75) α 2 = y[0] = 2y[-1] + y[-2] = 1 (76) α 1 = y[1] = 2y[0] + y[-1] = 2<label>(77)</label></formula><p>Hence, we should download 2 stages of individual symbols (round 1), and 1 stage of sums of two symbols (round 2). We should suppress the round that retrieves sums of three symbols (round 3), and have 1 stage of sums of all four symbols (round 4). The user initializes the scheme by randomly and independently interleaving the symbols of each message. The query table for this example is shown in Table <ref type="table" target="#tab_5">V</ref>. In round 1, the user downloads individual symbols from all messages at each database. The user downloads a 1 , b 1 , c 1 , d 1 and a 2 , b 2 , c 2 , d 2 from database 1, as α 1 = 2. This is repeated for database 2. In round 2, the user downloads sums of two symbols. There are  , which matches the upper bound in Theorem 2. This sum rate outperforms the repetition-based achievable rate which is 3  5 in <ref type="bibr" target="#b11">(12)</ref>. We note that this case can be solved using the achievable scheme presented in Section IV as well since M P = 2 in this case. In fact, this is equivalent to the case considered in Section IV-D2, if the number of databases is reduced from </p><formula xml:id="formula_94">N = 3 to N = 2. Starting from</formula><formula xml:id="formula_95">= 2 3 = 1 1+ 1 N .</formula><p>We presented this case here even though it could be solved using the scheme in Section IV, in order to give an example where the second achievable scheme achieves the upper bound in Theorem 2 and yields a capacity result since M P is an integer. Interestingly, we observe that for all cases where P = M 2 , the two achievable schemes are both optimal. The two schemes present an interesting trade-off between the field size and the upload cost: The first achievable scheme in Section IV requires using an MDS code with field size q ≥ M but the number of queries for each database is limited to M + P . On the other hand, the second achievable scheme here in Section V does not use any coding and can work with the storage field size, however, the number of queries increase exponentially since the number of stages for each round is related to an unstable IIR filter.</p><p>2) M = 5 Messages, P = 2 Messages, N = 3 Databases: In this example, we show an explicit query structure for N &gt; 2. In this case the corresponding difference equation for the IIR filter is</p><formula xml:id="formula_96">y[n] = y[n -1] + 1 2 y[n -2]<label>(78)</label></formula><p>with the initial conditions y[-1] = 0, y[-2] = (N -1) M -P = 8. Thus, the number of stages in each round are: 3) M = 7 Messages, P = 3 Messages, N = 3 Databases: Finally, in this section, we consider an example with N = 3 databases and larger M and P than in previous examples, where we describe the structure and the calculation of the number of queries without specifying the explicit query table as it grows quite large. We first calculate the number of stages at each round. The corresponding IIR filter is  <ref type="figure">d,</ref><ref type="figure">e,</ref><ref type="figure">f,</ref><ref type="figure">g</ref>). This means that for each stage of round 3, the user needs 1 stage of round 1, 3 stages of round 2, and 3 stages of round 3. This in total requires 8 • 3 = 24 stages from round 2 and 3 and 8 • 1 stages from round 1 and hence, we exhaust all the generated side information by round 4. Round 4 generates 8 stages of side information in the form of sums of fours. This will be used in the last round to get 8 • 2 new symbols from the desired messages.</p><formula xml:id="formula_97">α 1 = 6, α 2 = 4, α 3 = 4, α 4 = 0, α 5 = 8.</formula><formula xml:id="formula_98">y[n] = 1 2 (3y[n -1] + 3y[n -2] + y[n -3])<label>(79</label></formula><p>The achievable sum rate in this case is 3933 5445 = 437 605 &lt;</p><formula xml:id="formula_99">1 1+ 1 N + 1 3N 2 =<label>27</label></formula><p>37 . The gap is 166 22385 0.0074.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. CONVERSE PROOF</head><p>In this section, we derive an upper bound for the MPIR problem <ref type="foot" target="#foot_9">7</ref> . The derived upper bound is tight when P ≥ M 2 and when M P ∈ N. We follow the notations and simplifications in <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b11">[12]</ref>, and we define</p><formula xml:id="formula_100">Q Q [P] n : P ⊆ {1,• • • ,M }, |P| = P, n ∈ {1,• • • ,N }<label>(80)</label></formula><p>and</p><formula xml:id="formula_101">A [P] n1:n2 A [P] n1 , A [P] n1+1 , • • • , A [P] n2<label>(81)</label></formula><p>for</p><formula xml:id="formula_102">n 1 ≤ n 2 , n 1 , n 2 ∈ {1, • • • , N }.</formula><p>Without loss of generality, the following simplifications hold for the MPIR problem: 1) We can assume that the MPIR scheme is symmetric.</p><p>Since for every asymmetric scheme, there exists an equal rate symmetric scheme that can be constructed by replicating all permutations of databases and messages. 2) To invoke the privacy constraint, we fix the response of one database to be the same irrespective of the desired set of messages P, i.e., A</p><formula xml:id="formula_103">[Pi] n = A n , where |P i | = P for every i ∈ {1, 2, • • • , β} for some n ∈ {1, • • • , N }, and β = M P .</formula><p>No loss of generality is incurred due to the fact that the queries and the answers are statistically independent from P. In the sequel, we fix the answer string of the first database, i.e., The following lemma is a consequence of the symmetry assumption; its proof can be found in <ref type="bibr" target="#b7">[8]</ref>.</p><formula xml:id="formula_104">[P] 1 = A 1 , ∀P<label>(82)</label></formula><p>Lemma 1 (Symmetry <ref type="bibr" target="#b7">[8]</ref>) For any W S = {W i : i ∈ S}</p><formula xml:id="formula_105">H(A [P] n |W S , Q) = H(A [P] 1 |W S , Q), n ∈ {1,• • • ,N } (83) H(A 1 |Q) = H(A [P] n |Q), n ∈ {1,• • • ,N }, ∀P<label>(84)</label></formula><p>We construct the converse proof by induction over M P in a similar way to <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b11">[12]</ref>. The base induction step is obtained for 1 ≤ M P ≤ 2 (this is the case P ≥ M 2 as it was referred to so far, where the user wants to retrieve at least half of the messages). We obtain an inductive relation for the case M P &gt; 2. The converse proof extends the proof in <ref type="bibr" target="#b7">[8]</ref> for P &gt; 1.</p><p>A. Converse Proof for the Case 1 ≤ M P ≤ 2 To prove the converse for the case 1 ≤ M P ≤ 2, we need the following lemma which gives a lower bound on the interference within an answer string.</p><p>Lemma 2 (Interference Lower Bound) For the MPIR problem with P ≥ M 2 , the uncertainty of the interfering messages W P +1:M within the answer string A is lower bounded as,</p><formula xml:id="formula_106">H(A [1:P ] 1 |W 1:P , Q) ≥ (M -P )L N<label>(85)</label></formula><p>Furthermore, (85) is true for any set of desired messages P with |P| = P , i.e.,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>H(A</head><formula xml:id="formula_107">[P] 1 |W P , Q) ≥ (M -P )L N<label>(86)</label></formula><p>Proof: For clarity of presentation, we assume that P = {1, • • • , P } without loss of generality. Hence,  </p><formula xml:id="formula_108">(M -P )L = H(W P +1:M ) (87) = H(W P +1:M |W 1:P , Q) (88)</formula><p>= N H(A 1 |W 1:P , Q)</p><p>where (88) follows from the independence of the messages P +1:M from the messages W 1:P and the queries as in ( <ref type="formula" target="#formula_3">2</ref>) and ( <ref type="formula">3</ref>); (89) follows from the reliability constraint <ref type="bibr" target="#b6">(7)</ref>, since messages W P +1:M can be decoded correctly from the answer strings A Consequently, H(A 1 |W 1:P , Q) ≥ (M -P )L</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>N</head><p>. The proof of the general statement can be done replacing W 1:P by W P , W P +1:M by W P which corresponds to the complement set of messages of W P , and the answer strings A   </p><p>where β = M P represents the total number of message subsets of size P that can be constructed from M messages; (95) follows from the independence between the messages and the queries; (96) follows from the reliability constraint in <ref type="bibr" target="#b6">(7)</ref> with noting that A </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>(M -P ) , N P N +(M -P ) , • • • , N P N +(M -P )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>= 20 Fig. 3 :</head><label>203</label><figDesc>Fig. 3: Deviation of the achievable sum rate from the upper bound.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>2 Fig. 4 :</head><label>24</label><figDesc>Fig. 4: Effect of changing M for fixed P = 5, 6, 10 and fixed N = 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>3 Fig. 5 :</head><label>35</label><figDesc>Fig.5: Effect of changing N for fixed (M, P ) = (5, 2),<ref type="bibr" target="#b9">(10,</ref><ref type="bibr" target="#b4">5)</ref>,<ref type="bibr" target="#b19">(20,</ref><ref type="bibr" target="#b2">3)</ref>.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>(a 3 , b 3 ) from a 3 + b 3 and 2a 3 + b 3 . Similarly, by subtracting out c 1 from round two in the second database, the user can decode (a 4 , b 4 ) from a 4 + b 4 and 2a 4 + b 4 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>3 , c 1 with c 4 , b 2 with b 3 , and b 4 with b 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Examples for the Case P ≥ M 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>A</head><label></label><figDesc>. Motivating Example: M = 5, P = 2 Messages, N = 2 Databases To motivate our achievable scheme, consider the case of retrieving two messages denoted by letters (a, b) from five stored messages denoted by letters (a, b,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>5 3 =</head><label>3</label><figDesc>10 equations. One of those 10 equations is in the desired c + d + e form, and the remaining 9 of them have either a or b or both a, b in them. In tabulating all these 9 combinations, we recognize two categories of side information equations needed from earlier rounds. The first category corresponds to equations of the form a + b + (c, d, e), where (c, d, e) means possible choices for the rest of the equation, i.e., these equations have both a and b in them and plus one more symbol in the form of c or d or e. This category</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>a 5 + b 5 + c 3 + d 3 a 7 + b 7 + c 3 + d 3 a 9 + b 9 +</head><label>557799</label><figDesc>c 2 + d 2 4a 5 + b 5 + 3c 3 + 2d 3 4a 7 + b 7 + 3c 3 + 2d 3 4a 9 + b 9 + 3c 2 + 2d 2 requires downloading one stage of individual symbols (i.e., an individual c or d or e), that is, one stage of round 1. We note also that one of the symbols (a, b) should be known as a side information from the second database in order to solve for the remaining new symbol. The second category corresponds to equations of the form a + (c + d, c + e, d + e) and b + (c + d, c + e, d + e), i.e., these equations have only one of a or b but not both. This category requires two stages of round 2, as we need different side information equations that contain sum of twos, e.g., c + d, c + e, d + e.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>14 and c 7 , d 7 , e 7 to obtain b 11 , b 12 , b 13 . These are from round 1. Round 2 generates c 11 + d 11 , c 12 + e 11 , d 12 + e 12 from stage 1, and c 13 + d 13 , c 14 + e 13 , d 14 + e 14 from stage 2 as side information for round 3. In round 3, the user downloads sum of three symbols. There are 5 3 = 10 of them. Symbols c 10 , d 10 , e 10 downloaded from round 1 in database 2 are used to be summed with mixtures of a + b. The two sets of side information generated in the second round are exploited in the equations that have one a or b. Note that for each such equation, one of a or b is new and the other one is decoded from database 2. Round 3 generates one side information as c 19 + d 19 + e 19 that is used in round 5. This last round includes the sum of all five messages.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>2 .</head><label>2</label><figDesc>Which means that there are three categories of sums: First category is with only undesired messages; we have 2 0 = 1 query subgroup of the form c + d + e + f . The second category is to have 1 term from the desired group and the remaining are undesired; we have 2 1 = 2 query subgroups, one corresponds to a with combinations of 3 terms from c, d, e, f , and the other to b with combinations of 3 terms from c, d, e, f . Each query subgroup</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>contains 4 3 2 = 1</head><label>321</label><figDesc>queries, i.e., the first query subgroup is of the form a + (c + d + e, c + d + f, c + e + f, d + e + f ) and the second query subgroup is of the form b + (c + d + e, c + d + f, c + e + f, d + e + f ). Third category is to have 2 terms from the desired group and 2 terms from the undesired group; we have 2 query subgroup of this category that takes the form a + b + (c + d, c + e, • • • ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>4 2 = 6</head><label>46</label><figDesc>such equations. At database 1, the undesired symbols from database 2 in the first round are exploited in some of</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>)with the initial conditions y[-3] = (N -1) M -P = 16, y[-2] = 0, y[-1] = 0. Hence, the number of stages for each roundα k = y[4k], k = 1, • • • , 7, are calculated iteratively as α 1 = 67, α 2 = 30, α 3 = 12, α 4 = 8, α 5 = 0, α 6 = 0, α 7 = 16.In round 1, the user downloads 67 individual symbols from each message and from each database. Each database can use the side information generated by the other two databases. Hence, each database has 67 • 2 = 134 side information equations in the form of single symbols from round 1 to exploit. In round 2, the user downloads sums of two symbols. Each stage in round 2 requires 3 stages from round 1, since the user faces with a + (d, e, f, g), b + (d, e, f, g) or c + (d, e, f, g) cases. Then, round 2 requires 30 • 3 = 90 stages from the generated side information in round 1, and we are left with 134 -90 = 44 more stages of round 1. Each database can use the side information stages from the other two databases, i.e., each can use up to 2 • 30 = 60 stages of side information in the form of sums of two.In round 3, the user downloads sums of three symbols, which can be either of a + b + (d, e, f, g), a + c + (d, e, f, g), b + c + (d, e, f, g), a + (d + e, d + f, • • • ), and similarly for b, c. Therefore, each stage in round 3 requires 3 stages from round 2, and 3 stages from round 1. This in total requires 12 • 3 = 36 stages from round 1 and 36 stages from round 2, and we will be left with 8 stages from round 1 and 24 stages from round 2. Round 3 generates 2•12 = 24 stages of side information in the form of sums of threes. In round 4, the user downloads sums of 4 symbols, which can be either a + b + (d + e, d + f, • • • ), and similarly for b + c and a + c, a + (d + e + f, d + e + g, • • • ) and similarly for b, c, or a + b + c + (</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>3 a</head><label>3</label><figDesc>a 105 + d 24 + e 24 b 67 + c 33 + d 33 b 85 + c 25 + d 25 b 103 + c 25 + d 25 b 68 + c 34 + e 33 b 86 + c 26 + e 25 b 104 + c 26 + e 25b 69 + d 34 + e 34 b 87 + d 26 + e 26 b 105 + d 26 + e 26 c 44 + d 44 + e 44 c 48 + d 48 + e 48 c 52 + d 52 + e 52 stage 70 + b 14 + c 17 a 88 + b 14 + c 17 a 106 + b 8 + c 11 a 14 + b 70 + d 17 a 14 + b 88 + d 17 a 8 + b 106 + d 11 a 71 + b 15 + e 17 a 89 + b 15 + e 17 a 107 + b 9 + e 11 a 72 + c 35 + d 35 a 90 + c 35 + d 35 a 108 + c 27 + d 27 a 73 + c 36 + e 35 a 91 + c 36 + e 35 a 109 + c 28 + e 27 a 74 + d 36 + e 36 a 92 + d 36 + e 36 a 110 + d 28 + e 28 b 71 + c 37 + d 37 b 89 + c 37 + d 37 b 107 + c 29 + d 29 b 72 + c 38 + e 37 b 90 + c 38 + e 37 b 108 + c 30 + e 29 b 73 + d 38 + e 38 b 91 + d 38 + e 38 b 109 + d 30 + e 30 c 45 + d 45 + e 45 c 49 + d 49 + e 49 c 53 + d 53 + e 53= H(W P +1:M |W 1:P , Q) -H(W P +1:M |A [M -P +1:M ] 1:N , W 1:P , Q) (89) = I(W P +1:M ; A [M -P +1:M ] n |W 1:P , Q)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head></head><label></label><figDesc>if P ≥ M 2 as {P + 1, • • • , M } ⊆ {M -P + 1, • • • , M } inthis regime; (91) follows from the fact that the answer strings are deterministic functions of all messages and queries (Q, W 1:M ); and (93) follows from the independence bound and Lemma 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>M 2 .</head><label>2</label><figDesc>[M -P +1:M ] 1:N by A [P * ] 1:N , where P ⊆ P * , |P * | = P . Now, we are ready to prove the converse of the case P ≥ We use a similar converse technique to the case of M =</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head></head><label></label><figDesc>,• • •,A [P β ] 2:N |A 1 , W P1 , Q) (102) |W P1 , Q) -H(A 1 |W P1 , Q)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head></head><label></label><figDesc>represent all answer strings from all databases to every possible subset of messagesP i ⊆ {1, • • • , M }, i = 1, 2, • • • , β,hence all messages can be correctly decoded as all possible answer strings are known; (98) follows from the fact that answer strings are deterministic functions of the messages and the queries; (99) follows from simplification (82) without loss of generality; (101) follows from the fact that the messagesW P = (W i1 , W i2 , • • • , W i P )can be reconstructed from A [P] 1:N ; and (102) is a consequence of the fact that conditioning does not increase entropy and Lemma 1. Now, every message appears in -1 P -1 different message subsets of size P , therefore the answer strings (A [P2] 1:N , • • • , A [P β ] 1:N ) are sufficient to construct all messages W 1:M irrespective of P 1 . Therefore, , • • • , A [P β ] 1:N |W P1 , Q) = (M -P )L (104) Using this and Lemma 2 in (103) yields M L ≤ N n=1 H(A [P1] n |Q) + (M -P )L -(M -P )L N</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>TABLE I :</head><label>I</label><figDesc>The query table for the case M</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE II :</head><label>II</label><figDesc>The query table for M = 5,</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE III :</head><label>III</label><figDesc>The query table for the caseM = 4, P = 2, N = 3. , b 1 , c 1 , d 1 a 2 , b 2 , c 2 , d 2 a 3 , b 3 , c 3 , d 3 a 4 + b 4 + c 2 + d 2 a 6 + b 6 + c 1 + d 1 a 8 + b 8 + c 1 + d 1 a 4 + 3b 4 + 2c 2 + 4d 2 a 6 + 3b 6 + 2c 1 + 4d 1 a 8 + 3b 8 + 2c 1 + 4d 1</figDesc><table><row><cell>Database 1</cell><cell>Database 2</cell><cell>Database 3</cell></row><row><cell>a 1</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>, we have retrieved a 1 , • • • , a 34 and b1• • • , b 34 , i.e., 68 bits in a total of 112 downloads (56 from each database). Thus, the achievable sum rate is 68 112 = 17 28 . This is Rs in Theorem 2, whereas the upper bound Rs in Theorem 2 is Rs and Rs over all possible values of M , P and N .</figDesc><table><row><cell>364 Rs and Rs is equal to 3 possible gap between</cell><cell>1 N + 1 1+ 1 2N 2 0.0082, which also is the largest = 8 13 . The gap between</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>TABLE IV :</head><label>IV</label><figDesc>The query table for the case M = 5, P = 2, N = 2. , b 1 , c 1 , d 1 , e 1 a 6 , b 6 , c 6 , d 6 , e 6 stg 2 a 2 , b 2 , c 2 , d 2 , e 2 a 7 , b 7 , c 7 , d 7 , e 7 stg 3 a 3 , b 3 , c 3 , d 3 , e 3 a 8 , b 8 , c 8 , d 8 , e 8 stg 4 a 4 , b 4 , c 4 , d 4 , e 4 a 9 , b 9 , c 9 , d 9 , e 9 stg 5 a 5 , b 5 , c 5 , d 5 , e 5 a 10 , b 10 , c 10 , d 10 , e 10 14 + e 6 a 21 + e 1 b 11 + c 7 b 18 + c 2 b 12 + d 7 b 19 + d 2 b 13 + e 7 b 20 + e 2 c 11 + d 11 c 15 + d 15 c 12 + e 11 c 16 + e 15 d 12 + e 12 d 16 + e 16 stage 2 a 6 + b 14 a 1 + b 21 a 15 + c 8 a 22 + c 3 a 16 + d 8 a 23 + d 3 a 17 + e 8 a 24 + e 3 b 15 + c 9 b 22 + c 4 b 16 + d 9 b 23 + d 4 b 17 + e 9 b 24 + e 4 c 13 + d 13 c 17 + d 17 c 14 + e 13 c 18 + e 17 d 14 + e 14 d 18 + e 18 25 + b 7 + c 10 a 2 + b 29 + c 5 a 7 + b 25 + d 10 a 30 + b 2 + d 5 a 26 + b 8 + e 10 a 3 + b 30 + e 5 a 27 + c 15 + d 15 a 31 + c 11 + d 11 a 28 + c 16 + e 15 a 32 + c 12 + e 11 a 29 + d 16 + e 16 a 33 + d 12 + e 12 b 26 + c 17 + d 17 b 31 + c 13 + d 13 b 27 + c 18 + e 17 b 32 + c 14 + e 13 b 28 + d 18 + e 18 b 33 + d 14 + e 14 c 19 + d 19 + e 19 c 20 + d 20 + e 20 rd. 5 stg 1 a 8 + b 34 + c 20 + d 20 + e 20 a 34 + b 3 + c 19 + d 19 + e 19</figDesc><table><row><cell>Database 1</cell><cell>Database 2</cell></row><row><cell>round 1 a 1 round 2 stg 1 stage 1 stage 1 a round 3 a 11 + b 6 a 12 + c 6 a 13 + d 6 a</cell><cell>a 18 + b 1 a 19 + c 1 a 20 + d 1</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>TABLE V :</head><label>V</label><figDesc>The query table for the case M = 4, P = 2, N = 2. , b 1 , c 1 , d 1 a 3 , b 3 , c 3 , d 3 stg 2 a 2 , b 2 , c 2 , d 2 a 4 , b 4 , c 4 , d 4 + b 10 + c 6 + d 6 a 10 + b 1 + c 5 + d 5 these sums. These equations are either in the form + (c, d) or in the form b + (c, d). This necessitates two sets of different individual symbols to be downloaded from database 2 in the first round, or otherwise the symbols are repeated and privacy is compromised. Moreover, we note that the user downloads a 5 + b 3 which uses b 3 as side information even though W 2 is desired; this is reversed in database 2 to download a 1 +b 7 with a 1 as a side information to have a symmetric scheme. Round 2 concludes with downloading c 5 + d 5 and c 6 + d 6 at the two databases, which will be used as side information in the last round. Round 3 is skipped and the user proceeds to round 4 (last round) directly. In round 4, the user downloads sum of four symbols, and uses the side information downloaded in round 2 and any decoded symbols for the other desired message. For example, in database 1, the user downloads a 3 + b 10 + c 6 + d 6 , hence, the side information c 6 + d 6 is exploited in this round as well as a 3 . The user finishes the scheme by shuffling the order of all queries randomly. The user retrieves a 1 , • • • , a 10 and b 1 , • • • , b</figDesc><table><row><cell></cell><cell cols="2">Database 1</cell><cell>Database 2</cell></row><row><cell cols="2">rd. 1 a 1 round stg 1 2 1 stage</cell><cell>a 5 + b 3 a 6 + c 3 a 7 + d 3 b 5 + c 4 b 6 + d 4</cell><cell>a 1 + b 7 a 8 + c 1 a 9 + d 1 b 8 + c 2 b 9 + d 2</cell></row><row><cell></cell><cell></cell><cell>c 5 + d 5</cell><cell>c 6 + d 6</cell></row><row><cell>rd. 4</cell><cell cols="3">stg 1 a 3 10 privately in</cell></row><row><cell cols="4">30 downloads (15 from each database) and achieves a sum</cell></row><row><cell cols="3">rate of 20 30 = 2 3 = 1 1+ 1 N</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>Table III in Section IV-D2 and removing the downloads from database 3, we obtain the query table which uses MDS-coded queries shown in Table VI below. Via the scheme in Table VI below, the user retrieves a 1 , • • • , a 4 and b 1 , • • • , b 4 privately in 12 downloads (6 from each database), therefore achieving the same optimal sum rate of 8 12</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>TABLE VI :</head><label>VI</label><figDesc>Alternative query table for the caseM = 4, P = 2, N = 2. , b 1 , c 1 , d 1 a 2 , b 2 , c 2 , d 2 a 3 + b 3 + c 2 + d 2 a 4 + b 4 + c 1 + d 1 a 3 + 3b 3 + 2c 2 + 4d 2 a 4 + 3b 4 + 2c 1 + 4d 1</figDesc><table><row><cell>Database 1</cell><cell>Database 2</cell></row><row><cell>a 1</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>The query table is shown in Tables VII, VIII and IX. This scheme retrieves a 1 , • • • , a 126 and b 1 , • • • , b 126 privately in 354 downloads (177 from each database), therefore, achieving a sum rate of 252 354 = 42 59 &lt;</figDesc><table><row><cell>1 N + 1 1+ 1 2N 2</cell><cell>= 18 25 . The gap is 12 1475</cell><cell>0.0081.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>TABLE VII :</head><label>VII</label><figDesc>The query table for the case M = 5, P = 2, N = 3. , b 1 , c 1 , d 1 , e 1 a 7 , b 7 , c 7 , d 7 , e 7 a 13 , b 13 , c 13 , d 13 , e 13 stg 2 a 2 , b 2 , c 2 , d 2 , e 2 a 8 , b 8 , c 8 , d 8 , e 8 a 14 , b 14 , c 14 , d 14 , e 14 stg 3 a 3 , b 3 , c 3 , d 3 , e 3 a 9 , b 9 , c 9 , d 9 , e 9 a 15 , b 15 , c 15 , d 15 , e 15 stg 4 a 4 , b 4 , c 4 , d 4 , e 4 a 10 , b 10 , c 10 , d 10 , e 10 a 16 , b 16 , c 16 , d 16 , e 16 stg 5 a 5 , b 5 , c 5 , d 5 , e 5 a 11 , b 11 , c 11 , d 11 , e 11 a 17 , b 17 , c 17 , d 17 , e 17 stg 6 a 6 , b 6 , c 6 , d 6 , e 6 a 12 , b 12 , c 12 , d 12 , e 12 a 18 , b 18 , c 18 , d 18 , e 18 22 + e 7 a 36 + e 1 a 50 + e 1 b 19 + c 8 b 33 + c 2 b 47 c 2 b 20 + d 8 b 34 + d 2 b 48 + d 2 b 21 + e 8 b 35 + e 2 b 49 + e 2 c 19 + d 19 c 27 + d 27 c 35 + d 35 c 20 + e 19 c 28 + e 27 c 36 + e 35 d 20 + e 20 d 28 + e 28 d 36 + e 36 stage 2 a 7 + b 22 a 1 + b 36 a 1 + b 50 a 23 + c 9 a 37 + c 3 a 51 + c 3 a 24 + d 9 a 38 + d 3 a 52 + d 3 a 25 + e 9 a 39 + e 3 a 53 + e 3 b 23 + c 10 b 37 + c 4 b 51 + c 4 b 24 + d 10 b 38 + d 4 b 52 + d 4 b 25 + e 10 b 39 + e 4 b 53 + e 4 c 21 + d 21 c 29 + d 29 c 37 + d 37 c 22 + e 21 c 30 + e 29 c 38 + e 37 d 22 + e 22 d 30 + e 30 d 38 + e 38 stage 3 a 26 + b 13 a 40 + b 13 a 54 + b 7 a 27 + c 13 a 41 + c 13 a 55 + c 7 a 28 + d 13 a 42 + d 13 a 56 + d 7 a 29 + e 13 a 43 + e 13 a 57 + e 7 b 26 + c 14 b 40 + c 14 b 54 + c 8 b 27 + d 14 b 41 + d 14 b 55 + d 8 b 28 + e 14 b 42 + e 14 b 56 + e 8 c 23 + d 23 c 31 + d 31 c 39 + d 39 c 24 + e 23 c 32 + e 31 c 40 + e 39 d 24 + e 24 d 32 + e 32 d 40 + e 40</figDesc><table><row><cell></cell><cell>Database 1</cell><cell>Database 2</cell><cell>Database 3</cell></row><row><cell>round 1 stg 1 a 1 round 2 stage 1</cell><cell>a 19 + b 7 a 20 + c 7 a 21 + d 7 a</cell><cell>a 33 + b 1 a 34 + c 1 a 35 + d 1</cell><cell>a 47 + b 1 a 48 + c 1 a 49 + d 1</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>TABLE VIII :</head><label>VIII</label><figDesc>The query table for the case M = 5, P = 2, N = 3 (cont.).<ref type="bibr" target="#b12">13</ref> + b 29 a 13 + b 43 a 7 + b 57 a 30 + c 15 a 44 + c 15 a 58 + c 9 a 31 + d 15 a 45 + d 15 a 59 + d 9 a 32 + e 15 a 46 + e 15 a 60 + e 9 b 30 + c 16 b 44 + c 16 b 58 + c 10 b 31 + d 16 b 45 + d 16 b 59 + d 10 b 32 + e 16 b 46 + e 16 b 60 + e 10 c 25 + d 25 c 33 + d 33 c 41 + d 41 c 26 + e 25 c 34 + e 33 c 42 + e 41 d 26 + e 26 d 34 + e 34 d 42 + e 42 61 + b 8 + c 11 a 79 + b 2 + c 5 a 97 + b 2 + c 5 a 8 + b 61 + d 11 a 2 + b 79 + d 5 a 2 + b 97 + d 5 a 62 + b 9 + e 11 a 80 + b 3 + e 5 a 98 + b 3 + e 5 a 63 + c 27 + d 27 a 81 + c 19 + d 19 a 99 + c 19 + d 19 a 64 + c 28 + e 27 a 82 + c 20 + e 19 a 100 + c 20 + e 19 a 65 + d 28 + e 28 a 83 + d 20 + e 20 a 101 + d 20 + e 20 b 62 + c 29 + d 29 b 80 + c 21 + d 21 b 98 + c 21 + d 21 b 63 + c 30 + e 29 b 81 + c 22 + e 21 b 99 + c 22 + e 21 b 64 + d 30 + e 30 b 82 + d 22 + e 22 b 100 + d 22 + e 22 c 43 + d 43 + e 43 c 47 + d 47 + e 47 c 51 + d 51 + e 51 stage 2 a 9 + b 65 + c 12 a 3 + b 83 + c 6 a 3 + b 101 c 6 a 66 + b 10 + d 12 a 84 + b 4 + d 6 a 102 + b 4 + d 6 a 10 + b 66 + e 12 a 4 + b 84 + e 6 a 4 + b 102 + e 6 a 67 + c 31 + d 31 a 85 + c 23 + d 23 a 103 + c 23 + d 23 a 68 + c 32 + e 31 a 86 + c 24 + e 23 a 104 + c 24 + e 23 a 69 + d 32 + e 32 a 87 + d 24 + e 24</figDesc><table><row><cell>Database 1</cell><cell>Database 2</cell><cell>Database 3</cell></row><row><cell>round 2 a round 3 stage 4 stage 1 a</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>TABLE IX :</head><label>IX</label><figDesc>The query table for the case M = 5, P = 2, N = 3 (cont.).a15 + b 74 + c 18 a 15 + b 92 + c 18 a 9 + b 110 + c 12 a 75 + b 16 + d 18 a 93 + b 16 + d 18 a 111 + b 10 + d 12 a 16 + b 75 + e 18 a 16 + b 93 + e 18 a 10 + b 111 + e 12 a 76 + c 39 + d 39 a 94 + c 39 + d 39 a 112 + c 31 + d 31 a 77 + c 40 + e 39 a 95 + c 40 + e 39 a 113 + c 32 + e 31 a 78 + d 40 + e 40 a 96 + d 40 + e 40 a 114 + d 32 + e 32 b 76 + c 41 + d 41 b 94 + c 41 + d 41 b 112 + c 33 + d 33 b 77 + c 42 + e 41 b 95 + c 42 + e 41 b 113 + c 34 + e 33 b 78 + d 42 + e 42 b 96 + d 42 + e 42 b 114 + d 34 + e 34 c 46 + d 46 + e 46 c 50 + d 50 + e 50 c 54 + d 54 + e 54 round 5 stg 1 a 115 + b 11 + c 47 + d 47 + e 47 a 119 + b 5 + c 43 + d 43 + e 43 a 123 + b 5 + c 43 + d 43 + e 43 stg 2 a 11 + b 115 + c 48 + d 48 + e 48 a 5 + b 119 + c 44 + d 44 + e 44 a 5 + b 123 + c 44 d 44 + e 44 stg 3 a 116 + b 12 + c 49 + d 49 + e 49 a 120 + b 6 + c 45 + d 45 + e 45 a 124 + b 6 + c 45 + d 45 + e 45 stg 4 a 12 + b 116 + c 50 + d 50 + e 50 a 6 + b 120 + c 46 + d 46 + e 46 a 6 + b 124 + c 46 + d 46 + e 46 stg 5 a 117 + b 17 + c 51 + d 51 + e 51 a 121 + b 17 + c 51 + d 51 + e 51 a 125 + b 11 + c 47 + d 47 + e 47 stg 6 a 17 + b 117 + c 52 + d 52 + e 52 a 17 + b 121 + c 52 + d 52 + e 52 a 11 + b 125 + c 48 + d 48 + e 48 stg 7 a 118 + b 18 + c 53 + d 53 + e 53 a 122 + b 18 + c 53 + d 53 + e 53 a 126 + b 12 + c 49 + d 49 + e 49 stg 8 a 18 + b 118 + c 54 + d 54 + e 54 a 18 + b 122 + c 54 + d 54 + e 54 a 12 + b 126 + c 50 + d 50 + e 50</figDesc><table><row><cell></cell><cell>Database 1</cell><cell>Database 2</cell><cell>Database 3</cell></row><row><cell>round 3</cell><cell>stage 4</cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>We note that using q = min {p m ≥ M : p is a prime, m ∈ N} is sufficient to ensure the existence of the P × M MDS generator matrix in Section 4. Furthermore, binary field suffices for the achievable scheme in Section 5.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Note that in the degenerate case, when P = M , the privacy constraint is trivially satisfied as H(P) = H(P|Q[P]n ) = 0 as there is no uncertainty about the identity of the desired messages if P = M either with or without the knowledge of the queries. Thus, the optimal sum retrieval rate is 1 which is achieved by downloading all the messages.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>If N = 1, the optimal retrieval scheme is to download the contents of the database, hence C P s = P M .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>We note that this is similar to the TPIR problem when N T ∈ N, in which case one cannot simply lump every T databases together and apply the capacity-achieving scheme of PIR with non-colluding databases for the new system that consists of N T databases. In both problems, the use of MDS codes is important to induce symmetry across the group of messages/databases.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_4"><p>Check for instance inTable IV that all of the downloads (equations) involving undesired symbols from database 2 are used in database 1: singles c 6 , d 6 , e 6 , c</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_5"><p>, d 7 , e 7 , c</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_6"><p>, d 8 , e 8 , c</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_7"><p>, d 9 , e 9 , c</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_8"><p>, d 10 , e 10 ; sums of twos c 15 + d 15 , c 16 + e 15 , d 16 + e 16 , c 17 + d 17 , c 18 + e 17 , d 18 + e 18 ; sum of threes c 20 + d 20 + e 20 , all downloaded from database 2 are all used as side information in database 1.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_9"><p>We note that the assumption that W i ∈ F L q is indeed unnecessary in terms of converse arguments. Consequently, our converse proof is valid for any storage alphabet.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work was supported by NSF Grants CNS 13-14733, CCF 14-22111, CCF 14-22129, and CNS 15-26608, and presented in part at IEEE ISIT 2017.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>B. Converse Proof for the Case M P &gt; 2 In the sequel, we derive an inductive relation that can be used in addition to the base induction step of 1 ≤ M P ≤ 2 derived in the previous sub-section to obtain an upper bound for the MPIR problem. The idea we pursue here is similar in spirit to the one in <ref type="bibr" target="#b7">[8]</ref>, where the authors developed a base converse step for M = 2 messages, and developed an induction over the number of messages M for the case M &gt; 2.</p><p>Here, we have developed a base converse step for 1 ≤ M P ≤ 2, and now develop an induction over M P for the case M P &gt; 2. The following lemma upper bounds the remaining uncertainty of the answer strings after knowing a subset of size P of the interference messages. 2:N after conditioning on the messages indexed by P 1 , such that</p><p>Proof: We begin with</p><p>where (110) follows from the independence bound; (111) follows from non-negativity of entropy; (113) follows from the statistical independence between the messages and the queries; and (114) follows from the decodability of W P1 given the answer strings (A</p><p>n , A</p><p>[P1] n+1:N ), which is tantamount to the privacy constraint as in the second simplification. Now, we derive the inductive relation for M P &gt; 2. Without loss of generality, let</p><p>Then, starting from (99), we write</p><p>where (118) follows from the decodability of</p><p>2:N ), the symmetry lemma and the independence bound; (119) follows from the fact that conditioning does not increase entropy. In (121), we note that subsets</p><p>1:N ) after knowing W 1:2P . Finally, (122) follows from the interference conditioning lemma.</p><p>Consequently, (122) can be written as</p><p>which is equivalent to</p><p>Now, (124) constructs an inductive relation, since evaluating N H(A 1 |W 1:2P , Q) is the same as N H(A 1 |Q) with (M -2P ) messages, i.e., the problem of MPIR with M messages for fixed P is reduced to an MPIR problem with (M -2P ) messages for the same fixed P . We note that (124) generalizes the inductive relation in <ref type="bibr" target="#b7">[8]</ref> for P = 1.</p><p>We can write the induction hypothesis for MPIR with M messages as</p><p>Next, we proceed with proving this relation for M + 1 messages. From the induction hypothesis, we have </p><p>which concludes the induction argument. Consequently, the upper bound for the MPIR problem can be obtained as,</p><p>where (132) follows from (129); and (133) follows from evaluating the sum in (132).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. CONCLUSIONS</head><p>In this paper, we introduced the multi-message private information retrieval (MPIR) problem from an informationtheoretic perspective. The problem generalizes the PIR problem in <ref type="bibr" target="#b7">[8]</ref> which retrieves a single message privately. We determined the exact sum capacity for this problem when the number of desired messages is at least half of the number of total stored messages to be</p><p>. We showed that joint retrieval of the desired messages strictly outperforms repeating the single-message capacity achieving scheme for each message. Furthermore, we showed that if the total number of messages is an integer multiple of the number of desired messages, then the sum capacity is</p><p>N ) M/P , which resembles the single-message PIR capacity expression when the number of messages is P . For the remaining cases, we derived lower and upper bounds. We observed numerically that the gap between the lower and upper bounds decreases monotonically in N and the worst case gap is 0.0082 which occurs for the case N = 2 when M = 5, P = 2.</p><p>The MPIR problem can be extended in several interesting directions. First, we recall from earlier remarks in the paper that the sum capacity for M/P / ∈ N is still an open problem, in addition to characterizing the optimal capacity region. Second, the MDS-coded MPIR as an extension of <ref type="bibr" target="#b11">[12]</ref> is an interesting open problem, as the contents of the databases are themselves coded via an MDS code in <ref type="bibr" target="#b11">[12]</ref>. This is a challenging problem, in particular if P ≥ M 2 , because our achievable scheme here uses a P ×M MDS code; it would be interesting to see how the storage MDS code and the retrieval MDS code would interact. Similar difficulties would exist in the MPIR problem with colluding databases (extending <ref type="bibr" target="#b12">[13]</ref>), robust MPIR problem (extending <ref type="bibr" target="#b12">[13]</ref>), and MPIR problem with Byzantine databases (extending <ref type="bibr" target="#b27">[28]</ref>), as all these problems adopt some version of MDS coding for retrieval purposes. Furthermore, one can examine whether multiround MPIR enhances the MPIR retrieval rate or not (extending the case of single-message retrieval in <ref type="bibr" target="#b28">[29]</ref>), and study the effects of limited message size on MPIR (extending <ref type="bibr" target="#b24">[25]</ref>). Our converse techniques may be generalized to be applicable to these scenarios. Some progress in these MPIR problems has been made recently in <ref type="bibr" target="#b29">[30]</ref>.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Private information retrieval</title>
		<author>
			<persName><forename type="first">B</forename><surname>Chor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="965" to="981" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Private information retrieval</title>
		<author>
			<persName><forename type="first">S</forename><surname>Yekhanin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="68" to="73" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A survey on private information retrieval</title>
		<author>
			<persName><forename type="first">W</forename><surname>Gasarch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bulletin of the EATCS</title>
		<imprint>
			<biblScope unit="volume">82</biblScope>
			<biblScope unit="page" from="72" to="107" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A survey of single-database private information retrieval: Techniques and applications</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Skeith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Workshop on Public Key Cryptography</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="393" to="411" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Computationally private information retrieval with polylogarithmic communication</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cachin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stadler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on the Theory and Applications of Cryptographic Techniques</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Blind interference alignment for private information retrieval</title>
		<author>
			<persName><forename type="first">H</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jafar</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1601.07885</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Blind interference alignment</title>
		<author>
			<persName><forename type="first">S</forename><surname>Jafar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal of Selected Topics in Signal Processing</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="216" to="227" />
			<date type="published" when="2012-06">June 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The capacity of private information retrieval</title>
		<author>
			<persName><forename type="first">H</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Jafar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="4075" to="4088" />
			<date type="published" when="2017-07">July 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">One extra bit of download ensures perfectly private information retrieval</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">B</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">V</forename><surname>Rashmi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ramchandran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE ISIT</title>
		<imprint>
			<date type="published" when="2014-06">June 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Private information retrieval from MDS coded data in distributed storage systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Tajeddine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">El</forename><surname>Rouayheb</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE ISIT</title>
		<imprint>
			<date type="published" when="2016-07">July 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Private information retrieval for coded storage</title>
		<author>
			<persName><forename type="first">T</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yamamoto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE ISIT</title>
		<imprint>
			<date type="published" when="2015-06">June 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The capacity of private information retrieval from coded databases</title>
		<author>
			<persName><forename type="first">K</forename><surname>Banawan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ulukus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Info. Theory</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1945" to="1956" />
			<date type="published" when="2018-03">March 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The capacity of robust private information retrieval with colluding databases</title>
		<author>
			<persName><forename type="first">H</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Jafar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Info. Theory</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="2361" to="2370" />
			<date type="published" when="2018-04">April 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Private information retrieval from coded databases with colluding servers</title>
		<author>
			<persName><forename type="first">R</forename><surname>Freij-Hollanti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Gnilke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hollanti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Karpuk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Applied Algebra and Geometry</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="647" to="664" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">The capacity of symmetric private information retrieval</title>
		<author>
			<persName><forename type="first">H</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jafar</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1606.08828</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Symmetric private information retrieval for MDS coded distributed storage</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Skoglund</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1610.04530</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Cover</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Thomas</surname></persName>
		</author>
		<title level="m">Elements of Information Theory</title>
		<imprint>
			<publisher>John Wiley &amp; Sons</publisher>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">One (block) size fits all: PIR and SPIR with variable-length records via multi-block queries</title>
		<author>
			<persName><forename type="first">R</forename><surname>Henry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Goldberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">RAID-PIR: Practical multiserver PIR</title>
		<author>
			<persName><forename type="first">D</forename><surname>Demmler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Herzberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Workshop on Cloud Computing Security</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="45" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A fast multi-server, multi-block private information retrieval protocol</title>
		<author>
			<persName><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">K</forename><surname>Kuppusamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cappos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Globecom</title>
		<imprint>
			<date type="published" when="2015-12">Dec 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Multi-query computationallyprivate information retrieval with constant communication rate</title>
		<author>
			<persName><forename type="first">J</forename><surname>Groth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kiayias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lipmaa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Workshop on Public Key Cryptography</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Batch codes and their applications</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the thirty-sixth annual ACM symposium on Theory of computing</title>
		<meeting>the thirty-sixth annual ACM symposium on Theory of computing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="262" to="271" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Sublinear scaling for multi-client private information retrieval</title>
		<author>
			<persName><forename type="first">W</forename><surname>Lueks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Goldberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Financial Cryptography and Data Security</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="168" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Discrete-Time Signal Processing</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Oppenheim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Schafer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>Pearson Higher Education</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Optimal download cost of private information retrieval for arbitrary message length</title>
		<author>
			<persName><forename type="first">H</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Jafar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Info. Forensics and Security</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2920" to="2932" />
			<date type="published" when="2017-12">Dec 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Polynomial codes over certain finite fields</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">S</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Solomon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="300" to="304" />
			<date type="published" when="1960">1960</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Wicker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">K</forename><surname>Bhargava</surname></persName>
		</author>
		<title level="m">Solomon Codes and their Applications</title>
		<imprint>
			<publisher>John Wiley &amp; Sons</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The capacity of private information retrieval from Byzantine and colluding databases</title>
		<author>
			<persName><forename type="first">K</forename><surname>Banawan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ulukus</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1706.01442</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Info. Theory</title>
		<imprint>
			<date type="published" when="2017-06">June 2017</date>
		</imprint>
	</monogr>
	<note>Submitted</note>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Multiround private information retrieval: Capacity and storage overhead</title>
		<author>
			<persName><forename type="first">H</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jafar</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1611.02257</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Multi-file private information retrieval from MDS coded databases with colluding servers</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ge</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1705.03186</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Hons.) in electrical engineering from Alexandria University</title>
		<author>
			<persName><forename type="first">Karim</forename><surname>Banawan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">His research interests include information theory</title>
		<title level="s">S&apos;13) received the B.Sc. and M.Sc. degrees (Highest</title>
		<meeting><address><addrLine>Alexandria, Egypt; College Park, MD, USA; College Park, MD, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008">2008. 2012. 2017</date>
		</imprint>
		<respStmt>
			<orgName>University of Maryland ; Department of Electrical and Computer Engineering, University of Maryland</orgName>
		</respStmt>
	</monogr>
	<note>He is currently pursuing the Ph.D. degree at the. wireless communications, physical layer security and private information retrieval</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Prior to joining UMD, she was a Senior Technical Staff Member at AT&amp;T Labs-Research. She received her Ph.D. degree in Electrical and Computer Engineering from Wireless Information Network Laboratory (WINLAB), Rutgers University, and B.S. and M.S. degrees in Electrical and Electronics Engineering from Bilkent University. Her research interests are in wireless communications, information theory, signal processing, and networks, with recent focus on private information retrieval, timely status updates over networks, energy harvesting communications, information theoretic physical layer security, and wireless energy and information transfer. Dr. Ulukus is a fellow of the IEEE</title>
	</analytic>
	<monogr>
		<title level="m">She is on the Editorial Board of the IEEE Transactions on Green Communications and Networking since 2016. She was an Editor for the IEEE Journal on Selected Areas in CommunicationsSeries on Green Communications and Networking</title>
		<imprint>
			<date type="published" when="2003">2015-2016. 2003-2007. 2015 and 2008. 2012. 2011</date>
		</imprint>
		<respStmt>
			<orgName>Professor of Electrical and Computer Engineering at the University of Maryland at College Park ; Institute for Systems Research (ISR) ; University of Maryland</orgName>
		</respStmt>
	</monogr>
	<note>Journal of Communications and Networks. She was a general TPC co-chair of 2017 IEEE ISIT, 2016 IEEE Globecom, 2014 IEEE PIMRC, and 2011 IEEE CTW</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
