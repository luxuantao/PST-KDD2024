<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Taming Verification Hardness: An Efficient Algorithm for Testing Subgraph Isomorphism</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Haichuan</forename><surname>Shang</surname></persName>
							<email>shangh@cse.unsw.edu.au</email>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science and Engineering</orgName>
								<orgName type="institution">University of New South Wales &amp; NICTA Sydney</orgName>
								<address>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ying</forename><surname>Zhang</surname></persName>
							<email>yingz@cse.unsw.edu.au</email>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science and Engineering</orgName>
								<orgName type="institution">University of New South Wales &amp; NICTA Sydney</orgName>
								<address>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Xuemin</forename><surname>Lin</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science and Engineering</orgName>
								<orgName type="institution">University of New South Wales &amp; NICTA Sydney</orgName>
								<address>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jeffrey</forename><surname>Xu</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Systems Engineering and Engineering Management</orgName>
								<orgName type="institution">Chinese university of Hong</orgName>
								<address>
									<settlement>Kong Hong Kong</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Taming Verification Hardness: An Efficient Algorithm for Testing Subgraph Isomorphism</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">CD8B2FB5B4FD0EDC2E353D9DC9636400</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:02+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Graphs are widely used to model complicated data semantics in many applications. In this paper, we aim to develop efficient techniques to retrieve graphs, containing a given query graph, from a large set of graphs. Considering the problem of testing subgraph isomorphism is generally NP-hard, most of the existing techniques are based on the framework of filtering-and-verification to reduce the precise computation costs; consequently various novel feature-based indexes have been developed. While the existing techniques work well for small query graphs, the verification phase becomes a bottleneck when the query graph size increases. Motivated by this, in the paper we firstly propose a novel and efficient algorithm for testing subgraph isomorphism, QuickSI. Secondly, we develop a new feature-based index technique to accommodate QuickSI in the filtering phase. Our extensive experiments on real and synthetic data demonstrate the efficiency and scalability of the proposed techniques, which significantly improve the existing techniques.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Many recent real applications strongly demand efficiently and effectively managing graph structured data such as paths, trees, and general graphs. These applications include Bioinformatics, Chemistry, Social networks, Software and Data Engineering, World Wide Web, etc. In such applications, graphs are used to model complex structures and relationships. For instance, graphs may represent chemical compounds in Chemistry. Graphs are also used in UML and ER diagrams.</p><p>The subgraph containment query problem can be described as follows. Given a graph database D = {g1, g2, ..., gn} and a query graph q, retrieve all graph gi ∈ D such that q is a subgraph of gi. For example, if we use the graph in Figure <ref type="figure">1</ref> as the query q, then among the 3 graphs (D = {ga, g b , gc}) in Figure <ref type="figure" target="#fig_0">2</ref>, only graph g b contains q. The subgraph containment (or subgraph isomorphism) problem has been shown</p><p>Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the VLDB copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Very Large Data Base Endowment. To copy otherwise, or to republish, to post on servers or to redistribute to lists, requires a fee and/or special permission from the publisher, ACM. VLDB '08, August 24-30, 2008, Auckland, New Zealand Copyright 2008 VLDB Endowment, ACM 000-0-00000-000-0/00/00.  <ref type="bibr" target="#b7">[7]</ref>.</p><p>In recent years, a number of techniques for processing subgraph containment queries have been proposed <ref type="bibr">[8,</ref><ref type="bibr" target="#b16">16,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b20">20,</ref><ref type="bibr" target="#b4">4]</ref>. The main paradigm follows the framework of filteringand-verification which is based on feature-based indexes. In the filtering phase, a feature-based index is used to prune the captured negative results and generate a candidate set. In the verification phase, a precise computation is conducted to generate the final results based on subgraph isomorphism (NP-complete). The existing techniques include gIndex <ref type="bibr" target="#b16">[16]</ref>, TreePi <ref type="bibr" target="#b18">[18]</ref> and TreeDelta <ref type="bibr" target="#b20">[20]</ref>.</p><p>However, the existing verification techniques are not efficient especially when the query graph size becomes large. Note that the larger graphs the higher cost for subgraph isomorphism testing. Moreover, due to intrinsic limits of feature-based indexes, the accuracy of filtering may be getting worse while graph sizes are increasing; that is, the ratio of the generated candidate set size over the actual result set size is getting larger. This leads to a dramatic performance degrade with an increment of query graph sizes. In <ref type="bibr" target="#b4">[4]</ref>, <ref type="bibr">Cheng et al.</ref> propose a new paradigm, FG-Index, with the aim to use index only to process a subgraph containment query; that is, verification free. Nevertheless, when query graph sizes increase, many graphs still remain for a verification.</p><p>Motivated by these, in this paper, our primary focus is on developing efficient verification techniques. We propose an efficient subgraph isomorphism testing algorithm QuickSI (Quick Subgraph Isomorphism) to conduct a verification to generate final results. Comparing to the well adopted Ullman's algorithm <ref type="bibr" target="#b13">[13]</ref>, QuickSI achieves up to 1-4 orders of magnitude speed-up. In addition, our verification techniques can also be used in the filtering phase to efficiently generate candidates.</p><p>Our main contributions are summarized as follows.</p><p>• To significantly reduce the verification costs, we develop an efficient subgraph isomorphism testing algorithm QuickSI. Several new techniques are proposed. Firstly, we propose QI-Sequence, for a given query graph, to bound the search space in the subgraph isomorphism testing. Secondly, we determine the QI-Sequence order based on the frequencies of features that appear in the underneath graph database. The QI-Sequence order further reduces the search space.</p><p>With the two techniques, our new algorithm QuickSI significantly improves the existing verification techniques by up to 4 orders of magnitudes speed-up.</p><p>• In addition, we develop a novel index called Swift-Index where the mined tree features are represented as QI-Sequences and all QI-Sequences in the index are organized as a prefix tree. The prefix tree index makes it possible to significantly reduce the cost in the filtering phase by sharing the cost of subgraph isomorphism testing. Note that in order to check whether or not a graph contains a query graph, in the filtering phase, all the existing algorithms need to check if the graph contains all the indexed features that are contained in the query graph (subgraph isomorphism). Sharing reduces the cost of checking the common parts of several features. Our Swift-Index significantly outperforms the filtering techniques used in gIndex.</p><p>Experimental results show that our new techniques significantly outperform the most recent, efficient technique, FGindex <ref type="bibr" target="#b4">[4]</ref> towards both index construction and query processing when query graph size is not very small. Against real data set, our query processing techniques can achieve up to an order of magnitude speed-up over FG-Index while the index size is 20% of FG-Index. In addition, the results also show that our techniques have high scalability on the database size, the graph size and the number of distinct labels.</p><p>The rest of the paper is organized as follows. Section 2 presents the problem statement and the framework. Section 3 introduces a new verification approach and a new subgraph isomorphism testing algorithm called QuickSI. Section 4 proposes a new filtering approach with a new prefix-tree index called Swift-Index. Experimental studies are reported in Section 5. The related work and conclusion are given in Section 6 and Section 7, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">THE PROBLEM STATEMENT AND THE FRAMEWORK</head><p>We firstly give our problem statement on subgraph containment queries (or subgraph isomorphism queries). Then, we outline the framework of f iltering-and-verif ication followed by an overview towards the most related work -Ullman's Algorithm for verification. For presentation simplicity, graphs to be studied in the paper are "simple" undi- </p><formula xml:id="formula_0">C C N f e a t u r e C C C C g r a p h I D -l i s t { a , b , c } { c } C C C C C { a , b } f 1 f 2 f 3</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Problem Statement</head><p>A graph is simple if it has no loops nor multiple edges <ref type="bibr" target="#b6">[6]</ref>. Given two sets of labels, ΣV and ΣE, a labeled graph g is defined as a triple (V, E, l) where V is the set of vertices, E ⊆ V × V is the set of undirected edges, and l is a mapping function: V → ΣV and E → ΣE. We denote the vertex set and the edge set of a graph g as V (g) and E(g), respectively. Given an edge (u, v) ∈ E(g) and the mapping function l of g, l(u), l(v) are the labels of u and v in g and l(u, v) is the label of the edge (u, v) in g. We use |V (g)| and |E(g)| to represent the number of vertices and the number of edges, respectively. Definition 1. (SUBGRAPH ISOMORPHISM) Given two graphs g = (V , E , l ) and g = (V, E, l), g is subgraphisomorphic to g, denoted as g ⊆ g, if there is an injective function f : g → g such that</p><formula xml:id="formula_1">1. ∀v ∈ V , f (v) ∈ V (g) such that l (v) = l(f (v)). 2. ∀(u, v) ∈ E , (f (u), f (v)) ∈ E such that l (u, v) = l(f (u), f (v)).</formula><p>A graph g is a subgraph of g if g is subgraph-isomorphic to g where g is also called a supergraph of g , denoted by g ⊆ g. We may also simply say that g contains g . A subgraph IndG(V , g) of g is induced if it is the maximum subgraph for a given subset V of V (g); that is, IndG(V , g) consists of all edges in g with the vertices in V .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2. (SUBGRAPH CONTAINMENT QUERY)</head><p>Given a graph database D = {g1, g2, ..., gn} and a query graph q, the problem of subgraph containment query (or subgraph isomorphism query) is to find a set of graphs which contain q from D, such as Dq = {g|g ∈ D ∧ q ⊆ g}.</p><p>Problem Statement. In this paper, we will develop efficient algorithms to process subgraph containment queries. In the rest of the paper, we assume edges are not labeled; nevertheless our techniques can be immediately extended to cover edge-labeled graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Filtering and Verification Framework</head><p>The framework of filtering-and-verification is presented in Algorithm 1, where a feature-based index plays the key role in the framework.</p><p>Algorithm 1: QueryProecssing(q, I, D) Input : q is a query graph;</p><p>I is a graph index; D is a graph database; Output: R is a set of matched graphs;</p><formula xml:id="formula_2">F := {fi|fi ⊆ q ∧ fi ∈ I}; 1 C := f i ∈F fi.list; 2 R := ∅; 3 for each g ∈ C do 4 if q ⊆ g then 5 R := R ∪ {g}; 6 return R 7 FEATURE-BASED INDEX. A feature based index I = {(fi, fi.list)} is a set of indexed items, (fi, fi.list).</formula><p>Here, fi is a fragment (or subgraph) of a graph, which can be a path, a tree, or a graph. And fi.list is a list of graph identifiers for the graphs that contain the subgraph, such as fi.list = {gi.ID|fi ⊆ gi ∧ gi ∈ D}. (Note that we use gi.ID to denote the graph identifier of graph gi.) Below, we call fi a feature and fi, list its graph ID-list (or simply ID-list).</p><p>Example 1. The feature f1 in Figure <ref type="figure" target="#fig_1">3</ref> is contained by all three graphs in Figure <ref type="figure" target="#fig_0">2</ref>, therefore its ID-list f1.list = {a, b, c}. As the feature f2 is only contained by graph (b) in Figure <ref type="figure" target="#fig_0">2</ref>, its ID-list f2.list = {b}.</p><p>As shown in Algorithm 1, the filtering phase and the verification phase are specified in line 1-2 and line 4-6, respectively. Line 1 retrieves the features, which are contained in the query graph q, from the feature-based index I. Line 2 gets all graph identifiers for the graphs that contain all the features appearing in the query graph, which is known as the candidate set C. Line 4-6 process subgraph isomorphism testing for each graph g whose graph identifier is in C. If there is a subgraph isomorphism mapping from q to g, q ⊆ g, g is added to the result set R. Obviously, q ⊆ g if |V (g)| &lt; |V (q)|. Line 7 finally returns the matched result set.</p><p>In the next subsection, we introduce the Ullman's algorithm which is widely used for subgraph isomorphism testing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Ullman Algorithm</head><p>Most existing verification techniques adopt Ullman's algorithm <ref type="bibr" target="#b13">[13]</ref>, which is designed to find the subgraph-isomorphic mapping from a graph g (e.g., a query graph q) to a graph g. Assume that α = |V (g)| and β = |V (g )|. The algorithm uses a vector F = (F1, ..., Fi, ..., Fα) to denote which vertices of g have been used at an intermediate state of the computation. Here, Fi = 1 indicates that the ith vertex of g has been used. Together with F , a vector H = (H1, ..., Hi, ..., H β ) is used to record the mapping from g to g. Here, Hi = j indicates that the ith vertex of g has been mapped to the jth vertex of g. Let deg(i, g) denote the degree of vertex i in graph g. A matrix M = [m βα ] is used to reduce the search tree size, where mij = 1 if deg(i, g ) ≤ deg(j, g), otherwise mij = 0.</p><p>Ullman Algorithm is outlined in Algorithm 2. As a treesearch-based algorithm, Ullman's algorithm attempts to eliminate successor nodes in a search tree as early as possible.  Line 1-2 check whether it can find an isomorphic mapping from g to g. Lines 3-4 enumerate all unused vertices and test whether they satisfy the refine-criterion as stated below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>REFINE-CRITERION:</head><p>1. l (d) = l(k).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">(∀x</head><formula xml:id="formula_3">∈ [1, β])((x, d) ∈ E(g ) ⇒ (∃y ∈ [1, α])(y, k) ∈ E(g) ∧ mxy = 1).</formula><p>If the refine-criterion fails for (d, k), it sets m dk to 0. If any row of M contains the 0 value only, then the procedure fails. Line 5-9 set the mapping vector H and vector F , and go down to the next test level. Line 10 backtracks to the upper level if there is no valid mapping in the current level. Note that we extend the original refine-criterion in <ref type="bibr" target="#b13">[13]</ref> by accommodating node labels (i.e., by adding Criterion 1). It can be immediately verified that our refine-criterion is correct.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">A NEW VERIFICATION APPROACH</head><p>Ullman algorithm is designed based on the branch and bound paradigm <ref type="bibr" target="#b11">[11]</ref>. In such a paradigm, one of the critical issues is how to choose an effective search order so that it can cut as many branches as possible in searching. It is important to know that the search order in the Ullman algorithm is random, and a random order can possibly result in a search order that seriously slows the algorithm. An example is shown to explain.</p><p>Example 2. Suppose that in Ullman algorithm, it determines if a given query graph q (Figure <ref type="figure">1</ref>) is sub-isomorphic to the graph g b (Figure <ref type="figure" target="#fig_0">2(b)</ref>) by visiting the vertices in the query graph q according to the following visiting order: v1, v3, v2, v4, v5, v6, and v7. Assume that v1 and v3 have been visited. There are 14 pairs of vertices with labels N and C in g b that need to be considered (2 N -labeled vertices, and 7 C-labeled vertices). In fact, there are only three pairs of vertices in g, namely, u1, u3 , u9, u3 and u9, u7 need to be considered.</p><p>In order to reduce the search space, in this paper, we propose QI-Sequence to encode a graph for efficient subgraph isomorphism testing. In brief, we encode a search order and topological information in QI-Sequence for a query graph q, and we determine the effective search order using the frequencies of features that appear in the underneath graph database D. Following the search order and other topological information specified in the QI-Sequence for q, we identify the mapping between q and g. Such encoding and ordering can significantly reduce the unnecessary branch and bound, and is shown effective in our extensive experimental studies.</p><p>The rest of this section is organized as follows. Section 3.1 introduces QI-Sequence to encode a query graph. Section 3.2 presents an efficient algorithm QuickSI to test if the query graph q is sub-isomorphic to a data graph, based on the QI-Sequence of q. In Section 3.3, we discuss how to determine an effective QI-Sequence, as a search order, by effectively utilizing feature frequencies in the graph database.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">QI-Sequence</head><p>Given a query graph q of size β in terms of the number of vertices in q, a QI-Sequence is a sequence that represents a rooted spanning tree for q. It consists of a list of spanning entries, Ti, for 1 ≤ i ≤ β, where each Ti keeps the basic information of the spanning tree of q. In QI-Sequence, a Ti may be followed by a list of extra entries, Rij, which keeps the extra topology information related to the corresponding spanning entry.</p><p>Formally, a QI-Sequence of q is represented as a regular expression SEQq</p><formula xml:id="formula_4">= [[TiR * ij ] β ].</formula><p>Here, Ti contains several information. Firstly, Ti.v records a vertex v k in a query graph q, for example, Ti.v := v k . Secondly, Ti keeps a pair, [Ti.p, Ti.l], where Ti.p stores the parent vertex of Ti.v in the spanning tree and Ti.l stores the label of Ti.v. It is important to note that the subindex i of Ti specifies the search order. As for Rij, there are two kinds of extra entries in Rij, namely, degree constraint and extra edge. The degree constraint is in the form of [deg : d], where d is the degree of vi. <ref type="foot" target="#foot_0">1</ref> The extra edge (i.e., edge that does not appear in the spanning tree) is in the form of [edge : j], where j indicates a vertex indicated by Tj.v in SEQq. We only record such an extra edge, [edge : j], in Rij after Ti in SEQq if the extra edge is from Ti.v to Tj.v for j &lt; i.</p><p>Table <ref type="table">1</ref> illustrates two different QI-Sequences of the query graph, q in Figure <ref type="figure">1</ref>, based on two different spanning trees. Note that an entry Ti in a QI-Sequence does not necessarily correspond to the vertex vi; for instance, T1 in the QI-Sequence (b) in Table <ref type="table">1</ref> correspond to v4. The two QI-Sequences are different. The QI-Sequence (Table <ref type="table">1</ref>(a)) is label selective as the possible mapping of N is less than C in graph database. On the other hand, the QI-Sequence (Table 1(b)) is random. It is clear that the two QI-Sequences will have different search spaces when processing subgraph isomorphism testings. We will discuss how to choose an effective QI-Sequence in details in Section 3.3.</p><p>Let SEQ g and SEQg be two QI-Sequences for two graphs, g and g. In the following Theorem 1, we show that if the two QI-Sequences are identical then the two graphs are identical. Our QI-Sequence based subgraph isomorphism testing algorithm is designed based on Theorem 1.</p><p>Table <ref type="table">1</ref>: Two SEQqs for query graph q in Figure <ref type="figure">1</ref> Type</p><formula xml:id="formula_5">[Ti.p, Ti.l] Ti.v T1 [0, N ] v1 T2 [1, C] v2 R21 [deg : 3] T3 [2, C] v3 T4 [3, C] v4 T5 [4, C] v5 T6 [5, C] v6 T7 [6, C] v7 R71 [edge : 2] Type [Ti.p, Ti.l] Ti.v T1 [0, C] v4 T2 [1, C] v5 T3 [1, C] v3 T4 [2, C] v6 T5 [4, C] v7 T6 [5, C] v2 R61 [deg : 3] R62 [edge : 3] T7 [6, N ] v1 (a) (b)</formula><p>Theorem 1. Given two graphs g and g. Let SEQ g and SEQg be the two corresponding QI-Sequences. If the two QI-Sequences are identical, then the corresponding graphs, g and g, must be identical.</p><p>Proof-Sketch: Theorem 1 is immediate based on the following result. A QI-Sequence SEQg, for a graph g, can be uniquely converted to a graph g which is identical to g.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">QuickSI Algorithm</head><p>In this section, we discuss our new algorithm for subgraph isomorphism testing. Let q and g be a query graph and a graph in the candidate set after filtering phase, and let SEQq be the QI-Sequence for q. Our QuickSI algorithm is designed to check if there exists a QI-Sequence for a subgraph, g of g, denoted as SEQ g , which is identical to SEQq.</p><p>The QuickSI algorithm is presented in Algorithm 3. There are five inputs. (1) SEQq is the QI-Sequence of a query graph q of size β (= |V (q)|). ( <ref type="formula" target="#formula_13">2</ref>) F and H are two vectors as used in Ullman's algorithm (Algorithm 2). (3) g is a graph of size α (= |V (g)|), and (4) d is the current search position for 1 ≤ d ≤ β. The algorithm adopts depth-first-search order following the order explicitly specified in SEQq.</p><p>We explain the two vectors below. Firstly, H = {H1, ..., Hi, ..., H β } is used to store mapping from the QI-Sequence SEQq to a graph g. Hi := uj indicates that the vertex Ti.v of q has been mapped to the vertex uj ∈ g. Given a successful mapping H1, H2, ..., Hi, the degree constraint, [deg : x], specified in Rij, implies that the vertex Hi ∈ g must have the degree, deg(Hi, g), not smaller than x; that is, deg(Hi, g) ≥ x. Moreover, each edge constraint [edge : x], specified in Rij, implies that there must be an edge between Hi and Hx in graph g where x &lt; i. Secondly, F = {F1, ..., Fi, ..., Fα} is used to indicate whether or not the ith vertex in g is used at an intermediate state of the computation.</p><p>In Algorithm 3, α and β are the numbers of vertices in g and q, respectively. We first test whether computation has reached the end of SEQq by checking depth d. If d &gt; β, it implies that we have already found a QI-Sequence, SEQ g , for g ⊆ g, that equals SEQq. We can conclude that q is a subgraph of g, because q is identical to g and g ⊆ g. Otherwise, we get the d-th vertex entry T d and try to find a mapping vertex in g. If there is a vertex u ∈ g with same label that satisfies all constraints in the extra entries R dj , it can be a valid mapping, and the searching will continue recursively, until the algorithm ends up with a successful mapping or fails in all possible trials at a certain label.</p><p>Algorithm 3: QuickSI (SEQq, g,H ,F ,d) Input : SEQq: QI-Sequence of query graph q; g: a graph; H : a vector with length β, initialized by all 0; F : a vector with length α, initialized by all 0; d: depth, initialized by 1; Output: Boolean: SEQq is a subgraph of g;  <ref type="table">1</ref>(a)) for the query graph, q, in Figure <ref type="figure">1</ref>, and the graph g b in Figure <ref type="figure" target="#fig_0">2(b)</ref>. The QuickSI algorithm first finds that u1 in g b can be mapped to T1. It stores the mapping H1 := u1 and sets the vector element F1 := 1. For the vertex set V := {u2} which is connected to u1, it finds l(u2) = C which is same as T2.l. When it tests the degree restriction, [deg : 3], specified in R21, it finds the degree of u2 is 2, which is less than 3. The tree search algorithm returns to T1, releases u1 by setting F1 := 0 and matches T1 to a different vertex u9. Finally, it finds a successful mapping H = {u9, u8, u7, u6, u5, u4, u3} or H = {u9, u8, u3, u4, u5, u6, u7}.</p><formula xml:id="formula_6">if d &gt; β then 1 return T rue; 2 T := T d ∈ SEQq; 3 V := ∅; 4 if d = 1 then 5 V := {v|v ∈ V (g), l(v) = T.l and Fv = 0} ; 6 else 7 V := {v|v ∈ V (g), (v, HT.p) ∈ E(g), l(v) = T.</formula><p>Correctness. It can be immediately verified that if there is a QI-Sequence, SEQ g for a subgraph of g, g ⊆ g, that equals SEQq, then Algorithm 3 must be able to find it. According to Theorem 1, the correctness of the algorithm is immediate.</p><p>Cost Analysis. Note that the above subgraph isomorphism testing follows depth-first search strategy. As the search depth is fixed, the computation cost depends on the fan-out at each depth. We define search breadth at depth i below, denoted by Bi. Search breadth represents the number of possible isomorphism mappings from the prefix sequence</p><formula xml:id="formula_7">SEQ i q = [[TiR * ij ] i ]; that is, SEQ i q = [[TiR * ij ] i ] con- tains the first i entries in SEQq.</formula><p>Definition 3. (SEARCH BREADTH) Given SEQq for a query graph q and a graph g, the search breadth Bi =|</p><formula xml:id="formula_8">{H i |H i : SEQ i q → g} | (1 ≤ i ≤ β) where SEQ i q = [[TiR * ij ] i ] is a prefix of SEQq.</formula><p>Also, H i is a distinct mapping vector from SEQ i q to g. The length of a H i is i since H i maps SEQ i q to g.</p><p>Given a QI-Sequence SEQq and a graph g, the isomorphism testing cost is computed as follows. We use Tiso to denote the total number of comparisons performed in the algorithm QuickQI. As we can pre-compute the degree for data graphs, it takes O(1) time to check both kinds of extra entries (degree constraint and extra edge) if an adjacent matrix is used. It takes O(deg) to find a forwarding edge in a data graph g to go one depth further regarding SEQq, where deg is the degree of the vertex mapped to HT i .p in g. (Note that Ti.p points to the parent vertex of Ti.v.)</p><formula xml:id="formula_9">Tiso = α + B1 • r1 + Σ β-1 i=1 Σ B i j=1 deg&lt;i,j&gt; • ri+1 (1) ≤ α + B1 • r1 + Σ β-1 i=1 Bi • degmax • ri+1</formula><p>Here, deg&lt;i,j&gt; is the degree of the vertex HT i .p in g at j-th mapping, ri = 1 + |{Rij|Rij ∈ SEQq}| which is the number of extra entries at depth i, and degmax is the maximum vertex degree of g. We have the following Theorem.</p><formula xml:id="formula_10">Theorem 2. Let SEQq = [[TiR * ij ]</formula><p>β ] be a QI-Sequence and degmax(g) be the maximum vertex degree in g.</p><formula xml:id="formula_11">Tiso ≤ α + B1 × degmax(g) β × rmax,</formula><p>where rmax is the maximum number of extra entries for any Rij.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof. Because we keep connectivity during the isomor</head><formula xml:id="formula_12">- phism testing, it is immediate that if ∀ i ≥ 2, then Bi ≤ Σ B i-1 j=1 deg&lt;i-1,j&gt; ≤ Bi-1degmax</formula><p>The theorem immediate follows from Eq. ( <ref type="formula">1</ref>).</p><p>The space requirement is O(|SEQq| + |g|) where |g| denotes the space required to store a graph g.</p><p>As an example, consider Tiso for testing whether the query graph q is sub-isomorphic to graph ga (Figure <ref type="figure" target="#fig_0">2</ref>(a)), using the two QI-Sequences in Table <ref type="table">1</ref>. With the random QI-Sequence in Table 1(b), Tiso ≤ 161, whereas with the QI-Sequence in Table <ref type="table">1</ref>(a), Tiso ≤ 37.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Effective QI-Sequence</head><p>In this section, we discuss how to determine an effective QI-Sequence, SEQq, for fast subgraph isomorphism testing. Reconsider Eq. ( <ref type="formula">1</ref>), search breadths play an important role in subgraph isomorphism testing. Minimizing Bi can reduce cost of subgraph isomorphism testing. However, it is too costly to find the optimal QI-Sequence, in order to minimize the total breadths and therefore significantly reduce the subgraph isomorphism testing cost for any data graph in the graph database D. Instead, we develop efficient heuristics to construct an effective QI-Sequence, SEQq, for a query graph to reduce the total breadths and the subgraph isomorphism testing cost for any data graph in the graph database D. Our approach is based on the inner support defined below. Definition 4. (INNER SUPPORT) Given a query graph, q, and a data graph, g, the inner support φ(q, g) is the number of isomorphic mappings from q to g.</p><p>It is immediate that the search breadth Bi is φ(SEQ i q , g) for a data graph.</p><p>Counting Inner Supports for Vertices and Edges. Suppose that we index all 1-vertex and 1-edge features, we </p><formula xml:id="formula_13">φavg(v) = |{f |f (v) ∈ V (g) ∧ g ∈ D}| |{g|f (v) ∈ V (g) ∧ g ∈ D}|<label>(2)</label></formula><formula xml:id="formula_14">φavg(e) = |{f |f (e) ∈ E(g) ∧ g ∈ D}| |{g|f (e) ∈ E(g) ∧ g ∈ D}|<label>(3)</label></formula><p>The average inner support φavg(e) (φavg(v)) of an edge e (of a vertex v) is the average number of its possible mappings in the graphs which contain this edge (vertex). In Eq. ( <ref type="formula" target="#formula_14">3</ref>), we omit the graphs which do not contain any mapping of the given edge, because these graphs will be pruned in the filtering step. Therefore, only the graphs that contain at least one mapping of the given edge need to be tested. Eq. ( <ref type="formula" target="#formula_14">3</ref>) counts the average number of distinct edges in the graphs which have high probability not to be pruned in the filtering step. It is reasonable because only the graphs which pass the filtering step need to be tested in the verification step. The statistic for the graphs in the candidate set after filtering is more valuable than the statistic for all graphs in the database.</p><p>Finding Minimum Spanning Tree. Once the average inner supports of each distinct vertex and edge are counted, we add those supports to the vertices and edges of q and convert q to a weighted graph q w , where each edge e in q w has a weight w(e) = φavg(e) and w(v) = φavg(v). Then, we find the minimum spanning tree in q w based on edge weights. The minimum spanning tree will be used to generate a QI-Sequence of q and we will use the vertex weights to determine the order of the first two entries in such a QI-Sequence.</p><p>We extend Prim's algorithm <ref type="bibr" target="#b1">[1]</ref> to compute the minimum spanning tree for q w and construct the QI-Sequence for q. Our extension contains the technique to choose a "better" minimum spanning tree when more than one minimum spanning tree are involved. The main idea is presented in Algorithm 4.</p><p>In Algorithm 4, VT and ET store the the set of vertices and edges in intermediate steps. P is the set of current possible edges which will be chosen to the spanning tree. SEQq will be refined as follows to fix the order of the first two vertices to generate a QI-Sequence of q. Suppose that (u, v) is the first edge in SEQq. If φ(u) = φ(v), we pick one of them with lower average inner support as the first vertex. Otherwise, we choose one with higher degree. If the degrees are also equal, we randomly select one.</p><p>SelectFirstEdge (Algorithm 5) and SelectSpanningEdge (Al-Algorithm 4: SpanningTree(q w ) Input : q w : weighted query graph; Output: T : a minimum spanning tree of q; SEQq: a QI-Sequence; VT := ∅;  <ref type="table">2</ref>, the weight graph q w is calculated as Figure <ref type="figure">4</ref>. In the weight graph q w , there are only 1 edge (v1, v2) which has the minimum weight 1.4. Therefore, we will select it as the first edge of the minimum spanning tree. Afterwards, as the edges (v2, v3) and (v2, v7) have the same weight, both of them are selected to the set P . In the function SelectSpanningEdge, we find that they have same induced subgraph and the degree of v3 and v7 are also same. Thus we randomly choose one of them, for example, v3. Assume the edges (v3, v4),(v4, v5),(v5, v6) and (v5, v6) subsequently become the spanning edges. We add (v2, v7) to the SEQq as an extra entry.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Filtering-And-Verification</head><p>Our filtering-and-verification algorithm is shown in Algorithm 7, called QI-Framework, based on the QuickSI algorithm shown in Algorithm 3. Given a query graph q, it first obtains the candidate set, C, by calling a Filtering procedure (line 1) which we will discuss in the next section. Next, it iteratively checks every graph gi in the candidate set C and inserts gi into final result if q is contained by gi by calling Algorithm 6: SelectSpanningEdge(P , q w ) Input : P : a set of edges; q w : a weight graph; VT : a set of vertices; Output: e: an edge in P ; P := {e|e ∈ P ∧ (∀e ∈ P )∃(w(e) ≤ w(e ))}; Algorithm 7: QI-Framework (q, I, D) Input : q is a query graph; I is the index; D is a graph database; Output: R: a set of graphs in which q is a subgraph; C := Filtering(q, I); 1 Convert q to a QI-Sequence SEQq;  QuickSI (line 3-7). It is worth noting that it only needs to convert q to a QI-Sequence once (line 2). Finally, it returns the result R (line 8).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">A NEW FILTERING APPROACH</head><p>Recall that in the f iltering-and-verif ication (Algorithm 1) the filtering is done as F := {fi|fi ⊆ q ∧ fi ∈ I} followed by C := f i ∈F fi.list (line 1-2). It first obtains a set of features that appear in the query graph q as well as in the index (I), and then identifies the candidate set (C). For the first step, it needs to decompose the query graph, q, into a set of features, fi, and identify every feature fi that also appears in the index I. The query decomposition can be done fast but the identification of a feature in the index needs subgraph isomorphism testing, which is costly.</p><p>We observe that the subgraph isomorphism testing cost can be further reduced if two indexed features fj and f k in the database share a common subgraph. We explain our main idea below. Suppose that there are two indexed features, fj and f k in the database which share a common subgraph. Let fi be a feature in a query graph q. We need to test whether fi ⊆ fj and further test whether fi ⊆ f k , in the existing f iltering-and-verif ication framework. In our approach, instead, we pre-compute QI-Sequences for fj and f k , denoted as SEQ f j and SEQ f k , and maintain SEQ f j and SEQ f k in a prefix-tree index called Swift-Index. Given a query graph q, we do not decompose the query graph, q, into a set of features fi. Instead, we search from the prefixtree index in a top-down fashion, and test if a QI-Sequence, say SEQ f j , appear in Q using our QuickSI algorithm. The prefix-tree structure allows us to reduce the computational cost for subgraph isomorphism testing, because if a prefix of QI-Sequences does not appear in the query graph q, the whole QI-Sequences cannot appear in q.</p><p>Taking the advantage of the paradigm in QuickSI, we develop efficient filtering techniques to generate a candidate set. Our techniques are based on a new effective prefix-tree index called Swift-Index which indexes tree features that appear in the graph database D. Our QuickSI paradigm not only can be used to speed up the verification but also can be used to speed up the filtering computation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Swift-Index</head><p>In Swift-Index, we use tree features instead of subgraph features for the following reasons. Firstly, it is well known that the costs of mining tree features are much lower than those of mining graph features, especially when feature sizes increase. Secondly, features need to be canonized, while a graph canonization is equivalent to the graph isomorphism problem. It is well known that the graph isomorphism problem is open <ref type="bibr" target="#b2">[2]</ref>; there is no polynomial algorithm developed nor proof of NP-complete. On the other hand, computing a canonical form of trees can be done in O(degmaxk log k) <ref type="bibr" target="#b5">[5]</ref>, where k and degmax are the number of vertices and the maximal vertex degree in the tree, respectively.</p><p>Tree features in Swift-Index are organized by a prefix tree <ref type="bibr" target="#b6">[6]</ref>. To construct such an index, we first convert each tree feature f to a QI-Sequence SEQ f . Then we organize all QI-Sequences into a prefix tree. Note that in a QI-Sequence of a feature, there are no extra edge constraints since a feature is a tree. In the prefix tree, each node represents an entry Ti of a SEQ f for a tree feature f such that all entries in SEQ i f are recorded along the path from the root to the node. A dummy node is created to represent the root in the prefix tree. Consequently, each node of a prefix tree accumulatively carry a prefix of a QI-Sequence, SEQ i f . The ID-list of a feature (i.e., a list of IDs of graphs containing the feature) is attached to the end node of the feature in the prefix tree. Because each node in the prefix tree can be represented by [TiR * ij ], the maximum depth of the prefix tree is the maximum number of vertices among features.</p><p>Figure <ref type="figure" target="#fig_9">5</ref> shows a simple prefix tree for three features in Figure <ref type="figure" target="#fig_1">3</ref> and an additional feature f4. We can see the encoded QI-Sequences of f1 and f4 share the prefix of SEQ 2</p><formula xml:id="formula_15">f 1 = [T1[0, N ]][T2[1, C]].</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Filtering</head><p>Given a Swift-Index I, in this section, we discuss our prefix-pruning and prefix-sharing techniques to reduce the costs of subgraph isomorphism testing in the filtering phase.</p><p>Prefix-Pruning. The prefix-prunning is based on the following property: A prefix SEQ i f of a QI-Sequence SEQ f represents an induce subgraph of the tree feature f against the vertices in SEQ i f . The QI-Sequence SEQ f cannot be mapped to a query graph q if its prefix SEQ i f cannot be mapped to f . This property allows us to prune away the features as early as possible.</p><p>Given a query graph q and the prefix-tree Swift-Index, I, the process of finding all features in I that are contained in q is conducted by traversing the prefix-tree from the top to the bottom in the depth-first fashion. When visting a  node in the prefix-tree, ni, the path from the root to the node ni represents SEQ i f for all tree features SEQ f that has SEQ i f as their prefix. If SEQ i f is not sub-isomorphic to q, then there is no need to further examine the subtrees below ni in the prefix-tree, because SEQ j f , for j &gt; i, cannot be sub-isomorphic to q.</p><formula xml:id="formula_16">n 1 : T 1 &lt; 0 , N &gt; &lt; r o o t &gt; n 2 : T 2 &lt; 1 , C &gt; n 7 : T 3 &lt; 1 , C &gt; n 1 1 : T 3 &lt; 2 , C &gt; n 1 2 : T 4 &lt; 3 , C &gt; n 1 3 : T 5 &lt; 1 , C &gt; a b c n i l c n i l n 8 : T 4 &lt; 1 , C &gt; a b n i l n 4 : T 3 &lt; 2 , C &gt; n 3 : T 3 &lt; 2 , O &gt; c n i l</formula><p>Prefix-Sharing. We further reduce the subgraph isomorphism testing cost by utilizing the prefix-tree. Note that there could be many sub-isomorphism mappings from a prefix, SEQ i f , to a query graph q. To save memory space, during the depth-first traversal of the prefix-tree (Swift-Index), we only keep one sub-isomorphism mapping and replace it by another sub-isomorphism mapping if the current subisomorphism mapping has been already used against all the features with the prefix. We explain it using an example.</p><p>Example 5. Regarding the prefix tree in Figure <ref type="figure" target="#fig_9">5</ref>(b), assume that the query graph q is the one in Figure <ref type="figure" target="#fig_0">2(b)</ref>. Since f1 and f2 share the prefix SEQ 2</p><formula xml:id="formula_17">f 1 = [T1[0, N ]][T2[1, C]],</formula><p>we could identify whether q contains f1 and f2 by sharing computation for deciding if SEQ 2 f 1 is sub-isomorphic to q. It proceeds as follows.</p><p>In the beginning, T1 and T2 are mapped to the vertices u1 and u2 in q, respectively. We try to identify the next entry T3 in the QI-Sequence of f4 and find that it cannot be mapped to any vertex adjacent to u2 in q. Then, we keep the isomorphic mapping between T1, T2 and u1, u2 , while trying to find a mapping between T3 in the QI-Sequence of f1 and a vertex in q. We successfully map T3 to u3 of q. As T3 is the last entry the QI-Sequence of f1, we select f1 into the result feature set and mark T3 of f1 as a successful node in the prefix tree.</p><p>As T3 in the QI-Sequence of f4 fails to be mapped to any vertices in q regarding the mapping between T1, T2 and u1, u2 , we will find the next mapping from T1, T2 to 2 vertices in q. To do this in a backward fashion in the depthfirst search, we will find the next mapping of T2. In this case, there is no other isomorphic mapping from T2 to a vertex in q given the mapping between T1 to u1. Then, we go back Algorithm 8: Filtering(q, I) Input : q: a query graph; I: a prefix tree index; Output: C: a list of candidate graphs; S := ∅; 1 H :=empty mapping from feature to query; 2 F :=empty vector for vertices usage of q; 3 for each child n of I.ROOT do 4 PrefixQuickSI(n, q,H ,F ,1,S);  to T1. We find another isomorphic mapping: T1, T2 to u9, u8 in q. Next we only need to focus on f4. We find T3 of f4 still cannot be mapped to any vertex adjacent to u8. We can conclude that f4 is not contained by q.</p><p>The Filtering Algorithm. Based on prefix-pruning and prefix-sharing discussed, we propose our filtering algorithm in Algorithm 8 where Algorithm 9 is invoked recursively. Filtering (Algorithm 8) initializes H and F for mapping information and vertex usages of q, respectively. It recursively calls PrefixQuickSI (Algorithm 9) to find out all features {f } such that f ⊆ q and f ∈ I. Finally, it intersects the ID-lists of the features in set S to create candidate set C of graphs; that is, find graphs that contain all the features in S. PrefixQuickSI can be regarded as a "batch" version of QuickSI. Different from processing an one-to-one isomorphism testing, given a query graph q, PrefixQuickSI can do the subgraph isomorphism testing simultaneously for a set of features with the same prefix. It reuses the ancestor's intermediate status in the subgraph isomorphism testing effectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Index Construction</head><p>In order to control the index size, we only choose frequent and discriminative tree features to build the prefix tree. We assume that frequent trees have high probability to appear in queries. Given a tree feature f , the frequency f rq(f ) is computed by |{g|f ⊂g∧g∈D}| |D| , where D is the graph database. Let the frequency threshold be δ ∈ [0, 1]. We define the frequency selection criteria as follows.</p><p>Frequent Criteria. Given a frequency threshold δ, a feature f is frequent iff f rq(f ) ≥ δ.</p><p>Given a feature f , we also define the discriminative measure dis(f ) as follows.</p><formula xml:id="formula_18">dis(f ) = |f.list| | {f .list|f ⊂ f ∧ f ∈ I}|</formula><p>where f.list is the inverted list of feature f . Let the discriminative threshold be γ ∈ [0, 1]. The discriminative criteria <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b20">20]</ref> shown below is also used to control feature number as follows.</p><p>Discriminative Criteria. Given a discriminative threshold γ, a feature f is discriminative, iff dis(f ) &lt; 1γ.</p><p>The Swift-Index is constructed using Algorithm 10. We use both PrefixQuickSI and QuickSI algorithms in the query In our experiments, we use default parameters or suggested values unless specified otherwise. Particularly, default values σ = 0.1 and δ = 0.1 are used in FG-Index <ref type="bibr" target="#b4">[4]</ref> algorithm. In algorithm (Tree+∆) , the support threshold is set to 0.01 and the maximal tree size is by default 10. For GSI algorithm, we adopt the default parameters in <ref type="bibr" target="#b16">[16]</ref> with support threshold 0.1 and maximum fragment size maxL=10. The values of θ and γ are set to 0.1 and L is set to 10 in algorithm SSI.</p><p>Our experiments are conducted on the real dataset as well as synthetic datasets. Following previous works <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b9">9,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b20">20]</ref>, we omit edge labels of graphs in our experiments.</p><p>Real dataset. We use the AIDS Antiviral Screen dataset, which consists of 43, 905 classified chemical molecules. The dataset is publicly available on the website of Development Therapeutics Program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Synthetic dataset</head><p>In order to evaluate the scalability of our techniques, we generate a large number of graphs by using the synthetic graph data generator GraphGen in <ref type="bibr" target="#b4">[4]</ref>. The generator also allows us to specify various parameters such as the average graph density, graph size and the number of distinct node labels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Performance on Real Dataset</head><p>The AIDS Antiviral dataset is a popular benchmark in recent related works <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b20">20,</ref><ref type="bibr" target="#b4">4]</ref>. There are totally 62 distinct vertex labels in the data set but the majority of the vertex labels are C, O and N . We derive different subsets from the full collection for comparison purpose. Default real dataset is a subset containing 10K graphs, which is firstly used in <ref type="bibr" target="#b16">[16]</ref> and can be downloaded from http://www. xifengyan.net/software.htm. On average, each graph has 25.4 vertices and 27.3 edges. Other subsets with 1K, 5K, 20K and 40K graphs are derived in a similar way in order to study the scalability of the algorithms against different database size. We also create a large real dataset in order to evaluate the performance of our techniques on large graphs. This set consists of the largest 10K graphs taken from the original AIDS Antiviral collection. In the large real dataset, each graph has 40.4 vertices and 44 edges on average. We adopt the query set from <ref type="bibr" target="#b16">[16]</ref> to test the effectiveness of our technique in terms of query response time. There are six query sets Q4, Q8, Q12, Q16, Q20 and Q24. Each query set Qi consists of 1000 query graphs with i edges. Default query set is Q16 in the following experiments. In the first experiment, we demonstrate the efficiency of our subgraph isomorphism testing algorithm QuickSI against Ullman algorithm. We first run filtering algorithm proposed in Section 4 against the default real dataset to create candidate sets for each query set. The candidate sets are then verified for subgraph isomorphism using QuickSI and Ullman respectively. We use QuickSI and QuickSI(R) to denote QuickSI algorithm with an effective QI-Sequence and a random QI-Sequence, respectively. Average verification time for each query set is recorded and demonstrated in Figure <ref type="figure">6</ref>, which shows that both QuickSI and QuickSI(R) algorithm significantly outperform Ullman algorithm. Both QuickSI and QuickSI(R) achieve even more performance gain with increasing query graph size. For query set Q24, the average runtime of QuickSI is 5, 535 times less than that of Ullman. Moreover, compared with Ullman algorithm, performance of both QuickSI and QuickSI(R) are less sensitive to query graph size. Meanwhile, QuickSI is twice as fast as QuickSI(R). It confirms our heuristic QI-Sequence construction algorithm plays an important role in reducing the verification cost.</p><p>Figure <ref type="figure" target="#fig_13">7</ref> illustrates the average query response time of two previous algorithms FG-Index and (Tree+∆) against different query sets. It turns out that FG-Index is much more competitive than (Tree+∆) in terms of query response time, which is our primary performance measure. <ref type="foot" target="#foot_3">3</ref> Thus we exclude (Tree+∆) in the following experiments.  The experiments demonstrate that our new SSI Algorithm is the clear winner in the three algorithms on both datasets regarding query processing time.</p><p>FG-Index is attractive for very small queries. This is a reasonable result, as for small queries, large amount of graphs in the candidate set can be verified without subgraph isomorphism testing using FG-Index, whereas for larger queries, the verification free technique can not take effect on most candidates.</p><p>Comparing GSI and FG-Index, we can see that FG-Index beats GSI with a factor of up to 2 on median-sized data graphs, while on the large real dataset, GSI Algorithm outperforms FG-Index by a large margin. Remember that in <ref type="bibr" target="#b4">[4]</ref>, gIndex is outperformed by FG-Index Algorithm with at least one order, while with the help of our efficient verification algorithm, GSI Algorithm is comparable, in some cases much better than FG-Index. The difference shows that our verification algorithm can bring immediate improvement to the overall query performance of current filtering-andverification based algorithms.</p><p>GSI Algorithm always spends less verification time compared with SSI Algorithms, since its graph-based index has better pruning ability, but the overall performance of GSI dramatically decreases when query graph size increases, because the filtering time grows and becomes the dominant cost.</p><p>We also record the index construction time, number of features in the index and the size of index for both default real dataset and large real dataset. Results are listed in Table <ref type="table" target="#tab_3">3</ref>    In order to study the scalability of the algorithms against the graph database size, Figure <ref type="figure" target="#fig_17">9</ref> demonstrates the overall performance of three techniques on different subsets of the AIDS Antiviral collection. Because the binary code of gIndex from <ref type="bibr" target="#b16">[16]</ref> fails to build index when the number of graphs reaches 20K, there is no experimental result of GSI for the 20K and 40K datasets. In Figure <ref type="figure" target="#fig_17">9</ref>(a), the query set with medium size Q16 is used as default query set to evaluate the response time. We can see the SSI wins on all four metrics in Figure <ref type="figure" target="#fig_17">9</ref>, showing that the scalability of SSI also outperforms FG-Index.  In this section, we present the performance evaluation on synthetic datasets. As important parameters such as graph size, number of graphs and size of the query graph are studied on the real dataset, we focus on investigating the scalability of the techniques to the number of distinct vertex labels, which has a great impact on overall performance. Generally speaking, the less the number of distinct vertex labels, the harder the subgraph search problem is, since informative vertex labels are supposed to guide pruning and to reduce search space. We use the synthetic data generator from <ref type="bibr" target="#b4">[4]</ref> to generate a set of graph datasets with different number of distinct labels, varying from 50 to 10. The average number of edges in the queries graph and data graphs are 20 and 30 respectively. There are 10K data graphs and 1K queries in the following experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Performance on Synthetic Dataset</head><p>Figure <ref type="figure" target="#fig_19">10</ref> reports the overall performance of three techniques against the number of distinct labels. As expected, performance of all three techniques deteriorate with the decreasing number of distinct vertex labels. But compared with the other two techniques, SSI is much more scalable. When the number of distinct labels drops from 50 to 20, the response time of SSI are nearly fixed, while response time of FG-Index and GSI increases 10 times and 5 times, respectively. Same trend is observed on the number of features and index size, but all three techniques are not scalable to construction time. gIndex fails to build index when the number of distinct labels reaches 10. We do not report the response time of FG-Index for distinct number of 10, since FG-Index fails to return any result.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED WORK</head><p>Research in subgraph isomorphism and graph isomorphism has drawn a great deal of attention in the database community. In order to speed up subgraph and similarity search over large graph databases, most related work focuses on developing index techniques to support efficient searching. There are two categories of indexing techniques: featurebased index and nonfeature-based index.</p><p>In feature-based index, some graph fragments or patterns are chosen as index features, and an inverted list is built for each feature. Generally query processing follows the filtering-and-verification framework. Shasha et al. <ref type="bibr">[8]</ref> pro-  Grep enumerates all paths within a threshold length as index features. Main problem of the method is that by extracting paths from graphs, large amount of structural information is not preserved, and as a consequence, the index's pruning power is diminished.</p><p>To overcome this problem, some recent work uses more complex and selective sub-structures as index features, meanwhile adopt data mining techniques <ref type="bibr" target="#b15">[15,</ref><ref type="bibr" target="#b19">19]</ref> to improve performance and to reduce index size. Among these techniques, gIndex <ref type="bibr" target="#b16">[16]</ref> developed by Yan et al. introduces "discriminative ratio" for selecting feature set. Only frequent and discriminative subgraphs are selected as index patterns. Comparing with GraphGrep, index size of gIndex is 10 times smaller, while the candidate set size after filtering is 3-10 times smaller. Authors of gIndex also extend the framework and propose a structural filtering algorithm called Grafil to support approximate graph queries <ref type="bibr" target="#b17">[17]</ref>. Two recent techniques, TreePi <ref type="bibr" target="#b18">[18]</ref> and (Tree+∆) <ref type="bibr" target="#b20">[20]</ref> try to index frequent and discriminative subtrees rather than subgraphs, as trees can be manipulated efficiently while preserving most structural information of the original graphs. Since mining frequent trees is much easier than mining graphs, construction time of both TreePi and (Tree+∆) are relatively small. TreePi also adopts a new pruning technique based on the concept of Center Distance Constraints. The basic observation is that if the query graph appears in a candidate graph, distances between pairs of features in query graph must be preserved in the candidate graph as well. In another new indexing technique FG-Index <ref type="bibr" target="#b4">[4]</ref>, both frequent subgraphs and edges are chosen as feature set. FG-Index supports verification-free subgraph search with a reversed containment testing. The observation is that, if the query graph is contained by some feature in the index, all graphs in the database which contain that feature must also contain the query graph, and such graphs can be returned as final results without further verification. This technique becomes effective only when many large subgraphs are indexed, thus construction cost and storage overhead of FG-Index are much larger than other feature-based indexing techniques.</p><p>In the category of non-feature-based index, Messmer et al. propose novel clutering-structured mechanism and decisiontree approach for indexing graphs for isomorphism and sub-graph isomorphism <ref type="bibr" target="#b12">[12]</ref>. The method generates results in polynomial time, at the cost of a large index whose size increases exponentially with respect to database size. Berretti et al. <ref type="bibr" target="#b3">[3]</ref> propose a metric indexing schema for contentbased image retrieval. Graphs are clustered hierarchically according to their mutual distances. More recently, He and Singh propose a clustering-based index called Closure-tree to support both subgraph queries and similarity queries <ref type="bibr" target="#b9">[9]</ref>. The graph closure is a "bounding box" containing structural information of the constituent graphs. <ref type="bibr" target="#b9">[9]</ref> also proposes a technique called pseudo subgraph isomorphism, which is an approximation technique for subgraph isomorphism.</p><p>There are other literatures related to graph queries on specific graph databases. gString <ref type="bibr" target="#b10">[10]</ref> is developed on chemical compound databases. Williams et al. <ref type="bibr" target="#b14">[14]</ref> develop a treestructured index based on graph decomposition for graphs with limited sizes. And a novel spectral graph coding technique named GCoding is proposed for the sub-graph search problem in <ref type="bibr" target="#b21">[21]</ref>. Based on GCoding, the structure of the graph can be encoded into a numerical space, and a two-step filtering method is presented to search the graph database.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSION</head><p>In this paper, we study the problem of efficiently processing subgraph containment queries. An efficient subgraphisomorphic verification algorithm, QuickSI, is proposed. In addition, combining QuickSI with a novel prefix-tree index, Swift-Index, our new techniques significantly improve the existing techniques for subgraph containment queries, in particular for graphs with median and/or large sizes. Our new techniques achieve high scalability regarding graph sizes and graph database sizes. Possible directions for future studies include an investigation of whether or not our current techniques can be effectively used to support the existing techniques for subgraph containment queries. Approximate query processing is another direction.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 1: Simple Query Graph</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: A Sample of Feature-based Index</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Algorithm</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Figure 4: The Weight Graph</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>1 ET := ∅; 2 SEQq := ∅; 3 P 4 e 6 Remove e from q w ; 7 while 8 P 9 e 11 Remove e from q w ; 12 for 14 SEQq ← e and remove e from q w ; 15 T 17 Algorithm 5 : 1 P 3 return e; 4 gorithm 6 )Example 4 .</head><label>123467891112141517513464</label><figDesc>:= {e|e ∈ E(q w ) ∧ ∀(e ∈ E)∃(q w )∃w(e) ≤ w(e )}; := SelectF irstEdge(P, q w ); 5 ET := {e},SEQq ← e, VT := {e.u, e.v}; VT = V (q w ) do := {e|e ∈ E(q w ) ∧ e.u ∈ VT ∧ e.v ∈ VT }; := SelectSpanningEdge(P, q w , VT ); 10 ET := ET ∪ {e}, SEQg ← e, VT := VT ∪ {e.v} ; each e ∈ q w satisfying e.u ∈ VT ∧ e.v ∈ VT do 13Sort them by the increasing order of w(e); := (VT , ET ); 16 return T , SEQq; SelectFirstEdge(P , q w ) Input : P : a set of edges;q w : a weight graph; Output: e: an edge in P ; if |P | &gt; 1 then := {e|e ∈ P ∧ ∀(e ∈ P )∃(deg(e.u, q w ) + 2 deg(e.v, q w ) ≤ deg(e .u, q w ) + deg(e .v, q w ))}; Randomly select an edge e ∈ P ; in Algorithm 4 deal with cases when there are several candidate edges in P with the same weight. Our algorithm will choose the edge which make the induce subgraph of the current vertex set VT as dense as possible. Suppose we have a graph q as shown in Figure 1(a) and the average frequency is shown in Table</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>1 if |P | &gt; 1 then 2 P 4 P</head><label>124</label><figDesc>:= {e|e ∈ P ∧ ∀(e ∈ P )∃(|IndG(VT ∪ {e.v}, q w )| ≥ 3 |IndG(VT ∪ {e .v}, q w )|)}; if |P | &gt; 1 then := {e|e ∈ P ∧ ∀(e ∈ P )∃(deg(e.v, q w ) ≤ 5 deg(e .v, q w ))}; Randomly select an edge e ∈ P ; 6 return e;7</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>2 for each gi ∈ C do 3 H 4 F 5 if 6 R</head><label>23456</label><figDesc>:= {0, ..., 0}; := {0, ..., 0}; QuickSI(SEQq, gi,H ,F ,1) then = R ∪ {gi}; 7 return R;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>8</head><label>8</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Prefix Tree of Features</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>5 C 6 for each feature f ∈ S do 7 C</head><label>567</label><figDesc>:=all graph IDs in graph database; := C ∩ f.list;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Algorithm 10 : 3 I 5 for each tree feature f with i vertices do 6 R 9 I 10 return I 11 with</head><label>1035691011</label><figDesc>Constuction(D,θ,γ,L) Input : D: a graph database; θ: the frequency threshold; γ: the discriminative threshold; L: the maximal size of feature; Output: I: a prefix tree index; I := ∅; 1 for each single vertex and single edge f do 2 f.list := {g|f ⊆ g}; := I ∪ {f }; 4 for i := 3 to L do :=QI-Framework(f ,I,D);7 if |M | |D| ≥ θ ∧ |M | |C| &lt; (1γ) then8f.list := {g|f ⊆ g}; := I ∪ {f }; Intel Xeon 2.40GHz dual CPU and 4G memory running Debian Linux.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 7 :</head><label>7</label><figDesc>Figure 6: Verification Time</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 8 :Figure 8</head><label>88</label><figDesc>Figure 8: Response time Figure 8 reports the average query response time per query comparing SSI, GSI and FG-Index algorithms against the default real dataset and the large real dataset. Filtering</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Scalability to #Graphs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Scalability to # Distinct Labels</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>l and</figDesc><table><row><cell>8</cell><cell></cell></row><row><cell></cell><cell>Fv = 0} ;</cell></row><row><cell>9</cell><cell>for each vertex v ∈ V do</cell></row><row><cell></cell><cell cols="2">for each restriction R dj ∈ SEQq do</cell></row><row><cell></cell><cell cols="2">goto line-9 if R dj is not satisfied;</cell></row><row><cell></cell><cell>H d := v;</cell></row><row><cell></cell><cell>Fv := 1;</cell></row><row><cell></cell><cell cols="2">if QuickSI(SEQ, g,H ,F ,d + 1) then</cell></row><row><cell></cell><cell>return T rue;</cell><cell>/* Terminate */</cell></row><row><cell></cell><cell>Fv := 0;</cell></row></table><note><p>return F alse; Example 3. Consider SEQq (Table</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>and Table4. It is clear that the SSI technique has the smallest feature number, construction time and number of features. Note that both SSI and GSI indexes are counted in ASCII mode, while FG-Index is counted in binary mode.</figDesc><table><row><cell></cell><cell>Construction Time (s)</cell><cell>#Features</cell><cell>Index Size</cell></row><row><cell>FG-Index</cell><cell>167.08 (166.5 + 0.58)</cell><cell>1641</cell><cell>12.5M</cell></row><row><cell>GSI</cell><cell>146.6</cell><cell>3276</cell><cell>13M</cell></row><row><cell>SSI</cell><cell>26.6</cell><cell>462</cell><cell>5.5M</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3 :</head><label>3</label><figDesc>Statistic for Real data</figDesc><table><row><cell></cell><cell>Construction Time (s)</cell><cell>#Features</cell><cell>Index Size</cell></row><row><cell>FG-Index</cell><cell>2133 (2102 + 31)</cell><cell>7100</cell><cell>53.8M</cell></row><row><cell>GSI</cell><cell>306.2</cell><cell>4394</cell><cell>13M</cell></row><row><cell>SSI</cell><cell>170.7</cell><cell>922</cell><cell>11.8M</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 4 :</head><label>4</label><figDesc>Statistic for Large Real data</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>To avoid a redundant computation, we do not record [deg : d] when d ≤</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p></p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><p>We do not use the index techniques in<ref type="bibr" target="#b18">[18]</ref> and<ref type="bibr" target="#b20">[20]</ref> as those indexes are closely interfered with the verification procedure.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3"><p>The main goal of (Tree+∆) is to reduce mining cost while achieving high efficiency in processing subgraph containment queries.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. The authors thank Xifeng Yan and Jiawei Han for providing gIndex, and James Cheng for providing FG-Index. The authors acknowledge the anonymous reviewers who provided helpful suggestions to the paper. We also would like to thank Yi Luo's contribution to the proof reading. The work was supported by ARC Grant (DP0881035 and DP0666428) and Google Research Award. The fourth author was supported by a grant of RGC, Hong Kong SAR, China (No. 418206).</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Algorithm 9: PrefixQuickSI(n, q,H ,F ,d,S) Input : n: a node in prefix tree; q: a graph; H : a vector with mapping information; F : a vector with usage information; d: depth, initialized by 1; S: the matched feature set; SEQ := n.SEQ; </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">PERFORMANCE EVALUATION</head><p>In this section, we report extensive empirical results to evaluate the effectiveness and efficiency of our new techniques. We compare our verification algorithm QuickSI described in Section 3 against the widely applied subgraph isomorphism testing algorithm Ullman <ref type="bibr" target="#b13">[13]</ref>. To analyze the benefit of our verification algorithm and index technique on overall query processing performance, we implement two algorithms GSI and SSI. GSI combines gIndex <ref type="bibr" target="#b16">[16]</ref> with our verification algorithm QuickSI by feeding the output of gIndex to QuickSI to produce final results. We show that our verification algorithm can bring immediate benefit to the performance of current filtering-and-verification based algorithms 2 . SSI is a combination of our new index technique Swift-Index proposed in Section 4 with QuickSI for verification. We compare FG-Index <ref type="bibr" target="#b4">[4]</ref> and (Tree+∆) <ref type="bibr" target="#b20">[20]</ref> with GSI and SSI. All algorithms proposed in this paper are implemented in standard C++ with STL library surport and compiled with GNU GCC. Experiments are run on a PC</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Hopcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ullman</surname></persName>
		</author>
		<title level="m">Data Structures and Algorithms</title>
		<imprint>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Graph isomorphism is low for zpp(np) and other lowness results</title>
		<author>
			<persName><forename type="first">V</forename><surname>Arvind</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Köbler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STACS</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="431" to="442" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Efficient matching and indexing of graph models in content-based retrieval</title>
		<author>
			<persName><forename type="first">S</forename><surname>Berretti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Bimbo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Vicario</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Pattern Anal. Mach. Intell</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1089" to="1105" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Fg-index: towards verification-free query processing on graph databases</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGMOD international conference on Management of data</title>
		<meeting>the ACM SIGMOD international conference on Management of data</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="857" to="872" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Canonical forms for labelled trees and their applications in frequent subtree mining</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Chi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Muntz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Knowl. Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="203" to="234" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">H</forename><surname>Cormen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Stein</surname></persName>
		</author>
		<title level="m">Introduction to Algorithms</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Computers and Intractability; A Guide to the Theory of NP-Completeness</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<pubPlace>New York, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Graphgrep: A fast and universal method for querying graphs</title>
		<author>
			<persName><forename type="first">R</forename><surname>Giugno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Shasha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Pattern Recognition</title>
		<meeting>the International Conference on Pattern Recognition</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="112" to="115" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Closure-tree: An index structure for graph queries</title>
		<author>
			<persName><forename type="first">H</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Data Engineering</title>
		<meeting>the International Conference on Data Engineering</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page">38</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Gstring: A novel approach for efficient search in graph databases</title>
		<author>
			<persName><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Data Engineering</title>
		<meeting>the International Conference on Data Engineering</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="566" to="575" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">An automatic method of solving discrete programming problems</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">H</forename><surname>Land</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Doig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Econometrica</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="497" to="520" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A decision tree approach to graph and subgraph isomorphism detection</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">T</forename><surname>Messmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Bunke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pattern Recognition</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1979" to="1998" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">An algorithm for subgraph isomorphism</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Ullmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="31" to="42" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Graph database indexing using structured graph decomposition</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Huan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Data Engineering</title>
		<meeting>the International Conference on Data Engineering</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="976" to="985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">gspan: Graph-based substructure pattern mining</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE International Conference on Data Mining</title>
		<meeting>the IEEE International Conference on Data Mining</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page">721</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Graph indexing: a frequent structure-based approach</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGMOD international conference on Management of data</title>
		<meeting>the ACM SIGMOD international conference on Management of data</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="335" to="346" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Substructure similarity search in graph databases</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGMOD international conference on Management of data</title>
		<meeting>the ACM SIGMOD international conference on Management of data</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="766" to="777" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Treepi: A novel graph indexing method</title>
		<author>
			<persName><forename type="first">S</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Data Engineering</title>
		<meeting>the International Conference on Data Engineering</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="966" to="975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Fast frequent free tree mining in graph databases</title>
		<author>
			<persName><forename type="first">P</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">X</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">World Wide Web</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="71" to="92" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Graph indexing: tree + delta &lt;= graph</title>
		<author>
			<persName><forename type="first">P</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">X</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Very Large Data Bases</title>
		<meeting>the International Conference on Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="938" to="949" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A novel spectral coding in a large graph database</title>
		<author>
			<persName><forename type="first">L</forename><surname>Zou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">X</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Extending Database Technology</title>
		<meeting>the International Conference on Extending Database Technology</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
