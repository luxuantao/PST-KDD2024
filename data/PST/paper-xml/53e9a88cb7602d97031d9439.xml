<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Flexible Dynamic Information Flow Control in Haskell</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Deian</forename><surname>Stefan</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Stanford University</orgName>
								<address>
									<settlement>Stanford</settlement>
									<region>CA</region>
									<country>USA (</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alejandro</forename><surname>Russo</surname></persName>
							<email>russo@chalmers.se</email>
							<affiliation key="aff1">
								<orgName type="institution">Chalmers University of Technology</orgName>
								<address>
									<settlement>Gothenburg</settlement>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">John</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
							<email>mitchell@cs.stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Stanford University</orgName>
								<address>
									<settlement>Stanford</settlement>
									<region>CA</region>
									<country>USA (</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Mazières</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Stanford University</orgName>
								<address>
									<settlement>Stanford</settlement>
									<region>CA</region>
									<country>USA (</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Flexible Dynamic Information Flow Control in Haskell</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">4F1A72278F078A1D64FB8DF057B71006</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T10:06+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.1.1 [Programming Techniques]: Applicative (Functional) Programming; D.3.3 [Programming Languages]: Language Constructs and Features-Modules</term>
					<term>packages General Terms Security</term>
					<term>Languages</term>
					<term>Design Information flow control</term>
					<term>Monad</term>
					<term>Library</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We describe a new, dynamic, floating-label approach to languagebased information flow control, and present an implementation in Haskell. A labeled IO monad, LIO, keeps track of a current label and permits restricted access to IO functionality, while ensuring that the current label exceeds the labels of all data observed and restricts what can be modified. Unlike other language-based work, LIO also bounds the current label with a current clearance that provides a form of discretionary access control. In addition, programs may encapsulate and pass around the results of computations with different labels. We give precise semantics and prove confidentiality and integrity properties of the system.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Complex software systems are often composed of modules with different provenance, trustworthiness, and functional requirements. A central security design principle is the principle of least privilege, which says that each component should be given only the privileges it needs for its intended purpose. In particular, it is important to differentially regulate access to sensitive data in each section of code. This minimizes the trusted computing base for each overall function of the system and limits the downside risk if any component is either maliciously designed or compromised.</p><p>Information flow control (IFC) tracks the flow of sensitive data through a system and prohibits code from operating on data in violation of security policy. Significant research, development, and experimental effort has been devoted to static information flow mechanisms. Static analysis has a number of benefits, including reduced run-time overhead, fewer run-time failures, and robustness against implicit flows <ref type="bibr" target="#b9">[10]</ref>. However, static analysis does not work well in environments where new classes of users and new kinds of data are encountered at run-time. In order to address the needs of such systems, we describe a new, dynamic, floating-label approach to language-based information flow control and present an implementation in Haskell.</p><p>Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Haskell <ref type="bibr">'11, September 22, 2011</ref>, Tokyo, Japan. Copyright c 2011 ACM 978-1-4503-0860-1/11/09. . . $10.00</p><p>Our approach uses a Labeled type constructor to protect values by associating them with labels. However, the labels themselves are typed values manipulated at run-time, and can thus be created dynamically based on other data such as a username. Conceptually, at each point in the computation, the evaluation context has a current label. We use a labeled IO monad, LIO, to keep track of the current label and permit restricted access to IO functionality (such as a labeled file system), while ensuring that the current label accurately represents an upper bound the labels of all data observed or modified. Unlike other language-based work, LIO also bounds the current label with a current clearance. The clearance of a region of code may be set in advance to impose an upper bound on the floating current label within that region. This restricts data access, limits the amount of code that could manipulate sensitive data, and reduces opportunities to exploit covert channels. Finally, we introduce an operator, toLabeled, that allows the result of a computation that would have raised the current label instead to be encapsulated within the Labeled type.</p><p>The main features of our system can be understood using the example of an online conference review system, called λChair. In this system, which we describe more fully later in the paper, authenticated users can read any paper and can normally read any review. This reflects the normal practice in conference reviewing, for example, where every member of the program committee can see submissions, their reviews, and participate in related discussion. Users can be added dynamically and assigned to review specific papers. In addition, as an illustration of the power of the labeling system, integrity labels are used to make sure that only assigned reviewers can write reviews for any given paper. Conversely, confidentiality labels are used to manage conflicts of interest. Users with a conflict of interest on a specific paper lack the privileges, represented by confidentiality labels, to read a review. As conflicts of interest are identified, confidentiality labels on the papers may change dynamically and become more restrictive. It is also possible to remove conflicts of interest dynamically, if desired. A subtlety that we have found advantageous is that reviewers with a conflict of interest can potentially refer to reviews (by having a name that is bound to a review) but cannot perform specific operations simply because they can refer to them. As we have structured our online conference review system, the actual display of a conflict-of-interest review is a prohibited operation.</p><p>The main contributions of this paper include: ◮ We propose a new design point for IFC systems in which most values in lexical scope are protected by a single, mutable, current label, yet one can also encapsulate and pass around the results of computations with different labels. Label encapsulation is explicitly reflected by types in a way that prevents implicit flows. ◮ We prove information flow and integrity properties of our design and describe LIO, an implementation of the new model in Haskell. LIO, which can be implemented entirely as a library (based on type safety), demonstrating both the applicability and simplicity of the approach. ◮ Unlike other language-based work, our model provides a notion of clearance that imposes an upper bound on the program label, thus providing a form of discretionary access control on portions of the code. IFC originated with military applications <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b10">11]</ref> that label data and processes with sensitivity security levels. The associated labelchecking algorithms then prevent a Trojan horse reading classified data, for example, from leaking the data into less classified files. In operating systems, IFC is generally enforced at the kernel boundary, allowing a small amount of trusted code to impose a flexible security policy on a much larger body of supporting software. Extending the core concepts of IFC to a broader range of situations involving mutually distrustful parties that mix their code and data, Myers and Liskov <ref type="bibr" target="#b27">[28]</ref> subsequently introduced a decentralized label model (DLM) that has been the basis of much subsequent OS and language-based work. Unfortunately, despite its attractiveness, the DLM is not widely used to protect data in web applications, for example. In the operating systems domain, most of the past DLM-inspired work has relied exclusively on dynamic enforcement <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b38">39]</ref>. This is due to the dynamic nature of operating systems, which must support a changing set of users, evolving policies, and dynamically loaded code. But it is often inconvenient to establish security domains by arranging software according to course-grained kernel abstractions like processes and files. Moreover, adopting a new OS presents an even bigger barrier to deployment than adopting a new compiler. LIO uses the type system to enforce abstraction statically, but checks the values of labels dynamically. Thanks to the flexibility of dynamic checking, the library implements an IFC mechanism that is more permissive than previous static approaches <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b31">32]</ref> but providing similar security guarantees <ref type="bibr" target="#b33">[34]</ref>. Though purely language-based, LIO explores a new design point centered on floating labels that draw on past OS work. Both the code and technical details omitted in this paper can be found at http://www.scs.stanford.edu/ ~deian/lio.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Security Library</head><p>In this section, we give an overview of the information flow control approach used in our dynamic enforcement library for Haskell.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Labels and IFC</head><p>The goal of information flow control is to track and control the propagation of information according to a security policy. A well-known policy addressed in almost every IFC system is noninterference: publicly-readable program results must not depend on secret inputs. This policy preserves confidentiality of sensitive data <ref type="bibr" target="#b14">[15]</ref>.</p><p>To enforce information flow restrictions corresponding to security policies such as non-interference, every piece of data is associated with a label, including the labels themselves. Labels form a lattice <ref type="bibr" target="#b8">[9]</ref> with partial order ⊑ (pronounced "can flow to") governing the allowed flows. A lattice can be as simple as a few security levels. For instance, the three labels L, M, and H, respectively denoting unclassified, secret and top secret levels, form the lattice L ⊑ M ⊑ H. An IFC system such as our LIO library prohibits a computation running with security level M from reading top secret data (labeled H) or writing to public channels (labeled L). Dual to such confidentially policies are integrity policies <ref type="bibr" target="#b5">[6]</ref>, which use the partial order on labels to enforce restrictions on writes.</p><p>Our library is polymorphic in the label type, allowing different types of labels to be used. Custom label formats can be created by defining basic label operations: the can flow to label comparison (⊑), a function computing the join of two labels (⊔), and a function computing the meet of two labels (⊓). Concretely, label types are instances of the Label type class: class (Eq l) ⇒ Label l where leq : : l → l → Bool --Can flow to (⊑) lub :</p><p>:</p><formula xml:id="formula_0">l → l → l --Join (⊔) glb : : l → l → l --Meet (⊓)</formula><p>For any two labels L1 and L2, the join has the property that Li ⊑ (L1 ⊔ L2), i = 1, 2, while the meet has the property that (L1 ⊓ L2) ⊑ Li, i = 1, 2. In this section we present examples using the simple three-point lattice introduced above, or a generic/abstract label format; Section 3 details DC labels, a new, practical label format used to implement λChair.</p><p>Compared to existing systems, LIO is a language-based floatinglabel system, inspired by IFC operating systems <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b39">40]</ref>. In a floating-label system, the label of a computation can rise to accommodate reading sensitive data (similar to the program counter (pc) of more traditional language-based systems <ref type="bibr" target="#b32">[33]</ref>). Specifically, in a floating-label system, a computation C with label LC wishing to observe an object labeled LR must raise its label to the join, LC ⊔ LR, of the two labels. Consider, for instance, a simple λChair review system computation executing on behalf of a user, Clarice, with label LC that retrieves and prints a review labeled LR, as identified by R:</p><formula xml:id="formula_1">readReview R = do --L C rv ← retrieveReview R --L C ⊔ L R printLabeledCh rv --L C ⊔ L R</formula><p>The computation label (initially LC) is shown in the comments, on the right. Internally, the retrieveReview function is used to retrieve the review contents rv, raising the computation label to LC ⊔LR to reflect the observation of confidential data. This directly highlights the notion of a "floating-label": a computation's label effectively "floats above" the labels of all objects it observes. Moreover, this implies that a computation cannot write below its label; doing so could potentially result in writing secret data to public channels.</p><p>To illustrate the way floating labels restrict data writes, consider the action following the review retrieval: printLabeledCh rv. The trusted printLabeledCh function returns an action that writes the review content rv to an output channel, permitting the output channel label LO. The output channel label LO is dynamically set according to the user executing the computation. Specifically, LO is carefully set as to allow for printing out all but the conflicting reviews. For example, if Clarice is in conflict with review R then LO is set such that LR ⊑ LO. Since the computation label directly corresponds to the labels of the data it has observed, printLabeledCh simply checks that the computation label flows to the output channel. In the example above, the trusted function checks that LC ⊔ LR ⊑ LO before printing to (standard) output channel O.</p><p>As already mentioned, in contrast to other language-based systems, LIO also associates a clearance with each computation. This clearance sets an upper bound on the current floating label within some region of code. For example, code executing with a secret (M) clearance can never raise its label to read top secret data (labeled H). The notion of clearance can also prevent Clarice from retrieving (and not just printing) the contents of a conflicting review R by setting the computation's clearance to LP such that LR ⊑ LP . When the action retrieveReview R attempts to raise the current label to LC ⊔ LR to retrieve the review contents, the dynamic check will fail because LC ⊔ LR ⊑ LP . For flexibility, the output channel label can simply be LO = ⊤, allowing any information that can be retrieved to be written to the output channel.</p><p>Additionally, clearance can be used to prevent Clarice from using termination as a covert channel. For example, the following code can be used to leak conflicting-review information: leakingRetriveReview r = do rv ← retrieveReview r if rv = = "Paper..." then forever (return rv) else return rv However, using clearance, we prevent such leaks by setting the clearance and review labels in such manner that retrieveReview fails when raising the computation label to retrieve conflicting reviews.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Library Interface</head><p>LIO is a termination-insensitive <ref type="bibr" target="#b1">[2]</ref> and flow-sensitive <ref type="bibr" target="#b19">[20]</ref> IFC library that dynamically enforces information flow restrictions. At a high level, LIO defines a monad called LIO, intended to be used in place of IO. The library furthermore contains a collection of LIO actions, many of them similar to IO actions from standard Haskell libraries, except that they contain label checks that enforce IFC. For instance, LIO provides file operations like those of the standard library, but confining the application to a dedicated portion of the file system where a label is stored along with each file.</p><p>To implement the notion of floating label bounded by a clearance, our library provides LIO as a state monad that uses IO as the underlying base monad and it is parametrized by the type of labels. The state consists of a current label Lcur, i.e., the computation's floating label, and a current clearance Ccur, which is an upper bound on Lcur, i.e., Lcur⊑ Ccur. Specifically, the (slightly simplified) LIO monad can be defined as:</p><formula xml:id="formula_2">newtype Label l ⇒ LIO l a = LIO (StateT (l, l) IO a)</formula><p>where the state corresponds to the (Lcur, Ccur) pair. To allow for the execution of LIO actions, our library provides a function (evalLIO) that takes an LIO action and returns an IO action which, when executed, will return the result of the IFC-secured computation. It is important to note that untrusted LIO code cannot execute IO computations by binding IO actions with LIO ones (to bypass IFC restrictions), and thus effectively limits evalLIO to trusted code. Additionally, using evalLIO, (trusted) programmers can easily, though cautiously, enforce IFC in parts of an otherwise IFC-unaware program.</p><p>The current label provides means for associating a label with every piece of data. Hence, rather than individually labeling definitions and bindings, all symbols in scope are protected by Lcur (when a single LIO action is executed). Moreover, the only way to read or modify differently labeled data is to execute actions that internally access restricted symbols and appropriately validate and adjust the current label (or clearance).</p><p>However, in many practical situations, it is essential to be able to manipulate differently-labeled data without monotonically increasing the current label. For this purpose, the library additionally provides a Labeled type for labeling values with a label other than Lcur. A Labeled, polymorphic in the label type, protects an immutable value with a specified label (irrespective of the current label). This is particularly useful as it allows a computation to delay raising its current label until necessary. For example, an alternative approach to the above retrieveReview (called retrieveReviewAlt) retrieves the review, encapsulates it as a Labeled value, and returns the Labeled review, leaving the current label unmodified. This approach delays the creeping of current label until the review content, as encapsulated by Labeled, is actually needed, for instance, by printLabeledCh.</p><p>We note that LIO can be used to protect pure values in a similar fashion as Labeled. However, the protection provided by Labeled allows for serializing labeled values and straight forward inspection by trusted code (which should be allowed to ignore the protecting label). Unlike LIO, Labeled is not a monad. Otherwise, the monad instance would allow a computation to arbitrarily manipulate labeled values without any notion of the current label or clearance, and thus possibly violate the restriction that LIO computations should not handle values below their label and above their clearance. Moreover, such instance would require a definition for a default label necessary when lifting a value with return. Instead, our library provides several functions that allows for the creation and usage of labeled values within LIO. Specifically, we provide (among other) the following functions:</p><formula xml:id="formula_3">◮ label : : Label l ⇒l → a → LIO l (Labeled l a)</formula><p>Given a label l such that Lcur ⊑ l ⊑ Ccur and a value v, the action label l v returns a labeled value that protects v with l. ◮ unlabel : : Label l ⇒Labeled l a →LIO l a Conversely, the action unlabel lv raises the current label (clearance permitting) to the join of lv's label and the current label, returning the value with the label removed. Note that the new current label is at least as high as lv's label, thus protecting the confidentiality of the value. ◮ toLabeled :</p><formula xml:id="formula_4">: Label l ⇒l → LIO l a →LIO l (Labeled l a)</formula><p>Given a label l such that Lcur ⊑ l ⊑ Ccur and an LIO action m, toLabeled l m executes m without raising Lcur. However, instead of returning the result directly, the function returns the result of m encapsulated in a Labeled with label l. To preserve confidentiality (see Section 4 for further details), action m must not read any values with a label above l. We can implement toLabeled as follows:</p><formula xml:id="formula_5">toLabeled l m = do (L ′ cur , C ′ cur ) ← get --Save context res ← m --Execute action (Lcur, _) ← get --Get inner context unless (Lcur ⊑ l) fail --Check IFC violation put (L ′ cur , C ′ cur ) --Restore context lRes ← label l res --Encapsulate result return lRes --Return result</formula><p>In monadic terms, toLabeled is an environment-oriented action that provides a different context for a temporary bind thread, while unlabel is a state-oriented action that affects the current bind thread.</p><formula xml:id="formula_6">◮ labelOf : : Label l ⇒Labeled l a →l</formula><p>If lv is a labeled value with label l and value v, labelOf lv returns l. The formal semantics of these functions are given in Section 4 (see Figure <ref type="figure" target="#fig_3">4</ref>); in this section, we illustrate their functionality and use through examples.</p><p>Consider the previous example of readReview. The internal function retrieveReview takes a review identifier R and returns the review contents. This implies that, internally, retrieveReview has access to a list of reviews. These reviews are individually protected by a label, where the addition of a new review to the system can be implemented as:</p><formula xml:id="formula_7">addReview R L R rv = do r ← label L R rv addToReviewList R r</formula><p>where the addToReviewList simply adds the Labeled review to the internal list. The implementation of retrieveReview directly follows:</p><formula xml:id="formula_8">retrieveReview R = do --Lcur = L C r ← getFromReviewList R --Lcur = L C rv ← unlabel r --Lcur = L C ⊔ L R return rv --Lcur = L C ⊔ L R</formula><p>where the getFromReviewList retrieves the Labeled review from the internal list and unlabel removes the protecting label, and raises the current label to reflect the read.</p><p>We previously alluded to an alternative implementation of retrieveReview which, instead, returns the labeled review content while keeping the current label the same. As getFromReviewList is a trusted function and not directly available to untrusted users, such as Clarice, retrieveReviewAlt can be implemented in terms of toLabeled and retrieveReview:</p><formula xml:id="formula_9">retrieveReviewAlt R = do --Lcur = L C r ← toLabeled (L C ⊔ L R ) $ do --Lcur = L C rv ← retrieveReview R --Lcur = L C ⊔ L R return rv --Lcur = L C ⊔ L R return r --Lcur = L C</formula><p>Note that although the current label within the inner computation is raised, the outer computation's label does not change-instead the review content is protected by (LC ⊔ LR). Hence, only when the review content is actually needed, unlabel can be used to retrieve the content and raise the computation's label accordingly:</p><formula xml:id="formula_10">readReviewAlt R = do --Lcur = L C r ← retrieveReviewAlt R --Lcur = L C --Perform other computations --Lcur = L ′ C rv ← unlabel r --Lcur = L ′ C ⊔ L R printLabeledCh rv --Lcur = L ′ C ⊔ L R</formula><p>Our library also provides labeled alternatives to IORefs and files. Specifically, we provide labeled references Ref l a that are created with newRef, read with readRef, and written to with writeRef. When creating or writing to a reference with label LR, it must be the case that Lcur ⊑ LR ⊑ Ccur, while reading raises Lcur to Lcur ⊔ LR ⊑ Ccur. The rules for file operations follow identically, however writing to a file also implies observation (since the write can fail) and so the current label is raised in both cases. Finally, though beyond the scope of this paper, the library provides support for privileges. Privileges allow LIO code to operate under a more permissive ⊑ relation, but still more restricting than simply allowing the execution of arbitrary IO actions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">λChair</head><p>To demonstrate the flexibility of our dynamic information flow library, we present λChair, a simple API (built on the examples of Section 2) for implementing secure conference reviewing systems. In general, a conference reviewing system should support various features (and security policies) that a program committee can use in the review process; minimally, it should support: ◮ Paper submission: ability to add new papers to the system. ◮ User creation: ability to dynamically add new reviewers. ◮ User login: a means for authenticating users. ◮ Review delegation: ability to assign reviewers to papers. ◮ Paper reading: means for reading papers. ◮ Review writing: means for writing reviews. ◮ Review reading: means for reading reviews. ◮ Conflict establishment: ability to restrict specific users from reading conflicting reviews. Even for such a minimal system, a number of security concerns must be addressed. First, only users assigned to a paper may write the corresponding reviews. Second, information from the review of one paper should not leak into a different paper's review. Third, a reviewer should not be permitted to modify the review of a paper that she/he is not assigned to review. And, fourth, users should not received any information regarding papers for which they have conflicts. We establish these four policies as non-interference policies for the confidentiality and integrity of reviews. We note that, although enforcing additional security properties is desirable, these four policies are sufficient when implementing a minimalistic and fair review system. λChair's API provides the aforementioned security policies by applying information flow control. Following the examples of Section 2, we take the approach of enforcing IFC when writing to output channels, and thus the security for the above policies correspond to that of non-interference, i.e., secret data is not leaked into less secret channels/reviews. We do, however, note that the alternative, clearance restricting approach of Section 2, can be implemented and thus enforce the security policies by confinement rather than non-interference (see <ref type="bibr">Section 5)</ref>. Before delving into the details of the λChair, we first introduce the specific label format used in the implementation.</p><p>3.1 DC Labels λChair is implemented using Disjunction-Category (DC) labels, a new label format especially suitable for systems with mutually distrusting parties. DC labels can be used to express a conjunction of restrictions on data, which allows for the construction of policies that reflect the concern of multiple parties. Such policies are expressed by leveraging the notions of principals and Disjunction Categories (henceforth just categories).</p><p>A principal is a string representation of a source of authority such as a user, a group, a role, etc. To ensure egalitarian protection mechanisms, any code is free to create principals.</p><p>A category is an information-flow restriction specifying the set of principals that own it. Each category is denoted as a disjunction of its owners; for example, the category owned by principals P1 and P2 is written as [P1 ∨ P2]. Additionally, categories are qualified to be secrecy or integrity categories. A secrecy category restricts who can read, receive, or propagate information; an integrity category specifies who can modify a piece of data.</p><p>A DC label L = S, I is a set S of secrecy categories and a set I of integrity categories. All categories must be satisfied in order to allow information to flow and thus we write each set as a conjunction of categories. For example, the DC label</p><formula xml:id="formula_11">{[P1 ∨ P2] ∧ [P2 ∨ P3]} , {[P4]</formula><p>} has two secrecy categories and a single integrity category. Data with a DC label L1 can be propagated to an endpoint having a DC label L2 if the restrictions imposed by L1 are uphold by L2. We formalize this notion using the ⊑-relationship as follows.</p><p>Definition 1 (Can flow to). Given any two DC labels L1 = S1, I1 and L2 = S2, I2 , and interpreting each principal as a Boolean variable named according to the content of the string itself, we have</p><formula xml:id="formula_12">∀c1 ∈ S1.∃c2 ∈ S2 : c2 ⇒ c1 ∀c2 ∈ I2.∃c1 ∈ I1 : c1 ⇒ c2 S1, I1 ⊑ S2, I2</formula><p>,</p><p>where ⇒ denotes Boolean implication.</p><p>From now on, when we refer to a principal P , it can be interpreted as a string or Boolean variable depending on the context. As an example of the use of ⊑-relationship, the DC label</p><formula xml:id="formula_13">{[P1 ∨ P2] ∧ [P2 ∨ P3]} , {[P4]} ⊑ {[P1] ∧ [P3]} , {[P4 ∨ P6]} since P1 ⇒ P1∨P2, P3 ⇒ P2∨P3,</formula><p>and P4 ⇒ P4∨P6. Intuitively, the higher we move in the ⊑-relationship, the more restrictive the secrecy category becomes, while the integrity category, on the other hand, changes into a more permissive one. Additionally, we note that if a label contains a category that is implied by another, the latter is extraneous, as it has no effect on the value of the label, and can be safely removed.</p><p>The join and meet for labels L1 = S1, I1 and L2 = S2, I2 are respectively defined as follows:</p><formula xml:id="formula_14">L1 ⊔ L2 = reduce(S1 ∧ S2), reduce(I1 ∨ I2) L1 ⊓ L2 = reduce(S1 ∨ S2), reduce(I1 ∧ I2)</formula><p>Here, reduce removes any extraneous categories from a given set and ∧ and ∨ denote the conjunction and disjunction of two category sets viewed as Boolean formulas of principals in conjunctive normal form.</p><p>In the context of the well-known DLM <ref type="bibr" target="#b27">[28]</ref>, a DC label secrecy category of the form [P1 ∨ P2 ∨ • • • ∨ Pn] can be interpreted as the (slightly modified) DLM label component/policy {P1, P2, . . . , Pn : P1, P2, . . . , Pn}, where principals P1, . . . , Pn are both the owners and readers. Although a DLM component consists of a single owner, which does not need to be part of the reader list, a DC label component (category) consists of multiple owners which are also the (only) readers. Using this slightly modified notion of a label component, a DLM label (set of components) loosely corresponds to our notion of a label (conjunction of disjunctions). Readers interested in the formal semantics of DC labels and the comparison with DLM can refer to http://www.scs.stanford. edu/ ~deian/dclabel for further details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">DC Labels in λChair</head><p>In this section we describe the data structures and the role of DC labels (from now on just labels) in λChair.</p><p>λChair provides an API to build review systems for the functionalities described in Section 3. Intuitively, the API just supplies administrators and reviewers with functions for querying review entries and modifying user accounts. Technically speaking, λChair runs over an underlying state monad that stores information regarding reviews and users.</p><p>Review entries A review entry is defined as a record consisting of a paper id, a reference to the corresponding paper, and a reference to the shared review 'notebook'. Specifically, a review entry is defined as</p><formula xml:id="formula_15">data ReviewEnt = ReviewEnt { paperId : : Id , paper : : DCRef Paper , review : : DCRef Review }</formula><p>where DCRef is a labeled reference using DC labels. In other words, type DCRef a = Ref DCLabel a. Note that this differs from the examples of Section 2, in which the reviews were simply Labeled types.</p><p>Reading and writing papers Upon logging in, users are allowed to read and print out any paper by providing the paper id. The label of the reference paper in the ith-review entry is set to {} , {[Pi]} . Observe that the secrecy categories is empty (we interpret the empty category as the true Boolean value), thus allowing any function (without other integrity categories in its label) to read the paper by reading the reference content, i.e., the paper. This label does, however, restrict the modification of the paper to code running in a process that owns the integrity category Pi and can therefore run with the category [Pi] in the integrity set of its current label. Only a trusted administrator is allowed to own such principals. Consequently, reviewers' code cannot modify the paper because their current label (assigned by the trusted login procedure) never includes Pi in their integrity set.</p><p>Reading and writing reviews Similarly, reviewers' code is allowed to access any reviews written to any reference review. However, once a review has been read, its contents must not be written to another paper's review. We fulfill this requirement by identifying, using labels, when a given piece of code reads a certain review. More specifically, we label the reference review in the ith-review entry as {[Ri]} , {[Ri]} . As a consequence, when a function wishes to read the review for entry i, it must raise its current label as to include category [Ri] in its secrecy and integrity sets (clearance permitted). Once a process has been tainted as such, it will not be able to modify the contents of another paper's review since the integrity category [Ri] will cause the current label's integrity set to contain Ri in every category and (Ri ∨ C) ⇒ Rj for any C and i = j. Consider, for instance, a reviewer's code that has the current label set (by the trusted login procedure) to {[Ri]} , {[Ri]} , i.e., in the process of reviewing paper Pi. If the code reads another review with label Lj</p><formula xml:id="formula_16">= {[Rj ]} , {[Rj ]} , the current label is then updated to L = {[Ri] ∧ [Rj]} , {[Ri ∨ Rj]}</formula><p>, which clearly implies that L ⊑ Lj . The integrity category [Ri] restricts the modification of the review to processes that own Ri. In this case, however, the process running reviewers' code, assigned to review paper i, contains, at least initially, category [Ri] in the integrity set of its current label.</p><p>Users A reviewer is defined as a record consisting of a unique user name, password (used for authentication), and two disjoint sets of paper ids (in our implementation these are simple lists).</p><p>One set corresponds to the user's conflicting papers, the second set corresponds to the papers the user has been assigned to review. Concretely, we define a user as follows:</p><p>data User = User { name : : Name , password : : Password , conflicts : : [Id] , assignments :</p><p>:</p><formula xml:id="formula_17">[Id] }</formula><p>A user is authenticated using the name and password credentials. Upon logging in, the code of the reviewer assigned to papers 1, . . . , n is executed with the current label initially set to</p><formula xml:id="formula_18">{} , {[R1] ∧ • • • ∧ [Rn]}</formula><p>, where Ri is the principal corresponding to review entry i. The current clearance is set to ALL, {} . The special category set ALL (denoting the conjunction of all possible categories) in the clearance allows the executing code to (raise its current label and) read any data, while the integrity categories in the current label allow the process to only write to assigned reviews. Note, however, that in our case all reviewers append their review to the same review "notebook" and thus a write implies a read. Hence, to allow a reviewer to effectively perform a write-only operation, the process must execute the append function using toLabeled. We note the user is exposed to a function that appends to the review rather than directly writing to it, because multiple users are assigned to review the same paper and one should not be allowed to overwrite the work of another (using privileges a more elegant solution can easily be implemented).</p><p>Conflicts Following the readReview examples of Section 2, we restrict the reading, or more specifically, printing of a review to those reviewers in conflict with the paper. Although every user is allowed to retrieve a review, they cannot observe the result unless they write it to an output channel (in our simple example this corresponds to the standard output). Hence, code running on behalf of a user (determined after logging in) can only write to the output channel (using printLabelCh) if the current label L can flow to the output channel label Lo. Using the set of conflicting paper ids, for every user, we dynamically assign the output channel label Lo = So, {} , where</p><formula xml:id="formula_19">So = {[R1] ∧ • • • ∧ [Rn] ∧ [Rn+1 ∨ CONFLICT] ∧ • • • ∧ [RN ∨ CONFLICT]}</formula><p>and Ri where i = n + 1, . . . , N are the principals corresponding to all the review entries in the system (at the point of the print) that the authenticated user conflicts with. Here, CONFLICT corresponds to a principal that none of the users own (similar to Pi used in the labels of paper references). For each conflicting paper i, we create a category [Ri ∨ CONFLICT]. To observe the properties of this label, consider the case when executing code reads a conflicting paper Ri. In this situation, the current label is raised to</p><formula xml:id="formula_20">L = {[Ri] ∧ • • • } , {• • • } ,</formula><p>and subsequently when attempting to write to the output channel, it is the case that L ⊑ Lo. For L ⊑ Lo to hold true, there must be a category in Lo that implies <ref type="bibr">[Ri]</ref>. However, due to the conflict, the only category containing Ri in the channel label's secrecy category is [Ri ∨ CONFLICT] (and clearly [Ri ∨ CONFLICT] ⇒ [Ri]), which asserts that conflicting data cannot flow to the output channel. We further highlight that the channel label permits non-conflicting reviews j to be observed by including the corresponding category [Rj ] without principal CONFLICT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Implementation</head><p>In this section we present the API provided by λChair. As the main goal of λChair is to demonstrate the flexibility and power of our dynamic information flow library, we do not extend our example to a full-fledged system; the API can, however, be used to build relatively complex review systems. Below, we present the details of the λChair functions, which return actions in the RevLIO monad. This monad is a State monad defined using the State monad transformer with LIO as the base monad, and a state consisting of the system users, review entries, and name of the user that the executing code is running on behalf of.</p><p>System administrator interface A λChair administrator is provided with several functions that dynamically change the system state. Of these, we detail the most interesting cases below. Given a user name and paper id, it assigns the user to review the corresponding paper. The user must not already be in conflict with the paper. ◮ addConflict : : Name →Id → RevLIO () Given a user name and paper id, it marks the user as being in conflict with the paper. As above, it must be the case that the user is not already assigned to review the paper. ◮ asUser : : Name →RevLIO () →RevLIO () Given a user name, and user-constructed piece of code, it firsts authenticates the user and then executes the provided code with the current label and clearance of the user as described in Section 3.2. After the code is executed, the current label and clearance are restored and any information flow violations are reported.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Reviewer interface</head><p>The reviewer, or user, composes an untrusted RevLIO computation (or action) that the trusted code executes using asUser. Such actions may be composed using the following interface: ◮ findPaper : : String →RevLIO Id Given a paper title, it returns its paper id, or fails if the paper is not found. ◮ readPaper :</p><formula xml:id="formula_21">: Id → RevLIO Paper</formula><p>Given a paper id, the function returns an action which, when executed, returns the paper content. ◮ readReview : : Id → RevLIO () Given a paper id, the function returns an action which, when executed, prints the review to the standard output. Its implementation is similar to the example of Section 2, except operating on references. ◮ appendToReview : :Id→Content→RevLIO () Given a paper id and a review content, the function returns an action which, when executed, appends the supplied content to the review entry. Since there is no direct observation of the current review content, and to avoid label creep, the function, internally, uses toLabeled. An IFC violation results in an exception (not-catchable by untrusted code) being thrown (in the semantics presented in Section 4,  the program gets "stuck"). Figure <ref type="figure" target="#fig_1">1</ref> shows a simple example using the λChair API. In this example, Alice is assigned to review two papers. She does so by reading each paper (for the second, she also reads the existing reviews) and appending to the shared review. Bob, on the other hand, is added to the system after Alice's code is executed. Bob first writes a review for paper 2 and then attempts to violate IFC by trying to read (and write to the output channel) the reviews of paper 1. Though his review is appended to the correct paper, the review of the first paper is suppressed. We finally note that although the example is quite simple, it illustrates the use of the λChair primitives that may be used to implement a usable paper review system. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Formal Semantics for LIO</head><p>This section formalizes our library for a simple call-by-name<ref type="foot" target="#foot_0">1</ref> λ-calculus extended with Booleans, unit values, pairs, recursion, references, and the monadic operations for LIO. Figure <ref type="figure" target="#fig_2">2</ref> provides the formal syntax of the considered language. Syntactic categories v, e, and τ represent terms, expressions, and types, respectively. Terms are side-effect free while expressions denote (possible) sideeffecting computations.</p><p>In the syntax category v, symbol true and false represent Boolean values. Symbol () represents the unit value. Symbol ℓ denotes security labels. Symbol a represent memory addresses in a given store. Terms include (x), functions (λx.e), tuples (e, e), and recursive functions (fix e). Three special syntax nodes are added to this category: Lb v e, (e) LIO , and •. Node Lb v e denotes the run-time representation of a labeled value. Similarly, node (e) LIO denotes the run-time representation of a monadic LIO computation. Node • represents an erased term (explained in Section 5). None of these special nodes appear in programs written by users and they are merely introduced for technical reasons.</p><p>Expressions are composed of values (v), function applications (e e), pair projections (πi e), conditional branches (if e then e else e), and local definitions (let x = e in e). Additionally, expressions may involve operations related to monadic computations in the LIO monad. More precisely, return e and e &gt;&gt;= e represent the monadic return and bind operations. Monadic operations related to the manipulation of labeled values inside the LIO monad are given by label, unlabel, and toLabeled. Expression label e1 e2 creates a labeled value that guards e2 with label e1.</p><p>Expression unlabel e acquires the content of the labeled value e while in a LIO computation. Expression toLabeled e1 e2 creates a labeled value, with label e1, of the result obtained by evaluating the LIO computation e2. Non-proper morphisms related to creating, reading, and writing of references are respectively captured by expressions newRef, readRef, and writeRef. Expression lowerClr e allows lowering of the current clearance to e. Expressions getLabel and getClearance return the current label and current clearance of an LIO computation. Finally, expressions labelOf e and labelOfRef e respectively obtain the security label of labeled values and references.</p><p>We consider standard types for Booleans (Bool), unit (()), pairs (τ, τ ), and function (τ → τ ) values. Type ℓ describes se-</p><formula xml:id="formula_22">Γ ⊢ e1 : ℓ Γ ⊢ e2 : τ Γ ⊢ Lb e1 e2 : Labeled ℓ τ Γ ⊢ e : τ Γ ⊢ (e) LIO : LIO ℓ τ Γ ⊢ • : τ</formula><p>The typing judgments have standard form Γ ⊢ e : τ , such that expression e has type τ assuming the typing environment Γ; we use Γ for both variable and store typings. The typing rules for several terms are shown in Figure <ref type="figure" target="#fig_6">3</ref>; the typing for the remaining terms and expressions are standard and we therefore do not describe them any further. We, however, note that, different from previous work <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b31">32]</ref>, we do not require to use any of the sophisticated features of Haskell's type-system, a direct consequence of our dynamic approach.</p><p>The LIO monad presented in Section 2 is implemented as a State monad. To simplify the formalization and description of expressions, without loss of generality, we make the state of the monad part of a run-time environment. More precisely, for a given LIO computation, the symbol Σ denotes a run-time environment that contains the current label, written Σ.lbl, the current clearance, written Σ.clr, and store, written Σ.φ. A run-time environment Σ and LIO computation form a configuration Σ, e . Given a configuration Σ, e , the current label, clearance, and store when starting evaluation e is given by Σ.lbl, Σ.clr, and Σ.φ, respectively.</p><p>The relation Σ, e -→ Σ ′ , e ′ represents a single evaluation step from expression e, under the run-time environment Σ, to expression e ′ and run-time environment Σ ′ . We say that e reduces to e ′ in one step. We define such relation in terms of a structured operational semantics via evaluation contexts <ref type="bibr" target="#b13">[14]</ref>.</p><p>The reduction rules for the core simply-typed λ-calculus are standard and therefore omitted. We note that substitution ([e1/x] e2) is defined in the usual way: homomorphic on all operators and renaming bound names to avoid captures. Figure <ref type="figure" target="#fig_3">4</ref> presents the evaluation contexts and non-standard reduction rules for our language. These rules guarantee that programs written using our approach fulfill non-interference, i.e., confidential information is not leaked, and confinement, i.e., a computation cannot access data above the clearance.</p><p>The main contribution of our language are the primitives label, unlabel, and toLabeled. Rule (LAB) generates a labeled value if and only if the label is between the current label and clearance of the LIO computation and thus guaranteeing containment properties (see <ref type="bibr">Section 5)</ref>. Rule (UNLAB) provides a method for accessing the content e of a labeled value Lb l e in LIO computations. When the content of a labeled value is "retrieved" and used in a LIO computation, the current label is raised (</p><formula xml:id="formula_23">Σ ′ = Σ[lbl → l ′ ],</formula><p>where l ′ = Σ.lbl ⊔ l), capturing the fact that the remaining computation might depend on e. Rule (TOLAB) deserves some attention. We write -→ * for the reflexive and transitive closure of -→. Expression toLabeled l e is used to execute the provided LIO computation e until completion ( Σ, e -→ * Σ ′ , (v) LIO ) and wraps its result v into a labeled value with label l. Observe that the label l needs to be an upper bound on the current label for the evaluation of computation e (Σ ′ .lbl ⊑ l). Specifying label l is responsibility of the programmer. The reason for this is due to the fact that security labels are protected by the current  </p><formula xml:id="formula_24">::= [•] | Lb E e | E e | πi E | if E then e else e | return E | E &gt;&gt;= e | label E e | unlabel E | toLabeled E e | newRef E e | readRef E | writeRef E e | lowerClr E | labelOf E | labelOfRef E Σ, E[return v] -→ Σ, E[(v) LIO ] Σ, E[(v) LIO &gt;&gt;= e2] -→ Σ, E[e2 v] (LAB) Σ.lbl ⊑ l ⊑ Σ.clr Σ, E[label l e] -→ Σ, E[return (Lb l e)] (UNLAB) l ′ = Σ.lbl ⊔ l l ′ ⊑ Σ.clr Σ ′ = Σ[lbl → l ′ ] Σ, E[unlabel (Lb l e)] -→ Σ ′ , E[return e] (TOLAB) Σ.lbl ⊑ l ⊑ Σ.clr Σ, e -→ * Σ ′ , (v) LIO Σ ′ .lbl ⊑ l Σ ′′ = Σ ′ [lbl → Σ.lbl, clr → Σ.clr] Σ, E[toLabeled l e] -→ Σ ′′ , E[label l v] (NREF) Σ.lbl ⊑ l ⊑ Σ.clr Σ ′ = Σ.φ[a → Lb l e] Σ, E[newRef l e] -→ Σ ′ , E[return a] a fresh (RREF) Σ.φ(a) = Lb l e l ′ = Σ.lbl ⊔ l l ′ ⊑ Σ.clr Σ ′ = Σ[lbl → l ′ ] Σ, E[readRef a] -→ Σ ′ , E[return e] (WREF) Σ.φ(a) = Lb l e Σ.lbl ⊑ l ⊑ Σ.clr Σ ′ = Σ.φ[a → Lb l e ′ ] Σ, E[writeRef a e ′ ] -→ Σ ′ , E[return ()] (LWCLR) Σ.lbl ⊑ l ⊑ Σ.clr Σ ′ = Σ[clr → l] Σ, E[lowerClr l] -→ Σ ′ , E[return ()] (CLAB) l = Σ.lbl Σ, E[getLabel] -→ Σ, E[return l] (CCLR) l = Σ.clr Σ, E[getClearance] -→ Σ, E[return l] (GLAB) Σ, E[labelOf (Lb l e)] -→ Σ, E[l] (GLABR) e = Σ.φ(a) Σ, E[labelOfRef a] -→ Σ, E[labelOf e]</formula><p>label, effectively making them public information accessible to any computation within scope (see rules (GLAB) and (GLABR)). As a consequence, if toLabeled did not require an upper bound on the data to be observed within e, labels can be used to leak information. Recall that the current label and clearance of a given LIO computation can be changed dynamically. To illustrate this point, consider a computation whose current label is l0, taking two (confidential) labeled values as arguments, with respective labels l1 and l2 such that li ⊑ l0, i = 1, 2.</p><formula xml:id="formula_25">leak lV1 lV2 = do lV3 ← toLabeled' $ do v1 ← unlabel lV1 --Lcur = l 1 if v1 then return True else unlabel lV2 --Lcur = l 2 return (labelOf lV3)</formula><p>Therefore, if the returned value is l1 or l2 (remember that labels are public information), information is directly leaked! To close this channel, programmers should provide an upper bound of the current label obtained when e finishes computing. Since our approach is dynamic, flow-sensitive, and sound, this may require non-trivial, and possibly complicated, static analysis in order to automatically determine the label for each call of toLabeled <ref type="bibr" target="#b30">[31]</ref>.</p><p>By using big-step semantics instead of an evaluation context of the form toLabeled l E, rule (TOLAB) does not need to rely on the use of trusted primitives or a stack for (saving and) restoring the current label and clearance when executing toLabeled.</p><p>When creating a reference, newRef l e produces a labeled value that guards e with label l (Lb l e) and stores it in the memory store (Σ ′ = Σ.φ[a → Lb l e]). The result of this operation is the memory address a (return a). Observe that references are created only if the reference's label (l) is between the current label and clearance label of the LIO monad (Σ.lbl ⊑ l ⊑ Σ.clr). The restriction l ⊑ Σ.clr is to assure that programs cannot manipulate or access data beyond their clearance (see <ref type="bibr">Section 5)</ref>. Rule (RREF) obtains the content e of a labeled value Lb l e stored in the address a. This rule raises the current label to the security level l ′ (Σ ′ = Σ[lbl → l ′ ] where l ′ = Σ.lbl ⊔ l). As in the previous rule, (RREF) enforces that the result of reading a reference is below the clearance (l ′ ⊑ Σ.clr). Rule (WREF) updates the memory store with a new value for the reference (Σ ′ = Σ.φ[a → Lb l e ′ ]) as long as the label of the reference is above the current label and it does not exceed the clearance (Σ.lbl ⊑ l ⊑ Σ.clr). If considering Σ.lbl as a dynamic version of the pc the restriction that the label of the reference must be above the current label (Σ.lbl ⊑ l) is similar to the one imposed by <ref type="bibr" target="#b29">[30]</ref>.</p><p>Rule (LWCLR) allows a computation to lower the current clearance to l. This operation is particularly useful when trying to contain the access to some data as well as the effects produced by computations executed by toLabeled. Rules (CLAB) and (CCLR) obtain the current label and clearance from the run-time environment. Finally, rules (GLAB) and (GLABR) return the labels of labeled values and references. Observe that, regardless of the current label and clearance of the run-time environment, these two rules always succeed, effectively making labels public data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Soundness</head><p>In this section we show that LIO computations satisfy two security policies: non-interference and containment. Non-interference shows that secrets are not leaked, while containment establishes that certain piece of code cannot manipulate or have access to certain data. The latter policy is similar to the containment policies presented in <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b23">24]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Non-interference</head><p>As in <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b31">32]</ref>, we prove the non-interference property by using the technique of term erasure. Intuitively, data at security levels where the attacker cannot observe information can be safely rewritten to the syntax node •. For the rest of the paper, we assume that the attacker can observe data up to security level L. The syntactic term •, denoting an erased expression, may be associated to any type (recall Figure <ref type="figure" target="#fig_6">3</ref>). Function εL is responsible for performing the rewriting for data at security level not lower than L. In most of the cases, the erasure function is simply applied homomorphically (e.g., εL(if E then e else e ′ ) = if εL(E) then εL(e) else εL(e ′ )). In the case of data constructors it is simply the identity function. </p><formula xml:id="formula_26">(l) = l εL(a) = a εL(Lb l e) = Lb l • l ⊑ L Lb l εL(e) otherwise εL(Σ.φ) = {(x, εL(Σ.φ(x)) : x ∈ dom(Σ.φ)} εL(Σ) = Σ[φ → εL(Σ.φ)] εL( Σ, e ) = εL(Σ), • Σ.lbl ⊑ L εL(Σ), εL(e) otherwise</formula><p>The two interesting cases for this function are when εL is applied to a labeled value or a given configuration. In such cases, term erasing could indeed modify the behavior of the program. Figure <ref type="figure" target="#fig_5">5</ref> shows the definition of εL for several terms and configurations.</p><p>A labeled value is erased if the label assigned to it is above L (εL(Lb l e) = Lb l •, if l ⊑ L). Similarly, the computation performed in a certain configuration is erased if the current label is above</p><formula xml:id="formula_27">L (εL( Σ, e ) = εL(Σ), • if Σ.lbl ⊑ L).</formula><p>Following the definition of the erasure function, we introduce a new evaluation relation -→L as follows:</p><formula xml:id="formula_28">Σ, e -→ Σ ′ , e ′ Σ, e -→L εL( Σ ′ , e ′ )</formula><p>Expressions under this relationship are evaluated in the same way as before, with the exception that, after one evaluation step, the erasure function is applied to the resulting configuration, i.e., runtime environment and expression. In that manner, the relation -→L guarantees that confidential data, i.e., data not below level L, is erased as soon as it is created. We write -→ * L for the reflexive and transitive closure of -→L.</p><formula xml:id="formula_29">Σ, e -----→ * Σ ′ , e ′   ε L   ε L εL( Σ, e ) -----→ * L εL( Σ ′ , e ′ ) Figure 1. Simulation between -→ * and -→ * L .</formula><p>Most results that prove non-interference pursue the goal of establishing a relationship between -→ * and -→ * L through the erasure function, as highlighted in Figure <ref type="figure" target="#fig_1">1</ref>. Informally, the diagram establishes that erasing all secret data, i.e., data not below L, and then taking evaluation steps in -→L is the same as taking steps in -→ and then erasing all the secret values in the resulting configuration. Observe that if information from some level above L is leaked by e, then erasing all secret data and then taking evaluation steps in -→L might not be the same as taking steps in -→ and then erasing all the secret values in the resulting configuration.</p><p>For simplicity, we assume that the space address of the memory store is split into different security levels and that allocation is deterministic. In that manner, the address returned when creating a reference with level l depends only on the references with level l already in the store. These assumptions are valid in our language since, similar to traditional references in Haskell, we do not provide any mechanisms for deallocation or inspection of addresses in the API. However, when memory allocation is an observable channel, the library could be adapted in order to deal with non-opaque pointers <ref type="bibr" target="#b16">[17]</ref>.</p><p>We start by showing that the evaluation relationship -→ and -→L are deterministic. We note that e = e ′ means syntactic equality between expressions e and e ′ . Equality between run-time environments, written Σ = Σ ′ , is defined as the point-wise equality between mappings Σ and Σ ′ .</p><p>Proposition 1 (Determinacy of -→).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>◮ For any expression e and run-time environment Σ such that</head><p>Σ, e -→ Σ ′ , e ′′ , there is a unique term e ′ and unique evaluation context E such that e = E[e ′ ]. ◮ If Σ, e -→ Σ ′ , e ′ and Σ, e -→ Σ ′′ , e ′′ , then e ′ = e ′′ and Σ ′ = Σ ′′ . Proof. By induction on expressions and evaluation contexts. Proposition 2 (Determinacy of -→L). If Σ, e -→L Σ ′ , e ′ and Σ, e -→L Σ ′′ , e ′′ , then e ′ = e ′′ and Σ ′ = Σ ′′ . Proof. From Proposition 1 and definition of εL.</p><p>The following proposition shows that the erasure function is homomorphic to the application of evaluation contexts and substitution as well as that it is idempotent. The next lemma establishes a simulation between -→ and -→L for expressions that do not execute toLabeled.</p><p>Lemma 1 (Single-step simulation without toLabeled). If Γ ⊢ e : τ and Σ, e -→ Σ ′ , e ′ where toLabeled is not executed, then Γ ⊢ e ′ : τ and εL( Σ, e ) -→L εL( Σ ′ , e ′ ).</p><p>Proof. Subject reduction holds by showing that a reduction step does not change the types of references in the store Σ.φ and then applying induction on the typing derivations. The simulation holds by simple case analysis on e.</p><p>Using this lemma, we then show that the simulation is preserved when performing several evaluation steps.</p><p>Lemma 2 (Simulation for expressions not executing toLabeled). If Γ ⊢ e : τ , Σ, e -→ * Σ ′ , e ′ where there are no executions of toLabeled, then Γ ⊢ e ′ : τ and εL( Σ, e ) -→ * L εL( Σ ′ , e ′ ). Proof. By induction on -→ and applying Lemma 1.</p><p>The reason for highlighting the distinction between expressions executing toLabeled and those not executing it is due to the fact that the evaluation of toLabeled involves big-step semantics (recall rule (TOLAB) in Figure <ref type="figure" target="#fig_3">4</ref>). However, the next lemma shows the simulation between -→ * and -→ * L for any expression e, and it is proved by simple induction on the number of executed toLabeled.  We define L-equivalence between expressions. Intuitively, two expressions are L-equivalent if they are syntactically equal, modulo labeled values whose labels are above L. We use ≈L to represent L-equivalence for expressions. Figure <ref type="figure" target="#fig_8">6</ref> shows the definition for labeled values. Considering the simple lattice: L ⊑ M ⊑ H and an attacker at level L, it holds that Lb H 8 ≈L Lb H 9, but it does not hold that Lb L 2 ≈L Lb L 3 or Lb H 8 ≈L Lb M 8. Recall that labels are protected by the current label, and thus (usually) observable by an attacker -unlike the expressions they protect, labels must be the same even if they are above L. The rest of ≈L is defined as syntactic equality between constants (e.g., true ≈L true) or homomorphisms (e.g., if e then e1 else e2 ≈L if e ′ then e ′</p><p>1 else e ′ 2 if e ≈L e ′ , e1 ≈L e ′ 1 , and e2 ≈L e ′ 2 ). Since our language encompasses side-effecting expressions, it is also necessary to define L-equivalence between memory stores. Specifically, we say that two run-time environments are L-equivalent if an attacker at level L cannot distinguish them: Definition 2 (L-equivalence for stores).</p><formula xml:id="formula_30">l ⊑ L ∨ l ′ ⊑ L ∀a.Σ.φ(a) = Lb l e ≈L Σ ′ .φ(a) = Lb l ′ e ′ Σ.φ ≈L Σ ′ .φ</formula><p>Note that the L-equivalence ignores the store references with labels above L. Similarly, we define L-equivalence for configurations.</p><p>Definition 3 (L-equivalence for configurations).</p><p>e ≈L e ′ Σ.φ ≈L Σ ′ .φ</p><formula xml:id="formula_31">Σ.lbl = Σ ′ .lbl Σ.clr = Σ ′ .clr Σ.lbl ⊑ L Σ, e ≈L Σ ′ , e ′ Σ.φ ≈L Σ ′ .φ Σ.lbl ⊑ L Σ ′ .lbl ⊑ L Σ, e ≈L Σ ′ , e ′</formula><p>In the above definition, it is worth remarking that we do not require ≈L for expressions when the current label is not below L. This omission comes from the fact that e and e ′ would be reduced to • when applying our simulation between -→ * and -→ * L (recall Figure <ref type="figure" target="#fig_5">5</ref>).</p><p>The next theorem shows the non-interference policy. It essentially states that given two inputs with possibly secret information, the result of the computation is indistinguishable to an attacker. In other words, there is no information-flow from confidential data to outputs observable by the attacker.</p><p>Theorem 1 (Non-interference). Given a computation e (with no •, ( ) LIO , or Lb) where Γ ⊢ e : Labeled ℓ τ → LIO ℓ (Labeled ℓ τ ′ ), environments Σ1 and Σ2 where Σ1.φ = Σ2.φ = ∅, security label l, an attacker at level L such that l ⊑ L, then ∀e1e2.(Γ ⊢ ei : Labeled ℓ τ )i=1,2</p><formula xml:id="formula_32">∧ (ei = Lb l e ′ i )i=1,2 ∧ Σ1, e1 ≈L Σ2, e2 ∧ Σ1, e e1 -→ * Σ ′ 1 , (Lb l1 e ′′ 1 ) LIO ∧ Σ2, e e2 -→ * Σ ′ 2 , (Lb l2 e ′′ 2 ) LIO ⇒ Σ ′ 1 , Lb l1 e ′′ 1 ≈L Σ ′ 2 , Lb l2 e ′′<label>2</label></formula><p>Observe that even though we assume that the input labeled values e1 and e2 are observable by the attacker (l ⊑ L), they might contain confidential data. For instance, e1 could be of the form Lb l (Lb l ′ true) where l ′ ⊑ L.</p><p>Proof. The L-equivalence (and, thus, the proof) directly follows by Lemma 3 and determinacy of -→L.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Confinement</head><p>In this section we present the formal guarantees that LIO computations cannot modify data below their current label and manipulate information above their current clearance. These kind of properties are similar to the ones found in <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b23">24]</ref>.</p><p>We start by proving that the current label of a LIO computation does not decrease.</p><p>Proposition 4 (Monotonicity of the current label). If Γ ⊢ e : τ and Σ, e -→ * Σ ′ , e ′ , then Σ.lbl ⊑ Σ ′ .lbl.</p><p>Similarly, we show that the current clearance of a LIO computation never increases. Proposition 4 and 5 are crucial to assert that once a LIO computation reads confidential data, it cannot lower its current label to leak it. Similarly, a computation should not be able to arbitrarily increase its clearance; doing so would allow it to read any data with no access restrictions.</p><p>Before delving into the containment theorems, we first define a store modifier that removes all store elements with a label above a given label l:</p><formula xml:id="formula_33">(Σ.φ) ↓l = Σ.φ \ {(a, Lb l ′ e) : a ∈ dom (Σ.φ) ∧ l ⊑ l ′ } (Σ.φ) ↓l</formula><p>In other words, this retains all the labeled references with a label below l, usually the current label.</p><p>The first theorem states that LIO computations cannot create labeled values, new locations or modify memory cells below their current label (no-write down).</p><p>Theorem 2 (Containment imposed by the current label). Given labels l, lc, and lv, a computation e (with no •, ( ) LIO , or Lb) where Γ ⊢ e : Labeled ℓ τ → LIO ℓ (Labeled ℓ τ ), environment Σ[lbl → l, clr → lc] such that l ⊑ lc, and l ⊑ lv.</p><formula xml:id="formula_34">Γ ⊢ e1 : Labeled ℓ τ ∧ e1 = Lb lv e ′ 1 ∧ Σ, e e1 -→ * Σ ′ , (Lb lv e ′′ 1 ) LIO ⇒ (Σ.φ) ↓l = (Σ ′ .φ) ↓l ∧ e ′ 1 = e ′′<label>1</label></formula><p>Proof. The proof follows directly from Proposition 4, definition of the store modifier and induction on -→ * .</p><p>The theorem simply states that the computation cannot allocate or modify the store below l. Moreover the computation should only be able to return a labeled value below its current label that was provided as input, or by capture. Dual to Theorem 2, the next theorem captures the fact that LIO computations cannot compute on labeled values above their clearance. In other words, LIO computations cannot create, read, and write references or read and create contents for labeled values above the clearance (recall that references store labeled values). Again, we first define a store modifier; in this case, one that removes all store elements below a given clearance as follows:</p><formula xml:id="formula_35">(Σ.φ) ↑l = Σ.φ \ {(a, Lb l ′ e) : a ∈ dom (Σ.φ) ∧ l ′ ⊑ l} (Σ.φ) ↑l</formula><p>In other words, this retains all the labeled references with a label above l, usually the current clearance. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Related Work</head><p>Heintze and Riecke <ref type="bibr" target="#b17">[18]</ref> consider security for lambda-calculus where lambda-terms are explicitly annotated with security labels, for a type-system that guarantees non-interference. One of the key aspects of their work consists of an operator which raises the security annotation of a term in a similar manner to our raise of the current label when manipulating labeled values. Similar ideas of floating labels have been used by many operating systems, dating back to the High-Water-Mark security model <ref type="bibr" target="#b21">[22]</ref> of the ADEPT-50 in the late 1960s. Asbestos <ref type="bibr" target="#b12">[13]</ref> first combined floating labels with the Decentralized label model <ref type="bibr" target="#b27">[28]</ref>. Abadi et al. <ref type="bibr" target="#b0">[1]</ref> develop the dependency core calculus (DCC) based on a hierarchy of monads to guarantee non-interference. In their calculus, they define a monadic type that "protects" (the confidentiality of) side-effect-free values at different security levels. Though not a monad, our Labeled type similarly protects pure values at various security levels. To manipulate such values, DCC uses a non-standard typing rule for the bind operator; the essence of this operator, in a dynamic setting with side-effectful computations, is captured in our library through the interaction of of Labeled, unlabel, and LIO.</p><p>Tse and Zdancewic <ref type="bibr" target="#b35">[36]</ref> translate DCC to System F and show that non-interference can be stated using the parametricity theorem for System F. The authors also provide a Haskell implementation for a two-point lattice. Their implementation encodes each security level as an abstract data type constructed from functions and binding operations to compose computations with permitted flows. Since they consider the same non-standard features for the bind operation as in DCC, they provide as many definitions for bind as different type of values produced by it. Moreover, their implementation needs to be compiled with the flag -fallow-undecidable-instances, in GHC. Our work, in contrast, defines only one bind operation for LIO, without the need for such compiler extensions.</p><p>Harrison and Hook show how to implement an abstract operating system called separation kernel <ref type="bibr" target="#b15">[16]</ref>. Programs running under this multi-threading operating system satisfy non-interference. To achieve this, the authors rely on the state monad to represent threads, monad transformers to present parallel composition, and the resumption monad to achieve communication between threads. Non-interference is then enforced by the scheduler implementation, which only allow signaling threads at the same, or higher, security level as the thread that issued the signal. The authors use monads differently from us; their goal is to construct secure kernels rather than provide information-flow security as a library. Our library is simpler and more suitable for writing sequential programs in Haskell. Extending our library to include concurrency is stated as a future work.</p><p>Crary et al. <ref type="bibr" target="#b7">[8]</ref> design a monadic calculus for non-interference for programs with mutable state. Similar to our work, their language distinguishes between term and expressions, where terms are pure and expressions are (possibly) effectful computations. Their calculus mainly tracks information flow by statically approximating the security levels of effects produced by expressions. Compared to their work, we only need to make approximations of the side-effects of a given computation when using toLabeled; the state of LIO keeps track of the dynamic security level upper bound of observed data. Overall, our dynamic approach is more flexible and permissive than their proposed type-system.</p><p>Pottier and Simonet <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b34">35]</ref> designed FlowCaml, a compiler to enforce non-interference for OCaml programs. Rather than implementing a compiler from scratch, and more similar to our approach, the seminal work by Li and Zdancewic <ref type="bibr" target="#b24">[25]</ref> presents an implementation of information-flow security as a library, in Haskell, using a generalization of monads called Arrows <ref type="bibr" target="#b18">[19]</ref>. Extending their work, Tsai et al. <ref type="bibr" target="#b6">[7]</ref> further consider side-effects and concurrency. Contributing to library-based approaches, Russo et al. <ref type="bibr" target="#b31">[32]</ref> eliminate the need for Arrows by showing an IFC library based solely on monads. Their library defines monadic types to track informationflow in pure and side-effectful computations. Compared to our dynamic IFC library, Russo et al.'s library is slightly less permissive and leverages Haskell's type-system to statically enforce noninterference. However, we note that our library has similar (though dynamic) functions provided by their SecIO library; similar to unlabel, they provide a function that maps pure labeled values into side-effectful computations; similar to toLabeled, they provide a function that allows reading/writing secret files into computations related to public data.</p><p>Recently, Morgenstern et al. <ref type="bibr" target="#b26">[27]</ref> encoded an authorizationand IFC-aware programming language in Agda. Their encoding, however, does not consider computations with side-effects. More closely related, Devriese and Piessens <ref type="bibr" target="#b11">[12]</ref> used monad transformers and parametrized monads <ref type="bibr" target="#b2">[3]</ref> to enforce non-interference, both dynamically and statically. However, their work focuses on modularity (separating IFC enforcement from underlying user API), using type-class level tricks that make it difficult to understand errors triggered by insecurities. Moreover, compared to our work, where programmers write standard Haskell code, their work requires one to firstly encode programs as values of a specific type.</p><p>Compared to other language-based works, LIO uses the notion of clearance. Bell and La Padula <ref type="bibr" target="#b4">[5]</ref> formalized clearance as a bound on the current label of a particular users' processes. In the 1980s, clearance became a requirement for high-assurance secure systems purchased by the US Department of Defense <ref type="bibr" target="#b10">[11]</ref>. More recently, HiStar <ref type="bibr" target="#b38">[39]</ref> re-cast clearance as a bound on the label of any resource created by the process (where raising a process's label is but one means of creating a something with a higher label). We adopt HiStar's more stringent notion of clearance, which prevents software from copying data it cannot read and facilitates bounding the time during which possibly untrustworthy software can exploit covert channels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion</head><p>We propose a new design point for IFC systems in which most values in lexical scope are protected by a single, mutable, current label, yet one can also encapsulate and pass around the results of computations with different labels. Unlike other language-based work, our model provides a notion of clearance that imposes an upper bound on the program label, thus providing a form of discretionary access control on portions of the code.</p><p>We prove information flow and integrity properties of our design and describe LIO, an implementation of the new model in Haskell. LIO, which can be implemented entirely as a library (based on type safety), demonstrates both the applicability and simplicity of the approach. Our non-interference theorem proves the conventional property that lower-level results do not depend on higher-level inputs -the label system prevents inappropriate flow of information. We also prove containment theorems that show the effect of clearance on the behavior of code. In effect, lowering the clearance imposes a discretionary form of access control by preventing subsequent code (within that scope) from accessing higher-level information.</p><p>As an illustration of the benefits and expressive power of this system, we describe a reviewing system that uses LIO labels to manage integrity and confidentiality in an environment where users and labels are added dynamically. Although we have use LIO for the λChair API and even built a relatively large web-framework that securely integrates untrusted third-party applications, we believe that changes in the constructs are likely to occur as the lan-guage matures. This further supports our library-based approach to language-based security.</p><p>An interesting future work consists on extending our library to handle concurrency. Enforcement mechanisms for sequential programs do not generalize naturally to multithreaded programs. In this light, it is hardly surprising that Jif <ref type="bibr" target="#b28">[29]</ref>, the mainstream IFC compiler, lack support for multithreading. Due to the monadic structure of LIO programs, we believe it is possible to extend our library to consider concurrency, that addresses termination <ref type="bibr" target="#b1">[2]</ref> and internal-timing leaks <ref type="bibr" target="#b37">[38]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>:</head><label></label><figDesc>◮ addPaper : Paper →RevLIO Id Given a paper, it creates a new review entry for the paper and return the paper id. Internally, addPaper uses a function similar to addReview of Section 2. ◮ addUser : : Name →Password →RevLIO () Given a unique user name and password, it adds the new user. ◮ addAssignment : : Name → Id → RevLIO ()</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1</head><label>1</label><figDesc>Figure1An example of code using λChair API.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2</head><label>2</label><figDesc>Figure 2 Formal syntax for terms, expressions, and types. Label: l Address: a Term: v ::= true | false | () | l | a | x | λx.e | (e, e) | fix e | Lb v e | (e) LIO | • Expression: e ::= v | e e | πi e | if e then e else e | let x = e in e | return e | e &gt;&gt;= e | label e e | unlabel e | toLabeled e e | newRef e e | readRef e | writeRef e e | lowerClr e | getLabel | getClearance | labelOf e | labelOfRef e Type: τ ::= Bool | () | τ → τ | (τ, τ ) | ℓ | Labeled ℓ τ | LIO ℓ τ | Ref ℓ τ Store: φ :Address → Labeled ℓ τ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4</head><label>4</label><figDesc>Figure 4 Semantics for non-standard constructs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>E</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5</head><label>5</label><figDesc>Figure 5 Erasure function for several terms, memory store and configurations. εL(l) = l εL(a) = a</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Proposition 3 (</head><label>3</label><figDesc>Properties of erasure function).1. εL(E[e]) = εL(E)[εL(e)] 2. εL([e2/x]e1) = [εL(e2)/x]εL(e1) 3. εL(εL(e)) = εL(e) 4. εL(εL(E)) = εL(E) 5. εL(εL(Σ)) = εL(Σ) 6. εL(εL( Σ, e )) = εL( Σ, e ) Proof.From the definition of εL and by induction on expressions and evaluation contexts.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Lemma 3 (</head><label>3</label><figDesc>Simulation). If Γ ⊢ e : τ and Σ, e -→ * Σ ′ , e ′ then εL( Σ, e ) -→ * L εL( Σ ′ , e ′ ). Proof. By induction on the number of executed toLabeled and applying Lemma 2 for the base case.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 6 L</head><label>6</label><figDesc>Figure 6 L-equivalence for expressions. e ≈L e ′ l ⊑ L Lb l e ≈L Lb l e ′</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Proposition 5 (</head><label>5</label><figDesc>Monotonicity of the current clearance). If Γ ⊢ e : τ and Σ, e -→ * Σ ′ , e ′ , then Σ ′ .clr ⊑ Σ.clr.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Theorem 3 (</head><label>3</label><figDesc>Containment imposed by clearance). Given labels l, lc, and lv, a computation e (with no •, ( ) LIO , or Lb) whereΓ ⊢ e : Labeled ℓ τ → LIO ℓ (Labeled ℓ τ ), environment Σ[lbl → l, clr → lc] such that l ⊑ lc and lv ⊑ lc, Γ ⊢ e1 : Labeled ℓ τ ∧ e1 = Lb lv e ′ 1 ∧ Σ, e e1 -→ * Σ ′ , (Lb lv e ′′ 1 ) LIO ⇒ (Σ.φ) ↑lc = (Σ ′ .φ) ↑lc ∧ e ′ 1 = e ′′1Proof. Directly from Proposition 5, definition of the store modifier and induction on -→ * .</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>For clarity, we use a call-by-name instead of call-by-need calculus; extension to the latter is straight forward, as shown in<ref type="bibr" target="#b22">[23]</ref>. curity labels. Type Labeled ℓ τ describes labeled values of type τ where the label is of type ℓ. Type LIO ℓ τ represents monadic LIO computations, with a result type τ and the security labels of type ℓ. Type Ref ℓ τ describes labeled references, with labels of type ℓ, to values of type τ . Figure 3 Typing rules for terms. ⊢ l : ℓ Γ(a) = Labeled ℓ τ Γ ⊢ a : Ref ℓ τ</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank Alex Aiken and the anonymous reviewers for their insightful comments. This work was funded by DARPA (CRASH and PROCEED), NSF (including a Cybertrust award and the TRUST Center), the Air Force Office of Scientific Research, the Office of Naval Research, and the Swedish research agency VR.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A Core Calculus of Dependency</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Heintze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Riecke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Symp. on Principles of Programming Languages</title>
		<meeting>ACM Symp. on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1999-01">Jan. 1999</date>
			<biblScope unit="page" from="147" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Terminationinsensitive noninterference leaks more than just a bit</title>
		<author>
			<persName><forename type="first">A</forename><surname>Askarov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hunt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sabelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sands</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 13th European Symp. on Research in Computer Security</title>
		<meeting>of the 13th European Symp. on Research in Computer Security</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="333" to="348" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Parameterised notions of computation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Atkey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conor McBride and Tarmo Uustalu. Electronic Workshops in Computing</title>
		<imprint>
			<publisher>British Computer Society</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="31" to="45" />
		</imprint>
	</monogr>
	<note>Workshop on mathematically structured functional programming</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Stack-based access control and secure information flow</title>
		<author>
			<persName><forename type="first">A</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Naumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Functional Programming</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">02</biblScope>
			<biblScope unit="page" from="131" to="177" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Secure computer system: Unified exposition and multics interpretation</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Bell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">L</forename><surname>Padula</surname></persName>
		</author>
		<idno>MTR-2997</idno>
	</analytic>
	<monogr>
		<title level="j">Rev. 1, MITRE Corp</title>
		<imprint>
			<date type="published" when="1976-03">March 1976</date>
			<pubPlace>Bedford, MA</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Integrity considerations for secure computer systems</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">J</forename><surname>Biba</surname></persName>
		</author>
		<idno>ESD- TR-76-372</idno>
		<imprint>
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">A library for secure multithreaded information flow in Haskell</title>
		<author>
			<persName><forename type="first">T</forename><surname>Tsai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Russo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hughes</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007-07">July 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A monadic analysis of information flow security with mutable state</title>
		<author>
			<persName><forename type="first">K</forename><surname>Crary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kliger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pfenning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Functional Programming</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="249" to="291" />
			<date type="published" when="2005-03">March 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A lattice model of secure information flow</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Denning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Communications of the ACM</title>
		<imprint>
			<date type="published" when="1976-05">May 1976</date>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="236" to="243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Certification of programs for secure information flow</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Denning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Denning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="504" to="513" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Trusted Computer System Evaluation Criteria (Orange Book)</title>
		<imprint>
			<date type="published" when="1985-12">December 1985</date>
		</imprint>
	</monogr>
	<note>Department of Defense. DoD 5200.28-STD edition</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Information flow enforcement in monadic libraries</title>
		<author>
			<persName><forename type="first">D</forename><surname>Devriese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Piessens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 7th ACM SIGPLAN Workshop on Types in Language Design and Implementation</title>
		<meeting>of the 7th ACM SIGPLAN Workshop on Types in Language Design and Implementation<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Labels and event processes in the Asbestos operating system</title>
		<author>
			<persName><forename type="first">P</forename><surname>Efstathopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vandebogart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Frey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Ziegler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kohler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mazières</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005-10">October 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The theory and practice of first-class prompts</title>
		<author>
			<persName><forename type="first">M</forename><surname>Felleisen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 15th ACM SIGPLAN-SIGACT Symp. on Principles of programming languages</title>
		<meeting>of the 15th ACM SIGPLAN-SIGACT Symp. on Principles of programming languages</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="180" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Security policies and security models</title>
		<author>
			<persName><forename type="first">J</forename><surname>Goguen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1982-04">April 1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Achieving information flow security through precise control of effects</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">L</forename><surname>Harrison</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">18th IEEE Computer Security Foundations Workshop</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="16" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Noninterference in the presence of nonopaque pointers</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hedin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sands</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 19th IEEE Computer Security Foundations Workshop</title>
		<meeting>of the 19th IEEE Computer Security Foundations Workshop</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The SLam calculus: programming with secrecy and integrity</title>
		<author>
			<persName><forename type="first">N</forename><surname>Heintze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Riecke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Symp. on Principles of Programming Languages</title>
		<meeting>ACM Symp. on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1998-01">Jan. 1998</date>
			<biblScope unit="page" from="365" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Generalising monads to arrows</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hughes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="67" to="111" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">On flow-sensitive security types</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hunt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sands</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference record of the 33rd ACM SIGPLAN-SIGACT Symp. on Principles of programming languages, POPL &apos;06</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="79" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Information flow control for standard OS abstractions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Krohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yip</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Brodsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Cliffer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kohler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007-10">October 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Formal models for computer security</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Landwehr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computing Survels</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="247" to="278" />
			<date type="published" when="1981-09">September 1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A natural semantics for lazy evaluation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Launchbury</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 20th ACM SIGPLAN-SIGACT Symp. on Principles of programming languages</title>
		<meeting>of the 20th ACM SIGPLAN-SIGACT Symp. on Principles of programming languages</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="144" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Security properties of typed applets</title>
		<author>
			<persName><forename type="first">X</forename><surname>Leroy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Rouaix</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 25th ACM SIGPLAN-SIGACT Symp. on Principles of programming languages</title>
		<meeting>of the 25th ACM SIGPLAN-SIGACT Symp. on Principles of programming languages</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="391" to="403" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Encoding Information Flow in Haskell</title>
		<author>
			<persName><forename type="first">P</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zdancewic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CSFW &apos;06: Proc. of the 19th IEEE Workshop on Computer Security Foundations</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Arrows for secure information flow</title>
		<author>
			<persName><forename type="first">P</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zdancewic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">411</biblScope>
			<biblScope unit="issue">19</biblScope>
			<biblScope unit="page" from="1974" to="1994" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Security-typed programming within dependently typed programming</title>
		<author>
			<persName><forename type="first">J</forename><surname>Morgenstern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Licata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 15th ACM SIG-PLAN International Conference on Functional Programming, ICFP &apos;10</title>
		<meeting>of the 15th ACM SIG-PLAN International Conference on Functional Programming, ICFP &apos;10</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A decentralized model for information flow control</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 16th ACM Symp. on Operating Systems Principles</title>
		<meeting>of the 16th ACM Symp. on Operating Systems Principles</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="129" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Protecting privacy using the decentralized label model</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="410" to="442" />
			<date type="published" when="2000-10">October 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Information flow inference for ML</title>
		<author>
			<persName><forename type="first">F</forename><surname>Pottier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Simonet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Symp. on Principles of Programming Languages</title>
		<meeting>ACM Symp. on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="2002-01">Jan. 2002</date>
			<biblScope unit="page" from="319" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Dynamic vs. static flow-sensitive security analysis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Russo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sabelfeld</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 2010 23rd IEEE Computer Security Foundations Symp., CSF &apos;10</title>
		<meeting>of the 2010 23rd IEEE Computer Security Foundations Symp., CSF &apos;10</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="186" to="199" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">A library for light-weight information-flow security in Haskell</title>
		<author>
			<persName><forename type="first">A</forename><surname>Russo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Claessen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hughes</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Language-based information-flow security</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sabelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in Communications</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2003-01">January 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">From dynamic to static and back: Riding the roller coaster of information-flow control research</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sabelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Russo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Andrei Ershov International Conference on Perspectives of System Informatics</title>
		<meeting>Andrei Ershov International Conference on Perspectives of System Informatics</meeting>
		<imprint>
			<date type="published" when="2009-06">June 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">The Flow Caml system</title>
		<author>
			<persName><forename type="first">V</forename><surname>Simonet</surname></persName>
		</author>
		<ptr target="http://cristal.inria.fr/~simonet/soft/flowcaml/" />
	</analytic>
	<monogr>
		<title level="m">Software release</title>
		<imprint>
			<date type="published" when="2003-07">July 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Translating dependency into parametricity</title>
		<author>
			<persName><forename type="first">S</forename><surname>Tse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zdancewic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Ninth ACM SIGPLAN International Conference on Functional Programming</title>
		<meeting>of the Ninth ACM SIGPLAN International Conference on Functional Programming</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Labels and event processes in the Asbestos operating system</title>
		<author>
			<persName><forename type="first">S</forename><surname>Vandebogart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Efstathopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kohler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Frey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Ziegler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mazières</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">A version appeared in Proc. of the 20th ACM Symp. on Operating System Principles</title>
		<imprint>
			<date type="published" when="2005">December 2007. 2005</date>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Probabilistic noninterference in a concurrent language</title>
		<author>
			<persName><forename type="first">D</forename><surname>Volpano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Computer Security</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<date type="published" when="1999-11">Nov. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Making information flow explicit in HiStar</title>
		<author>
			<persName><forename type="first">N</forename><surname>Zeldovich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Boyd-Wickizer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kohler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mazières</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006-11">November 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Securing distributed systems with information flow control</title>
		<author>
			<persName><forename type="first">N</forename><surname>Zeldovich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Boyd-Wickizer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mazières</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008-04">April 2008</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
