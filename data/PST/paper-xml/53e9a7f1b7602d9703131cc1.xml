<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fundamentals of Deductive Program Synthesis</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Zohar</forename><surname>Manna</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Richard</forename><surname>Waldinger</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Computer and Systems Sciences</orgName>
								<address>
									<addrLine>Springer-Verlag</addrLine>
									<postCode>1991</postCode>
									<settlement>Berlin</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">Stanford University</orgName>
								<address>
									<postCode>94305</postCode>
									<settlement>Palo Alto</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">Weizmann Institute of Science</orgName>
								<address>
									<settlement>Rehovot</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department">Artificial Intelligence Center</orgName>
								<orgName type="institution">SRI International</orgName>
								<address>
									<postCode>94025</postCode>
									<settlement>Menlo Park</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">Stanford University</orgName>
								<address>
									<postCode>94305</postCode>
									<settlement>Palo Alto</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Fundamentals of Deductive Program Synthesis</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">850489BF10D2A925D176FE191EF939B3</idno>
					<note type="submission">received May 3, 1991; revised February 3, 1992. Recom-</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:32+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Automated deduction</term>
					<term>deductive tableau</term>
					<term>formal methods</term>
					<term>program synthesis</term>
					<term>program transformation</term>
					<term>specifications</term>
					<term>theorem proving</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>An informal tutorial is presented for program synthesis, with an emphasis on deductive methods. According to this approach, to construct a program meeting a given specification, we prove the existence of an object meeting the specified conditions. The proof is restricted to be sufficiently constructive, in the sense that, in establishing the existence of the desired output, the proof is forced to indicate a computational method for finding it. That method becomes the basis for a program that can be extracted from the proof. The exposition is based on the deductive-tableau system, a theorem-proving framework particularly suitable for program synthesis. The system includes a nonclausal resolution rule, facilities for reasoning about equality, and a well-founded induction rule.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>HIS is an introduction to program synthesis, the deriva-T tion of a program to meet a given specification. It focuses on the deductive approach, in which the derivation task is regarded as a problem of proving a mathematical theorem.</p><p>Let us outline this approach in very general terms. We here construct only applicative (functional) programs. We are given a specification that describes a relation between the input and output of the desired program. The specification does not necessarily suggest any method for computing the output. To construct a program that meets the specification, we prove the existence, for any input object, of an output object that satisfies the specified conditions. The proof is conducted in a background theory that expresses the known properties of the subject domain and describes the primitives of the programming language. The proof is restricted to be sufficiently constructive so that, to establish the existence of a satisfactory output object, it is forced to indicate a computational method for finding one. That method becomes the basis for a program that can be extracted from the proof.</p><p>In principle, many theorem-proving methods can be adapted for program synthesis. We have developed a proof system, called the deductive tableau, that is specifically intended for this purpose.</p><p>In this paper, we begin by defining program synthesis and relating it to other software development technology. We then introduce the deductive-tableau proof system and show how to extract programs from tableau proofs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Specifications</head><p>Program synthesis begins with a specification; in our case, this is a representation of the relationship between the input and output. A specification should be a description of the purpose or expected behavior of the desired program; ideally, it is close to the intentions of the users of the system. A good specification is clear and readable; we do not care if it describes an efficient computation, or indeed any computation at all. A program, on the other hand, is primarily a description of a computation, preferably an efficient one.</p><p>While many languages have been proposed for specification, we have settled on logic in our own work, because it is quite general and appropriate for deductive methods. If other languages are more appropriate for particular subject domains, it is plausible that they be translated into logic.</p><p>Let us give logical specifications for some familiar programs.</p><p>Example (Sorting Specification) Suppose we would like our programs to sort a list of numbers. Then we may be give the specification:</p><p>This specification is presented in a background theory of lists of numbers. For a given input object, the list 1, the program must return an output object, the list z , satisfying the condition perm(1, z ) , i.e., that z is a permutation of I , and the condition ord(z), i.e., that z is in nondecreasing order. The background theory provides the meaning for the constructs perm and ord. 0 Note that the specification provides a clear statement of the purpose of a sorting program, but does not describe how we want the list to be sorted. A sorting program itself, such as quicksort or mergesort, does describe how the computation is to be performed, but does not state the purpose of the program.</p><p>Example (Square-Root Specification) Suppose we want a program to find a rational approximation to the square root of a nonnegative rational; then we may give Here, we are given the nonnegative rational r and positive rational error tolerance E as inputs. Our desired output z is less than or equal to fi; that is, z2 5 r , but z + E is strictly greater than fi; that is, r &lt; ( z + E ) ~. In other words, fi lies in the half-open interval [z, z + E): Z Our background theory is that of the nonnegative rationals. U</p><p>In general, we shall be dealing with specifications of the form f ( a ) f i n d z such that Q [ a , z ]   The theorem corresponding to this specification is <ref type="bibr">4.</ref> In other words, for every input a, there exists an output z that satisfies the input-output relation Q <ref type="bibr">[ a , z ]</ref> . The proof is restricted to be sufficiently constructive to indicate a method for finding z in terms of a. That method is expressed by a single term t[a], which can be extracted from the proof. The term indicates which substitutions were made for z to allow the proof to go through. The program we produce is then f ( a ) +I.</p><formula xml:id="formula_0">(V'a)(3z)Q[a,</formula><p>We describe the method as if there were only one input and output, but in fact we can have several of each. If there is more than one output, we define a separate function for each. In the following example, there are two outputs.</p><p>where Q[a, z ] is a sentence of the background theory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Deductive Sofhvare Technologies</head><p>Program synthesis is one of several methods to assist in software development that is amenable to deductive techniques. Here, we mention Some of the other deductive softwaredevelopment methods, with representative references:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example (Front,Lasl Derivation</head><p>In the theory of finite strings, we would like to construct a program to find, for a given nonempty string, s, two outputs: the last character l a d s 1 of s. and the string front(s) of all Logic Programming. Executing a program expressed in logic <ref type="bibr" target="#b20">[20]</ref>. Testing. Exhibiting inputs that a program to fail to meet its specification <ref type="bibr" target="#b38">[42]</ref>. Modification. Altering a given program to reflect but the last character of s. For example, if s is the string BADA, f r o n t ( s ) is the string BAD and last(s) is the character A.</p><p>The program may be specified as In other words, s is to be decomposed into the concatenation z1 * z2 of two strings, z1 and z2, where z2 consists of a single character. Here, A is the empty string. Note that characters are regarded as strings.</p><p>The theorem corresponding to the specification is changes in its specification or environment <ref type="bibr" target="#b9">[9]</ref>. In a somewhat different category, we may consider a variety of knowledge-based software development methods (e.g., [40]) which rely on imitating the techniques of the experienced programmer. Automated deduction is exploited here in an auxiliary role; the programming process is not regarded as a task of proving a theorem, but as a task of transformation with many deductive subtasks.</p><p>Many researchers in formal methods for software development (e.g., <ref type="bibr">[lo]</ref>) do regard programming as primarily a deductive process, but are not at all concerned with automating the task; rather, they intend to provide intellectual tools for the programmer.</p><p>These methods all rely on deductive techniques, and several of them are less ambitious than full program synthesis. By developing more powerful theorom-proving techniques that are specialized to software-engineering application, we can make progress in several of these areas at once. The proof is restricted to be sufficiently constructive to indicate a method for finding z1 and z2. In this case, the program we shall extract from the proof is i f char(s) else head <ref type="bibr">(s)</ref> .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>front (tail(s)) f r o n t ( s )</head><p>then</p><formula xml:id="formula_1">A if char(s)</formula><p>else last (tail(s)).</p><p>Here, head(s) and taiZ(s) are, respectively, the first character and the string of all but the first character of the nonempty string s. Also, char(s) is true i f s consists of a single character.</p><p>If c is a character and s is a string, the prefix function c . s yields the result of prefixing c to s. Thus c . s is the same as { { l a s t ( s ) e then s c * s, but c . s is a basic function defined only for a character and a string. The concatenation function SI * s2 is defined in terms of the prefix function, for any two strings s1 and s2. 0</p><p>The structure of the proof of the theorem determines the structure of the program we extract. In particular, a case analysis in the proof corresponds to the formation of a conditional or test in the program. The use of the principle of mathematical induction in the proof coincides with the appearance of recursion or other repetitive constructs in the program. If the proof requires some lemmas, the program will invoke some auxiliary subprograms. Of course, different proofs of the theorem may lead to different programs, some of which may be preferable to others.</p><p>The phrasing of a specification as a theorem is quite straightforward. If a proof is sufficiently constructive, the extraction of the program is purely mechanical. Thus the main problem of deductive program synthesis is finding a sufficiently constructive proof of the theorem. We now turn our attention to the field of theorem proving, or automated deduction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Theorem Proving</head><p>We may distinguish between decision procedures, which guarantee success at proving theorems within a particular class, and heuristic methods, whose success is not guaranteed. We may also distinguish between automatic systems, which act without human intervention, and interactive systems, which require it.</p><p>The theories of interest here, such as those of the nonnegative integers, strings, and trees, are undecidable; no decision procedures exist. We know of no way of restricting the specification or programming language to ensure the successful completion of a proof without also restricting ourselves to a trivial class of specifications and programs. We assume then that our theorem prover will employ heuristic methods or rely on human guidance-probably both.</p><p>We have distinguished between automatic and interactive systems, but this distinction is not sharp. Implementers of interactive systems introduce automatic features to reduce the burden on the user. At the same time, implementers of automatic systems introduce interactive controls so the user can assist the system to discover proofs that are too difficult to be found automatically.</p><p>Although interactive systems are amenable to gradual automation, most of them are intended to help the user check and flesh out a proof already outlined by hand, rather than to discover a new proof. The logical frameworks embedded in the automatic systems are more conducive to proof discovery.</p><p>The emphasis of this paper, however, is on neither the heuristic aspects of theorem proving nor on the design of interactive mechanisms, but rather on the development of a logical framework sufficiently powerful to facilitate the discovery and succinct presentation of nontrivial derivation proofs.</p><p>Let us consider some of the theorem-proving systems that have already been developed to see how appropriate they are for our purpose. We discuss some automatic and some interactive systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>We may classify automatic theorem provers according to</head><p>Predicate Logic with Equality. Much work has exploited the resolution <ref type="bibr" target="#b32">[36]</ref> and paramodulation <ref type="bibr" target="#b42">[46]</ref> inference rules for these theories. Theorem provers based on these ideas, such as those developed at the Argonne National Laboratory [21], regularly settle open questions in mathematics and logic [47], admittedly in areas in which human intuition is weak, such as combinatory logic and equivalential calculus. Recent theorem-proving systems for predicate logic with equality have employed termrewriting systems [19] and connection methods [l], <ref type="bibr">[2]</ref>, rather than resolution and paramodulation, as the primary inference technique.</p><p>A separate body of work focuses on proofs requiring the principle of mathematical induction. The Boyer-Moore system [5] has been motivated by and applied to large problems in program verification, but has also been applied to the interactive reconstruction of large proofs in mathematics and logic, such as the Godel Incompleteness theorem <ref type="bibr" target="#b37">[41]</ref>. All of this work is relevant to program synthesis, yet it is difficult to find an existing system with all the features we need. We require the ability to prove theorems involving the quantifiers and connectives of first-order logic and the mathematical-induction principle. The Argonne systems, for example, do well with pure predicate logic, but have no facilities for inductive proofs. The Boyer-Moore system, which specializes in proof by induction, does not prove theorems with existential quantifiers.</p><p>Many of the interactive systems have grown out of LCF [14], which was based on Scott's "Logic of Computable Functions." Although these systems are under user control, they provide the capability to encode commonly repeated patterns of inference as tactics. The system Isabelle [34] arises from LCF, but is generic; that is, it allows us to describe a new logic, then prove theorems in that logic (cf. <ref type="bibr" target="#b13">[13]</ref>).</p><p>Of particular relevance to program synthesis is the development of interactive systems to prove theorems in constructive logics. The Nuprl system [7] (cf. [8], <ref type="bibr" target="#b33">[37]</ref>, <ref type="bibr" target="#b17">[17]</ref>) is based on Martin-Liif's constructive logic [30], [33] and has been applied to problems in program derivation as well as mathematics.</p><p>Although a derivation proof must be sufficiently constructive to allow us to extract a program, it does not need to be carried out in a constructive logic. Typically, most of a derivation proof has no bearing on the program we extract; it deals with showing that a program fragment extracted from some other part of the proof satisfies some additional conditions. Since many intuitively natural steps are not constructive, it is too constraining to carry out the entire derivation proof in a constructive logic. In our treatment, we adopt a classical logic, restricting it to be constructive only when necessary.</p><p>Most theorem-proving systems can be adapted to program synthesis and other software-engineering applications. The deductive framework we employ in this paper is a hybrid; it incorporates ideas from resolution and inductive theorem the logical theories on which they focus:</p><p>Theories with Znduction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>rl-</head><p>proving, and is intended for both interactive and automatic implementation. An interactive synthesis system, based on the theorem prover described in <ref type="bibr" target="#b6">[6]</ref>, has been implemented.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">PRELIMINARIES</head><p>In this section we introduce some formal preliminaries. We are a bit brisk here; the section may be skimmed by those familiar with these notions. Those wishing a more detailed explanation may refer to <ref type="bibr">[25]</ref> and [29].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Language</head><p>We first define the expressions of our language, which consist of the terms and the sentences.</p><p>The terms include the constants a, b, c, . . . and the variables U , U , w, . . . . Terms may be constructed by the repeated application of function symbols f , g, h, . . . to other terms. For example, f(a, g(a, x)) is a term. Also, if 3 is a sentence and s and t are terms, the conditional (if F then s else t ) is a term; we call the if-then-else operator a term constructor. Atomic sentences (or atoms) are constructed by applying predicate symbols p , y, T , . . . to terms. For example, p(u, f(a, g(a, x))) is an atomic sentence. We allow both prefix and infix notations for function and predicate symbols. We include the equality symbol = as a predicate symbol.</p><p>Sentences include the truth symbols true and false and the atomic sentences; they may be constructed by the repeated application of the connectives A, V , 1, .. . and the quantifiers (Vx) and (32) to other sentences. We use the notation ifthen for implication in place of the conventional arrow or horseshoe. We include a conditional connective if -thenelse; in other words, if 3 , G , and l-l are sentences then (if 3 then 0 else 'FI) is also a sentence. We rely on context to distinguish between the conditional connective and conditional term constructor.</p><p>A closed expression contains no free (unquantified) variables. A ground expression contains no variables at all. A herbrand expression is ground and contains neither connectives, term constructors nor equality symbols; thus g(a) is a herbrand term, and p ( a , f(a, b ) ) is a herbrand atom.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Interpretation and Truth</head><p>The truth of a sentence is defined only with respect to a particular interpretation. Intuitively speaking, we may think of an interpretation as a situation or case. We adopt the Herbrand notion and define an interpretation as a finite or infinite set of herbrand atoms. Informally, we think of the elements of the interpretation as a complete list of the herbrand atoms that are true in the corresponding situation. The truth-value of any closed sentence with respect to the interpretation is determined by the recursive application of the following semantic rules:</p><formula xml:id="formula_2">A herbrand atom P is true under an interpretation Z if P E 2.</formula><p>If a sentence is not closed, we do not define its truthvalue. Thus we do not say whether p(s) is true under { p ( a ) } . Henceforth in this section we speak only of closed sentences.</p><p>A closed sentence (3 A 0 ) is true under 1 if 3 and 0 are both true under Z; similarly for the other connectives.  belongs to the latter interpretation, but q(b,a) does not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A closed sentence (3x</head><p>In general, if a closed sentence s = t is true under 2, we shall also say that s = t under Z or that s and t are equal under Z. Henceforth we will often say "sentence" when we mean "closed sentence".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Models and Theories</head><p>An interpretation Z is a model for a finite or infinite set of (closed) sentences S if every sentence in S is true under 2. Thus the interpretations { p ( a ) } and { p ( b ) } are models for the set of sentences {(3x)p(x), p ( a ) V p ( b ) } , but the interpretation { p ( b ) } is not a model for the set of sentences A set of sentences S implies a.sentence -f if 3 is true under every model for S. For example, the set { p ( a ) } implies the sentence (3x)p(x). The theory TH defined by a set of sentences S is the set of all closed sentences implied by S; this is also called the deductive closure of S. We say that the sentences belonging to TH are valid in the theory. We call S the set of axioms for the theory TH.</p><p>The valid sentences of a theory are true under every model for the theory. The contradictory sentences of the theory are defined to be those that are false under every model for the theory. A sentence 3 is contradictory in the theory if and only if its negation 1 3 is valid in the theory.</p><p>The theory defined by the empty set { } of axioms is predicate logic, PL. For example, (3s)p(x) V (Vx)ip(x) is a valid sentence of predicate logic. Any interpretation is a model for predicate logic.</p><p>The total reflexive theory TR is defined by the following two axioms: M a ) }. By convention, we omit outermost universal quantifiers from axioms. Thus we may write the axioms for the total reflexive IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 18, NO. 8, AUGUST 1992 theory TR as</p><formula xml:id="formula_3">U k U (reflexivity) U k v v v U (totality).</formula><p>The sentence is valid in this theory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>0</head><p>When we say that a (closed) sentence is valid, without specifying a theory, we mean that it is valid in predicate logic. If a sentence is valid (in predicate logic), it is valid in any theory.</p><p>The models for a theory are the same as the models for its axioms. Intuitively speaking, a model for a theory corresponds to a situation that could possibly happen. For example, an interpretation that contains neither a a is not a model for the total reflexive theory TR, because it violates the totality axiom.</p><p>b nor b</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Substitutions</head><p>A substitution is a set {xl t tl , . . . , x, + t,} of replacement pairs xi t ti, where the xi are distinct variables, the ti are terms, and each xi is distinct from its corresponding ti. Thus {x t y, y t g(x)} is a substitution, but {x t a, x t b} and {x t x} are not. The empty substitution { } contains no replacement pairs. If e is an expression and 0 : {XI c tl, . . . , x, + t,} is a substitution, then eo, the result of applying 0 to e, is obtained by safely replacing each free occurrence of xi in e with the corresponding term ti. (The safety condition requires that certain quantified variables y in e be given a new name y' if some of the terms ti also contain occurrences of y. For details, see <ref type="bibr">[25]</ref>.) Applying the empty substitution leaves an expression unchanged; that is, e{ } = e for all expressions e. We say that any expression e0 is an instance of e.</p><p>The composition OX of two substitutions 0 and A is a substitution with the property that e(0X) = (e0)X for all expressions e. For example, Composition is associative but not commutative. The empty substitution is an identity under composition.</p><p>A substitution is a permutation if the terms ti are the same as the variables xi, in some order. Thus {x + y, y e z , z t x} is a permutation; {x +-y} is not. Permutations are the substitutions with inverses: That is, ?r is a permutation if and only if there is some substitution ?rP1 such that 7n-l = { }.</p><p>A substitution 6 is more general than a substitution 4 if there exists a substitution X such that ox = d.</p><p>For example, {x t y} is more general than {x + a, y +-a}, because {x t a, y t a } = {x t y}{y t a}. It follows that any substitution 0 is more general than itself and the empty substitution { } is more general than any substitution 6.</p><p>A substitution 0 is a unifier of two expressions d and e if d0 and e0 are syntactically identical, i.e., if d0 = eo.</p><p>For example, {x t a, y t b} is a unifier of the two expressions p(x, b) and p ( a , y). If two expressions have a unifier, they are said to be unifiable.</p><p>A unifier of d and e is most-general if it is more general than any unifier of d and e. For example, {x t y} and {y t x} are most-general unifiers of IC and y. The substitution 0 : {x t a , y t a} is a unifier of x and y, and both {x t y} and {y t x} are more general than 0.</p><p>A unification algorithm is a procedure for testing whether two expressions are unifiable. If so, it returns a most-general unifier; otherwise, it returns a special object nil, which is distinct from any substitution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="111.">THE DEDUCTIVE TABLEAU</head><p>Our proofs are represented by a two-dimensional structure, the deductive tableau. Each row in a tableau contains a sentence, either an assertion or a goal, and an optional term, the output entry. In general, in a given row, there may be one output entry for each output of the desired program. Thus, typical rows in a tableau have the following form:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>output columns</head><p>The proof itself is represented by the assertions and goals of the tableau; the output entries serve for extracting a program from the proof. Usually, we speak as if our tableaux have only a single output column, but in fact the results apply when there are several output columns as well.</p><p>Before we describe the meaning of a tableau, let us look at an example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example (Deductive Tableau)</head><p>This tableau is part of the derivation of a program to find an upper bound for two objects a1 and a2 in the total reflexive theory TR.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="0">A. Suiting a Tableau</head><p>We have said that a tableau may represent a proof and a derivation; it may also be regarded as a specification. Specifications describe sets of permissible output objects, which are identified with ground terms. In this section, we gradually define what it means for a ground term to satisfy a tableau.</p><p>We first restrict our attention to a particular interpretation and a single row of a tableau.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition (Suiting a Row)</head><p>A closed term t suits a row W l (or, respectively, m] )</p><p>under an interpretation Z if, for some substitution A, the following two conditions are satisfied:</p><p>Truth condition. The sentence AX is closed and false under Z (or, respectively, the sentence GX is closed and true under z ) .</p><p>Output condition. If there is an output entry s, the term SA is closed and SA equals t under 2.</p><p>In case the output entry s is absent, the output condition holds 0</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example (Suiting a Row)</head><p>If a1 k a2 is true under an interpretation 1, the term al vacuously. We call X a suiting substitution.</p><p>suits the row under 2. To see this, we take the suiting substitution X to be { z + a l } . The truth condition holds because ( z Q)X, that is, a1 2 a2, is closed and true under 1. The output condition holds because zX, that is, al, is closed and equal to a1 under 1.</p><p>In this example, the term a1 is actually identical to the instance zX of the output entry z. If a row has no output entry, the output condition for suiting a row always holds. This means that, under an interpretation, if some closed term suits the row, then any closed term suits the row, since the truth condition does not depend on the term. In a sense, a missing output entry may be thought of as a "don't care" condition.</p><p>We have defined what it means to suit a single row; now we say what it means to suit an entire tableau.</p><p>Definition (Suiting a Tableau) Under an interpretation, a closed term suits a tableau if it suits some row of the tableau.</p><p>If we think of the tableau as a specification and the interpretation as a situation or case, the closed terms that suit the tableau coincide with the outputs that will meet the specification in that case. then a1 else a2) also suits this row under Z.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example (Suiting a Tableau)</head><p>Let 7 be the following tableau:</p><p>If al 5 a2 is true under 2, then a1 suits 7 under Z, with the empty suiting substitution { ). If, on the other hand, -.(al 2 a2) is true under 2, then a2 suits 7 under 1. In either case, the conditional term ( i f a l k a2 then a1 else a2) suits 7 under 1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Satisfying a Tableau</head><p>The notion of suiting a tableau depends on the interpretation; a term may suit a tableau under one interpretation and not under another. In that sense, suiting is analogous to truth for a sentence. We now introduce a notion of "satisfying" a tableau, which is independent of the particular interpretation. That notion is analogous to validity for a sentence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition (Satisfying a Tableau)</head><p>In a theory Hence t satisfies the tableau in TR.</p><p>Thus for any model Z for the theory TR, t suits 7 under 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>U</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Equivalence Between Tableaux</head><p>We introduce two distinct relations of similarity between tableaux. The stronger relation, equivalence, requires that the two tableaux always have the same suiting terms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition (Equivalence of Tableaux)</head><p>Two tableaux That is, for 71 and 1 2 to be equivalent in TH they must have the same suiting terms under each model for the theory. When we say that two tableaux are equivalent without specifying a theory, we mean that they are equivalent in predicate logic.</p><p>If two tableaux are equivalent (in predicate logic), they are equivalent in any theory. Eamples of equivalent tableaux will be provided by the following basic properties. The proof of one of these properties is provided; the others are similar.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Property (Duality)</head><p>For any sentences A and G and optional term s, we have:</p><p>In other words, any assertion A is equivalent to a goal (TA),</p><p>with the same output entry s, if any. Any goal 6 is equivalent to an assertion (-G), also with the same output entry.</p><p>The equivalence relation between tableaux has the substi- tutivity property that if we replace any subtableau of a given tableau with an equivalent tableau, we obtain an equivalent tableau. Hence the duality property allows us to push any assertion of a tableau into the goal column by negating it, obtaining an equivalent tableau.</p><p>It will follow that, for any tableau, we can push all the assertions into the goal column, or all the goals into the assertion column, by negating them, thereby obtaining an equivalent tableau. Neverthless, the distinction between assertions and goals has intuitive appeal and possible strategic power, so we retain it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Property (Renaming)</head><p>For any sentences A and G, optional term s, and permutation T , we have:</p><p>Applying a permutation to a row has the effect of systematically renaming its free vairables. For example, by applying the permutation T : {x c y, y t z , z t x} to the assertion we obtain the assertion The property tells us that these two rows are equivalent.</p><p>The renaming property states that we can systematically rename the free variables of any row, obtaining an equivalent tableau.</p><p>We prove the renaming property for a goal row.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof (Renaming Property)</head><p>Suppose the closed term t suits the row We show that then t also suits the row</p><formula xml:id="formula_4">(*) (t)</formula><p>GA is closed and true under Z,</p><p>SA is closed and equal to t under Z.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S</head><p>with suiting substitution w-lA, where T-' is the inverse of the permutation R .</p><p>To show this, we show the truth condition,</p><formula xml:id="formula_5">(GT) ( . -' A)</formula><p>is closed and true under Z, = G(TT-')A = G{ } A = GA, and similarly for s.</p><formula xml:id="formula_6">( S T ) (T-'A)</formula><p>In the other direction, we assume that t suits the row with suiting substitution A, and can show that t also suits the original row with suiting substitution TA.</p><p>o Property (Instance) For any sentences A and 8, optional term s, and substitution 8, we have 0</p><p>It follows that we may add to a tableau any instance of any of its rows, obtaining an equivalent tableau. Note that, while the duality and renaming properties allow us to replace one row with another, the instance property requires that we retain the old row while adding the new one. If we replaced the row, we would not necessarily retain equivalence.</p><p>The following property allows us to add to or remove from the tableau's equivalence. We restrict our attention to a fixed theory TH.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Property (Valid Assertion and Contradictory Goal)</head><p>Suppose A is a sentence whose every ground instance AB is valid in theory TH; suppose 4 is a sentence whose every ground instance GO is contradictory in TH. Then for any tableau 7 and term s,</p><formula xml:id="formula_7">I I I I</formula><p>in theory TH. In other words, A may be added as an assertion, or 6 as a goal, to any tableau, yielding an equivalent tableau.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>0</head><p>It follows from the valid-assertion property that any row</p><formula xml:id="formula_8">- 7 1 . 1</formula><p>or -1 can be dropped from any tableau. These are sometimes called trivial rows.</p><p>We have defined validity in a theory for closed sentences only. However, if A is an assertion in a tableau that is not closed, we often say that A is a valid sentence when we really mean that every closed instance of A is valid. The valid-assertion property can then be paraphrased to say that a valid assertion can be added to any tableau, preserving its equivalence.</p><p>The following property tells us more about what it means when a row lacks an output entry.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Property (No output)</head><p>A row (assertion or goal) with no output entry is equivalent to one whose output entry is a new variable; that is, a variable that does not occur free in the row:</p><p>The rationale here is that if some closed term suits either of these rows, then any closed term will. More precisely, a closed term t suits 7 with suiting substitution </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Primitive Expressions</head><p>For some purposes, the notion of equivalence is too strong. We may not care if two tableaux are suited by the same closed terms, for each model for the theory, so long as they are satisfied by the same closed terms. And we may not care if they are satisfied by precisely the same closed terms, so long as they are satisfied by the same closed terms that correspond a tableau any valid assertion or contrasting goal, and retain to computer programs; that is, those that we know how to compute. This latter idea is captured in the notion of primitive terms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition (Primitive Expression)</head><p>Assume we are given a finite set of constant, function, and predicate symbols, called the primitive set. An expression is said to be primitive if It is quantifier-free All of its contant, function, and predicate symbols belong to the primitive set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>0</head><p>Note that a primitive expression may contain variables.</p><p>Intuitively speaking, the primitive expressions are those we know how to compute, in terms of the variables and the elements of the primitive set. Typically, the primitive set will include the basic operators of the theory, plus those function symbols for which we have already derived programs. For example, in deriving a program to compute the multiplication function in the theory of the nonnegative integers, we typically include the constant symbol 0, the addition function symbol +, and the equality predicate symbol = in the primitive set.</p><p>We can now define a relation of similarity, weaker than equivalence, between tableaux. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition (Primitively Similar)</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Iv. PROPERTIES OF DEDUCTION RULES</head><p>Deduction rules add new rows to a tableau. They do not necessarily preserve equivalence, but they do preserve primitive similarity; that is, they maintain the set of primitive closed terms that satisfy the tableau. Thus the program specified by the tableau is unchanged by the application of deduction rules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition (Soundness)</head><p>A rule for adding new rows to a tableau is sound in theory TH if the same primitive closed terms satisfy the tableau in 0</p><p>We shall guarantee that each of our deduction rules is sound in the background theory.</p><p>Let us introduce some terminology for speaking about deduction rules. We use the following notation to describe a rule: TH before and after applying the rule.</p><p>Here, the assertions A, and the goals 0, are the required rows I,, which must be present in the tableau if the rule is to be applied. The assertions A, and the goals G, are the generated rows 7g, which may be added to the tableau by the rule.</p><p>The old tableau refers to the tableau before the application of deduction rules; if the rule is applicable, the required rows form a subtableau 7, of the old tableau. The new tableau refers to the tableau after application of the rule; it is the union of the old tableau and the generated tableau 7,.</p><p>Although we are not yet ready to introduce the deduction rules of our system, we mention one of them as an illustration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example (If-Split Rule)</head><p>In tableau notation, the if-split rule is written</p><formula xml:id="formula_9">zf A then Q s</formula><p>In other words, if a goal of the form ( i f A then G) is present in the tableau, then we may add the new assertion A and the new goal 0. The output entry s for the required goal (if A then G), if any, is inherited by the generated assertion 0 A and the generated goal 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Description of the Derivation Process</head><p>it to the deductive tableau notation.</p><p>At this point we describe the derivation process and relate</p><p>We are given a specification</p><formula xml:id="formula_10">f ( a ) find z such that Q[u, Z]</formula><p>in theory TH. We assume that z is the only free variable in Q [ a , z ] . We are also given a set of primitive symbols; to allow the formation of recursive programs, we include f in the primitive set. We form the initial tableau </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example (Derivation Process)</head><p>In the theory of finite strings, we want to derive a program that, for a given nonempty string s, returns the last character of s and the string of all but the last character of s. Our specification is</p><formula xml:id="formula_11">( f i n d (21, z 2 ) such that if 1 (S = A) then char(z2) A ( f r o n t ( s ) , last(s)) e I s = 21 * 2 2 .</formula><p>In other words, we want to decompose s into the concatenation z1 * 2 2 of a string z1 and a character z2; then z2 is the last character of s and z1 is the string of all but z2. We assume that s is not equal to the empty string A. Note that for this program there are two outputs, z1 and z2. That is, we need to compute two functions, f r o n t and last. The primitive set includes all the basic constant, function, and predicate symbols of the theory of strings, as well as the function symbols front and last.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The corresponding initial tableau then contains the goal assertions goals f r o n t ( s ) l a s t ( s )</head><p>Here, the input s is a constant and the outputs z1 and z2 are variables. Properties of the theory of strings are also included in the initial tableau as assertions. For instance, the axioms for the concatenation function are represented as the assertions</p><formula xml:id="formula_12">A * y = y i f char(u) then ( U . yi) * yz = U . (yi * YZ)</formula><p>By the application of deduction rules, new rows are added to the tableau, obtaining a primitively similar tableau. The process continues until we ultimately obtain the final goal</p><formula xml:id="formula_13">zf c</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>h a r ( s ) i f c h a r ( s ) then A then s else h e a d ( s ) . e l s e l a s t ( t a i l ( s ) ) f r o n t ( t a i Z ( s ) )</head><p>The program we extract from the proof is then</p><formula xml:id="formula_14">i f char(s) front(s) + then A else head(s) . front(tail(s)) i f char(s) { { last(s) + then s else last (tail (s)).</formula><p>0</p><p>The correctness of the derivation process depends on two properties of tableaux. We begin with a definition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition (Correctness)</head><p>A program ! ( a )</p><p>t <ref type="bibr">[a]</ref> is correct with respect to the specification if the sentence is valid in the theory TH augmented with the additional axiom</p><formula xml:id="formula_15">f ( a ) e find z such that Q[a,z] (VX) Q[? f ( . &gt;I (Vz)[f(.) = t[sIl.</formula><p>0</p><p>The additional axiom we add to the theory is the definition</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Property (Initial Tableau)</head><p>If </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Justification of a Deduction Rule</head><p>Our deductive system will have several deduction rules. Furthermore, if we wish to apply the system to a particular theory, it may be convenient to introduce new rules peculiar to that theory. To establish the soundness of these rules, we introduce a general method for justifying deduction rules.</p><p>For each rule we formulate a justification condition. If the justification condition holds, then the rule is sound. This is the content of the following result. The justification condition suffices to establish that, when we add the generated rows to the tableau, we are not altering the set of primitive satisfying terms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Property (Justification)</head><formula xml:id="formula_16">A</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof (Justification Property)</head><p>Suppose that the justification condition holds for a deduction rule. We would like to show that the rule is sound. In other words, we must show that the new tableau and old tableau specify the same class of primitive closed terms. Because we are adding new rows but not deleting any, we cannot lose any primitive closed terms in applying the rule; we merely must ensure that we do not gain any. In other words, we must guarantee that for any primitive closed term </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof (Justification for Equivalence Property)</head><p>Suppose that the justification condition for equivalence holds for a deduction rule. We would like to show that the rule preserves equivalence. In other words, for each model Z for TH, we must show that the sets of terms that suit the two tableaux are the same. Because the rule adds but never deletes rows, we cannot lose any suiting terms in applying the rule; but we must ensure that we do not gain any. In other words, we must show that, for any closed term t, if t suits 7, under Z then t suits To under Z.</p><p>Suppose t does suit 7, under Z; we must show that t also suits 7,. Because t suits I,, it must suit either the original subtableau 7, (as we wanted to show) or the generated subtableau 79 under 2.</p><p>If t suits A under Z, the justification condition for equivalence tells us that it also suits I,, and therefore I,, under Z, as we wanted to show. 0 Let us use the justification condition for equivalence to show the soundness of the if-split rule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Property (Soundness of If-Split)</head><p>The if-split rule preserves equivalence of tableaux, and 0</p><p>The proof of the soundness of the if-split rule requires a</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition (Closing Substitution)</head><p>Let e be any expression, y1, . . . , y, be a complete list of all the free variables in e, and a be a constant. Then the substitution A, = {yl +-a , . . . , yn + a } is a closing substitution for e.</p><p>In the case in which there are no free variables in e, that is, if e is closed, we take the closing substitution A, = { }. 0</p><p>Note that, if A, is a closing substitution for e, then eXa is closed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof (Soundness of If-Split)</head><p>We show that the justification condition for equivalence holds for the if-split rule.</p><p>Let 1 be a model for the theory TH and t be any closed term. We suppose that t suits the generated tableau ' &amp; under 2, and show that then t suits the required tableau I, under 2.</p><p>If t suits the generated tableau, it must suit at least one of the two rows hence is sound, in any theory TH.</p><p>technical notion that will also be useful later.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>s</head><p>We suppose it suits the assertion. Then for some suiting substitution A, we have, by the truth condition, and, by the output condition, Let A, be a closing substitution for 6X. We show that t suits the required tableau 7, under Z, with suiting substitution AX, .</p><p>Because AX is closed, AAA, is identical to AX, and hence is closed and false under Z. Therefore, by the semantic rule for if-then, (if AAAa then 6XXa) is closed and true under 2;</p><p>A X is closed and false under Z SA is closed and equal to t under 2.</p><p>that is, the truth condition holds (if A then g)XXa is closed and true under 1.</p><p>Because SA is closed, SAX, is identical to SA, and hence we have the output condition SAX, is closed and equal to t under Z.</p><p>This establishes that t suits the required tableau 7,, under Z, as we wanted to show.</p><p>The proof for the case in which t suits the generated goal is the same. 0</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Simplification</head><p>Before we introduce the rules of our system, we would like to describe the simplification process. This is a process in which subexpressions of the tableau are replaced by simpler expressions. Simplification can be applied to the assertions, goals, or output entries of the tableau. Subsentences are replaced by equivalent sentences, and subterms are replaced by equal terms. The set of simplifications to be applied depends on the background theory, although some simplifications can be applied in any theory. Because the result of a simplification is always simpler than the given expression, termination of the process is guaranteed.</p><p>Simplification is not regarded as a deduction rule. While a rule adds new rows to a tableau without changing those that are already present, simplification replaces an old row with a new one. Also, while the application of a deduction Tule is at the discretion of a user or control strategy, the simplification process is mandatory and automatic. That is, we shall fully simplify all the rows of our tableau before applying any deduction rule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example (Simpl$cation)</head><p>The and-two simplification, and the all-redundant-quantifier simplification, (V x ) 3 =+ 3, where z does not occur free in 3.</p><p>Finally, there are theory simplifications, whose application is limited to a particular theory. For example, if our background theory is the nonnegative integers, we include the plus-zero-right simplification for addition,</p><formula xml:id="formula_17">u + o = + u .</formula><p>In the theory of strings, we have the left-empty simplification for concatenation,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>v. THE DEDUCTION RULES</head><p>We are now ready to introduce the deduction rules of our Splitting rules. Break down a row into its logical components. Resolution rule. Performs a case analysis on the truth of a subsentence of two rows. Equivalence rule. Replaces a subsentence with an equivalent sentence. Skolemization rules. Remove quantifiers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Equality rule. Mathematical induction rule.</head><p>system. We divide them into several categories: Replaces a subterm with an equal term.</p><p>Assumes that the desired program behaves correctly on inputs smaller than the given one. We describe the splitting rules, the resolution rule, the equality rule, and the mathematical induction rule subsequently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. The Splitting Rules</head><p>These rules are logically redundant: any theorem that can be proved with the help of the splitting rules can also be proved without them. Nevertheless, splitting rules often clarify the presentation of a proof.</p><p>We include three splitting rules in our system:</p><p>In other words, an assertion that is a conjunction can be decomposed into its two conjuncts. The output entries of the required assertion, if any, are inherited by the two generated assertions. If the required row has no output entries, neither do the generated rows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>0</head><p>The or-split rule is similar: Rule (Or-Split)</p><formula xml:id="formula_18">61 v 6 2 7 1 6 2</formula><p>In other words, a goal that is a disjunction can be decomposed</p><p>The and-split and or-split rules reflect the meaning of the tableau: there is an implicit conjunction between the assertions of our tableau and an implicit disjunction between the goals. Note that there is no or-split rule for assertions and no and-split rule for goals. into its two disjuncts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>0</head><p>We have seen the if-split rule:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Rule (If-Split)</head><p>In other words, an implication can be split into an assertion and a goal, its antecedent and consequent, respectively. 0 The if-split rule reflects the intuitive proof method that, to prove a sentence ( i f A then G), assume the antecedent A and attempt to prove the consequent G. The justification for the ifsplit rule was used to illustrate the justification property for equivalence. The justification for the other splitting rules is similar.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example (If-Split Rule)</head><p>Suppose our tableau contains the goal r]</p><p>Then we may add its antecedent as the assertion More precisely, the rule allows the following inference:</p><formula xml:id="formula_19">if ( 2 + € ) 2</formula><p>We take and G2 to be goal rows with no free variables in common; we rename the variables of these rows to achieve this, if necessary.</p><p>We require that P and PI be free, quantifier-free subsentences of &amp;[PI and &amp;[P'], respectively, that are unifiable. We let 0 be a most-general unifier of these sentences; thus PO and PI0 are identical. In general, there can be more than one subsentence P in Gl <ref type="bibr">[P]</ref>, and more than one subsentence PI in G2[P1]; we take 0 to be a most-general unifier of all these subsentences.</p><p>We replace all occurrences of PO in G10 with false, obtaining !&amp;8[ f a l s e ] ; we replace all occurrences of PI0 (that is, PO) in G20 with true, obtaining GzO[true].</p><p>We take the conjunction of the results, obtaining</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(&amp;e[ false]</head><p>A 820[true]). After simplification, this is added to the tableau as a new goal. The output entry associated with the new goal is the conditional term (if PO then to else SO). The test of this conditional is the unified subsentence PO. The thenterm and the else-term are the appropriate instances to and SO, respectively, of the output entries of the required goals.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>0</head><p>Before discussing the ramifications of this rule, we illustrate Example (Resolution Rule) We apply the rule to a goal and a copy of itself. Assume our tableau contains the row it with an example. We apply 0 to the two rows; the original row is unchanged, but the renamed copy becomes</p><p>We replace all copies of PO in the instantiated original row with false, and all occurrences of PO in the instantiated copy with true. The conjunction of the resulting goals is added to the tableau as a new goal:</p><formula xml:id="formula_20">t h e n z + F</formula><p>The output entry of the new goal is a conditional term whose test is the unified subsentence and whose then-term and elseterm are the appropriate instances of the output entries of the two required rows.</p><p>The derived row is simplified to</p><p>The simplifications that were applied to the goal are the true-false simplifications, T f a l s e + true </p><formula xml:id="formula_21">( U + v) + v * U + 2v.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="0">Digression (Binary Search)</head><p>Let us interrupt the exposition a moment and discuss the The given goal, intuition behind the step in the preceding example. is a consequence of the initial goal from the derivation of the rational square-root program. It expresses the fact that we would like to find a nonnegative rational number z that is an approximation within E less than the exact square root of r. Why is this? Note that z + E is the midpoint of the interval [ z , z + 2 ~) .</p><p>In the case in which ( z + 5 r , that is, z + E 5 fi, we know that fi lies in the right-half of the interval. But then the then-term z + E is within E less than the exact square root of T .</p><p>In the alternative case, in which r &lt; ( z + E)', that is fi &lt; z + E , we know that fi lies in the left-half of the interval [ z , z + 2 6 ) . But then the else-term z is already within E less than the exact square root of r.</p><p>In either case, the value of the conditional term is within E less than the exact square root and hence is a suitable output for our program.</p><p>The derived row contains the basis for the idea of binary search, while the given row does not. This discovery was obtained by a mechanical step, a single application of the resolution rule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="0">C. No-Conditional Cases</head><p>In applying the resolution rule, we normally introduce a conditional term as the output entry for the derived row. There are some cases, however, in which we apply the rule without introducing a conditional.</p><p>Suppose that the output entries s and t of the required rows happen to be unified by the substitution 0; that is, SO and to are identical. In this case, the conditional output entry</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>if PO</head><p>then t0 else st9 if 3 then U else U + U is simplified by the cond-term-two simplification to yield SO. Thus in this case the rule introduces no conditional term at all. The resulting program is of course more efficient than if the conditional had been introduced. Moreover, if the test PO is not primitive, we may not know how to compute the conditional at all.</p><p>Suppose now that one of the two required goals, say Gz, has no output entry. Then instead of the conditional, the output entry for the generated goal will be simply SO, where s is the output entry for 61.</p><p>Why is this? By the no-output property, the goal G2 with no output entry is equivalent to one with the new variable U as output entry, where U does not occur free in the row and is unaffected by 0. The output entry generated by the standard, conditional case of the rule is (if PO then u0 else SO). Because U is unaffectedby 6, this is (if PO then U else SO). By the instance property, we may add to our tableau the instance of that row whose goal is the same but whose output entry is (if PO then SO else SO), which again simplifies to st9. We shall call this the "one-output" case.</p><p>Suppose, finally, that both goals have no output entry; then the derived goal has no output entry either. Why? By the no-output property, again, the first goal is equivalent to one with output entry v, where v is a new variable. By the oneoutput case of the resolution rule, we may associate with the goal the output entry wt9, that is, v. But then, by the no-output property again, that output entry can be dropped altogether.</p><p>The no-conditional cases of the resolution rule will be illustrated after we have introduced the dual versions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Dual Versions of the Resolution Rule</head><p>We have presented the resolution rule as it applies to two goals. With the duality property, we can justify dual versions of the rule, that apply to two assertions, or to an assertion and a goal. These may be expressed as follows:</p><p>Rule (AA-Resolution)  We would like to apply the AG version of the resolution rule to these rows. The two rows have no variables in common. The boxed subsentences are unifiable; a most-general unifier is B :{U t a l , z t a l } . The result of applying the AG version of the resolution rule is then: which simplifies to Because the assertion has no output entry, the derived goal has no conditional; this is a one-output case of the rule.</p><formula xml:id="formula_22">A18[ f a l s e ]</formula><p>The step illustrated is part of the derivation of a program to find an upper-bound for two objects a1 and a2 in the total reflexive theory TR. The intuitive content of the derived row is that, in the case in which a1 a2, the term al will be a 0 suitable output for the program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Polarity</head><p>The resolution rule could be applied with the roles of the two rows reversed. For instance, in the preceding section we applied the AG version of the resolution rule to an assertion and a goal. We could also have applied the GA version to the same goal and assertion, obtaining which simplifies to the trivial goal It is typical that, of the two ways of applying the rule, one will not advance the proof. In this section, we introduce a syntactic condition that will allow us to avoid many of these fruitless applications of the resolution rule.</p><p>Roughly speaking, a subsentence of a tableau is of negative (-) or positive (+) polarity if it is within the scope of an odd or even number, respectively, of negation <ref type="bibr" target="#b7">( 7 )</ref> connectives. p(x) is of negative polarity, because it is within the scope of a single negation, but q(y) is of positive polarity, because it is within the scope of two negations. We have annotated each of these subsentences with its polarity symbol. We regard the antecedent 3 of an implication ( i f 3 then 6) as being within the scope of an additional implicit negation, because ( i f 3 then 6) is equivalent to (( <ref type="formula">13</ref>) or 6). Also, while each goal has positive polarity, we regard each assertion A as having negative polarity, because we could push it into the goal column by negating it, obtaining (TA). We regard both sides 3 and 6 of an equivalence</p><p>(3 = 6) as having both polarities ( z k ) , because (3 = 6) is equivalent to ( i f 3 then G) A ( i f 6 then 3); the first occurrence of 3 is within the scope of an additional implicit negation, but the second is not; similarly for 9. The if-part 3 of a conditional sentence ( i f 3 then 6 else 3-t) or a conditional term ( i f 3 then s else t ) also has both polarities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example (Polarity)</head><p>The following sentence is annotated according to its polarities:</p><p>Because the sentence is an assertion rather than a goal, its polarity, and that of all its subsentences, are reversed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>0</head><p>Now that we have defined polarity of a subsentence of a tableau, we can use the notion to describe a strategy for restricting the resolution rule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition (Polarity strategy, for Resolution)</head><p>An application of the resolution rule is in accordance with the polarity strategy if at least one negative occurrence of the unified subsentences P is replaced by false, and at least one positive occurrence of the unified subsentences P' is replaced by true. The positive and negative occurrences to which we 0 refer may actually have both polarities.</p><p>We illustrate the polarity strategy with an example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example (Polarity Strategy)</head><p>Suppose our tableau contains the two goals:</p><p>The boxed subsentences are unifiable, with most-general unifier {x t a , y t a}. Therefore, we may apply the resolution rule, obtaining which simplifies to This application of the rule is in accordance with the polarity strategy: The subsentence p(x), which has negative (in fact, both) polarities, is replaced by false; also, the subsentence p ( a ) , which has positive polarity, is replaced by true.</p><p>We can also reverse the roles of the two goals in applying the resolution rule, obtaining which simplifies to the trivial goal t h e n t ( a , U ) else a This application of the rule is in violation of the polarity strategy, because no negative occurrence of the unified sub-0</p><p>We have illustrated the polarity strategy with the GG version of the resolution rule. The strategy is precisely the same for the other versions. We must remember, however, that polarities are reversed in assertions.</p><p>Violating the polarity strategy does not always cause us to derive a trivial row; furthermore, observing the strategy does not always prevent us from deriving a trivial row. Nevertheless, it can be shown that observing the polarity strategy never prevents us from completing a proof, and in fact never even lengthens the proof. Because observing the strategy sentences is replaced by false. greatly reduces the number of applications of the rule we must consider, there is little reason to ever apply the resolution rule in violation of the polarity strategy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F. Relation with Classical Resolution</head><p>The question arises as to how the nonclausal resolution rule presented here relates to the classical clausal resolution principle introduced by Robinson <ref type="bibr" target="#b32">[36]</ref>. The clausal version of the rule is only applied to assertions that are in clausal form: that is, they are disjunctions of literals, where each literal is either an atom or the negation of an atom. If we apply the clausal resolution principle to the two clauses</p><formula xml:id="formula_23">P V Q 1 P ' v R</formula><p>(where P is an atom and Q and R are themselves clauses), we obtain</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>QO v RO,</head><p>where 0 is a most-general unifier of P and P'. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G. Justification of the Resolution Rule</head><p>Let us now justify the resolution rule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Property (Soundness of Resolution)</head><p>The resolution rule preserves equivalence of tableaux, and 0</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof (Soundness of Resolution)</head><p>Let us reproduce the resolution rule here for convenience: hence is sound, in any theory TH.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="691">I,. { 7gl</head><p>We show that the rule satisfies the justification condition for equivalence. Let 2 be a model for TH, and r be any closed term. We suppose that T suits the generated tableau 19 under Z, and show that r then suits the required tableau I, under 2.</p><p>If r suits 7g under 1, then there must be a suiting substitution A. In other words, by the truth condition,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="610">[ f a l s e ]</head><p>610 [falselx </p><formula xml:id="formula_24">( A )A, that is. ( A ) 626 [true] G20 [</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Case: P O X is false under Z</head><p>The proof distinguishes between two cases.</p><p>In this case, we show that r suits the first row:</p><p>of IT with suiting substitution OX.</p><p>We must show the truth condition, that G1[P]OX is closed and true under Z.</p><p>But 61O[false]X may be obtained from 61[P]OX by replacing some occurrences of the closed subsentence P O X with the sentence false, which has the same truth-value in this case.</p><p>Also, &amp;O[false]X is itself closed and true under 2. This implies the desired truth condition. We must also show the output condition, that SOX is closed and equal to r under 2. But the conditional term ( i f POX then tOX else SOX) is, in this case, equal to SOX under 1. Also the conditional term is closed and equal to r under 2. This implies the desired output condition.</p><p>Hence in this case, r suits the first row of I, under 2. In the alternative case, in which POX is true under 1, we show that r suits the second row of I, under 2, again with suiting substitution OX. Hence in either case, r suits the required tableau 7, under Z. This shows that the rule satisfies the justification condition for equivalence. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>H. The Equality Rule</head><p>Normally, we describe the properties of the functions and relations of our theory by introducing assertions into the tableau. For example, we may describe the relation of the total reflexive theory TR by introducing axioms into our tableau as assertions:</p><formula xml:id="formula_25">u &gt; u u &gt; v v v k u</formula><p>Proven properties may also be introduced into the tableau as additional assertions, such as the following property of the upper-bound function ub:</p><formula xml:id="formula_26">&amp; ( U , U) U A I ub(u, v) y v I</formula><p>This approach is not adequate for describing the equality relation, for which we require a large number of so-called functional-and predicate-substitutivity axioms, such as</p><formula xml:id="formula_27">i f u = w i f u = v then f(u, w) = f(w, w) then p(wl U , x) E p(w, w, x).</formula><p>Several such axioms may be required for each function and predicate symbol used in our proof. If we add all the required instances, the strategic ramifications are disastrous: these axioms spawn numerous consequences irrelevant to the theorem at hand.</p><p>Most theorem provers successful at working with the equality relation have used special equality rules, rather than representing equality properties axiomatically. The equality rule we use here is a nonclausal version of the paramodulation rule <ref type="bibr" target="#b42">[46]</ref>.</p><p>We present the rule first as it applies to two assertions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Rule (AA-equality)</head><p>Az (e')</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>if (e = r)O then t O else SO</head><p>More precisely, the rule allows the following inference:</p><p>We take A1 and A2 to be assertion rows with no free variables in common; we rename the variables of these rows to achieve this, if necessary. We replace all occurrences of (a = T)O in A18 with false, obtaining A18[fulse]; we replace one or more occurences of C'8 (that is, l e ) in Ape with r0, obtaining A2H(~8). (Because we replace some but not necessarily all occurrences, we use the angle brackets ( ) rather than the square brackets [ ] to denote replacement.)</p><p>We take the disjunction of the results, obtaining</p><formula xml:id="formula_28">(AlO[fulse] v A28(~8)).</formula><p>After simplification, this is added to the tableau as a new assertion.</p><p>The output entry associated with the new assertion is the 0</p><p>We have presented the equality rule as it applies to two assertions. As with the resolution rule, we can apply dual versions of the equality rule to an assertion and a goal, or to two goals; the justification of these versions of the rule appeals to the duality property.</p><p>Also, as with the resolution rule, we introduce a conditional term into the output entry only if both given rows have output entries that fail to be unified by the substitution 8. If only one of the rows has an output entry s, we take SO as the new output entry. If both rows have output entries s and t that are unified by 8, we take the unified term s8 as the new output entry. If both rows have no output entry, neither will the new row.</p><p>An application of the rule is in accordance with the polarity strategy if at least one negative occurrence of an equality We illustrate the equality rule with an example.</p><formula xml:id="formula_29">I = T is</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example (Equality Rule)</head><p>This example is taken from the transformation of a program to reverse a string. We are in the process of deriving an auxiliary subprogram rew2(s1 t ) to reverse the string s and concatenate it onto the string t. Because both terms have output entries, a conditional term is introduced as the new output entry. The application is in accordance with the polarity strategy, because the occurrence 0</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example (Equality Rule)</head><p>This example is taken from the derivation of a square-root program in the theory of nonnegative rationals. We assume our tableau contains the assertion of the equality (s = A) is negative in the tableau.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>r &lt; E'</head><p>which is an axiom for multiplication, and the goal: 0 The two rows have no variables in common. The boxed subterms are unifiable; a most-general unifier is { z + 0, v + 0). The result of applying a dual version of the equality rule is then: which reduces under simplification to (The condition 0 5 r is simplified to true in the theory of nonnegative rationals.) Because the given assertion has no output entry, no conditional construct is introduced in applying the rule. The application is in accordance with the polarity strategy, because the occurrence of the equality (0 . v = 0) is negative in the tableau.</p><p>The intuitive content of the derived goal is that, for the case in which r &lt; E ~, that is, in which fi is in the half-open interval [0, E), we know 0 is a suitable output for the desired</p><p>The equality rule allows us to discard all the equality axioms, except for the reflexivity axiom U = U , from our initial tableau, without sacrificing the possibility of completing any derivation.</p><p>square-root program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>U I. The Well-Founded Induction Rule</head><p>The well-founded induction principle is valuable for program synthesis and other applications because of its generality: the induction principles of all theories turn out to be instances of the well-founded induction rule. In derivation proofs, use of the rule corresponds to the introduction of recursion, or other repetitive constructs, into the derived program. Before we describe the rule, we introduce the notion of a well-founded relation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition (Well-Founded Relation)</head><p>A relation 4 is wellfounded (in a theory TH) if there are no infinite decreasing sequences in TH; i.e., no sequences x1,x2,x3,. . . such that x1 + x2 and 22 + 23 and . . . .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>0</head><p>For example, the less-than relation &lt; and the propersubstring relation + are well-founded in the theories of nonnegative integers and strings, respectively. (A string s is a proper substring of a string t, written s 4 string t , if s and t are distinct and if the elements of s occur contiguously in t.) On the other hand, the less than relation &lt; is not well-founded in the theory of nonnegative rationals, because 1,1/2,1/4,1/8,. . . constitutes an infinite decreasing sequence under &lt;.</p><p>Well-founded relations are of interest to us because of the following property.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Property (Well-Founded Induction Principle)</head><p>For any well-founded relation 4 in theory TH and any sentence P[x], any closed instance of the following sentence is valid in TH:</p><formula xml:id="formula_30">if (V x') then P[x] Ithen P[x'] J then (V x)P[x]</formula><p>where x' does not occur free in P[x].</p><p>In other words, suppose we are trying to prove that P[x] is true for every object x. For this purpose, it suffices to consider an arbitrary object d and show that P [ d ] holds under the induction hypothesis that P[x] is true for every x such that x 4 5'. The well-founded induction principle is called complete induction or course-of-values induction when 4 is taken to be the less-than relation &lt; over the nonnegative integers. It is also called Noetherian induction.</p><formula xml:id="formula_31">then char(Zast(z)) A x = f r o n t ( z ) * l a s t ( z ) l l</formula><p>In the deductive-tableau framework, this principle is repre-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Rule (Well-Founded Induction)</head><p>This row corresponds to the induction hypothesis that, for any nonempty input x less than s under &lt; w , the functions f r o n t and last will indeed decompose x into the concatenation of sented as a rule.</p><p>string front(z) and character lust(x). The relation + can When the program being derived has more than one input, applies to two tuples of inputs, be any well-founded relation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="0">assertions goals</head><p>the well-founded relation 4 rather than to the inputs themselves.</p><formula xml:id="formula_32">i f z &lt; , a then Q[z, f ( ~) 1 Example (Well-Founded Induction Rule)</formula><p>The initial goal for the rational square-root derivation is</p><p>Here, Q[u, 21 is the initial goal of the tableau; we require that output entries 21,. . . , z,, all of them may occur free in the goal.) The relation -&amp; is required to be well-founded in TH.</p><p>The function symbol f stands for the function we are trying</p><p>The rationale for the induction rule is as follows. We are trying to construct a program to compute a function f that, for a given input a, will yield an output z that satisfies z be the only free variable in the row. (If there are several <ref type="bibr">21.</ref> It suffices to conduct the derivation under the induction hypothesis that the function f will behave properly on each input z that is less than a under According to the well-founded induction rule, we may add to our tableau as an induction hypothesis the assertion -&amp;, . More precisely, we may assume inductively that, for each input 2 such that x + a, the output f ( x ) will satisfy the input-output relation Q [ x , f ( x ) ] .</p><formula xml:id="formula_33">then z2 5 r A to compute. 0 the input-output relation e [ u ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example (Well-Founded Induction Rule)</head><p>Recall that the initial goal for the front-last derivation is This row declares that the square-root program behaves properly for any pair of inputs less than the original inputs under 4 w. The well-founded relation applies to two pairs, that is, </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>J. Recursion Formation</head><p>The induction hypothesis introduced by application of the induction rule contains occurrences of the function symbol f, which denotes the function we are trying to compute. If the induction hypothesis is used in the proof, it can happen that terms of form f ( t ) will be introduced into the output column and hence into the derived program. This is the mechanism by which recursive calls are introduced into the program.</p><p>This row says that we would like our program to decompose a nonempty string s into the concatenation of a string z1 and a character 22, so that f r o n t ( s ) and lust(s) can be taken to be z1 and 2 2 , respectively. According to the induction rule, we may add to our tableau the new assertion</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example (Recursion Formation)</head><p>f ront-last derivation, introducing the induction hypothesis We have applied the induction rule to the initial goal of the</p><formula xml:id="formula_34">af x + w s then 7f -( x = A) then c h a r ( l a s t ( z ) ) A ( x = [ f r o n t ( r ) * l a s t ( z ) 1)</formula><p>This induction hypothesis contains occurrences of the function symbols front and last, which we are trying to compute. Suppose we have also derived the following goal: Note that the boxed subterms of the two rows are unifiable, with most-general unifier (21 t f r o n t ( x ) , z2 t Zast(x)}. By application of the right-to-left version of the equality rule, we obtain, after simplification, the goal x + , s A</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">c h a r ( Z a s t ( r ) )</head><formula xml:id="formula_35">A s = u . z</formula><p>By using the induction hypothesis, we have introduced the terms f ront(x) and last(x) into the output column. This will result in the formation of recursive calls in the final program.</p><p>s in the goal has the effect of ensuring that these recursive calls will not cause a nonterminating computation of the final program. If there were an infinite sequence of calls to either front or last, the corresponding arguments would constitute an infinite sequence of strings decreasing with respect to 4 this would contradict the wellfoundedness of -&amp; , The condition l ( x = A) in the goal guarantees that the argument to the recursive calls is a legal input; i.e., that it is nonempty.</p><p>to be used in the proof has not been de-U</p><p>The condition x 3</p><p>The relation 4</p><p>We illustrate recursion formation with another example.</p><p>termined; it may be any well-founded relation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example (Recursion Formation)</head><p>pose we have derived the assertion</p><p>In the derivation of the rational square-root program, sup-This is an immediate consequence of our induction hypothesis.</p><p>We have earlier obtained the goal This was obtained by an application of the resolution rule in a previous example. The boxed subsentences of the two rows are unifiable, with most-general unifier {x t T , U + 2 ~, z + s q r t ( r , 2 c ) } . By application of the resolution rule, we obtain, after simplification, the goal By using the induction hypothesis in the proof, we have introduced three occurrences of the recursive call sqrt(r, 26) into the output column. The condition ( r , 2 ~) 4 ( r , E ) in the goal guarantees that these recursive calls do not lead to a nonterminating computation. The condition 2~ &gt; 0 guarantees that the arguments r and 26 of the recursive calls are legal inputs; that is, 26 is positive. The well-founded relation 4 0 is yet to be determined.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>K. Choice of a Well-Founded Relation</head><p>There are many well-founded relations that can serve as the basis for an induction proof. Until the proof is well under way, it may be difficult to determine which relation will be most convenient to use. Rather than attempting to choose a relation at the beginning of the proof, we prefer to start the proof with an unspecifed relation 4 w , so that we can discover those properties the relation is required to satisfy.</p><p>We assume that a number of relations are given in advance to be well-founded, with certain known properties. In addition, there are mechanisms for constructing new well-founded relations from old ones, to satisfy certain properties. When </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example (Choice of a Well-Founded Relation)</head><p>In the theory of strings, the proper substring relation + string is given to be well-founded and known to have the property that the tail of a nonempty string is its proper substring; that is,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I I I</head><p>In a derivation of front-last, we obtain the goal last(s) of s and the string f r o n t ( s ) of all but the last character of s. The specification is f 2nd (zl,z2) such that (front(s),last(s)) -+ then char(z2) A s = z1 * z2 in the theory of strings. Our initial goal is thus:</p><formula xml:id="formula_36">assertions goals then c h a r ( z 2 ) A s = Z I * zz</formula><p>Properties of the theory of strings, expressed as assertions, are present in the initial tableau and will be mentioned as we use them.</p><p>By the if-split rule, we may decompose our goal into its antecedent and consequent This suggests that we take the relation 4 to be the proper substring relation &lt; s t r i n g . We can then apply the resolution rule to these two rows, with most-general unifier {y t s } , to obtain, after simplification, the goal 2. 7 ( s = A ) 0</p><p>The selection of the well-founded relation may be regarded as an extralogical step, to be performed by an external mechanism. Alternatively, we can extend our theories to include well-founded relations as objects. We may then regard 2 4 y as an abbreviation for 4 (w, 5 , y), where w is a variable that ranges over well-founded relations. In the above resolution step, when we unified tail(y) + strzng y with tail(s) +2u s, the unification algorithm would then include w c string as a replacement in the most-general unifier. In other words, the choice of the well-founded relation would be a byproduct of the proof process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="0">VI. EXAMPLES</head><p>In this section we give some examples of the derivation of specific programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. The Front-Last Derivation</head><p>We have not given all the rules in the system, but have shown enough to illustrate a full derivation of the frontlast program. This program, the reader will recall, is to find, for a given nonempty string s, two outputs: the last character The output entries z1 and , 752 have been dropped from the row 2, because these variables do not occur free in the assertion. We have annotated goal 3 in anticipation of a future step.</p><p>1) The Base Case: By the equality rule, applied to an axiom for concatenation, Now both output entries have been instantiated. The intuitive content of this row is that, in the case in which the input string s consists of a single character, f r o n t ( s ) may be taken to be A, and last(s) to be s itself. This will lead to the base case for the program we are constructing. Let us set it aside for a while and turn our attention to the recursive case.</p><p>2) The Recursive Case: We have earlier developed the goal .I</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S</head><p>By the equality rule, applied to an axiom for concatenation, Note that, by use of the induction hypothesis, the recursive calls front(x) and last(x) have been introduced into the output columns.</p><p>We next apply the resolution rule, again to the induction hypothesis and the goal. Because these rows have the variable x in common, we rename the variable in the induction hypothesis:</p><p>ipplying the rule, with most-general unifier {x' + x}, we </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>char(u) A</head><p>and the goal, with most-general unifier { z1 t U . yl, z2 t y2}, we obtain</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">char(u) A</head><p>By the resolution rule, applied to the decomposition property for strings, By the induction rule, applied as always to the initial goal, we may assume the induction hypothesis</p><formula xml:id="formula_37">7. i f x + u , s then if i ( x = A)</formula><p>then char (Zast(z)) A (z = I f r o n t ( z ) * l a s t ( z ) 1)-and the goal, taking the most-general unifier {y t s, U t head(s), x t tail(s)} we obtain</p><formula xml:id="formula_38">I I I 1 I 10. i ( s = A) A Zast(taiZ(s))</formula><p>By the equality rule, applied right-to-left to assertion 7 and goal 6, with most-general unifier (91 t front(z), y2 + last(x)}, we obtain the goal: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>f r o n t ( t a i l ( s ) ) last(tail( s))</head><p>This step has suggested that the well-founded relation be taken to be the proper substring relation. Because we have obtained the goal true with primitive output entries, we can take this to be the final goal of our tableau. The program we extract from the proof is i f char(s) f ront(s) e then A else head(s) . front(tail(s))</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i f char(s)</head><p>{ else last(tail(s)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. The Final Square-Root Program</head><p>We do not give the full derivation for the square-root program we have been using as an example; it is described in <ref type="bibr">Manna and Waldinger [27]</ref>. The final program we obtain is Let us explain this somewhat odd program, because it illustrates a more general phenomenon.</p><p>Recall that the program is intended to find a rational approximation sqrt(r,E) that is within E less than the exact square root of r ; that is, fi is to belong to the half-open interval [sqrt(r, E ) , sqrt(r, E ) + E ) .</p><p>In the case in which the error tolerance is quite large, that is, max(r, 1) &lt; E , it turns out that T &lt; E ~, that is, fi belongs to the interval [O,E) and, hence, that 0 is a good enough approximation to the square root of r.</p><p>Otherwise, we double our error tolerance and recursively find an approximation sqrt(r,Zt) that is within 2~ less than the square root of r; that is, fi belongs to the interval [sqrt(r, Z E ) , sqrt(r, 2t) + 2t). The program then asks whether (sqrt(r, 26) + E)* 5 r , that is, whether fi is in the right or the left half of our interval.</p><p>In the case in which fi is in the right half [sqrt(r, ZE) + t, sqrt(r,ZE) + Z E ) , we can take sqrt(r,Zc) + E to be our approximation to the square root; it is certain to be within E less than fi.</p><p>In the alternative case, in which fi is in the left half</p><p>[sqrt(r, at), sqrt(r, ~E ) + E ) , we can take s q r t ( r , ZE) itself to be our approximation. In either case, the conditional expression will yield an approximation within E less than fi.</p><p>This recursive program uses a binary-search technique, but it does not resemble conventional iterative binary-search algorithms. Usually, a binary-search algorithm will begin with a very large interval containing the desired output. It will divide the interval in half at each iteration, and will retain the half that contains the output. The process continues until the interval is sufficiently small; that is, shorter than a given error tolerance.</p><p>Rather than dividing an interval in half at each iteration, our derived program doubles its error tolerance at each recursion, until the tolerance is quite large. At this point, it can form a large interval that contains the desired output. As it unwinds from the recursion, it implicitly divides this interval in half, just as a conventional algorithm does. Similar recursive binarysearch programs may be obtained for division and other numerical problems.</p><p>This program was first derived by purely formal manipulation of the rules of the system, to explore the search space, without any expectation of finding a program of this form. When the program was obtained, we did not understand it and thought we had made an error in the derivation.</p><p>The program as derived is quite inefficient, since it contains several occurrences of the same recursive call sqrt(r, 26). These can be replaced by a single recursive call by ordinary elimination of common subexpressions. More sophisticated program transformation techniques <ref type="bibr">[ 16 J</ref> have been applied to transform the program into a linear iterative form.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. The Slowsort Program</head><p>Another example of a program obtained by formal manip-ulation is this sorting program obtained by Traugott <ref type="bibr" target="#b41">[45]</ref>:</p><formula xml:id="formula_39">i f 1 = () then () else i f taiZ(l) = () then 1 else i f head(l) 5 head(sort(tail(l))) sort(l) -e</formula><p>then head <ref type="bibr">(l)</ref> . sort(tail(l))</p><p>else head(sort(tail(l))).</p><p>I sort(head(l) tad( sort(tail(l)))).</p><p>Here, 1 is a list of numbers, and () is the empty list. No particular claims are made for the efficiency of this program;</p><p>for example, to find the minimum element of tail(Z), the program sorts it and throws away all but the first element. The program is unusual in that it sorts the list without invoking any auxiliary programs, just basic list-processing primitives.</p><p>Traugott derived other sorting programs with this property as well. He also considered the relationship between the proof strategy and the form of the extracted program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. SUBPROGRAMS</head><p>Once we have derived a program f , we can use it as a subprogram in future derivations. We do this by including in the tableau for these derivations an assertion stating that the derived program f does indeed meet its specification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>More precisely, suppose we have derived a program</head><formula xml:id="formula_40">f ( u ) + t to meet a specification f ( u ) + f i n d z such that &amp;[a, 21.</formula><p>Then in the initial tableau for the derivation of a new program g, we may include the assertion which states that f does satisfy its specification. If this assertion is used in the proof, the new program g may invoke the earlier program f . The function symbol f is included in the primitive list for the derivation of g.</p><p>If we choose, we may include the program f itself as an assertion in the derivation for g. That is, we may include the assertion: in the initial tableau for g. If we do this, we have lost a certain degree of modularity, because the program for g may depend on the particular implementation for f . We thus are no longer free to replace the program for f with a different program meeting the same specification. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Program Transformation</head><p>At this point we illustrate both the formation of subprograms and the application of deductive methods to program transformation problems.</p><p>We In other words, it reverses s and concatenates the result with t. To complete the derivation of reversel, it is necessary to derive reverse2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Derivation of Reverse2</head><p>present those steps relevant to our present discussion.</p><p>We will not give the full derivation of reverse2, but will</p><p>We begin with the initial tableau</p><p>The function symbols reverse and are excluded from the primitive list, so that they may not occur in the derived program. By the well-founded induction rule, we may assume the induction hypothesis From our initial goal, the definition of reverse, and some properties of strings, we eventually obtain the goal</p><formula xml:id="formula_41">I I l(s = A) I I I ead( s) . t )</formula><p>The boxed subsentences of the assertion and the goal unify, </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Derivation of Reverse1</head><p>program reversel is simple. We begin with initial tableau Once we have derived reverse2, the derivation of the We may include in our tableau the assertion that, for all z and y, the program reverse2(z, y) does meet the specification from which it was derived:</p><formula xml:id="formula_42">I I I I</formula><p>We assume that we have the following property of concatenation:</p><formula xml:id="formula_43">(zq = i)- reuerseZ(s, A )</formula><p>By the equality rule applied to this and the previous assertion, with most-general unifier {5 t reverse(%), y + A}, we obtain assertions By the resolution rule, applied to this assertion and the initial goal, with most-general unifier {x t s, z +-reverse2(s, A)}, we obtain the final goal</p><formula xml:id="formula_44">goals reversel (s) z = reverse(s)</formula><p>From this proof, we extract the program z reverse1 ( s ) reverse2(s,A).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. The Need for Generalization</head><p>This derivation illustrates a phenomenon in program synthesis that reflects a corresponding observation in theorem proving. It has been remarked that, in proving a theorem by induction, it is often necessary to prove a more general theorem so as to have the benefit of a more general induction hypothesis. (This fact has been exploited by the Boyer-Moore theorem prover [5].) Similarly, in deriving a program, it is sometimes necessary to derive a more general program so as to have the benefit of a more general recursive call.</p><p>To illustrate this phenomenon, let us see what would have happened had we begun the derivation of the reversel program without first deriving reversee. We begin with the goal By the well-founded induction rule, we may assume the induction hypothesis ll As in the derivation of the reverse2 program, we may obtain, from the initial goal, the definition of reverse, and properties of strings, the new row This time, however, the boxed subsentence of the goal fails to unify with the boxed subsentence of the induction hypothesis. Because the specification for reversel is less general than the specification for reverse2, its induction hypothesis is also less general: in fact, the induction hypothesis is not general enough to unify with the desired goal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Motivation for Generalization</head><p>In our successful derivation for reversel , we have assumed that we were clever enough to first derive reverse2. If we were not given the specification for reverse2, could we, or perhaps a system, be led to discover it? In general, automatic generalization of this sort is a difficult problem. We speculate that appropriate generalizations may be discovered by observing regularities in the structure of a derivation attempt.</p><p>For example, in the attempted derivation of reverse1 (assuming that reverse2 has not yet been developed), we begin with the goal z = reverse(s) and obtain the subsentence z = reverse(tail(s)) * head(s).</p><p>If we apply the same steps to this subsentence, as we did to the original goal, we obtain the subsentence If we can observe the regularity in these goals, we may be inspired to construct a subprogram to satisfy instead the input-output condition: This is the specification for the auxiliary subprogram reverse2. Each of the above three subsentences is equivalent to an instance of this condition, taking 5 to be s,tail(s), and taiZ(tail(s)), respectively, and t^ to be A,head(s), and head(tail(s)) * head(s), respectively. Some generalizations, however, are more difficult to motivate. For example, in the derivation of a unification algorithm [24], [32], we begin with a specification</p><formula xml:id="formula_45">f i n d 0 such that el6 = e26 A z = reverse(tail(tail(s))) * head(tail(s)) * head(s.) z = reverse(;) * i. unifY(el,e2) V</formula><p>In other words, we wish the program to return a substitution 6 that is a unifier of el and e2, and that is more general than any other unifier 4. In the case in which el and e2 are not unifiable, the program is to return the special object nil, which is not a substitution.</p><p>The details of this derivation are outside the scope of this discussion. For our derivation proof to succeed, we found it necessary to add to the first disjunct of the specification the new condition 6'0, = 0 that is, 6' is idempotent under composition. Nonidempotent most-general unifiers are unintuitive; for example, {z c y} and {y +-x} are idempotent most-general unifiers of z and y, but {x t z , y t-z , z t z} is a nonidempotent most-general unifier. On the other hand, idempotence had not been studied in connection with unification, so we were surprised to require its introduction into the specification. (Idempotence has been studied independently in the work of Eder [ll].)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. SPECIALIZED INFERENCE RULES</head><p>Progress in program synthesis depends on the development of techniques for automated deduction, both interactive and automatic. The inference rules we have introduced so far are very general: they apply to proving theorems in any theory. If we are satisfied with a more specialized system, one which is competent in a particular theory, such as the strings, we may be able to devise more powerful inference rules whose applicability is limited to that theory. Such rules may be able to achieve in a single step inferences that would otherwise require several steps.</p><p>The first benefit of this is to shorten proofs. This is a clear advantage in an interactive system, in which each step of the proof requires some effort on the part of the user. For an automatic system, a shorter proof may be an advantage if it can be found more easily. Because introducing new inference rules gives us more choices at each stage, it can actually increase the search space. Although the proof is shorter, it may be more difficult to discover.</p><p>A new inference rule may pay for itself, however, if, in addition to shortening the proof, it allows us to discard from the initial tableau some assertions that represent valid properties of the theory. We can do this only if the rule has certain completeness properties, which guarantee that in discarding the assertions we are not losing any opportunity to complete a proof. If so, the rule may reduce the number of choices at each stage and hence contract the search space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Associative-Commutative Unification and E-Unification</head><p>One way to increase the power of an inference rule is to extend the unification algorithm to take the properties of the theory into account. For example, the associative and commutative properties of operators, such as the addition and multiplication functions in the theories of numbers or the conjunction and disjunction connectives in any logical theory, may be incorporated into an associative-commutative (AC) unification algorithm <ref type="bibr" target="#b39">[43]</ref>. While the ordinary unification algorithm would not be able to unify the two terms a + (x + b ) and (c + U ) + b, the AC algorithm would, returning the unifier {z + c}.</p><p>Completeness results for the algorithm have been established; that is, if the algorithm is adopted, we may discard the associativity property:</p><p>( u + w ) + w = u + ( w + w ) and the commutativity property: from the initial tableau.</p><p>Unlike ordinary unification, which always returns a single most-general unifier, the AC unification algorithm may return a finite number of distinct unifiers. For example, for an associative-commutative function f , the result of unifying the two terms f ( a , z ) and f ( b , y ) can be either {z + b , y t-U } or {x t-f ( b , U ) , y t-f ( a , U ) } , where u is a new variable. Special unification algorithms have been devised <ref type="bibr" target="#b35">[39]</ref> for treating operators with various combinations of properties, including associativity, commutativity, identity, and idempotence. More general E-uniJication algorithms (e.g., [ 121) treat operators with properties defined by a set of equations supplied by the user. Some of these algorithms produce multiple mostgeneral unifiers, or even an infinite stream of unifiers; some are not guaranteed to terminate, whether they produce an infinite stream or not. u+w = w + u B. Sorted Unification Some unification algorithms have been devised for dealing with sort relations; these are the unary relations, such as integer (x), s t r i n g (x), or char(z), that serve to categorize our set of objects. Sorted unification algorithms (e.g., <ref type="bibr" target="#b34">[38]</ref>) allow us to provide a declaration that associates a particular sort relation with each variable and term. Thus we might declare that z is of sort integer and s is of sort s t r i n g . The sorted unification algorithm will produce only replacement pairs z +-t such that z and t are of the same sort.</p><p>An advantage of using sorted unification is that we can drop from our assertions and goals all subsentences p ( t ) , where p is a sort relation. For instance, if we have declared z to be of sort string and y to be of sort integer, the sentence will be understood to mean (v'z)(3Y)!dz, Y)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">i f s t r i n g ( z ) t h e n ( 3 y ) [ i n t e g e r ( y ) A d z , Y)1 (VX) [</head><p>Some assertions may disappear completely. Use of sorted unification has achieved dramatic reduction of the search space for some problems.</p><p>Extended unification algorithms may replace ordinary unification in the resolution and other inference rules of a deductive system. Where the algorithm may return multiple unifiers or fail to terminate, the control for the rule must be adapted accordingly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Special Inference Rules</head><p>Another way to specialize a deduction system to a particular theory is to introduce entirely new inference rules. We have already seen how paramodulation (our equality rule) allows us to give special treatment to the equality relation, and thereby eliminate such axioms as transitivity and the functional-substitutivity of equality from our initial tableau. <ref type="bibr">Manna and Waldinger [26]</ref>  <ref type="bibr">(and,</ref><ref type="bibr">with Stickel,</ref><ref type="bibr">[22]</ref>) introduce an analogous rule for dealing with ordering relations; adopting this rule allows us to give special treatment to the ordering relation. Bledsoe and Hines give special inference rules for real numbers <ref type="bibr" target="#b3">[4]</ref> and set theory <ref type="bibr">[18]</ref>.</p><p>We have seen that we can specialize a rule to a particular theory or subtheory if we have a special unification algorithm for that theory. Stickel <ref type="bibr" target="#b40">[44]</ref> has shown that we can also specialize a rule if we are given a procedure for determining the validity of sentences in a subtheory. The specialized rule can then be used to perform derivations in a combination of the subtheory with other theories.</p><p>For example, suppose we have two goals</p><formula xml:id="formula_46">I I Ib&gt;-nJ II</formula><p>where is a total reflexive relation. The ordinary resolution rule cannot be applied, because the boxed subsentences are not unifiable. If, however, we have a procedure capable of determining that, if z1 is taken to be a, the disjunction of the instances a k b v b h a is valid in the total reflexive theory, then the theory resolution rule is able to deduce the final row Stickel formulates completeness results that allow us to remove axioms from the initials tableau, such as the totality axiom u k v v v k u .</p><p>Analogous theory extensions may be formulated for the equality rule and other inference rules. Such rules have been found to achieve sizable reductions in the search space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IX. DISCUSSION</head><p>There are, of course, many aspects of program synthesis that have not been discussed in this paper, both because of space restrictions and because many of these topics are still being developed.</p><p>We have limited ourselves to discussing the synthesis of applicative programs, which return an output but produce no side effects. Some work on the deductive synthesis of imperative programs, which may alter data structures and produce other side effects, is discussed in <ref type="bibr">[28]</ref>. We have also disregarded the synthesis of concurrent, real-time, and reactive programs, which may interact with their environments (e.g., <ref type="bibr">[351)</ref>.</p><p>We have considered specifications only in the form of firstorder input-output relations. In general, it is necessary to deal with higher-order specifications that describe properties other than input-output relations. For example, if we are constructing a pair of programs, we should be able to say that one is the inverse of the other.</p><p>We have for the most part ignored the efficiency of the programs we construct; in fact, automatically synthesized programs are often wantonly wasteful of time and space. One way of treating this is to include performance criteria as part of the program's specification; the synthesized program would then be forced to meet these criteria. Another approach is to maintain a crude performance estimate for each output entry, in a separate column. Performance estimates could be taken into account in directing the search for a program. Furthermore, once a program was constructed, the search could continue for programs with better performance estimates, based on a better algorithm or data structure, for instance.</p><p>Finally, we have concentrated on program synthesis to the exclusion of the use of deductive techniques in collaboration with other software production methods; e.g., deductive testing, debugging, verification, modification, and maintenance.</p><p>At present, progress in program synthesis is limited by the power of automated proof systems. Derivation proofs are an appealing and challenging area of application for both automatic and interactive theorem proving.</p><p>For automatic systems, program synthesis has an advantage over mathematics as an application area. To make a contribution to mathematics, a system must be able to prove theorems that a human mathematician cannot. For this reason, theoremproving systems such as Argonne's [21] have had their greatest successes in areas in which human intuition is weak, such as combinatory logic and ternary Boolean algebras, so that the machine can compete on a more equal footing. For program synthesis, there is great utility in a system that can reliably be expected to prove routine and mathematically naive results, because from these results we can extract correct programs. The challenge is that many such proofs are still outside the reach of current automatic deductive technology.</p><p>To construct an interactive, rather than an automatic, program synthesis system is closer to an engineering feat today. Such a system relies on human intuition to guide the upper levels of the proof search, but itself completes the automatable details. Errors in human guidance may delay the discovery of a program, but never cause the system to construct an incorrect program. The challenge in designing an interactive system is to phrase the interaction in terms that the human guide can understand.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>0098-5589/92$03.00 0 1992 IEEE the specification sqrt(r, E ) e C. Outline of Deductive Program Synthesis synthesis and its relation to mathematical proofs. In this section we give a more detailed outline of program In general, we are given a specification f i n d z such that i f E &gt; O then z2 5 r A r &lt; ( z + E ) ~. f ( a ) e f i n d z such that Q [ a , z ] .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>(</head><label></label><figDesc>f r o n t ( s ) , l a s t ( s ) ) * f i n d (zl, z 2 ) such that [ ~~~( ~~r ~ A s = z1 * z2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>For example, a = b is true under the interpretation { p ( a ) , p ( b ) } , but false under the interpretation {q(a, b ) , y(a, a ) , y(b, b)}; q(u, a )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>(</head><label></label><figDesc>VU)[U ? .I ( reflexcivity ) (VU)(VV)[U 5 21 v 21 5 U ] (totality).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>2 ,</head><label>2</label><figDesc>with suiting substitution A. Then by the truth condition, and by the output condition,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>is closed and equal to t under 1. and the output condition, But these follow from the conditions (*) and (t), because by properties of substitutions, (GT) (. . -' A)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>t is a ground primitive term. At this point we may stop the derivation process. The program we obtain is</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>3 r \ 3 + 3</head><label>3</label><figDesc>allows any subsentence of the form (3 r\ 3) to be replaced by the corresponding sentence 3. Applying that simplification, we replace the row with the corresponding row 0 We arbitrarily divide our simplifications into categories. The true-false simplifications replace subsentences containing instances of the truth symbols true or false. For example, the are true-false simplifications. We provide a full set of these, and-true simplification, Rule (And-Split) In tableau notation, 3 A t r u e + 3 A2 S and the not-false simplification, Ai A A2 -false + true suboccurrences of the truth symbols true or false. simplifications, such as the or-two simplification, There are other logical simplifications that are not true-false 3 v 3 = + 3 the cond-term-two simplification, i f 3 then s else s + s</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>(</head><label></label><figDesc>We shall explain the box and minus-sign annotations subsequently.) This row has the variable z in common with itself; therefore in the copy we rename z to z^:The boxed subsentences P : ( z + e)2 5 r and PI : z2 5 r are unifiable: a most-general unifier is 2 +-z + E . The unified subsentence PO is then ( z + E ) ~ 5 r .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>3 true A 3 3</head><label>33</label><figDesc>-.--IEEE TRANSACTIONS ON SOFIWARE ENGINEERING, VOL. 18, NO. 8, AUGUST 1992 3 A true + and the numerical simplification</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>That is, fi should lie in the half-open interval [ z , z + E ) . If we succeed, z will be a suitable output for the program. The derived row, Zf (Z+f)' 5 T I then z + c else z expresses the fact that it suffices to find a nonnegative rational z that is a cruder approximation, within 2~ less than the exact square root of r . That is, fi should lie in the interval [ z , z + 2 6 ) . If so, the conditional term if ( z + e ) ' 5 r then z + E else z will be a suitable output for the program.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>and nonconditional cases for these dual versions of the rule are the same as for the original (GG) version.The justification for these dual versions lies in first pushing the assertions into the goal column by negating them, then applying the GG version of the rule. For the AA version, the resulting goal is subsequently pushed back to the assertion column, negating it once more. The resulting assertion, l d l e[ false] ( -dz$true] ) is then simplified, with the simplification f a l s e to yield dl e[ false] V dz B[true]. The following application of the resolution rule illustrates Example (Dual Version, No-Conditional) Suppose our tableau includes the assertion both the AG version and the one-output case of the rule.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>ma,l+ A 2 a2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>690[</head><label></label><figDesc>f a l s e z q(a)] A [false V i q ( a ) ] Thus, in the goal if ~( a ) ---. IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 18, NO. 8, AUGUST 1992</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>11 -</head><label>11</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>resolution rule to the corresponding two assertions On the other hand, if we apply the AA version of the : 7P' v R we obtain the new assertion f a l s e V Q8 V i t r u e V R B which simplifies to Q8 V RB This assertion corresponds to the same clause produced by the classical resolution rule.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>0</head><label></label><figDesc>IEEE TRANSACTIONS ON SOFIWARE ENGINEERING, VOL. 18, NO. 8, AUGUST 1992</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head></head><label></label><figDesc>We require that C = T be a subsentence of AI[[ = T ] and e' be a subterm of AZ(1') such that C and C' are unifiable, with most-general unifier 8. Here, C = r and C' are free and quantifier-free subexpressions. As in the resolution rule, there may be many distinct subsentences l = T in AI[[ = 7-1, and many subterms C' in Az(e'); the substitution 8 must unify all the appropriate expressions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head></head><label></label><figDesc>replaced by false; no restriction is imposed on the occurrences of the subterms C l . The equality rule allows us to replace instances of the leftterm C with corresponding instances of the right term T. By the symmetry of the equality relation, we can justify a right-to-left version of the rule, which allows us to replace instances of the right term T with corresponding instances of the left term C. conditional term (if (C = T)O then t8 else s8).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Our tableau contains the two goalsz</head><label></label><figDesc>These rows have no variable in common. The boxed subterms are identical and hence unifiable with most-general unifier { }. The result of applying a dual version of the rule, the GG-equality rule, is then: tail(s), head(s) . t ) which reduces under simplification to -, f a l s e A O &lt; r A r &lt; (0 + €1' 0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head></head><label></label><figDesc>ON SOFTWARE ENGINEERING, VOL. 18, NO. 8, AUGUST 1992 -'2 the required properties of the unspecified relation + 2u match the properties of a known or constructed relation 4 r , we can choose 3 to be that relation 4 T .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head></head><label></label><figDesc>(m = Y)and the most recent goal, with most-general unifier (21 c A,y c z2}, we obtain the goal Note that the first output entry has been instantiated.By the resolution rule, applied to the reflexivity axiom and the goal, with most-general unifier {x +-s,z2 c s}, we obtain l a s t ( r ) 5. c h a r ( s )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>9 .</head><label>9</label><figDesc>x 4 , d Ai ( x = A) A</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head>3 ) 11 .</head><label>311</label><figDesc>Note that at this stage the output entries are fully instantiated. It remains to select the well-founded relation and to combine the base case and the recursive calls. Choice of a Well-Founded Relation: Let us assume that we know the following property of the proper substring relation + s t r i n g : -( s = A ) A-(tail(s) = A) A I c h a r ( h e a d ( s ) ) I fBy application of the resolution rule, taking + to be 4 string and taking the most-general unifier to be {y + s}, we obtain h e a d ( s ) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head>4 )</head><label>4</label><figDesc>The Final Steps: By the resolution rule, applied to the axiom I I I then1 c h a r ( h e a d ( y ) ) 1 - I and the goal, with most-general unifier {y c s}, we obtain By the resolution rule, applied to the trichotomy property of strings, y = A V c h a r ( y ) V l ( t a i l ( y ) = A) Iwith most-general unifier {y +-s}, we obtain By the resolution rule, applied to our earlier assertion I 2. - 1 -I and the goal, we obtain Finally, by the resolution rule applied to this goal and the one we set aside for the base case. we obtain the goal By this step, conditional terms have been introduced into our program.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head></head><label></label><figDesc>if (sqrt(r, 2 6 ) + E l 2 5 r then sqrt(r, 26) + E else sqrt(r, 2 ~) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_28"><head></head><label></label><figDesc>assertions -..-. IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 18, NO. 8, AUGUST 1992 goals reversel(s)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>).F[x] is true under Z if there is a herbrand term t such that F[t] is true under 2; here, F[t] is the result of replacing all free occurrences of x in 3 [ x ] with t. For example, the sentence (3x)p(x) is true is true under Z if, for every herbrand term t, F[t] is true under Z. If (if P then s else t ) is a closed term, a closed sentence F[if P then s else t ] is true under Z if the sentence (if P then F[s] else F [ t ] ) is true under Z. For herbrand terms s and t, s = t is true under Z if, for each herbrand atom P ( s ) , P ( s ) E Z if and only if P ( t ) E 2. Here, P ( t ) is obtained from P ( s ) by replacing exactly one free occurrence of s with t. This holds only when s and t are indistinguishable under Z.</figDesc><table><row><cell>under the interpretation { p ( a ) } because a is a herbrand</cell></row><row><cell>term and p ( a ) is true under { p ( a ) } .</cell></row><row><cell>A closed sentence (Vx)F[x]</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>The conditional term (if a1</head><label></label><figDesc>k a2 then a1 else az) is also equal to this instance of 2 under 2, because a1 5 a2 is true. Therefore, even though the two terms are not identical, the conditional term (if a1 2 a2</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>corresponds Example (Satisfying a Tableau)</head><label></label><figDesc>TH, a closed term t satisfies a tableau 7 if t 0 If we think of the tableau as a specification, t</figDesc><table><row><cell>. -</cell><cell>--</cell></row><row><cell></cell><cell>suits 7 under every model of TH.</cell></row><row><cell></cell><cell>to a program that satisfies the specification.</cell></row><row><cell></cell><cell>Suppose 7 is the following tableau:</cell></row><row><cell></cell><cell>6</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 18, NO. 8, AUGUST 1992 S</head><label></label><figDesc>Let our background theory be the total reflexive theory TR. Then the closed term t : i f a1 k a2 then a1 else a2 Then t suits the first row To see this, consider an arbitrary model Z for TR. We a2 is true under Z: In this case, t equals a1 2, as we have seen. Therefore t suits 7 under 2. In this case, t equals a2 under 2. Also (by the totality axiom, since 2 is a model for the total reflexive theory TR), a2 t a1 is true under 2. Thus t suits the second row under 2. Therefore t suits 7 under 2.</figDesc><table><row><cell>satisfies 7 in TR.</cell></row><row><cell>distinguish between two cases:</cell></row><row><cell>under 2. Case: al</cell></row></table><note><p><p>under Case: al t a2 is false under</p>2:  </p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>(21 +t l , . . . ,xn +-tn} if and only if t suits I , with suiting substitution {U t t , x1 +-t l , . . , xn</figDesc><table /><note><p>t t n } .</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>exists a model Z , for TH such that for any closed primitive term t, if t suits the generated tableau 7, under 2, then t suits the required tableau 7, under Z , t suits the old tableau I, under Z ,</figDesc><table><row><cell>and</cell><cell></cell></row><row><cell>if and only if</cell><cell></cell></row><row><cell>t suits 7, under 1,.</cell><cell>0</cell></row></table><note><p>deduction rule is sound in theory TH if the following justification condition holds: rr ~ for any model 2, for theory TH, there</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>, under Z , Case: t suits 7, under Z , t suits 7, under</head><label></label><figDesc>The new tableau 7, consists of the original rows 7, plus the generated rows 7,. To suit the entire tableau 7&amp; the term must suit one of these two subtableaux. We distinguish between two cases.The justification property can be used to show soundness of rules that do not preserve the equivalence of the tableau. If a rule does preserve equivalence, it is automatically sound and there is a simpler way to show that it preserves equivalence.</figDesc><table><row><cell>Case: t suits 7, under 2,</cell></row><row><cell>Then by the justification condition,</cell></row><row><cell>as we wanted to show.</cell></row><row><cell>Then by the justification condition again,</cell></row><row><cell>But since 7, is a subtableau of the old tableau I,, we have</cell></row><row><cell>as we wanted to show.</cell></row><row><cell>Property (Justif cation for Equivalence)</cell></row><row><cell>A deduction rule preserves equivalence in theory TH if the</cell></row><row><cell>following justification condition for equivalence holds:</cell></row><row><cell>for any model Z for theory TH,</cell></row><row><cell>for any closed term t ,</cell></row></table><note><p>t, if t satisfies 7, in theory TH then t satisfies I, in TH. Suppose t does satisfy 7, in TH; we must show that t also satisfies 7,. Consider an arbitrary model Z , for TH; we would like to show that We have supposed that the justification condition holds for this deduction rule. Let 2, be the model corresponding to Z , whose existence is guaranteed by the justification condition. Because we have supposed that t satisfies 7, in theory TH, we know that t suits 7, under 2,. t suits 7, under 1,. 0 t suits 7Z, . t suits 7, under I,, if t suits the generated tableau 7, under Z then t suits the required tableau 7, under Z. 0 -I I . 1 if A then E</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head></head><label></label><figDesc>The rule corresponds to a case analysis in an informal argument, and it accounts for the introduction of conditional terms in program derivation. We present it first as it applies to two goals.Rule (GG-Resolution)</figDesc><table><row><cell>E &gt; O</cell><cell>I</cell></row><row><cell cols="2">and its consequent as the goal</cell></row><row><cell>B. The Resolution Rule</cell><cell></cell></row><row><cell cols="2">The resolution rule is a nonclausal version of the classical</cell></row><row><cell cols="2">Robinson [36] resolution principle, introduced for program</cell></row><row><cell cols="2">synthesis [23]; a similar nonclausal resolution rule was de-</cell></row><row><cell cols="2">veloped independently by Murray [31].</cell></row><row><cell></cell><cell>5 r</cell></row><row><cell></cell><cell>t h e n z + c</cell></row><row><cell></cell><cell>else z</cell></row></table><note><p>t h e n tt, d s r se</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head></head><label></label><figDesc>suppose we are given a program + f i n d z such that z = reverse(s). course, the reverse program itself will satisfy this specification, but different derivations will yield different programs, some of them more efficient than others.Looking ahead, the particular program we shall derive is</figDesc><table><row><cell></cell><cell cols="2">( if s = 0</cell></row><row><cell></cell><cell cols="3">else reverse(taiZ(s)) * head(s)</cell></row><row><cell cols="4">for reversing the characters of a given string s. The program</cell></row><row><cell cols="4">is inefficient because, in executing successive recursive calls</cell></row><row><cell cols="4">to reverse, it will be computing the concatenation function</cell></row><row><cell>many times.</cell><cell></cell><cell></cell></row><row><cell cols="4">To transform a given program, we may regard that program</cell></row><row><cell cols="4">as the specification for a new program. For this example, the</cell></row><row><cell>new specification is</cell><cell></cell><cell></cell></row><row><cell>reversel ( s ) Of where</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>( i f s = A</cell></row><row><cell cols="2">reverse2(s, t )</cell><cell cols="2">then t else reverse2(tail(s),</cell></row><row><cell>assertions</cell><cell>goals</cell><cell></cell><cell>reverseb(s, t )</cell></row><row><cell cols="3">z = reverse(s) t</cell><cell>Z</cell></row></table><note><p><p><p>reversel (s) + reverse2(s, A)</p>head(s) . t).</p>The auxiliary subprogram reverse2(s, t ) may be regarded as a generalization of reverse. It meets the specification reverseZ(s, t ) + f 2nd z such that z = reverse(s) * t.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14"><head></head><label></label><figDesc>with most-general unifier {x t tail(s), y t head(s) . t , z + reverse2(tail(s), head(s) . t ) } . By the resolution rule,</figDesc><table><row><cell>we obtain</cell><cell></cell></row><row><cell>I I</cell><cell>reverse&amp;(tail(s), head(s) . t )</cell></row></table><note><p>Use of the induction hypothesis has accounted for the introduction of the recursive call reverse2(taiZ(s), head(s).t) into the output entry and, ultimately, into the reverse2 program.</p></note></figure>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>mended by D. Bjorner. This work was supported in part by the National Science Foundation through grants CCR-89-04809, CCR-89-11512, and CCR-89-13641, by the Defense Advanced Research Projects Agency under Contract No. NAG2-703, and by the U.S. Air Force Office of Scientific Research under Contract No.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Theorem proving via general matings</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">B</forename><surname>Andrews</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="193" to="214" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Matings in matrices</title>
		<author>
			<persName><forename type="first">W</forename><surname>Bibel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="844" to="852" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A transformation system for developing recursive programs</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Burstall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Darlington</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="44" to="67" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Variable elimination and chaining in a resolution-based prover for inequalities</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Bledsoe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hines</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th Conf on Auto. Deduction</title>
		<meeting>5th Conf on Auto. Deduction</meeting>
		<imprint>
			<date type="published" when="1980">1980</date>
			<biblScope unit="page" from="281" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">IEEE TRANSACTIONS ON SOFIWARE ENGINEERING</title>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Boyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Moore</surname></persName>
		</author>
		<title level="m">A Computational Logic</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Using the deductive tableau system</title>
		<author>
			<persName><forename type="first">R</forename><surname>Burback</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Macintosh Educational Software Collection</title>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
		<respStmt>
			<orgName>Chariot Software Group</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Implementing Mathematics with the NuPrl Proof Development System</title>
		<author>
			<persName><forename type="first">R</forename><surname>Constable</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The calculus of constructions</title>
		<author>
			<persName><forename type="first">T</forename><surname>Coquand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Huet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Contr</title>
		<imprint>
			<biblScope unit="volume">76</biblScope>
			<biblScope unit="issue">2/3</biblScope>
			<biblScope unit="page" from="95" to="120" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">The Evolution of Programs</title>
		<author>
			<persName><forename type="first">N</forename><surname>Dershowitz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983">1983</date>
			<publisher>Birkhauser</publisher>
			<pubPlace>Boston, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">A Discipline of Programming</title>
		<author>
			<persName><forename type="first">E</forename><surname>Dijkstra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1976">1976</date>
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Englewood Cliffs, NJ</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Properties of substitutions and unifications</title>
		<author>
			<persName><forename type="first">]</forename><forename type="middle">E</forename><surname>Eder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symbolic Comput</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="31" to="46" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">First-order unification in an equational theory</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th Con$ on Auto. Deduction</title>
		<meeting>4th Con$ on Auto. Deduction</meeting>
		<imprint>
			<date type="published" when="1979">1979</date>
			<biblScope unit="page" from="161" to="167" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Specifying theorem provers in a higherorder logic programming language</title>
		<author>
			<persName><forename type="first">A</forename><surname>Felty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 9th Int. Conf on Auto. Deduction</title>
		<meeting>9th Int. Conf on Auto. Deduction</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="61" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Milner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P</forename><surname>Wadsworth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lcf</forename><surname>Edinburgh</surname></persName>
		</author>
		<imprint>
			<publisher>A Mechanised Logic of Computation</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Formal specification as a design tool</title>
		<author>
			<persName><forename type="first">J</forename><surname>Guttag</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Horning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th ACM Symp. on Principles of Program. Languages</title>
		<meeting>7th ACM Symp. on Principles of Program. Languages</meeting>
		<imprint>
			<date type="published" when="1980">1980</date>
			<biblScope unit="page" from="251" to="261" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Efficient compilation of linear recursive functions into object-level loops</title>
		<author>
			<persName><forename type="first">P</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Khoshnevisan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGPLAN &apos;86 Sym. on Compiler Constructions</title>
		<meeting>SIGPLAN &apos;86 Sym. on Compiler Constructions</meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="207" to="218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">PX: A Computational Logic</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Nakano</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Str+ve C: the Str+ve based subset prover</title>
		<author>
			<persName><forename type="first">L</forename><surname>Hines</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 10th Int. Conf on Auto. Deduction</title>
		<meeting>10th Int. Conf on Auto. Deduction</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="193" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">An equational approach to theorem proving in the first-order predicate calculus</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kapur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Narendran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 9&apos;h Int. Joint Conf on Art. Intell</title>
		<meeting>9&apos;h Int. Joint Conf on Art. Intell</meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="1146" to="1153" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Predicate logic as a programming language</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kowalski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IFIP Conpress &apos;74</title>
		<meeting>IFIP Conpress &apos;74</meeting>
		<imprint>
			<biblScope unit="page" from="569" to="5144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">OTTER 2.0 users&apos; guide</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>M K U N E</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. and Comput. Sci. Div., Argonne Natl. Lab</title>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Deductive synthesis of the unification algorithm</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stickel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Waldinger ; John Mccarthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lifschitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ed</forename><forename type="middle">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Waldinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Waldinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of</title>
		<imprint>
			<date type="published" when="1980">1980. 1981</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="5" to="48" />
		</imprint>
	</monogr>
	<note>Sci. Comput. Program.</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The Logical Basis for Computer Programming</title>
		<author>
			<persName><forename type="first">R</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Waldinger</surname></persName>
		</author>
		<author>
			<persName><surname>Waldinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Z. Manna</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="59" />
			<date type="published" when="1985">1985. 1986</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
	<note>J. ACM</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">The origin of a binary-search paradigm</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Waldinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sci. Comput. Program</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="37" to="83" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The deductive synthesis of imperative LISP programs</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Waldinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 6th AAAI Nat. Conf on Art. Intell</title>
		<meeting>6th AAAI Nat. Conf on Art. Intell</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="155" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Constructive mathematics and computer programming</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Waldinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 6th Int. Cong. for Logic</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Martin-Liif</surname></persName>
		</editor>
		<meeting>6th Int. Cong. for Logic<address><addrLine>Reading, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1982">1990. 1982</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="153" to="175" />
		</imprint>
	</monogr>
	<note>The Logical Basis for Computer Programming</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Completely nonclausal theorem proving</title>
		<author>
			<persName><forename type="first">N</forename><surname>Murray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Art. Intell</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="67" to="85" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Formal synthesis of a unification algorithm by the deductivetableau method</title>
		<author>
			<persName><forename type="first">D</forename><surname>Nardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Program</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="1" to="43" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Programming in Martin-Lof&apos;s Type Theory: An Introduction</title>
		<author>
			<persName><forename type="first">B</forename><surname>Nordstrom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Petersson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Smith</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990. 1991</date>
			<publisher>Academic</publisher>
			<biblScope unit="page" from="261" to="280" />
			<pubPlace>New York; New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">The foundation of a generic theorem prover</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Paulson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Auto. Reason</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="363" to="398" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A framework for the synthesis of reactive modules</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Concurency &apos;88</title>
		<meeting>Concurency &apos;88</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="4" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A machine-oriented logic based on the resolution principle</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Robinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="23" to="41" />
			<date type="published" when="1965">1965</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Towards a mathematical theory of program synthesis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sato</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 6th Int. Joint Conf on Art. Intell</title>
		<meeting>6th Int. Joint Conf on Art. Intell</meeting>
		<imprint>
			<date type="published" when="1979">1979</date>
			<biblScope unit="page" from="757" to="762" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Computational aspects of an order sorted logic with term declarations</title>
		<author>
			<persName><forename type="first">M</forename><surname>Schmidt-Schauss</surname></persName>
		</author>
		<idno>SEKI Rep. SR- 88-10</idno>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
		<respStmt>
			<orgName>Universitat Kaiserslautem</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Unification theory</title>
		<author>
			<persName><forename type="first">J</forename><surname>Siekmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symbolic Comput</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3/4</biblScope>
			<biblScope unit="page" from="207" to="274" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Top-down synthesis of divide-and-conquer algorithms</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Art. Intell</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="43" to="96" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Checking the proof of Godel&apos;s incompleteness theorem</title>
		<author>
			<persName><forename type="first">N</forename><surname>Shankar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Instit. Comput. Sci</title>
		<imprint>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
	<note>Univ. Texas at Austin</note>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Algorithmrc Program Debugging</title>
		<author>
			<persName><forename type="first">E</forename><surname>Shapiro</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983">1983</date>
			<publisher>Cambridge, M A MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">A unification algorithm for associative-commutative functions</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Stickel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="423" to="434" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Automated deduction by theory resolution</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Stickel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Auto. Reason</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="333" to="355" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Deductive synthesis of sorting programs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Traugott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symbolic Comput</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="533" to="572" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Paramodulation and theorem proving in firstorder theories with equality</title>
		<author>
			<persName><forename type="first">L</forename><surname>Wos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Robinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine Intelligence</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Meltzer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Michie</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Open questions solved with the assistance of AURA</title>
		<author>
			<persName><forename type="first">L</forename><surname>Wos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Winkler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automated Theorem Proving: Afrer 25 Years</title>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Bledsoe</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Loveland</surname></persName>
		</editor>
		<meeting><address><addrLine>Providence, RI</addrLine></address></meeting>
		<imprint>
			<publisher>Ameri. Math. Soc</publisher>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="73" to="88" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
