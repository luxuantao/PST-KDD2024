<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Business process model abstraction: a definition, catalog, and survey</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012-01-05">5 January 2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Sergey</forename><surname>Smirnov</surname></persName>
							<email>sergey.smirnov@hpi.uni-potsdam.de</email>
						</author>
						<author>
							<persName><forename type="first">Hajo</forename><forename type="middle">A</forename><surname>Reijers</surname></persName>
							<email>h.a.reijers@tue.nl</email>
						</author>
						<author>
							<persName><forename type="first">Mathias</forename><surname>Weske</surname></persName>
							<email>mathias.weske@hpi.uni-potsdam.de</email>
						</author>
						<author>
							<persName><forename type="first">Thijs</forename><surname>Nugteren</surname></persName>
							<email>tnugteren@deloitte.nl</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Dr.-Helmert-Strasse</orgName>
								<address>
									<postCode>14482</postCode>
									<settlement>Potsdam</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Industrial Engineering and Innovation Sciences</orgName>
								<orgName type="institution">Eindhoven University of Technology</orgName>
								<address>
									<postBox>P.O. Box 513</postBox>
									<postCode>5600 MB</postCode>
									<settlement>Eindhoven</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Deloitte Consulting BV</orgName>
								<address>
									<addrLine>Laan van Kronenburg 2</addrLine>
									<postBox>P.O. Box 300</postBox>
									<postCode>1180 AH</postCode>
									<settlement>Amstelveen</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Business process model abstraction: a definition, catalog, and survey</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2012-01-05">5 January 2012</date>
						</imprint>
					</monogr>
					<idno type="MD5">805D5E8862E02AE4E4E89361A8C6EC9D</idno>
					<idno type="DOI">10.1007/s10619-011-7088-5</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T10:30+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The discipline of business process management aims at capturing, understanding, and improving work in organizations by using process models as central artifacts. Since business-oriented tasks require different information from such models to be highlighted, a range of abstraction techniques has been developed over the past years to manipulate overly detailed models. At this point, a clear understanding of what distinguishes these techniques and how they address real world use cases has not yet been established. In this paper we systematically develop, classify, and consolidate the use cases for business process model abstraction and present a case study to illustrate the value of this technique. The catalog of use cases that we present is based on a thorough evaluation of the state of the art, as well as on our cooperation with end users in the health insurance sector. It has been subsequently validated by experts from the consultancy and tool vendor domains. Based on our findings, we evaluate how the existing business process model abstraction approaches support the discovered use cases and reveal which areas are not adequately covered, as such providing an agenda for further research in this area. Communicated by Asuman Dogac. S. Smirnov ( ) • M. Weske Hasso Plattner Institute, 2-3 Prof.-</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A modern business process is an inherently distributed system: its activities are performed by various employees, on different locations, using a heterogeneous set of IT systems. Furthermore, a business process typically crosses the borders of organizational departments and even companies. As a consequence, the software applications that support business processes tend to be distributed as well <ref type="bibr" target="#b12">[13]</ref>. Hence, processes are complex artifacts that challenge managers in their efforts to properly govern them. Against this background, business process models are key artifacts to represent how work is performed in organizations. A broad spectrum of management tasks can be supported with such models, e.g., the documentation, evaluation, and improvement of business processes. While some models are useful to configure workflow technology <ref type="bibr" target="#b19">[20]</ref>, others are used to train new employees, identify performance improvement opportunities, align conflicting views of stakeholders on business operations, and demonstrate an organization's compliance with external regulations <ref type="bibr" target="#b2">[3]</ref>. Obviously, this variety of modeling goals requires a modeler to focus on the relevant aspects of the distributed business process.</p><p>As, traditionally, for each modeling goal a specific process model was designed, companies maintain large process model repositories consisting of hundreds or even thousands of models. The stored models have complex interrelations: they may overlap, describe processes that subsume each other, or describe one process from different perspectives. Models that formalize the same business process typically vary in the level of abstraction, so that along with detailed models also more coarse-grained models are maintained. As such models are stored independently, it is hard to keep them in sync. Each change of the process need to be applied to all its models, which incurs a significant overhead.</p><p>To solve this problem, business process model abstraction (BPMA) has been proposed recently, e.g., see <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b38">39,</ref><ref type="bibr" target="#b50">51]</ref>. The general idea is to develop a detailed process model and to provide views on it using abstraction mechanisms. Hence, BPMA sets the scope of the model and focuses on the relevant aspects of the complex distributed system the model represents. For instance, BPMA may aim at delivering the model that reveals the process evolution within one organizational department. Another example is the model that visualizes how particular resources are used throughout the process. However, the work reported in the literature puts the focus mainly on abstraction techniques, rather than on the specific use cases for abstraction. As a result, the academic view on BPMA is quite narrow, overlooking a number of both challenging and relevant research questions.</p><p>Against this backdrop, the contributions of this paper are as follows. Firstly, this work provides a comprehensive and precise view on BPMA. In particular, our discussion of the different levels of decision making for the act of process model abstraction arguably results in a comprehensive treatment of the subject, while the formalization of the involved operations contributes to its precision. The second contribution of this paper is a catalog of fifteen use cases. The use cases have been gathered and validated in close cooperation with industrial partners from the health insurance, consulting, and software vendor domains. The catalog <ref type="bibr" target="#b0">(1)</ref> illustrates the value of BPMA, (2) helps to categorize existing BPMA techniques, and (3) displays the mismatches between the available BPMA techniques and the industrial demand, which leads to research opportunities. The third and final contribution is a survey of the existing techniques available in the BPMA field.</p><p>The structure of the paper is as follows. Section 2 motivates the demand for business process model abstraction and sketches its problematics. Section 3 formalizes business process model abstraction. Section 4 empirically explores the application of BPMA and presents a catalog of use cases as validated by BPM professionals. To illustrate the use of BPMA in a real life setting, we provide a case study in Section 5. Section 6 leverages the use case catalog to match the existing research against the industry demand in BPMA. Section 7 concludes the paper with a summary and discussion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head><p>This section informally introduces the concept of business process model abstraction. We start the section by motivating the demand for business process model abstraction. Next, we informally introduce associated concepts as well as the relations between them.</p><p>Given a particular business process, various stakeholders may use models of that process with different levels of details. In such a setting it is often so that several models are created for one process. Consider the example in Fig. <ref type="figure">1</ref>. Model m describes a business process, where a forecast request is processed. Once an email with Fig. <ref type="figure">1</ref> Models capturing business process "Forecast request handling" at different levels of abstraction a forecast request is received, it is registered, and the data is collected. Then, there are two options: either to perform a full data analysis, or carry out a quicker alternative. The process will conclude with a forecast report creation. Model m contains semantically related activities that are aggregated together into more coarse-grained ones. The groups of related activities are marked by areas with a dashed border, e.g., group g 1 includes Receive email and Record request. Model m a is a more abstract specification of the forecast business process. Each activity group in m corresponds to a high-level activity in m a , e.g., g 1 corresponds to Receive forecast request. Meanwhile, m a is even more abstract: its activities are refined by the activities of model m a and are further refined by activities of m. While the forecast process can be enacted using model m, abstract models m a and m a are perhaps more suitable for monitoring the state of process instances. Therefore, a process participant might want to leverage model m a , while a process owner who is less interested in the particular process details may monitor states of process instances by means of m a .</p><p>The problem now is that if various process models essentially capturing one and the same business process are stored independently, it is hard to keep them in sync. Indeed, each change of the business process needs to be propagated to all its models, which incurs a significant overhead. Also, the storage of separate models is errorprone and may lead to inconsistencies between these. Against this background, business process model abstraction has emerged as a technique that allows one to inspect a business process model at different abstraction levels. In this way, the mentioned problems are mitigated. Informally, business process model abstraction can be seen as an operation on a business process model that preserves process properties that are essential for a particular purpose, while it leaves out insignificant details. To further pin down the notion of business process model abstraction, we provide two perspectives on the relations between models capturing one business process with different precision.</p><p>First, we postulate a finite non-empty set of process models M and an infinite non-empty set of process instances I . A mapping inst : M → P(I ) sets up a correspondence between a process model and the set of instances it describes. For a process model m ∈ M there is a set of abstract process models, where each model describes the set of instances inst(m), but with less detail: abstr : M → P(M). If the user possesses model m, any abstract model m a ∈ abstr(m) provides no new information about inst(m). Although one process model may have many abstractions, in the further discussion we typically refer to a process model m and its single counterpart, abstract process model m a ∈ abstr(m). In some cases, as in the example above, we consider other abstract process models, like m a .</p><p>Second, we allocate the artifacts relevant for BPMA to different levels of the Meta Object Facility (MOF) <ref type="bibr" target="#b35">[36]</ref>. Indeed, BPMA is an engineering problem dealing with models. From here onwards, we refer to MOF as a standard for model-driven engineering which organizes (meta-) modeling artifacts into 4 levels. In this way we reuse the established vocabulary and formalism of the MOF. Figure <ref type="figure" target="#fig_0">2</ref> relates the BPMA artifacts constellation according to MOF. A set of process instances inst(m) related to process model m is allocated to level M0. The business process model m is put on level M1, as it describes/models a set of instances inst(m). Process model m conforms to the modeling notation in which it is described-metamodel n. The Model m a describes the set of instances inst(m). Notice that we require models m and m a to conform to one metamodel. For instance, if the detailed process model is created using the Business Process Modeling Notation (BPMN) <ref type="bibr" target="#b36">[37]</ref>, an abstract process model conforms to BPMN as well. However, in the general case, models m and m a may adhere to different notations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Business process model abstraction framework</head><p>By now we have discussed the business process model abstraction in an informal way. For the purpose of this paper, it is necessary to address in more detail what the goal of abstraction is, when the abstraction has to be applied, and how abstraction is exactly performed. These issues have been partially studied in <ref type="bibr" target="#b38">[39]</ref>. In this section, we propose a framework that systematically organizes the relevant concepts, which enables their formal discussion. Rather than creating the framework from scratch, we reuse the knowledge of cartographic generalization, a discipline existing for centuries. Cartographic generalization is the process of selecting and representing information of a map in a way that adapts to the scale of the display medium. Hence, cartographic generalization copes with a problem that resembles that of business process model abstraction.</p><p>There exist several cartographic generalization models, e.g., <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b33">34]</ref>. We adopt the overall structure of the first comprehensive generalization model focused on digital generalization as proposed by McMaster and Shea in <ref type="bibr" target="#b28">[29]</ref>. McMaster and Shea claim that cartographic generalization consists of three components: a consideration of objectives of why to generalize; a cartometric evaluation of the conditions that indicate when to generalize; a selection of spatial and attribute transformations providing techniques on how to generalize. We will consider these components in the context of business process model abstraction, which will help us to arrive at a precise understanding of what business process model abstraction entails. Before we proceed with the formalization, Definition 1 postulates our notion of a process model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1 (Process model)</head><formula xml:id="formula_0">A tuple m = (A, G, F, t) is a process model, where: -A is a finite nonempty set of activities -G is a finite set of gateways -N = A ∪ G is a finite set of nodes with A ∩ G = ∅ -F ⊆ N × N is the flow relation, such that (N, F ) is a connected graph -t : G → {and, xor}</formula><p>is a mapping that associates each gateway with a type.</p><p>The execution semantics of such a process model can be given by a translation into a Petri net following on common formalizations <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b14">15]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Business process model abstraction: why</head><p>The why aspect of abstraction considers the reasons for abstracting a process model, i.e., the goal of a process model abstraction. The abstraction goal is driven by the purpose of an abstract process model and its intended audience. On the one hand, stakeholders may vary from technical specialists, interested in a particular technical perspective of a process, to managers seeking a high-level business process overview. On the other hand, even one user alone may demand a whole spectrum of abstraction scenarios. For instance, a manager may both be interested in activities which have a high execution cost and in the parts of the model that capture most frequent distributed process runs. A distributed run is a behavioral model of a distributed system that describes one complete system evolution <ref type="bibr" target="#b44">[45]</ref>. The purposes and the stakeholders of these scenarios are different, and, so are the goals.</p><p>Depending on an abstraction goal, different objects attract the user's attention. Consider an example in Fig. <ref type="figure" target="#fig_1">3</ref>. The models in Fig. <ref type="figure" target="#fig_1">3</ref> describe a business process, where a forecast request is processed. Model m 1 is the most comprehensive process description among the three. Notice that each activity is annotated with its average execution cost. The models in Fig. <ref type="figure" target="#fig_1">3</ref>  Every business process model abstraction operation focuses on a set of objects of one type. We refer to these objects as abstraction objects. By applying abstraction, a decision is made for each of those objects whether it is significant or insignificant with respect to a specific goal. While significant abstraction objects will be preserved, Definition 2 (Abstraction object) Let m = (A, G, F, t) be a process model. An abstraction object is a set ω ⊆ (A ∪ G ∪ F ) that describes one fact about a business process. This fact is considered relevant during one act of abstraction.</p><p>Definition 2 formalizes the abstraction object as a subset of model elements. However, not every subset of model elements is an abstraction object: Definition 2 requires the set of model elements to describe a fact about a process that is either abstracted or preserved by an abstraction operation. In this way an abstraction object has a pragmatic aspect, i.e., it captures information about the abstraction goal. Thereafter, the set of abstraction objects may vary from one abstraction operation to another, even when the same initial model is considered. We reference the finite non-empty set of abstraction objects in model m during one abstraction operation as Ω.</p><p>Returning to the Abstraction Example 1, demanding a process model with more coarse-grained activities, we identify activities as abstraction objects. Hence, the set of abstraction objects contains 13 activities of process model m 1 . If we consider the Abstraction Example 2, where the user is interested in expensive process runs, we discover two abstraction objects in model m 1 : the run with the lower branch and the run with the upper branch. Model m 3 describes only one process run and, hence, has one abstraction object. This abstraction scenario evidences another phenomenon. While we distinguish two subsets of model elements that capture distributed runs, these two subsets share common model elements. Disregard of the common elements, we clearly distinguish the two abstraction objects. This phenomenon originates from the definition of an abstraction object as the subset of model elements enriched with a pragmatic aspect.</p><p>An abstraction goal defines an abstraction criterion-a property of an abstraction object that enables object comparison and allows the identification of objects relevant for the task at hand. For instance, in the Abstraction Example 2 the abstraction criterion is the process run execution cost. At the same time, we claim that the Abstraction Example 1 leverages user input as the abstraction criterion: the user manually selects significant activities. In particular, only activity Generate forecast report is considered significant and appears in model m 2 as is.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Business process model abstraction: when</head><p>The next component of business process model abstraction deals with the conditions under which abstraction objects are affected. An abstraction criterion allows for a comparison of abstraction objects. Subsequently, an abstraction criterion classifies abstraction objects of a process model into significant and insignificant. We formalize this classification with the function. Definition 3 (Abstraction object significance) Let m be a process model and Ωthe set of abstraction objects of this model. Mapping sign : Ω → {true, false} is an abstraction object significance function such that for every ω ∈ Ω:</p><formula xml:id="formula_1">sign(ω) = true, if ω is significant, false, else.</formula><p>For the Abstraction Example 1 we assume the abstraction object significance function to be user-defined: during abstraction the user manually specifies which activities are insignificant. The Abstraction Example 2 in Fig. <ref type="figure" target="#fig_1">3</ref> vividly illustrates the idea of abstraction significance function: while model m 1 captures two possible distributed process runs, m 3 describes only one process run with the highest execution cost. In this case the run of a process with the lower execution cost of 2410 € is considered insignificant. Hence, function sign evaluates to true in the former case and to false in the latter case. The significant abstraction object appears in model m 3 , while the insignificant object is abstracted.</p><p>If an abstraction criterion displays at least an ordinal scale, the classification into significant and insignificant elements can be realized by an abstraction threshold value. The threshold value partitions the set of model elements into two classes: elements with a criterion value greater or equal to the threshold, and the rest. One of these classes is considered to be significant, while the other-insignificant (the choice depends on the concrete abstraction goal). Reference <ref type="bibr" target="#b38">[39]</ref> proposes an abstraction slider, which is an implementation of the function sign.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Business process model abstraction: how</head><p>The how component of business process model abstraction covers the method that enables the transformation of a process model into a more abstract process representation. While the abstraction relates process models, we makes use of an auxiliary binary relation R α . The R α relation sets up correspondences between abstraction objects of m and m a . In this way the relation characterizes business process model abstraction on the level of process model elements. </p><formula xml:id="formula_2">-|Ω| &gt; |Ω a | -∀ω a ∈ Ω a : sign(ω a ) = true -there is an abstraction object correspondence R α ⊆ Ω × Ω a such that ∀ω ∈ Ω : 1. either ∃ω a ∈ Ω a that ωR α ω a 2. or ∃ω a ∈ Ω a : ωR α ω a ⇒ ∃ω ∈ Ω : ω = ω ∧ ω R α ω a .</formula><p>Definition 5 requires the business process model abstraction to deliver a process model with less abstraction objects, |Ω| &gt; |Ω a |. To conceal an insignificant abstraction object ω, an abstraction operation must abide by one out of two options.</p><p>The first option is to deliver an abstract process model with no abstraction object corresponding to ω. Consider the pair of models m 1 and m 3 in Fig. <ref type="figure" target="#fig_1">3</ref> as an example, where m 3 is the abstraction of m 1 . Model m 1 describes two process runs, low cost (insignificant abstraction object) and expensive (significant abstraction object). Model m 3 describes only one run-the expensive run. While the expensive run in m 1 corresponds to the expensive run in m 3 , the low cost run has no correspondence.</p><p>The second option is to aggregate ω with other abstraction objects of m 1 and absorb them into one abstraction object of m 2 . As an example we consider Abstraction Example 1 illustrated by models m 1 and m 2 in Fig. <ref type="figure" target="#fig_1">3</ref>. In this abstraction scenario the abstraction object is an activity and several activities of m 1 are aggregated into single activity of m 2 . Hence, each insignificant abstraction object in m 1 corresponds to an abstraction object in m 2 through relation R α , while other abstraction objects in m 1 correspond to the same abstraction object in m 2 .</p><p>The two options to conceal abstraction objects relate to two different types of abstractions: elimination (π ) and aggregation (σ ). Elimination produces a model that contains no information whatsoever about the omitted abstraction objects Ω , while the other abstraction objects are preserved. Definition 6 (Elimination) A business process model abstraction π : M → M transforming a process model m with the set of abstraction objects Ω into model m a with the set of abstraction objects Ω a to conceal abstraction objects Ω ⊂ Ω, where ∀ω ∈ Ω : sign(ω) = false, is an elimination, iff:</p><formula xml:id="formula_3">-|Ω| = |Ω a | + |Ω | -∀ω ∈ Ω there is no ω a ∈ Ω a such that ωR α ω a -the restriction of the abstraction object correspondence relation R α to (Ω\Ω ) × Ω a is a bijection.</formula><p>Elimination results in a process model with no insignificant abstraction objects (in the context of the abstraction goal). Significant abstraction objects that are not handled by elimination are preserved as is. That is why the restriction of the auxiliary relation R α is a bijection. Once again, as an outcome of elimination, the abstract process model provides no information about insignificant process details. In contrast, aggregation-the other type of business process model abstraction-partially preserves information about such details.</p><p>Definition 7 (Aggregation) A business process model abstraction σ : M → M transforming a process model m with the set of abstraction objects Ω into model m a with the set of abstraction objects Ω a to conceal abstraction objects Ω ⊂ Ω, where ∀ω ∈ Ω : sign(ω) = false, is an aggregation, iff:</p><formula xml:id="formula_4">-the abstraction object correspondence relation R α is left-total -∀ω ∈ Ω there exist ω ∈ Ω and ω a ∈ Ω a such that (ω, ω a ), (ω , ω a ) ∈ R α .</formula><p>Aggregation produces an abstract model, where each insignificant abstraction object ω ∈ Ω , together with several other abstraction objects, is represented with a newly introduced abstraction object ω a . Object ω a inherits the properties of objects it aggregates. For instance, if two sequential activities are aggregated into one activity, properties of the new activity comprise properties of the aggregated activities: the execution cost of an aggregating activity may be defined as the sum of execution costs of its aggregated activities.</p><p>Figure <ref type="figure">4</ref> compares the effects of elimination and aggregation operations. Aggregation decreases the granularity of the process model, i.e., it makes a process model Fig. <ref type="bibr" target="#b3">4</ref> Comparison of aggregation and elimination basic abstraction operations: elimination changes the process coverage level, while aggregation impacts granularity level of model elements more coarse-grained. In the ultimate case, the whole business process is described by one high-level activity. Elimination omits model elements, but does not change their granularity level. Hence, elimination and aggregation enable navigation along two orthogonal axes: the granularity level of model elements and the coverage level of a business process by a model.</p><p>To complete our reflection on BPMA, we distinguish two additional aspects that have to be explicitly considered when an abstraction method is selected in practice. First of all, as an intrinsic property of BPMA is information loss, an abstract model contains fewer ordering constraints than its detailed counterpart. Depending on the exact abstraction use case and the underlying abstraction goal, the tolerance level for the loss of ordering constraints may differ. While there are order-preserving abstractions, localizing the lost ordering constraints within an abstracted fragment, others are more tolerant to ordering constraints loss (see <ref type="bibr" target="#b40">[41]</ref>). In other words, the importance of control flow preservation must be taken into account.</p><p>Secondly, non-functional properties may be more or less important to be preserved when applying BPMA. Companies often use process models to analyze operational business processes, for example to analyze their operational cost or bottlenecks. Elements of the models supporting such an analysis are annotated with additional information, e.g., activity execution time, hand-off times, and activity execution probabilities. If the user considers abstract models for an analysis, a BPMA has to ensure that the analysis of model m a delivers the same results as the analysis of model m. If the BPMA fulfills this requirement, we call it an abstraction that preserves non-functional properties.</p><p>At this point, we have arrived at a formal and complete view of BPMA. Furthermore, we have stressed the context-specific importance of preserving the control-flow and non-functional properties in a process model when applying BPMA. We will be using the various notions that have been introduced in this section in the structuring of a catalog of BPMA uses cases in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">BPMA use case catalog</head><p>In this section, we discuss a catalog of BPMA use cases which are identified with the help of BPM experts. First, we explain the method that has been applied to derive and validate the use cases. Next, we present the initial version of the catalog used as the input for the validation stage. Then, we discuss the feedback that we received during the validation stage and summarize the modified use case catalog.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Catalog design</head><p>In order to understand the user demand for BPMA techniques we referred to the expertise of our industry partners. As the problem of BPMA is relatively new, we followed an exploratory approach and conducted a series of semi-structured interviews with BPM experts. The study was separated into the two phases of (1) generation and (2) validation, which overall involved three categories of stakeholders, i.e., end users, consultants, and software developers.</p><p>In the first phase we considered BPMA use cases that emerged out of a joint project with a large German health insurance company, AOK. The goal of the project was to develop BPMA techniques enabling a fast comprehension of large business process specifications containing, for example, more than 300 nodes. The BPMA use cases were retrieved and elaborated in interviews with AOK employees: a business process leader, a coordinator of IT infrastructure for process management, a BP knowledge manager and three process modelers. All these employees are interested in BPMA as end users of a set of over 4 000 process models. The use cases derived from the interviews were complemented by use cases from the literature. The literature study includes papers from the reputable conferences on business process management and information systems, e.g., the International Conference on Business Process Management and the International Conference on Service Oriented Computing, as well as journals, e.g., IEEE Transactions of Software Engineering and Information Systems within the timespan of the last decade.</p><p>In the second phase the use cases were validated by involving two further companies: Infosys, an Indian information technology services company with a specific focus on BPM, and Pallas Athena, a Dutch software vendor developing BPM systems. From these parties, ten and eight professionals participated in this study respectively. All of the involved Infosys employees fulfill a role as BP consultant; their experience with BPM had an average value of 6.5 years. The spectrum of job descriptions of the interviewees at Pallas Athena varied from that of software engineer to the chief executive officer. The BPM experience of the participants within this group had an average value of 11.5 years. The primary goal in this phase was to reflect on the relevance of the initial set of use cases. Secondly, we encouraged the interviewees to generate new use cases. The output of the second phase was a validated use case catalog. In comparison with the initial set of 14 cases, one use case was dropped and two new use cases were added leading to a total of 15 use cases in the end.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Initial use cases</head><p>The set of initial use cases that were derived from the first phase of our exploratory approach will be discussed in this section by distinguishing four groups, each of which contains use cases that have similar properties. In this discussion, we will use the notions as introduced in Section 3 to characterize the various groups of use cases.</p><p>Specifically, the description of each group contains the central abstraction object, the used abstraction criterion, the basic abstraction operation being involved, and the importance of preserving a model's control-flow and non-functional properties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Group 1: preserving relevant activities</head><p>The user analyzes a business process captured by a process model. The model specifies numerous activities. However, the user wants to focus on activities that are significant for the task at hand. The distinction between what the significant and insignificant activities are is based on the threshold value of a non-functional property of these activities. All the activities with a value for this property that is lower than the threshold are insignificant and these are eliminated. The use cases in this group share that they have the activity as abstraction object and elimination as a basic abstraction operation. The ordering constraints between the significant activities are preserved, while the use of elimination leads to a change of the non-functional properties of the overall process. We distinguish four BPMA use cases that belong to this group.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Use Case 1: Preserve Pricey Activities</head><p>The user optimizes a business process and is interested in the activities with a high execution cost. Use Case 2: Preserve Frequent Activities The user improves a business process and focuses on frequently executed activities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Use Case 3: Preserve Long Activities</head><p>The user is interested in process optimization and focuses on activities with a high duration.</p><p>Use Case 4: Show High Hand-off Times The user optimizes a business process and focuses on activities with high hand-off times.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Group 2: preserving relevant process instances</head><p>The user analyzes a business process described by a precise model specifying the life cycle for a wide variety of process instances. The user does not want to know about each process instance, but needs to focus on a specific subset of instances. We call such instances significant. The significant process instances are visualized in the process model as paths. A BPMA eliminates the paths corresponding to insignificant process instances and preserves the paths describing significant ones. To summarize, the use cases in this group have process instances as an abstraction object, have elimination as a basic abstraction operation, preserve the ordering constraints among the significant abstraction objects, and do not allow to preserve the non-functional properties of the overall process. We have encountered the following use cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Use Case 5: Preserve Pricey Instances</head><p>The user optimizes a process and considers costly process instances as significant. She specifies a cost threshold, distinguishing significant process instances from insignificant ones: process instances with an execution cost that is higher than the threshold value are significant, the rest are not. Use Case 6: Preserve Frequent Instances The user performs process optimization and considers frequent process instances as significant. By means of an instance execution frequency threshold, the user distinguishes significant instances from insignificant ones. The instances with an execution frequency higher than the threshold are considered to be significant, while the rest are insignificant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Use Case 7: Preserve Instances with Long Duration</head><p>The user optimizes the process and considers paths with long durations as significant. She specifies a path execution duration threshold value, distinguishing significant instances from insignificant ones: the instances with execution times higher than the threshold are important, while instances with lower execution times are unimportant. Use Case 8: Trace a Case The user is interested in the question how special cases evolve in a business process. For instance, she wants to know how orders with a cost higher than 1 000 euros unfold. Hence, the user specifies a case to be traced and obtains a model capturing only the significant process evolutions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Group 3: filtering of model elements</head><p>The process model in possession of the user is overspecified for the task at hand. Only a subset of model elements is relevant and have to be disclosed. In contrast to the use cases of Group 1, the significance of model elements is determined according to their qualitative properties. The user wants to grasp the coarsegrained activities that appear in the business process. She does not require an abstraction mechanism to deliver the ordering constraints between the high level activities: once these activities are available, she can manually order them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Use case validation</head><p>The validation of the catalog design took place during two separate workshops, one for each of the involved companies. At the start of a workshop, each participant received a booklet that described the initial set of use cases. The participants were asked to study these descriptions and the researchers were available for clarification. Each participating BPM expert expressed her demand for each of the presented use cases.</p><p>To express her opinion, each participant had three options. If the participant found the use case important and the intended abstraction approach helpful, she could mark the use case with a yes. If the participant saw no value in the presented use case, she could answer no. If the participant had doubts about the relevance of the use case, she was able to respond with undecided. For the evaluation we encoded the responses: positive responses correspond to 1, negative responses were encoded with -1, whilst neutral answers-with 0. Participants had the opportunity to give comments and discuss the use cases with the researchers during the workshop. Both workshops lasted between 2 and 2.5 hours.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Relevance and completeness</head><p>Table <ref type="table" target="#tab_2">1</ref> presents the aggregated values of the response codes. As can be seen, the table differentiates between the 4 groups of stakeholders: novice and experienced consultants as well as novice and experienced (software) vendors. First, we observe that the number of novice consultants involved is equal to the number of experienced consultants <ref type="bibr" target="#b4">(5)</ref>, while for the vendors the situation is uneven-the novices outnumber the experts (6 vs. 2). Second, there is a tendency notable of experts expressing a higher appreciation of the use cases than novices. This is clearly visible for the consultants, but this relation also holds for the whole group: The average score that an expert provides for a use case equals 0.60, while this is 0.38 for the novices. Finally, the opinions of the two groups, consultants and vendors, are highly consistent, with the notable exception of "Use Case 8: Trace a Case". The latter use case is favorably perceived by consultants (total score of 7), while the vendor representatives take a neutral stance (total score of 0). Overall, the use cases "Use Case 6: Preserve Frequent Instances" and "Use Case 12: Get Process Quick View Respecting Ordering Constraints" find the most outspoken support. The former is associated with finding a so-called "happy path" in the process or its "sunny day scenario". The latter use case is interpreted by most participants as the type of abstraction that is most in demand. Surprisingly, the participants seem to differentiate between use cases that exploit the same abstraction technique, but operate with different non-functional properties of model elements. This is most vividly illustrated by the contrast between the values for "Use Case 1: Preserve Pricey Activities" and "Use Case 2: Preserve Frequent Activities". Whilst the former use case is of not much interest for interviewees (score of 0), the latter is in high demand (score of 13). A less pronounced differentiation can be observed for "Use Case 5: Preserve Pricey Instances" and "Use Case 6: Preserve Frequent Instances". We conclude that frequency is perceived as a more natural abstraction criterion by users. Furthermore, these observations highlight the importance of an explicit choice for the abstraction criterion in question.</p><p>A study of Table <ref type="table" target="#tab_2">1</ref> also reveals that use case 14 is a clear outlier. This use case is the only one that completely neglects control flow: it exclusively delivers a set of activities to the user. We deduce that for the BPMA stakeholders ordering constrains are of vital importance and belong to the essential model information to be preserved. Hence, we interpret "Use Case 14: Retrieve Coarse-grained Activities" as an example of a false BPMA use case and drop it from the final catalog.</p><p>During the evaluation of use cases that belong to Group 1 the participants noticed that the elimination of insignificant activities often leads to unacceptable information loss. Instead of eliminating insignificant activities, the interviewees saw benefits of aggregating them. We summarize these user requests in a new use case.</p><p>Use Case 15: Preserve Frequent Activities Summarizing Rare Activities The user analyzes a process captured in a detailed process model. She has to focus on activities relevant for the current analysis. The distinction between significant and insignificant activities bases on the threshold value of an activity frequency: the activities with a frequency value lower than the threshold are insignificant. Signifi-cant activities are preserved as-is, while insignificant activities are aggregated, when possible.</p><p>The introduction of this use case raises the issue whether a whole new family of use cases should be created that is based on the initial members of Group 1. However, despite the external similarity to the use cases of Group 1, such new use cases would heavily rely on the technique needed for "Use Case 13: Get Process Quick View Respecting Roles". As such, we decided not to pursue this larger extension.</p><p>Interviewees also pointed to BPMA scenarios where only model elements relevant for a certain perspective, e.g., a business perspective or a data flow perspective, are presented to the user. Notice that this abstraction depends on the existence of information that is relevant to make this distinction in the initial process model. Abstractions of this type belong to Group 4: Filter Model Elements. We formulate the user demand in the following use case:</p><p>Use Case 16: Get Particular Process Perspective The user analyzes a process model captured in a detailed process model. She wants to see a particular process perspective. Model elements which belong to the desired perspective are significant and preserved in the model as-is. Model elements which do not belong to this perspective are insignificant and are eliminated.</p><p>No needs for further use cases were found. In sum, this leads us to a final set of 15 use cases, which is one of the contributions of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Additional insights</head><p>While the second phase in our validation approach mainly aimed at the relevance and completeness of the use case catalog, the discussions with the involved participants raised additional insights. First of all, other visualization techniques came forward as important alternatives to deal with some of the use cases. In particular, we can distinguish the following techniques that were brought forward:</p><p>1. Highlighting Instead of completely abstracting from model objects that do not need to be visualized, it is also possible to highlight the objects that deserve attention, for example by coloring these or changing their shape. The main advantage is that it provides the context of the highlighted objects. A good example where this could be useful is "Use Case 6: Preserve Frequent Instances", where a "happy path" is highlighted within the process model. 2. Tagging Depending on the exact use case, it may be important to see more rather than less information in a process model, which is the objective of BPMA. Such additional information could be presented as tags, annotations or even icons that are added to existing process model elements. For instance, in the context of "Use Case 13: Get Process Quick View Respecting Roles" it could also be useful to see relevant role information along with tasks in the model. 3. Animation While BPMA is focused on the static representation of process model content, for some use cases a more dynamic representation mode is desirable. Specifically, for the use cases in Group 2 (Preserving Relevant Process Instances) it is useful to see how a particular process evolution unfolds step-by-step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Textual Reporting</head><p>For the considered use cases, it is not always important to obtain the information that one seeks in the form of a process model. Instead, a textual or tabular enumeration can suffice. Recall that we dropped "Use Case 14: Retrieve Coarse-grained Activities" as a use case for BPMA, even though the participants can imagine the intended overview to be relevant in the form of a tabular visualization.</p><p>This overview is by no means meant as comprehensive, but it puts the importance of BPMA into the right perspective. After all, it would be improper to consider BPMA as the only viable way to present relevant information in a process model. At the same time, we do argue that the value of BPMA in comparison with other techniques can be explicitly found in use cases that involve very large process models. For all of the alternatives we listed, one can foresee a range of problems in such cases. For example, if highlighting is applied in an extremely large process model, it will become difficult to distinguish, let alone focus, on the emphasized objects.</p><p>A final insight relates to the specific feedback of one of the participants, who argued that he did not see value in BPMA for any of the proposed use cases. He explained that in his environment a strictly hierarchical modeling approach is employed, such that each process is modeled on five different levels of granularity (using subprocesses). Therefore, according to this participant, the BPMA techniques add limited additional value with respect to navigating through these levels. Clearly, it is open to debate whether switching between subprocesses can provide exactly the same insights as the BPMA techniques do. Yet, it is important to realize that built-in features of process models can of course greatly contribute to an improvement of large process model understanding. This is also in line with our earlier work on the value of modularity <ref type="bibr" target="#b43">[44]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Case study</head><p>Whilst the previous section explored the BPMA problematics in breadth, this section provides an in depth study. Such a shift in the argumentation reveals the technical aspects of BPMA that complement the high-level discussion of the earlier sections. We present a case study on the design of a BPMA technique motivated by a specific industry demand and supporting use case "Use Case 12: Get Process Quick View Respecting Ordering Constraints". In particular, we report on the solution developed to support the BPM initiative at AOK Brandenburg-a large health insurance company located in Teltow, Germany. We start by describing the project initial setting and the goal in Section 5.1. Furthermore, in Section 5.2 we outline the developed solution and illustrate it by the example. The detailed technical description of the discussed BPMA approach can be found in <ref type="bibr" target="#b39">[40]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Case motivation</head><p>AOK captures its operational processes in about 4 000 Event-driven Process Chains (EPCs) <ref type="bibr" target="#b22">[23]</ref>. EPCs allow designers to model activities as functions visualized by rectangles, process states as events visualized by hexagons, and routing decisions as Fig. <ref type="figure">5</ref> EPC example connectors captured as circles. Figure <ref type="figure">5</ref> provides an EPC example, where Function 1, Event 1, and XOR exemplify functions, events, and connectors, respectively. The functions, events, and connectors are the nodes of the graph, where the edges express the process ordering constraints. The edges are called connections. Finally, EPCs classifies connectors into XOR, AND, and OR with respect to the routing logic and into splits and joins with respect to the number of incoming/outgoing edges. A connector is a split if it has multiple outgoing edges and a join if it has multiple incoming edges. A XOR split activates exactly one outgoing branch, an AND split-all outgoing branches, while an OR split activates at least one. A XOR join awaits for one incoming branch, an AND join for all incoming branches, while the semantics of OR joins is non-trivial <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b29">30]</ref>. In Fig. <ref type="figure">5</ref> we observe an example of a XOR split connector. The EPC designers are not limited to creation of block-structured process models, i.e., the EPCs are arbitrarily structured. The models are enriched with information about the time required to complete each activity and probabilities of connection transitions from the source to the target. AOK uses such process models to evaluate the number of employees required to enact all process instances. However, some of the models contain exhaustive details impeding their comprehension by humans. Figure <ref type="figure" target="#fig_3">6</ref>(a) presents an example of a process model from the AOK repository. The process model is composed of 333 nodes: 130 functions, 137 events, and 66 connectors. The existence of this model and similar ones within AOK have created a demand for the use of techniques that can help deliver more abstract process representations. In particular, AOK business analysts are interested in models that contain more coarse-grained activities. An important constraint here is that the BPMA to be applied has to deliver process models containing high-level activities summarizing the content of the initial model.</p><p>Obviously, the BPMA technique to be selected is framed by the mentioned requirements. Specifically, the abstraction should preserve the ordering constraints of a process model and the time required to complete the process. While the former requirement is essential, the latter originates from the fact that process models are used in the head counting task, where process completion time is key. From a technical perspective, the BPMA should also deliver process models that are valid EPCs. The model's arbitrary structure motivated the development of a new BPMA technique: the available solutions handled only block-structured process models, see, e.g., <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b27">28]</ref>. The next section presents the designed solution. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Developed BPMA technique</head><p>The developed BPMA considers activities as abstraction objects. The abstraction criterion is the activity completion time: activities consuming more time to complete are considered to be more significant to display. To preserve process non-functional properties, aggregation is selected as the basic abstraction operation. The model transformation is then realized as a composition of aggregation operations. The aggregation operations are referenced as elementary abstractions and are distinguished into four types:</p><p>-sequential abstraction -block abstraction -loop abstraction -dead end abstraction.</p><p>Each elementary abstraction is associated with a certain type of EPC fragment and defines how this fragment is transformed. Figure <ref type="figure">7</ref> illustrates the structural effect of elementary abstractions. While here we briefly sketch the elementary abstractions, the reader may consult <ref type="bibr" target="#b39">[40]</ref> for the detailed rules specifying how the model transformations are realized and process non-functional properties are re-evaluated.</p><p>Sequential elementary abstraction transforms process fragments that are sequences-fragments formed by a function, followed by an event, followed by a function. Figure <ref type="figure">7</ref>(a) exemplifies the corresponding sequential abstraction. Functions f 1 , f 2 , and event e 1 form a sequence. As a result of sequential abstraction, a sequence is replaced by an aggregating function f S . Semantics of the aggregating function is the following: function f 1 is executed and afterwards function f 2 occurs with the probability equal to the probability of reaching function f 2 from f 1 in the initial process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 7 Four elementary abstractions realizing the BPMA technique</head><p>An EPC process fragment is a block if (1) it starts with a split and ends with a join connector of the same type, (2) all paths from the split connector lead to the join connector, (3) there is at most one function on each path, (4) each path between the split and the join contains only events and functions, (5) the number of the outgoing connections of the split connector equals the number of the incoming connections of the join connector, and (6) the split connector has one incoming connection and the join connector-one outgoing. Figure <ref type="figure">7(b)</ref> shows an example of a block. After block abstraction, an original process fragment is replaced by an event, followed by an aggregating function, followed by another event. Events are added to assure that a new EPC is well-formed. This abstraction approach can supports AND, OR, and XOR connectors. Semantics of the aggregating function conforms to the semantics of the abstracted block and depends on the block type. For instance, in case of a XOR block the aggregating function f B means that only one function of the abstracted fragment is executed.</p><p>Often one or several tasks are iterated within a process. To abstract from such process cycles we introduce the loop elementary abstraction. An EPC process fragment is a loop if (1) it starts with a XOR join connector and ends with a XOR split connector, (2) the process fragment does not contain any other connector, (3) the XOR join has exactly one outgoing and two incoming connections, (4) the XOR split has ex-actly one incoming and two outgoing connections, ( <ref type="formula">5</ref>) there is exactly one path from the split to the join and exactly one path from the join to the split, and ( <ref type="formula">6</ref>) there is at least one function in the process fragment. Abstraction replaces the whole process fragment corresponding to a loop by one aggregating function f L , see Fig. <ref type="figure">7(c</ref>). To assure that the resulting EPC is well-formed we add an extra event e 0 between the functions f 0 and f L . The aggregating function states that functions f 1 and f 2 are executed iteratively.</p><p>Dead end elementary abstraction allows to conceal alternative process terminations described by "spaghetti-like" models. We claim an EPC process fragment to be a dead end if it consists of a function, followed by a XOR split connector, followed by an event, followed by a function, followed by an end event. We require the XOR split connector to have exactly one incoming connection. Figure <ref type="figure">7(d)</ref> illustrates the mechanism of the dead end abstraction. Functions f 0 and f k , events e k and e k+1 and the XOR split connector constitute the dead end. The XOR split has k outgoing branches and after the abstraction the k-th branch is removed. On the right side of Fig. <ref type="figure">7(d</ref>) the abstracted process is presented. As a result of abstraction, a XOR split branch which belongs to a dead end is removed from a process model. Function f 0 is replaced by an aggregating function f D . An aggregating function in dead end abstraction has the following semantics: upon an occurrence of function f D in a process, function f 0 is executed. Afterwards, function f k may be executed. If function f k is executed the branch is terminated and f D is not left, otherwise the execution of the branch continues.</p><p>The design of elementary abstractions allows to preserve the ordering constraints, as well as the process completion time. Given the elementary abstractions, the BPMA can be described as follows. First, insignificant process model elements are identified. Next, elementary abstractions are applied. For every insignificant activity to be abstracted, starting from the least significant one, the abstraction algorithm tries to apply transformation rules. If one of the elementary abstractions can be employed, an activity is aggregated. The aggregating activity is tested, whether it is significant or not. If it turns out that the aggregating activity is insignificant, it has to be abstracted in the subsequent steps. The algorithm works until all the activities in the model are significant, i.e., pass the threshold. It could also be the case that there are insignificant activities that cannot be reduced, as elementary abstractions can not handle them. This is the effect of the best effort principle. Therefore, the described abstraction mechanism guarantees that it abstracts a process model at a best effort basis, bringing the process model either to the required abstraction level or to the state when no elementary abstraction operation can be applied.</p><p>Figure <ref type="figure" target="#fig_3">6</ref>(b) shows the result of abstraction model shown in Fig. <ref type="figure" target="#fig_3">6</ref>(a) using the presented BPMA technique. After abstraction, the number of process model nodes was reduced to 167: 44 functions, 82 events, and 41 connectors. The overall reduction of process nodes is near 50% of its original size.</p><p>The proposed abstractions allow a company to deal with coarse-grained functions in business processes, while keeping the overall process logic intact. In terms of organization and management, these coarse-grained functions (with the associated execution effort being measured in minutes rather than of seconds) facilitate process improvement on a higher level. Tedious discussions on extremely low granularity functions are no longer required. Instead, process participants can apply improvements within the functions, keeping the overall process logic in sync with the process model.</p><p>The presented case study provides the insights into the technical details of BPMA. While the developed BPMA technique addresses use case "Use Case 12: Get Process Quick View Respecting Ordering Constraints", it also takes into account the specific requirements of the industry partner: order preservation and evaluation of non-functional properties in the process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related work</head><p>The derived catalog of use cases as presented in Sect. 4 systematically describes BPMA from an application perspective. In the previous section, we have also illustrated how a specific BPMA is applied in a realistic setting and how the involved algorithm operates. However, a similar detailed understanding of all available techniques is missing at this point. In this section, we will reflect on how the use cases in our catalog are supported by the available techniques, building on our understanding of the state of the art. Furthermore, by providing the links between the use cases in the catalog and the available techniques we can identify which use cases and which aspects of BPMA are calling for further research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">BPMA state of the art</head><p>Scientific papers that describe BPMA techniques by no means always use this exact label, but rather refer to developing process views, see <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b17">18]</ref>, or focus on process simplification, see <ref type="bibr" target="#b20">[21]</ref>. However, the essential purpose of these techniques is in line with the way we characterized BPMA in this paper. While in a number of papers, e.g., <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b46">47]</ref>, generic BPMA techniques are discussed, others address concrete use cases, see <ref type="bibr" target="#b17">[18]</ref>. In this section we present an overview of the available BPMA techniques, which is preceded with a short technique summary.</p><p>• Cardoso et al. <ref type="bibr" target="#b9">[10]</ref> Propose a quality of service evaluation method for workflows enriched with information on transition probability and activity execution time/cost. • Liu and Shen <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b46">47]</ref> Suggest an order-preserving BPMA approach making use of reduction rules developed in <ref type="bibr" target="#b45">[46]</ref>. • Chiu et al. <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref> Focuse on the BPMA in the context of cross-organizational interaction, where the generic model captures overall interaction, while abstract models are partner-specific. <ref type="bibr" target="#b37">[38]</ref> Adapt the principles of views in relational databases to the context of business process models delivering operations for constructing abstract process specification. • Günther and van der Aalst <ref type="bibr" target="#b20">[21]</ref> Develop an abstraction technique for process models mined from logs, where the technique exploits metrics based on log information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• Pankratius and Stucky</head><p>• Bobrik et al. <ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref> Propose a BPMA approach with an emphasize on how aspect, specifying basic abstraction rules and their composition rules. • Eshuis and Grefen <ref type="bibr" target="#b17">[18]</ref> Address the BPMA scenario, where an internal process model is adapted for an external partner in two steps: (1) the private details are concealed, (2) excessive information is hidden. • Polyvyanyy et al. <ref type="bibr" target="#b40">[41,</ref><ref type="bibr" target="#b41">42]</ref> Argue that process model decomposition can be employed in BPMA and develop abstraction algorithms based on decomposition.</p><p>In the remainder, we will elaborate on each approach using the formalism introduced in Sect. 3. Also, each approach is positioned against the use cases elaborated in Sect. 4. To illustrate the approaches we employ examples in the notations of the original papers. After the discussion of each individual approach, we will provide a condensed view at the end of this section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.1">Cardoso et al.</head><p>In <ref type="bibr" target="#b9">[10]</ref> Cardoso et al. evaluate the workflow quality of a service. The authors assume that every workflow activity is annotated with a non-functional property value, e.g., execution time or cost, and an execution probability. Quality of service for a workflow is evaluated through aggregation of workflow activities, where non-functional properties of an aggregating activity are determined by the properties of the aggregated ones. The paper considers activities as abstraction objects and utilizes aggregation as the basic abstraction operation. The proposed solution addresses the BPMA problem, in particular use cases of group "Group 1: Preserving Relevant Activities" and use cases "Use Case 12: Get Process Quick View Respecting Ordering Constraints" and "Use Case 13: Get Process Quick View Respecting Roles". The paper particularly concentrates on the how component of BPMA. While the employed model is formalized as a graph, with nodes being tasks and edges being transitions between tasks, the process model is completely block-structured. In such a setting the authors specify the abstraction algorithm based on patterns and corresponding reduction rules. Once a workflow fragment is matched against a pattern, it is reduced according to the reduction rule. Four patterns are identified: sequence, AND block, XOR block, and two types of loop blocks. Figure <ref type="figure">8</ref> demonstrates the application of these rules to model m in Fig. <ref type="figure">8(a)</ref>. The reduction rules for sequence, AND block, and the loop block are applied to fragments seq, and, and loop, respectively. The resulting abstract model is presented in Fig. <ref type="figure">8(b)</ref>. The reduction rules specify not only the structural transformations, but also the non-functional properties evaluation method.</p><p>Fig. <ref type="figure">8</ref> Illustration of the BPMA approach developed by Cardoso et al. in <ref type="bibr" target="#b9">[10]</ref> Fig. <ref type="figure">9</ref> Illustration of the BPMA approach developed by Liu and Shen in <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b46">47]</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.2">Liu and Shen</head><p>In <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b46">47]</ref> Liu and Shen study the construction of process views and, in particular, order-preserving process views. The paper regards activities as the abstraction objects and employs aggregation as the basic abstraction operation. The proposed BPMA approach can support the use cases of group "Group 1: Preserving Relevant Activities" along with use cases "Use Case 9: Adapt Process Model for an External Partner", "Use Case 12: Get Process Quick View Respecting Ordering Constraints", "Use Case 13: Get Process Quick View Respecting Roles", and "Use Case 15: Preserve Frequent Activities Summarizing Rare Activities".</p><p>The authors provide a formal definition of a process model and specify a process execution semantics. The formalism allows for one type of model nodes, activities, that may realize the splitting and joining logic of ANDs and XORs. Loop dependency is considered as a special dependency type and process models may contain only single entry-single exit loops. Figure <ref type="figure">9</ref> presents process model examples that adhere to the notation used in <ref type="bibr" target="#b26">[27]</ref>. The paper elaborates on an algorithm for abstract process model construction based on the reduction rules proposed in <ref type="bibr" target="#b45">[46]</ref>. The algorithm obeys three principles: activity membership, activity atomicity, and order preservation. The latter principle is of great practical importance and is thoroughly discussed in the paper. The order preservation requires the BPMA to preserve the ordering constraints of the initial model in the abstract model. The example in Fig. <ref type="figure">9(a)</ref> illustrates capabilities of the BPMA approach. While aggregations a1 and a2 violate the declared principles, a3 is valid. Figure <ref type="figure">9</ref>(b) presents the result of order-preserving abstraction: activities e, f , g, and h in the initial model are aggregated, see Fig. <ref type="figure">9(a)</ref>. While the paper elaborates on the BPMA how, it does not discuss the why and when questions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.3">Chiu et al.</head><p>Chiu et al. discuss the BPMA in the context of cross-organizational interaction in a web service environment <ref type="bibr" target="#b10">[11]</ref>. The authors concentrate on the use case, where an exhisting process model describes interorganizational interaction, while partner-specific models hiding confidential details are in demand. Effectively, this approach maps to "Use Case 9: Adapt Process Model for an External Partner". The BPMA approach selects activities as abstraction objects and uses elimination as the basic abstraction operation to deliver partner-specific views and narrow the scope within a party. The paper argues about the BPMA how, delegating the why and when questions to the human user. Chiu et al. employ UML activity diagrams to capture processes and introduce a metamodel for workflow views. The metamodel defines a view as a graph with activities that can be organized into sequences, enriched with choice logic. Each activity can either be optional or iterative. Figure <ref type="figure" target="#fig_4">10</ref> illustrates the approach: Model m in Fig. <ref type="figure" target="#fig_4">10(a</ref>) is the initial model, while abstract model m a in Fig. <ref type="figure" target="#fig_4">10(b</ref>) captures the process from the point of view of one participant. The paper informally discusses the transition from the initial model to the abstract one. The authors argue that the partner interaction specified in the initial UML activity diagram can be captured on the high level by means of a sequence diagram. The paper gives the general idea of such a transformation. Figure <ref type="figure" target="#fig_4">10</ref>(c) presents an example of a sequence diagram that can be mined from the initial model m. Finally, the paper specifies consistency criteria for process model views with respect to the initial model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.4">Pankratius and Stucky</head><p>Pankratius and Stucky relate process views to views in relational databases <ref type="bibr" target="#b37">[38]</ref>. The authors define process models as Petri nets and adapt relational database operations to the Petri net formalism. This results in eight operations enabling process view creation: selection, difference, place projection, transition projection, place join, transition join, theta join, and union. The designed operations may support the BPMA approach, where activities and, potentially, events can be considered as abstraction objects. Elimination and aggregation can be realized through place projection and transition projection, respectively. Figure <ref type="figure">11</ref> exemplifies an application of place projection and transition projection for a BPMA realization. Figure <ref type="figure">11(a)</ref> shows process model m, with two fragments, tx and px to be abstracted. Application of a transition Fig. <ref type="figure">11</ref> Illustration of the BPMA approach developed by Pankratius and Stucky in <ref type="bibr" target="#b37">[38]</ref> projection to fragment tx and place projection to fragment px in m results in transition tx and place px in model m a , respectively. Figure <ref type="figure">11(b</ref>) exhibits the abstract model m a .</p><p>It should be noted that the developed operations consider only the structure of Petri nets, ignoring the execution semantics. As a consequence, important properties, e.g., soundness, of delivered process models may be violated <ref type="bibr" target="#b54">[55]</ref>. In essence, the paper addresses the BPMA how. The developed BPMA technique supports use cases of group "Group 1: Preserving Relevant Activities" together with use cases "Use Case 9: Adapt Process Model for an External Partner", "Use Case 12: Get Process Quick View Respecting Ordering Constraints", "Use Case 13: Get Process Quick View Respecting Roles", "Use Case 15: Preserve Frequent Activities Summarizing Rare Activities", and "Use Case 16: Get Particular Process Perspective".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.5">Günther and van der Aalst</head><p>In <ref type="bibr" target="#b20">[21]</ref> Günther and van der Aalst investigate the simplification of "spaghettistructured" process models as mined from event logs. The paper addresses all three aspects of BPMA: why, when, and how. The authors choose activities and edges as abstraction objects. The abstraction mechanism assumes the availability of substantial process logs enriched with activity and transition frequencies. The authors elaborate on how this information can be used within BPMA. They suggest metrics, e.g., activity frequency, distinguishing significant abstraction objects from insignificant ones. The metrics are classified into significance and correlation metrics and allow to orchestrate basic abstraction operations. Figure <ref type="figure" target="#fig_0">12</ref> exemplifies the abstraction approach. The elements of initial model m are annotated with execution frequencies, see Fig. <ref type="figure" target="#fig_0">12(a)</ref>. In Fig. <ref type="figure" target="#fig_0">12</ref>(b) the edges with low frequencies are eliminated, while Fig. <ref type="figure" target="#fig_0">12(c</ref>) shows the aggregation of activity aggregation. The designed BPMA approach is potentially capable of supporting the use cases of groups "Group 1: Preserving Relevant Activities" and "Group 2: Preserving Relevant Process Instances" and use cases "Use Case 12: Get Process Quick View Respecting Ordering Constraints", "Use Case 13: Get Process Quick View Respecting Roles", "Use Case 15: Preserve Frequent Activities Summarizing Rare Activities", and "Use Case 16: Get Particular Process Perspective". Fig. <ref type="bibr" target="#b11">12</ref> Illustration of the BPMA approach developed by Günther and van der Aalst in <ref type="bibr" target="#b20">[21]</ref> The authors formalize a process model as a graph, where nodes are activities, and edges-control flow relation. Unfortunately, such a simplistic model limits the applicability of the approach to some extent, as process modeling notations typically specify more than one node type. Moreover, the assumed availability of rich process logs is rather restrictive: Models are rarely enriched with such detailed execution information. <ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref>. The authors concentrate on the BPMA's how component, leaving the why and when out of scope. These works consider activities as the abstraction objects. The basic abstraction operations are aggregation and elimination. The developed BPMA method addresses use cases of group "Group 1: Preserving Relevant Activities" along with use cases "Use Case 9: Adapt Process Model for an External Partner", "Use Case 12: Get Process Quick View Respecting Ordering Constraints", "Use Case 13: Get Process Quick View Respecting Roles", "Use Case 15: Preserve Frequent Activities Summarizing Rare Activities", and "Use Case 16: Get Particular Process Perspective".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.6">Bobrik et al.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Bobrik et al. study process views in</head><p>The process model is formalized as a graph with two node types, activities and gateways (subsequently typed to ORs, XORs, and ANDs), and the edges representing the control flow. Aggregation and elimination make use of the single entry single exit (SESE) fragments-fragments with exactly one incoming and exactly one outgoing edge. Elimination substitutes a SESE fragment with an edge, while aggregationwith an activity. The paper studies the BPMA properties, paying attention to controlflow preservation</p><p>Along with the model views, the authors discuss view construction for visualizations of process instances. The distinction of completed and not completed activities allows to extend basic abstraction operations beyond SESE fragment transformations: The completed activities are abstracted in a more flexible fashion. Figure <ref type="figure" target="#fig_1">13</ref> illustrates the proposed BPMA approach. The initial model m is shown in Fig. <ref type="figure" target="#fig_1">13(a)</ref>. Two basic abstraction operations are sequentially applied. SESE fragment sese1 is eliminated, resulting in model m a , see Fig. <ref type="figure" target="#fig_1">13(b</ref>). Then, fragment sese2 is aggregated resulting model m a , see Fig. <ref type="figure" target="#fig_1">13(c</ref>).</p><p>Fig. <ref type="bibr" target="#b12">13</ref> Illustration of the BPMA approach developed by Bobrik et al. in <ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref> Fig. <ref type="figure">14</ref> Illustration of the BPMA approach developed by Eshuis and Grefen in <ref type="bibr" target="#b17">[18]</ref> 6.1. <ref type="bibr" target="#b6">7</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Eshuis and Grefen</head><p>In <ref type="bibr" target="#b17">[18]</ref> Eshuis and Grefen are challenged by the adaptation of process models to support interorganizational communication. The designed approach has two steps: (1) the process owner specifies internal activities to be aggregated, (2) the process consumer omits and hides unnecessary activities. The selection of activities to be abstracted is manual. Thereby, the paper focuses on the BPMA how, ignoring why and when. The paper selects activities as the abstraction object. Aggregation and elimination are employed as basic abstraction operations. While the paper directly addresses use case "Use Case 9: Adapt Process Model for an External Partner", the developed BPMA approach indirectly supports the use cases of group "Group 1: Preserving Relevant Activities" and use cases "Use Case 9: Adapt Process Model for an External Partner", "Use Case 12: Get Process Quick View Respecting Ordering Constraints", "Use Case 13: Get Process Quick View Respecting Roles", "Use Case 15: Preserve Frequent Activities Summarizing Rare Activities", and "Use Case 16: Get Particular Process Perspective".</p><p>The processes are captured in UML Activity Diagrams. The formalization of a process model restricts models to block-structured ones, allowing AND and XOR blocks along with loops. The approach ensures that the resulting abstract models are order-preserving. The first phase is based solely on activity aggregation, concealing the private activities. Figure <ref type="figure">14</ref>(a) captures the initial model m, where the user selects to aggregate activities b and d. Figure <ref type="figure">14(b)</ref> shows the abstraction result: activities b, c, and d are aggregated into bcd. Activity c is aggregated, as the BPMA approach constructs order-preserving views. The second phase, customization, employs aggregation and elimination to preserve only activities demanded by the consumer. In the example model m a , see Fig. <ref type="figure">14(b)</ref>, the user preserves activities a, bcd, and g. Model m a in Fig. <ref type="figure">14</ref> shows the final result of abstraction, where irrelevant activities are hidden.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.8">Polyvyanyy et al.</head><p>In <ref type="bibr" target="#b40">[41,</ref><ref type="bibr" target="#b41">42]</ref> Polyvyanyy et al. study how process model decomposition supports BPMA. The developed BPMA approaches make use of aggregation as basic abstraction operation and choose activities as abstraction objects. The papers superficially discuss BPMA why and when, bringing how in the focus of the discussion. The developed BPMA technique supports use cases of group "Group 1: Preserving Relevant Fig. <ref type="bibr" target="#b14">15</ref> Illustration of the BPMA approach developed by Polyvyanyy et al. in <ref type="bibr" target="#b40">[41,</ref><ref type="bibr" target="#b41">42]</ref> Activities", as well as use cases "Use Case 9: Adapt Process Model for an External Partner", "Use Case 12: Get Process Quick View Respecting Ordering Constraints", "Use Case 13: Get Process Quick View Respecting Roles", "Use Case 15: Preserve Frequent Activities Summarizing Rare Activities", and "Use Case 16: Get Particular Process Perspective".</p><p>The paper formalizes a process model as a graph, where nodes are activities and gateways (ANDs and XORs), and edges correspond to the control flow. However, the obtained results can be extended for BPMN, see <ref type="bibr" target="#b47">[48]</ref>. While <ref type="bibr" target="#b40">[41]</ref> decomposes the model into fragments with exactly one incoming and exactly one outgoing edge, <ref type="bibr" target="#b41">[42]</ref> seeks for fragments having exactly one entry node and exactly one exit node. The latter approach results in more fine-grained decomposition making the BPMA more flexible. The proposed BPMAs are order-preserving. The approach is illustrated by the example in Fig. <ref type="figure">15</ref>. Figure <ref type="figure">15(a)</ref> shows the initial model m, where fragments S and R can be aggregated. Figure <ref type="figure">15</ref>(b) presents the abstraction result with the given fragments being aggregated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.9">Summary</head><p>Table <ref type="table" target="#tab_3">2</ref> summarizes the main properties of the aforementioned BPMA techniques. One can notice that the majority of BPMA approaches put the focus on the how component, leaving why and when mostly out of scope. However, even within the how aspect the focus is on the structural side of the model transformation. Typically, the decision which activities should be abstracted is delegated to the user. Furthermore, the business meaning of the coarse-grained activities created during abstraction has to be defined by the user as well. The question is whether without an more elaborate link with the why and when components it is possible for business users to adopt these techniques and link them to their needs. As can be seen, activities dominate the "abstraction object" column of Table <ref type="table" target="#tab_3">2</ref>. This confirms that in practice the end users perceive activities to be in the center of BPMA. The observation is supported by the analysis of the use cases addressed by the existing techniques: The majority focuses on activities. Indeed, most approaches are capable of supporting use cases of group "Group 1: Preserving Relevant Activities", as well as use cases "Get Process Quick View Respecting Ordering Constraints" and "Get Process Quick View Respecting Roles".</p><p>Finally, Table <ref type="table" target="#tab_3">2</ref> bears witness of the fact that the elimination π and aggregation σ are used relatively homogeneously. However, the aggregation prevails the table, being used in each BPMA technique, but one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">BPMA related papers</head><p>We recognize a series of papers that do not target BPMA specifically, yet notice that full-fledged BPMA can profit from their insights. In particular, we refer to the works on process model transformation, workflow inheritance, intermodel consistency, and model integration.</p><p>Among the papers on process model transformation, work is available on reduction rules and process model decomposition. Within decades the Petri net community studied reduction rule sets facilitating analysis of process models. In <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5]</ref> Berthelot suggested a rule set capable of reducing live and bounded marked graphs to a single transition. Murata proposed reduction rules preserving the liveness, safeness, and boundedness properties in <ref type="bibr" target="#b32">[33]</ref>. Desel and Esparza came up with a complete set of reduction rules for free-choice Petri nets, see <ref type="bibr" target="#b13">[14]</ref>. Reference <ref type="bibr" target="#b45">[46]</ref> developed a set of graph reduction rules for identification of structural conflicts in process model. Recently, van Dongen and Mendling used reduction rule sets for analysis of process model soundness, see <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b31">32]</ref>. In the context of BPMA, for every set of reduction rules it is essential to show that one of the following statements holds:</p><p>-The set of reduction rules is complete to abstract a process model of an arbitrary structure into one node. -There is a description of the class of models that can be reduced to one node by this set of rules.</p><p>As in practice process models have an arbitrary, non-compositional structure, the above requirements are highly relevant to reflect on the applicability of a set of reduction rules. Process model decomposition approaches are free of this limitation: they enable unique decomposition of a process model into a hierarchy of fragments. The generic results for decomposition of graphs have been obtained by Johnson, Pearson, and Pingali in <ref type="bibr" target="#b21">[22]</ref> and Tarjan and Valdes in <ref type="bibr" target="#b51">[52]</ref>. Later Vanhatalo et al. adapted these decomposition techniques for business processes <ref type="bibr" target="#b52">[53,</ref><ref type="bibr" target="#b53">54]</ref>. We argue that both reduction techniques and decomposition techniques have the potential to support elimination and aggregation as the most prominent forms of abstraction.</p><p>Preservation of process model behavior during model transformation can be defined in several ways. In <ref type="bibr" target="#b1">[2]</ref> Van der Aalst and Basten use Petri nets as process formalism and define the notion of process inheritance, which relates to the behavioral aspect of the model. In particular, they identify four types of inheritance: protocol, projection, protocol/projection, and life-cycle inheritance. Further, the authors specify operations on models maintaining inheritance property. The reported work relates to BPMA problem, as models m and m a can be seen as those belonging to one of the proposed inheritance relations.</p><p>While BPMA delivers an abstract process representation given a starting model, multiple models of one process might be already in place. Such models reflect the views of various stakeholders on one business process <ref type="bibr" target="#b24">[25]</ref>. Typically, numerous relations exist between such models, which leads to new challenges in model management. Thereafter, the BPM community has thoroughly studied such models and their relations. In the remainder of this section we present the related work according to the type of considered intermodel relations and the associated model management task.</p><p>First, it is crucial to manage the consistency of multiple process specifications. In <ref type="bibr" target="#b15">[16]</ref> Dijkman et al. addressed the problem of information system design, where multiple stakeholders contribute to the system creation. The authors developed a framework suggesting (1) the use of basic concepts shared by the stakeholders to be facilitate communication, <ref type="bibr" target="#b1">(2)</ref> means to manage consistency between relations of system specifications. Further, the paper illustrates the applicability of the approach, establishing relations between structural and behavioral models. Recently, Weidlich et al. investigated the consistency relation of models formalizing one business process, see <ref type="bibr" target="#b55">[56,</ref><ref type="bibr" target="#b56">57]</ref>. While <ref type="bibr" target="#b56">[57]</ref> focuses on the behavioral aspects of process model, <ref type="bibr" target="#b55">[56]</ref> studies methods for identification of correspondence relations between elements of different specifications. The existence of multiple models for one object is inherent not only for BPM, but also for software engineering and requirements engineering. Finkelstein et al. in <ref type="bibr" target="#b18">[19]</ref> argued that model inconsistencies are inevitable and suggested a formal approach to deal with them. <ref type="bibr" target="#b34">[35]</ref> suggested a framework for managing multiple views and their inconsistencies in the context of requirements engineering. The aforementioned papers study intra-and intermodel relations between model elements. We believe that their results can be useful in the context of BPMA when and how.</p><p>Second, the multiple models of a process can be seen as its "partial" models: each model presents one perspective on the subject. Integration of such partial models into one facilitates more comprehensive process understanding. Preuner, Conrad, and Schrefl designed a method for integration of models that capture business object life cycles <ref type="bibr" target="#b42">[43]</ref>. Two integration types are distinguished: integration of type hierarchies and integration of behavior of object types. The integration makes use of generalization/specialization and extension/refinement operations. In <ref type="bibr" target="#b30">[31]</ref> Mendling and Simon propose another approach for process view integration. The approach implies that one business process can have several specifications, each-an EPC model. Further, it assumes that the correspondences between elements of different models are known. Given two views of one business process and the element correspondences, the approach delivers an integrated process model. The relations between the integrated model and the initial models can be traced back to relation between m and m a , respectively.</p><p>Table <ref type="table">3</ref> Existing techniques related to identified BPMA use cases 6.3 Use case catalog as a research compass</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.1">Retrospective</head><p>Table <ref type="table">3</ref> provides correspondences between the use cases from the catalog and the existing techniques for BPMA. Notice that the table refers to the works directly addressing BPMA along with the techniques potentially helpful in BPMA context. A table row specifies the papers related to one or several use cases from the catalog. The columns distinguish the papers according to the three BPMA aspects: why, when, and how. The how aspect further refines the classification into papers on process model transformation and papers specifying how to apply abstraction algorithms for BPMA.</p><p>Table <ref type="table">3</ref> allocates several papers on dedicated rows by which we emphasize the role of these works. References <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b39">40]</ref> propose comprehensive solutions for particular BPMA use cases. By this, we mean that the papers discuss all the three aspects of BPMA. We emphasize <ref type="bibr" target="#b9">[10]</ref>, as it discusses not only a structural perspective on model transformations, but also the principles for the evaluation of non-functional properties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.2">Perspective</head><p>Another look at Table 3 reveals a disproportion in the related work: as the how is thoroughly investigated, the why and when are hardly touched upon. The why calls for research on how the user can formulate the abstraction goal and what the frontier is of BPMA's application. The when question is concerned with the definition of the sign function, which can be non-trivial, e.g., consider Use Case 9. We conjecture that a more complete coverage of these components will simplify the uptake of the available techniques by industry.</p><p>As we argued earlier, the how also displays some white spots. For instance, a high user demand for Use Case 12 is a strong motivation to develop techniques that deliver aggregations of activities that belong together according to the domain semantics of the model elements. A related problem is how to label an aggregating activity as delivered by an abstraction. Finally, it seems highly interesting to determine when BPMA techniques are preferable over alternative visualization techniques and textual reports.</p><p>Furthermore, even the referenced techniques provide only partial support for some of the use cases. For instance, although <ref type="bibr" target="#b17">[18]</ref> proposes a BPMA approach covering all the aspects of abstraction, the approach is only capable of handling block-structured process models. Similarly, a BPMA technique that is developed in <ref type="bibr" target="#b39">[40]</ref> is restricted by a set of rules that enable this abstraction. Finally, in <ref type="bibr" target="#b20">[21]</ref> Günther and Van der Aalst propose an approach that supports Use Case 12, but it is only capable of handling process models in a very simplistic notation. While the contributions of all these papers are duly acknowledged, it is also apparent that their applicability can be enhanced.</p><p>Table <ref type="table">3</ref> illustrates that BPMA has been studied by a number of researchers and that various techniques have become available in the past years. Yet, there is still considerable room for improvement and extension by tackling the almost unexplored why and when aspects on the one hand and by extending the range of advanced techniques addressing the how one the other.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions</head><p>This paper broadens the view on business process model abstraction based on a thorough investigation of real world BPMA use cases. The paper's contribution is threefold. First, the paper facilitates a better understanding of what business process model abstraction entails by providing a formal framework for BPMA. Second, it elicits the current industry demand for model abstraction, as detailed in the BPMA use case catalog. The third and final contribution is an extensive survey of the state of the art in process model abstraction. For that purpose, the work that is related to the topic of BPMA was described in considerable detail using the framework introduced in this paper. We demonstrated how the use case catalog can be used to relate the identified use cases against the related work. The comparison reveals well studied areas as well as the unexplored fields and challenging opportunities for the future work in process model abstraction.</p><p>Our own interests for future work relate to the area where semantical knowledge of a particular domain can be exploited to enhance the outcomes of BPMA. Specifically, we refer here to our first steps to use knowledge external to a specific process model to determine the relatedness of the activities it contains <ref type="bibr" target="#b48">[49,</ref><ref type="bibr" target="#b49">50]</ref>. Such an approach potentially enhances the quality of automated aggregations considerably. Another line of work that interests us is more oriented to the development of a tool suite that provides integrated support for a whole range of process model manipulations, including BPMA <ref type="bibr" target="#b25">[26]</ref>.</p><p>To conclude, the work that is reported in this paper should be seen within the context of the process modeling discipline, where scientific advances and industrial demands traditionally go hand in hand. It is our hope that this paper will further help to streamline and unify the various academic endeavors to address the real world needs of organizations relying on the use of business process models for a variety of purposes.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2</head><label>2</label><figDesc>Fig. 2 Allocation of business process model abstraction concepts on MOF levels</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3</head><label>3</label><figDesc>Fig. 3 Abstraction object examples</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Definition 4 (Definition 5 (</head><label>45</label><figDesc>Abstraction object correspondence) Let m be a process model with the set of abstraction objects Ω. Let also m a ∈ abstr(m) be a more abstract model of the same business process where the set of abstraction objects is Ω a . An abstraction object correspondence is a surjective binary relation R α ⊆ Ω × Ω a . Since a correspondence relation is surjective, every abstraction object of the process model m a corresponds to at least one abstraction object in the initial process model m. Returning to our running examples we observe the following in the Ab- straction Example 1: -(Generate forecast report, Generate forecast report) ∈ R α -(Prepare data for quick analysis, Perform quick analysis) ∈ R α -(Perform quick data analysis, Perform quick analysis) ∈ R α In the Abstraction Example 2 the distributed process run defined by the upper branch in model m relates to the only remaining distributed process run. Definition 5 formalizes business process model abstraction by means of the abstraction object correspondence relation. Business process model abstraction) Business process model abstraction is a function α : M → M that transforms a process model m with the set of abstraction objects Ω into model m a with the set of abstraction objects Ω a to conceal abstraction objects Ω ⊆ Ω, where ∀ω ∈ Ω : sign(ω) = false such that:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 6</head><label>6</label><figDesc>Fig. 6 Original (a) and abstracted (b) process models (labels are not magnified to protect the interests of the process owner)</figDesc><graphic coords="20,169.04,52.95,218.87,204.47" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 10</head><label>10</label><figDesc>Fig.<ref type="bibr" target="#b9">10</ref> Illustration of the BPMA approach developed by Chiu et al. in<ref type="bibr" target="#b10">[11]</ref> </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>can illustrate two abstraction examples. In another abstraction scenario the user wants to observe "expensive" distributed process runs by means of a model. In this scenario an abstraction mechanism has to analyze all the distributed runs defined by a process model and select those that represent expensive runs. Model m 3 presents the result of abstraction addressing such a user demand: among two alternative runs the most expensive is preserved.</figDesc><table /><note><p>Abstraction Example 1 One abstraction scenario results from a user demand in a high-level process outline, i.e., a model describing coarse-grained activities of the process and the ordering constraints between them. Model m 2 is an example of such a process overview discoverable from model m 1 . In comparison to activities of model m 1 , activities of m 2 are more abstract and each comprises a set of activities that are in the initial model. For instance, activity Perform quick analysis corresponds to the set {Prepare data for quick analysis, Perform quick data analysis}. Thereby, in this scenario the user focuses on the change of activity granularity. Abstraction Example 2</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Use Case 14 does not aim to preserve them. The following use cases belong to this group. Use Case 12: Get Process Quick View Respecting Ordering Constraints The user needs a process specification, capturing coarse-grained activities, as well as the ordering constraints between them. She does not know in advance which abstraction level is sufficient and wants to control this level gradually. The user wants to preserve non-functional properties of the process. Use Case 13: Get Process Quick View Respecting Roles Activities performed by a special role, e.g., Manager, are considered to be significant. The rest of activities are not. Insignificant activities are aggregated into coarse-grained ones, significant activities are preserved as is, and the ordering constraints are preserved where possible. Non-functional properties of the process, e.g., execution time or execution cost, should be preserved. Use Case 14: Retrieve Coarse-grained Activities</figDesc><table><row><cell>4.2.4 Group 4: obtaining a process quick view</cell></row><row><cell>The user needs a business process overview for fast process comprehension. The</cell></row><row><cell>available model is a process specification formalizing every minor detail. A study</cell></row><row><cell>of this model is time consuming and is not necessary for the ongoing work. The</cell></row><row><cell>user needs a representation of this business process on a higher level, capturing more</cell></row><row><cell>coarse-grained activities and overall information about the ordering constraints. For</cell></row></table><note><p>To simplify model comprehension, irrelevant model elements are eliminated. The relevant elements are preserved, as well as the ordering constraints between them. The use cases of this group exhibit common properties: abstraction objects are model elements and a basic abstraction operation is elimination. The ordering constraints between significant model elements are preserved, while non-functional properties of the overall process are changed. Use Case 9: Adapt Process Model for an External Partner The user adapts an existing business process model for the presentation to an external partner. The available model either captures confidential, internal process details, or details which are of no interest to the partner. The user manually marks model elements, which are relevant for inter-organizational collaboration and which are significant. Use Case 10: Trace Data Dependencies The user modifies a data object interface. Beforehand she needs to know which data dependencies exist in the business process. Hence, the significant model elements are those that access the data object of interest. Use Case 11: Trace a Task The user evaluates the effect of an activity in a process model. To achieve this, a transitive closure of model elements dependent on this activity has to evaluated. Model elements of this closure are significant, while other model elements are not. all of the use cases in this group, activities are abstraction objects. Aggregation is the basic abstraction operation. While Use Case 12 and 13 aim to preserve the ordering constraints, Use Case 14 does not consider the ordering constraints. Similarly, as the non-functional properties of the process are preserved by Use Case 12 and Use Case 13,</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1</head><label>1</label><figDesc>Support of BPMA use cases by interviewees</figDesc><table><row><cell>Category</cell><cell cols="2">Use case ID</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>1</cell><cell>2 3</cell><cell>4</cell><cell>5</cell><cell>6</cell><cell cols="5">7 8 9 10 11 12 13 14</cell></row><row><cell>Experienced consultant (5)</cell><cell>2</cell><cell>5 3</cell><cell>3</cell><cell>3</cell><cell>5</cell><cell>1 5 3 3</cell><cell>3</cell><cell>5</cell><cell>3</cell><cell>1</cell></row><row><cell>Novice consultant (5)</cell><cell>-1</cell><cell>1 1</cell><cell>2</cell><cell>1</cell><cell>3</cell><cell>3 2 0 0</cell><cell>2</cell><cell>3</cell><cell cols="2">3 -2</cell></row><row><cell>Experienced vendor (2)</cell><cell>-1</cell><cell>1 1</cell><cell>2</cell><cell>2</cell><cell>2</cell><cell>1 0 1 0</cell><cell>1</cell><cell>2</cell><cell>2</cell><cell>0</cell></row><row><cell>Novice vendor (6)</cell><cell>0</cell><cell>6 0</cell><cell>5</cell><cell>5</cell><cell>6</cell><cell>5 0 4 3</cell><cell>2</cell><cell>6</cell><cell cols="2">3 -1</cell></row><row><cell>Total</cell><cell cols="6">0 13 5 12 11 16 10 7 8 6</cell><cell>8</cell><cell cols="3">16 11 -2</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2</head><label>2</label><figDesc>Existing BPMA techniques    </figDesc><table><row><cell>Name</cell><cell cols="5">Why When How π σ Supported Use Cases Abstraction object</cell></row><row><cell>Cardoso et al.</cell><cell>+</cell><cell>+</cell><cell>+</cell><cell>-+ 12, 13, 15</cell><cell>Activity</cell></row><row><cell>Liu and Shen</cell><cell>-</cell><cell>-</cell><cell>+</cell><cell>-+ 1-4, 9, 12, 13, 15</cell><cell>Activity</cell></row><row><cell>Chiu et al.</cell><cell>-</cell><cell>-</cell><cell>+</cell><cell>+ -9</cell><cell>Activity</cell></row><row><cell>Pankratius and Stucky</cell><cell>-</cell><cell>-</cell><cell>+</cell><cell cols="2">+ + 1-4, 9, 12, 13, 15, 16 Model element</cell></row><row><cell cols="2">Günther and van der Aalst +</cell><cell>+</cell><cell>+</cell><cell>+ + 1-8, 12, 13, 15, 16</cell><cell>Edge, activity</cell></row><row><cell>Bobrik et al.</cell><cell>-</cell><cell>-</cell><cell>+</cell><cell cols="2">+ + 1-4, 9, 12, 13, 15, 16 Activity</cell></row><row><cell>Eshuis and Grefen</cell><cell>-</cell><cell>-</cell><cell>+</cell><cell cols="2">+ + 1-4, 9, 12, 13, 15, 16 Activity</cell></row><row><cell>Polyvyanyy et al.</cell><cell>-</cell><cell>-</cell><cell>+</cell><cell cols="2">-+ 1-4, 9, 12, 13, 15, 16 Activity</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The authors acknowledge the support of the following industry partners: AOK Nordost in Teltow, Germany; Infosys in Bangalore, India; and Pallas Athena in Apeldoorn, The Netherlands. The authors thank Tassilo Glander for sharing his research expertise on map visualization.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The application of Petri nets to workflow management</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M P</forename><surname>Van Der Aalst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Circuits Syst. Comput</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="21" to="66" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Life-cycle inheritance: a Petri-net-based approach</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M P</forename><surname>Van Der Aalst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Basten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICATPN 1997</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1248</biblScope>
			<biblScope unit="page" from="62" to="81" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kugeler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rosemann</surname></persName>
		</author>
		<title level="m">Process Management: A Guide for the Design of Business Processes</title>
		<meeting>ess Management: A Guide for the Design of Business esses<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Checking properties of nets using transformation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Berthelot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Petri Nets</title>
		<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1985">1985. 1986</date>
			<biblScope unit="page" from="19" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Transformations and decompositions of nets</title>
		<author>
			<persName><forename type="first">G</forename><surname>Berthelot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Petri nets</title>
		<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1986">1986. 1987</date>
			<biblScope unit="page" from="359" to="376" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Proviado-personalized and configurable visualizations of business processes</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bobrik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Th</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Reichert</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<publisher>EC-Web</publisher>
			<biblScope unit="page" from="61" to="71" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Parameterizable views for process visualization</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bobrik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Reichert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bauer</surname></persName>
		</author>
		<idno>TR-CTIT-07-37</idno>
		<imprint>
			<date type="published" when="2007-04">April 2007</date>
			<pubPlace>Enschede</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Centre for Telematics and Information Technology, University of Twente</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">View-based process visualization</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bobrik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Reichert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bauer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">BPM 2007</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4714</biblScope>
			<biblScope unit="page" from="88" to="95" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A review and conceptual framework of automated map generalization</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">E</forename><surname>Brassel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Weibel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Geogr. Inf. Sci</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="229" to="244" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Quality of service for workflows and web service processes</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cardoso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sheth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kochut</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Web Semant</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="281" to="308" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Workflow view driven crossorganizational interoperability in a web service environment</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">K W</forename><surname>Chiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Till</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Karlapalem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kafeza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Inf. Technol. Manag</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="221" to="250" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Workflow view based E-contracts in a crossorganizational E-services environment</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">K W</forename><surname>Chiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Karlapalem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kafeza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Distrib. Parallel Databases</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<biblScope unit="page" from="193" to="216" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Workflow Management Coalition: Reference model-the workflow reference model</title>
		<idno>WFMC-TC-1003</idno>
		<imprint>
			<date type="published" when="1995-01">January 1995</date>
			<publisher>Workflow Management Coalition</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Free Choice Petri Nets</title>
		<author>
			<persName><forename type="first">J</forename><surname>Desel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Esparza</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Cambridge University Press</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Semantics and analysis of business process models in BPMN</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Dijkman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dumas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ouyang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Softw. Technol</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1281" to="1294" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Consistency in multi-viewpoint design of enterprise information systems</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Dijkman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A C</forename><surname>Quartel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Van Sinderen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Softw. Technol</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">7-8</biblScope>
			<biblScope unit="page" from="737" to="752" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Verification of the SAP reference models using EPC reduction, state-space analysis, and invariants</title>
		<author>
			<persName><forename type="first">B</forename><surname>Van Dongen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jansen-Vullers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Verbeek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M P</forename><surname>Van Der Aalst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Ind</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="578" to="601" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Constructing customized process views</title>
		<author>
			<persName><forename type="first">R</forename><surname>Eshuis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Grefen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Knowl. Eng</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="419" to="438" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Inconsistency handling in multiperspective specifications</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C W</forename><surname>Finkelstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gabbay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hunter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kramer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Nuseibeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Softw. Eng</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="569" to="578" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">An overview of workflow management: from process modeling to workflow automation infrastructure</title>
		<author>
			<persName><forename type="first">D</forename><surname>Georgakopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hornick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sheth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Distrib. Parallel Databases</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="119" to="153" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Fuzzy mining-adaptive process simplification based on multiperspective metrics</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Günther</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M P</forename><surname>Van Der Aalst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">BPM 2007</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4714</biblScope>
			<biblScope unit="page" from="328" to="343" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The program structure tree: computing control regions in linear time</title>
		<author>
			<persName><forename type="first">R</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pearson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pingali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN PLDI 1994, PLDI</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="171" to="185" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Semantische Prozessmodellierung auf der Grundlage &quot;Ereignisgesteuerter Prozessketten (EPK)</title>
		<author>
			<persName><forename type="first">G</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Nüttgens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Scheer</surname></persName>
		</author>
		<idno>Heft 89</idno>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
		<respStmt>
			<orgName>Veröffentlichungen des Instituts für Wirtschaftsinformatik University of Saarland</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">On the semantics of EPCs: resolving the vicious circle</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kindler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Knowl. Eng</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="page" from="23" to="40" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">The role of visual modeling and model transformations in business-driven development</title>
		<author>
			<persName><forename type="first">J</forename><surname>Koehler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hauser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Küster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ryndina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vanhatalo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wahler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electron. Notes Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">211</biblScope>
			<biblScope unit="page" from="5" to="15" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Apromore: an advanced process model repository</title>
		<author>
			<persName><forename type="first">La</forename><surname>Rosa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Reijers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">A</forename><surname>Aalst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M P</forename><surname>Dijkman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Mendling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dumas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Garcia-Banuelos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Expert Syst. Appl</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="7029" to="7040" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Workflow modeling for virtual processes: an order-preserving process-view approach</title>
		<author>
			<persName><forename type="first">D</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="505" to="532" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">BPMN: how much does it cost? An incremental approach</title>
		<author>
			<persName><forename type="first">M</forename><surname>Magnani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Montesi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">BPM 2007</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4714</biblScope>
			<biblScope unit="page" from="80" to="87" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Generalization in digital cartography</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Mcmaster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Shea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Resource Publication of the Association of American Geographers</title>
		<meeting><address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Metrics for Process Models: Empirical Foundations of Verification, Error Prediction, and Guidelines for Correctness</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mendling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNBIP</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<date type="published" when="2008">2008</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Business process design by view integration</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mendling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Simon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Business Process Management Workshops</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4103</biblScope>
			<biblScope unit="page" from="55" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Detection and prediction of errors in EPCs of the SAP reference model</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mendling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Verbeek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Van Dongen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M P</forename><surname>Van Der Aalst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Neumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Knowl. Eng</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="312" to="329" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Petri nets: properties, analysis and applications</title>
		<author>
			<persName><forename type="first">T</forename><surname>Murata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE</title>
		<meeting>IEEE</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">77</biblScope>
			<biblScope unit="page" from="541" to="580" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Development of a rule-based system for automatic map generalization</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">G</forename><surname>Nickerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">R</forename><surname>Freeman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986-01">January. 1986</date>
			<publisher>ISSDH</publisher>
			<biblScope unit="page" from="537" to="556" />
			<pubPlace>Seattle, Washington, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">A framework for expressing the relationships between multiple views in requirements specification</title>
		<author>
			<persName><forename type="first">B</forename><surname>Nuseibeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kramer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Finkelstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Softw. Eng</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="760" to="773" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<author>
			<persName><surname>Omg</surname></persName>
		</author>
		<title level="m">Meta Object Facility (MOF) Core Specification</title>
		<imprint>
			<date type="published" when="2006-01">January 2006</date>
		</imprint>
	</monogr>
	<note>2.0 edition</note>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<author>
			<persName><surname>Omg</surname></persName>
		</author>
		<title level="m">Business Process Model and Notation (BPMN), 2011 edition</title>
		<imprint>
			<date type="published" when="2011-01">January 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">workflow view definition, and workflow normalization based on Petri nets</title>
		<author>
			<persName><forename type="first">V</forename><surname>Pankratius</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Stucky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">APCCM 2005</title>
		<meeting><address><addrLine>Darlinghurst</addrLine></address></meeting>
		<imprint>
			<publisher>Australian Computer Society</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="79" to="88" />
		</imprint>
	</monogr>
	<note>A formal foundation for workflow composition</note>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Process model abstraction: a slider approach</title>
		<author>
			<persName><forename type="first">A</forename><surname>Polyvyanyy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Smirnov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Weske</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008. 2008</date>
			<publisher>EDOC</publisher>
			<biblScope unit="page" from="325" to="331" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Reducing complexity of large EPCs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Polyvyanyy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Smirnov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Weske</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Modellierung betrieblicher Informationssysteme (Mo-bIS 2008) Modellierung zwischen SOA und Compliance Management</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Loos</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Nüttgens</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Turowski</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Werth</surname></persName>
		</editor>
		<meeting><address><addrLine>Bonn</addrLine></address></meeting>
		<imprint>
			<publisher>Bonner Köllen Verlag</publisher>
			<date type="published" when="2008-11-28">27-28 November 2008. 2008</date>
			<biblScope unit="volume">141</biblScope>
			<biblScope unit="page" from="195" to="207" />
		</imprint>
	</monogr>
	<note>Saarbrücken. GI-Edition -Lecture Notes in Informatics (LNI)</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">On application of structural decomposition for process model abstraction</title>
		<author>
			<persName><forename type="first">A</forename><surname>Polyvyanyy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Smirnov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Weske</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Business Process, Service Computing and Intelligent Service Management</title>
		<editor>
			<persName><forename type="first">W</forename><surname>Abramowicz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Maciaszek</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Kowalczyk</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Speck</surname></persName>
		</editor>
		<meeting><address><addrLine>Leipzig; Bonn</addrLine></address></meeting>
		<imprint>
			<publisher>Bonner Köllen Verlag</publisher>
			<date type="published" when="2009-03-25">23-25 March 2009. 2009</date>
			<biblScope unit="volume">147</biblScope>
			<biblScope unit="page" from="110" to="122" />
		</imprint>
	</monogr>
	<note>Germany. GI-Edition -Lecture Notes in Informatics (LNI)</note>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">The triconnected abstraction of process models</title>
		<author>
			<persName><forename type="first">A</forename><surname>Polyvyanyy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Smirnov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Weske</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">BPM 2009</title>
		<meeting><address><addrLine>Ulm, Germany; Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5701</biblScope>
			<biblScope unit="page" from="229" to="244" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">View integration of behavior in object-oriented databases</title>
		<author>
			<persName><forename type="first">G</forename><surname>Preuner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Conrad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schrefl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Knowl. Eng</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="153" to="183" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Modularity in process models: review and effects</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">A</forename><surname>Reijers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mendling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">5240</biblScope>
			<biblScope unit="page" from="20" to="35" />
			<date type="published" when="2008">2008. 2008</date>
			<publisher>Springer</publisher>
			<pubPlace>Milan, Italy; Berlin</pubPlace>
		</imprint>
	</monogr>
	<note>BPM</note>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">Elements of Distributed Algorithms: Modeling and Analysis with Petri Nets</title>
		<author>
			<persName><forename type="first">W</forename><surname>Reisig</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Analyzing process models using graph reduction techniques</title>
		<author>
			<persName><forename type="first">W</forename><surname>Sadiq</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Orlowska</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="117" to="134" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Discovering role-relevant process-views for recommending workflow information</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">DEXA</title>
		<imprint>
			<biblScope unit="volume">2736</biblScope>
			<biblScope unit="page" from="836" to="845" />
			<date type="published" when="2003">2003</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Structural aspects of business process diagram abstraction</title>
		<author>
			<persName><forename type="first">S</forename><surname>Smirnov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Workshop on BPMN</title>
		<imprint>
			<biblScope unit="page" from="375" to="382" />
			<date type="published" when="2009-07">July. 2009</date>
			<publisher>IEEE Comput. Soc</publisher>
			<pubPlace>Vienna, Austria; Los Alamitos</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Meronymy-based aggregation of activities in business process models</title>
		<author>
			<persName><forename type="first">S</forename><surname>Smirnov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Dijkman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mendling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Weske</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ER 2010</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6412</biblScope>
			<biblScope unit="page" from="1" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">A semantic approach for business process model abstraction</title>
		<author>
			<persName><forename type="first">S</forename><surname>Smirnov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">A</forename><surname>Reijers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Weske</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAiSE 2011</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6741</biblScope>
			<biblScope unit="page" from="497" to="511" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Visualization support for managing large business process specifications</title>
		<author>
			<persName><forename type="first">A</forename><surname>Streit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Brown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">BPM 2005</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3649</biblScope>
			<biblScope unit="page" from="205" to="219" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Prime subprogram parsing of a program</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Valdes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL 1980</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1980">1980</date>
			<biblScope unit="page" from="95" to="105" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">The refined process structure tree</title>
		<author>
			<persName><forename type="first">J</forename><surname>Vanhatalo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Völzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Koehler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">5240</biblScope>
			<biblScope unit="page" from="100" to="115" />
			<date type="published" when="2008">2008. 2008</date>
			<publisher>Springer</publisher>
			<pubPlace>Milan, Italy; Berlin</pubPlace>
		</imprint>
	</monogr>
	<note>BPM</note>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Faster and more focused control-flow analysis for business process models through SESE decomposition</title>
		<author>
			<persName><forename type="first">J</forename><surname>Vanhatalo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Völzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Leymann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSOC 2007</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4749</biblScope>
			<biblScope unit="page" from="43" to="55" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Beyond soundness: on the verification of semantic business process models</title>
		<author>
			<persName><forename type="first">I</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hoffmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">:</forename><forename type="middle">J</forename><surname>Mendling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Distrib. Parallel Databases</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="271" to="343" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">The ICoP framework: identification of correspondences between process models</title>
		<author>
			<persName><forename type="first">M</forename><surname>Weidlich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Dijkman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mendling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAiSE 2010</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6051</biblScope>
			<biblScope unit="page" from="483" to="498" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Deciding behaviour compatibility of complex correspondences between process models</title>
		<author>
			<persName><forename type="first">M</forename><surname>Weidlich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Dijkman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Weske</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">BPM 2010</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6336</biblScope>
			<biblScope unit="page" from="78" to="94" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
