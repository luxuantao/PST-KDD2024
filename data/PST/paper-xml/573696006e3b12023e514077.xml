<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">On the Expressive Power of Deep Learning: A Tensor Analysis</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Nadav</forename><surname>Cohen</surname></persName>
							<email>cohennadav@cs.huji.ac.il</email>
							<affiliation key="aff0">
								<orgName type="institution">The Hebrew University of Jerusalem</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">On the Expressive Power of Deep Learning: A Tensor Analysis</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T14:05+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Deep Learning</term>
					<term>Expressive Power</term>
					<term>Arithmetic Circuits</term>
					<term>Tensor Decompositions</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>It has long been conjectured that hypotheses spaces suitable for data that is compositional in nature, such as text or images, may be more efficiently represented with deep hierarchical networks than with shallow ones. Despite the vast empirical evidence supporting this belief, theoretical justifications to date are limited. In particular, they do not account for the locality, sharing and pooling constructs of convolutional networks, the most successful deep learning architecture to date. In this work we derive a deep network architecture based on arithmetic circuits that inherently employs locality, sharing and pooling. An equivalence between the networks and hierarchical tensor factorizations is established. We show that a shallow network corresponds to CP (rank-1) decomposition, whereas a deep network corresponds to Hierarchical Tucker decomposition. Using tools from measure theory and matrix algebra, we prove that besides a negligible set, all functions that can be implemented by a deep network of polynomial size, require exponential size in order to be realized (or even approximated) by a shallow network. Since log-space computation transforms our networks into SimNets, the result applies directly to a deep learning architecture demonstrating promising empirical performance. The construction and theory developed in this paper shed new light on various practices and ideas employed by the deep learning community.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>The expressive power of neural networks is achieved through depth. There is mounting empirical evidence that for a given budget of resources (e.g. neurons), the deeper one goes, the better the eventual performance will be. However, existing theoretical arguments that support this empirical finding are limited. There have been many attempts to theoretically analyze function spaces generated by network architectures, and their dependency on network depth and size. The prominent approach for justifying the power of depth is to show that deep networks can efficiently express functions that would require shallow networks to have super-polynomial size. We refer to such scenarios as instances of depth efficiency. Unfortunately, existing results dealing with depth efficiency (e.g. <ref type="bibr" target="#b15">Hastad (1986)</ref>; <ref type="bibr" target="#b16">Håstad and Goldmann (1991)</ref>; <ref type="bibr" target="#b8">Delalleau and Bengio (2011)</ref>; <ref type="bibr" target="#b27">Martens and Medabalimi (2014)</ref>) typically apply to specific network architectures that do not resemble ones commonly used in practice. In particular, none of these results apply to convolutional networks <ref type="bibr" target="#b23">(LeCun and Bengio (1995)</ref>), which represent the most empirically successful and widely used deep learning architecture to date. A further limitation of current results is that they merely show existence of depth efficiency (i.e. of functions that are efficiently realizable with a certain depth but cannot be efficiently realized with shallower depths), without providing any information as to how frequent this property is. These shortcomings of current theory are the ones that motivated our work.</p><p>The architectural features that specialize convolutional networks compared to classic feedforward fully-connected networks are threefold. The first feature, locality, refers to the connection of a neuron only to neighboring neurons in the preceding layer, as opposed to having the entire layer drive it. In the context of image processing (the most common application of convolutional networks), locality is believed to reflect the inherent compositional structure of data -the closer pixels are in an image, the more likely they are to be correlated. The second architectural feature of convolutional networks is sharing, which means that different neurons in the same layer, connected to different neighborhoods in the preceding layer, share the same weights. Sharing, which together with locality gives rise to convolution, is motivated by the fact that in natural images, the semantic meaning of a pattern often does not depend on its location (i.e. two identical patterns appearing in different locations of an image often convey the same semantic content). Finally, the third architectural idea of convolutional networks is pooling, which is essentially an operator that decimates layers, replacing neural activations in a spatial window by a single value (e.g. their maximum or average). In the context of images, pooling induces invariance to translations (which often do not affect semantic content), and in addition is believed to create a hierarchy of abstraction in the patterns neurons respond to. The three architectural elements of locality, sharing and pooling, which have facilitated the great success of convolutional networks, are all lacking in existing theoretical studies of depth efficiency.</p><p>In this paper we introduce a convolutional arithmetic circuit architecture that incorporates locality, sharing and pooling. Arithmetic circuits (also known as Sum-Product Networks, <ref type="bibr" target="#b33">Poon and Domingos (2011)</ref>) are networks with two types of nodes: sum nodes, which compute a weighted sum of their inputs, and product nodes, computing the product of their inputs. We use sum nodes to implement convolutions (locality with sharing), and product nodes to realize pooling. The models we arrive at may be viewed as convolutional networks with product pooling and linear point-wise activation. They are attractive on three accounts. First, as discussed in app. E, convolutional arithmetic circuits are equivalent to SimNets, a new deep learning architecture that has recently demonstrated promising empirical results on various image recognition benchmarks <ref type="bibr">(Cohen et al. (2016)</ref>). Second, as we show in sec. 3, convolutional arithmetic circuits are realizations of hierarchical tensor decompositions (see <ref type="bibr" target="#b12">Hackbusch (2012)</ref>), opening the door to various mathematical and algorithmic tools for their analysis and implementation. Third, the depth efficiency of convolutional arithmetic circuits, which we analyze in sec. 4, was shown in the subsequent work of <ref type="bibr">Cohen and Shashua (2016)</ref> to be superior to the depth efficiency of the popular convolutional rectifier networks, namely convolutional networks with rectified linear (ReLU) activation and max or average pooling.</p><p>Employing machinery from measure theory and matrix algebra, made available through their connection to hierarchical tensor decompositions, we prove a number of fundamental results concerning the depth efficiency of our convolutional arithmetic circuits. Our main theoretical result (thm. 1 and corollary 2) states that besides a negligible (zero measure) set, all functions that can be realized by a deep network of polynomial size, require exponential size in order to be realized, or even approximated, by a shallow network. When translated to the viewpoint of tensor decompositions, this implies that almost all tensors realized by Hierarchical Tucker (HT) decomposition <ref type="bibr" target="#b11">(Hackbusch and Kühn (2009)</ref>) cannot be efficiently realized by the classic CP (rank-1) decomposition. To the best of our knowledge, this result is unknown to the tensor analysis community, in which the advantage of HT over CP is typically demonstrated through specific examples of tensors that can be efficiently realized by the former and not by the latter. Following our main result, we present a generalization (thm. 3 and corollary 4) that compares networks of arbitrary depths, show-ing that the amount of resources one has to pay in order to maintain representational power while trimming down layers of a network grows double exponentially w.r.t. the number of layers cut off. We also characterize cases in which dropping a single layer bears an exponential price.</p><p>The remainder of the paper is organized as follows. In sec. 2 we briefly review notations and mathematical background required in order to follow our work. This is followed by sec. 3, which presents our convolutional arithmetic circuits and establishes their equivalence with tensor decompositions. Our theoretical analysis is covered in sec. 4. Finally, sec. 5 concludes. In order to keep the manuscript at a reasonable length, we defer our detailed survey of related work to app. D, covering works on the depth efficiency of boolean circuits, arithmetic circuits and neural networks, as well as different applications of tensor analysis in the field of deep learning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Preliminaries</head><p>We begin by establishing notational conventions that will be used throughout the paper. We denote vectors using bold typeface, e.g. v ∈ R s . The coordinates of such a vector are referenced with regular typeface and a subscript, e.g. v i ∈ R. This is not to be confused with bold typeface and a subscript, e.g. v i ∈ R s , which represents a vector that belongs to some sequence. Tensors (multidimensional arrays) are denoted by the letters "A" and "B" in calligraphic typeface, e.g. A, B ∈ R M 1 ×•••×M N . A specific entry in a tensor will be referenced with subscripts, e.g. A d 1 ...d N ∈ R. Superscripts will be used to denote individual objects within a collection. For example, v (i) stands for vector i and A y stands for tensor y. In cases where the collection of interest is indexed by multiple coordinates, we will have multiple superscripts referencing individual objects, e.g. a l,j,γ will stand for vector (l, j, γ). As shorthand for the Cartesian product of the Euclidean space R s with itself N times, we will use the notation (R s ) N . Finally, for a positive integer k we use the shorthand [k] to denote the set {1, . . . , k}.</p><p>We now turn to establish a baseline, i.e. to present basic definitions and results, in the broad and comprehensive field of tensor analysis. We list here only the essentials required in order to follow the paper, referring the interested reader to <ref type="bibr" target="#b12">Hackbusch (2012)</ref> for a more complete introduction to the field 1 . The most straightforward way to view a tensor is simply as a multi-dimensional array:</p><formula xml:id="formula_0">A d 1 ,...,d N ∈ R where i ∈ [N ], d i ∈ [M i ].</formula><p>The number of indexing entries in the array, which are also called modes, is referred to as the order of the tensor. The term dimension stands for the number of values an index can take in a particular mode. For example, the tensor A appearing above has order N and dimension M i in mode i, i ∈ [N ]. The space of all possible configurations A can take is called a tensor space and is denoted, quite naturally, by</p><formula xml:id="formula_1">R M 1 ×•••×M N .</formula><p>A central operator in tensor analysis is the tensor product, denoted ⊗. This operator intakes two tensors A and B of orders P and Q respectively, and returns a tensor A ⊗ B of order P + Q, defined by:</p><formula xml:id="formula_2">(A ⊗ B) d 1 ...d P +Q = A d 1 ...d P • B d P +1 ...d P +Q .</formula><p>Notice that in the case P = Q = 1, the tensor product reduces to an outer product between vectors. Specifically, v ⊗ u -the tensor product between u ∈ R M 1 and v ∈ R M 2 , is no other than the rank-1 matrix vu ∈ R M 1 ×M 2 . In this context, we will often use the shorthand ⊗ N i=1 v (i) to denote the joint tensor product v (1) ⊗• • •⊗v (N ) . Tensors of the form ⊗ N i=1 v (i) are called pure or elementary, and are regarded as having rank-1 (assuming v (i) = 0 ∀i). It is not difficult to see that any tensor can be expressed as a sum of rank-1 tensors:</p><formula xml:id="formula_3">A = Z z=1 v (1) z ⊗ • • • ⊗ v (N ) z , v (i) z ∈ R M i (1)</formula><p>A representation as above is called a CANDECOMP/PARAFAC decomposition of A, or in short, a CP decomposition 2 . The CP-rank of A is defined as the minimum number of terms in a CP decomposition, i.e. as the minimal Z for which eq. 1 can hold. Notice that for a tensor of order 2, i.e. a matrix, this definition of CP-rank coincides with that of standard matrix rank.</p><p>A symmetric tensor is one that is invariant to permutations of its indices. Formally, a tensor A of order N which is symmetric will have equal dimension M in all modes, and for every permutation π :</p><formula xml:id="formula_4">[N ] → [N ] and indices d 1 . . .d N ∈ [M ],</formula><p>the following equality will hold:</p><formula xml:id="formula_5">A d π(1) ...d π(N ) = A d 1 ...d N . Note that for a vector v ∈ R M , the tensor ⊗ N i=1 v ∈ R M ×•••×M is symmetric.</formula><p>Moreover, every symmetric tensor may be expressed as a linear combination of such (symmetric rank-1) tensors:</p><formula xml:id="formula_6">A = Z z=1 λ z • v z ⊗ • • • ⊗ v z .</formula><p>This is referred to as a symmetric CP decomposition, and the symmetric CP-rank is the minimal Z for which such a decomposition exists. Since a symmetric CP decomposition is in particular a standard CP decomposition, the symmetric CP-rank of a symmetric tensor is always greater or equal to its standard CP-rank. Note that for the case of symmetric matrices (order-2 tensors) the symmetric CP-rank and the original CP-rank are always equal.</p><p>A repeating concept in this paper is that of measure zero. More broadly, our analysis is framed in measure theoretical terms. While an introduction to the field is beyond the scope of the paper (the interested reader is referred to <ref type="bibr" target="#b20">Jones (2001)</ref>), it is possible to intuitively grasp the ideas that form the basis to our claims. When dealing with subsets of a Euclidean space, the standard and most natural measure in a sense is called the Lebesgue measure. This is the only measure we consider in our analysis. A set of (Lebesgue) measure zero can be thought of as having zero "volume" in the space of interest. For example, the interval between (0, 0) and (1, 0) has zero measure as a subset of the 2D plane, but has positive measure as a subset of the 1D x-axis. An alternative way to view a zero measure set S follows the property that if one draws a random point in space by some continuous distribution, the probability of that point hitting S is necessarily zero. A related term that will be used throughout the paper is almost everywhere, which refers to an entire space excluding, at most, a set of zero measure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Convolutional Arithmetic Circuits</head><p>We consider the task of classifying an instance X = (x 1 , . . . , x N ), x i ∈ R s , into one of the categories Y := {1, . . . , Y }. Representing instances as collections of vectors is natural in many applications. In the case of image processing for example, X may correspond to an image, and x 1 . . . x N may correspond to vector arrangements of (possibly overlapping) patches around pixels. As customary, classification is carried out through maximization of per-label score functions {h y } y∈Y , i.e. the predicted label for the instance X will be the index y ∈ Y for which the score value h y (X) is maximal. Our attention is thus directed to functions over the instance space X := {(x 1 , . . . , x N ) : x i ∈ R s } = (R s ) N . We define our hypotheses space through the following 2. CP decomposition is regarded as the classic and most basic tensor decomposition, dating back to the beginning of the 20'th century (see <ref type="bibr" target="#b21">Kolda and Bader (2009)</ref> for a historic survey).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>   </head><p>,</p><formula xml:id="formula_7">d i rep i d f   x input representation 1x1 conv global pooling dense (output) hidden layer i x M Z Z Y     , , , ,<label>:</label></formula><formula xml:id="formula_8">z i conv i z rep i  a     1 , N i pool z conv i z        , : y out y pool  a X Figure 1: CP model -convolutional arithmetic circuit implementing CP (rank-1) decomposition.</formula><p>representation of score functions:</p><formula xml:id="formula_9">h y (x 1 , . . . , x N ) = M d 1 ...d N =1 A y d 1 ,...,d N N i=1 f θ d i (x i )<label>(2)</label></formula><p>f θ 1 . . .f θ M : R s → R are referred to as representation functions, selected from a parametric family F = {f θ : R s → R} θ∈Θ . Natural choices for this family are wavelets, radial basis functions (Gaussians), and affine functions followed by point-wise activation (neurons). The coefficient tensor A y has order N and dimension M in each mode. Its entries correspond to a basis of</p><formula xml:id="formula_10">M N point-wise product functions {(x 1 , . . . , x N ) → N i=1 f θ d i (x i )} d 1 ...d N ∈[M ]</formula><p>. We will often consider fixed linearly independent representation functions f θ 1 . . .f θ M . In this case the point-wise product functions are linearly independent as well (see app. C.1), and we have a one to one correspondence between score functions and coefficient tensors. To keep the manuscript concise, we defer the derivation of our hypotheses space (eq. 2) to app. C, noting here that it arises naturally from the notion of tensor products between L 2 spaces.</p><p>Our eventual aim is to realize score functions h y with a layered network architecture. As a first step along this path, we notice that h y (x 1 , . . . , x N ) is fully determined by the activations of the M representation functions f θ 1 . . .f θ M on the N input vectors x 1 . . .x N . In other words, given</p><formula xml:id="formula_11">{f θ d (x i )} d∈[M ],i∈[N ]</formula><p>, the score h y (x 1 , . . . , x N ) is independent of the input. It is thus natural to consider the computation of these M •N numbers as the first layer of our networks. This layer, referred to as the representation layer, may be conceived as a convolutional operator with M channels, each corresponding to a different function applied to all input vectors (see fig. <ref type="figure">1</ref>).</p><p>Once we have constrained our score functions to have the structure depicted in eq. 2, learning a classifier reduces to estimation of the parameters θ 1 . . .θ M , and the coefficient tensors A 1 . . .A Y . The computational challenge is that the latter tensors are of order N (and dimension M in each mode), having an exponential number of entries (M N each). In the next subsections we utilize tensor decompositions (factorizations) to address this computational challenge, and show how they are naturally realized by convolutional arithmetic circuits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Shallow Network as a CP Decomposition of A y</head><p>The most straightforward way to factorize a tensor is through a CP (rank-1) decomposition (see sec. 2). Consider a joint CP decomposition for the coefficient tensors {A y } y∈Y :</p><formula xml:id="formula_12">A y = Z z=1 a y z • a z,1 ⊗ • • • ⊗ a z,N<label>(3)</label></formula><p>where a y ∈ R Z for y ∈ Y (a y z stands for entry z of a y ), and</p><formula xml:id="formula_13">a z,i ∈ R M for i ∈ [N ], z ∈ [Z].</formula><p>The decomposition is joint in the sense that the same vectors a z,i are shared across all classes y. Clearly, if we set Z = M N this model is universal, i.e. any tensors A 1 . . .A Y may be represented.</p><p>Substituting our CP decomposition (eq. 3) into the expression for the score functions in eq. 2, we obtain:</p><formula xml:id="formula_14">h y (X) = Z z=1 a y z N i=1 M d=1 a z,i d f θ d (x i )</formula><p>From this we conclude that the network illustrated in fig. <ref type="figure">1</ref> implements a classifier (score functions) under the CP decomposition in eq. 3. We refer to this network as CP model. The network consists of a representation layer followed by a single hidden layer, which in turn is followed by the output.</p><p>The hidden layer begins with a 1 × 1 conv operator, which is simply a 3D convolution with Z channels and receptive field 1 × 1. The convolution may operate without coefficient sharing, i.e. the filters that generate feature maps by sliding across the previous layer may have different coefficients at different spatial locations. This is often referred to in the deep learning community as a locallyconnected operator (see <ref type="bibr" target="#b46">Taigman et al. (2014)</ref>). To obtain a standard convolutional operator, simply enforce coefficient sharing by constraining the vectors a z,i in the CP decomposition (eq. 3) to be equal to each other for different values of i (this setting is discussed in sec. 3.3). Following conv operator, the hidden layer includes global product pooling. Feature maps generated by conv are reduced to singletons through multiplication of their entries, creating a vector of dimension Z. This vector is then mapped into the Y network outputs through a final dense linear layer.</p><p>To recap, CP model (fig. <ref type="figure">1</ref>) is a shallow (single hidden layer) convolutional arithmetic circuit that realizes the CP decomposition (eq. 3). It is universal, i.e. it can realize any coefficient tensors with large enough size (Z). Unfortunately, since the CP-rank of a generic tensor is exponential in its order (see <ref type="bibr" target="#b12">Hackbusch (2012)</ref>), the size required for CP model to be universal is exponential (Z exponential in N ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Deep Network as a Hierarchical Decomposition of A y</head><p>In this subsection we present a deep network that corresponds to the recently introduced Hierarchical Tucker tensor decomposition <ref type="bibr" target="#b11">(Hackbusch and Kühn (2009)</ref>), which we refer to in short as HT decomposition. The network, dubbed HT model, is universal. Specifically, any set of tensors A y represented by CP model can be represented by HT model with only a polynomial penalty in terms of resources. The advantage of HT model, as we show in sec. 4, is that in almost all cases it generates tensors that require an exponential size in order to be realized, or even approximated, by CP model. Put differently, if one draws the weights of HT model by some continuous distribution, with probability one, the resulting tensors cannot be approximated by a polynomial CP model. Informally, this implies that HT model is exponentially more expressive than CP model. </p><formula xml:id="formula_15">i x M 0 r 0 r 1 L r  1 L r  Y     0, , 0 ,</formula><p>, ,:</p><formula xml:id="formula_16">j conv j rep j    a       0 0 ' 2 1,2 , ', j j j pool j conv j             1 1 ' 1,2 ', L L j pool conv j            , 1</formula><p>, :</p><p>L y L out y pool HT model is based on the hierarchical tensor decomposition in eq. 4, which is a special case of the HT decomposition as presented in <ref type="bibr" target="#b11">Hackbusch and Kühn (2009)</ref> (in the latter's terminology, we restrict the matrices A l,j,γ to be diagonal). Our construction and theoretical results apply to the general HT decomposition as well, with the specialization done merely to bring forth a network that resembles current convolutional networks 3 .</p><formula xml:id="formula_17">φ 1,j,γ = r 0 α=1 a 1,j,γ α a 0,2j−1,α ⊗ a 0,2j,α • • • φ l,j,γ = r l−1 α=1 a l,j,γ α φ l−1,2j−1,α order 2 l−1 ⊗ φ l−1,2j,α order 2 l−1 • • • φ L−1,j,γ = r L−2 α=1 a L−1,j,γ α φ L−2,2j−1,α order N 4 ⊗ φ L−2,2j,α order N 4 A y = r L−1 α=1 a L,y α φ L−1,1,α order N 2 ⊗ φ L−1,2,α order N 2 (4)</formula><p>The decomposition in eq. 4 recursively constructs the coefficient tensors</p><formula xml:id="formula_18">{A y } y∈[Y ] by assem- bling vectors {a 0,j,γ } j∈[N ],γ∈[r 0 ] into tensors {φ l,j,γ } l∈[L−1],j∈[N/2 l ],γ∈[r l ]</formula><p>in an incremental fashion. The index l stands for the level in the decomposition, j represents the "location" within level l, and γ corresponds to the individual tensor in level l and location j. r l is referred to as level-l rank, and is defined to be the number of tensors in each location of level l (we denote for completeness r L := Y ). The tensor φ l,j,γ has order 2 l , and we assume for simplicity that N -the order of A y , is a power of 2 (this is merely a technical assumption also made in <ref type="bibr" target="#b11">Hackbusch and Kühn (2009)</ref>, it does not limit the generality of our analysis).</p><p>The parameters of the decomposition are the final level weights {a</p><formula xml:id="formula_19">L,y ∈ R r L−1 } y∈[Y ] , the in- termediate levels' weights {a l,j,γ ∈ R r l−1 } l∈[L−1],j∈[N/2 l ],γ∈[r l ]</formula><p>, and the first level vectors {a 0,j,γ ∈</p><formula xml:id="formula_20">R M } j∈[N ],γ∈[r 0 ] . This totals at N • M • r 0 + L−1 l=1 N 2 l • r l−1 • r l + Y • r l−1 individual parame-</formula><p>3. If we had not constrained A l,j,γ to be diagonal, pooling operations would involve entries from different channels.</p><p>ters, and if we assume equal ranks r :</p><formula xml:id="formula_21">= r 0 = • • • = r L−1 , the number of parameters becomes N • M • r + N • r 2 + Y • r.</formula><p>The hierarchical decomposition (eq. 4) is universal, i.e. with large enough ranks r l it can represent any tensors. Moreover, it is a super-set of the CP decomposition (eq. 3). That is to say, all tensors representable by a CP decomposition having Z components are also representable by a hierarchical decomposition with ranks r 0 = r 1 = • • • = r L−1 = Z<ref type="foot" target="#foot_0">4</ref> . Note that this comes with a polynomial penalty -the number of parameters increases from</p><formula xml:id="formula_22">N • M • Z + Z • Y in the CP decomposition, to N • M • Z + Z • Y + N • Z 2 in</formula><p>the hierarchical decomposition. However, as we show in sec. 4, the gain in expressive power is exponential.</p><p>Plugging the expression for A y in our hierarchical decomposition (eq. 4) into the score function h y given in eq. 2, we obtain the network displayed in fig. <ref type="figure" target="#fig_0">2</ref> -HT model. This network includes a representation layer followed by L = log 2 N hidden layers which in turn are followed by the output. As in the shallow CP model (fig. <ref type="figure">1</ref>), the hidden layers consist of 1 × 1 conv operators followed by product pooling. The difference is that instead of a single hidden layer collapsing the entire spatial structure through global pooling, hidden layers now pool over size-2 windows, decimating feature maps by a factor of two (no overlaps). After L = log 2 N such layers feature maps are reduced to singletons, and we arrive at a 1D structure with r L−1 nodes. This is then mapped into Y network outputs through a final dense linear layer. We note that the network's size-2 pooling windows (and the resulting number of hidden layers L = log 2 N ) correspond to the fact that our hierarchical decomposition (eq. 4) is based on a full binary tree over modes, i.e. it combines (through tensor product) two tensors at a time. We focus on this setting solely for simplicity of presentation, and since it is the one presented in <ref type="bibr" target="#b11">Hackbusch and Kühn (2009)</ref>. Our analysis (sec. 4) could easily be adapted to hierarchical decompositions based on other trees (taking tensor products between more than two tensors at a time), and that would correspond to networks with different pooling window sizes and resulting depths.</p><p>HT model (fig. <ref type="figure" target="#fig_0">2</ref>) is conceptually divided into two parts. The first is the representation layer, transforming input vectors</p><formula xml:id="formula_23">x 1 . . .x N into N •M real-valued scalars {f θ d (x i )} i∈[N ],d∈[M ]</formula><p>. The second and main part of the network, which we view as an "inference" engine, is the convolutional arithmetic circuit that takes the N •M measurements produced by the representation layer, and accordingly computes Y class scores at the output layer.</p><p>To recap, we have now a deep network (fig. <ref type="figure" target="#fig_0">2</ref>), which we refer to as HT model, that computes the score functions h y (eq. 2) with coefficient tensors A y hierarchically decomposed as in eq. 4.</p><p>The network is universal in the sense that with enough channels r l , any tensors may be represented. Moreover, the model is a super-set of the shallow CP model presented in sec. 3.1. The question of depth efficiency now naturally arises. In particular, we would like to know if there are functions that may be represented by a polynomially sized deep HT model, yet require exponential size from the shallow CP model. The answer, as described in sec. 4, is that almost all functions realizable by HT model meet this property. In other words, the set of functions realizable by a polynomial CP model has measure zero in the space of functions realizable by a given polynomial HT model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Shared Coefficients for Convolution</head><p>The 1 × 1 conv operator in our networks (see fig. <ref type="figure" target="#fig_0">1 and 2</ref>) implements a local linear transformation with coefficients generally being location-dependent. In the special case where coefficients do not depend on location, i.e. remain fixed across space, the local linear transformation becomes a standard convolution. We refer to this setting as coefficient sharing. Sharing is a widely used structural constraint, one of the pillars behind the successful convolutional network architecture. In the context of image processing (prominent application of convolutional networks), sharing is motivated by the observation that in natural images, the semantic content of a pattern often does not depend on its location. In this subsection we explore the effect of sharing on the expressiveness of our networks, or more specifically, on the coefficient tensors A y they can represent.</p><p>For CP model, coefficient sharing amounts to setting a z := a z,1 = • • • = a z,N in the CP decomposition (eq. 3), transforming the latter to a symmetric CP decomposition:</p><formula xml:id="formula_24">A y = Z z=1 a y z • a z ⊗ • • • ⊗ a z N times , a z ∈ R M , a y ∈ R Z</formula><p>CP model with sharing is not universal (not all tensors A y are representable, no matter how large Z is allowed to be) -it can only represent symmetric tensors.</p><p>In the case of HT model, sharing amounts to applying the following constraints on the hierarchical decomposition in eq. 4:</p><formula xml:id="formula_25">a l,γ := a l,1,γ = • • • = a l, N /2 l ,γ for every l = 0. . .L − 1 and γ = 1. . .r l .</formula><p>Note that in this case universality is lost as well, but nonetheless generated tensors are not limited to be symmetric, already demonstrating an expressive advantage of deep models over shallow ones. In sec. 4 we take this further by showing that the shared HT model is exponentially more expressive than CP model, even if the latter is not constrained by sharing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Theorems of Network Capacity</head><p>The first contribution of this paper, presented in sec. 3, is the equivalence between deep learning architectures successfully employed in practice, and tensor decompositions. Namely, we showed that convolutional arithmetic circuits as in fig. <ref type="figure" target="#fig_0">2</ref>, which are in fact SimNets that have demonstrated promising empirical performance (see app. E), may be formulated as hierarchical tensor decompositions. As a second contribution, we make use of the established link between arithmetic circuits and tensor decompositions, combining theoretical tools from these two worlds, to prove results that are of interest to both deep learning and tensor analysis communities. This is the focus of the current section.</p><p>The fundamental theoretical result proven in this paper is the following:</p><p>Theorem 1 Let A y be a tensor of order N and dimension M in each mode, generated by the recursive formulas in eq. 4. Define r := min{r 0 , M }, and consider the space of all possible configurations for the parameters of the composition -{a l,j,γ } l,j,γ . In this space, the generated tensor A y will have CP-rank of at least r N /2 almost everywhere (w.r.t. Lebesgue measure). Put differently, the configurations for which the CP-rank of A y is less than r N /2 form a set of measure zero. The exact same result holds if we constrain the composition to be "shared", i.e. set a l,j,γ ≡ a l,γ and consider the space of {a l,γ } l,γ configurations.</p><p>From the perspective of deep learning, thm. 1 leads to the following corollary:</p><p>Corollary 2 Given linearly independent representation functions {f θ d } d∈[M ] , randomizing the weights of HT model (sec. 3.2) by a continuous distribution induces score functions h y that with probability one, cannot be approximated arbitrarily well (in L 2 sense) by a CP model (sec. 3.1) with less than min{r 0 , M } N /2 hidden channels. This result holds even if we constrain HT model with weight sharing (sec. 3.3) while leaving CP model in its general form.</p><p>That is to say, besides a negligible set, all functions that can be realized by a polynomially sized HT model (with or without weight sharing), require exponential size in order to be realized, or even approximated, by CP model. Adopting the viewpoint of tensor analysis, thm. 1 states that besides a negligible set, all tensors realized by HT (Hierarchical Tucker) decomposition cannot be represented by the classic CP (rank-1) decomposition if the latter has less than an exponential number of terms 5 . To the best of our knowledge, this result has never been proved in the tensor analysis community. In the original paper introducing HT decomposition <ref type="bibr" target="#b11">(Hackbusch and Kühn (2009)</ref>), as a motivating example, the authors present a specific tensor that is efficiently realizable by HT decomposition while requiring an exponential number of terms from CP decomposition 6 . Our result strengthens this motivation considerably, showing that it is not just one specific tensor that favors HT over CP, but rather, almost all tensors realizable by HT exhibit this preference. Taking into account that any tensor realized by CP can also be realized by HT with only a polynomial penalty in the number of parameters (see sec. 3.2), this implies that in an asymptotic sense, HT decomposition is exponentially more efficient than CP decomposition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Proof Sketches</head><p>The complete proofs of thm. 1 and corollary 2 are given in app. B. We provide here an outline of the main tools employed and arguments made along these proofs.</p><p>To prove thm. 1 we combine approaches from the worlds of circuit complexity and tensor decompositions. The first class of machinery we employ is matrix algebra, which has proven to be a powerful source of tools for analyzing the complexity of circuits. For example, arithmetic circuits have been analyzed through what is called the partial derivative matrix (see <ref type="bibr" target="#b34">Raz and Yehudayoff (2009)</ref>), and for boolean circuits a widely used tool is the communication matrix (see <ref type="bibr">Karchmer (1989)</ref>). We gain access to matrix algebra by arranging tensors that take part in the CP and HT decompositions as matrices, a process often referred to as matricization. With matricization, the tensor product translates to the Kronecker product, and the properties of the latter become readily available. The second tool-set we make use of is measure theory, which prevails in the study of tensor decompositions, but is much less frequent in analyses of circuit complexity. In order to frame 5. As stated in sec. 3.2, the decomposition in eq. 4 to which thm. 1 applies is actually a special case of HT decomposition as introduced in <ref type="bibr" target="#b11">Hackbusch and Kühn (2009)</ref>. However, the theorem and its proof can easily be adapted to account for the general case. We focus on the special case merely because it corresponds to convolutional arithmetic circuit architectures used in practice. 6. The same motivating example is given in a more recent textbook introducing tensor analysis <ref type="bibr" target="#b12">(Hackbusch (2012)</ref>). a problem in measure theoretical terms, one obviously needs to define a measure space of interest. For tensor decompositions, the straightforward space to focus on is that of the decomposition variables. For general circuits on the other hand, it is often unclear if defining a measure space is at all appropriate. However, when circuits are considered in the context of machine learning they are usually parameterized, and defining a measure space on top of these parameters is an effective approach for studying the prevalence of various properties in hypotheses spaces.</p><p>Our proof of thm. 1 traverses through the following path. We begin by showing that matricizing a rank-1 tensor produces a rank-1 matrix. This implies that the matricization of a tensor generated by a CP decomposition with Z terms has rank at most Z. We then turn to show that the matricization of a tensor generated by the HT decomposition in eq. 4 has rank at least min{r 0 , M } N/2 almost everywhere. This is done through induction over the levels of the decomposition (l = 1. . .L). For the first level (l = 1), we use a combination of measure theoretical and linear algebraic arguments to show that the generated matrices have maximal rank (min{r 0 , M }) almost everywhere. For the induction step, the facts that under matricization tensor product translates into Kronecker product, and that the latter increases ranks multiplicatively 7 , imply that matricization ranks in the current level are generally equal to those in the previous level squared. Measure theoretical claims are then made to ensure that this indeed takes place almost everywhere.</p><p>To prove corollary 2 based on thm. 1, we need to show that the inability of CP model to realize a tensor generated by HT model, implies that the former cannot approximate score functions produced by the latter. In general, the set of tensors expressible by a CP decomposition is not topologically closed 8 , which implies that a-priori, it may be that CP model can approximate tensors generated by HT model even though it cannot realize them. However, since the proof of thm. 1 was achieved through separation of matrix rank, distances are indeed positive and CP model cannot approximate HT model's tensors almost always. To translate from tensors to score functions, we simply note that in a finite-dimensional Hilbert space convergence in norm implies convergence in coefficients under any basis. Therefore, in the space of score functions (eq. 2) convergence in norm implies convergence in coefficients under the basis {(x 1 , . . . ,</p><formula xml:id="formula_26">x N ) → N i=1 f θ d i (x i )} d 1 ...d N ∈[M ]</formula><p>. That is to say, it implies convergence in coefficient tensors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Generalization</head><p>Thm. 1 and corollary 2 compare the expressive power of the deep HT model (sec. 3.2) to that of the shallow CP model (sec. 3.1). One may argue that such an analysis is lacking, as it does not convey information regarding the importance of each individual layer. In particular, it does not shed light on the advantage of very deep networks, which at present provide state of the art recognition accuracy, compared to networks of more moderate depth. For this purpose we present a generalization, specifying the amount of resources one has to pay in order to maintain representational power while layers are incrementally cut off from a deep network. For conciseness we defer this analysis to app. A, and merely state here our final conclusions. We find that the representational penalty is double exponential w.r.t. the number of layers removed. In addition, there are certain cases where the removal of even a single layer leads to an exponential inflation, falling in line with the suggestion of <ref type="bibr" target="#b2">Bengio (2009)</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Discussion</head><p>In this work we address a fundamental issue in deep learning -the expressive efficiency of depth. There have been many attempts to theoretically analyze this question, but from a practical machine learning perspective, existing results are limited. Most of the results apply to very specific types of networks that do not resemble ones used in practice, and none of the results account for the localitysharing-pooling paradigm which forms the basis for convolutional networks -the most successful deep learning architecture to date. In addition, current analyses merely show existence of depth efficiency, i.e. of functions that are efficiently realizable by deep networks but not by shallow ones. The practical implications of such findings are arguably slight, as a-priori, it may be that only a small fraction of the functions realizable by deep networks enjoy depth efficiency, and for all the rest shallow networks suffice.</p><p>Our aim in this paper was to develop a theory that facilitates an analysis of depth efficiency for networks that incorporate the widely used structural ingredients of locality, sharing and pooling. We consider the task of classification into one of a finite set of categories Y = {1. . .Y }. Our instance space is defined to be the Cartesian product of N vector spaces, in compliance with the common practice of representing natural data through ordered local structures (e.g. images through patches). Each of the N vectors that compose an instance is represented by a descriptor of length M , generated by running the vector through M "representation" functions. As customary, classification is achieved through maximization of score functions h y , one for every category y ∈ Y. Each score function is a linear combination over the M N possible products that may be formed by taking one descriptor entry from every input vector. The coefficients for these linear combinations conveniently reside in tensors A y of order N and dimension M along each axis. We construct networks that compute score functions h y by decomposing (factorizing) the coefficient tensors A y . The resulting networks are convolutional arithmetic circuits that incorporate locality, sharing and pooling, and operate on the N •M descriptor entries generated from the input.</p><p>We show that a shallow (single hidden layer) network realizes the classic CP (rank-1) tensor decomposition, whereas a deep network with log 2 N hidden layers realizes the recently introduced Hierarchical Tucker (HT) decomposition <ref type="bibr" target="#b11">(Hackbusch and Kühn (2009)</ref>). Our fundamental result, presented in thm. 1 and corollary 2, states that randomizing the weights of a deep network by some continuous distribution will lead, with probability one, to score functions that cannot be approximated by a shallow network if the latter's size is not exponential (in N ). We extend this result (thm. 3 and corollary 4) by deriving analogous claims that compare two networks of any depths, not just deep vs. shallow.</p><p>To further highlight the connection between our networks and ones used in practice, we show (app. E) that translating convolution and product pooling computations to log-space (for numerical stability) gives rise to SimNets -a recently proposed deep learning architecture which has been shown to produce state of the art accuracy in computationally limited settings <ref type="bibr">(Cohen et al. (2016)</ref>).</p><p>Besides the central line of our work discussed above, the construction and theory presented in this paper shed light on various conjectures and practices employed by the deep learning community. First, with respect to the pooling operation, our analysis points to the possibility that perhaps it has more to do with factorization of computed functions than it does with translation invariance. This may serve as an explanation for the fact that pooling windows in state of the art convolutional networks are typically very small (see for example <ref type="bibr" target="#b40">Simonyan and Zisserman (2014)</ref>), often much smaller than the radius of translation one would like to be invariant to. Indeed, in our framework, as we show in app. A, pooling over large windows and trimming down a network's depth may bring to an exponential decrease in expressive efficiency.</p><p>The second point our theory sheds light on is sharing. As discussed in sec. 3.3, introducing weight sharing to a shallow network (CP model) considerably limits its expressive power. The network can only represent symmetric tensors, which in turn means that it is location invariant w.r.t. input vectors (patches). In the case of a deep network (HT model) the limitation posed by sharing is not as strict. Generated tensors need not be symmetric, implying that the network is capable of modeling location -a crucial ability in almost any real-world task. The above findings suggest that the sharing constraint is increasingly limiting as a network gets shallower, to the point where it causes complete ignorance to location. This could serve as an argument supporting the empirical success of deep convolutional networks -they bind together the statistical and computational advantages of sharing with many layers that mitigate its expressive limitations.</p><p>Lastly, our construction advocates locality, or more specifically, 1 × 1 receptive fields. Recent convolutional networks providing state of the art recognition performance (e.g. <ref type="bibr" target="#b24">Lin et al. (2014)</ref>; <ref type="bibr" target="#b45">Szegedy et al. (2015)</ref>) make extensive use of 1 × 1 linear transformations, proving them to be very successful in practice. In view of our model, such 1 × 1 operators factorize tensors while providing universality with a minimal number of parameters. It seems reasonable to conjecture that for this task of factorizing coefficient tensors, larger receptive fields are not significantly helpful, as they lead to redundancy which may deteriorate performance in presence of limited training data. Investigation of this conjecture is left for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A. Generalized Theorem of Network Capacity</head><p>In sec. 4 we presented our fundamental theorem of network capacity (thm. 1 and corollary 2), showing that besides a negligible set, all functions that can be realized by a polynomially sized HT model (with or without weight sharing), require exponential size in order to be realized, or even approximated, by CP model. In terms of network depth, CP and HT models represent the extremes -the former has only a single hidden layer achieved through global pooling, whereas the latter has L = log 2 N hidden layers achieved through minimal (size-2) pooling windows. It is of interest to generalize the fundamental result by establishing a comparison between networks of intermediate depths. This is the focus of the current appendix.</p><p>We begin by defining a truncated version of the hierarchical tensor decomposition presented in eq. 4:</p><formula xml:id="formula_27">φ 1,j,γ = r0 α=1 a 1,j,γ α a 0,2j−1,α ⊗ a 0,2j,α . . . φ l,j,γ = r l−1 α=1 a l,j,γ α φ l−1,2j−1,α order 2 l−1 ⊗ φ l−1,2j,α order 2 l−1 . . . A = r Lc −1 α=1 a Lc α 2 L−Lc +1 ⊗ j=1 φ Lc−1,j,α order 2 Lc −1 (5)</formula><p>The only difference between this decomposition and the original is that instead of completing the full process with L := log 2 N levels, we stop after L c ≤L. At this point remaining tensors are binded together to form the final order-N tensor. The corresponding network will simply include a premature global pooling stage that shrinks feature maps to 1 × 1, and then a final linear layer that performs classification. As before, we consider a shared version of the decomposition in which a l,j,γ ≡ a l,γ . Notice that this construction realizes a continuum between CP and HT models, which correspond to the extreme cases L c = 1 and L c = L respectively.</p><p>The following theorem, a generalization of thm. 1, compares a truncated decomposition having L 1 levels, to one with L 2 &lt; L 1 levels that implements the same tensor, quantifying the penalty in terms of parameters: Theorem 3 Let A (1) and A (2) be tensors of order N and dimension M in each mode, generated by the truncated recursive formulas in eq. 5, with L 1 and L 2 levels respectively. Denote by {r</p><p>(1) l } L1−1 l=0 and {r</p><p>(2) l } L2−1 l=0 the composition ranks of A (1) and A (2) respectively. Assuming w.l.o.g. that L 1 &gt; L 2 , we define r := min{r</p><formula xml:id="formula_28">(1) 0 , ..., r<label>(1)</label></formula><p>L2−1 , M }, and consider the space of all possible configurations for the parameters of A (1) 's composition -{a (1),l,j,γ } l,j,γ . In this space, almost everywhere (w.r.t. Lebesgue measure), the generated tensor A (1) requires that r</p><p>(2)</p><formula xml:id="formula_29">L2−1 ≥ (r) 2 L−L 2 if</formula><p>one wishes that A (2) be equal to A (1) . Put differently, the configurations for which A (1) can be realized by A (2) with r</p><p>(2) L2−1 &lt; (r) 2 L−L 2 form a set of measure zero. The exact same result holds if we constrain the composition of A (1) to be "shared", i.e. set a (1),l,j,γ ≡ a (1),l,γ and consider the space of {a (1),l,γ } l,γ configurations.</p><p>In analogy with corollary 2, we obtain the following generalization:</p><p>Corollary 4 Suppose we are given linearly independent representation functions f θ1 . . .f θ M , and consider two networks that correspond to the truncated hierarchical tensor decomposition in eq. 5, with L 1 and L 2 hidden layers respectively. Assume w.l.o.g. that L 1 &gt; L 2 , i.e. that network 1 is deeper than network 2, and define r to be the minimal number of channels across the representation layer and the first L 2 hidden layers of network 1. Then, if we randomize the weights of network 1 by a continuous distribution, we obtain, with probability one, score functions h y that cannot be approximated arbitrarily well (in L 2 sense) by network 2 if the latter has less than (r) 2 L−L 2 channels in its last hidden layer. The result holds even if we constrain network 1 with weight sharing while leaving network 2 in its general form.</p><p>Proofs of thm. 3 and corollary 4 are given in app. B. Hereafter, we briefly discuss some of their implications. First, notice that we indeed obtain a generalization of the fundamental theorem of network capacity (thm. 1 and corollary 2), which corresponds to the extreme case L 1 = L and L 2 = 1. Second, note that for the baseline case of L 1 = L, i.e. a full-depth network has generated the target score function, approximating this with a truncated network draws a price that grows double exponentially w.r.t. the number of missing layers. Third, and most intriguingly, we see that when L 1 is considerably smaller than L, i.e. when a significantly truncated network is sufficient to model our problem, cutting off even a single layer leads to an exponential price, and this price is independent of L 1 . Such scenarios of exponential penalty for trimming down a single layer were discussed in <ref type="bibr" target="#b2">Bengio (2009)</ref>, but only in the context of specific functions realized by networks that do not resemble ones used in practice (see <ref type="bibr" target="#b16">Håstad and Goldmann (1991)</ref> for an example of such result). We prove this in a much broader, more practical setting, showing that for convolutional arithmetic circuit (Sim-Net -see app. E) architectures, almost any function realized by a significantly truncated network will exhibit this behavior. The issue relates to empirical practice, supporting the common methodology of designing networks that go as deep as possible. Specifically, it encourages extending network depth by pooling over small regions, avoiding significant spatial decimation that brings network termination closer.</p><p>We conclude this appendix by stressing once more that our construction and theoretical approach are not limited to the models covered by our theorems (CP model, HT model, truncated HT model). These are merely exemplars deemed most appropriate for initial analysis. The fundamental and generalized theorems of network capacity are similar in spirit, and analogous theorems for networks with different pooling window sizes and depths (corresponding to different tensor decompositions) may easily be derived.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix B. Proofs</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.1. Proof of Theorems 1 and 3</head><p>Our proof of thm. 1 and 3 relies on basic knowledge in measure theory, or more specifically, Lebesgue measure spaces. We do not provide here a comprehensive background on this field (the interested reader is referred to <ref type="bibr" target="#b20">Jones (2001)</ref>), but rather supplement the brief discussion given in sec. 2, with a list of facts we will be using which are not necessarily intuitive:</p><p>• A union of countably (or finitely) many sets of zero measure is itself a set of zero measure.</p><p>• If p is a polynomial over d variables that is not identically zero, the set of points in R d in which it vanishes has zero measure (see <ref type="bibr" target="#b4">Caron and Traynor (2005)</ref> for a short proof of this).</p><p>• If S ⊂ R d1 has zero measure, then S × R d2 ⊂ R d1+d2 , and every set contained within, have zero measure as well.</p><p>In the above, and in the entirety of this paper, the only measure spaces we consider are Euclidean spaces equipped with Lebesgue measure. Thus when we say that a set of d-dimensional points has zero measure, we mean that its Lebesgue measure in the d-dimensional Euclidean space is zero. Moving on to some preliminaries from matrix and tensor theory, we denote by [A] the matricization of an order-N tensor A (for simplicity, N is assumed to be even), where rows correspond to odd modes and columns correspond to even modes. Namely, if</p><formula xml:id="formula_30">A ∈ R M1×•••×M N , the matrix [A] has M 1 •M 3 • . . . •M N −1 rows and M 2 •M 4 • . . . •M N columns, rearranging the entries of the tensor such that A d1...d N is stored in row index 1+ N /2 i=1 (d 2i−1 −1) N /2 j=i+1 M 2j−1 and column index 1+ N /2 i=1 (d 2i −1) N /2</formula><p>j=i+1 M 2j . To distinguish from the tensor product operation ⊗, we denote the Kronecker product between matrices by . Specifically, for two matrices A ∈ R M1×M2 and B ∈ R N1×N2 , A B is the matrix in R M1N1×M2N2 that holds A ij B kl in row index (i − 1)N 1 + k and column index (j − 1)N 2 + l. The basic relation that binds together tensor product, matricization and Kronecker product is</p><formula xml:id="formula_31">[A ⊗ B] = [A] [B],</formula><p>where A and B are tensors of even orders. Two additional facts we will make use of are that the matricization is a linear operator (i.e. for scalars α 1 . . .α r and tensors with the same size A</p><formula xml:id="formula_32">1 . . .A r : [ r i=1 α i A i ] = r i=1 α i [A i ]</formula><p>), and less trivially, that for any matrices A and B, the rank of A B is equal to rank(A) • rank(B) (see <ref type="bibr" target="#b1">Bellman et al. (1970)</ref> for a proof). These two facts, along with the basic relation laid out above, lead to the conclusion that:</p><formula xml:id="formula_33">rank v (z) 1 ⊗ • • • ⊗ v (z) 2 L = 2 L /2 i=1 rank v (z) 2i−1 v (z) 2i v (z) 2i−1 ⊗ v (z) 2i = 1</formula><p>and thus:</p><formula xml:id="formula_34">rank Z z=1 λ z v (z) 1 ⊗ • • • ⊗ v (z) 2 L = rank Z z=1 λ z v (z) 1 ⊗ • • • ⊗ v (z) 2 L ≤ Z z=1 rank v (z) 1 ⊗ • • • ⊗ v (z) 2 L = Z</formula><p>In words, an order-2 L tensor given by a CP-decomposition (see sec. 2) with Z terms, has matricization with rank at most Z. Thus, to prove that a certain order-2 L tensor has CP-rank of at least R, it suffices to show that matricization has rank of at least R.</p><p>We now state and prove two lemmas that will be needed for our proofs of thm. 1 and 3.</p><p>Lemma 5 Let M, N ∈ N, and define the following mapping taking x ∈ R 2M N +N to three matrices:</p><formula xml:id="formula_35">A(x) ∈ R M ×N , B(x) ∈ R M ×N and D(x) ∈ R N ×N . A(x) simply holds the first M N elements of x, B(x)</formula><p>holds the following M N elements of x, and D(x) is a diagonal matrix that holds the last N elements of x on its diagonal. Define the product matrix U (x) := A(x)D(x)B(x) ∈ R M ×M , and consider the set of points x for which the rank of U (x) is different from r := min{M, N }. This set of points has zero measure. The result will also hold if the points x reside in R M N +N , and the same elements are used to assign A(x) and B(x) (A(x) ≡ B(x)).</p><p>Proof Obviously rank(U (x)) ≤ r for all x, so it remains to show that rank(U (x)) ≥ r for all x but a set of zero measure. Let U r (x) be the top-left r × r sub-matrix of U (x). If U r (x) is non-singular then of course rank(U (x)) ≥ r as required. It thus suffices to show that the set of points x for which det U r (x) = 0 has zero measure. Now, det U r (x) is a polynomial in the entries of x, and so it either vanishes on a set of zero measure, or it is the zero polynomial (see <ref type="bibr" target="#b4">Caron and Traynor (2005)</ref>). All that is left is to disqualify the latter option, and that can be done by finding a specific point x 0 for which det U r (x 0 ) = 0. Indeed, we may choose x 0 such that D(x 0 ) is the identity matrix and A(x 0 ), B(x 0 ) hold 1 on their main diagonal and 0 otherwise. This selection implies that U r (x 0 ) is the identity matrix, and in particular det U r (x 0 ) = 0.</p><p>Lemma 6 Assume we have p continuous mappings from R d to R M ×N taking the point y to the matrices A 1 (y). . .A p (y). Assume that under these mappings, the points y for which every i ∈ [p] satisfies rank(A i (y)) &lt; r form a set of zero measure. Define a mapping from R p × R d to R M ×N given by (x, y) → A(x, y) := p i=1 x i • A i (y). Then, the points (x, y) for which rank(A(x, y)) &lt; r form a set of zero measure.</p><p>Proof Denote S := {(x, y) : rank(A(x, y)) &lt; r} ⊂ R p × R d . We would like to show that this set has zero measure. We first note that since A(x, y) is a continuous mapping, and the set of matrices A ∈ R M ×N which have rank less than r is closed, S is a closed set and in particular measurable. Our strategy for computing its measure will be as follows. For every y ∈ R d we define the marginal set S y := {x : rank(A(x, y)) &lt; r} ⊂ R p . We will show that for every y but a set of zero measure, the measure of S y is zero. An application of Fubini's theorem will then prove the desired result.</p><p>Let C be the set of points y ∈ R d for which ∀i ∈ [p] : rank(A i (y)) &lt; r. By assumption, C has zero measure. We now show that for y 0 ∈ R d \ C, the measure of S y0 is zero. By the definition of C there exists an i ∈ [p] such that rank(A i (y 0 )) ≥ r. W.l.o.g., we assume that i = 1, and that the top-left r × r sub-matrix of A 1 (y 0 ) is non-singular. Regarding y 0 as fixed, the determinant of the top-left r × r sub-matrix of A(x, y 0 ) is a polynomial in the elements of x. It is not the zero polynomial, as setting x 1 = 1, x 2 = • • • = x p = 0 yields A(x, y 0 ) = A 1 (y 0 ), and the determinant of the latter's top-left r × r sub-matrix is non-zero. As a non-zero polynomial, the determinant of the top-left r × r sub-matrix of A(x, y 0 ) vanishes only on a set of zero measure <ref type="bibr" target="#b4">(Caron and Traynor (2005)</ref>). This implies that indeed the measure of S y0 is zero.</p><p>We introduce a few notations towards our application of Fubini's theorem. First, the symbol 1 will be used to represent indicator functions, e.g. 1 S is the function from R p × R d to R that receives 1 on S and 0 elsewhere. Second, we use a subscript of n N to indicate that the corresponding set is intersected with the hyper-rectangle of radius n. For example, S n stands for the intersection between S and [−n, n] p+d , and R d n stands for the intersection between R d and [−n, n] d (which is equal to the latter). All the sets we consider are measurable, and those with subscript n have finite measure. We may thus apply Fubini's theorem to get:</p><formula xml:id="formula_36">(x,y) 1 Sn = (x,y)∈R p+d n 1 S = y∈R d n x∈R p n 1 S y = y∈R d n ∩C x∈R p n 1 S y + y∈R d n \C x∈R p n 1 S y</formula><p>Recall that the set C ∈ R d has zero measure, and for every y / ∈ C the measure of S y ∈ R p is zero. This implies that both integrals in the last expression vanish, and thus 1 Sn = 0. Finally, we use the monotone convergence theorem to compute 1 S :</p><formula xml:id="formula_37">1 S = lim n→∞ 1 Sn = lim n→∞ 1 Sn = lim n→∞ 0 = 0</formula><p>This shows that indeed our set of interest S has zero measure.</p><p>With all preliminaries and lemmas in place, we turn to prove thm. 1, establishing an exponential efficiency of HT decomposition (eq. 4) over CP decomposition <ref type="bibr">(eq. 3)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof [of theorem 1]</head><p>We begin with the case of an "unshared" composition, i.e. the one given in eq. 4 (as opposed to the "shared" setting of a l,j,γ ≡ a l,γ ). Denoting for convenience φ L,1,1 := A y and r L = 1, we will show by induction over l = 1, ..., L that almost everywhere (at all points but a set of zero measure) w.r.t. {a l,j,γ } l,j,γ , all CP-ranks of the tensors {φ l,j,γ } j∈[ N /2 l ],γ∈[r l ] are at least r 2 l /2 . In accordance with our discussion in the beginning of this subsection, it suffices to consider the matricizations [φ l,j,γ ], and show that these all have ranks greater or equal to r 2 l /2 almost everywhere.</p><p>For the case l = 1 we have:</p><formula xml:id="formula_38">φ 1,j,γ = r0 α=1 a 1,j,γ α a 0,2j−1,α ⊗ a 0,2j,α</formula><p>Denote by A ∈ R M ×r0 the matrix with columns {a 0,2j−1,α } r0 α=1 , by B ∈ R M ×r0 the matrix with columns {a 0,2j,α } r0 α=1 , and by D ∈ R r0×r0 the diagonal matrix with a 1,j,γ on its diagonal. Then, we may write [φ 1,j,γ ] = ADB , and according to lemma 5 the rank of [φ 1,j,γ ] equals r := min{r 0 , M } almost everywhere w.r.t. {a 0,2j−1,α } α , {a 0,2j,α } α , a 1,j,γ . To see that this holds almost everywhere w.r.t. {a l,j,γ } l,j,γ , one should merely recall that for any dimensions d 1 , d 2 ∈ N, if the set S ⊂ R d1 has zero measure, so does any subset of S × R d2 ⊂ R d1+d2 . A finite union of zero measure sets has zero measure, thus the fact that rank[φ 1,j,γ ] = r holds almost everywhere individually for any j ∈ [ N /2] and γ ∈ [r 1 ], implies that it holds almost everywhere jointly for all j and γ. This proves our inductive hypothesis (unshared case) for l = 1.</p><p>Assume now that almost everywhere rank[φ l−1,j ,γ ] ≥ r 2 l−1 /2 for all j ∈ [ N /2 l−1 ] and γ ∈ [r l−1 ]. For some specific choice of j ∈ [ N /2 l ] and γ ∈ [r l ] we have: 1,2j,α ] for α = 1. . .r l−1 . By our inductive assumption, and by the general property rank(A B) = rank(A)•rank(B), we have that almost everywhere the ranks of all matrices M α are at least r 2 l−1 /2 • r 2 l−1 /2 = r 2 l /2 . Writing [φ l,j,γ ] = r l−1 α=1 a l,j,γ α • M α , and noticing that {M α } do not depend on a l,j,γ , we turn our attention to lemma 6. The lemma tells us that rank[φ l,j,γ ] ≥ r 2 l /2 almost everywhere. Since a finite union of zero measure sets has zero measure, we conclude that almost everywhere rank[φ l,j,γ ] ≥ r 2 l /2 holds jointly for all j ∈ [ N /2 l ] and γ ∈ [r l ]. This completes the proof of the theorem in the unshared case.</p><formula xml:id="formula_39">φ l,j,γ = r l−1 α=1 a l,j,γ α φ l−1,2j−1,α ⊗ φ l−1,2j,α =⇒ [φ l,j,γ ] = r l−1 α=1 a l,j,γ α [φ l−1,2j−1,α ] [φ l−1,2j,α ] Denote M α := [φ l−1,2j−1,α ] [φ l−</formula><p>Proving the theorem in the shared case may be done in the exact same way, except that for l = 1 one needs the version of lemma 5 for which A(x) and B(x) are equal.</p><p>We now head on to prove thm. 3, which is a generalization of thm. 1. The proof will be similar in nature to that of thm. 1, yet slightly more technical. In short, the idea is to show that in the generic case, expressing A (1) as a sum of tensor products between tensors of order 2 L2−1 requires at least r N /2 L 2 terms. Since A (2) is expressed as a sum of r L2−1 such terms, demanding</p><formula xml:id="formula_40">A (2) = A (1) implies r L2−1 ≥ r N /2 L 2 .</formula><p>To gain technical advantage and utilize known results from matrix theory (as we did when proving thm. 1), we introduce a new tensor "squeezing" operator ϕ. For q ∈ N, ϕ q is an operator that receives a tensor with order divisible by q, and returns the tensor obtained by merging together the latter's modes in groups of size q. Specifically, when applied to the tensor A ∈ R M1×•••×Mc•q (c ∈ N), ϕ q returns a tensor of order c which holds A d1...dc•q in the location defined by the following index for every mode t ∈ [c]: 1 + q i=1 (d i+q(t−1) − 1) q j=i+1 M j+q(t−1) . Notice that when applied to a tensor of order q, ϕ q returns a vector. Also note that if A and B are tensors with orders divisible by q, and λ is a scalar, we have the desirable properties:</p><formula xml:id="formula_41">• ϕ q (A ⊗ B) = ϕ q (A) ⊗ ϕ q (B) • ϕ q (λA + B) = λϕ q (A) + ϕ q (B)</formula><p>For the sake of our proof we are interested in the case q = 2 L2−1 , and denote for brevity ϕ := ϕ 2 L 2 −1 .</p><p>As stated above, we would like to show that in the generic case, expressing A (1) as</p><formula xml:id="formula_42">Z z=1 φ (z) 1 ⊗ • • • ⊗ φ (z) N /2 L 2 −1 , where φ (z) i</formula><p>are tensors of order 2 L2−1 , implies Z ≥ r N /2 L 2 . Applying ϕ to both sides of such a decomposition gives:</p><formula xml:id="formula_43">ϕ(A (1) ) = Z z=1 ϕ(φ (z) 1 ) ⊗ • • • ⊗ ϕ(φ (z) N /2 L 2 −1 )</formula><p>, where ϕ(φ (z) i ) are now vectors. Thus, to prove thm. 3 it suffices to show that in the generic case, the CP-rank of ϕ(A (1) ) is at least r N /2 L 2 , or alternatively, that the rank of the matricization [ϕ(A (1) )] is at least r N /2 L 2 . This will be our strategy in the following proof:</p><p>Proof [of theorem 3] In accordance with the above discussion, it suffices to show that in the generic case rank[ϕ(A (1) )] ≥ r N /2 L 2 . To ease the path for the reader, we reformulate the problem using slightly simpler notations. We have an order-N tensor A with dimension M in each mode, generated as follows:</p><formula xml:id="formula_44">φ 1,j,γ = r0 α=1 a 1,j,γ α a 0,2j−1,α ⊗ a 0,2j,α . . . φ l,j,γ = r l−1 α=1 a l,j,γ α φ l−1,2j−1,α order 2 l−1 ⊗ φ l−1,2j,α order 2 l−1 . . . A = r L 1 −1 α=1 a L1,1,1 α 2 L−L 1 +1 ⊗ j=1 φ L1−1,j,α order 2 L 1 −1</formula><p>where:</p><formula xml:id="formula_45">• L 1 ≤ L := log 2 N • r 0 , ..., r L1−1 ∈ N &gt;0 • a 0,j,α ∈ R M for j ∈ [N ] and α ∈ [r 0 ] • a l,j,γ ∈ R r l−1 for l ∈ [L 1 − 1], j ∈ [ N /2 l ] and γ ∈ [r l ] • a L1,1,1 ∈ R r L 1 −1</formula><p>Let L 2 be a positive integer smaller than L 1 , and let ϕ be the tensor squeezing operator that merges groups of 2 L2−1 modes. Define r := min{r 0 , ..., r L2−1 , M }. With [•] being the matricization operator defined in the beginning of the appendix, our task is to prove that rank[ϕ(A)] ≥ r N /2 L 2 almost everywhere w.r.t. {a l,j,γ } l,j,γ . We also consider the case of shared parameters -a l,j,γ ≡ a l,γ , where we would like to show that the same condition holds almost everywhere w.r.t. {a l,γ } l,γ .</p><p>Our strategy for proving the claim is inductive. We show that for l = L 2 . . .L 1 − 1, almost everywhere it holds that for all j and all γ: rank[ϕ(φ l,j,γ )] ≥ r 2 l−L 2 . We then treat the special case of l = L 1 , showing that indeed rank[ϕ(A)] ≥ r N /2 L 2 . We begin with the setting of unshared parameters (a l,j,γ ), and afterwards attend the scenario of shared parameters (a l,γ ) as well.</p><p>Our first task is to treat the case l = L 2 , i.e. show that rank[ϕ(φ L2,j,γ )] ≥ r almost everywhere jointly for all j and all γ (there is actually no need for the matricization [•] here, as ϕ(φ L2,j,γ ) are already matrices). Since a union of finitely many zero measure sets has zero measure, it suffices to show that this condition holds almost everywhere when specific j and γ are chosen. Denote by e i a vector holding 1 in entry i and 0 elsewhere, by 0 a vector of zeros, and by 1 a vector of ones. Suppose that for every j we assign a 0,j,α to be e α when α ≤ r and 0 otherwise. Suppose also that for all 1 ≤ l ≤ L 2 − 1 and all j we set a l,j,γ to be e γ when γ ≤ r and 0 otherwise. Finally, assume we set a L2,j,γ = 1 for all j and all γ. These settings imply that for every j, when γ ≤ r we have</p><formula xml:id="formula_46">φ L2−1,j,γ = ⊗ 2 L 2 −2</formula><p>j=1 (e γ ⊗ e γ ), i.e. the tensor φ L2−1,j,γ holds 1 in location (γ, ..., γ) and 0 elsewhere. If γ &gt; r then φ L2−1,j,γ is the zero tensor. We conclude from this that there are indices 1 ≤ i 1 &lt; ... &lt; i r ≤ M L2−1 such that ϕ(φ L2−1,j,γ ) = e iγ for γ ≤ r, and that for γ &gt; r we have ϕ(φ L2−1,j,γ ) = 0. We may thus write:</p><formula xml:id="formula_47">ϕ(φ L2,j,γ ) = ϕ r L 2 −1 α=1 φ L2−1,2j−1,α ⊗ φ L2−1,2j,α = r L 2 −1 α=1 ϕ(φ L2−1,2j−1,α )⊗ϕ(φ L2−1,2j,α ) = r α=1</formula><p>e iα e iα Now, since i 1 . . .i r are different from each other, the matrix ϕ(φ L2,j,γ ) has rank r. This however does not prove our inductive hypothesis for l = L 2 . We merely showed a specific parameter assignment for which it holds, and we need to show that it is met almost everywhere. To do so, we consider an r × r sub-matrix of ϕ(φ L2,j,γ ) which is non-singular under the specific parameter assignment we defined. The determinant of this sub-matrix is a polynomial in the elements of {a l,j,γ } l,j,γ which we know does not vanish with the specific assignments defined. Thus, this polynomial vanishes at subset of {a l,j,γ } l,j,γ having zero measure (see <ref type="bibr" target="#b4">Caron and Traynor (2005)</ref>). That is to say, the sub-matrix of ϕ(φ L2,j,γ ) has rank r almost everywhere, and thus ϕ(φ L2,j,γ ) has rank at least r almost everywhere. This completes our treatment of the case l = L 2 .</p><p>We now turn to prove the propagation of our inductive hypothesis. Let l ∈ {L 2 + 1, ..., L 1 − 1}, and assume that our inductive hypothesis holds for l − 1. Specifically, assume that almost everywhere w.r.t. {a l,j,γ } l,j,γ , we have that rank[ϕ(φ l−1,j,γ )] ≥ r 2 l−1−L 2 jointly for all j ∈ [ N /2 l−1 ] and all γ ∈ [r l−1 ]. We would like to show that almost everywhere, rank[ϕ(φ l,j,γ )] ≥ r 2 l−L 2 jointly for all j ∈ [ N /2 l ] and all γ ∈ [r l ]. Again, the fact that a finite union of zero measure sets has zero measure implies that we may prove the condition for specific j ∈ [ N /2 l ] and γ ∈ [r l ]. Applying the squeezing operator ϕ followed by matricization [•] to the recursive expression for φ l,j,γ , we get:</p><formula xml:id="formula_48">[ϕ(φ l,j,γ )] = ϕ r l−1 α=1 a l,j,γ α φ l−1,2j−1,α ⊗ φ l−1,2j,α = r l−1 α=1 a l,j,γ α ϕ(φ l−1,2j−1,α ) ⊗ ϕ(φ l−1,2j,α ) = r l−1 α=1 a l,j,γ α [ϕ(φ l−1,2j−1,α )] [ϕ(φ l−1,2j,α )] For α = 1. . .r l−1 , denote the matrix [ϕ(φ l−1,2j−1,α )] [ϕ(φ l−1,2j,α )] by M α .</formula><p>The fact that the Kronecker product multiplies ranks, along with our inductive assumption, imply that almost everywhere rank</p><formula xml:id="formula_49">(M α ) ≥ r 2 l−1−L 2 • r 2 l−1−L 2 = r 2 l−L 2 .</formula><p>Noting that the matrices M α do not depend on a l,j,γ , we apply lemma 6 and conclude that almost everywhere rank[ϕ(φ l,j,γ )] ≥ r 2 l−L 2 , which completes the prove of the inductive propagation.</p><p>Next, we treat the special case l = L 1 . We assume now that almost everywhere rank[ϕ(φ L1−1,j,γ )] ≥ r 2 L 1 −1−L 2 jointly for all j and all γ. Again, we apply the squeezing operator ϕ followed by matricization [•], this time to both sides of the expression for A:</p><formula xml:id="formula_50">[ϕ(A)] = r L 1 −1 α=1 a L1,1,1 α 2 L−L 1 +1 j=1 [ϕ(φ L1−1,j,α )] As before, denote M α := 2 L−L 1 +1 j=1 [ϕ(φ L1−1,j,α )] for α = 1. . .r L1−1 .</formula><p>Using again the multiplicative rank property of the Kronecker product along with our inductive assumption, we get that almost everywhere rank(M α ) ≥</p><formula xml:id="formula_51">2 L−L 1 +1 j=1 r 2 L 1 −1−L 2 = r L−L2 . Noticing that {M α } α∈[r L 1 −1 ]</formula><p>do not depend on a L1,1,1 , we apply lemma 6 for the last time and get that almost everywhere (w.r.t. {a l,j,γ } l,j,γ ), the rank of [ϕ(A)] is at least r L−L2 . This completes our proof in the case of unshared parameters.</p><p>Proving the theorem in the case of shared parameters (a l,j,γ ≡ a l,γ ) can be done in the exact same way as above. In fact, all one has to do is omit the references to j and the proof will apply. Notice in particular that the specific parameter assignment we defined to handle l = L 2 was completely symmetric, i.e. it did not include any dependence on j.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.2. Proof of Corollaries 2 and 4</head><p>Corollaries 2 and 4 are a direct continuation of thm. 1 and 3 respectively. In the theorems, we have shown that almost all coefficient tensors generated by a deep network cannot be realized by a shallow network if the latter does not meet a certain minimal size requirement. The corollaries take this further, by stating that given linearly independent representation functions f θ1 . . .f θ M , not only is efficient realization of coefficient tensors generally impossible, but also efficient approximation of score functions. To prove this extra step, we recall from the proofs of thm. 1 and 3 (app. B.1) that in order to show separation between the coefficient tensor of a deep network and that of a shallow network, we relied on matricization rank. Specifically, we derived constants R D , R S ∈ N, R D &gt; R S , such that the matricization of a deep network's coefficient tensor had rank greater or equal to R D , whereas the matricization of a shallow network's coefficient tensor had rank smaller or equal to R S . Given this observation, corollaries 2 and 4 readily follow from lemma 7 below (the lemma relies on basic concepts and results from the topic of L 2 Hilbert spaces -see app. C.1 for a brief discussion on the matter).</p><p>Lemma 7 Let f θ1 . . .f θ M ∈L 2 (R s ) be a set of linearly independent functions, and denote by T the (Euclidean) space of tensors with order N and dimension M in each mode. For a given tensor A ∈ T , denote by h(A) the function in L 2 (R s ) N defined by:</p><formula xml:id="formula_52">(x 1 , . . . , x N ) h(A) → M d1,...,d N =1 A d1...d N N i=1 f θ d i (x i )</formula><p>Let {A λ } λ∈Λ ⊂ T be a family of tensors, and A * be a certain target tensor that lies outside the family. Assume that for all λ ∈ Λ we have rank([A λ ]) &lt; rank([A * ]), where [•] is the matricization operator defined in app. B.1. Then, the distance in L 2 (R s ) N between h(A * ) and {h(A λ )} λ∈Λ is strictly positive, i.e. there exists an &gt; 0 such that:</p><formula xml:id="formula_53">∀λ ∈ Λ : h(A λ ) − h(A * ) 2 &gt; Proof The fact that {f θ d (x)} d∈[M ] are linearly independent in L 2 (R s ) implies that the product functions { N i=1 f θ d i (x i )} d1...d N ∈[M ] are linearly independent in L 2 (R s ) N (see app. C.1). Let (h (t) ) ∞ t=1 be a se- quence of functions that lie in the span of { N i=1 f θ d i (x i )} d1...d N ∈[M ]</formula><p>, and for every t ∈ N denote by A (t)  the coefficient tensor of h (t) under this basis, i.e. A (t) ∈ T is defined by:</p><formula xml:id="formula_54">h (t) (x 1 , . . . , x N ) = M d1,...,d N =1 A (t) d1,...,d N N i=1 f θ d i (x i ) Assume that (h (t) ) ∞ t=1 converges to h(A * ) in L 2 (R s ) N : lim t→∞ h (t) − h(A * ) 2 = 0</formula><p>In a finite-dimensional Hilbert space, convergence in norm implies convergence in representation coefficients under any preselected basis. We thus have:</p><formula xml:id="formula_55">∀d 1 . . .d N ∈ [M ] : A (t) d1,...,d N t→∞ −−−→ A * d1,...,d N</formula><p>This means in particular that in the tensor space T , A * lies in the closure of {A (t) } ∞ t=1 . Accordingly, in order to show that the distance in L 2 (R s ) N between h(A * ) and {h(A λ )} λ∈Λ is strictly positive, it suffices to show that the distance in T between A * and {A λ } λ∈Λ is strictly positive, or equivalently, that the distance between the matrix [A * ] and the family of matrices {[A λ ]} λ∈Λ is strictly positive. This however is a direct implication of the assumption ∀λ ∈ Λ : rank([A λ ]) &lt; rank([A * ]).</p><p>(point-wise) addition and scalar multiplication, as well as the inner-product defined by integral over pointwise multiplication. The topic of L 2 function spaces lies at the heart of functional analysis, and requires basic knowledge in measure theory. We present here the bare necessities required to follow this appendix, referring the interested reader to <ref type="bibr" target="#b36">Rudin (1991)</ref> for a more comprehensive introduction.</p><p>For our purposes, it suffices to view an L 2 space as a vector space of all functions f satisfying f 2 &lt; ∞. This vector space is infinite dimensional, and a set of functions F ⊂ L 2 is referred to as total if the closure of its span covers the entire space, i.e. if for any function g ∈ L 2 and &gt; 0, there exist functions f 1 . . .f K ∈ F and coefficients c 1 . .</p><formula xml:id="formula_56">.c K ∈ R such that | K i=1 c i • f i − g| 2 &lt; .</formula><p>F is regarded as linearly independent if all of its finite subsets are linearly independent, i.e. for any f <ref type="table">and c 1</ref> </p><formula xml:id="formula_57">1 . . .f K ∈ F, f i = f j ,</formula><formula xml:id="formula_58">. . .c K ∈ R, if K i=1 c i • f i = 0 then c 1 = • • • = c K = 0.</formula><p>A non-trivial result states that L 2 spaces in general must contain total and linearly independent sets, and moreover, for any s ∈ N, L 2 (R s ) contains a countable set of this type. It seems reasonable to draw an analogy between total and linearly independent sets in L 2 space, and bases in a finite dimensional vector space. While this analogy is indeed appropriate from our perspective, total and linearly independent sets are not to be confused with bases for L 2 spaces, which are typically defined to be orthonormal.</p><p>It can be shown (see for example <ref type="bibr" target="#b12">Hackbusch (2012)</ref>) that for any natural numbers s and N , if {f d (x)} d∈N is a total or a linearly independent set in L 2 (R s ), then {(x 1 , . . . , x N ) → N i=1 f di (x i )} d1...d N ∈N , the induced point-wise product functions on (R s ) N , form a set which is total or linearly independent, respectively, in L 2 (R s ) N . As we now briefly outline, this result actually emerges from a deep relation between tensor products and Hilbert spaces. The definitions given in sec. 2 for a tensor, tensor space, and tensor product, are actually concrete special cases of much deeper, abstract algebraic concepts. A more formal line of presentation considers multiple vector spaces V 1 . . .V N , and defines their tensor product space V 1 ⊗ • • • ⊗V N to be a specific quotient space of the space freely generated by their Cartesian product set. For every combination of vectors v (i) ∈ V i , i ∈ [N ], there exists a corresponding element v (1) ⊗ • • • ⊗v (N ) in the tensor product space, and moreover, elements of this form span the entire space. If V 1 . . .V N are Hilbert spaces, it is possible to equip V 1 ⊗ • • • ⊗V N with a natural inner-product operation, thereby turning it too into a Hilbert space. It may then be shown that if the sets {v</p><formula xml:id="formula_59">(i) α } α ⊂ V i , i ∈ [N ]</formula><p>, are total or linearly independent, elements of the form v</p><p>(1)</p><formula xml:id="formula_60">α1 ⊗ • • • ⊗ v (N )</formula><p>α N are total or linearly independent, respectively, in V 1 ⊗ • • • ⊗V N . Finally, when the underlying Hilbert spaces are L 2 (R s ), the point-wise product mapping</p><formula xml:id="formula_61">f 1 (x)⊗ • • • ⊗f N (x) → N i=1 f i (x i ) from the tensor product space L 2 (R s ) ⊗N := L 2 (R s )⊗ • • • ⊗L 2 (R s ) to L 2 (R s ) N</formula><p>, induces an isomorphism of Hilbert spaces.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.2. Construction</head><p>Recall from sec. 3 that our instance space is defined as X := (R s ) N , in accordance with the common practice of representing natural data through ordered local structures (for example images are often represented through small patches around their pixels). We classify instances into categories Y := {1. . .Y } via maximization of per-label score functions {h y : (R s ) N → R} y∈Y . Our hypotheses space H is defined to be the subset of L 2 (R s ) N from which score functions may be taken. In app. C.1 we stated that if {f d (x)} d∈N is a total set in L 2 (R s ), i.e. if every function in L 2 (R s ) can be arbitrarily well approximated by a linear combination of a finite subset of {f d (x)} d∈N , then the pointwise products {(x 1 , . . . , x N ) → N i=1 f di (x j )} d1,...,d N ∈N form a total set in L 2 (R s ) N . Accordingly, in a universal hypotheses space H = L 2 (R s ) N , any score function h y may be arbitrarily well approximated by finite linear combinations of such point-wise products. A possible formulation of this would be as follows. Assume we are interested in -approximation of the score function h y , and consider a formal tensor A y having N modes and a countable infinite dimension in each mode i ∈ [N ], indexed by d i ∈ N. Then, there exists such a tensor, with all but a finite number of entries set to zero, for which:</p><formula xml:id="formula_62">h y (x 1 , . . . , x N ) ≈ d1...d N ∈N A y d1,...,d N N i=1 f di (x i ) (6)</formula><p>Given that the set of functions {f d (x)} d∈N ⊂L 2 (R s ) is total, eq. 6 defines a universal hypotheses space. There are many possibilities for choosing a total set of functions. Wavelets are perhaps the most obvious choice, and were indeed used in a deep network setting by <ref type="bibr" target="#b4">Bruna and Mallat (2012)</ref>. The special case of Gabor wavelets has been claimed to induce features that resemble representations in the visual cortex <ref type="bibr" target="#b37">(Serre et al. (2005)</ref>). Two options we pay special attention to due to their importance in practice are: where h y (x 1 , . . . , x N ) is of the form:</p><formula xml:id="formula_63">h y (x 1 , . . . , x N ) = M d1,...,d N =1 A y d1,...,d N N i=1 f θ d i (x i ) (2)</formula><p>and {f θ } d∈[M ] are selected from a parametric family of functions F = {f θ : R s → R} θ∈Θ . For universality, i.e. for the ability of score functions h y to approximate any function in L 2 (X ) as M → ∞, we required that it be possible to choose a countable subset of F that is total in L 2 (R s ). We noted that the families of Gaussians (eq. 7) and neurons (eq. 8) meet this requirement.</p><p>In this subsection we formalize our argument that a finite value for M is sufficient when X represents natural data, and in particular, natural images. Based on empirical studies characterizing the statistical properties of natural images, and in compliance with the number of channels in a typical convolutional network layer, we find that M on the order of 100 typically suffices.</p><p>Let D be a distribution of labeled instances (X, ȳ) over X × Y (we use bar notation to distinguish the label ȳ from the running index y), and D X be the induced marginal distribution of instances X over X . We would like to show, given particular assumptions on D, that there exist functions f θ1 , . . . , f θ M ∈ F and tensors A 1 , . . . , A Y of order N and dimension M in each mode, such that the score functions h y defined in eq. 2 achieve low classification error:</p><formula xml:id="formula_64">L 0−1 D (h 1 , . . . , h Y ) := E (X,ȳ)∼D 1 ȳ = argmax y∈Y h y (X)<label>(9)</label></formula><p>1 [•] here stands for the indicator function, taking the value 1 when its argument is true, and 0 otherwise.</p><p>Let {h * y } y∈Y be a set of "ground truth" score functions for which optimal prediction is achieved, or more specifically, for which the expected hinge-loss (upper bounds the 0-1 loss) is minimal:</p><formula xml:id="formula_65">(h * 1 , . . . , h * Y ) = argmin h 1 ,...,h Y :X →R L hinge D (h 1 , . . . , h Y )</formula><p>where:</p><formula xml:id="formula_66">L hinge D (h 1 , . . . , h Y ) := E (X,ȳ)∼D max y∈Y 1 [y = ȳ] + h y (X) − h ȳ (X)<label>(10)</label></formula><p>Our strategy will be to select score functions h y of the format given in eq. 2, that approximate h * y in the sense of low expected maximal absolute difference:</p><formula xml:id="formula_67">E := E X∼D X max y∈Y h y (X) − h * y (X)<label>(11)</label></formula><p>We refer to E as the score approximation error obtained by h y . The 0-1 loss of h y with respect to the labeled example (X, ȳ) ∈ X × Y is bounded as follows:</p><formula xml:id="formula_68">1 ȳ = argmax y∈Y h y (X) ≤ max y∈Y {1 [y = ȳ] + h y (X)} − h ȳ (X) = max y∈Y 1 [y = ȳ] + h * y (X) + h y (X) − h * y (X) − h * ȳ (X) + h * ȳ (X) − h ȳ (X) ≤ max y∈Y 1 [y = ȳ] + h * y (X) − h * ȳ (X) + max y∈Y h y (X) − h * y (X) + h * ȳ (X) − h ȳ (X) ≤ max y∈Y 1 [y = ȳ] + h * y (X) − h * ȳ (X) + 2 max y∈Y h y (X) − h * y (X)</formula><p>Taking expectation of the first and last terms above with respect to (X, ȳ) ∼ D, and recalling the definitions given in eq. 9, 10 and 11, we get:</p><formula xml:id="formula_69">L 0−1 D (h 1 , . . . , h Y ) ≤ L hinge D (h * 1 , . . . , h * Y ) + 2E</formula><p>In words, the classification error of the score functions h y is bounded by the optimal expected hinge-loss plus a term equal to twice their score approximation error. Recall that we did not constrain the optimal score functions h * y in any way. Thus, assuming a label is deterministic given an instance, the optimal expected hinge-loss is essentially zero, and the classification error of h y is dominated by their score approximation error E (eq. 11). Our problem thus translates to showing that h y can be selected such that E is small.</p><p>At this point we introduce our main assumption on the distribution D, or more specifically, on the marginal distribution of instances D X . According to various studies, in natural settings, the marginal distribution of individual vectors in X , e.g. of small patches in images, may be relatively well captured by a Gaussian Mixture Model (GMM) with a moderate number (on the order of 100 or less) of distinct components. For example, it was shown in <ref type="bibr" target="#b49">Zoran and Weiss (2012)</ref> that natural image patches of size 2×2, 4×4, 8×8 or 16×16, can essentially be modeled by GMMs with 64 components (adding more components barely improved the log-likelihood). This complies with the common belief that a moderate number of low-level templates suffices in order to model the vast majority of local image patches. Following this line, we model the marginal distribution of x i with a GMM having M components with means µ 1 . . .µ M ∈ R s . We assume that the components are well localized, i.e. that their standard deviations are small compared to the distances between means, and also compared to the variation of the target functions h * y . In the context of images for example, the latter two assumptions imply that a local patch can be unambiguously assigned to a template, and that the assignment of patches to templates determines the class of an image. Returning to general instances X, their probability mass will be concentrated in distinct regions of the space X , in which for every i ∈ [N ], the vector x i lies near µ ci for some c i ∈ [M ]. The score functions h * y are approximately constant in each such region. It is important to stress here that we do not assume statistical independence of x i 's, only that their possible values can be quantized into M templates µ 1 , . . . , µ M .</p><p>Under our idealized assumptions on D X , the expectation in the score approximation error E can be discretized as follows:</p><formula xml:id="formula_70">E := E X∼D X max y∈Y h y (X) − h * y (X) = M c1,...,c N =1 P c1,...,c N max y∈Y h y (M c1,...,c N ) − h * y (M c1,...,c N )<label>(12</label></formula><p>) where M c1,...,c N := (µ c1 , . . . , µ c N ) and P c1,...,c N stands for the probability that x i lies near µ ci for every i ∈ [N ] (P c1,...,c N ≥0, c1,...,c N P c1,...,c N = 1). We now turn to show that f θ1 . . .f θ M can be chosen to separate GMM components, i.e. such that for every c, d ∈ [M ], f θ d (µ c ) = 0 if and only if c = d. If the functions f θ are Gaussians (eq. 7), we can simply set the mean of f θ d to µ d , and its standard deviations to be low enough such that the function effectively vanishes at µ c when c = d. If f θ are neurons (eq. 8), an additional requirement is needed, namely that the GMM component means µ 1 . . .µ M be linearly separable. In other words, we require that for every d ∈ [M ], there exist w d ∈ R s and b d ∈ R for which w d µ c + b d is positive if c = d and negative otherwise. This may seem like a strict assumption at first glance, but notice that the dimension s is often as large, or even larger, then the number of components M . In addition, if input vectors x i are normalized to unit length (a standard practice with image patches for example), µ 1 . . .µ M will also be normalized, and thus linear separability is trivially met. 0 when c =d, and that would ensure that in this case f θ d (µ c ) effectively vanishes. Assuming we have chosen f θ1 . . .f θ M to separate GMM components, and plugging-in the format of h y given in eq. 2, we get the following convenient form for h y (M c1,...,c N ):</p><formula xml:id="formula_71">h y (M c1,...,c N ) = A y c1,...,c N N i=1 f θc i (µ ci )</formula><p>Assigning the coefficient tensors through the following rule:</p><formula xml:id="formula_72">A y c1,...,c N = h * y (M c1,...,c N ) N i=1 f θc i (µ ci ) implies: h y (M c1,...,c N ) = h * y (M c1,...,c N ) for every y ∈ Y and c 1 . . .c N ∈ [M ].</formula><p>Plugging this into eq. 12, we get a score approximation error of zero.</p><p>To recap, we have shown that when the parametric functions f θ are Gaussians (eq. 7) or neurons (eq. 8), not only are the score functions h y given in eq. 2 universal when M → ∞ (see app. C.2), but they can also achieve zero classification error (eq. 9) with a moderate value of M (on the order of 100) if the underlying data distribution D is "natural". In this context, D is regarded as natural if it satisfies two conditions. The first, which is rather mild, requires that a label be completely determined by the instance. For example, an image will belong to one category with probability one, and to the rest of the categories with probability zero. The second condition, which is far more restrictive, states that input vectors composing an instance can be quantized into a moderate number (M ) of templates. The assumption that natural images exhibit this property is based on various empirical studies where it is shown to hold approximately. Since it does not hold exactly, our analysis is approximate, and its implication in practice is that the classification error introduced by constraining score functions to have the format given in eq. 2, is negligible compared to other sources of error (factorization of the coefficient tensors, finiteness of training data and difficulty in optimization).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix D. Related Work</head><p>The classic approach for theoretically analyzing the power of depth focused on investigation of the computational complexity of boolean circuits. An early result, known as the "exponential efficiency of depth", may be summarized as follows: for every integer k, there are boolean functions that can be computed by a circuit comprising alternating layers of AND and OR gates which has depth k and polynomial size, yet if one limits the depth to k − 1 or less, an exponentially large circuit is required. See <ref type="bibr" target="#b41">Sipser (1983)</ref> for a formal statement of this classic result. Recently, <ref type="bibr" target="#b35">Rossman et al. (2015)</ref> have established a somewhat stronger result, showing cases where not only are polynomially wide shallow boolean circuits incapable of exact realization, but also of approximation (i.e. of agreeing with the target function on more than a specified fraction of input combinations). Other classical results are related to threshold circuits, a class of models more similar to contemporary neural networks than boolean circuits. Namely, they can be viewed as neural networks where each neuron computes a weighted sum of its inputs (possibly including bias), followed by threshold activation (σ(z) = 1[z ≥ 0]). For threshold circuits, the main known result in our context is the existence of functions that separate depth 3 from depth 2 (see <ref type="bibr" target="#b14">Hajnal et al. (1987)</ref> for a statement relating to exact realization, and the techniques in <ref type="bibr" target="#b26">Maass et al. (1994)</ref>; <ref type="bibr" target="#b28">Martens et al. (2013)</ref> for extension to approximation).</p><p>More recent studies focus on arithmetic circuits <ref type="bibr" target="#b39">(Shpilka and Yehudayoff (2010)</ref>), whose nodes typically compute either a weighted sum or a product of their inputs 9 (besides their role in studying expressiveness, deep networks of this class have been shown to support provably optimal training <ref type="bibr" target="#b25">Livni et al. (2014)</ref>). A special case of this are the Sum-Product Networks (SPNs) presented in <ref type="bibr" target="#b33">Poon and Domingos (2011)</ref>. SPNs are a class of deep generative models designed to efficiently compute probability density functions. Their summation weights are typically constrained to be non-negative (such an arithmetic circuit is called monotone), and in addition, in order for them to be valid (i.e. to be able to compute probability density functions), additional architectural constraints are needed (e.g. decomposability and completeness). The most widely known theoretical arguments regarding the efficiency of depth in SPNs were given in <ref type="bibr" target="#b8">Delalleau and Bengio (2011)</ref>. In this work, two specific families of SPNs were considered, both comprising alternating sum and product layers -a family F whose nodes form a full binary tree, and a family G with n nodes per layer (excluding the output), each connected to n − 1 nodes in the preceding layer. The authors show that functions implemented by these networks require an exponential number of nodes in order to be realized by shallow (single 9. There are different definitions for arithmetic circuits in the literature. We adopt the definition given in <ref type="bibr" target="#b27">Martens and Medabalimi (2014)</ref>, under which an arithmetic circuit is a directed acyclic graph, where nodes with no incoming edges correspond to inputs, nodes with no outgoing edges correspond to outputs, and the remaining nodes are either labeled as "sum" or as "product". A product node computes the product of its child nodes. A sum node computes a weighted sum of its child nodes, where the weights are parameters linked to its incoming edges.</p><p>hidden-layer networks). The limitations of this work are twofold. First, as the authors note themselves, it only analyzes the ability of shallow networks to realize exactly functions generated by deep networks, and does not provide any result relating to approximation. Second, the specific SPN families considered in this work are not universal hypothesis classes and do not resemble networks used in practice. Recently, <ref type="bibr" target="#b27">Martens and Medabalimi (2014)</ref> proved that there exist functions which can be efficiently computed by decomposable and complete (D&amp;C) SPNs of depth d + 1, yet require a D&amp;C SPN of depth d or less to have super-polynomial size for exact realization. This analysis only treats approximation in the limited case of separating depth 4 from depth 3 (D&amp;C) SPNs. Additionally, it only deals with specific separating functions, and does not convey information regarding how frequent these are. In other words, according to this analysis, it may be that almost all functions generated by deep networks can be efficiently realized by shallow networks, and there are only few pathological functions for which this does not hold. A further limitation of this analysis is that for general d, the separation between depths d + 1 and d is based on a multilinear circuit result by <ref type="bibr" target="#b34">Raz and Yehudayoff (2009)</ref>, that translates into a network that once again does not follow the common practices of deep learning.</p><p>There have been recent attempts to analyze the efficiency of network depth in other settings as well. The most commonly used type of neural networks these days includes neurons that compute a weighted sum of their inputs (with bias) followed by Rectified Linear Unit (ReLU) activation (σ(z) = max{0, z}). <ref type="bibr" target="#b31">Pascanu et al. (2013) and</ref><ref type="bibr" target="#b29">Montufar et al. (2014)</ref> study the number of linear regions that may be expressed by such networks as a function of their depth and width, thereby showing existence of functions separating deep from shallow (depth 2) networks. <ref type="bibr" target="#b47">Telgarsky (2015)</ref> shows a simple construction of a depth d width 2 ReLU network that operates on one-dimensional inputs, realizing a function that cannot be approximated by ReLU networks of depth o(d/ log d) and width polynomial in d. <ref type="bibr" target="#b9">Eldan and Shamir (2015)</ref> provides functions expressible by ReLU networks of depth 3 and polynomial width, which can only be approximated by a depth 2 network if the latter's width is exponential. The result in this paper applies not only to ReLU activation, but also to the standard sigmoid (σ(z) = 1/(1 + e −z )), and more generally, to any universal activation (see assumption 1 in <ref type="bibr" target="#b9">Eldan and Shamir (2015)</ref>). <ref type="bibr" target="#b3">Bianchini and Scarselli (2014)</ref> also considers different types of activations, studying the topological complexity (through Betti numbers) of decision regions as a function of network depth, width and activation type. The results in this paper establish the existence of deep vs. shallow separating functions only for the case of polynomial activation. While the above works do address more conventional neural networks, they do not account for the structure of convolutional networks -the most successful deep learning architectures to date, and more importantly, they too prove only existence of some separating functions, without providing any insight as to how frequent these are.</p><p>We are not the first to incorporate ideas from the field of tensor analysis into deep learning. <ref type="bibr" target="#b42">Socher et al. (2013)</ref>, <ref type="bibr" target="#b48">Yu et al. (2012)</ref>, <ref type="bibr" target="#b38">Setiawan et al. (2015)</ref>, and <ref type="bibr" target="#b18">Hutchinson et al. (2013)</ref> all proposed different neural network architectures that include tensor-based elements, and exhibit various advantages in terms of expressiveness and/or ease of training. In <ref type="bibr" target="#b19">Janzamin et al. (2015)</ref>, an alternative algorithm for training neural networks is proposed, based on tensor decomposition and Fourier analysis, with proven generalization bounds. In <ref type="bibr" target="#b30">Novikov et al. (2014)</ref>, <ref type="bibr">Anandkumar et al. (2014), Yang and</ref><ref type="bibr" target="#b47">Dunson (2015)</ref> and <ref type="bibr" target="#b43">Song et al. (2013)</ref>, algorithms for tensor decompositions are used to estimate parameters of different graphical models. Notably, <ref type="bibr" target="#b43">Song et al. (2013)</ref> uses the relatively new Hierarchical Tucker decomposition <ref type="bibr" target="#b11">(Hackbusch and Kühn (2009)</ref>) that we employ in our work, with certain similarities in the formulations. The works differ considerably in their objectives though: while <ref type="bibr" target="#b43">Song et al. (2013)</ref> focuses on the proposal of a new training algorithm, our purpose in this work is to analyze the expressive efficiency of networks and how that depends on depth. Recently, <ref type="bibr" target="#b22">Lebedev et al. (2014)</ref> modeled the filters in a convolutional network as four dimensional tensors, and used the CP decomposition to construct an efficient and accurate approximation. Another work that draws a connection between tensor analysis and deep learning is the recent study presented in <ref type="bibr" target="#b13">Haeffele and Vidal (2015)</ref>. This work shows that with sufficiently large neural networks, no matter how training is initialized, there exists a local optimum that is accessible with gradient descent, and this local optimum is approximately equivalent to the global optimum in terms of objective value.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: HT model -convolutional arithmetic circuit implementing hierarchical decomposition.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>7. If denotes the Kronecker product, then for any matrices A and B: rank(A B) = rank(A)•rank(B). 8. Hence the definition of border rank, see<ref type="bibr" target="#b12">Hackbusch (2012)</ref>.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Assuming we have linear separability, one may set θ d = (w d , b d ), and for threshold or ReLU activations we indeed get f θ d (µ c ) = 0 ⇐⇒ c = d. With sigmoid activations, we may need to scale (w d , b d ) so that w d µ c + b d</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>input representation 1x1 conv pooling 1x1 conv pooling dense (output) hidden layer 0 hidden layer L-1 (L=log 2 N)</head><label></label><figDesc></figDesc><table><row><cell>  , rep i d</cell><cell></cell><cell>f </cell><cell>d</cell><cell>  i x</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Most of the previous works relating to depth efficiency (see app. D) merely show existence of functions that separate depths (i.e. that are efficiently realizable by a deep network yet require super-polynomial size from shallow networks). Corollary 2 on the other hand establishes depth efficiency for almost all functions that a deep network can implement. Equally importantly, it applies to deep learning architectures that are being successfully employed in practice (SimNets -see app. E).</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_0">. To see this, simply assign the first level vectors a 0,j,γ with CP's basis vectors, the last level weights with CP's per-class weights, and the intermediate levels' weights with indicator vectors.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>Amnon Shashua would like to thank Tomaso Poggio and Shai S. Shwartz for illuminating discussions during the preparation of this manuscript. We would also like to thank Tomer Galanti, Tamir Hazan and Lior Wolf for commenting on draft versions of the paper. The work is partly funded by Intel grant ICRI-CI no. 9-2012-6133 and by ISF Center grant 1790/12. Nadav Cohen is supported by a Google Fellowship in Machine Learning.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix C. Derivation of Hypotheses Space</head><p>In order to keep the body of the paper at a reasonable length, the presentation of our hypotheses space (eq. 2) in sec. 3 did not provide the grounds for its definition. In this appendix we derive the hypotheses space step by step. After establishing basic preliminaries on the topic of L 2 spaces, we utilize the notion of tensor products between such spaces to reach a universal representation as in eq. 2 but with M → ∞. We then make use of empirical studies characterizing the statistics of natural images, to argue that in practice a moderate value of M (M ∈ Ω(100)) suffices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.1. Preliminaries on L 2 Spaces</head><p>When dealing with functions over scalars, vectors or collections of vectors, we consider L 2 spaces, or more formally, the Hilbert spaces of Lebesgue measurable square-integrable real functions equipped with standard ( <ref type="formula">8</ref>)</p><p>In both cases, there is an underlying parametric family of functions F = {f θ : R s → R} θ∈Θ of which a countable total subset may be chosen. The fact that Gaussians as above are total in L 2 (R s ) has been proven in <ref type="bibr" target="#b10">Girosi and Poggio (1990)</ref>, and is a direct corollary of the Stone-Weierstrass theorem. To achieve countability, simply consider Gaussians with rational parameters (mean and variances). In practice, the choice of Gaussians (with diagonal covariance) give rises to a "similarity" operator as described by the SimNet architecture <ref type="bibr">(Cohen and Shashua (2014)</ref>; <ref type="bibr">Cohen et al. (2016)</ref>). For the case of neurons we must restrict the domain R s to some bounded set, otherwise the functions are not integrable. This however is not a limitation in practice, and indeed neurons are widely used across many application domains. The fact that neurons are total has been proven in <ref type="bibr" target="#b7">Cybenko (1989)</ref> and <ref type="bibr" target="#b17">Hornik et al. (1989)</ref> for threshold and sigmoid activations. More generally, it has been proven in <ref type="bibr" target="#b44">Stinchcombe and White (1989)</ref> for a wide class of activation functions, including linear combinations of ReLU. See <ref type="bibr" target="#b32">Pinkus (1999)</ref> for a survey of such results. For countability, we may again restrict parameters (weights and bias) to be rational.</p><p>In the case of Gaussians and neurons, we argue that a finite set of functions suffices, i.e. that it is possible to choose f θ1 . . .f θ M ∈ F that will suffice in order to represent score functions required for natural tasks. Moreover, we claim that M need not be large (e.g. on the order of 100). Our argument relies on statistical properties of natural images, and is fully detailed in app. C.3. It implies that under proper choice of</p><p>spans the score functions of interest, and we may define for each label y a tensor A y of order N and dimension M in each mode, such that:</p><p>which is exactly the hypotheses space presented in sec. 3. Notice that if {f θ d (x)} d∈[M ] ⊂L 2 (R s ) are linearly independent (there is no reason to choose them otherwise), then so are the product functions</p><p>), and a score function h y uniquely determines the coefficient tensor A y . In other words, two score functions h y,1 and h y,2 are identical if and only if their coefficient tensors A y,1 and A y,2 are the same.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.3. Finite Function Bases for Classification of Natural Data</head><p>In app. C.2 we laid out the framework of classifying instances in the space X := {(x 1 , . . . , x N ) : x i ∈ R s } = (R s ) N into labels Y := {1, . . . , Y } via maximization of per-label score functions h y : X → R:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix E. Computation in Log-Space with SimNets</head><p>A practical issue one faces when implementing arithmetic circuits is the numerical instability of the product operation -a product node with a large number of inputs is easily susceptible to numerical overflow or underflow. A common solution to this is to perform the computations in log-space, i.e. instead of computing activations we compute their log. This requires the activations to be non-negative to begin with, and alters the sum and product operations as follows. A product simply turns into a sum, as log i α i = i log α i . A sum becomes what is known as log-sum-exp or softmax: log i α i = log i exp(log α i ).</p><p>Turning to our networks, the requirement that all activations be non-negative does not limit their universality. The reason for this is that the functions f θ are non-negative in both cases of interest -Gaussians (eq. 7) and neurons (eq. 8). In addition, one can always add a common offset to all coefficient tensors A y , ensuring they are positive without affecting classification. Non-negative decompositions (i.e. decompositions with all weights holding non-negative values) can then be found, leading all network activations to be non-negative. In general, non-negative tensor decompositions may be less efficient than unconstrained decompositions, as there are cases where a non-negative tensor supports an unconstrained decomposition that is smaller than its minimal non-negative decomposition. Nevertheless, as we shall soon see, these non-negative decompositions translate into a proven architecture, which was demonstrated to achieve comparable performance to state of the art convolutional networks, thus in practice the deterioration in efficiency does not seem to be significant.</p><p>Naïvely implementing CP or HT model (fig. <ref type="figure">1</ref> or 2 respectively) in log-space translates to log activation following the locally connected linear transformations (convolutions if coefficients are shared, see sec. 3.3), to product pooling turning into sum pooling, and to exp activation following the pooling. However, applying exp and log activations as just described, without proper handling of the inputs to each computational layer, would not result in a numerically stable computation 10 .</p><p>The SimNet architecture <ref type="bibr">(Cohen and Shashua (2014)</ref>; <ref type="bibr">Cohen et al. (2016)</ref>) naturally brings forth a numerically stable implementation of our networks. The architecture is based on two ingredients -a flexible similarity measure and the MEX operator:</p><p>The similarity layer, capable of computing both the common convolutional operator as well as weighted l p norm, may realize the representation by computing log f θ (x i ), whereas MEX can naturally implement both log-sum-exp and sum-pooling (lim β→0 MEX β (x, 0) = mean j {x j }) in a numerically stable manner. Not only are SimNets capable of correctly and efficiently implementing our networks, but they have already been demonstrated <ref type="bibr">(Cohen et al. (2016)</ref>) to perform as well as state of the art convolutional networks on several image recognition benchmarks, and outperform them when computational resources are limited.</p><p>10. Naïve implementation of softmax is not numerically stable, as it involves storing αi = exp(log αi) directly. This however can be easily corrected by defining c := maxi log αi, and computing log i exp(log αi − c) + c. The result is identical, but now we only exponentiate negative numbers (no overflow), with at least one of these numbers equal to zero (no underflow).</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Tensor decompositions for learning latent variable models</title>
		<author>
			<persName><forename type="first">Animashree</forename><surname>Anandkumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rong</forename><surname>Ge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Hsu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matus</forename><surname>Sham M Kakade</surname></persName>
		</author>
		<author>
			<persName><surname>Telgarsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="2773" to="2832" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Introduction to matrix analysis</title>
		<author>
			<persName><forename type="first">Richard</forename><surname>Bellman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Ernest Bellman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Ernest Bellman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><forename type="middle">Ernest</forename><surname>Bellman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1970">1970</date>
			<publisher>SIAM</publisher>
			<biblScope unit="volume">960</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Learning Deep Architectures for AI</title>
		<author>
			<persName><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations and Trends in Machine Learning</title>
				<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1" to="127" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">On the complexity of neural network classifiers: A comparison between shallow and deep architectures. Neural Networks and Learning Systems</title>
		<author>
			<persName><forename type="first">Monica</forename><surname>Bianchini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Franco</forename><surname>Scarselli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1553" to="1565" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Simnets: A generalization of convolutional networks</title>
		<author>
			<persName><forename type="first">Joan</forename><surname>Bruna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stéphane</forename><surname>Mallat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Caron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tim</forename><surname>Traynor</surname></persName>
		</author>
		<idno>05-02</idno>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems (NIPS), Deep Learning Workshop</title>
				<imprint>
			<date type="published" when="2005">2012. 2005. 2014</date>
		</imprint>
	</monogr>
	<note type="report_type">WSMR Report</note>
	<note>Invariant Scattering Convolution Networks</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">Nadav</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amnon</forename><surname>Shashua</surname></persName>
		</author>
		<title level="m">Convolutional rectifier networks as generalized tensor decompositions. International Conference on Machine Learning (ICML)</title>
				<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">Nadav</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Or</forename><surname>Sharir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amnon</forename><surname>Shashua</surname></persName>
		</author>
		<title level="m">Deep simnets. IEEE Conference on Computer Vision and Pattern Recognition (CVPR)</title>
				<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Approximation by superpositions of a sigmoidal function</title>
		<author>
			<persName><surname>Cybenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematics of Control, Signals and Systems</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="303" to="314" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Shallow vs. deep sum-product networks</title>
		<author>
			<persName><forename type="first">Olivier</forename><surname>Delalleau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
				<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="666" to="674" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">The power of depth for feedforward neural networks</title>
		<author>
			<persName><forename type="first">Ronen</forename><surname>Eldan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ohad</forename><surname>Shamir</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1512.03965</idno>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Networks and the best approximation property</title>
		<author>
			<persName><forename type="first">F</forename><surname>Girosi</surname></persName>
		</author>
		<author>
			<persName><surname>Poggio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Biological cybernetics</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="169" to="176" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A New Scheme for the Tensor Representation</title>
		<author>
			<persName><forename type="first">W</forename><surname>Hackbusch</surname></persName>
		</author>
		<author>
			<persName><surname>Kühn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Fourier Analysis and Applications</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="706" to="722" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Tensor Spaces and Numerical Tensor Calculus</title>
		<author>
			<persName><forename type="first">Wolfgang</forename><surname>Hackbusch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Springer Series in Computational Mathematics</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<date type="published" when="2012-02">February 2012</date>
			<publisher>Springer Science &amp; Business Media</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Global Optimality in Tensor Factorization, Deep Learning, and Beyond</title>
		<author>
			<persName><forename type="first">D</forename><surname>Benjamin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">René</forename><surname>Haeffele</surname></persName>
		</author>
		<author>
			<persName><surname>Vidal</surname></persName>
		</author>
		<ptr target="CoRRabs/1202.2745,cs.NA" />
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Threshold circuits of bounded depth</title>
		<author>
			<persName><forename type="first">András</forename><surname>Hajnal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wolfgang</forename><surname>Maass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pavel</forename><surname>Pudlák</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Márló</forename><surname>Szegedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">György</forename><surname>Turán</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Computer Science, 1987., 28th Annual Symposium on</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="99" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Almost optimal lower bounds for small depth circuits</title>
		<author>
			<persName><forename type="first">Johan</forename><surname>Hastad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the eighteenth annual ACM symposium on Theory of computing</title>
				<meeting>the eighteenth annual ACM symposium on Theory of computing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="6" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">On the power of small-depth threshold circuits</title>
		<author>
			<persName><forename type="first">Johan</forename><surname>Håstad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mikael</forename><surname>Goldmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Complexity</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="113" to="129" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Multilayer feedforward networks are universal approximators</title>
		<author>
			<persName><forename type="first">Kurt</forename><surname>Hornik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maxwell</forename><forename type="middle">B</forename><surname>Stinchcombe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Halbert</forename><surname>White</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural networks</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="359" to="366" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Tensor Deep Stacking Networks</title>
		<author>
			<persName><forename type="first">Brian</forename><surname>Hutchinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Li</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dong</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Pattern Anal. Mach. Intell</title>
		<imprint>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1944" to="1957" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Beating the Perils of Non-Convexity: Guaranteed Training of Neural Networks using Tensor Methods</title>
		<author>
			<persName><forename type="first">Hanie</forename><surname>Majid Janzamin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anima</forename><surname>Sedghi</surname></persName>
		</author>
		<author>
			<persName><surname>Anandkumar</surname></persName>
		</author>
		<idno>CoRR abs/1506.08473</idno>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Lebesgue integration on Euclidean space</title>
		<author>
			<persName><forename type="first">Frank</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mauricio Karchmer. Communication complexity a new approach to circuit depth</title>
				<imprint>
			<publisher>Jones &amp; Bartlett Learning</publisher>
			<date type="published" when="1989">2001. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">G</forename><surname>Tamara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brett</forename><forename type="middle">W</forename><surname>Kolda</surname></persName>
		</author>
		<author>
			<persName><surname>Bader</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Tensor Decompositions and Applications. SIAM Review (</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="455" to="500" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Speeding-up Convolutional Neural Networks Using Fine-tuned CP-Decomposition</title>
		<author>
			<persName><forename type="first">Vadim</forename><surname>Lebedev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yaroslav</forename><surname>Ganin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maksim</forename><surname>Rakhuba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ivan</forename><forename type="middle">V</forename><surname>Oseledets</surname></persName>
		</author>
		<author>
			<persName><surname>Victor</surname></persName>
		</author>
		<author>
			<persName><surname>Lempitsky</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note>CoRR abs/1202.2745, cs.CV</note>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Convolutional networks for images, speech, and time series. The handbook of brain theory and neural networks</title>
		<author>
			<persName><forename type="first">Yann</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">3361</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName><forename type="first">Min</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qiang</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shuicheng</forename><surname>Yan</surname></persName>
		</author>
		<title level="m">Network In Network. International Conference on Learning Representations</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">On the computational efficiency of training neural networks</title>
		<author>
			<persName><forename type="first">Roi</forename><surname>Livni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shai</forename><surname>Shalev-Shwartz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ohad</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">A comparison of the computational power of sigmoid and Boolean threshold circuits</title>
		<author>
			<persName><forename type="first">Wolfgang</forename><surname>Maass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Schnitger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eduardo</forename><forename type="middle">D</forename><surname>Sontag</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">On the expressive efficiency of sum product networks</title>
		<author>
			<persName><forename type="first">James</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Venkatesh</forename><surname>Medabalimi</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1411.7717</idno>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">On the representational efficiency of restricted boltzmann machines</title>
		<author>
			<persName><forename type="first">James</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arkadev</forename><surname>Chattopadhya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Toni</forename><surname>Pitassi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Zemel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
				<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="2877" to="2885" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">On the number of linear regions of deep neural networks</title>
		<author>
			<persName><forename type="first">Razvan</forename><surname>Guido F Montufar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kyunghyun</forename><surname>Pascanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yoshua</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
				<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="2924" to="2932" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Novikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anton</forename><surname>Rodomanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anton</forename><surname>Osokin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dmitry</forename><surname>Vetrov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Putting MRFs on a Tensor Train. ICML</title>
		<imprint>
			<biblScope unit="page" from="811" to="819" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">On the number of inference regions of deep feed forward networks with piece-wise linear activations</title>
		<author>
			<persName><forename type="first">Razvan</forename><surname>Pascanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guido</forename><surname>Montufar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">arXiv preprint arXiv</title>
		<imprint>
			<biblScope unit="page">1312</biblScope>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Approximation theory of the MLP model in neural networks</title>
		<author>
			<persName><forename type="first">Allan</forename><surname>Pinkus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Numerica</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="143" to="195" />
			<date type="published" when="1999-01">January 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Sum-product networks: A new deep architecture</title>
		<author>
			<persName><forename type="first">Hoifung</forename><surname>Poon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pedro</forename><surname>Domingos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Vision Workshops (ICCV Workshops), 2011 IEEE International Conference on</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="689" to="690" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Lower bounds and separations for constant depth multilinear circuits</title>
		<author>
			<persName><forename type="first">Ran</forename><surname>Raz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amir</forename><surname>Yehudayoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Complexity</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="171" to="207" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">An average-case depth hierarchy theorem for boolean circuits</title>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Rossman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rocco</forename><forename type="middle">A</forename><surname>Servedio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Li-Yang</forename><surname>Tan</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1504.03398</idno>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Functional analysis. international series in pure and applied mathematics</title>
		<author>
			<persName><forename type="first">Walter</forename><surname>Rudin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Serre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lior</forename><surname>Wolf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tomaso</forename><surname>Poggio</surname></persName>
		</author>
		<title level="m">Object Recognition with Features Inspired by Visual Cortex. CVPR</title>
				<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="994" to="1000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Statistical Machine Translation Features with Multitask Tensor Networks</title>
		<author>
			<persName><forename type="first">Hendra</forename><surname>Setiawan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhongqiang</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jacob</forename><surname>Devlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Lamar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rabih</forename><surname>Zbib</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><forename type="middle">M</forename><surname>Schwartz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Makhoul</surname></persName>
		</author>
		<idno>cs.CL</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing of the Asian Federation of Natural Language Processing</title>
				<meeting>the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing of the Asian Federation of Natural Language Processing</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Arithmetic circuits: A survey of recent results and open questions</title>
		<author>
			<persName><forename type="first">Amir</forename><surname>Shpilka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amir</forename><surname>Yehudayoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Foundations and Trends in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="207" to="388" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Very deep convolutional networks for large-scale image recognition</title>
		<author>
			<persName><forename type="first">Karen</forename><surname>Simonyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Zisserman</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1409.1556</idno>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">Borel sets and circuit complexity</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Sipser</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983-12">December 1983</date>
			<publisher>ACM</publisher>
			<pubPlace>New York, New York, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Reasoning With Neural Tensor Networks for Knowledge Base Completion</title>
		<author>
			<persName><forename type="first">Richard</forename><surname>Socher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Danqi</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><forename type="middle">D</forename><surname>Manning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><forename type="middle">Y</forename><surname>Ng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
				<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="926" to="934" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Hierarchical Tensor Decomposition of Latent Tree Graphical Models</title>
		<author>
			<persName><forename type="first">Le</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mariya</forename><surname>Ishteva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ankur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><forename type="middle">P</forename><surname>Parikh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haesun</forename><surname>Xing</surname></persName>
		</author>
		<author>
			<persName><surname>Park</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICML</title>
		<imprint>
			<biblScope unit="page" from="334" to="342" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Universal approximation using feedforward networks with nonsigmoid hidden layer activation functions</title>
		<author>
			<persName><forename type="first">Maxwell</forename><surname>Stinchcombe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Halbert</forename><surname>White</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Joint Conference on Neural Networks</title>
				<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="613" to="617" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Christian</forename><surname>Szegedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wei</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yangqing</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Sermanet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dragomir</forename><surname>Anguelov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dumitru</forename><surname>Erhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vincent</forename><surname>Vanhoucke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Rabinovich</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
			<publisher>Going Deeper with Convolutions. CVPR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">DeepFace: Closing the Gap to Human-Level Performance in Face Verification</title>
		<author>
			<persName><forename type="first">Yaniv</forename><surname>Taigman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ming</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><forename type="middle">'</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Aurelio</forename><surname>Ranzato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lior</forename><surname>Wolf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR &apos;14: Proceedings of the 2014 IEEE Conference on Computer Vision and Pattern Recognition</title>
				<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2014-06">June 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Bayesian conditional tensor factorizations for high-dimensional classification</title>
		<author>
			<persName><forename type="first">Matus</forename><surname>Telgarsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">; Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D B</forename><surname>Dunson</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1509.08101</idno>
	</analytic>
	<monogr>
		<title level="m">Representation benefits of deep feedforward networks</title>
				<imprint>
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Large Vocabulary Speech Recognition Using Deep Tensor Neural Networks</title>
		<author>
			<persName><forename type="first">Dong</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Li</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Seide</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>INTERSPEECH</publisher>
			<biblScope unit="page" from="6" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Natural Images, Gaussian Mixtures and Dead Leaves</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Zoran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yair</forename><surname>Weiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
				<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1745" to="1753" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
