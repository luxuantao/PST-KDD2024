<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">GUESS: A Language and Interface for Graph Exploration</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Eytan</forename><surname>Adar</surname></persName>
							<email>eadar@u.washington.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science and Engineering 101 Paul G. Allen Center</orgName>
								<orgName type="institution">University of Washington</orgName>
								<address>
									<postBox>Box 352350</postBox>
									<postCode>98195</postCode>
									<settlement>Seattle</settlement>
									<region>WA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">GUESS: A Language and Interface for Graph Exploration</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">A95EE3A4A1E9D69DB1CD2B93968D90C7</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T02:34+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Graph visualization</term>
					<term>domain-specific embedded language ACM Classification Keywords D.2.6 Programming Environments</term>
					<term>H.5.2 User Interfaces</term>
					<term>D.2.11 Domain-specific architectures</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>As graph models are applied to more widely varying fields, researchers struggle with tools for exploring and analyzing these structures. We describe GUESS, a novel system for graph exploration that combines an interpreted language with a graphical front end that allows researchers to rapidly prototype and deploy new visualizations. GUESS also contains a novel, interactive interpreter that connects the language and interface in a way that facilities exploratory visualization tasks. Our language, Gython, is a domain-specific embedded language which provides all the advantages of Python with new, graph specific operators, primitives, and shortcuts. We highlight key aspects of the system in the context of a large user survey and specific, real-world, case studies ranging from social and knowledge networks to distributed computer network analysis.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>INTRODUCTION</head><p>Graphs models are in use today in domains as varied as social sciences, organizational behavior, physics, and biological sciences. With such wide ranging use it is not surprising that the number of visualization options available to researchers has become almost overwhelming. Researchers now must struggle to decide which tool is best suited for his or her needs. These tools are at times too general to handle the modeling of specific graph models or at times limited to one domain. The GUESS system was inspired by this need. Its design is in part the result of watching users of our previous system, Zoomgraph <ref type="bibr" target="#b1">[2]</ref>. We have found many areas of common need in graph exploration and visualization systems, and in particular two main tasks: a) the creation of static images through exploratory data analysis, and b) the creation of dynamic visualizations that they would like to distribute to others. The common feature to both use cases is a need for a flexible way of dealing with graph data.</p><p>The GUESS language, Gython, extends the Python interpreter, or more accurately the Jython system <ref type="bibr" target="#b17">[18]</ref>, by adding new operators, so-called syntactic sugar, and data structures which are tightly bound to the visualization and database backend. Additionally, our customized, interactive interpreter lets users quickly access the output of their work. For example, passing the mouse over the textual output in the interpreter window will cause the corresponding graph objects to be highlighted. A contextual menu system in the interpreter window allows further control of graph properties (e.g. changing colors). GUESS is distributed with many commands and network algorithms ranging from layout algorithms to shortest path to clustering algorithms. A number of these are contributed by the JUNG library <ref type="bibr" target="#b16">[17]</ref> which we use for the underlying data structures.</p><p>Since its release, the GUESS system has been downloaded over a thousand times and has an active mailing list of users. It has been used in applications ranging from computer network analysis to biological networks to social networks to water-line networks. These uses have frequently been undertaken by users with very little programming experience and demonstrate the viability of our approach.</p><p>In addition to our discussion of a number of case studies, we have also collected a survey from 76 individuals (primarily in the social network community) that describes their use of alternative systems and GUESS.</p><p>Below we briefly cover related work and then we delve into the Gython language with particular attention to exploratory analysis tasks. We describe the GUESS GUI (Figure <ref type="figure">1</ref>) and interactive interpreter and conclude with further discussions of our user survey and two case studies in which users have developed visualizations using GUESS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RELATED WORK</head><p>A full discussion of the many graph drawing packages is beyond the scope of this paper but are extensively described in <ref type="bibr" target="#b22">[23]</ref>. Because our survey asked users familiar with some of these systems to describe their impressions we will address a few specific systems in the discussion of the language and interface. Briefly, however, we believe that GUESS is related to three specific system categories: graph analysis/visualization systems, graph libraries, and database visualization.</p><p>The GUESS system is an attempt to combine analysis and visualization into one package that supports Exploratory Data Analysis (EDA) <ref type="bibr" target="#b28">[29]</ref> for graphs. It thus distinguishes itself from solutions that require one system to perform analysis, such as partitioning (e.g. using Analytic Technologies' UCINET), followed by a different program for rendering (e.g. Pajek <ref type="bibr" target="#b3">[4]</ref> or GraphViz <ref type="bibr" target="#b8">[9]</ref>). Interactive exploration is difficult when a user is forced to go back and forth between the analysis and the visualization packages.</p><p>Similarly, systems using sophisticated APIs that require a program compile run (PCR) cycle are also unattractive. Frameworks in this domain include excellent graph analysis and visualization libraries that are ideal for low-level programmers. For example, in C/C++ we have LEDA <ref type="bibr" target="#b20">[21]</ref> and in Java the GET/GLT <ref type="bibr" target="#b26">[27]</ref>, Prefuse <ref type="bibr" target="#b12">[13]</ref>, yEd [32], and JGraph <ref type="bibr" target="#b15">[16]</ref> systems. GUESS does not seek to displace these toolkits but rather provides a new way to interface with them. For example, we have demonstrated that our visualization layer can be replaced with Prefuse and TouchGraph <ref type="bibr" target="#b27">[28]</ref> (while still controllable through Gython). Our main use case is depicted in Figure <ref type="figure">2</ref>. We believe that GUESS should allow users to simply load a graph and immediately begin controlling the visualization. Once the analysis is complete, more experienced users can go further and easily prototype more complex visualization applications.</p><p>The GGobi package contains a graph visualization plug-in that is embedded in the R system <ref type="bibr" target="#b25">[26]</ref>. Other approaches, such as LINK <ref type="bibr" target="#b5">[6]</ref> or Graphlet <ref type="bibr" target="#b13">[14]</ref>, use interpreted languages (Scheme and TCL, respectively) and are more related to our goals. Users of Graphlet are given access to various graph structures and algorithms and can manipulate the Tk GUI. Graphlet is in fact an evolution from the GraphEd <ref type="bibr" target="#b14">[15]</ref> system, an older, C based system and illustrates the evolution to interpreted languages. Though Graphlet is similar to GUESS in a number of ways, we believe that by adhering to the unmodified TCL language, the system forces users to make use of complex, multi-line programs to achieve basic goals that could be satisfied with concise, domain-specific operators and primitives. Unlike other systems which simply implement graph data structures and algorithms in a specific language, GUESS augments the language to ease common user tasks. Additionally, by not providing a stronger connection between the interactive interpreter and the visualization, systems such as Graphlet add work for the user who must manually match the output of exploratory commands to the visualization.</p><p>Other solutions that make data exploration possible are not necessarily streamlined for data structures common in graph analysis. The GGobi/R solution, for example, requires users to manipulate matrices and vectors and frequently requires additional steps for very simple tasks. A different approach is the use of the general LEFTY graphics language <ref type="bibr" target="#b18">[19]</ref> in GraphViz. We believe that a popular language such as Python, augmented with operators and syntactic sugar, reduces the learning curve while providing the right level of abstraction. Additionally, GUESS is based on Python because the language is familiar to many users and is similar to a number of statistical systems (e.g. S-plus and R). There are also a wide array of libraries implemented in Python that can be easily integrated into GUESS.</p><p>We also believe that our use of a modified Python core distinguishes GUESS from database visualization systems such as Tioga <ref type="bibr" target="#b2">[3]</ref>, Polaris <ref type="bibr" target="#b24">[25]</ref>, DEVise <ref type="bibr" target="#b19">[20]</ref>, and Rivet <ref type="bibr" target="#b6">[7]</ref>. While these approaches are potentially able to handle graph structures, the generality of their approach limits their abstractions and forces more work for the user. By focusing on language structures and operations that are unique to graphs, we believe GUESS users can more rapidly develop visualizations on these types of structures. Another interesting area of related research has been the work in graph database and schema designs. GML and XML-based approaches such as GraphML, and GXL, provide a mechanism for describing and passing graphs between applications, as well as flexibility for additional attributes <ref type="bibr" target="#b9">[10]</ref>. However, while graphs in these formats can express many user-defined properties, storage in an XML database and querying (e.g. in XQL, XQuery, XPath, XUpdate) is difficult for novice users.</p><p>Other solutions, such as GraphDB <ref type="bibr" target="#b10">[11]</ref> and GOOD <ref type="bibr" target="#b11">[12]</ref>, were designed from the start to hold and query graph structures but lack visualization features.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>THE GYTHON LANGUAGE</head><p>When we originally built Zoomgraph we drew inspiration from domain-specific languages such as GnuPlot and the statistical analysis system R. However, we quickly learned that this require a steeper learning curve for users. In designing Gython we have opted to use a domain-specific-embedded language (DSEL) instead. Specifically, we extend Python with features necessary for dealing with graph structures. Because Gython is an extension of Jython (an implementation of Python in Java), our users have the ability to rapidly add to the GUESS GUI. In fact, we have created a great many classes and examples to bootstrap visualization tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>GUESS Objects -Nodes and Edges</head><p>Because nodes and edges are the primary currency of any graph we chose those to be the primary (first-class) objects in GUESS.</p><p>Each node has a name that is accessible from the global namespace. For example, in a social network we may have a node named bob_jones, or in a protein-protein interaction network we could have Hsp70. The user will not necessarily be accessing individual nodes, but the option is available to them. Edges are also uniquely identified, but these identifiers are not directly accessible to the user. Instead, edges are referenced by their two endpoints. For example, if we assume two nodes, bob and alice, the edge between them is bob&lt;-&gt;alice. From the implementation perspective, the bob node will look up any undirected edges connecting it to alice.</p><p>In order to select edges that that represent different relationships, we have added additional operators into the language, -&gt;, &lt;-&gt;, &lt;-, and ?. These are defined as:</p><p>• alice&lt;-&gt;bob selects all undirected or bidirected edges between alice and bob (undirected and bidirected are equivalent in GUESS) • alice-&gt;bob and alice&lt;-bob selects all directed edges. • alice?bob selects all edges between alice and bob.</p><p>Though we have added shortcuts operators, we have avoided overloading (i.e. redefining) existing operators to prevent user confusion. By making these operators a part of Gython, users have a concise way of selecting groups of edges. In other implementations, such as Graphlet, or many of the other toolkits, the user must iterate over edges to find specific matches (e.g. a multi-line "for each" program). This is a crucial design point of GUESS. Because a great deal of interaction with GUESS happens through an interactive interpreter, where users enter commands which are immediately executed, it is undesirable to have multi-line commands as these become difficult to enter and correct. Another solution would have been to create functions such as: alice.edgesTo(bob) or getDirectedEdges(alice,bob) to mask the iterations. However, we feel that these lack the conciseness of the more direct statement: alice-&gt;bob and force the user to remember longer commands (e.g. was it getDirectedEdges or findDirectedEdges?).</p><p>In addition to nodes and edges, the other main structure in GUESS is the set. This is based on our observation that users most often deal with groupings of nodes or edges rather than those edges themselves (e.g. all edges representing relations of a certain type, all nodes representing certain employees, etc.) Although Python has the notion of sets at the most basic levels we extend this in Gython to speed up certain tasks. For example, if we have five nodes, N1 through N5, we can create the following two groups of nodes:</p><formula xml:id="formula_0">group1 = (N1,N2,N3) group2 = (N3,N4,N5)</formula><p>We can find the intersection by using the "&amp;" operator or the union with "|" which are both novel to Gython (e.g. group1 &amp; group2). This is useful because users are frequently interested in groups that fall in multiple groups (e.g. department 1 employees that are managers or vice presidents). Another common task is finding the edges between groups of nodes. For example, we would like to find all routes of communication between computers in China and computers in the US. To facilitate this, the same edge selection operators that worked for individual nodes will also work on sets. So given our two groups, a user may use the command group1-&gt;group2 to find all directed edges between the two (note that (N1,N2,N3)-&gt;(N3,N4,N5) will generate the same results.</p><p>The working graph object exists in the global namespace as the variable "g". The set of all nodes and edges in the graph are accessed as g.nodes and g.edges respectively. Using these sets a user could find all outgoing edges from N1 by using the command: N1-&gt;g.nodes (though there are alternative methods).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Node and Edge Fields</head><p>Based on our experiments with Zoomgraph and our survey we have found that users require graphs structures to support properties. While graphs can be described as a simple matrix, most users require graph structures where nodes and edges have more complex properties. Of the 55 survey participants that answered this question, 35 (or 64%) indicated that they worked with graphs with complex properties (e.g. employee identifier on nodes, relationship type on edges, etc.) and 14 (or 25%) indicated needing at least simple properties (e.g. weights on edges, labels for nodes, etc.), with only the remaining 6 (or 11%) satisfied with simple matrices.</p><p>In GUESS, a user has the option of associating fields (i.e. properties or attributes) with nodes and edges. Currently, fields can be textual, numerical, or Boolean (with some additional exceptions for shapes and images). For example, one of our sample applications involves a social network within a company. Nodes, representing employees, have a textual department field associated with them called dept and job function field called jobfunc. For example, Bob, Alice and Jane are Manager, Designer, and Intern respectively. Similarly, edges have a freq field representing the frequency of communication between two employees (e.g. Bob and Alice communicated 10 times).</p><p>To be consistent with Python we decided that attributes could be accessed by appending the field name to the variable name (e.g.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>variable.field).</head><p>This is standard in Python, but required modifications to the Jython implementation. For example:</p><p>• bob.jobfun returns "Manager" • (bob&lt;-&gt;alice).freq returns 10 • (alice&lt;-&gt;jane).freq = 21 updates the amount of communication between alice and jane.</p><p>Fields come in two flavors, data fields, and visual fields. The 3 examples above are simple examples of data fields. Visual fields correspond to properties that are used by GUESS to visualize the graph. For nodes these include, style, height width, fixed, visible, color, label, labelvisible, indegree, outdegree, totaldegree, x, and y. For edges, GUESS currently utilizes color, width, label, labelvisible, directed, and weight. When loading a new graph into the system, a user may define the initial values for any subset of these attributes. Certain properties (e.g. indegree, outdegree, totaldegree) are calculated dynamically with structure changes. These are calculated as needed in order to prevent overhead to graph operations. Other measures, for example graph centrality measures <ref type="bibr" target="#b29">[30]</ref> or PageRank <ref type="bibr" target="#b23">[24]</ref>, are also generated the first time those fields are accessed on a node (e.g. alice.betweenness or bob.pagerank).</p><p>Changes to visual properties cause an immediate change to the display. For example, bob.color = red will set the bob node to red (GUESS has namespace definitions for nearly 80 colors but will also accept an RGB triplet). Users can make use of Python's iterators to modify the fields of groups. The for-loop, for temp in g.nodes: temp.color = red will set all graph nodes to red. However, because such functions are used so frequently and the syntax is cumbersome, an additional feature of Gython is the application of setter operations to groups. For example: • g.nodes.color = pink will set all nodes in the graph to pink • (alice,bob).style = 2 will make the alice and bob nodes circular (default is square) • (bob,jane).size = 20 will change the size of bob and jane to 20 pixels (this is syntactic sugar that sets height and width at the same time) • (alice-bob,bob-alice).width = 3 will change the line width on the two edges.</p><p>In addition to fields, nodes and edges have a number of methods that can be used to find various graph features. For example, alice.unweightedShortestPath(bob) will calculate the length of the shortest path from alice to bob. As we begin to stabilize these methods and find which are frequently used we may replace them with operators (i.e. alice&lt;*&gt;bob may come to mean shortest path). Many other functions exist for selecting neighboring edges, nodes, and other graph properties but are beyond the scope of this paper.</p><p>Though both types of fields, visual and data, exist in GUESS, users access both in the same manner. This is very different than most toolkit implementations such as JUNG or Prefuse in which a Model-View-Controller model disentangles data from visualization. While useful from a programming perspective, such models frequently require additional code. For example, we could define an EdgeWidthRenderer object which tells the visualization system what width to set each edge to (perhaps based on some edge property). We believe that in exploratory situations users simply wish to modify visual properties directly and not implement rendering objects.</p><p>While GUESS is not intended to scale to Internet sized graphs we have successfully loaded and manipulated networks of tens of thousands of nodes and edges on a standard PC. Layout algorithms are by far the most expensive operations though the usual graph sizes (&lt; 5000 nodes) are laid out nearly instantaneously and standard operations such as coloring and grouping are nearly real time for much larger graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Filtering Fields</head><p>In addition to controlling node and edge properties, fields are also used in GUESS to filter graph elements. In order to make filtering commands directly accessible to users a unique object is automatically created for every field that is either defined by the system or user. That is, for every field in the system a field object is created and made accessible in the global namespace.</p><p>These objects have overloaded ("==", "&gt;", "&lt;", "&gt;=", "&lt;=", and "!=") and added operators ("like", "roverlaps", "rcontains", "rexact", and "rcontained") When the operators are applied to a field object, GUESS will find all nodes or edges matching the filter and return a set of matching objects. For example:</p><p>• freq &gt; 10 will select all edges with communication frequency greater than 10, and (freq &gt; 10).color = blue will make those edges blue • name like 'al%' will find all nodes whose name starts with "al".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>•</head><p>Users can also make queries between fields. For example x &gt; y finds all nodes whose x location is larger than their y location.</p><p>We believe that while including the query syntax in the language is common in database visualization systems, it is novel in this context. Because the bulk of graph systems make use of languages that are not targeted at querying datasets, users are forced to make database queries, and remap the results back to the graph data. Presuming a connection to a database, a user may have to do something of the form: matchingRows = db.query("SELECT * from edges where freq&gt;10") for each row in matchingRows: matchingEdge = mapRowToEdge(row)</p><p>While we may be able to hide this in a function (e.g. findMatching("freq &gt; 10")) this becomes more cumbersome when users begin to require unions, intersections, or connections between sets. If we relied on only existing language constructs such as those provided in Java or TCL we may have to do:</p><p>intersection((alice,bob),(findMatchingNodes("job func == 'manager'"))</p><p>to find who between alice and bob is a manager. In Gython the equivalent query would be:</p><p>(alice,bob) &amp; (jobfunc = 'manager')</p><p>A user could also find all edges connecting alice with a frequency of communication greater than 15 by doing:</p><formula xml:id="formula_1">(alice&lt;-&gt;g.nodes) &amp; (freq &gt; 15)</formula><p>If a naming conflict exists between node and edge fields, the node field is bound in the namespace (e.g. width). To specify which width field one is interested in, we prepend Node. or Edge. to the field name (e.g. Node.width vs Edge.width).</p><p>Fields are objects themselves and have properties including simple measures like "max" and "avg" (e.g. freq.max). Fields are also passed as arguments to various functions including sortBy(fieldname) and groupAndSortBy(fieldname). Respectively, these functions generate a set of nodes or edges sorted by a particular field or a set of sets in which objects with equivalent field values are grouped together. Notably we can also use the syntax group1.sortBy(fieldname) to sort all items in group1 by some field.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Loading Graphs</head><p>Unlike Zoomgraph, users of GUESS have more options for loading graphs into the system. A simple comma separated format called GDF is the easiest for new users. However, GUESS now supports GraphML and the Pajek file formats for importing from other applications.</p><p>In addition to loading in various graph description files, users of GUESS can also create and remove nodes, edges, and fields onthe-fly. Various primitives support these functions and the data is appropriately saved into the backend database.</p><p>Because GUESS uses a database as a backend, advanced users can switch in their own databases by implementing a simple API. One user of GUESS, who had previously created a large system for analysis, elected to use a network module (built in GUESS) which allowed him to connect remotely and simply execute scripted commands to construct and manipulate a graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Graph States</head><p>There are two main reasons we may be interested in preserving graph states. The first is the necessity of undoing events in exploratory tasks, and the second is in the analysis of timesensitive data (e.g. dynamic graphs).</p><p>Although we noticed this in Zoomgraph users, participants in our survey confirmed for us the importance of reverting to previous versions of the visualization. When asked to name their main issues with systems such as Pajek and UCINET, users responded with statements such as: "[In UCINET] you have to reload a network for every operation. Horrible." and for Pajek "once you have applied a spring embedding algorithm you can never return to the previous sociogram display." Clearly, when performing exploratory visualizations it is crucial to revert to previous layouts if the current one is unsatisfactory (this is especially important since many layout algorithms require a long time to compute). In GUESS we allow users to issue a "save state" command, ss(state name), or to easily retrieve a saved state through the load state command, ls(state name). The argument to both methods is a either a string or integer which is becomes the name of the state. While we could do this automatically for the user after every command to support full undo, we disable this option in the distributed version as it has a computation cost and may disrupt the user's flow 1 .</p><p>While there are many instances of graphs that are static, frequently users are interested in graphs that are changing over time. In our own work we have had to visualize various dynamic social networks and have generated movies to depict various phenomena. In our survey population we asked the 1 of this feature, GUESS allows users to log their interaction sessions to file (these can later be "replayed").</p><p>participants if they required visualizations of dynamic graphs (yes or no). Of the 59 that answered, 47 (or 80%) indicated a need to visualize such graphs. On the other hand several noted in their criticism of systems such as Pajek and UCINET as well as toolkits such as JUNG that very little support is available for this task.</p><p>The Gython language supports querying and access of fields at different states. For example, if we had defined a state for every year we would type bob <ref type="bibr">[1999]</ref>.jobfunc to find Bob's job function in 1999. We could also find all communication edges where the frequency of communication increased from 1999 to 2000 by doing: freq[2000] &gt; freq <ref type="bibr">[1999]</ref>.</p><p>In order to preserve a mental map model <ref type="bibr" target="#b21">[22]</ref>, GUESS, like Zoomgraph, implements a tweening algorithm that smoothly transforms a graph from state to state. A user may specify the amount of time to spend on this transformation. Because nodes and edges can appear and disappear between states and are distracting in their transition we have added additional controls that define how quickly in the cycle nodes and edges should disappear and how late they should appear. When a user is satisfied with their animation, GUESS can export the visualization in QuickTime format. In fact all user interactions with the visualization system can be saved. If a user wants to manually move nodes and edges or apply transformations these can be saved as a movie as well.</p><p>Sometimes dynamic graphs have a complex notion of state. For example, a social network graph may have different communication frequencies for each time period. For this type of dynamic graph, the state mechanism described above is appropriate. A far simpler type of state is a network in which nodes and edges exist or vanish depending on the time (e.g. the network link is up or is down). To represent this we allow users to define a range field which is a comma delimited list indicating when a node or edge exists. A range field such as "1,5-10,20," for example, indicates that a graph element existed during time 1 and 20 and during the period between 5 and 10 (inclusive). Users can query on this using the familiar query syntax with the operators roverlap, rcontains, rcontained, rexact. For example:</p><p>• Node rcontains 5 returns all nodes that exist at time 5 • Edge roverlap (4,6) returns all edges that overlap the time period 4-6.</p><p>Now that we have defined the fundamentals of the language, we can start to see how they can be used in visual exploration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Functions and Programming in Gython</head><p>In the original Zoomgraph system we had implemented all graph functions as reserved keywords. One of the criticisms of this was that it was difficult for users to add their own functions or modify ours. Users had to program the primitive in Java so it would be accessible to them in the Zoomgraph language. Instead, in GUESS we have bundled some functions into the appropriate objects (e.g. graph functions are part of graph objects, display window functions in the main window object, etc.). A user wanting to generate a random layout would use the command g.randomLayout().</p><p>While packaging of this type is understandable to programmers, in observing our users it emerged that they were frequently confused about which functions belonged to which object.</p><p>Rather than having them look up these functions every time we implemented an automated system that generates a number of wrapper functions at compile time that are then defined globally.</p><p>Users can now type randomLayout() (in fact they can do randomLayout, omitting the parenthesis-another Gython feature) and the system automatically knows which object to invoke the function on. In this way, we have provided both primitives and functions which the user may select from depending on their comfort level with the language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Simple Visualizations and Exploration</head><p>While the GUESS interface provides a number of features for the exploration and manipulation of the graphs (panning, zooming, etc.), it is frequently desirable and potentially easier, to achieve this programmatically. For example, GUESS provides a center(…) function which will take any set of nodes and edges and center the camera around those objects, panning and zooming as needed. A user can, for example, zoom in on a department by typing center(dept == 'IT').</p><p>One of the most used features of GUESS are functions that map data properties to visual properties. For instance, we may want to map the communication frequency field to the width of an edge (ranging from 1 to 5 pixels). Programmatically, this would correspond to something the following: Since commands such as these are used so frequently we have created shortcut functions called colorize and resize which take a field as an argument and optional arguments such as starting and ending colors and sizes and visually transform the nodes or edges. The commands for the previous two examples would be resizeLinear(freq,1,5) and colorize(dept). Figure <ref type="figure" target="#fig_2">3</ref>, for example, was generated using the command colorize(totaldegree,yellow,red).</p><p>Since GUESS is built on top of the JUNG library we can also make use of various pieces of code available that perform graph based clustering. One application where GUESS has been used is in finding communities of nodes and visually highlighting those communities. Using the betweenness clustering method, a popular community finding algorithm, and GUESS' ability to create convex hulls around sets we apply the following function:</p><p>for clust in edgeBetweennessClusters( <ref type="formula">7</ref>): createConvexHull(clust,randomColor(120))</p><p>In this example we are asking for 7 clusters and the randomColor method takes an optional alpha variable to indicate transparency. Various other clustering algorithms are implemented and available to the user. For Figure <ref type="figure" target="#fig_2">3</ref> we applied groupBy(dept) instead of the betweenness clustering method to generate the hulls.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Layout Algorithms and New Visualizations</head><p>It is rare for a user visualizing a graph to have already specified the coordinates for all the nodes. More frequently, the user will depend on the visualization system to layout the graph in a way that conveys some interesting aspect of the graph. GUESS provides a number of standard layout algorithms including Fruchterman-Reingold, Kamada-Kawai, Sugiyama, GEM, ISOM, radial layouts, and various spring based implementations (these are fairly standard techniques and are surveyed in <ref type="bibr" target="#b7">[8]</ref>) as well as a few of our own creation. For iterative layouts, such as the spring-based techniques, users may specify the number of iterations to run. Supplying no argument will result in a query to the user every 30 seconds asking if they would like to continue.</p><p>While our algorithms are frequently sufficient for users, they may also create their own using quite easily. A custom visualization such as Figure <ref type="figure" target="#fig_2">3</ref> takes under 10 lines. The equivalent algorithm would have taken far more work directly in systems such as JUNG or Prefuse as we would have had to implement and compile new layout algorithms, and potentially new renderers, in order to control placement and display.</p><p>While we have not attempted extensive scaling experiments we have successfully loaded and applied the GEM algorithm to graphs with 10000 nodes and 12000 edges. Larger graphs seem very plausible and seem only limited by memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>THE GUI</head><p>At the visual layer, the GUESS system supports the display of very large graphs through the use of the Piccolo framework <ref type="bibr" target="#b4">[5]</ref>. Piccolo provides an infinite visualization plane with infinite zoom for 2D objects. However, in building GUESS we have opted to disentangle the data from the visual representation, thus allowing integration with Prefuse and TouchGraph.</p><p>Beyond simple pan and zoom features, users have access to a number of commands that change the display of the graph, export images, and perform basic layout operations. Users can also annotate the graph with basic 2D objects. Additional features include a property window and basic charting. Automatically generated legends are a crucial feature in exploratory environments as they help annotate visual data in a useful way. This was one of the most requested features in Zoomgraph and is now available in GUESS. Our belief is that the default interface to GUESS should be as plain as possible. Network and graph analysis in various fields has resulted in an incredibly large collection of algorithms and methods. Frequently, the methods are similar but the language and names to describe them are completely different. Even within fields such as social network analysis the number of tools is overwhelming. Pajek, for example, has 17 menus in the menu bar with an average of 8 items in each. These are themselves submenus which may go down 4 levels. Of the 47 survey participants who described their issues with Pajek and UCINET, 17 (or 36%) made specific note of the overwhelming UIs and lack of guidance as their main issue with these systems.</p><p>We believe the interface that an end user is exposed to should contain the functions needed for their task. As such, we have allowed programmatic control of menu options, toolbars, and other areas of the GUI. Our hope is that users will load interface views that address their specific needs. A biologist, for example, may not see the social network algorithms that are available to the social analyst or the network flow algorithms for the computer scientist.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The Interactive Interpreter</head><p>One of the most novel features of GUESS has been the interactive interpreter. We started with the basic Jython interpreter<ref type="foot" target="#foot_0">2</ref> console and extended from there. The console provides a simple way to enter commands. As commands are entered they are evaluated immediately and the output is displayed in the console. Figure <ref type="figure" target="#fig_3">4</ref> shows a slightly enlarged view of this console in the bottom left of the visualization window.</p><p>If a user ends their line with a colon, the Python symbol indicating the start of a code block, the interpreter allows the user to enter additional lines. Hitting enter on a blank link leaves the code block mode. This is particularly useful for defining loops. The interpreter also provides the usual cut and paste operations as well as a history function to cycle through previous commands.</p><p>If we look at the output of the groupBy command in Figure <ref type="figure" target="#fig_3">4</ref> we notice that the result is fairly overwhelming. The response is a large grouping of node groups (one for each department). This is useful for a programmer, but simply looking at the results may not tell us much. A user faced with this list may want to match what is in the list to the visualization. To help, we drew inspiration from trends in development environments and systems such as Matlab. When a user moves the mouse cursor over text in the interactive window and the text under the mouse corresponds to a node or edge, that edge is highlighted in the visual display. If the mouse moves over a variable representing a group of nodes or edges the complete group is highlighted. More interestingly, GUESS makes a distinction between items in sets and sets. For example, if the system returns a group of two groups such as [[V1],[V3,V4], GUESS forms the following table in memory: </p><formula xml:id="formula_2">[ [ V 1 ] , [ V 3 , V 4 ] ]</formula><p>When the user mouses over positions 3 or 4, node V1 is highlighted. Similarly, when the user moves over positions 11 or 12, V3 is highlighted. However, if the user moves over position 10, 13, or 16, both nodes V3 and V4 are highlighted in the display. Moving over positions 1, 9, or 17 causes highlighting of all three nodes. The "matched" text is always underlined to provide the user with a visual indication of the area they are moving over. From an implementation perspective we make use of an interval-tree data structure which is highly optimized for these tasks.</p><p>Due to our event management infrastructure, highlighting a node does not necessarily mean simply highlighting it in the graph window. If the node, edge, or group is part of any other visualization (e.g. a chart) that area will be highlighted as well. Figure <ref type="figure" target="#fig_3">4</ref> is an example of all this in action.</p><p>Tooltips that are displayed are contextualized to the type of the object being moused-over. The top entries 15 entries are shown for lists, exception logs are shown for errors, and documentation is displayed when mousing over functions. GUESS also allows functions that create lists to annotate them. For example the grouping operators, will annotate lists with the grouping criteria.</p><p>In Figure <ref type="figure" target="#fig_3">4</ref> at the top of the tooltip box we find a note that "dept == dept6." This annotation helps the user quickly identify the reason a group was formed. A tooltip window displays additional information. In addition to the highlighting in the graph display, note that the pie segment containing moused-over nodes is slightly pulled out.</p><p>A last feature that allows for integration between visualizations and the interpreter are contextualized menus. When the user right clicks on text or on items in the visualization a popup menu appears with items specific to the selected items. For example, for nodes or groups of nodes, users can select the style of the nodes. For edges the menu may include a setting for edge width. These menus enable quickly modifying the visual aspects of graph elements without extensive typing. In all menus users have the option to define a variable name in the interpreter with the contents of the selected item. A user may select a number of nodes in the graph, right-click for the menu, and set the variable "foo" to the content of the selection. Subsequently, commands like foo.color = black would be understood and executed by GUESS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Handling User "Mistakes" in the Interpreter</head><p>In watching our users interact with the system it became apparent that they were frequently overwriting the association between namespace names and objects. For example, a user would type g = 5 and would lose access to the graph object. This is extremely dangerous in an exploratory system because it is difficult to back out of namespace changes gracefully (at least without extensive modifications to the language subsystem). Instead, we settled upon a simple scheme in which we distinguish between user variables and immutable system variables. Nodes and the graph object, g, for example, as well as colors and fields are of this immutable type and an error message is returned if a user tries to modify their content.</p><p>Other issues, such as infinite loops are helpfully handled by Java. This ensures that user error does not cause a disastrous crash of the system. Furthermore, when GUESS is run in "persistent" mode all changes to the graph are flushed to disk and can recovered at the restart of the application.</p><p>A previous issue was that deleted nodes and edges were gone from the system. In GUESS, nodes and edges that are deleted from the graph become part of a special _deleted state which can be queried as all states. Those nodes can be easily re-added to the working state with a simple command.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Building Applications</head><p>During the exploration stage users may save their visualizations into a persistent database, a simple file, or export the image into any number of formats (including JPG, PNG, GIF, PDF, EPS, and others). Users may also save a log of their program so that it can be rerun at a later time on either the same data or new graphs. While this is in some cases sufficient (e.g. a user simply wishes to generate an image for paper), there are frequently times where a user would like to build a new application or augment the GUI. Gython, like Jython, can be compiled into Java code and our applications can be used in Applets.</p><p>GUESS allows users to create new "toolbars" that are docked either vertically or horizontally in the GUI. Because we are using a modified Jython core, users are able to make use of standard Java widgets while ignoring the messy details of implementing complex event handlers. Users can also make user of functional programming techniques in defining GUI reactions. For example, a user can create a button and have the display center every time the button is clicked by this command:</p><p>testButton.actionPerformed = lambda event: center() A slider bar can be used to control which edges are display in the social network example:</p><p>testSlider.mouseReleased = hideshow def hideshow: val = testSlider.getValue() (freq &lt; val).visible = 0 (freq &gt;= val).visible = 1</p><p>For users familiar with Java, where they would have to define a listener object to handle mouse events, query databases or filter nodes, this is far simpler. Once the user has completed designing their visualization and/or GUI modifications these can be deployed either as an application or as an applet. Users may define highlighting behavior in the same way, augment menus (both main menus and contextualized popups), and control what happens when items are clicked on (e.g. open a webpage or zoom in).</p><p>As we primarily rely on Jython for these features we will not cover the full details of writing GUI extensions and instead concentrate on a few sample applications that illustrate GUESS in action.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SURVEY AND GUESS CASE STUDIES</head><p>We are aware of many groups either using or evaluating GUESS in applications ranging from social networks to model checkers to computer networks to biodiversity networks. Some use GUESS independently of other systems, but we are aware of at least one where a simple network interface has been created so that GUESS can respond to remote commands. Below we briefly describe our survey in more detail and conclude by concentrating on two real-world examples of GUESS in use.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Graph Software Survey</head><p>Although we have described some of the survey results in the context of the system description it is worth mentioning some other key facts. The survey was collected over a one week period by advertising to a number of mailing lists (the bulk of responses came from SOCNET, a large social-networks mailing list with some from the JUNG and GUESS mailing lists). During this time, 77 users completed at least one portion of the survey. Of the 63 users answering this question, 49 (or 78%) indicated that they had no experience with GUESS at all. Thus the bulk of responses were more useful for understanding user needs and experiences with other graph visualization and analysis packages. Only 37% (28 out of 76) were from a field where programming knowledge was to be expected (e.g. Computer Science and Physics). The rest were from primarily social science fields (e.g. Sociology and Ethnography).</p><p>The goal of the survey was primarily to identify issues, both positive and negative, users had with other systems. The bulk of participants had no (49 participants) or very limited exposure (6 participants) to GUESS (of 63).</p><p>The survey collected free form answers for three categories of graph tools: Menu-based tools (Pajek, UCINET, etc.), toolkits and programmable systems (JUNG, Graphlet, Prefuse, etc.), and math systems with graph functions (Mathematica, R, etc.). Participants indicated which systems they had used and were prompted to enter positive and negative impressions. These responses were coded and appear throughout the paper. Positive responses tended to be short statements concerning availability or price (free was always good). Participants were far more willing to provide negative reactions. These results are encouraging for us as they confirm a number of our decisions. For the menu-based tools the top complaints were (of 47 respondents): complex interfaces (17 instances), not batch oriented/extensible (11 instances), and issues with data formats (5 instances). Fewer respondents <ref type="bibr" target="#b30">(31)</ref> were familiar with toolkit systems and the only repeated complaint was on the learning curve (4 instances).</p><p>Because so many different systems exist for visualizing and analyzing graph structures we feel that these responses are mostly useful for identifying issues that GUESS can improve on. We feel that a better indication of GUESS' usefulness is in the positive responses in real case studies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proximity Estimation and Load Transfer</head><p>One of the groups to make use of both Zoomgraph and GUESS is the Networking Research Group at HP. One of their current projects is the estimation of network latencies in large networks <ref type="bibr" target="#b30">[31]</ref>. Because pair-wise computation of latency is very time consuming, the authors have developed algorithms for estimating which network nodes are closest (in terms of latency) to any source computer.</p><p>In order to demonstrate the effectiveness of the algorithm they have used GUESS to generate a custom visualization (Figure <ref type="figure">5a</ref>).</p><p>Their implementation loads the fully connected graph (all pairwise connections). When a user selects a node that node becomes the center of a star graph with all neighboring nodes around them. All other nodes and edges are removed from the graph. The connected nodes are laid out in a circle around the central node at a distance proportional to the real network latency. Those nodes that are predicted to be close are colored differently based on the predicted distance.</p><p>One of the requests of users of Zoomgraph was the ability to create a legend. This feature is now available in GUESS. Users may create as many legends as they want and "insert" node, edges, or convex hulls into the legend with some textual annotation. The legend used in this visualization indicates how colors correspond to latency values. Users of the visualization can quickly assess the quality of the prediction and understand where and how failures happen.</p><p>A different visualization for this group demonstrates a resource allocation system in which work on overloaded computers is moved to other resources. This tree based visualization is created dynamically through simulation. As a node in tree becomes overloaded it is divided into two other nodes with the edge being labeled with "reason" for the split.</p><p>Both visualizations were built in few days of part time effort and were well received in demonstration sessions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Political Weblog Network</head><p>After the US elections in 2004 there was a great deal of interest in the web research community in the study of online social structures in the political context. A recent project attempted to understand political webloggers <ref type="bibr" target="#b0">[1]</ref>, and specifically to compare liberal and conservative blog network structures. By using GUESS, the authors of the study were able to create high-quality, static, visualizations of these networks for their paper. They were also interested in making the data and the visualizations available to their readers.</p><p>The graph and a new toolbar were deployed with GUESS as an applet. Figure <ref type="figure" target="#fig_4">5b</ref> is a screenshot of this visualization. The graph was laid out using a GEM layout which clearly separates the red (conservative) and blue (liberal) nodes. Nodes are sized according to their in-degree and edge width is defined by the number of reciprocated citations between the blogs. Edges internal to the liberal side are colored blue, and similarly those on the conservative side are red, with those that cross in yellow. Up to this point the program is 8 lines of code.</p><p>Nodes and Edges may have event handlers attached to them that wait for the mouse to move over or the mouse button to be clicked. In this case, the author has elected to respond to shiftclicks on nodes by opening up a web page with the associated blog homepage. The toolbar at the bottom of the screen allows users to select a threshold (i.e. the number of times one blog links to another) for displaying links. As the slider is moved to the right edges that do not meet the threshold are hidden. In all, the script is under 60 lines of code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CONCULSIONS AND FUTURE WORK</head><p>In this paper we have introduced the GUESS system. We have illustrated how the Gython language can be used for exploratory data analysis of graph structures. We believe that the design decisions we have made in language design make the tool useful for rapid exploratory data analysis. We also believe that the use of a targeted, domain-specific language is broadly applicable in the design of direct manipulation systems in which fine grained user control is desirable. Furthermore, the GUESS system presents an environment for users with arbitrary graph datasets and a single mechanism for generating static and dynamic visualizations as well as applications. Finally, we believe that our GUI design represents a novel integration of textual and visual interaction which can be applied to other visualization systems where multiple modes of interaction are necessary. At present, our major goals are to improve the system's ability to handle dynamic graphs and to add path finding semantics that provides users with a more flexible grammar for finding graphs.</p><p>As we continue to work with users we hope to be able to generate custom interfaces for different users. By working with biologists or social scientists we hope to determine which features they find most useful for their tasks and provide a custom view into GUESS that supports those needs.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure</head><label></label><figDesc>Figure 2a-c:The GUESS pipeline, a) users load graphs into the system or programmatically create them, b) exploratory data analysis and visualization is performed, and c) a complete application or applet is generated with custom widgets and controls.</figDesc><graphic coords="2,229.80,90.00,135.00,113.76" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>for e in sortBy(freq): prop = (e.freq -freq.min)/ (freq.max-freq.min) e.width = 1 + 4 * propSimilarly, to color each department differently we could use the random color generator (GUESS also has a function to produce a sequence of colors in a range) and do:for group in groupBy(dept): group.color = randomColor()</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: A sample visualization where nodes (individuals) are placed around the circle by department. The more connected nodes are pulled into the circle and colored a deeper red (edge colors are the average of the node color). A convex hull groups departments together.</figDesc><graphic coords="6,333.96,472.92,214.56,179.40" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: A demonstration of the connection between the interpreter and various visualizations.A tooltip window displays additional information. In addition to the highlighting in the graph display, note that the pie segment containing moused-over nodes is slightly pulled out.</figDesc><graphic coords="7,193.44,54.72,365.52,204.24" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5a, b :</head><label>b</label><figDesc>Figure 5a,b: Figure 5a is a screenshots of a network estimation algorithm. Figure 5b captures the political weblog visualization applet (www.hpl.hp.com/research/idl/demos/politicalblogdem o.html). Note the additional "toolbar" at the bottom which was added by the user.</figDesc><graphic coords="9,56.04,478.20,229.44,164.88" type="bitmap" /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>Strictly speaking, we started with the graphical one implemented in the YaTiSeWoBe system.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>http://www.yworks.com</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>The author would like to thank David Feinberg and Joshua Tyler without whom GUESS could not have been built. Additional thanks to Bernardo Huberman, Lada Adamic, the Netvigator team, and all the users of Zoomgraph and GUESS. A great deal of thanks to the implementers of the free software which we were able to use in this system. Finally, thanks to Dan Weld and Kayur Patel for useful comments on this paper.</p></div>
			</div>


			<div type="availability">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>AVAILABILITY</head><p>GUESS is available at: http://www.graphexploration.org</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Adamic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Glance</surname></persName>
		</author>
		<title level="m">The Political Blogosphere and the 2004 U.S. Election: Divided They Blog,&quot; 2 nd Annual Weblogging Workshop, WWW 2005</title>
		<meeting><address><addrLine>Chiba, Japan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-05-10">May 10, 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Zoomgraph Manual</title>
		<author>
			<persName><forename type="first">E</forename><surname>Adar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Tyler</surname></persName>
		</author>
		<ptr target="www.hpl.hp.com/shl/projects/graphs/doc/zg-manual.htm" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The Tioga-2 Database Visualization Environment</title>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Spalding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Woodruff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Vis. &apos;95 Workshop. on Database Issues for Data Vis</title>
		<imprint>
			<date type="published" when="1995-10">Oct. 1995</date>
			<biblScope unit="page" from="181" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Pajek -Program for Large Analysis</title>
		<author>
			<persName><forename type="first">V</forename><surname>Batagelj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mrvar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Connections</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="47" to="47" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Toolkit Design for Interactive Structured Graphics</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">B</forename><surname>Bederson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Grosjean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="535" to="546" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Graph Drawing and Manipulation with LINK</title>
		<author>
			<persName><forename type="first">J</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Shannon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Skiena</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Lecture Notes in Computer Science 1353: Graph Drawing</title>
		<editor>
			<persName><forename type="first">G</forename><forename type="middle">Di</forename><surname>Battista</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Rivet: A Flexible Environment for Computer System Visualization</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bosch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Stolte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gerth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rosenblum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Graph Drawing: Algorithms for Visualization of Graphs</title>
		<author>
			<persName><forename type="first">G</forename><surname>Di Battista</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Eades</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tamassia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">G</forename><surname>Tollis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An open visualization system and its applications to software engineering</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">R</forename><surname>Gansner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>North</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software -Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1203" to="1233" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">The GraphML File Format</title>
		<ptr target="graphml.graphdrawing.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">GraphDB: Modeling and Querying Graphs in Databases</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Güting</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB &apos;94</title>
		<meeting><address><addrLine>Santiago De Chile, Chile</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994-12-15">Sep. 12-15, 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A Graph-Oriented Object Database Model</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gyseens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Paredaens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van Den Bussche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Van Gucht</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9 th Symposium on Principles of Database Systems</title>
		<meeting>the 9 th Symposium on Principles of Database Systems<address><addrLine>Nashville, TN</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Prefuse: A Toolkit for Interactive Information Visualization</title>
		<author>
			<persName><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Card</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Landay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHI 2005</title>
		<meeting><address><addrLine>Portland, OR</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">April 2-7, 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Graphlet: design and implementation of a graph editor</title>
		<author>
			<persName><forename type="first">M</forename><surname>Himsolt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software -Practice &amp; Experience</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1303" to="1324" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">GraphEd: A Graphical Platform for the Implementation of Graph Algorithms</title>
		<author>
			<persName><forename type="first">M</forename><surname>Himsolt</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994. 1994</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>Lecture Notes in Computer Science: Graph Drawing</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<ptr target="http://www.jgraph.com" />
		<title level="m">JGraph homepage</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName><surname>Jung Homepage</surname></persName>
		</author>
		<ptr target="http://jung.sourceforge.net" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<ptr target="http://www.jython.org" />
		<title level="m">Jython homepage</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Lefty: A two-view editor for technical pictures</title>
		<author>
			<persName><forename type="first">E</forename><surname>Koutsofios</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dobkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graphics Interface &apos;91</title>
		<meeting><address><addrLine>Calgary, Alberta</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="68" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">DEVise: Integrated Querying and Visual Exploration of Large Datasets</title>
		<author>
			<persName><forename type="first">M</forename><surname>Livny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ramakrishan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Beyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Donjerkovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lawande</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Myllymaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Wenger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of ACM SIGMOD</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">LEDA: a platform for combinatorial and geometric computing</title>
		<author>
			<persName><forename type="first">K</forename><surname>Melhorn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Naher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="96" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Layout Adjustment and the Mental Map</title>
		<author>
			<persName><forename type="first">K</forename><surname>Misue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Eades</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sugiyama</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Visual Languages and Computing</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="183" to="210" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Mutzel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Junger</surname></persName>
		</author>
		<title level="m">Graph Drawing Software</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">The PageRank Citation Ranking: Bringing Order to the Web</title>
		<author>
			<persName><forename type="first">L</forename><surname>Page</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Brin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Winograd</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
	<note type="report_type">Stanford Technical Report</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Polaris: A System for Query, Analysis, and Visualization of Multidimensional Relational Database</title>
		<author>
			<persName><forename type="first">C</forename><surname>Stolte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Exploratory Visual Analysis of Graphs in GGobi</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F</forename><surname>Swayne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Andreas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">T</forename><surname>Lang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Distributed Statistical Computing (DSC 2003)</title>
		<meeting><address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">March 20-22, 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Tom</forename><surname>Sawyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Software</forename></persName>
		</author>
		<ptr target="http://www.tomsawyer.com" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title/>
		<author>
			<persName><surname>Touchgraph</surname></persName>
		</author>
		<ptr target="http://www.touchgraph.com" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Exploratory Data Analysis</title>
		<author>
			<persName><forename type="first">J</forename><surname>Tukey</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1977">1977</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Wasserman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Faust</surname></persName>
		</author>
		<title level="m">Social Network Analysis</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Netvigator: Scalable Network Proximity Estimation</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Banerjee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">HP Laboratories Technical Report</title>
		<imprint>
			<date type="published" when="2004-02-28">2004-28, Feb. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
