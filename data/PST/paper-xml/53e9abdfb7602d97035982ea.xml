<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Distributed Algorithms for Guiding Navigation across a Sensor Network</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Qun</forename><surname>Li</surname></persName>
							<email>liqun@cs.dartmouth.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science Dartmouth College</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Michael</forename><surname>De Rosa</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science Dartmouth College</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Daniela</forename><surname>Rus</surname></persName>
							<email>rus@cs.dartmouth.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science Dartmouth College</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Distributed Algorithms for Guiding Navigation across a Sensor Network</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">E3EA3292E5085D7B6336A8D07E80DA02</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:55+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C.2.1 [Network Architecture and Design]: Wireless communication Algorithms</term>
					<term>Design</term>
					<term>Experimentation</term>
					<term>Measurement</term>
					<term>Performance Sensor networks</term>
					<term>Potential field</term>
					<term>Navigation</term>
					<term>Motes</term>
					<term>Robotics</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We develop distributed algorithms for self-organizing sensor networks that respond to directing a target through a region. The sensor network models the danger levels sensed across its area and has the ability to adapt to changes. It represents the dangerous areas as obstacles. A protocol that combines the artificial potential field of the sensors with the goal location for the moving object guides the object incrementally across the network to the goal, while maintaining the safest distance to the danger areas. We give the analysis to the protocol and report on hardware experiments using a physical sensor network consisting of Mote sensors.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>We wish to create more versatile information systems by using adaptive distributed sensor networks: hundreds of small sensors, equipped with limited memory and multiple sensing capabilities which autonomously organize and reorganize themselves as ad-hoc networks in response to task requirements and to triggers from the environment. Distributed adaptive sensor networks are reactive computing systems, well-suited for tasks in extreme environments, especially when the environmental model and the task specifications are uncertain and the system has to adapt to them.</p><p>A collection of active sensor networks can follow the movement of a source to be tracked, for example a moving vehicle. It can guide the movement of an object on the ground, for example a surveillance robot. Or it can focus attention over a specific area, for example a fire to localize its source and track its spread.</p><p>A sensor network consists of a collection of sensors distributed over some area that form an ad-hoc network. Each sensor is equipped with some limited memory and processing capabilities, multiple sensing modalities, and communication capabilities. Previous work in sensor networks has concentrated on routing protocols for sensor networks. Often the network topology is unknown and the network has to discover the best route for a packet. Optimization criteria include shortest path to destination, minimum power utilization, maximum minimum residual power in the network, etc.</p><p>In this paper we focus on a reactive task in sensor networks: guiding the movement of a user equipped with a node that can talk to the field of sensors across the field. We also discuss how sensor networks can serve as adaptive distributed repositories of information.</p><p>Current work in reactive routing protocols (or directed diffusion) are aiming for the network communication. They cannot provide the navigation information to the user in the sensor field. We combine robotics and networking. We model the user guidance problem as a robot motion planning problem and use the inherent feature of the sensor network to compute the robot navigation path in a distributed way. Our paper contributes: <ref type="bibr" target="#b1">(1)</ref> an interesting application for sensor network; <ref type="bibr" target="#b2">(2)</ref> an implementation and evaluation on a physical sensor network; (3) a distance computation method that does not use node positions; (4) performance analysis and hardware experimentation.</p><p>More specifically, we build on important previous work by <ref type="bibr" target="#b17">[17,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b28">28,</ref><ref type="bibr">7]</ref> and examine in more detail reactive sensors that can adapt to their environment by capturing a danger level map and distributing this map across the network. We represent the danger detected by the sensors as "obstacles" in the network and compute the artificial potential field that corresponds to the current state. We then develop a distributed protocol that combines this artificial potential field with information about the direction and goal of the moving object and guarantees the best safest path to the goal. By safest path we mean the path with the largest clearance of the danger zones. We also develop a protocol for distributing the information in the sensor network, such as the danger map and shortest paths. We then show how sensors equipped with limited memory can cooperate to hold and retrieve information about the network. Finally, we discuss an implementation of our protocols on a real sensor network consisting of 50 Mote sensors <ref type="bibr" target="#b10">[10]</ref> and present our experimental data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>We are inspired by previous work in sensor networks <ref type="bibr" target="#b6">[6]</ref>, ad-hoc networks <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b9">9,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b4">4,</ref><ref type="bibr" target="#b24">24]</ref>, and robotics <ref type="bibr" target="#b15">[15]</ref>. Our experimental work is done with the Mote hardware <ref type="bibr" target="#b10">[10]</ref>.</p><p>In Intanagonwiwat et al.'s direct diffusion <ref type="bibr" target="#b11">[11]</ref> approach, data generated by sensor nodes is named by attribute-value pairs. A node requests data by sending interests for named data; the interests will be propagated within the network to find the source of the related data. The direct diffusion method is used to reinforce the best path from the source to the sink. We propose to actively disseminate the information in the network, and consider the sensor network as an information base.</p><p>Ye et al. <ref type="bibr" target="#b28">[28]</ref> proposed TTDD, a Two-Tier Data Dissemination approach that provides scalable and efficient data delivery to multiple mobile sinks. The data source proactively builds a grid structure and the sink requests the data from the nodes on the grid. This approach can be applied to the general problem of sensor network data dissemination.</p><p>Meguerdichian et al. <ref type="bibr" target="#b17">[17]</ref> considered the minimal exposure path problem in a sensor network. They developed an efficient and effective algorithm for the problem. We consider a seemingly similar problem. We are concerned about the dangerous areas rather than the coverage of an individual sensor. Instead of calculating the information about the worst case exposure-based coverage caused by the deployment of a sensor network, we use the sensor network to compute a path that can navigate a user to the goal by avoiding the dangerous area. Furthermore, we use distributed algorithms to disseminate the data in the sensor network.</p><p>There have been many studies conducted on mote sensor networks, especially two recent papers that are closely related to our system implementation. An empirical study on networks composed of over 150 Motes was conducted in <ref type="bibr">[7]</ref>. The paper presents the data collected in different layers and reveals that even a simple protocol can exhibit a large complexity in the mote network. It gives many very useful experimental data on a real sensor network platform. Some of the observations from our experiments show the same behaviors in many scenarios. Wan and Campbell et al. <ref type="bibr" target="#b27">[27]</ref> proposed PSFQ (Pump slowly, Fetch Quickly), a reliable transport protocol in wireless sensor networks. This paper addresses some problems that we encountered in our system implementation.</p><p>Gupta and Kumar <ref type="bibr" target="#b8">[8]</ref> researched the capacity bounds of a large scale ad-hoc network. Scaglione and Servetto <ref type="bibr" target="#b23">[23]</ref> showed an approach to work around the vanishing per-node throughput problem by coupling routing and source coding in a sensor network.</p><p>We use the number of hops to evaluate the distance between sensors. The similar method was used in <ref type="bibr" target="#b19">[19]</ref>. Papers working on location in ad-hoc networks include <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b22">22,</ref><ref type="bibr" target="#b20">20,</ref><ref type="bibr" target="#b25">25]</ref>.</p><p>The application developed in this paper uses techniques from robotics, where a key problem is how to plan the mo-tion of moving robots. A good overview of motion planning in robotics is given by <ref type="bibr" target="#b15">[15]</ref>. <ref type="bibr" target="#b16">[16]</ref> proposed a robot motion planner that rasterizes configuration space obstacles into a series of bitmap slices, and then use dynamic programming to compute the distance from each point to the goal and the paths in this space. This method guarantees that the robot finds the best path to the goal. <ref type="bibr" target="#b14">[14]</ref> discusses the use of an artificial potential field for robot motion planning. A robot moving in accordance to the potential will never hit obstacles, but it may get stuck in local minima. We combine these two methods to find the best path to the goal, which is safe and short, and modify them to exploit the distributed nature of sensor networks. Another related work by Batalin and Sukhatme <ref type="bibr" target="#b2">[2]</ref> is to address the problem of coverage and exploration of an unknown dynamic environment using a mobile robot by using beacons. The beacons (markers) that form a communication network are used a support infrastructure to aid exploration of the mobile robot.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">A DISTRIBUTED ALGORITHM FOR GUID-ING THE NAVIGATION OF A USER</head><p>Sensors detect information about the area they cover. They can store this information locally or forward it to a base station for further analysis and use. Sensors can also use communication to integrate their sensed values with the rest of the sensor landscape. In this section we explore using sensor networks as distributed information repositories. We describe a method to distribute the information about the environment redundantly across the entire network. Users of the network (people, robots, unmanned planes, etc.) can use this information as they traverse the network. We illustrate this property of a reactive sensor network in the context of a guiding task, where a moving object is guided across the network along a safe path, away from the type of danger that can be detected by the sensors.</p><p>The guiding application can be formulated as a robotics motion planning problem in the presence of obstacles. The dangerous areas of the sensor network are represented as obstacles. Danger may include excessive heat (volcanoes, fire, etc), people, etc. We assume that each sensor can sense the presence or absence of such types of danger. A danger configuration protocol run across all the nodes of the network creates the danger map. We do not envision that the network will create an accurate geometric map, distributed across all the nodes. Instead, we wish for the nodes in the network to provide some information about how far from danger each node is. If the sensors are uniformly distributed, the smallest number of communication hops to a sensor that triggers "yes" to danger is a measure of the distance to danger. The goal is to find a path for the moving object that avoids the dangerous areas. We envision having the user ask the network regularly for where to go next. The nodes within broadcasting range from the user supply the next best step.</p><p>There are numerous solutions to motion planning in the presence of obstacles and uncertainty. For a good survey of the techniques see <ref type="bibr" target="#b15">[15]</ref>. We seek a solution that lends itself naturally to the discrete nature of sensor networks. In <ref type="bibr" target="#b16">[16]</ref>, Donald et al. describe an optimal solution for motion planning when the map of the world is given. The first step of the solution is to rasterize the configuration space obstacles into a series of bitmap slices. Dynamic programming is then used to calculate the optimal path in this space. Although this method can not be applied directly, it can be adapted for sensor networks. Although the map is not immediately available, the motion planning algorithm fits a sensor network well in two ways. First, the sensors can be regarded as the bitmap pixels. Second, the dynamic programming component of the algorithm can be implemented by using the sensor communications.</p><p>In order to supply obstacle information to the planning algorithm we use artificial potential fields. In an artificial potential field, objects move under the actuation of artificial forces. Usually, the goal generates an attractive potential which pulls the object to the goal. The obstacles generate a repulsive potential which push the object away from the goal. The (negated) gradient of the total potential is the artificial force acting on the object. The direction of this force is the current best direction of motion <ref type="bibr" target="#b15">[15]</ref>.</p><p>The "obstacles" (recall they correspond to the dangerous areas) will have repulsing values and the goal will have an attracting value according to some metric (see Figure <ref type="figure" target="#fig_0">1(left))</ref>. Algorithm 1 shows the potential field protocol. The potential field is computed in the following way. Each node whose sensor triggers "danger" 1 diffuses the information about the danger to its neighbors in a message that includes its source node id, the potential value, and the number of hops from the source of the message to the current node. When a node receives multiple messages from the same source node, it keeps only the message with the smallest number of hops. (The message with the least hops is kept because that message is likely to travel along the shortest path.) The cur- 1 The possibility to identify obstacles is dependent on the sensing quality of the sensors. Our assumption is that the sensors have this capability and this is not the concern of our algorithm, although it is a very important factor in applying our algorithm in real applications. In our experiments, a light sensor becomes an obstacle when it detects a high light intensity. For Mica Motes we found that the light sensors work well.</p><p>Algorithm 1 The potential field computation protocol.</p><p>1: for all sensors si in the network do 2: poti = 0, hopsj = ∞ for any danger j 3:</p><p>if sensed-value = danger then 4: hopsi = 0 5:</p><p>Broadcast message (i, hops = 0) 6:</p><p>if receive(j, hops) then 7:</p><p>if hopsj &gt; hops + 1 then 8: hopsj = hops + 1 9:</p><p>Broadcast message (j, hopsj) 10:</p><p>for all received j do 11:</p><p>Compute the potential pot j of j using pot j = 1 hops j 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>12:</head><p>Compute the potential at si using all pot j , poti = poti + pot j if receive((g, k, hops, potential) then 6:</p><p>Compute the potential integration from the goal to here: 7:</p><p>if Pg &lt; potential + poti then 8:</p><formula xml:id="formula_0">Pg = potential + poti 9: hopsg = hops + 1 10: priorg = k 11:</formula><p>Broadcast (G id , my id (si), hopsg, Pg)</p><p>rent node computes the new potential value from this source node. The node then broadcasts a message with its potential value and number of hops to its neighbors. After this configuration procedure, nodes may have several potentials from multiple sources. To compute its current danger level information, each node adds all the potentials.</p><p>Note that the potential field protocol provides a distributed repository of information about the area covered by the sensor network. It can be run in an initialization phase, continuously, or intermittently. The sensor network can selforganize adaptively to the current landscape. It updates its distributed information content by running the potential field computation protocol regularly. In this way, the network can adapt to sensor failure, to the addition of new nodes into the network and to dynamic danger sources that can move across the network.</p><p>The potential field information stored at each node can be used to guide an object equipped with a sensor that can talk to the network in an on-line fashion. The safest path to the goal can be computed using Algorithm 2. The goal node initiates a dynamic programming computation of this path using broadcasting. The goal node broadcasts a message with the danger degree of the path, which is zero for the goal. When a sensor node receives a message, it adds its own potential value to the potential value provided in the message, and broadcasts a message updated with this new potential to its neighbors. If the node receives multiple messages, it selects the message with the smallest potential (corresponding to the least danger) and remembers the sender of the message.</p><p>A user of the sensor network can rely on the informa-Algorithm 3 The navigation guiding protocol. 1: if si is a user sensor then 2: while Not at the goal G do 3:</p><p>Broadcast inquiry message (G id ) 4:</p><p>for all received messages m = (G id , my id (s k ), hops, potential, prior) do 5:</p><p>Choose the message m with minimal potential then minimal hops 6:</p><p>Let my id (s k ) be the id for the sender of this message 7:</p><p>Move toward my id (s k ) and prior 8: if si is an information sensor then 9:</p><p>if receive (G id ) inquiry message then 10:</p><p>Reply with (G id , my id (si), hopsg, Pg, priorg)</p><p>tion computed using Algorithms 1 and 2 to get continuous feedback from the network on how to traverse the area. Algorithm 3 shows the navigation guiding protocol. The user asks the network for where to go next. The neighboring nodes reply with their current values. The user's sensor chooses the best possibility from the returned values. Note that this algorithm requires the "integrated" potential computed by Algorithms 1 and 2 in order to avoid getting stuck in local minima.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Implementation Issues</head><p>Our navigation algorithms have an implicit assumption that the communication paths in the network are bi-directional. Since the safest path is computed backward from the goal, messages have to be able to flow in the opposite direction to lead the user to the goal. Our experience (see 4.4) has taught us that not all links in sensor networks are bi-directional. For example see Figure <ref type="figure" target="#fig_1">2</ref> that shows the distribution of symmetric and asymmetric links in an experiment with a 7x7 grid of Mote sensors. This is consistent with data from <ref type="bibr">[7]</ref>. We propose the following method for identifying the bidirectional links in the network. The computation can be thought of as an additional protocol run by each node. The distribution of symmetric and asymmetric links in one experiment. The x-axis shows the node id and the y-axis the number of links. For each node we have three bars: the first shows the number of symmetric links, the second is the number of unidirectional outgoing links and the third the number of unidirectional incoming links.</p><p>Each node does neighbor profiling to find all its stable one-hop neighbors bi-directionally; that is, these neighbors should be reachable to and from the node with high probability. In this way we may ward off the unidirectional link nodes that may lead to long distance hops. Each node only uses the received packets from its stable neighbors after profiling. In our current implementation, we perform the neighbor profiling on the fly. Every time a node receives a packet, it increases the frequency of the sender of the packet, which measures the stability of that link. A link is used only if its frequency is higher than some threshold value, which is one fifth of the maximal frequency of all the links in our implementation. 1/5 is a parameter we chose for our experiments.</p><p>A side effect of neighbor profiling is the removal of many of the transient links that are active for a very short time. By exchanging the information about the frequency of two neighbors, the system ends up using the most stable bidirectional links. Our hop distance can also be close to average instead of too abnormal.</p><p>Algorithms 1 and 2 ask each sensor to broadcast upon receiving a message with fewer hops to the dangerous area or a smaller potential integration to the goal. Many broadcasts may not be necessary since only the message with the least hops to the danger node location or the minimal potential integration to the goal is useful. To reduce the message broadcasts, we let each sensor wait for some time before it broadcasts. The waiting time for sensor si is proportional to one unit in Algorithm 1 and the value poti in Algorithm 2. The main idea is to let the message traveling time be proportional to the hops from the danger or the potential integration along the path traveled. Then the messages that carry the non-optimal value will be suppressed and only the messages that carry the optimal value will get broadcast. We can prove that the number of message broadcasts for each sensor is 1 in each algorithm using this technique <ref type="bibr" target="#b1">[1]</ref>. In our current implementation, we let each sensor wait for one unit time plus a small random number to reduce the message broadcasts and traffic congestions due to the simultaneous transmissions.</p><p>In order to desynchronize the nodes in a proximity that would, upon the reception of a packet, simultaneously broadcast the packet, we also add random variable waiting time to each node to reduce the contention.</p><p>Packet loss is common in our Mote network because of the network congestion or the inability of the Mote to handle the incoming packets. Thus it is important that we design protocols that repeat the packet transmission.</p><p>Most of the information stored at a node can be inferred by reading the protocols. To adapt the network topology (goal and obstacles) change, each sensor periodically flushes its route cache (route to obstacles and goal) with all the other information unchanged. Currently we have not included the capability to tune the cache expiration timer. Instead, we fix the expiration time to flush the caches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Analysis</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Correctness</head><p>Our protocols can correctly determine the safest path to the goal without getting stuck in the local minima that are often an issue with artificial potential fields methods. Theorem 1. Algorithm 3 will always give the user sensor a path to the goal.</p><p>Proof. In Algorithm 2, the prior link of a node points to a node that has potential value less than that of the current node. So for each node other than the goal, there must be a neighboring node that has a smaller potential value. This proves that there is no local minima in the network. The user's sensor can always find a node among its neighbors that leads to a smaller potential value. If the process continues, the node will end up with the goal that has the smallest potential value 0. Therefore, Algorithm 3 can always give the user sensor a path to the goal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">The Hop Distance Model</head><p>One critical assumption behind Algorithm 1 is that we can represent distance in terms of numbers of hops. In general, how realistic is this model? To answer this question, we consider how the density of the sensor distribution affects the distance evaluation in our algorithms. We now address this question for the case when that each node has a constant transmission range, which is an assumption consistent with our testbed hardware.</p><p>The key metric is the minimal number of hops between any two sensors that are l distance apart. Since in our algorithms each sensor uses flooding to broadcast packets to all of its neighbors and each sensor within the transmission range of the broadcasting sensor can forward the packets, it is very hard to characterize this metric. An approximation can be obtained by allowing only the sensors at the boundary of the transmission range to forward packets. Of all those sensors we choose the sensor that can make the most progress in the direction of the destination sensor. The number of hops computed this way is an approximation of the minimal number of hops.</p><p>In <ref type="bibr" target="#b26">[26]</ref>, Takagi and Kleinrock proposed the most forward routing and analyzed its average progress in the direction of the destination. We can use the same analysis to approximate the distance of a single hop.</p><p>Suppose the average progress be R by using the analysis in <ref type="bibr" target="#b26">[26]</ref> and the transmission range be R. Then the minimal ideal hops should be l/R, but the expected minimal hops in our real sensor network is l/R . That is, the distance we evaluate is always R/R times of the real distance.</p><p>In <ref type="bibr">[7]</ref>, Ganesan et al. reported the length of a hop may not be fixed, as we observed in our experiments. By experiments, we can get the expectation and the deviation of the length of a hop (call them E and d). According to central limit theorem in probability theory, the length of n hops has the expectation of nE and the deviation of √ nd, that is, the deviation (or the difference) between the real distance and the computed distance is in the order of √ nd, which is small compared with the distance of the order of nE. This actually shows that our algorithms are robust in the real network scenario.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.3">Performance Bound of the Computed Path</head><p>We expect our protocols to compute the integrated potential value on the safest path, but the implementation introduces error. We now compare the integrated potential value on the path found by our protocols and the optimal path to show how safe the found path would be.</p><p>Theorem 2. The computed potential integration on the computed path is upper and lower bounded with respect to the actual potential integration on the path.</p><p>Proof. Suppose we find a path from A to B by running our algorithms, the sum of the potential value on the sensor nodes by running our algorithm is P1, and the nodes on the found path are A = s0, s1, s2,</p><formula xml:id="formula_1">• • • , s k = B. Let s0s1, s1s2, • • • , s k-1 s k (or s0s1s2 • • • s k-1 s k ) be the path con-</formula><p>necting all these nodes consecutively by lines. Let the integration on this path be P2 (continuous line integration, not only on the points). We would like to compare P1 and P2; specifically we would like to upper bound P2. Take a look at si-1si. Let the potential value of si-1 be pi-1, si be pi. We assume we use the fixed transmission model. |si-1si| ≤ R (R is the transmission range). For any danger source dj, suppose the potential that si gets from obstacle dj is pij = 1</p><formula xml:id="formula_2">h 2 ij where hij = l ij</formula><p>R and lij is the distance between si and dj . For any point t on segment si-1si, let ltj be the distance between t and dj. Then ltj ≥ lij -R, so the potential value at t due to dj is ptj = 1</p><formula xml:id="formula_3">h 2 tj ≤ R 2 (l ij -R) 2 = 1 ( l ij R -1) 2 = 1 (h ij -1) 2 . So we have p tj p ij ≤ h 2 ij (h ij -1) 2 . Similarly we have p tj p i-1j ≤ h 2 i-1j (h i-1j -1) 2 .</formula><p>By integrating upon the entire path, we have the following. P2 =</p><formula xml:id="formula_4">B A j ptj = k-1 i=0 s i+1 s i j ptj ≤ k-1 i=0 s i+1 s i j ( h 2 ij (h ij -1) 2 •pij ) ≤ k-1 i=0 R•( j h 2 ij (h ij -1) 2 •pij ) (since |si-1si| ≤ R) If h 2 ij (h ij -1) 2 ≤ q1 for all i, j, we have P2 ≤ R•q1• k-1 i=0 j pij = R • q1 • P1.</formula><p>On the other hand, we have the following. First we have |si-1si+1| ≥ R, so |si-1si| + |sisi+1| ≥ R. Let's find s i on sisi+1 such that |si-1si| + |sis i | = R/2 or find s i on si-1si such that |s i si| + |sisi+1| = R/2. Without loss of generality, we assume s i is on sisi+1. The distance from any point on si-1si or sis i to si-1 is no greater than R/2 (also less than R), so for any point t on these two segments, we have ptj =</p><formula xml:id="formula_5">1 h 2 tj = R 2 (l tj ) 2 ≥ R 2 (l i-1j +R) 2 = 1 (h i-1j +1) 2 .</formula><p>Similarly, the distance from any point on s i si+1 to si is no greater than R, so for any point t on this segment, we have ptj = 1</p><formula xml:id="formula_6">h 2 tj = R 2 (l tj ) 2 ≥ R 2 (l ij +R) 2 = 1 (h ij +1) 2 . Let s0, s2, • • • , s2i be s 0 , s 2 ,</formula><p>• • • , s 2i and we then create s 1 , s 2 , • • • , s 2i+1 by the above procedure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>It follows that P2</head><formula xml:id="formula_7">= B A j ptj = k-1 i=0 s i+1 s i j ptj ≥ k-2 i=0 s i+1 s i j ( h 2 ij (h ij +1) 2 •pij ) ≥ k-2 i=0 R 2 •( j h 2 ij (h ij +1) 2 •pij ). If h 2 ij (h ij +1) 2 ≥</formula><p>q2 for all i, j, and</p><formula xml:id="formula_8">j h 2 k-1j (h k-1j +1) 2 is very small compared to P1, we have P2 ≥ R 2 • q2 • k-1 i=0 j pij = R 2 • q2 • P1.</formula><p>Combining the preceding analysis, we have</p><formula xml:id="formula_9">R 2 • q2 • P1 ≤ P2 ≤ R • q1 • P1.</formula><p>This tells that the real potential integration on the computed path is relatively close to the computed potential integration of the sensor nodes on that path.</p><p>Theoretically, there is an optimal path that has the minimal potential integration and may not traverse any sensor node, but this path is not feasible in our system since a user can only go from one sensor to another by listening to the reply from the next sensor in our navigation protocol. Therefore, instead of defining an optimal path, we define an optimal sensor path as one that is composed of a series of sensor nodes that are connected consecutively by straight line segments (the connected nodes are within the transmission range of each other), which we expect to characterize the motion of a user. Assume the optimal sensor path is a series of segments u0u1 • • • u l where u0, u1, • • • , u l are the sensor points and the potential integration along all these segments is P0. We now compare the potential integration of this optimal sensor path (P0) with that of our computed path (P2).</p><p>Theorem 3. The potential integration on the computed path is upper bounded with respect to the potential integration on the optimal sensor path.</p><p>Proof. Starting from u0 = s0, we want to choose some nodes from u0, u1, • • • , u l in that order. Suppose we have chosen s0 = u0, s1</p><formula xml:id="formula_10">= u l 1 , • • • , s2i-3 = u l 2i-3 , s2i-2 = u l 2i-2 .</formula><p>Let's choose the next two points s2i-1 = uj , s2i = uj+1 with the least j such that j &gt; l2i-2 and |s2i-2uj+1| = |u l 2i-2 uj+1| &gt; R. The process continues until there is no point left and we let the last point be s k = u l . Let the potential sum on all those points si (0 ≤ i ≤ k -1) be P 0 (by adding up the potential values on all the node points), and we will compare P0 and P 0 . For any 1 ≤ x ≤ k, we have |sx-1sx| ≤ R, and for any 0 ≤ y ≤ k/2 , we have |s2y-2s2y-1| + |s2y-1s2y| &gt; R. Consider segments s2y-2ue • • • u f s2y-1s2y on the optimal sensor path. If the sum of all the segments of s2y-2ue • • • u f s2y-1 is no less than R/2, we find s 2y-1 on the segments of s2y-2ue </p><formula xml:id="formula_11">• • • u f s2y-1 such that |s2y-2ue • • • ups 2y-1 | ≥ R/2,</formula><formula xml:id="formula_12">• • • u b s2y-1 such that |s2y-2ue • • • ups 2y-1 | ≥ R/2, |s 2y-1 ur • • • s2y-1s2y| ≥ R/2,</formula><p>and all points on s2y-2ue • • • ups 2y-1 is within R from s2y-2, and all points on s 2y-1 ur • • • s2y-1s2y is within R from s2y-1 ). If the sum of all the segments of s2y-2ue • • • u f s2y-1 is less than R/2, we find s 2y-1 on the segment of s2y-1s2y such that |s2y-2ue • • • u f s2y-1s 2y-1 | = R/2. In either case, any point t on segments s2y-2ue • • • s 2y-1 has potential value ptj ≥ 1 (h 2y-2j +1) 2 , and any point t on segments s 2y-1</p><formula xml:id="formula_13">• • • s2y has potential value ptj ≥ 1 (h 2y-1j +1) 2 . Both |s2y-2ue • • • s 2y-1 | and |s 2y-1 • • • s2y| are no less than R/2. P0 = l-1 i=0 u i+1 u i j ptj ≥ k/2 -1 i=0 ( s 2i-1 s 2i-2 j ( h 2 2i-2j (h 2i-2j +1) 2 • p2i-2j ) + s 2i s 2i-1 j ( h 2 2i-1j (h 2i-1j +1) 2 • p2i-1j )) ≥ k-2 i=0 R 2 • ( j h 2 ij (h ij +1) 2 • pij). If h 2 ij (h ij +1) 2 ≥</formula><p>q0 for all i, j, and</p><formula xml:id="formula_14">j h 2 k-1j (h k-1j +1) 2 is very small compared to P 0 , we have P0 ≥ R 2 • q0 • k-1 i=0 j pij = R 2 • q0 • P 0 . Since P 0 ≥ P1 ≥ P 2</formula><p>Rq 1 , we have P2 ≤ 2q 1 q 0 P0, i.e., our computed path has bounded potential integration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.4">Propagation and Communication Capability</head><p>Two natural questions arise about the protocols we described previously: How much time does it take to propagate the obstacle and goal information? Is the network capable of transmitting all the information? In this section, we answer the two questions in the context of our current implementation, in which we use one packet for propagating the information of each obstacle or goal for every broadcast. To optimize the bandwidth usage by reducing the information transmission, we can combine the information about two or more obstacles and the goal into a packet, or use information encoding to reduce the information redundancy among the neighboring nodes. It is no surprising they can provide performance gain to our system.</p><p>We assume that each node has fixed transmission range and the nodes in a node's neighborhood (say k nodes) should be silent to avoid contention when that node broadcasts. For the obstacle information propagation, assume the number of the concerned obstacles is o; i.e., on average, each node has to process the information of o obstacles. Let the transmission rate for each node be b packets/s. Then the time for the obstacle information propagating to a node is okl/b where l = min(L, l0), L is the distance for the potential value to become 0, and l0 is the distance between the node and the obstacle, both in number of hops. The formula is for the case when we add waiting time for each broadcast; i.e., each node only broadcasts once for each obstacle information propagation. In this case, each node needs to wait for k/b time before broadcasting the best value. This waiting time allows enough time for each of the node's neighbors to broadcast the packet if they hold the same value as this node, so that they do not collide. For the case without explicit waiting time scheme, the MAC protocol enforces this delay to make sure all the packets go through smoothly. On the other hand, suppose we do not have the waiting time scheme, each node may broadcast multiple times because the least number of hops is unlikely to be obtained by the first received message so that the node needs to broadcast several packets before the best value is propagated. In this case, we must multiply the propagation time by another parameter m, which is the average messages broadcast for each node. Similarly, we can evaluate the propagation time for the goal information.</p><p>The transmission rate of the Mote sensors we are using is approximately b = 40 packets/s, so for k = 8, the added waiting time to each node is 8/40 = 0.2s. Regardless of how many obstacles there are in this system, if each node is in the proximity of only one obstacle, it takes 0.2 * 10 = 2 seconds to propagate the information up to 10 hops away.</p><p>When the obstacles are static, and we do not care about the time, the network is capable of transmitting these amount of bits. If we have some constraints on the time, say, we have moving obstacles and the location of an obstacle must be known to the network within a distance resolution d, the network may not be able to carry all the information. Suppose the maximal speed of the obstacle is v. In the worst case, an obstacle generates v/d packets per time unit, so each node needs to process ov/d packets, which should be less that b/k, i.e., ov/d &lt; b/k. If we do not have the waiting time, we expect more packets will be generated and the precision about the vehicle represented by the network will be low.</p><p>Suppose an obstacle is moving at a speed of 1m/s, the maximal transmission rate for a node is 40 packets/s, the number of concerned obstacles is 1, and the number of the concerned neighbors of a node is 8. The network can sustain updates at a resolution of 0.2 meters. If we have the same network, but the moving object is a vehicle moving at a speed of 30 miles, the vehicle updates can happen every 2.7 meters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">EXPERIMENTS</head><p>We have implemented the algorithms described in Section 3 using the Mote MOT300 sensors <ref type="bibr" target="#b10">[10]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Correctness Validation</head><p>We have implemented the protocols in Algorithms 1, 2, and 3. In our experiments, we asked both the goals and the obstacles to generate the potential field and propagate it to the entire network periodically. This demonstrates experimentally that the goals and the obstacles can be added to the network at any time.</p><p>The goal is represented with one Mote. The obstacles are represented by one Mote each. The user traversing the sensor network is also represented by one Mote.</p><p>A first experiment was designed to show empirically that the protocols work and are correct. In this first experiment we used a grid of 12 first generation Motes. The Motes were approximately on a line with several nodes around the obstacles in order to test if the safest path is a detour around the obstacle. All neighbors are within communication range. The application is run by iterating a request for the next step by the user, a response by the network, and a move to the direction of the network response. To implement this last part we assume that the nodes know their location and that it can be transmitted to the moving object/user. This can be done by augmenting Motes with a GPS location, or via triangulation. Since we have not done this augmentation of the hardware yet, we simulate location knowledge by placing the Motes in a grid pattern and supplying coordinates. The potential field and goal path computations are run by the network continuously.</p><p>When an obstacle or goal broadcasts, the receiving network node checks its list of known goals, and replaces the old data with the new broadcast if the new broadcast has a lower hop count. If the obstacle or goal is unknown, then an entry is created, and it erases the oldest entry if there is no room.</p><p>When a node receives a broadcast, it degrades the value of the broadcast based either on a linear function on the number of hops (for goals) or by the number of hops squared (for obstacles). If the new value is not below a cutoff threshold, the packet is transmitted to its neighbors.</p><p>When a user requests potential estimates, all nodes that can hear it respond. The user chooses the node with the lowest value (that is lower than the value of the current node). The user moves toward this node.</p><p>This first experiment proved that a user with a sensor node actually went around the obstacles and got to the goal, via the correct path. We observed that the network adapted to the introduction of new obstacle nodes quickly and robustly.</p><p>When a new obstacle is inserted in the network, the obstacle starts broadcasting its danger information which affects the information held by each node. At this point Algorithms 1 and 2 cause the local information to change. We call the total time for the network to identify the new distances from danger and to the goal for each node the time for the network to stabilize. In other words, the time for the network to stabilize is the information propagation time in the network, which depends on the maximal hops from the goals or the obstacles to any node in the network. When an obstacle is added to the system online, it takes an identical amount of time to diffuse the information to the whole network.</p><p>Fig. <ref type="figure" target="#fig_4">3</ref> shows the comparison between the measured real distance and the hops counted using our algorithm. The data was collected in our 7x7 grid network. We can see the measured real distance is approximately linear in the number of hops. Fig. <ref type="figure" target="#fig_6">4</ref> shows the potential integrations (line integration instead of the sum of the point potentials) in 54 experiments with eight different network topologies. For each network topology, we computed the optimal path by using dynamic programming and recorded the computed paths in several experiments. The solid line is the potential integration on the optimal path. The dashed line is the average potential integration over the computed paths. The dotted line is the worst potential integration among all the computed paths in experiments. Note that the potential integration bears no linear relationship with the distance. Compared with a dangerous path, which has potential integration of 3-5, the computed path is quite close to the safest path.    </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Measuring Adaptation</head><formula xml:id="formula_15">) )<label>(</label></formula><p>)</p><p>) )</p><p>4.20 4.20 0.30 12.80</p><formula xml:id="formula_17">0 0 0 0 0 0 1 1 1 1 1 1</formula><p>1.43 2.10 0.17 2.17 1.10 27.17 4.27 9.10</p><p>For each experiment, the goal is at the black disk and the danger is at the shaded disk.</p><p>second experiment, we used a 50 Mote MOT300 testbed. We arranged the nodes in the given topology and gave each node position information (which could be obtained using a GPS extension of the hardware.) We ran a suite of different network topologies and measured the network stabilization time when obstacles and goals are injected on-line in the network. Tables 1 summarizes our data. The layouts include grids with various numbers of Motes, randomly dispersed Motes, and circles. In each network we inserted obstacle sensors (assumed to have detected danger) and goal sensors. The focus of these experiments has been to determine on how quickly the network responds to the environmental change, specifically new danger sources and goal changes.</p><p>We ran all the experiments on a large table in our lab, as shown in Figure <ref type="figure" target="#fig_0">1</ref>(right). For each experiment, we set the transmission range to be very small (9"). In all these second round experiments we focused on the network as a whole and did not use a base station (thus, we did not collect data in a central place.) To collect timing data, we used two procedures: the videotaping procedure and the logging procedure.</p><p>We used the videotaping procedure to capture the global behavior of the sensor node. The Mote LEDs were programmed to capture the state of the Mote. We recorded the experiment with a Sony video camera at a rate of 30 frames per second. We then analyzed the resulting video to capture the timing measurements-which gave us a resolution of 1/30 th of a second. We looked at the video sequence frame by frame and kept track of when and which LED triggered. Since the overall timings for the navigation algorithms are on the order of seconds, we believe our methodology is accurate enough.</p><p>We analyzed four metrics for each experiment: the time for the danger information to propagate from the danger/obstacle sensor to the whole network, the time for all the nodes in the network to obtain their shortest distance to the dangerous areas, the time for the goal information to propagate to the whole network, and the time for all the nodes in the network to obtain their safest path to the goal. Tables 1 shows the time distribution of the four metrics.</p><p>We also did experiments to measure the response time of the sensor network after changing the topology of the network. Starting from the initial topology (No. 0), we changed the locations of the obstacles and recorded the response time in each experiment. Table <ref type="table" target="#tab_1">2</ref> shows the data of 15 consecutive experiments. The response time is defined as the period from the time when the topology change occurs to the time when the user finds the path to the goal. The route cache on each mote is refreshed every 10 seconds. The route information incurred by the topology change is updated only after flushing the cache. Without taking into account the information propagation time, the average response time is 5 seconds. The information propagation adds extra time after the cache is flushed.</p><p>We also used the logging procedure to collect data about the message flow in the system. In the logging procedure, information about incoming and outgoing messages, as well  4.50</p><formula xml:id="formula_18">0 ¡ ¡ ¡ ¡ 0 1 ¢ ¢ ¢ ¢ ¢ ¢ £ £ £ £ 3.63 2 ¤ ¤ ¤ ¤ ¤ ¤ ¥ ¥ ¥ ¥ ¥ ¥ 6.83 3 ¦ ¦ ¦ ¦ ¦ ¦ § § § § 3.</formula><p>) )</p><p>4.87</p><formula xml:id="formula_20">12 0 0 0 0 0 0 1 1 1 1</formula><p>6.70 For each experiment, the goal is at the black disk and the danger is at the shaded disk. The black line and arrow signify the safe path found in each network topology.</p><p>as internal events of interest, were logged to the 4Mbit flash chip on the Mote sensors with a resolution of 1/128 of a second. After each experiment the data was read out over the radio link and then postprocessed using custom C programs.</p><p>There are some limitations to this approach since data can be lost if a write to the flash chip is already pending. This was minimized by adding buffers so that at least one message or event of each type could be queued for writing if a write was already pending. Figure <ref type="figure">5</ref>: Measured communication graph of the experimental 7x7 grid network. Notice the absence of many point to point links we expect to be available (from example from (1,1) to (2,1)) and the presence of long links we do not expect to have, for example from (1,7) to <ref type="bibr">(7,</ref><ref type="bibr" target="#b6">6)</ref>.</p><p>Nodes were configured to log records of the packets sent and received, corresponding time, and related internal events. The network was a 7x7 grid with 49 Motes evenly placed on the grid. The neighboring Motes were spaced apart from each other at a distance slightly less than the transmission range in the appropriate direction. The two obstacles were placed at (1, 1) and <ref type="bibr">(7,</ref><ref type="bibr">7)</ref>; the goal was put at position <ref type="bibr" target="#b1">(1,</ref><ref type="bibr">7)</ref>. Starting from (1, 1), we numbered the Motes along the lines Figure <ref type="figure">6</ref>: The obstacle and goal propagation time distribution. In our experiment, the nodes were arranged in a 7x7 grid, with obstacles placed at (1,1) and <ref type="bibr">(7,</ref><ref type="bibr">7)</ref>. The nodes on x-axis are sorted according to the Manhattan distance to (1,1), while the y-axis shows propagation time (in seconds). shown on the y-axis. parallel to the line (1, 7) -(7, 1), so that 1 and 49 were obstacles and 22 was the goal. The number of each mote gives a sense of the distance to the two obstacles. The obstacles and the goal periodically broadcast beacons. Each mote rebroadcasts a packet only if the received packet has a value that is as good, or better than, the current optimal value.</p><p>In order to distinguish the information propagation of the obstacle and goal, we first turned on the obstacles for approximately 30 seconds, and turned them off, then turned on the goal mote for more than 30 seconds. Fig. <ref type="figure">5</ref> shows the connectivity between Motes. A line between two Motes indicates that they communicated directly at least once in the experiment. We can see how irregular  Fig. <ref type="figure">6</ref> (top) shows the obstacle information propagation time, that is, the time when a mote receives a stable potential value. Some Motes get the stabilized potential value very quickly, but it takes a long time for a fraction of Motes to finally get the potential. The same observation can be made in Fig. <ref type="figure">6</ref> (bottom), which shows the goal propagation time, defined as the time for a mote to get a stabilized integration value to the goal. Fig. <ref type="figure" target="#fig_11">7</ref> presents the number of transmitted packets and received packets at each mote. The Motes closer to the obstacles transmit and receive more data. In the middle of the x-axis, the heightened activity represents Motes that are close to the goal.</p><p>Fig. <ref type="figure" target="#fig_12">8</ref> plots the the send/receive activity of each node over time, which gives more detail about the packets sent and received. The Motes close to the obstacles or the goal receive and rebroadcast more packets than other Motes. In this figure, we observe some void areas where no mote sends or receives any packet. This is because many Motes do not reliably rebroadcast packets to their neighbors. We believe this to be caused by two factors. One is that the rate of packet reception at these key nodes is too high, and thus they are unable to process all incoming messages. Another is that the packets these nodes forward to their neighbors are corrupted because of network congestion. This also explains why the obstacle and goal propagation times are uneven, as much more traffic is generated by two obstacles than by one goal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Performance Optimization</head><p>We optimized the message broadcasts using the methods described in section 3.1 and performed several experiments with this implementation. The goal was to eliminate the asymmetric and transient links and to reduce the network congestion. The experiments were conducted on the same 7x7 grid as ones in section 4.2. The following figures were plotted in the same fashion as the related figures in the previous experiments. We observed the following (as compared to the initial suite of experiments). 1. The obstacles and goal propagation time (Fig. <ref type="figure" target="#fig_14">10</ref>). The obstacle propagation was done very quickly and evenly for each node because the network had less congestion. Our current waiting time scheme gave the priority to the packets that traveled with less hops.</p><p>2. Packet send/receive count (Fig. <ref type="figure" target="#fig_16">11</ref>). Compared to our previous scheme, we see much better balanced packet transmission on all the nodes. Most of the nodes showed the increase in the transmitted packet both for sending and receiving, which suggests that less packets were suppressed because of the congestion and all the nodes had quite large probability to broadcast their best computed value to the network.</p><p>3. The packet send/receive analysis (Fig. <ref type="figure" target="#fig_17">12</ref>). In this figure, we have more packets for goal propagation because each node actively broadcasts (broadcasts once for every second) to test the network congestion. We see that although there is large network traffic, the sends and receives on each node are balanced. For all the nodes, the transmitted packets are balanced among all the nodes. We can reduce the transmitted packets in goal propagation by changing the program.    </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Lessons Learned</head><p>Several interesting aspects of these experiments can be observed. The time for network stabilization (that is, the time for all the nodes to get the shortest distance to the danger source and the time for all the nodes to get the safest path to the goal) takes much longer than we expected. In our algorithms we made two typical assumptions: (1) a node broadcasts the message received immediately and (2) each node gets the packet traveling through the shortest path. We observed that on the hardware testbed neither of these assumptions held. The network stabilization takes a long time because of network congestion and transitory link status. Often, nodes seemingly out of range hear each other for brief moments of time.</p><p>Our observations of these hardware experiments have taught us some lessons about the assumptions used by most distributed sensor network protocols examined theoretically or in simulation.</p><p>1. Data loss. Data loss is not rare in sensor networks. This is due to network congestion, transmission interference, and garbled messages.</p><p>2. Asymmetric connection. We observed that the transmission range in one direction may be quite different from that in the opposite direction. Thus, the assump- tion that if a node receives a packet from another node, it can send back a packet is too idealistic. In routing algorithm design, the existence of a route that can carry a packet from the source to a node does not guarantee a reverse route from that node to the source.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Congestion. Network congestion is very likely when</head><p>the message rate is high. This is aggravated when the nodes in proximity of each other try to send packets at the same time. For a sensor network, because of its small memory and simplified protocol stack, congestion is a big problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.</head><p>Other unpredictable network conditions. In our sensor networks nodes that should be several hops away from each other occasionally come in direct communication range. We expect many transitory links (on and off) in a unstable network due to the impact of the unpredictable conditions.</p><p>We conclude that the uncertainty introduced by data loss, asymmetry, congestion, and transient links is fundamental in sensor networks. We need new models, algorithms, and simulations that take this kind of uncertainty into account. Guided by these lessons, we are currently conducting experiments to characterize better the likelihood of these uncertainty conditions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">USING SENSOR NETWORKS TO DIS-TRIBUTE INFORMATION</head><p>Section 3 provided an example for how to use a sensor network as a distributed information repository about the environment in the context of a navigation guiding application. In this section we examine in more detail how to represent the information needed by our algorithm effectively in a sensor network. We thus examine the use of a sensor network as a distributed information repository.</p><p>Consider again the navigation guiding application formulated as a motion planning problem. Suppose multiple goal are installed in the network. It is possible that each sensor has enough memory to store all the pertinent information about these goals. However, the current sensor hardware has very limited memory which restricts the amount of information that can be stored.</p><p>We argue that sensors do not have to store all the information about the goals. Instead, all the necessary information should be stored somewhere, but not everywhere, in the network. The important thing is being able to retrieve the information any time it is needed.</p><p>Many sensors can cooperate to store information by having each sensor locally store only part of it. If the density of the network is such that multiple sensors cover the same area, the local information is the same for the sensors in some neighborhood. Thus, it does not matter who stores what. We propose that when a node receives a piece of information about the network, it randomly chooses to either keep it or to discard the information. To make this work, we must address (1) how to quantify the probability of discarding the information with respect to the information amount, the message size, and the density of the nodes; (2) how to retrieve the information from this sensor proximity, and <ref type="bibr" target="#b3">(3)</ref> what are the trade-offs between the memory utilization and broadcasting amount.</p><p>In order to address the information storage question, consider the proximity area S covered by a group of sensors. All local (environmental) information about S is the same for all these sensors. To use Algorithm 3, at least one of the sensors in S must store information about the goals. Let λ•S be the number of sensors in the area where λ is the density of the sensor distribution and S is the area of the field in question. Suppose each sensor has memory m. Then mλS is the total memory across all sensors. Let the amount of information to be recorded be mi where mi is the size of information i. If mλS ≥ mi, then it is possible that in the proximity area S, all the required information can be found locally using Algorithm 3. To achieve this information distribution when the amount of information is too large for a node's memory (that is, m &lt; mi), we can use a random, independent and distributed method to store the information on each sensor. Each sensor node randomly keeps a piece of information with probability p = m m i . When it receives a piece of information, the probability that the information can be found in this area is 1 -(1 -p) λS (see Figure <ref type="figure" target="#fig_4">13</ref>). Currently, we are also exploring some other approaches to cooperative caching data among proximity sensors.</p><p>Algorithm 4 summarizes the protocol for locating a piece of information in a sensor network. If the information cannot be found in the proximity area S, the sensor must try to retrieve information beyond the area in the sensor network. Intuitively, the request for information is broadcast to all the sensors in the area S. The sensors who have the information reply to the request. If there is no reply in the transmission range, the request must be broadcast again to a larger area, by making larger and larger concentric communication bands. More specifically, the user sends out the information request; the sensors in the broadcast range hear the request and reply if they have the information. Otherwise no sensor replies to the request. After some period of silence with no reply (∆, the transmission time for the request and reply message), the user's requesting node sends out an information request for two hops. Each node receiving this message will broadcast the request out. If the information is found, it is sent back to the requesting node. Otherwise after some time of silence time with no reply (2∆ here), the requesting node sends out an information request for three hops, and so on, until finally the information gets back to the requesting node. The probablity to keep information The probability to find the information in the proximity <ref type="bibr">Figure 13:</ref> This figure shows the probability (Y-axis) that a piece of information can be found in S, some neighborhood of a sensor. The X-axis is the probability that the sensor keeps a piece of information. We plot for various numbers of sensors in the area from λS = 2 to λS = 10 where λS is the number of sensors in that area. As the number of the sensors increases, the probability to find some information in that area is close to 1 even though the probability that a sensor keeps the information is small.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSION</head><p>We have discussed self-organizing sensor networks that can react to their environment and adapt to changes. We have described a novel application: using the sensor network to guide the movement of a user (human or robot, equipped with a sensor that can talk to the network) across the area of the network along a safest path. Safety is measured as the distance to the sensors that detect danger. We described several protocols for solving this problem. Our protocols implement a distributed repository of information that can be stored and retrieved efficiently when needed. We have used ideas from robotics to provide a correct solution to the navigation guiding task. We have implemented these protocols on a network of 50 Mote sensors. The key metric used in our experimental evaluations is the time it takes the network to adapt to a new situation (detecting a moving vehicle, detecting a new obstacle, adding a new sensor in the network, removing a sensor from the network, etc.). Our experimental work has taught us a number of lessons about some typical assumptions for designing protocols and have pointed out some important new directions of research.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: The left figure shows a typical setup for the navigation guiding task. The solid black circles correspond to sensors whose sensed value is "danger". The white circles correspond to sensors that do not sense danger. The dashed line shows the guiding path across the area covered by the sensor network. Note that the path travels from sensor to sensor and preserves a maximal distance from the danger areas, while progressing to the exit area. The right picture shows some Mote sensors used for our experiments. The three sensors placed in the upright position denote 2 obstacles (that is, danger areas) and one goal.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Algorithm 2</head><label>2</label><figDesc>The safest path to goal computation protocol. 1: Let G be a goal sensor 2: G broadcasts msg = (G id , my id (G), hops = 0, potential = 0) 3: for all sensors si do 4:Initially hopsg = ∞ and Pg = ∞ 5:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Figure2: The distribution of symmetric and asymmetric links in one experiment. The x-axis shows the node id and the y-axis the number of links. For each node we have three bars: the first shows the number of symmetric links, the second is the number of unidirectional outgoing links and the third the number of unidirectional incoming links.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>and all the points on segments s 2y-1 ur • • • s2y-1 are within R distance from s2y-1, and |s 2y-1 ur • • • s2y-1| + |s2y-1s2y| ≥ R/2 ( The argument is as follows. Draw a circle with radius R centered at s2y-1. If the circle intersects segments s2y-2ue • • • u f s2y-1, let the last intersection point be ty. We have |s2y-2ty| + |tys2y-1| + |s2y-1s2y| ≥ |s2y-2s2y-1| + |s2y-1s2y| ≥ R and |tys2y-1| = R. There must be a point s 2y-1 on segments tyua</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: This figure shows the comparison between the measured real distance and the hops counted using our algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Optimal/Experimental average/Experimental worst)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: This figure shows the potential integrations in 54 experiments with eight different network topologies. The solid, dashed, and dotted lines are the potential integrations on optimal path, average over all computed paths, and the worst computed respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 7 :</head><label>7</label><figDesc>Figure7: Transmission count distribution. The nodes on x-axis are sorted according to the Manhattan distance to (1,1), while the y-axis represents the number of packets (send/receive) for that node.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Transmission/reception of packets by individual nodes over time. The bottom part signifies the propagation of the information from the two obstacles (1 and 49) in the first period of the experiment when only the obstacles were turned on. The top part is the goal information propagation in the second half of the experiment when only the goal was turned on..</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Measured communication graph of the experimental 7x7 grid network.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: The obstacle and goal propagation time distribution as a function of the sensor node id.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Transmission count distribution.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: Transmission/reception of packets by individual nodes over time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>The data that summarizes timing measurements for several experiments with a sensor network consisting of Mote sensors. All network topologies are summarized as geometric icons and all measurements are in seconds.</figDesc><table><row><cell>Exp.</cell><cell>danger</cell><cell>Shortest goal</cell><cell>safest</cell><cell>Exp.</cell><cell>danger</cell><cell cols="2">Shortest</cell><cell>goal</cell><cell>safest</cell><cell>Exp.</cell><cell>danger</cell><cell cols="2">Shortest</cell><cell>goal</cell><cell>safest</cell></row><row><cell>Config.</cell><cell>prop.</cell><cell>distance prop.</cell><cell>path</cell><cell>Config.</cell><cell>prop.</cell><cell>distance</cell><cell cols="2">prop.</cell><cell>path</cell><cell>Config.</cell><cell>prop.</cell><cell>distance</cell><cell cols="2">prop.</cell><cell>path</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>¢ ¢ ¢</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>£ £ £</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">¤ ¤ ¤</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">¥ ¥ ¥</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>¢ ¢ ¢</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>£ £ £</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">¤ ¤ ¤</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">¥ ¥ ¥</cell><cell></cell><cell></cell></row><row><cell>¡ ¡</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>¡ ¡</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="2">0.23 1.13 0.17</cell><cell>9.23</cell><cell></cell><cell cols="5">1.23 22.33 2.27 19.27</cell><cell></cell><cell>4.20</cell><cell>9.10</cell><cell></cell><cell>1.37 22.63</cell></row><row><cell>¦ ¦ ¦</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>§  §  §</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>¦ ¦ ¦</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>§  §  §</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="2">0.20 2.17 0.13</cell><cell>4.23</cell><cell></cell><cell cols="4">5.20 20.30 1.17</cell><cell>9.40</cell><cell></cell><cell cols="4">1.20 20.23 2.13</cell><cell>3.13</cell></row><row><cell></cell><cell cols="3">1.16 3.13 2.13 10.03</cell><cell></cell><cell cols="4">1.30 16.23 1.10</cell><cell>2.17</cell><cell></cell><cell>0.17</cell><cell>6.17</cell><cell></cell><cell>0.04 19.37</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>! ! !</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>! ! !</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>" " "</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell># # #</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>" " "</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell># # #</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="2">0.10 3.10 0.10</cell><cell>1.07</cell><cell></cell><cell cols="4">9.37 17.37 0.33</cell><cell>8.43</cell><cell></cell><cell>0.20</cell><cell>7.17</cell><cell></cell><cell>1.13</cell><cell>3.1</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>' '</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>' '</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>$ $ $</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>% %</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>$ $ $</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>% %</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>( (</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>( ( (</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="2">0.23 1.33 0.13</cell><cell>1.07</cell><cell></cell><cell cols="5">7.27 10.13 0.04 33.80</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>The data of the response time for several experiments with a sensor network consisting of Mote sensors. All network topologies are summarized as geometric icons and all measurements are in seconds.</figDesc><table><row><cell>Exp.</cell><cell>Exp.</cell><cell>Response</cell><cell>Exp.</cell><cell>Exp.</cell><cell>Response</cell><cell>Exp.</cell><cell>Exp.</cell><cell>Response</cell></row><row><cell>No.</cell><cell>Config.</cell><cell>Time</cell><cell>No.</cell><cell>Config.</cell><cell>Time</cell><cell>No.</cell><cell>Config.</cell><cell>Time</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>We have implemented the protocols in Algorithms 1, 2, and 3 on the second generation Motes MOT300. In this</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>&amp; &amp; &amp; &amp; &amp; &amp;</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We are very grateful to Deborah Estrin for introducing us to the Motes hardware. We thank the TinyOS group for providing great support. We are also grateful to Ron Peterson for his invaluable help and discussions. We thank all the reviewers for their helpful comments and Professor Suresh Singh for shepherding this paper.</p><p>Support for this work has been provided in part by the Institute for Security Technology Studies (ISTS), NSF award 0225446, I1S-9912193, ONR award N00014-01-1-0675, and DARPA TASK program award F30602-00-2-0585.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">REFERENCES Algorithm 4 Sensor information query algorithm 1: if I am the query sensor s then 2: depth1 = depth2 = 1 3: while true do 4: Broadcast (s, query, depth1, depth2) 5: Wait for time depth1 * ∆ 6: if some reply arrives then 7: stop 8: else 9: depth1 + +, depth2 + + 10: if I am not the query sensor then 11: receive(s, query, depth1, depth2) 12: if I have already received a message with prefix (s, query, depth1, * )</title>
		<imprint/>
	</monogr>
	<note>then 13: discard the message 14: if I have the information to query then 15: send the information to s, stop 16: if depth2 -1 == 0 then 17: stop 18: else 19: broadcast(s, query, depth1, depth2 -1</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Three power-aware routing algorithms for sensor networks</title>
		<author>
			<persName><forename type="first">Javed</forename><surname>Aslam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qun</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniela</forename><surname>Rus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Wireless Communications and Mobile Computing</title>
		<imprint>
			<date type="published" when="2003-03">March 2003</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="187" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Efficient exploration without localization</title>
		<author>
			<persName><forename type="first">M</forename><surname>Batalin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Sukhatme</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICRA</title>
		<meeting><address><addrLine>Taipei</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-05">May 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">GPS-free positioning in mobile ad-hoc networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Srdan Capkun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Hamdi</surname></persName>
		</author>
		<author>
			<persName><surname>Hubaux</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cluster Computing</title>
		<imprint>
			<date type="published" when="2002-04">April 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Energy conserving routing in wireless ad-hoc networks</title>
		<author>
			<persName><forename type="first">Jae-Hwan</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leandros</forename><surname>Tassiulas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE INFOCOM</title>
		<meeting>IEEE INFOCOM<address><addrLine>Tel Aviv, Israel</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-03">Mar. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Performance comparison of two on-demand routing protocols for ad hoc networks</title>
		<author>
			<persName><forename type="first">Samir</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charles</forename><surname>Perkins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elizabeth</forename><surname>Royer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INFOCOM</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Embedding the internet</title>
		<author>
			<persName><forename type="first">Deborah</forename><surname>Estrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ramesh</forename><surname>Govindan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Heidemann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of ACM</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="39" to="41" />
			<date type="published" when="2000-05">May 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Complex behavior at scale: An experimental study of low-power wireless sensor networks</title>
		<author>
			<persName><forename type="first">Deepak</forename><surname>Ganesan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bhaskar</forename><surname>Krishnamachari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alec</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Culler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Deborah</forename><surname>Estrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephen</forename><surname>Wicker</surname></persName>
		</author>
		<idno>02-0013</idno>
	</analytic>
	<monogr>
		<title level="m">UCLA Computer Science Tech</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The capacity of wireless networks</title>
		<author>
			<persName><forename type="first">Piyush</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">R</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory, IT</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="388" to="404" />
			<date type="published" when="2000-03">March 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A new routing protocol for the reconfigurable wireless network</title>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">J</forename><surname>Haas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICUPC&apos;97</title>
		<meeting>ICUPC&apos;97<address><addrLine>San Diego</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-10">Oct. 1997</date>
			<biblScope unit="page" from="562" to="566" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">System architecture directions for network sensors</title>
		<author>
			<persName><forename type="first">Jason</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Szewczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alec</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seth</forename><surname>Hollar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Culler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kristofer</forename><surname>Pister</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Directed diffusion: A scalable and robust communication paradigm for sensor networks</title>
		<author>
			<persName><forename type="first">Chalermek</forename><surname>Intanagonwiwat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ramesh</forename><surname>Govindan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Deborah</forename><surname>Estrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Mobicom</title>
		<meeting>of Mobicom<address><addrLine>Boston</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-08">August 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Dynamic source routing in ad-hoc wireless networks</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Maltz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mobile Computing</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Imielinski</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Korth</surname></persName>
		</editor>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="153" to="181" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Location-aided routing (LAR) in mobile ad hoc networks</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">B</forename><surname>Ko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">H</forename><surname>Vaidya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Mobicom</title>
		<meeting>ACM Mobicom</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="66" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Planning and control via potential fuctions</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Koditschek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Robotics Review</title>
		<editor>
			<persName><forename type="first">Khatib</forename><surname>Lozano-Perez</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">I</biblScope>
			<biblScope unit="page" from="349" to="367" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">J.-C</forename><surname>Latombe</surname></persName>
		</author>
		<title level="m">Robot Motion Planning</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Kluwer</publisher>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Real-time robot motion planning using rasterizing computer graphics hardware</title>
		<author>
			<persName><forename type="first">J</forename><surname>Lengyel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Reichert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Donald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Greenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGGRAPH</title>
		<meeting>SIGGRAPH<address><addrLine>Dallas, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="327" to="336" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Exposure in wireless ad hoc sensor networks</title>
		<author>
			<persName><forename type="first">Seapahn</forename><surname>Meguerdichian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Farinaz</forename><surname>Koushanfar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gang</forename><surname>Qu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Miodrag</forename><surname>Potkonjak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MOBICOM</title>
		<meeting><address><addrLine>Rome</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-07">July 2001</date>
			<biblScope unit="page" from="139" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">An efficient routing protocol for wireless networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Murthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Garcia-Luna-Aceves</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">MANET</title>
		<imprint>
			<biblScope unit="issue">1,2</biblScope>
			<biblScope unit="page" from="183" to="197" />
			<date type="published" when="1996-10">October 1996</date>
			<publisher>ACM/Baltzer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Organizing a global coordinate system from local information on an ad hoc sensor network</title>
		<author>
			<persName><forename type="first">Radhika</forename><surname>Nagpal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Howard</forename><surname>Shrobe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Bachrach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IPSN LNCS 2634</title>
		<meeting><address><addrLine>Palo Alto</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-04">April 2003</date>
			<biblScope unit="page" from="333" to="348" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Ad hoc positioning system (APS) using AOA</title>
		<author>
			<persName><forename type="first">Dragos</forename><surname>Niculescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">R</forename><surname>Badrinath</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INFOCOM</title>
		<meeting><address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-04">April 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A review of current routing protocols for ad hoc mobile wireless networks</title>
		<author>
			<persName><forename type="first">Elizabeth</forename><surname>Royer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C-K</forename><surname>Toh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Personal Communication</title>
		<imprint>
			<date type="published" when="1999-04">April 1999</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="46" to="55" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Dynamic fine-grained localization in ad-hoc networks of sensors</title>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Savvides</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chih-Chieh</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mani</forename><forename type="middle">B</forename><surname>Strivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mobicom</title>
		<meeting><address><addrLine>Rome</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-07">July 2001</date>
			<biblScope unit="page" from="166" to="179" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">On the interdependence of routing and data compression in multi-hop sensor networks</title>
		<author>
			<persName><forename type="first">Anna</forename><surname>Scaglione</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sergio</forename><surname>Servetto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Mobicom</title>
		<meeting><address><addrLine>Atlanta, GA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Power-aware routing in mobile ad-hoc networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Raghavendra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mobicom</title>
		<meeting><address><addrLine>Dallas, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-10">Oct. 1998</date>
			<biblScope unit="page" from="181" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Connectivity based location estimation scheme for wireless ad hoc networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Sundaram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ramanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Globecom</title>
		<meeting>Globecom</meeting>
		<imprint>
			<date type="published" when="2002-11">Nov. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Optimal transmission ranges for randomly distributed packet radio terminals</title>
		<author>
			<persName><forename type="first">H</forename><surname>Takagi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Kleinrock</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Communications, COM</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1984-03">March 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">PSFQ: A reliable transport protocol for wireless sensor networks</title>
		<author>
			<persName><forename type="first">Chieh-Yih</forename><surname>Wan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Campbell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lakshman</forename><surname>Krishnamurthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In the 1st ACM International Workshop on WSNA</title>
		<imprint>
			<date type="published" when="2002-09">September 2002</date>
			<pubPlace>Atlanta, GA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A two-tier data dissemination model for large-scale wireless sensor networks</title>
		<author>
			<persName><forename type="first">Fan</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haiyun</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jerry</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Songwu</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lixia</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Mobicom</title>
		<meeting><address><addrLine>Atlanta, GA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
