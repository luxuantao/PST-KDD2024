<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Computing similarity between RNA strings 1 by</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="1996-07-30">30 July 1996</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">V</forename><surname>Bafna</surname></persName>
							<email>bafna@dimacs.rutgers.edu</email>
						</author>
						<author>
							<persName><forename type="first">S</forename><surname>Muthukrishnan</surname></persName>
						</author>
						<author>
							<persName><forename type="first">R</forename><surname>Ravi</surname></persName>
							<email>ravi@andrew.cmu.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">DIMACS Center</orgName>
								<address>
									<postBox>P.O. Box 1179</postBox>
									<postCode>08855</postCode>
									<settlement>Piscataway</settlement>
									<region>NJ</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Dept. of Computer Science</orgName>
								<orgName type="institution">Univ. of Warwick Coventry</orgName>
								<address>
									<postCode>CV47AL</postCode>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Graduate School of Industrial Administration Carnegie Mellon University Pittsburgh</orgName>
								<address>
									<postCode>15217</postCode>
									<region>PA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Computing similarity between RNA strings 1 by</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="1996-07-30">30 July 1996</date>
						</imprint>
					</monogr>
					<idno type="MD5">05E64B75DF6F04848B4A4062F31EE97C</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:29+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Ribonucleic acid (RNA) strings are strings over the four-letter alphabet fA; C; G; Ug with a secondary structure of base-pairing between A 0 U and C 0 G pairs in the string. Edges are drawn between two bases that are paired in the secondary structure and these edges have traditionally been assumed to be noncrossing. The noncrossing base-pairing naturally leads to a tree-like representation of the secondary structure of RNA strings.</p><p>In this paper, we address several notions of similarity between two RNA strings that take into account both the primary sequence and secondary base-pairing structure of the strings. We present ecient algorithms for exact matching and approximate matching between two RNA strings. We dene a notion of alignment between two RNA strings and devise algorithms based on dynamic programming. We then present a method for optimally aligning a given RNA sequence with unknown secondary structure to one with known sequence and structure, thus attacking the structure prediction problem in the case when the structure of a closely related sequence is known. The techniques employed to prove our results include reductions to well-known string matching problems, allowing wild cards and ranges, and speeding up dynamic programming by using the tree structures implicit in the secondary structure of RNA strings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Problem</head><p>Running time String Symmetric Exact Matching (SEM) O(n + m) Matching Containment Exact Matching (CEM) O(n polylog m) Symmetric K-mismatches problem (SKM) O(nm 2=3 polylog m) Containment K-mismatches problem (CKM) O(n p m polylog m) Alignment Global similarity or RNA edit distance O(n 2 m 2 ) Longest Common RNA Substring (RLCS) O(n 2 m 2 ) Shortest Common RNA Superstring (RSCS) O(n 2 m 2 (n 2 + m 2 )) Structure Inferring structure through alignment O(n 2 m 2 + nm 3 )</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A variety of string matching problems are motivated by the analysis of DNA or protein sequences. An example is the problem of computing the similarity between two sequences such as the edit distance to transform one into another using insertions, deletions and substitutions of characters <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b20">21]</ref>. When comparing RNA sequences, usually much more is known about the secondary structure of base-pairing between nucleotides in the sequence. A bonded pair of bases is usually represented as an edge between the two complementary bases involved in the bond. Traditional models of RNA secondary structure <ref type="bibr" target="#b26">[27]</ref> assume that every base participates in at most one such pair, and that the edges representing the paired bases are noncrossing along the length of the string. The secondary structure can be represented by a nesting tree whose nodes correspond to edges of the pairing and parenthood in the tree represents the immediate enclosure relation between the two edges (see g. <ref type="bibr" target="#b0">1)</ref>.</p><p>Figure <ref type="figure">1</ref>: Secondary structure of an RNA sequence Consequently, much of the work on comparing the secondary structures of two RNA strings have been modeled as problems of comparing two trees <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b25">26]</ref>. In this paper, we study several problems in computing the similarity between two RNA strings that take into consideration both the primary sequence and secondary base-pairing information provided with the strings. We also investigate the problem of inferring the secondary structure of an RNA sequence when a closely related RNA string is given. We reserve the term RNA string when the sequence as well as the structure is given and use RNA sequence to denote only the primary sequence. Standard notions of similarity between two sequences have been formulated as problems of exact and approximate string matching, nding a longest common subsequence (LCS) or a shortest common supersequence (SCS) of the sequences, and computing optimal alignments under general scoring functions. We formulate the corresponding versions of these problems between two RNA strings and present ecient algorithms for computing them. In the context of RNA strings, we would like to match symbols as well as edges in the two strings. An edge in one of the strings is said to be matched if the two symbols in the other string that are aligned to its endpoints are connected by an edge in the second string. Two variants of exact and approximate matching problems arise, depending on whether edges in both the pattern and text strings or only the edges in the pattern are required to be matched: we call these variants the symmetric and containment variants respectively. We observe that the actionat-a-distance eect of aligning edges signicantly increases the complexity of RNA string similarity algorithms. Furthermore, problems like LCS and SCS that are computationally identical for sequences turn out to be quite dierent in the context of RNA strings.</p><p>Finally, we solve the problem of inferring the secondary structure of an RNA sequence when a closely related RNA string is given by aligning the sequence with the given RNA string. The alignment not only maximizes the common characters as in traditional sequence alignment but also favors the alignment of the endpoints of an edge in the related string with complementary base-pairs in the input string.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Results</head><p>Table <ref type="table" target="#tab_0">1</ref> describes the list of problems addressed in this paper and the time complexity of the algorithms we propose for solving them. In the table, n and m represent the sizes of the two input strings. String matching. The rst four entries of the table are analogous to exact and approximate matching problems in standard strings. In such problems, a pattern RNA string (of length m) and a typically longer text RNA string (of length n) are given, and the task is to compute the positions in the text where the pattern occurs with at most k ( 0) mismatches. We obtain our bounds by reducing these RNA string matching problems to well-known string matching problems allowing wild cards and ranges.</p><p>While character mismatches clearly account as mismatches, the notion of an edge mismatch can be dened in many ways. Consider the alignment of the pattern beginning at position i in the text. We shall insist that an edge in the pattern string must always be matched by an edge in the text or it creates an edge mismatch. An edge in the text string which has exactly one endpoint within the range formed by the projection of the pattern in the text cannot be considered an edge mismatch, since the other endpoint is out of the span of the pattern in the text. However, two variants arise from the consideration of whether an edge in the text within the span of the pattern must be deemed to match with an edge in the pattern. The Symmetric variant counts a text edge within the span of the pattern that is not matched as a mismatch, while the Containment version does not count this as a mismatch. (Formal denition of these problems are in Section 2). Alignment. The global similarity between two RNA strings is dened as a weighted sum of sequence similarity and structural similarity. Our algorithm for computing global similarity can be used to compute an edit distance between two RNA strings that is a weighted sum of sequence edit cost and edge-mismatch costs.</p><p>The next two entries in Table <ref type="table" target="#tab_0">1</ref> are analogous to the LCS and SCS problems.</p><p>Informally, an RNA-subsequence of an RNA-string is a subsequence of the string and has an edge only if the corresponding base-pairs have an edge in the RNA-string. A longest common RNA subsequence (RLCS) of two RNA strings is an RNA-subsequence of the two given strings with the maximum number of characters plus edges. This denition, as well as our algorithm, can be extended to maximize an arbitrary weighted sum of the number of characters and the number of edges. The shortest common RNA supersequence (RSCS) is an RNA string of which both the given strings are RNA subsequences such that the total number of characters plus edges in the supersequence is minimum. Again, the extension to weighting number of edges and number of characters dierently is straightforward. Somewhat surprisingly, RLCS and RSCS seem to be computationally very dierent problems. We can reduce RLCS to computing an optimal alignment by dening the scoring function appropriately. On the other hand our algorithm for computing the RSCS has running time that is two orders of magnitude more. Structure. The problem of inferring structure through alignment, takes as input an RNA sequence and an RNA string and computes an alignment of the sequence with the string to maximize a weighted sum of the sequence similarity and the number of edges in the RNA string whose endpoints are aligned with complementary base-pairs in the RNA sequence. This alignment can be used as a measure of commonality between the RNA string and the unknown RNA sequence. As more and more RNA secondary structures become available, our formulation of the prediction problem appears increasingly relevant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>{ 4 {</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related work</head><p>Comparison methods. First we review work on comparison methods developed to estimate distances between RNA secondary structures. Since secondary structures can be represented as trees, there are several papers <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b25">26]</ref> addressing comparisons of trees. Tree edits are discussed and ecient algorithms are derived in <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b25">26]</ref> while a new notion of tree alignment is proposed and algorithms developed in <ref type="bibr" target="#b6">[7]</ref>. Even though these comparison methods compute distances only between secondary structures, the worst-case running time of estimating this distance (tree edits or alignments) is quadric; the running time of our alignment algorithm that takes in to account both sequence and structure compares favorably with this estimate.</p><p>Tree based comparison methods do not appear to generalize when comparing both the secondary structure as well as the underlying sequence of two RNA strings. The diculty seems to be in extending the tree model for RNA strings to include characters. However, our algorithms use a combination of sequence edit computation and a tree-based computation. Prediction methods. Prediction of RNA secondary structure of a single RNA molecule from its sequence has been widely studied in the past <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b28">29]</ref>. Most of this work use adaptations of dynamic programming to solve variants of the problem; For instance, one could take into account dierent energy assignments for the dierent secondary structure primitives such as stacked pairs, hairpins, multiloops, interior loops and bulges <ref type="foot" target="#foot_0">1</ref> , and compute a structure that minimizes the total energy. Sanko <ref type="bibr" target="#b16">[17]</ref> considers prediction of secondary structure common to two RNA strings also taking into account alignment of the sequences. The dierence from our approach is that he does not assume that the secondary structure of either of the sequences is given, but instead computes an alignment and a most likely folding that is common to both sequences. Sanko's algorithm more carefully models the energy functions for dierent kinds of loops in the structure (such as stacked pairs, multiloops etc.); the running time of his algorithm for two sequences is two orders of magnitude higher. In contrast to the above work, our version of the prediction problem assumes that more information is available. In particular, we assume that we are given both the sequence and the secondary structure of an RNA string that is closely related to one whose structure is to be predicted.</p><p>Another related line of work is <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b15">16]</ref> that uses stochastic context-free grammars (with probabilities attached to production rules) to model a family of related RNA strings. These papers also describe procedures for building such grammars given a set of unaligned RNA sequences with no secondary structure known for any member in the set. In this way, this problem is more closely related to that considered by Sanko in <ref type="bibr" target="#b16">[17]</ref> and described in the previous paragraph.</p><p>Other related work appears in <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b7">8]</ref>. The approach in the rst paper <ref type="bibr" target="#b10">[11]</ref> addresses a single RNA sequence. Multiple secondary structures are computed from the given sequence and a consensus structure is output. The second article <ref type="bibr" target="#b17">[18]</ref> considers the problem of aligning several RNA strings, each with a given secondary structure. The paper proposes a syntactic parenthetical representation of the RNA secondary structure that is interleaved with the primary RNA sequence. The paper then uses conventional multiple-sequence alignment methods on these modied sequences to infer a similar substring. However, the author does not rigorously specify what function of these modied sequences is being optimized to derive the nal alignment and common substring; Our algorithms for exact and approximate matching of two RNA strings supercially resembles this method in that an edge between two positions in a string is encoded by the oset to the other endpoint (rather than parentheses as in <ref type="bibr" target="#b17">[18]</ref>), and traditional string matching techniques are then employed. The third article <ref type="bibr" target="#b18">[19]</ref> uses edit distance data between several trees representing RNA secondary structures to build a phylogenetic tree illustrating the relationship between these structures. Finally, <ref type="bibr" target="#b7">[8]</ref> considers query primitives for data that is tree-structured that are less restricted than exact tree-pattern matching and analyzes the complexity of implementing such primitives. Thus, this work is more closely related to work on distances between trees.</p><p>In the next section, we describe our results on RNA string matching; We then turn to alignment of RNA strings and its variants in Section 3. In Section 4, we describe our algorithm for structure prediction given a related RNA string. We conclude with some open questions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RNA string matching</head><p>In this section, we explore string matching problems in the context of RNA strings. We formally dene the variants of string matching problems that arise when we deal with RNA strings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Problem denitions</head><p>The rst problem we consider is the basic problem of exact matching. Symmetric Exact Matching (SEM). Given a text RNA string t and a pattern RNA string p of length n and m respectively, determine all those positions where p occurs in t, that is, all locations i in t where,</p><formula xml:id="formula_0">1. Strings match, that is, t[i] 1 1 1 t[i + m 0 1] = p[1] 1 1 1 p[m]</formula><p>, and 2. Secondary structures are identical, that is, for any bonding pair (i + j 0 1; i + k 0 1) in t, 0 j &lt; k m 01, (j; k) is a bonding pair in p as well and vice-versa. Note that the existence of some bonding pair (i + j; i + k) in t, where 0 j &lt; k and k &gt; m 0 1 does not aect p occurring at i in t. Similarly for bonding pairs (i + j; i + k) in t, where 0 k m 0 1 and j &lt; 0.</p><p>Containment Exact Matching (CEM). It is dened just as SEM except that the secondary structure of p and that of the substring of t of length m beginning at i need not be identical. It is only required that the secondary structure of p be contained in the latter. Formally, p occurs in t at i if strings match as before and 2. For any bonding pair (j; k) in p, 1 j &lt; k m, (i + j 0 1; i + k 0 1) in t is a bonding pair as well, but not necessarily vice-versa. The other basic problem we consider is the k-mismatches problem for the RNA strings dened as below. Symmetric K-mismatches problem (SKM). Given a text RNA string t and a pattern RNA string p of length n and m respectively, and a parameter K, determine all those positions where p occurs in t with at most K mismatches. We say that p occurs at i in t with at most K mismatches if there exist integers K 1 and K 2 such that K 1 + K 2 K and in addition, 1. There are K 1 string mismatches. That is, t</p><formula xml:id="formula_1">[i] 1 1 1t[i + m 0 1] and p[1] 1 1 1 p[m] dier in K 1 positions. 2.</formula><p>There are K 2 secondary structures mismatches. That is, there are K 2 pairs of text and pattern positions i + j 0 1; i + k 0 1, 0 j &lt; k m 0 1 and j; k where precisely one of (i + j 0 1; i + k 0 1) or (j; k) is a bonding pair in the corresponding string. Note again that the existence of some bonding pair (i + j; i + k) in t, where 0 j &lt; k and k &gt; m 0 1 does not aect the number of mismatches between the secondary structure of p and that of t[i] 1 1 1t[i + m 0 1]. Similarly for bonding pairs (i + j; i + k) in t, where 0 k m 0 1 and j &lt; 0.</p><p>Containment K-mismatches problem (CKM). The CKM problem is dened the same way as SKM except for the mismatches in the secondary structure. Here we only consider the number of bonding pairs in p which mismatch, that is, those that do not fall on bonding pairs in t; the bonding pairs in t that do not fall on a bonding pair in p are not counted as mismatches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Exact Matching with RNA strings</head><p>In this section, we sketch our results for SEM and CEM problems. Proof: Our algorithm works as follows. First we perform standard string matching (using, say <ref type="bibr" target="#b8">[9]</ref>) to nd all locations where p does not occur in t since the strings mismatch. This takes O(n + m) time.</p><p>Next we look for mismatches in the secondary structure. We construct an instance of string matching with wild cards to solve this problem. Note that the RNA strings are strings drawn from fA; C; G; Ug; the strings we generate for string matching with wild cards will contain symbols from fA; C; G; Ug as well as integers. We generate a text string t 0 from t by replacing t[i] by the integer k 0 i if (i; k) or (k; i) is a bonding pair in t. Similarly, we generate p 0 from p by replacing each position i by k 0 i if (i; k) or (k; i) is a bonding pair in p, and by the wild card otherwise.</p><p>Every position i such that p occurs at i in t and p 0 occurs at i in t 0 corresponds to a position where the RNA-string p is contained in the RNA-string t. The algorithm takes time O(n polylog m) using the bound in <ref type="bibr" target="#b4">[5]</ref> for exact string matching with wildcards. Proof: We prove that a simple modication of the Knuth-Morris-Pratt algorithm <ref type="bibr" target="#b8">[9]</ref> suces to solve the SEM problem. Let the match operation between two strings as dened for the SEM problem be denoted by =. Lemma 2.3 The = relation is transitive, that is, if t</p><formula xml:id="formula_2">[i] 1 1 1 t[i + k 0 1] matches p[1] 1 1 1 p[k],</formula><p>and some prex p[1] 1 1 1 p[j], j &lt; k, matches the sux of t</p><formula xml:id="formula_3">[i] 1 1 1t[i + k 0 1], then the string p[1] 1 1 1 p[j], matches the sux of p[1] 1 1 1 p[k].</formula><p>Proof: Follows from the denition of the = relation.</p><p>2</p><p>Now we modify the comparisons in the KMP algorithm to perform SEM. Note that in standard KMP, comparing two locations is merely testing for character equality. The following subroutines for Compare(p[i],t[j]) for j i, and Compare(p[i],p[j]) for i j implement our = relation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Compare(p[i],t[j]) if p[i] 6 = t[j] return unequal if p[i] = t[j]</head><p>, (i 0 k; i) is a bonding pair in t, 0 k i but (j 0 k; j) is not a bonding pair in p then return unequal if p[i] = t[j], (j 0 k; j) is a bonding pair in p, 0 k i but (i 0 k; i) is not a bonding pair in t then return unequal else return equal end The Compare(p[i],p[j]) for i j operation is implemented the same way. That completes the description of the algorithm.</p><p>The proof of correctness relies on the valid implementation of the failure function in the KMP algorithm by the new Compare operations. However, this is straightforward to verify, given Lemma 2.3 and that in the preprocessing of the pattern in the algorithm using the = operation, the following is maintained: The largest prex of p[1] 1 1 1 p[i + 1] that matches its sux under = is the largest prex p</p><formula xml:id="formula_4">[1] 1 1 1 p[k] of p[1] 1 1 1 p[i] that matches p[i 0 k + 1] 1 1 1 p[i]</formula><p>and also answers Compare(p[i + 1],p[k + 1]) equal. It follows that the entire algorithm works in O(n + m) time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">2.3 K-mismatches with RNA strings</head><p>We now describe algorithms for RNA string matching with mismatches. Our algorithms use known results from generalized string matching.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>{ 8 {</head><p>String matching with mismatches: Given a pattern string p of length m and a text string t of length n, for each position i; 1 i n 0 m, nd the number of mismatches when p is positioned at i in t.</p><p>Theorem 2.4 <ref type="bibr" target="#b0">[1]</ref> The string matching problem with mismatches can be solved in O(n p mpolylogm) time.</p><p>String matching with sets of ranges: Given a pattern string p of length m and a text string t of length n where t contains symbols from an ordered alphabet 6 and each position of p matches (a xed number of) sets of ranges of the symbols from 6, for each position i; 1 i n 0 m, nd the number of mismatches when p is positioned at i in t. An example. Let p = ah[a 0 c] + [f 0 g] + [z]ic and t = ababcda. The second position in p from the left matches symbols a; b; c; f; g; z. Therefore, the number of mismatches between p and t at the leftmost position is 1 and that at the 5th position from the left is 3.</p><p>Theorem 2.5 <ref type="bibr" target="#b11">[12]</ref> The string matching problem with sets of ranges can be solved in O(nm Proof: As usual we solve the version of the problem in which for each text location we return the number of mismatches (in the string and the secondary structure) between p and t. The problem of counting character mismatches can be solved in O(n p m polylog m) time using Theorem 2.4. Next we compute the number of mismatches in the secondary structure. Recall the reduction in the proof of Theorem 2.1. We generate t 0 and p 0 (with wild cards) as described there. Observe that the number of mismatches of p 0 at a location i in t 0 is exactly twice the number of edge mismatches of p at i in t. Thus, our problem is reduced to solving the problem of counting the mismatches between p 0 and t 0 . This problem in turn can be solved in O(n p m polylog m) time as above. Finally, we can combine the number of mismatches in the two parts above in linear time and detect all locations in t where the total number of mismatches is at most K. Denition 3.1 The Global Alignment problem for RNA strings is dened as follows: Given RNA strings s and t, compute an alignment A (and the associated function gap) that maximizes P 1im 0 (s[i 0 gap[1; i]]; t[i 0 gap[2; i]]) + P 1i&lt;jm 0 (i 0 gap[1; i]; j 0 gap[1; j]; i 0 gap[2; i]; j 0 gap[2; j]) Theorem 3.2 Algorithm AlignRNA (g. 2) computes the score of an optimum global alignment for Two RNA strings in O(n 2 m 2 ) time.</p><p>The proof of correctness of the theorem follows from the observation that the last column in an alignment either participates in an edge match or not. If not, this column represents a character insertion, deletion or substitution. The algorithm chooses the one with maximum score among these four possible cases. Since we examine all pairs of intervals drawn from the two strings, the running time is as claimed. Standard techniques can be used to retrieve an alignment of maximum similarity using the same algorithm.</p><p>Note that edit-distance is the inverse problem of computing an alignment with a minimum number of insertions, deletions, mismatches and bonding pair mismatches. It follows that edit-distance can be computed in O(n 2 m 2 ) time.</p><p>Procedure AlignRNA begin for intervals (i 1 ; j 1 ), 1 i 1 &lt; j 1 m and (i 2 ; j 2 ), 1 i 2 &lt; j 2 n (* Assume that the intervals are examined in lexicographically increasing order of widths *)</p><p>Align[i 1 ; j 1 ; i 2 ; j 2 ] = max 8 &gt; &lt; &gt; :</p><p>Align[i 1 ; j 1 0 1; i 2 ; j 2 ] + (s[j 1 ]; `00 ) Align[i 1 ; j 1 ; i 2 ; j 2 0 1] + (`0 0 ; t[j 2 ]) Align[i 1 ; j 1 0 1; i 2 ;</p><formula xml:id="formula_5">j 2 0 1] + (s[j 1 ]; t[j 2 ]) if there exist i 1 k 1 &lt; j 1 ; i 2 k 2 &lt; j 2 s.t. (k 1 ; j 1 ) 2 S 1 ; (k 2 ; j 2 ) 2 S 2 Align[i 1 ; j 1 ; i 2 ; j 2 ] = max 8 &gt; &gt; &gt; &lt; &gt; &gt; &gt; : Align[i 1 ; j 1 ; i 2 ; j 2 ]; Align[i 1 ; k 1 0 1; i 2 ; k 2 0 1]+ Align[k 1 + 1; j 1 0 1; k 2 + 1; j 2 0 1] +(k 1 ; j 1 ; k 2 ; j 2 ) + (s[k 1 ]; t[k 2 ]) + (s[j 1 ]; t[j 2 ])</formula><p>end Figure <ref type="figure">2</ref>: Computing optimal alignment for RNA strings</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">LCS and SCS of RNA strings</head><p>For sequences, LCS and SCS can easily be deduced from an alignment in which no mismatches occur. The LCS is simply the sequence formed by concatenating matched non-space symbols from such an alignment, while the SCS is the concatenation of all non-space symbols that appear in the alignment. It is also easy to see that for strings of length m and n, if l is the length of the longest common subsequence and s is the length of the shortest common supersequence, then l = m + n 0 s. Therefore for sequences, the solutions to both problems are identical. The notion of a subsequence and supersequence can be extended naturally to RNA strings as follows: Denition 3.3 Let s and t be two RNA strings with structure S 1 and S 2 respectively. s is an RNA-supersequence of t if there exists an alignment A of s and t, such that for all i, A[1; i] = s[i], for all j, either A[2; j] = `0 `or A[1; j] = A[2; j] (i.e., s is a supersequence of t), and for all i; j (i 0 gap[2; i]; j 0 gap[2; j]) 2 S 2 implies (i; j) 2 S 1 .</p><p>s is an RNA-subsequence of t if t is an RNA-supersequence of s. <ref type="bibr">Denition 3.4</ref> Let s be an RNA string with structure S. Dene the 'length' of s, denoted by len(s), to be jsj + jSj.</p><p>From this, the denition of a shortest common RNA-supersequence (RSCS) and a longest common RNA-subsequence (RLCS) of two or more RNA sequences follows.</p><p>Theorem 3.5 Let s; t be two RNA strings over P with structure S 1 and S 2 respectively. RLCS of s; t can be computed in O(n 2 m 2 ) time.</p><p>Proof: For elements u; v 2 P [f`0 0 g, dene</p><formula xml:id="formula_6">(u; v) = 8 &gt; &lt; &gt; : 1 u = v 0 u = `00 or v = `00</formula><p>01 otherwise and</p><formula xml:id="formula_7">(i; j; k; l) = 8 &gt; &gt; &gt; &gt; &gt; &gt; &lt; &gt; &gt; &gt; &gt; &gt; &gt; : 1 s[i] = t[k] ^s[j] = t[l] ^(i; j) 2 S 1 ^(k; l) 2 S 2 0 s[i] = `00 _s[j] = `00 _ t[k] = `00 _t[l] = `00 01 otherwise</formula><p>Algorithm AlignRNA with these denitions of and computes the length of RLCS of two strings. The claim on running time follows from Theorem 3.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>Note that the alignment obtained in the LCS computation does not always yield a common RNA supersequence. In fact, it is possible that for the alignment obtained, there exist indices 1 i &lt; j &lt; k &lt; l m + n such that (i 0 gap[1; i]; k 0 gap[1; k]) 2 S 1 { 12 { and (j 0 gap[2; j]; l 0 gap[2; l]) 2 S 2 . Clearly a common RNA supersequence must have both base-pairs but they cannot be interleaved because of our assumption of an unknotted structure.</p><p>Our algorithm for computing RSCS must therefore enforce this condition. For an RNAstring s with structure S, dene a spanning-interval [i; j] as a substring s[i : : : j], such that no pair (k; l) 2 S satises i k j &lt; l or k &lt; i l j. We compute the RSCS for each pair of spanning interval [i 1 ; j 1 ] and [i 2 ; j 2 ] in the two strings. If j 1 or j 2 do not form bonds with another base-pair, then RSCS[i 1 ; j 1 ; i 2 ; j 2 ] = min 8 &gt; &lt; &gt; : RSCS[i 1 ; j 1 0 1; i 2 ; j 2 ] + 1 RSCS[i 1 ; j 1 ; i 2 ; j 2 0 1] + 1 RSCS[i 1 ; j 1 0 1; i 2 ; j 2 0 1] + (s[j 1 ]; t[j 2 ]) where is dened as in RLCS. Otherwise, let (k 1 ; j 1 ) 2 S 1 and (k 2 ; j 2 ) 2 S 2 . Then we have dierent cases depending whether (k 1 ; j 1 ) and (k 2 ; j 2 ) match or not in the RSCS of the two strings. (k 1 ; j 1 ) and (k 2 ; j 2 ) are matched only if s[k 1 ] = t[k 2 ], and s[j 1 ] = t[j 2 ]. In that case, RSCS[i 1 ; j 1 ; i 2 ; j 2 ] = RSCS[i 1 ; k 1 0 1; i 2 ; k 2 0 1] + RSCS[k 2 + 1; j 1 0 1; k 2 + 1; j 2 0 1] + 3</p><p>If (k 1 ; j 1 ) and (k 2 ; j 2 ) are not matched to each other then either (k 1 ; j 1 ) is aligned against an interval [x; y] in [i 2 ; j 2 ] or (k 2 ; j 2 ) is aligned against an interval (x; y) in [i 1 ; j 1 ]. In both cases, for the edges of the superstring to be noncrossing, the interval [x; y] must be a spanning interval of its corresponding string. Thus in the rst case, RSCS[i 1 ; j 1 ; i 2 ; j 2 ] = min x;y fRSCS[i 1 ; k 1 0 1; i 2 ; x 0 1] + RSCS[k 1 ; j 1 ; x; y] + len(t[y + 1 : : : j 2 ])g where the minimization is over all i 2 x &lt; y j 2 such that [x; y] is a spanning interval of t. Similarly, in the second case, RSCS[i 1 ; j 1 ; i 2 ; j 2 ] = min x;y fRSCS[i 1 ; x 0 1; i 2 ; k 2 0 1] + where s has a known structure S 1 , we infer the structure of t by aligning the two sequences. This approach is useful if we know that the two sequences are functionally related and have similar structure. For all 1 i &lt; j m + n, base-pairs i 0 gap[2; i] and j 0 gap[2; j] form a bond in t only if they are complementary and (i 0 gap[1; i]; j 0 gap[1; j]) 2 S. We would like to nd an alignment that maximizes the sequence similarity score as well as the number of bonds formed in t. The algorithm for computing RNA alignment can be easily modied to accomplish this. Consider the algorithm AlignRNA (g. 2). Note that when we are comparing intervals [i 1 ; j 1 ] and [i 2 ; j 2 ], and there exists (k 1 ; j 1 ) 2 S, there may be (m) complementary pairs (k 2 ; j 2 ) that (k 1 ; j 1 ) can align against, and we need to pick the pair that gives the best alignment. Therefore, the naive algorithm has complexity O(n 2 m 3 ). We improve the running time by reducing the number of intervals for which the computation of the score takes time (m). First note that in aligning intervals [i 1 ; j 1 ] and [i 2 ; j 2 ], we can consider the cases where the leftmost or the rightmost column is involved only in character operations (insertions, deletions or substitutions). This leaves only the cases where both i 1 and j 1 are endpoints of edges in S. Even so, the number of such intervals [i 1 ; j 1 ] is quadratic. However, we can use the tree structure on S to show that it suces to carry out the more expensive computation for only a linear number of such intervals [i 1 ; j 1 ]. This leads to an algorithm with a running time of O(n 2 m 2 + nm 3 ).</p><p>Consider the case when the endpoints of the interval [i 1 ; j 1 ] form an edge in S. Moreover, s[i 1 ] must be matched against t[i 2 ] and s[j i ] against t[j 2 ], else we are in a case of character operations addressed above. This step can be computed in constant time.</p><p>Next we consider the case when the endpoints of the interval [i 1 ; j 1 ] participate in dierent edges in S. For this case, we will binarize the forest structure on S to yield a linear number of such intervals [i 1 ; j 1 ] with the following property: the score of an optimal alignment of any such interval with t can be obtained by considering alignments of such subintervals with intervals in t.</p><p>Consider the forest dened by the elements of S and the function parent. We binarize the forest by introducing additional base-pairs in S to get S 0 , so that each node in S 0 has at most 2 children. Procedure Binarize (g. 3) accomplishes this, for a tree rooted at (i; j) 2 S.</p><p>For the algorithm InferStructure (g. 4), we assume that we already have the sets S and S 0 for s. Functions and are the costs for aligning bases and base-pairs respectively, as dened for RNA Alignment.</p><p>Observe that jS 0 j = O(jSj), which implies that jS 0 j = O(n). The rst two conditional statements each take constant time and are executed for all possible O(n 2 m 2 ) intervals. The last conditional statement takes time O(m), but is executed O(jS 0 jm 2 ) = O(nm 2 ) times. This gives the following theorem. Procedure Binarize(i; j) (* Assume that (i; j) 2 S has k children f(i 1 ; j 1 ); : : : ; (i k ; j k )g *) begin S 0 = ;. for 1 u &lt; k do Binarize(i u ; j u ) S 0 = S 0 [ f(i 1 ; j u )g if (u &gt; 1) parent((i 1 ; j u01 )) = (i 1 ; j u ) parent((i u ; j u )) = (i 1 ; j u ) parent(i 1 ; j k ) = (i; j) end Figure <ref type="figure">3</ref>: Binarizing an RNA structure tree Procedure InferStructure begin for intervals (i 1 ; j 1 ), 1 i 1 &lt; j 1 n and intervals (i 2 ; j 2 ), 1 i 2 &lt; j 2 m (* Assume that the intervals are examined in lexicographically increasing order of widths*)</p><p>Align[i 1 ; j 1 ; i 2 ; j 2 ] = max 8 &gt; &gt; &gt; &gt; &gt; &gt; &gt; &lt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; :</p><p>Align[i 1 + 1; j 1 ; i 2 ; j 2 ] + (s[i 1 ]; `00 ) Align[i 1 ; j 1 ; i 2 + 1; j 2 ] + (`0 0 ; t[i 2 ])</p><p>Align[i 1 + 1; j 1 ; i 2 + 1; j 2 ] + (s[i 1 ]; t[i 2 ])</p><p>Align[i 1 ; j 1 0 1; i 2 ; j 2 ] + (s[j 1 ]; `00 ) Align[i 1 ; j 1 ; i 2 ; j 2 0 1] + (`0 0 ; t[j 2 ]) Align[i 1 ; j 1 0 1; i 2 ; j 2 else if (i 1 ; j 1 ) 2 S`0 S and (k; j 1 )) = rightchild(i 1 ; j 1 ) Align[i 1 ; j 1 ; i 2 ; j 2 ] = max ( Align[i 1 ; j 1 ; i 2 ; j 2 ]; max i 2 &lt;l&lt;j 2 fAlign[i 1 ; k 0 1; i 2 ; l 0 1] + Align[k; j 1 ; l; j 2 ]g end Figure <ref type="figure">4</ref>: Inferring structure of an RNA string 5 Conclusions</p><p>We have formulated and provided ecient algorithms for a number of problems on computing similarity between RNA strings. Among possible extensions, we mention two: careful modeling of energies of secondary structure primitives such as multiloops, bulges etc., and dening models that capture more general structures such as proteins. It is worthwhile to note that our algorithms for RNA string matching extend to structures that allow crossing edges as long as every base forms at most one bond.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Theorem 2 . 1</head><label>21</label><figDesc>The CEM problem can be solved in O(n polylog m) time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>2 Theorem 2 . 2</head><label>222</label><figDesc>The SEM problem can be solved in O(n + m) time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>CKM problem can be solved in O(n p m polylog m) time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Theorem 4 . 1</head><label>41</label><figDesc>The algorithm InferStructure computes the score of an optimal alignment for inferring structure in O(m 2 n 2 + nm 3 ) time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Summary of results.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>0 1] + (s[j 1 ]; t[j 2 ]) if (i 1 ; j 1 ) 2 S and t[i 2 ] and t[j 2 ] are complementary base-pairs Align[i 1 ; j 1 ; i 2 ; j 2 ]; (i 1 ; j 1 ; i 2 ; j 2 ) + (s[i 1 ]; t[i 2 ]) + (s[j 1 ]; t[j 2 ]) + Align[i 1 + 1; j 1 0 1; i 2 + 1; j 2 0 1]</figDesc><table><row><cell>Align[i 1 ; j 1 ; i 2 ; j 2 ] = max</cell><cell>8 &gt; &lt; &gt; :</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>For a formal denition of these terms, refer to<ref type="bibr" target="#b28">[29]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_1"><p>AcknowledgementsWe thank Martin Vingron for help with formulating some of these problems.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>DIMACS and supported under NSF contract STC-8809648. The second author's research was partly supported by ALCOM IT.</p><p>2 Postdoctoral fellow DIMACS is a cooperative project of Rutgers University, Princeton University, AT&amp;T Bell Laboratories and Bellcore. DIMACS is an NSF Science and Technology Center, funded under contract STC{91{19999; and also receives support from the New Jersey Commission on Science and Technology.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Proof: Suppose without loss of generality that n 2m. We will again determine for each position the number of mismatches between p and t. Doing this considering p and t as sequences of characters can be done in O(nm 1  2 polylog m) time. Hence we only consider counting edge mismatches. We give a reduction from this problem to string matching with sets of ranges. We generate t 0 from t by replacing each position i by k 0 i if (i; k) or (k; i) is a bonding pair in t, and by a special character character X t if there is no bonding pair involving i. We generate p 0 from p by replacing each position i by k 0 i if (i; k) or (k; i) is a bonding pair in p, and by h[(m 0 i) <ref type="bibr" target="#b0">1</ref> </p><p>if there is no bonding pair involving i.</p><p>Suppose for a given placement of the pattern on the text, the character in position i of the pattern is not involved in a base-pair while the corresponding character in the text is. Two cases arise. If the base-pair in t lies within the span of p, then this indicates an edge mismatch. On the other hand, if the other endpoint of the base-pair in t is outside the span of p, then there is no edge mismatch at position i in p. In the rst case, the position in t 0 corresponding to position i in p 0 contains an integer in the range f0(i 0 1); : : : ; m 0 i 0 1g. This is outside the chosen range for p 0 [i] and results in a mismatch. In the second case, p 0 [i] matches with the corresponding character in t 0 . Thus, p 0 occurs at i in t 0 with 2k mismatches if and only if p occurs in t with k edge mismatches. By Theorem 2.5, the running time is O(nm 2 3 polylog m).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">3 Computing Alignment for RNA strings</head><p>In this section, we look at sequence-alignment problems in the context of RNA strings. Specically, we will consider variants of the edit-distance, longest-common-subsequence and shortest-common-supersequence problems.</p><p>Following Zuker <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b28">29]</ref>, assume a model in which there are no knots in the secondary structure. In other words, the edges representing base-pairs in the secondary structure must be noncrossing along the length of the string. A secondary structure is denoted by the set S of all base-pairs which have formed bonds. For (i; j) 2 S, h is accessible from (i; j) if i &lt; h &lt; j, and there is no pair (k; l) 2 S, s.t. i &lt; k &lt; h &lt; l &lt; j. Dene (i; j) 2 S as the parent of (k; l) 2 S if k; l are accessible from (i; j). Observe that each (i; j) 2 S has at most one parent due to noncrossing edges, implying a forest on the elements of S. The denitions of sibling, child and leaf follow naturally.</p><p>Let s[1 : : : n] and t[1 : : : m] be two RNA strings over the alphabet P = fA; C; G; Ug with structure S 1 and S 2 respectively. For technical reasons, let s[0] = t[0] = `00 . An alignment of s and t is dened by a 2 2 m 0 matrix A, in which the rst row contains s and the second contains t, possibly interspersed with spaces, and for all columns j, either A[1; j] 6 = `00 or A[2; j] 6 = `00 . For i 2 f1; 2g, dene gap[i; j] = ( j if A[i; j] = `00 jfl &lt; j s.t. A[i; l] = `00 gj otherwise Intuitively, if A[i; j] 6 = `00 , then gap[i; j] is the number of gaps that were inserted in the ith string till position j in alignment A. Following standard terminology, position i in A has a match if A[1; i] = A[2; i] 6 = `00 , an insertion if A[1; i] = `00 , a deletion if A[2; i] = `00 and a mismatch otherwise. Additionally, for RNA strings a bonding pair occurs at positions i; j if (i 0 gap[1; i]; j 0 gap[1; j]) 2 S 1 and (i 0 gap[2; i]; j 0 gap[2; j]) 2 S 2 . Intuitively, we would like to compute an alignment which maximizes both symbol and base-pair matches.</p><p>Formally, for elements u; v 2 P [f`0 0 g, dene (u; v) to be the similarity score associated with aligning u against v. For 1 i &lt; j m and 1 k &lt; l n, let (i; j; k; l) be the similarity score associated with aligning base-pairs (i; j) with (k; l).</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Generalized string matching</title>
		<author>
			<persName><forename type="first">K</forename><surname>Abrahamson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comp</title>
		<imprint>
			<biblScope unit="page" from="1039" to="1051" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Ecient 2-dimensional Approximate Matching of Nonrectangular Figures</title>
		<author>
			<persName><forename type="first">A</forename><surname>Amir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Farach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc of 2nd Ann ACM Symp on Discrete Algorithms</title>
		<meeting>of 2nd Ann ACM Symp on Discrete Algorithms</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="212" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">\Sparse dynamic programming I: Linear cost functions</title>
		<author>
			<persName><forename type="first">D</forename><surname>Eppstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Galil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Giancarlo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">F</forename><surname>Italiano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JACM</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="519" to="545" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">\Sparse dynamic programming II: Convex and concave cost functions</title>
		<author>
			<persName><forename type="first">D</forename><surname>Eppstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Galil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Giancarlo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">F</forename><surname>Italiano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JACM</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="546" to="567" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">String Matching and other Products</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Paterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM-AMS Proceedings</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="113" to="125" />
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">\RNA modeling using Gibbs sampling and stochastic context free grammars</title>
		<author>
			<persName><forename type="first">L</forename><surname>Grate</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Hebster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hughey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">S</forename><surname>Haussler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mian</surname></persName>
		</author>
		<author>
			<persName><surname>Noller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Second Intl. Conf. on Intelligent Systems for Molecular Biology</title>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">\Alignment of trees -an alternative to tree edit</title>
		<author>
			<persName><forename type="first">T</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Combinatorial Pattern Matching Conf</title>
		<meeting>Combinatorial Pattern Matching Conf</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">94</biblScope>
			<biblScope unit="page" from="75" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">\Query primitives for tree-structured data</title>
		<author>
			<persName><forename type="first">P</forename><surname>Kilpel Ainen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mannila</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Combinatorial Pattern Matching Conf. 94</title>
		<meeting>Combinatorial Pattern Matching Conf. 94</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">807</biblScope>
			<biblScope unit="page" from="213" to="225" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Fast pattern matching in strings</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Knuth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">R</forename><surname>Pratt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Computing</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="323" to="350" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">\On-line dynamic programming with applications to the prediction of RNA secondary structure</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">L</forename><surname>Larmore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schieber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Prof. First ACM-SIAM Symp. on Discrete Algorithms</title>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="503" to="512" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">\RNA secondary structures: comparison and determination of frequently recurring substructures by consensus</title>
		<author>
			<persName><forename type="first">S-Y</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Owens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Nussinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J-H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Shapiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">V</forename><surname>Maizel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CABIOS</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="205" to="210" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">New results and open problems related to non-standard stringology</title>
		<author>
			<persName><forename type="first">S</forename><surname>Muthukrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 6th Combinatorial Pattern Matching Conference</title>
		<meeting>6th Combinatorial Pattern Matching Conference</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="298" to="317" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">\A general method applicable to the search for similarities in the amino-acid sequences of two proteins</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">E</forename><surname>Needleman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Wunsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Bio</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="443" to="453" />
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">\Algorithms for loop matchings</title>
		<author>
			<persName><forename type="first">R</forename><surname>Nussinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pieczenik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Griggs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Kleitman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Appl. Math</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="68" to="82" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">\Stochastic context free grammars for modeling RNA</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Sakakibara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">S</forename><surname>Mian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Underwood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Haussler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. the Hawaii Intl. Conf. on System Sciences</title>
		<meeting>the Hawaii Intl. Conf. on System Sciences<address><addrLine>Los Alamitos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">\Recent methods for RNA modeling using stochastic contextfree grammars</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Sakakibara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hughey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">S</forename><surname>Mian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sj Olander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Underwood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Haussler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Combinatorial Pattern Matching Conf</title>
		<meeting>Combinatorial Pattern Matching Conf</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">807</biblScope>
			<biblScope unit="page" from="289" to="306" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">\Simultaneous solution of the RNA folding, alignment and protosequence problems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Sanko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Appl. Math</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="810" to="825" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">\An algorithm for comparing multiple RNA secondary structures</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Shapiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CABIOS</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="387" to="393" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">\Comparing multiple RNA secondary structures using tree comparisons</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Shapiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CABIOS</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="309" to="318" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">\The identication of common molecular subsequences</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Waterman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">147</biblScope>
			<biblScope unit="page" from="195" to="197" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">\Comparison of biosequences</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Waterman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Adv. in App. Math</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="482" to="489" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">\The tree to tree correction problem</title>
		<author>
			<persName><forename type="first">K-C</forename><surname>Tai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JACM</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="422" to="433" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">\Secondary structure of single-stranded nucleic acids</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Waterman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Studies in Foundations and Combinatorics, Advances in Mathematics supplementary studies</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Academic press</publisher>
			<date type="published" when="1978">1978</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="167" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">\RNA secondary structure: a complete mathematical analysis</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Waterman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Biosci</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="257" to="266" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">\Simple fast algorithms for the editing distance between trees and related problems</title>
		<author>
			<persName><forename type="first">K</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Shasha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="1245" to="1262" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">\On the editing distance between unordered labeled trees</title>
		<author>
			<persName><forename type="first">K</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Statman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Shasha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Proc. Lett</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="133" to="139" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">\On nding all suboptimal foldings of an RNA molecule</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zuker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">244</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="48" to="52" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">\RNA secondary structures and their prediction</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zuker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sanko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bull. Math. Biol</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="591" to="621" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">\Optimal computer folding of large RNA sequences using thermodynamics and auxiliary information</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zuker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Stiegler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acid Res</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="133" to="148" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
