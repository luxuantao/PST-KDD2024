<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">MUSIC: Middleware Support for Self-Adaptation in Ubiquitous and Service-Oriented Environments</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Romain</forename><surname>Rouvoy</surname></persName>
							<email>rouvoy@ifi.uio.no</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Oslo</orgName>
								<address>
									<postCode>0316</postCode>
									<settlement>Oslo</settlement>
									<country key="NO">Norway</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Paolo</forename><surname>Barone</surname></persName>
							<email>paolo.barone@hp.com</email>
							<affiliation key="aff1">
								<orgName type="institution">HP Italy</orgName>
								<address>
									<postCode>20063</postCode>
									<settlement>Cernusco sul Naviglio</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yun</forename><surname>Ding</surname></persName>
							<email>yun.ding@eml-d.villa-bosch.de</email>
							<affiliation key="aff2">
								<orgName type="institution">European Media Laboratory GmbH</orgName>
								<address>
									<postCode>69118</postCode>
									<settlement>Heidelberg</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Frank</forename><surname>Eliassen</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Oslo</orgName>
								<address>
									<postCode>0316</postCode>
									<settlement>Oslo</settlement>
									<country key="NO">Norway</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Svein</forename><surname>Hallsteinsen</surname></persName>
							<email>svein.hallsteinsen@sintef.no</email>
							<affiliation key="aff3">
								<orgName type="laboratory">SINTEF ICT</orgName>
								<address>
									<postCode>7024</postCode>
									<settlement>Trondheim</settlement>
									<country key="NO">Norway</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jorge</forename><surname>Lorenzo</surname></persName>
							<email>jorgelg@tid.es</email>
							<affiliation key="aff4">
								<orgName type="institution">Telef√≥nica I+D</orgName>
								<address>
									<postCode>47151</postCode>
									<settlement>Valladolid</settlement>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alessandro</forename><surname>Mamelli</surname></persName>
							<email>alessandro.mamelli@hp.com</email>
							<affiliation key="aff1">
								<orgName type="institution">HP Italy</orgName>
								<address>
									<postCode>20063</postCode>
									<settlement>Cernusco sul Naviglio</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ulrich</forename><surname>Scholz</surname></persName>
							<email>ulrich.scholz@eml-d.villa-bosch.de</email>
							<affiliation key="aff2">
								<orgName type="institution">European Media Laboratory GmbH</orgName>
								<address>
									<postCode>69118</postCode>
									<settlement>Heidelberg</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">MUSIC: Middleware Support for Self-Adaptation in Ubiquitous and Service-Oriented Environments</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C593653D74C1753CAAE0BF56D94A15B1</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:04+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Adaptation planning</term>
					<term>component-based architectures</term>
					<term>selfadaptation</term>
					<term>service-oriented architectures</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Self-adaptive component-based architectures facilitate the building of systems capable of dynamically adapting to varying execution context. Such a dynamic adaptation is particularly relevant in the domain of ubiquitous computing, where numerous and unexpected changes of the execution context prevail. In this paper, we introduce an extension of the MUSIC component-based planning framework that optimizes the overall utility of applications when such changes occur. In particular, we focus on changes in the service provider landscape in order to plug in interchangeably components and services providing the functionalities defined by the component framework. The dynamic adaptations are operated automatically for optimizing the application utility in a given execution context. Our resulting planning framework is described and validated on a motivating scenario of the MUSIC project.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>With the emergence of ubiquitous computing, common future scenarios will consist in people moving around carrying mobile devices, which they use extensively to assist both leisure and business related tasks. This will not only involve interactions with services provided through the Internet, but also with services directly provided by devices available in the surrounding environment.</p><p>For developers of mobile applications this is a very challenging scenario. Users' movements in ubiquitous computing environments cause frequent and unexpected changes in the execution context of their applications. For example, a mobile device is frequently roaming, and its applications have to be dynamically adapted to remain useful under new network conditions. Such an adaptation requires the detection of context changes, but also the selection of an application configuration that maintains a satisfactory Quality of Service (QoS) in the new context. Furthermore, when services become a part of the ubiquitous environment, both the availability and the quality of the services on which the applications depend becomes a concern of the application developer. There is therefore a need to dynamically discover services both when they become available and when they disappear. Also, such applications need to embed logic enabling them to reason about how and when to use a service available in the surrounding, to select among service alternatives when there are more than one available, and to adapt when a service disappears. Such a self-adaptation process is generally complex and costly to implement. To achieve self-adaptation, developers can use programming language features, such as conditional expressions, parameterization, and exceptions. However, these approaches introduce complexity by intertwining adaptation and application logic. Also, they make software evolution difficult. Conversely, approaches that use application independent middleware approaches for adaptation relieve the applications from adaptation concerns <ref type="bibr" target="#b0">[1]</ref>.</p><p>In the MUSIC project, we follow the latter approach by seeking to separate the self-adaptation concern from the business logic concern and delegate as much as possible of the added complexity related to self-adaptation to generic middleware. The adaptation process relies on the architecture model of the application, which specifies its adaptation capabilities and its dependencies to context available at runtime. In MUSIC, an application is modeled as a component framework, which defines the functionalities that can be dynamically configured with conforming component implementations. Thus, the purpose of an adaptation-planning framework is to evaluate the utility of alternative configurations in response to context changes, to select a feasible one (e.g., the one with highest utility) for the current context and to adapt the application accordingly.</p><p>In this chapter, we propose a comprehensive extension of the MUSIC platform and planning framework we initially sketched in <ref type="bibr" target="#b2">[2]</ref>. Currently, MUSIC only supports the adaptation of component-based architectures. The proposed extension enables the self-adaptation of mobile and ubiquitous applications in the presence of Service-Oriented Architectures (SOA). The planning middleware evaluates discovered remote services as alternative configurations for the functionalities required by an application. This means that the extended planning framework can support seamless configuration of component frameworks based on both local and remote components as well as services. In particular, components and services can be plugged in interchangeably to provide the functionalities defined by the component framework. In case of services, the planning framework deals directly with Service Level Agreement (SLA) protocols supported by the service providers. In addition to that, we introduce in this chapter a support for advertising services and associated service levels, in order to satisfy dynamically incoming service requests. Hence, MUSIC applications can use the MUSIC platform to share services with the environment.</p><p>In the remainder of this chapter, we first describe in section 2 the MUSIC approach to planning-based adaptation for component-based applications. In section 3, we introduce a motivating scenario for the support of SOA for self-adaptive applications in a ubiquitous environment, as well as derive a set of requirements. Section 4 exposes the MUSIC support for consuming and providing services in ubiquitous environments. Section 5 describes the integration of SOA into the MUSIC platform from an implementation perspective, while section 6 provides a preliminary validation of our approach by discussing how the requirements derived in section 3 are met by the proposed design. In section 7, we discuss related work before concluding and pointing out further work in section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The MUSIC Approach to Self-Adaptation</head><p>Planning-based adaptation of a component-based application refers to the capability of a system to adapt to changing user needs and operating conditions by exploiting knowledge about its composition and Quality of Service (QoS) characteristics of its constituting components <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b4">3,</ref><ref type="bibr" target="#b5">4,</ref><ref type="bibr" target="#b6">5,</ref><ref type="bibr" target="#b7">6]</ref>. In MUSIC this knowledge is provided in the form of a QoS-aware model (cf. Figure <ref type="figure">1</ref>), which describes the abstract composition, the relevant QoS dimensions and how they are affected when varying the actual component configuration. This model is exploited by the adaptation middleware to select, connect, and deploy a configuration of Component Realizations providing the best utility. The utility measures the degree of fulfillment of user preferences while optimizing device resource utilization <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b4">3]</ref>. The model describes the abstract composition as a set of Roles collaborating through Ports, which represent either functionality provided to or required from collaborating components. Properties and property predictor functions associated with the ports define how the QoS properties and resource needs of components are influenced by the QoS properties of the components they depend on. A port has a Type defining the functionality represented by the port in terms of interfaces and protocol. Component realizations implement ports and a component realization can be used in a role if the ports match (same type). Component realizations are Atomic or Composite. A Composite Realization is itself an abstract composition and allows for recursive decomposition. Constraints are predicates over the properties of the constituting components of a composition, which restrict the possible combinations of component realizations (e.g., configuration consistencies) <ref type="bibr" target="#b4">[3,</ref><ref type="bibr" target="#b8">7]</ref>.</p><p>The model is represented at runtime as plans within the middleware. A plan reflects a component realization and describes its ports and associated property Fig. <ref type="figure">1</ref>. Description of the MUSIC meta-model predictors as well as implicit dependencies on the hosting platform (e.g., platform type and version). In the case of an atomic component realization, it also contains a reference to the class, which realizes the component. In the case of a composite realization, the plan describes the internal structure in terms of roles and ports and the connections between them. Variation is obtained by describing a set of possible alternative realizations of the roles.</p><p>Then, planning refers to the process of selecting the components that make up an application configuration providing the best possible utility to the end-user. This process will be triggered at start-up of the application and at run-time when the execution context suddenly changes. When such an adaptation process is triggered for a particular type, the planning middleware iterates over the plans associated to the roles. For each plan, it resolves the plan dependencies and evaluates the configuration suitability to the current execution context by computing the Predicted Properties. The predicted properties are input to the normalized utility function that computes the expected utility of the evaluated application configuration <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">2,</ref><ref type="bibr" target="#b4">3,</ref><ref type="bibr" target="#b5">4,</ref><ref type="bibr" target="#b6">5]</ref>. The utility function of an application is provided by the developer and is typically expressed as a weighted sum of dimensional utility functions where the weights express user preferences (i.e., relative importance of a dimension to the user). A dimensional utility function measures user satisfaction in one property dimension.</p><p>An example model for an application assisting traveling on public transportation is shown in figure <ref type="figure" target="#fig_0">2</ref>. It is described as a collaboration of five roles. GUI presents a graphical user interface on the device. Main embeds the application logic and binds the different functionalities together. Main interacts with Route to find the shortest route and the estimated travel time. It also uses Map to get localized maps and Location to get the current location. The QoS properties used in the model are specified in table <ref type="table">1</ref>. Property predictors for the application, specified as functions of the properties of the components it consists of, are associated with the composition in figure <ref type="figure" target="#fig_0">2</ref>. The utility function assumes that the user always prefers high accuracy and low battery consumption, while the relative weighting (w_acc, w_bat) will be extracted from the user profile by the middleware.  The middleware manages a collection of active applications and seeks to maximize the overall utility, which is computed as a weighted sum of individual application utilities. The weights in this case express application priorities of the user.</p><p>Figure <ref type="figure">3</ref> depicts the component-based architecture of the MUSIC platform. The planning is typically triggered by context changes detected by the Context Manager. The Adaptation Controller coordinates the adaptation process. The Adaptation Reasoner supports the execution of the planning heuristics, which is driven by metadata included in the plans <ref type="bibr" target="#b5">[4]</ref>. The Plan Repository provides an interface IPlanResolver to the adaptation reasoner allowing for the recursive retrieval of plans associated to a given port. Any additional metadata on the required types will help the plan repository to exclude plans and thus drastically reduce the exploration space <ref type="bibr" target="#b5">[4,</ref><ref type="bibr" target="#b7">6]</ref>. The adaptation reasoner builds a valid application configuration and discards those whose dependencies are unresolved. Then, the heuristics ranks the application configurations by evaluating their utility based on the computation of the predicted properties, whose values are retrieved from the QoS Manager.</p><p>The reconfiguration process is handled by the Configuration Executor, which uses the set of plans selected by the planner to reconfigure the application. This requires the collaboration of the components, which must implement a reconfiguration interface allowing the middleware to bring them to a state where they can be safely replaced and transfer their state to an alternative component.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Challenges of Ubiquitous and Service-Oriented Environments</head><p>The term service is perhaps one of the most over-used and confusing terms in the software industry as analyzed in <ref type="bibr" target="#b10">[9]</ref>. Typically, services are defined as functionalities or capabilities provided by a software system to other software systems or to a human user <ref type="bibr" target="#b11">[10]</ref>. In the context of SOA, services are provided by independent service providers, which instantiate the providing software on their computers and advertise the services they provide using standardized mechanisms, such that they can be discovered and bound dynamically by consumers which need them. A fundamental concept of service-orientation is the standardized service contract <ref type="bibr" target="#b12">[11]</ref>, which is used to express the service semantics and capabilities. Service QoS properties are normally negotiated between the service provider and the service consumer, and are described as part of the service contract as a Service Level Agreement (SLA). A service level is used to describe the expected performance (e.g., response time and availability) and properties such as billing, termination terms, and penalties in case of a violation of the SLA <ref type="bibr" target="#b13">[12]</ref>. A SLA can either be created after selecting a fixed service level offer among several pre-defined offers or, in more complex cases, after a customization via a negotiation process. An SLA may be valid for a limited period or may be terminated explicitly. During SLA provisioning, the provider monitors the service QoS and adapts its resources to avoid SLA violations. The consumer may also perform monitoring to avoid trusting the provider blindly.</p><p>The platform presented in the previous section focuses on component based selfadapting systems. When mobile devices move around in ubiquitous computing environments they experience a dynamic service landscape and additional requirements to self-adaptation arise which require extensions of the platform. To investigate these issues, we consider the following scenario of Paul who is on his way to meet a friend, assisted by applications on his mobile device. First, we introduce several situations that Paul encounters and explain how he and his device react. Then, we explain the requirements that enable such flexibility.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Example Scenario: Paul on His Way to Meet a Friend</head><p>Paul has been at a concert in Paris. Now, he is taking the subway to a friend to see her new home and to tell her about the show. His MUSIC-enabled mobile device is WiFi-, UPnP-, and GPS-enabled. It provides several applications, among them a service-based version of the TravelAssistant from the example and a media-sharing application.</p><p>The TravelAssistant assists Paul with route planning, ticket vending, detects traveling delays, and notifies Paul if he is affected by such delays. The media-sharing platform, called InstantSocial <ref type="bibr" target="#b9">[8]</ref>, appears as a web site. However, instead of relying on a central Internet server, it is served by a composition of services scattered across nearby devices. As more users participate, this platform becomes more robust, the number of shared content items increases and it may become more attractive for the users. As soon as a critical mass of users leaves, it stops operating. Scene 1. The scenario starts with Paul entering the Paris subway. He wants to plan the journey to his friend, which requires a route service for the subway as well as a location and a map service for the remaining trip. RATP, the operating company, offers a route service for public transportation and a map service of Paris at two QoS levels: basic and premium quality. Via UMTS, there is also access to a commercial service of high quality, though for a higher monetary cost. Paul requests services of high quality and his device chooses the cheap premium service of RATP. Scene 2. With his TravelAssistant, Paul devises his journey and buys a ticket. As regular traveler, he has an electronic pass. Upon approaching a validation post, his device detects it, Paul's pass is checked, and the entrance gate opens automatically. Scene 3. Inside the train, Paul thinks of searching for further pictures of the concert. He starts the InstantSocial application, which configures itself according to the other InstantSocial instances in the vicinity. His device notifies Paul about the presence of a matching media-sharing group. He joins and a moment later his display shows a selection of pictures, each representing a collection of shots of interests. He browses through the content, selects the ones he likes, and begins to download. Scene 4. During the trip, there is an incident in the metro, blocking the planned itinerary. The travel assistant notifies Paul and proposes an alternative metro route with a different final station. Unfortunately, planning the remaining trip is not as smooth as desired: RATP reserves a large share of its bandwidth to guide the emergency personnel and declines to offer the high-quality map service. Furthermore, he cannot use GPS because the system's satellites are out of sight. As best solution, Paul's device chooses the external high-quality services, despite the higher cost. Scene 5. Now, Paul is in a train with fewer visitors of his concert. Due to the decreased robustness, InstantSocial adapts it focus from sharing to collecting pictures. The other instances tend to do the same such that the combined media platform weakens. Finally, Paul is notified about the poor quality and he terminates InstantSocial. Scene 6. After leaving the subway, the GPS module starts working and his device guides him through the streets. Some minutes later, he arrives at his friend's home in time with a device full of impressions to share.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Requirements for Planning-Based Adaptation</head><p>During Paul's journey, the applications on his device make flexible use of a variety of services and protocols nonetheless remains operational through various context changes. In particular, TravelAssistant and InstantSocial depend on external services that are dynamically chosen and used. Each InstantSocial instance also offers services to other instances. All these examples of flexibility require middleware support, which is provided by the design presented in this chapter.</p><p>Scene 1 shows a service selection process depending on QoS. The use of an UPnPbased service in scene 2 demonstrates the need for alternative connection protocols and services. Scene 3 demonstrates the degree of flexibility required: an InstantSocial instance is a combination of local and external services; it is able to offer and may use services at different QoS levels. The actual composition of the instance at a specific time has to be decided at runtime. Scene 4 features a willful reduction of a QoS level by the provider of an external service. It results in an adaptation to an alternative service provider, although the original provider is still offering the service, too. In scene 5, the device has to cope with an unplanned service termination by the sudden disappearance of InstantSocial instances. Furthermore, it demonstrates the deliberate termination of services by the user. Thus, to support scenarios of the kind presented above, we need to extend the platform to deal with the following SOA requirements: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Supporting Service-Oriented Architectures within MUSIC</head><p>The interpretation of the term service presented in the previous section relates naturally to the port concept in the conceptual model presented in section 2. Thus we can accommodate services in the conceptual model simply by considering that ports represent services provided by or required by components, that services are described by types, and that service levels are described by properties. However, the middleware must be extended in several ways to cope with the challenges derived above. The remaining of this section introduces the consumer-and the provider-side support offered by the MUSIC platform in order to enable the seamless integration of services made available in a ubiquitous computing environment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Consuming Services within MUSIC</head><p>In SOA-based computing environments, an application typically uses one or more services, which possibly depend on further services and so on. Thus, a large number of computers owned and administrated by different organizations may potentially be involved. This problem is aggravated when we deal with several applications running concurrently. Thus, optimizing utility over the entire set of involved computers is likely to be intractable both from a technical and administrative point of view. Therefore, we have to delineate the scope of an adaptation to be more tractable. To this end, we introduce the notion of adaptation domain and the distinction between internal and external services.</p><p>An adaptation domain is a collection of MUSIC platform instances controlled by one adaptation manager. It includes one distinguished node (e.g., a handheld device), which represents a permanent binding to a user. This node acts as the nucleus around which the adaptation domain forms dynamically as auxiliary nodes come and go. The movement of nucleus nodes or changes in connectivity due other phenomena causes the dynamic evolution of an adaptation domain. Adaptation domains may overlap in the sense that auxiliary nodes may be members of multiple adaptation domains. This adds to the dynamics and increases the complexity because the amount of resources the auxiliary nodes are willing to provide to a particular domain may vary depending on the needs of other served domains. The user of a nucleus node may start and stop applications or shared components, and the set of running components is adapted by the adaptation manager according to these user actions and context changes, taking into account the resource constraints.</p><p>Clearly, it makes a difference whether a role is bound by instantiating a component implementation running in the adaptation domain where a system is built (private instance), by using a service provided by a component instance already running there (internal service), or by connecting to a service provided by a third party (external service). In the first two cases, the adaptation manager building the system must provision the resources and has control of the provided service level. In the latter case, the service level is outside the control of the adaptation manager, and it is necessary to negotiate an SLA with the service providers in order to compare the suitability of services by different providers and weight against deploying an internal service. External services may be provided by other adaptation domains or by third party providers (also referred to as external non-MUSIC services).</p><p>Discovery of Services and Service Levels. Providers make their services accessible to third parties according to specific discovery protocols. The MUSIC platform supports an extensible set of discovery protocols allowing the detection of services available in the service landscape. The discovery of a service triggers the retrieval of its service description, which includes information on the service capabilities, semantics, and possibly the offered service level(s) or QoS properties in form of an agreement template. The service description and, if available, the agreement template are then converted to service plans, each one reflecting an alternative realization for the service level.</p><p>Negotiation of Service Level Agreements. The planning phase involves the evaluation of the available plans, for selecting the composition optimizing the utility of the applications running on the device. The utility depends on the QoS properties predicted by the services, whose value can be static or dynamic. Static properties consist of fixed values that do not change over the time. Dynamic property values can change according to the current status of the service. Evaluating the actual QoS values for such properties requires a process of negotiation with the service provider. The current MUSIC negotiation protocol is inspired by the WS-Agreement specification <ref type="bibr" target="#b14">[13]</ref> (for both the definition and the creation/monitoring of SLAs), where the provider enriches the service description with an agreement template and the consumer fills in the template to create and submit an agreement offer. The offer creation is driven by Service Level Objectives (SLO), which are conditions defined at application or configuration level and act as pre-defined criteria for negotiating an SLA contract. Once the provider has accepted the offer, the agreed property values are reflected in the plan.</p><p>Provisioning of Service Level Agreements. Whenever a service available in the landscape is selected for use as a result of the adaptation reasoning, the MUSIC platform instantiates service proxies. These Proxies act as local representatives of the remote services and encapsulate the communication protocol necessary to access them in a location-transparent way. They are created by a binding framework, which provides dedicated proxy factories. Each factory supports a particular communication protocol to export or import a service. During the binding phase, the SLA contract associated with the selected plan is provisioned and enforced by the involved parties, which includes the reservation of computing resources and the deployment of SLA monitoring facilities <ref type="bibr" target="#b12">[11,</ref><ref type="bibr" target="#b16">15,</ref><ref type="bibr" target="#b17">16]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Monitoring of Service Level Agreements.</head><p>For the purpose of SLA monitoring, the service proxy is instrumented with appropriate monitoring mechanisms according to the content of the SLA contract (e.g., response delay, result quality). Both parties are responsible for checking the status of the agreement and for taking proper actions in case of violation of the agreement. Thus, after the creation of an agreement, the MU-SIC middleware, at any given time, must be able to check the current state of the agreement itself. When an agreement is not fulfilled anymore, the MUSIC middleware must terminate it and trigger a new adaptation process in order to detect a new set of available services and to select among them the best candidate to replace the one breaking the contract. SLA-enabled service providers handle the state model of an agreement and of its constituting terms, and make them accessible to consumers in form of readable properties of the agreement.</p><p>On the consumer side, the MUSIC middleware architecture is responsible for checking the state of an agreement according to pre-defined policies (e.g., at given intervals or when detecting that the expected performance of a service is degrading). By querying the service provider for the agreement state, it is possible to detect whether the agreement has been violated or not. In case of violation, the consumer terminates explicitly the agreement by invoking a terminate operation on the provider side (since there might be costs associated to the usage of the service), and discards the related service plan, hence triggering a new adaptation process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Providing Services within MUSIC</head><p>Hosting both applications and components providing services to the outside world in an adaptation domain complicates the adaptation reasoning. In addition to the user owning the device, there are also external service consumers, which may have conflicting needs (expressed in the SLA). Fortunately, the utility function approach lends itself quite naturally to cope with such situations. Our solution is to treat shared components providing services to external clients in the same way as applications and equip them with their own utility function, computing the degree of fulfillment of active SLAs. Using the weights, the overall utility function balances the utility to the owner of the device against the utility to service clients. This information about user preferences is included in user profiles.</p><p>Another difficulty is related to property prediction. For shared services, the resources needed by the component to guarantee a certain QoS often depend on the number of consumers. Hence, property predictor functions for shared services must take this into account.</p><p>Publishing of Services and Service Levels. By publishing its description using the discovery protocols supported by the MUSIC platform, a service running on a node can be made available to other nodes within the adaptation domain. Each service description encloses the service type as well as an agreement template describing the static QoS properties that are provided by this service. QoS dimensions referring to dynamic properties of the application are unbound in order to be fixed at a later time depending on the capabilities and the processing load of the hosting node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Negotiation of Service Level Agreements.</head><p>The MUSIC platform supports the negotiation of agreements by playing the role of a service provider. Whenever a service consumer selects one of the published services, the MUSIC platform receives an agreement offer for consuming this service. The MUSIC platform applies the negotiation heuristics to decide whether to accept or reject this offer by taking the current resource availability into account. This heuristics predicts the impact of accepting the offer with regards to agreements that have been already accepted. If the resulting impact does not trigger any violation of previous agreements, the MUSIC platform creates an agreement, which keeps track of the negotiation process.</p><p>Provisioning of Service Level Agreements. When a service consumer requests an internal service, the MUSIC platform checks that the requested service refers to an accepted agreement. Then, the binding framework instantiates a service skeletoni.e., a local representative of the service consumer-which reflects the ongoing agreement and implements one of the supported communication protocols (e.g., SOAP or RMI). Invocations received via the service skeleton are delegated to the service instance locally deployed on the node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Monitoring of Service Level Agreements.</head><p>Depending on the negotiated properties agreed in the agreement, the service skeleton is instrumented with context sensors, which are responsible for monitoring the agreement. The MUSIC platform provides a library of sensors for observable properties (e.g., invocation latency) as part of its context middleware. If one of the sensors detects a violation in one of the dimensions of the agreement, it notifies the MUSIC platform about this violation, which results in the notification of the service consumer and the termination of the agreement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Realizing the Support for Service-Oriented Architectures</head><p>This section describes the extension of the MUSIC platform in order to support the SOA principles as well as the realization of the MUSIC reference implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Architecture of the Service-Oriented MUSIC Platform</head><p>To support the above-mentioned SOA principles <ref type="bibr" target="#b12">[11]</ref>, we have integrated new components into the MUSIC Platform (cf. Figure <ref type="figure" target="#fig_3">4</ref>, the composite component SOA Support). As MUSIC is independent of a particular technology, various implementations of these components can be developed (e.g., Web Service, CORBA, RMI, or UPnP).</p><p>More specifically, the Service Discovery is responsible for publishing and discovering services using different discovery protocols. The Remoting Service is responsible for the exporting of services at the service provider side, and for the binding to these services at the service consumer side. Whenever a service is exported, it is enabled to accept requests from (remote) service consumers. Each service description defining the provided functionalities and containing the necessary information for the consumer to access the service<ref type="foot" target="#foot_0">1</ref> can be published by the service discovery. If the service provider offers additional guarantees for the published services, agreement templates are published in addition to the service description.</p><p>The service discovery supports the dynamic registration of discovery listeners. A discovery listener can have interest for particular services and can enforce customized policies to handle them. For example, the Remote Platform Discovery Listener is particularly interested in finding remote instances of the MUSIC platform in order to provide information about the MUSIC platforms connected to the applications. The SLA Discovery Listener is interested in finding services accompanied with an SLA support. Upon the discovery of services, the service discovery notifies the registered discovery listeners by passing them the service descriptions. Since plans are the base for the Adaptation Manager to perform planning-based adaptation, the discovery listeners create service plans based on the service descriptions and the agreements negotiated by the SLA Negotiation. Plans for remote services are generated whenever The distributed instances of the MUSIC platform form a federation such that the service discovery on different platforms can interact with each other. Hence, MUSIC platform A can be aware of a service, which is published using a protocol supported by MUSIC platform B and not supported by A. If the remoting service on platform A supports the appropriate communication protocol, A is able to bind to that service which it would not able to discover alone.</p><p>Agreement templates can be either static or allow for dynamic negotiation <ref type="bibr" target="#b13">[12]</ref>. Furthermore, a service may be offered at a pre-defined set of service levels. When the service discovery detects such a service, it first generates an abstract service plan enclosing structural and behavioral metadata related to the service. Then, in order to reflect the alternative service levels the service discovery publishes an extended version of the service plan for each service level into the plan repository. Such a service level plan inherits the metadata of the service from the abstract service plan and extends it with the additional QoS properties described by the particular service level (e.g., service accuracy and cost).</p><p>The adaptation manager is then able to compare each available service level when applying the reasoning heuristics. Since service negotiation is a time critical factor for an efficient planning process, it should be resolved as soon as possible. In MUSIC, the negotiation is generally performed during service discovery for static QoS properties (e.g., service cost) described by the service levels. The resulting static QoS property values are included into the service plan such that the predicted properties can automatically report them at a later time. However, in presence of a flexible service level <ref type="bibr" target="#b12">[11,</ref><ref type="bibr" target="#b14">13]</ref>, the negotiation becomes dynamic, meaning that the SLA is negotiated during the planning process. Dynamic negotiation is particularly required when the adaptation manager needs to reason about up-to-date QoS properties (e.g., current service accuracy). In this case, the predicted properties, when evaluated by the reasoning heuristics, delegate the negotiation of the requested property to the SLA negotiation. The negotiation protocol is driven by SLOs, which are pre-defined criteria for negotiating SLA <ref type="bibr" target="#b16">[15]</ref>.</p><p>The Configuration Executor generally iterates over the plans composing the new configuration in order to reconfigure the application. As described in section 2, the configuration executor distinguishes between plans which refer to available services and plans which refer to services that are not available yet. In order to benefit from remote services, the configuration executor now faces a third case: If the plan refers to a remote service available in the environment, the configuration executor uses the Remoting Service to generate a specific component that will act as a service proxy. A service proxy is a local representative of the remote service. In particular, it implements the service type described by the application components and encapsulates the communication necessary to access the remote service. By invoking the service proxy, a service consumer interacts with the remote service in a location-transparent way-i.e., as if the remote service is a local one.</p><p>The remoting service supports the dynamic integration of binding frameworks. During the binding phase, the SLA associated with the selected plan is provisioned and enforced by the involved parties. For the purpose of monitoring, the service proxy is instrumented with appropriate monitoring mechanisms by the component SLA Monitoring according to the content of the SLA (e.g., response delay, result quality). The SLA monitoring is responsible for checking the status of the agreement for taking proper actions in case of its violation.</p><p>As an example of performing SLA monitoring in ubiquitous environments, the service proxy implements a disconnection detection algorithm. This disconnection support is inspired by the principles of ambient programming <ref type="bibr" target="#b18">[17]</ref>. When loosing the connection to a remote service, the proxy stores the incoming service requests in a queue and returns a non-blocking future object to the application. The future object includes actions that are triggered whenever the connection is resolved to process the result of the request. If the connection is lost for a long period, the service proxy terminates the agreement via the component SLA negotiation. Subsequently, the SLA monitoring removes the associated service level plan from the plan repository to trigger an adaptation of the application. During the reconfiguration process, the request queue is transferred to the new component (or service proxy) that will be selected and deployed by the middleware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Implementation of the Service-Oriented MUSIC Platform</head><p>The reference implementation of the MUSIC platform is based on the architecture described in section 5.1. The selection of the framework, which the reference implementation of the MUSIC architecture is built upon, has been made to meet the most relevant requirements for the MUSIC platform. They are, in particular, open source framework, multi-platform support, suitability for resource-constrained devices, and SOA support. Therefore, we selected OSGi to leverage the MUSIC platform.</p><p>OSGi (http://www.osgi.org) defined itself as the dynamic module system for Java, is a service-oriented component-based framework. The success of OSGi may be attributed to its relative simplicity, efficiency, openness, and portability. Multiple open source implementations of OSGi are available. Since its initial design, OSGi targets resource-constrained devices. Some existing implementations, such as Concierge <ref type="bibr" target="#b19">[18]</ref>, exhibit a reasonable memory footprint for resource-constraint devices (80 kB). Furthermore, some initiatives, such as the OSGi Mobile Specification (JSR-232) <ref type="bibr" target="#b20">[19]</ref>, the Eclipse eRCP project <ref type="bibr" target="#b21">[20]</ref> or the Sprint Titan platform <ref type="bibr">[21]</ref>, propose OSGi for hosting applications in mobile devices. OSGi offers a class-loading mechanism to dynamically load/unload modules (bundles in the OSGi terminology). This feature is particularly interesting to support the plug-ability of the MUSIC architecture. Plugability is required to tackle the heterogeneity in communication and service discovery technologies. It also allows the integration of an extensible set of customized context sensors and adaptation algorithms.</p><p>SOA is the cornerstone of both OSGi and MUSIC. The SOA implementation in OSGi is simple and efficient, based on fast Java method invocations and a service registry, which provides mechanisms to react on the appearance and disappearance of services (essential in mobile environments). However, OSGi lacks of distribution support because OSGi services only communicate within one Java VM. The Service Discovery and the Remoting Service jointly extend OSGi with transparent distribution support and provide an abstraction to dynamically incorporate realizations of different discovery and communication protocols.</p><p>The Service Discovery delegates requests for publishing and discovery to protocolspecific implementations of service discovery, which are plugged into the platform as OSGi services implementing the interface IServiceDiscoveryFactory. Currently, the Service Location Protocol (SLP) protocol based on jSLP <ref type="bibr" target="#b22">[22]</ref> and the Universal Plug and Play (UPnP) protocol based on the UPnP bundle of DomoWare <ref type="bibr" target="#b23">[23]</ref> are supported by the MUSIC platform.</p><p>The Remoting Service supports plug-ability in a similar way. Each protocolspecific realization implements the interface IExportFactory or IRemoteBindingFactory, and is registered as a service to the service registry. Currently, the remoting service has support for exporting and binding services using sockets messaging and UPnP. The Web Service support is under development by a lightweight SOAP engine and small footprint HTTP server <ref type="bibr">[24]</ref>. We create dynamic service proxies with the code generation library CGLIB <ref type="bibr" target="#b24">[25]</ref>, and attach communication protocol-specific interceptors to the service proxies. The instrumentation of a service proxy with SLA monitoring mechanisms will be realized by adding monitoring interceptors to the proxy (e.g., to measure the response time).</p><p>MUSIC has chosen a set of lightweight frameworks and protocols to offer the best balance between performance in mobile devices and application requirements. The preliminary implementation of the TravelAssistant has demonstrated the good behavior of the MUSIC platform in a handheld device.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Discussions</head><p>As a preliminary validation of our approach, in this section we present a walk-through of how the middleware would behave in the scenario described in section 3.1. Table <ref type="table" target="#tab_0">2</ref> presents the realizations available for the different services with property predictors for the relevant properties. In addition to the properties defined in table 1, we also introduced cost, which is very relevant for 3 rd party services, and extended the utility function as follows: utility=0.6*norm(acc) + 0.1*(1-norm(bat))+ 0.3*(1-norm(cost)).</p><p>Based on this extended model we computed the utilities of the various configurations in different scenes. Table <ref type="table" target="#tab_1">3</ref> shows the utility of the best configurations in different situations during the scenario.</p><p>In the first three scenes of the scenario, the composition i) using the RATP Loca- tion, Map, and high quality Route services predicts the highest utility and is therefore chosen. In scene 4, the high quality RATP Map service breaks its SLA. The service proxy observes this and notifies the component SLA Monitoring, which terminates the agreement and triggers a re-planning. The Adaptation Manager predicts that using the commercial Map service instead now yields the highest utility and asks the Configuration Executor to reconfigure the application's service binding. This includes generating a corresponding service proxy. In scene 6, the device's GPS discovers the satellites and publishes the associated service plans into the Plan Repository. As this service provided by a local component is free and accurate, the adaptation manager predicts its use to have the highest utility and reconfigures accordingly.  The InstantSocial application appears to the user as a centralized application, while under the hood, each user runs its own IS instance in its own adaptation domain. The multi-user behavior emerges from the interactions among the IS instances servicesi.e., each IS instance offers services and uses services offered by the others. The utility function determines the composition and behavior of an individual instance depending on the local resource situation and the QoS of the used services, and therefore indirectly also on the composition and resource situation of the other instances. Thus, the user-visible shape of InstantSocial appears according to size and quality of the instances in the collection.</p><p>The composition of IS describes three roles: browser proxy (BP), presentation (P), and content repository (CR). The content repository component is responsible for maintaining an inventory of available content in all the participating devices and providing access to it. CR instances act both as consumers and providers of the membership service. When a new CR instance is created, it will use the membership service provided by an existing instance to become included in the common distributed content repository, and later it may provide this service to another new instance. CR instances also implement partial replication of content to ensure a certain stability of the federated repository even if participants leave. Presentation components monitor the content repository in order to find relevant content elements, according to user preferences. They present lists of relevant contents and selected content elements to the BP component. Browser proxy components execute as demons and invoke the built-in browser to present the user interface when InstantSocial is in the foreground.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related Work</head><p>Adaptive Service Grids (ASG) <ref type="bibr" target="#b25">[26]</ref> and VieDAME <ref type="bibr" target="#b26">[27]</ref> are initiatives enabling dynamic compositions and bindings of services for provisioning adaptive services. In particular, ASG proposes a sophisticated and adaptive delivery lifecycle composed of three sub-cycles: planning, binding, and enactment. The entry point of this delivery lifecycle is a semantic service request, which consists of a description of what will be achieved and not which concrete service has to be executed. VieDAME proposes a monitoring system that observes the efficiency of BPEL processes and performs service replacement automatically upon performance degradation. Compared to our planning-based middleware, ASG and VieDAME focuse only on the planning per request of service compositions with regards to the properties defined in the semantic service request. Thus, both approaches do not support a uniform planning of both components and services as our planning-based framework for ubiquitous applications does. However, our planning-based middleware can be extended to integrate ASG and VieDAME adaptive services and thus support the dynamic enactment of service workflows.</p><p>Menasce and Dubey <ref type="bibr" target="#b27">[28]</ref> propose a QoS brokering approach in SOA. Consumers request services from a QoS broker, which selects a service provider that maximizes the consumer's utility function with regards to its cost constraint. The approach assumes that service providers register with the broker by providing service demands for each of the resources used by the provided services as well as cost functions for each service. The QoS broker uses analytic queuing models to predict the QoS values of the various services that could be selected under varying workload conditions. This approach is of interest both from the viewpoint of a consumer and a provider. While the client is relieved from performing service discovery and negotiation, the provider is given support for QoS management. This approach, however, requires the client device to be able to access the broker, which might not be possible in ubiquitous environments. Our approach differs in that we consider the offered properties as alternatives to determine the best application configuration and allow the client to adapt to the service landscape.</p><p>CARISMA is a mobile peer-to-peer middleware exploiting the principle of reflection to support the construction of context-aware adaptive applications <ref type="bibr" target="#b28">[29]</ref>. Services and adaptation policies are installed and uninstalled on the fly. CARISMA can automatically trigger the adaptation of the deployed applications whenever detecting context changes. CARISMA uses utility functions to select application profiles, which are used to select the appropriate action for a particular context event. If there are conflicting application profiles, then CARISMA proceeds to an auction-like procedure to resolve (both local and distributed) conflicts. Contrary to MUSIC, CARISMA does not deal with the discovery of remote services that can trigger application reconfigurations. However, the auction-like procedure used by CARISMA could be integrated in the MUSIC middleware as a particular negotiation protocol.</p><p>The conceptual models of both SeCSE (http://secse.eng.it) and PLASTIC (http://www.ist-plastic.org) focus on service-oriented systems. Inspired by the SeCSE model, the PLASTIC model extends it by introducing new concepts, such as context, location, and service level agreements. The MUSIC and the PLASTIC model have in common that both combine SOA and component-based software development. However, the MUSIC conceptual model uses a component-centric approach, while the PLASTIC model uses a service-centric approach.</p><p>Finally, R-OSGi extends OSGi with a transparent distribution support <ref type="bibr" target="#b29">[30]</ref> and uses jSLP to publish and discover services <ref type="bibr" target="#b22">[22]</ref>. The communication between a local service proxy and the associated service skeleton is message-based, while different communication protocols (e.g., TCP or HTTP) can be dynamically plugged in. In contrast to R-OSGi, the discovery and binding frameworks of MUSIC are open to support a larger range of discovery and communication protocols.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion and Perspectives</head><p>In this paper we have introduced the design of a QoS-driven generic planning framework for self-adaptive mobile applications, which seamlessly supports and blends component-based and service-based configurations. In particular, we have shown that the framework is able to adapt to changes in a landscape of ubiquitous remote services that dynamically come and go, and where the offered service qualities vary. The framework exploits these changes to maximize the overall utility of applications. To that aim, the paper has shown how the planning middleware discovers remote services and evaluates them as alternative providers for the functionalities required by an application. The planning framework deals directly with SLA protocols supported by the services to negotiate the best QoS for the end-user. The current MUSIC platform has already implemented the binding and discovery of services with a range of wellknown technologies, while the SLA support is currently under development.</p><p>As a preliminary validation of our approach, the paper also explained how the planning framework handles a use case in which the TravelAssistant and the Instant-Social applications of a mobile user exploit ubiquitous services, such as location, map, and content services, to improve their utility whenever such services become available. The TravelAssistant has successfully validated the service binding and discovery, and will be enhanced in future releases. InstantSocial will be developed by the end of the MUSIC project (http://www.ist-music.eu).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Example model for a TravelAssistant application</figDesc><graphic coords="4,42.18,418.10,345.42,67.51" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Table 1 .det 10 rel 10 batFig. 3 .</head><label>110103</label><figDesc>Fig. 3. Architecture of the MUSIC platform</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>‚Ä¢</head><label></label><figDesc>Dynamic discovery of services,‚Ä¢ Dynamic binding and change of binding to service providers,‚Ä¢ Negotiation of service level agreements and detection of violations,‚Ä¢Hosting and publishing of services.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. SOA configuration of the MUSIC platform</figDesc><graphic coords="12,48.66,55.40,332.88,210.60" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="5,43.14,55.40,343.92,156.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 2 .</head><label>2</label><figDesc>Services defined in the TravelAssistant application</figDesc><table><row><cell cols="2">Service Description</cell><cell>Provider</cell><cell>Level</cell><cell>Property predictors</cell></row><row><cell cols="2">Location Locates the device</cell><cell>RATP</cell><cell></cell><cell>cost=0, acc=5, bat=1</cell></row><row><cell></cell><cell>geographically</cell><cell>Local component</cell><cell></cell><cell>cost=0, acc=7 if GPS</cell></row><row><cell></cell><cell></cell><cell>using the builtin</cell><cell></cell><cell>signal, 0 otherwise,</cell></row><row><cell></cell><cell></cell><cell>GPS</cell><cell></cell><cell>bat=3</cell></row><row><cell>Map</cell><cell cols="2">Provides a map of a limited RATP</cell><cell>basic</cell><cell>cost=0, det=1, bat=2</cell></row><row><cell></cell><cell>area</cell><cell>RATP</cell><cell cols="2">detailed cost=5, det=9, bat=4</cell></row><row><cell></cell><cell></cell><cell>3 rd party</cell><cell></cell><cell>cost=9, det=9, bat=4</cell></row><row><cell>Route</cell><cell>Computes best route and</cell><cell>RATP</cell><cell>basic</cell><cell>cost=0, rel=1, bat=1</cell></row><row><cell></cell><cell>estimated travel time</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>RATP</cell><cell cols="2">reliable cost=5, rel=7, bat=1</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 3 .</head><label>3</label><figDesc>Some alternative configurations and utilities of the TravelAssistant</figDesc><table><row><cell></cell><cell>Configuration</cell><cell></cell><cell></cell><cell>Utility</cell><cell></cell></row><row><cell>Location</cell><cell>Map</cell><cell>Route</cell><cell>Scene 1</cell><cell>Scene 4</cell><cell>Scene6</cell></row><row><cell>RATP</cell><cell>RATP detailed</cell><cell>RATP reliable</cell><cell>0,64</cell><cell>-</cell><cell>-</cell></row><row><cell>RATP</cell><cell>3 rd party</cell><cell>RATP reliable</cell><cell>0,56</cell><cell>0,56</cell><cell>0,56</cell></row><row><cell>builtinGPS</cell><cell>3 rd party</cell><cell>RATP reliable</cell><cell>-</cell><cell>-</cell><cell>0,58</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>For example, the service consumer needs the remote service URL in order to access it. In case of a RMI-based binding, this URL would be rmi://localhost:8080/EchoService. While, in case of a Web Service, the URL is the location of the WSDL document, e.g., http://localhost:8090/axis2/services/EchoService?wsdl for the Echo Service.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. We would like to thank our partners of the MUSIC project for valuable comments. This work was partly funded by the European Commission through the project MUSIC (EU IST 035166).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Mobile Computing Middleware</title>
		<author>
			<persName><forename type="first">C</forename><surname>Mascolo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Capra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Emmerich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NETWORKING 2002</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Gregori</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Anastasi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Basagni</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2497</biblScope>
			<biblScope unit="page" from="20" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Composing Components and Services using a Planning-based Adaptation Middleware</title>
		<author>
			<persName><forename type="first">R</forename><surname>Rouvoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SC 2008</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Pautasso</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">√â</forename><surname>Tanter</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4954</biblScope>
			<biblScope unit="page" from="52" to="67" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">K</forename><surname>Geihs</surname></persName>
		</author>
		<title level="m">A comprehensive solution for application-level adaptation. Software: Practice and Experience</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Scalability of Decision Models for Dynamic Product Lines</title>
		<author>
			<persName><forename type="first">G</forename><surname>Brataas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. Work. on Dynamic Software Product Line</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
	<note>DSPL</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Using Architecture Models for Runtime Adaptability</title>
		<author>
			<persName><forename type="first">J</forename><surname>Floch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Construction and Execution of Adaptable Applications Using an Aspect-Oriented and Model Driven Approach</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Lundesgaard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DAIS 2007</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Indulska</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Raymond</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4531</biblScope>
			<biblScope unit="page" from="76" to="89" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Architectural Constraints in the Model-Driven Development of Self-Adaptive Applications</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">U</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Reichle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Geihs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Distributed Systems Online</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">7</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">InstantSocial -Implementing a Distributed Mobile Multi-user Application with Adaptation Middleware</title>
		<author>
			<persName><forename type="first">L</forename><surname>Fraga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hallsteinsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Scholz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EASST Communications</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A shared service terminology for online service provisioning</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Baida</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th Int. Conf. on Electronic commerce</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">The service engineering area: An overview of its current state and a vision of its future. European Commission. Network and Communication Technologies</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sassen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Macmillan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>Software Technologies</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Service-Oriented Architecture: Concepts, Technology, and Design</title>
		<author>
			<persName><forename type="first">T</forename><surname>Erl</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<publisher>Prentice Hall</publisher>
			<pubPlace>Englewood Cliffs</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Web service differentiation with service level agreements</title>
		<author>
			<persName><forename type="first">A</forename><surname>Dan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ludwig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pacifici</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>IBM White Paper</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Andrieux</surname></persName>
		</author>
		<title level="m">Web Services Agreement Specification (WS-Agreement)</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>Open Grid Forum Recommended Specification</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">An Adaptive Middleware to Overcome Service Discovery Heterogeneity in Mobile Ad Hoc Environments</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Flores-Cort√©s</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Blair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Grace</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Distributed Systems Online</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">7</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The WSLA Framework: Specifying and Monitoring Service Level Agreements for Web Services</title>
		<author>
			<persName><forename type="first">A</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ludwig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Network and Systems Management</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Monitoring Middleware for Service Level Agreements in Heterogeneous Environments</title>
		<author>
			<persName><forename type="first">G</forename><surname>Morgan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">5th Int. Conf. on e-Commerce, e-Business, and e-Government (I3E)</title>
		<meeting><address><addrLine>Poznan, Poland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">189</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Ambient-Oriented Programming</title>
		<author>
			<persName><forename type="first">J</forename><surname>Dedecker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Companion of the 20th Ann. Conf. on Object-Oriented Programming, Systems, Languages, and Applications</title>
		<imprint>
			<publisher>OOP-SLA</publisher>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Concierge: a service platform for resource-constrained devices</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Rellermeyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Alonso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2nd Eur. Conf. on Computer Systems (EuroSys)</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName><surname>Jcp</surname></persName>
		</author>
		<author>
			<persName><surname>Osgi</surname></persName>
		</author>
		<ptr target="http://jcp.org/en/jsr/detail?id=232" />
		<title level="m">Mobile Specification (JSR-232)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Embedded Rich Client Platform</title>
		<author>
			<persName><surname>Eclipse</surname></persName>
		</author>
		<ptr target="http://www.eclipse.org/ercp" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Rellermeyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Kuppe</surname></persName>
		</author>
		<ptr target="http://jslp.sourceforge.net" />
		<title level="m">jSLP</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Demuru</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Furfari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lenzi</surname></persName>
		</author>
		<ptr target="http://www.eclipse.org/equinox/server/http_in_equinox.php" />
		<title level="m">Equinox. OSGi HTTP Server</title>
		<imprint>
			<publisher>DomoWare</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Baliuka</surname></persName>
		</author>
		<ptr target="http://cglib.sourceforge.net" />
		<title level="m">Code Generation Library (CGLIB)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Implementing a Semantic Service Provision Platform -Concepts and Experiences</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kuropka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Weske</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Wirtschaftsinformatik Journal</title>
		<imprint>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="16" to="24" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Non-intrusive monitoring and service adaptation for WS-BPEL</title>
		<author>
			<persName><forename type="first">O</forename><surname>Moser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Rosenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dustdar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">17th Int. Conf. on World Wide Web (WWW)</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Utility-based QoS Brokering in Service Oriented Architectures</title>
		<author>
			<persName><forename type="first">D</forename><surname>Menasce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Dubey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conf. on Web Services (ICWS</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">CARISMA: Context-Aware Reflective Middleware System for Mobile Applications</title>
		<author>
			<persName><forename type="first">L</forename><surname>Capra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Emmerich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Mascolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">10</biblScope>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">R-OSGi: Distributed Applications Through Software Modularization</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Rellermeyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Alonso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Roscoe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Middleware 2007</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Cerqueira</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Campbell</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4834</biblScope>
			<biblScope unit="page" from="1" to="20" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
