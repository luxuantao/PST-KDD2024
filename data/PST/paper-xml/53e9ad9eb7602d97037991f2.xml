<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Science of Computer Programming</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2008-09-23">23 September 2008</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Irem</forename><surname>Aktug</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Royal Institute of Technology</orgName>
								<address>
									<settlement>Stockholm</settlement>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Katsiaryna</forename><surname>Naliuka</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">University of Trento</orgName>
								<address>
									<settlement>Trento</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Royal Institute of Technology</orgName>
								<address>
									<addrLine>Osquars Backe 2, 100 44 Stockholm</addrLine>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Science of Computer Programming</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2008-09-23">23 September 2008</date>
						</imprint>
					</monogr>
					<idno type="MD5">17D7BD6FF65B5EC88DFCC059FE2C32E2</idno>
					<idno type="DOI">10.1016/j.scico.2008.09.004</idno>
					<note type="submission">Received 1 April 2008 Accepted 3 September 2008</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:39+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Policy language Security enforcement mechanisms Runtime monitoring Security frameworks</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The paper presents ConSpec, an automata-based policy specification language. The language trades off clean semantics to language expressiveness; a formal semantics for the language is provided as security automata. ConSpec specifications can be used at different stages of the application lifecycle, rendering possible the formalization of various policy enforcement techniques.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>As mobile devices become increasingly popular, the problem of secure mobile application development gains importance. Mobile devices contain personal information, which users desire to protect. They also provide access to costly functionality, such as GSM services and GPRS connections. Hiding these resources from third-party applications would largely handicap application development for mobile platforms. It seems necessary to provide controlled access to the sensitive resources through fine-grained, at times application specific, constraints on execution.</p><p>A security policy selects a set of acceptable executions from all possible executions and is used to define how and under what conditions a sensitive resource can be accessed. For instance, a user policy may limit the number of SMSs that are sent by an application per hour in order to prevent spamming. The decision for allowing access to a requested resource at a certain point of the program execution may depend on various factors, such as the previous actions of the application, the state of the environment, the parameters of the request, etc. The user may want to forbid the sending of SMSs, for instance, after an application has accessed certain local files.</p><p>A program adheres to a policy if all its executions are in the set of executions selected by the policy. Several techniques exist to ensure that an application complies to a policy. Static verification techniques, such as model checking, analyze the program code in order to construct a mathematical proof that no execution of the program can violate the policy. Such an analysis is thorough and provides full assurance, at the same time, it is costly and often requires human interaction. Runtime monitoring can be used as an alternative to static checking. This security enforcement mechanism observes the behavior of a target program and terminates it if it does not respect the policy. Monitoring can effectively enforce many interesting security properties <ref type="bibr" target="#b15">[16]</ref>. However, it creates performance overhead since each security relevant action of the program should be detected and checked against the policy. Monitoring may be performed explicitly, i.e. by a separate program which is co-executed (executed in parallel) with the untrusted application. Due to expensive interprocess communication however, this technique is costly. In order to reduce this overhead, the monitor can instead be inlined in the untrusted program (see for instance <ref type="bibr" target="#b5">[6]</ref>). Then, the code of the program is interleaved with the code of the monitor.</p><p>We describe here first how security specifications can be enforced at the three stages of the application lifecycle: the development, installation and runtime phases. The approach that we present here combines static verification and monitoring to enforce security properties on mobile devices in the most effective way. We associate with the application a contract <ref type="bibr" target="#b4">[5]</ref>, a piece of data that describes its security-relevant behavior and simplifies tasks related to security enforcement. A framework which spans different stages of the application lifecycle and combines different techniques for ensuring compliance benefits from a common language for policy specification. In turn, the different aspects of the framework imposes different restrictions on such a language. The main contribution of this paper is the language ConSpec (Contract Specification Language) which can be used for specifying both user policies and application contracts. A semantics for a subset of ConSpec is provided and the formal treatment of several activities in the framework is briefly explained based on this semantics.</p><p>The paper is structured as follows. In Section 2, we describe the lifecycle of the application paired with its contract. In Section 3, we discuss design decisions behind ConSpec, present its syntax and give a formal semantics to ConSpec. Discussion of the related work and final remarks Section 5 end the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Security enforcement in the application lifecycle</head><p>In this section, we describe how security enforcement techniques can be applied throughout the lifecycle of an application and how the goals of all participants can be achieved in the contract-aware framework. The lifecycle of the application and the activities associated with each development phase are illustrated in Fig. <ref type="figure" target="#fig_0">1</ref>. We make use of the following scenario in the rest of the section:</p><p>Companies Alpha and Beta produce applications for mobile devices. Alpha develops application Weather that every morning at a user-defined time sends an SMS message to the operator's weather service and displays to the user the forecast it receives. Application HappyBirthday, produced by Beta, checks the user's address book and sends a congratulation SMS to each contact that has a birthday. Both companies want their applications to be used by as many users as possible.</p><p>Alice is a mobile device user. She wants to download and use third-party applications. But she does not want these applications to break the following policy: ''An application must not send more than 5 SMS messages per day''. She also dislikes messages being sent to multiple addresses, as this can be used for spamming. So her other requirement is that ''Each message can be sent to only a single phone number''. Development phase. We assume that the developer is aware of typical security policies and is willing to keep his application in conformance with them. It is sufficient that the developer is aware of which resources (and therefore which actions of the application) are security-relevant. Using this information he/she provides the application with a contract, which specifies the intended security-relevant behavior of the application. At this phase, the policy language is used for expressing this contract. The compliance of the contract and the application can be checked, for instance, using static verification by a trusted third party, who then signs the application and the contract by its private key. This analysis is performed by powerful machines rather than the mobile devices, and can make use of knowledge available to the developer (e.g. program specifications, annotations derived from the source code, etc.). Instead of code-signing, proof-carrying code (PCC) can be used to convey assurance in program-contract compliance <ref type="bibr" target="#b14">[15]</ref>. The application and the contract are supplied with an easy-to-check proof of their compliance. Instead of statically verifying contract compliance, the compliance can be enforced at runtime by inlining a monitor for the contract in the application.</p><p>In our example scenario Alpha and Beta are not aware about the particular limit of SMS messages that Alice allows. But they know that the number of messages matters. Therefore, Alpha supplies the Weather application with the contract that the application sends only one message per day. Also, as the application sends messages only to the operator's weather service, they guarantee in the contract that all messages are sent to a single phone number. Whereas, Beta developers know that the messages that their application sends can be directed to various addresses. But, as the HappyBirthday application sends congratulations to each contact individually, the contract states that each message is directed to one phone number. However, Beta developers still cannot tell in advance how many messages their application sends per day. For this reason, the contract for their application is more complex. It says that the application will send one message to every contact from the address book that has a birthday. Installation phase. Before the program is installed on the device, a formal check is needed to show that the security-relevant behavior of the application given by the contract is acceptable by the user policy. If policies and contracts are captured with automata on infinite strings, the problem of matching a policy against a contract reduces to the language containment problem for such automata. The complexity of this task severely restricts the expressive power of the policy language (for example, the problem of language containment is undecidable for two context-free languages <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>). When the problem is decidable, however, contract-policy matching is much simpler than checking the program against the policy itself, and is more likely to be feasible on a mobile device <ref type="bibr" target="#b4">[5]</ref>.</p><p>In our scenario, the contract of Weather can be matched against Alice's policy ''No more than 5 messages per day''. Also the rule ''All messages are sent to a single number'' matches Alice's requirement ''Each message is sent to a single number''. So this application is permitted to run at the device without any modifications. HappyBirthday's contract also satisfies this second requirement. Its contract can still not be matched against the entire policy due to the lack of information on the precise number of messages the program can send. It can run on the device only if it undergoes inlining.</p><p>A policy that is not covered by the contract can be enforced by monitoring. If the program is to be monitored explicitly, hooks that notify the monitor about ongoing security-relevant activity should be injected to the program in the installation stage, i.e. prior to execution. If the monitoring task is to be optimized in order to reduce runtime overhead, the monitor for the desired policy should be inlined into the program at this stage.</p><p>For instance, application Weather does not need to undergo inlining since its compliance to the user's policy has already been verified. But a monitor for Alice's policy can inlined in the HappyBirthday application to ensure that the application does not send more than 5 messages. Runtime. At runtime, a security policy can be enforced on the application by monitoring. Because of the performance overhead created by monitoring, it is preferable to use static methods described above and leave as little work to runtime as possible. But in many cases, the application of other techniques is not feasible (or not even possible due to, for example, the unavailability of the source code), and runtime monitoring is the only solution to protect a system.</p><p>In our setting, application Weather will not be monitored. But HappyBirthday will, and if a violation is detected (that is, if the application is trying to send the 6th message), it will be terminated. The behavior of the program will otherwise be unaltered (except for the slight performance deterioration due to monitoring) and the user will be able to freely enjoy its functionality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">ConSpec language</head><p>ConSpec is a policy language intended for programs written in intermediate object-oriented languages such as the bytecode languages of Java and .NET. Security relevant actions are taken as method invocations, more specifically system calls or invocations of API methods. The intention behind ConSpec is to design a language that can be exploited both for specification of requirements and for the description of the security-relevant behavior of actual systems. For this reason, the formalism selected is based on automata, which have been used for both purposes. For instance, the SPIN tool <ref type="bibr" target="#b8">[9]</ref> inputs system specifications as models written in the guarded-command language Promela and performs model checking on the Büchi automata extracted from these models. Security properties are also expressed as automata in various approaches (e.g. <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17]</ref>).</p><p>ConSpec is strongly inspired by the policy specification language PSLang, which was developed by Erlingsson and Schneider <ref type="bibr" target="#b5">[6]</ref> for runtime monitoring. PSLang policies consist of a set of variable declarations, followed by a list of security relevant events, where each event is accompanied by a piece of Java-like code that specifies how the security state variables should be updated in case the event is encountered in the current state. PSLang policies make monitor inlining simple: the updates provided by the user can be almost directly inserted into the target program. However, this leads for making specifications less formal. A policy text is intended to encode a security automaton: the state variables represent the automaton states and updates represent transitions. While this intuition is given, the exact way to extract the automaton from a PSLang policy is not provided. Such a task is not trivial due to the power of the programming language constructs that can be used in the updates.</p><p>Further we provide a formal semantics which maps ConSpec policies, which are on single executions of an application, to formal objects that can be used in constructing mathematical proofs. It is important to note that ConSpec is a more restricted language than PSLang; this is a design decision taken in order to allow application of formal methods for all stages of the development process, and not just runtime monitoring. More specifically, ConSpec does not allow arbitrary types in representing the security state and restricts the way the security state variables are updated. We have used a guardedcommand language for the updates where the guards are side-effect free and commands do not contain loops. The simplicity of the language then allows for a comparatively simple semantics. While the general ConSpec, which is the common language for all tasks in the application lifecycle, is to be kept as simple as possible, specific tasks may allow certain extensions. For instance, while putting conditions on heap objects make matching undecidable, these are easily handled by monitor inlining. A table that shows which features can be supported by different tasks is included in the Appendix.</p><p>Example 1. Assume method Open of class File is used for creating files (when argument mode has value ''CreateNew'') or for opening files (mode is ''Open''), either for reading (argument access is ''OpenRead'') or for writing. 1 Assume further that method Open of class Connection is used for opening connections, that method AskConnect is used for asking the user for permission to open a connection and that this latter method returns true in case of approval. Now, consider the security policy, which allows applications to access existing files for reading only, and requires, once such a file has been accessed, applications to obtain approval from the user each time a connection is to be opened. The policy also does not allow the application to execute further if a file opening operation raises an exception. This policy can be specified in ConSpec as follows: We begin by specifying that the policy applies to each single execution of an application. Scope declaration is followed by the security state declaration: the security state of the example policy is represented by the boolean variables accessed and permission, which are both false initially to mark, respectively, that no file has been accessed and that no permissions are granted when the program begins executing. The example policy contains three event clauses that state the conditions for and effect of the security relevant actions: call to the method File.Open, call to the method Connection.Open and return from the method GUI.AskConnect. The types of the method arguments are specified along with representative names, which have the event clause as their scope. The modifiers BEFORE and AFTER mark whether the call of or the normal return from the method specified in the event clause is security relevant (exceptional returns can be specified by the modifier EXCEPTIONAL). Event clauses contain guards and associated updates to the security state variables.</p><p>The restriction that the application should not overwrite local files is specified by the first event clause. Whatever the execution history, whenever the application calls the method File.Open, it should be creating a new file (the first guard) or it should be opening an existing file for reading (the second guard). If neither of these conditions hold for the current call.</p><p>In order to decide if the application is allowed to open a connection, history of existing file accesses and user permissions is consulted. An access to an existing file through a call to File.Open is recorded by the update block of the second guard in the event clause. If the current history contains an access to an existing file (that is if accessed is true), then an attempt to open the connection is allowed only if the security state variable permission is true. The only way this variable is true at a certain point in the execution is, if the last execution of the method GUI.AskConnect has returned ''true''. Notice that the policy does not allow the same permit to be used for several connections since permission is set to false before each connection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">ConSpec syntax</head><p>Fig. <ref type="figure" target="#fig_3">2</ref> summarizes the syntax of ConSpec policies. States. The security state variables of ConSpec are restricted to the primitive types (PrimType ): booleans, integers, and strings. ConSpec files set a limit on values of the type int which consist of some initial segment of natural numbers. Similarly, maximum length of strings are specified. (We have skipped these in the example policy.) This aims to limit the state space of 1 The methods used in this policy are not part of any standard API but have been chosen for the sake of the example.  the corresponding automata, in order to enable matching. The Scope construct is used for expressing security requirements on different levels and explained in more detail below. Event clauses. An event clause (Fig. <ref type="figure" target="#fig_3">2(b</ref>)) gives us a security relevant action and its modifier. Security relevant events are bound to the API methods in the program (we support programs delivered in either Java or .NET intermediate bytecode language). In order to resolve which method is of interest in case of overloading, the argument types of the method is to be specified as part of the action specification. The security relevant action is then fully specified by its signature which consists of the name of the method, the class to which the method belongs and the types of its arguments. The signature of an event clause is defined as the signature of the method associated with it. In ConSpec policies, all event clauses with the same modifier have a unique signature. This restriction means that one can not, for example, have two BEFORE clauses for the same method and has been imposed in order to ensure determinism. Notice that since the signature does not include the type of the return variable, it is not possible to have two AFTER event clauses for the same method, even if they do not agree on the return variable types. The modifier states when the update to the state will be performed: before the event, after the event or immediately after the throwing of an exception by the event.</p><p>Guards and update blocks. The event specification is followed by a sequence of guard-update block pairs. The update specifies how a state will be updated for the security relevant action while the guard selects the states, which the particular update will apply, as a subset of all states. The guards are evaluated top to bottom and the update corresponding to the first guard that holds, is performed. In case none of the guards evaluates to true, there is no transition for that action from the current state, unless an ELSE block is present, in which case the update of this block is executed. The guard is a side-effect free boolean expression which can mention only the set of argument values (and the return value when the AFTER modifier is used), and the security state. The update block begins with declarations of the local variables, which have the current block as their scope. A list of assignments to local variables and security state variables follow the declarations. If no assignments are present, the update block consists of the statement skip. The expression language used for forming guards and right hand side of assignments are explained below.</p><p>Expressions. The expression language of ConSpec has been designed to ensure that checking language containment of the induced automata (the matching problem) is decidable. Variables except security state and local variables can be of any type in Type, which includes both primitive types and classes. The expressions on integers are built using basic arithmetic and comparison operators. Strings can be checked for equality and the prefix relation using the functions equals and beginsWith, respectively. The expression language of ConSpec can potentially be extended with calls to other side-effect free functions. Expressions can also include field accesses using object references, expressed by the ''.'' operator. Regardless of the modifier used, accesses to fields of method arguments are interpreted on the heap at the time of call, while accesses to fields of the return value are interpreted at the time of return. Therefore, it is not, as of yet, possible to put constraints on the fields of a method argument at the time of return. The last field accessed in a field access expression should always be of one of the primitive types.</p><p>Example 2. Consider the contract of the Weather application described in Section 2. The contract imposes two restrictions on the program execution: it states that only one message can be sent by the application each day, and that all messages are directed to a single phone number, that cannot be changed during the program lifetime. We assume that this is the first number the message is sent to. The corresponding contract is expressed in ConSpec as shown below.</p><p>The security state of this contract includes the integer variable lastmessageday that stores the date the last message was sent, and the string usednumber, which is used to record the phone number of the first recipient.</p><p>The example contract contains one event clause bound to the .NET API call WindowsMobile.PocketOutlook. SmsMessage.Send(). This API call does not contain parameters. Particulars of, and all particularities about the message are stored in the fields of the SmsMessage object itself. In the contract below, the first guard-update block pair relates to the case when the application sends a text message for the first time. In this case the string usednumber is not associated with a value yet, so we check that the message is directed to one number only, and record this number and the current date for future comparison. If it is not the first time the message is being sent, we check that the date has changed since the time the last text message was sent in the second guard-update block pair. We also check that the message is directed to only one number, and that this number is the one that we recorded previously. If these conditions are met then the message is allowed to be sent, and the date is again recorded for future use. The contract is violated in an execution if and only if neither of the guards are satisfied by a call to the security-relevant method in the execution. This indicates that the application tried to send a message when it was forbidden to do so by the security requirements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SCOPE Session SECURITY STATE</head><p>int lastmessageday = 1; string usednumber = " "; BEFORE WindowsMobile.PocketOutlook.SmsMessage.Send() PERFORM usednumber == " " &amp;&amp; this.To.Count == 1 -&gt; { lastmessageday = Now.GetDay(); usednumber = this.To[0]; } this.To.Count == 1 &amp;&amp; this.To[0] == usednumber &amp;&amp; !Now.GetDay().equals(lastmessageday -&gt; { lastmessageday = Now.GetDay(); }</p><p>In this example, we have used two extensions to ConSpec. One is the use of array variables. The other is the occurrence of (side-effect free) API methods in guards and update blocks. Both extensions are easily accommodated in ConSpec. Scopes. Case studies show that many interesting real-life policies concern the entire execution history rather than a single run of the application <ref type="bibr" target="#b18">[19]</ref>. However, most policy languages (including PSLang) do not contain the feature of distinguishing between events in the current run and in the previous runs. ConSpec is expressive enough to write policies on multiple executions of the same application (scope Multisession) and on executions of all applications of a system (scope Global), in addition to policies on a single execution of the application (scope Session) and on lifetimes of objects of a certain class (scope Object). The syntax of persistent state declaration is similar to security state declaration and aims to specify the state that is preserved across single executions when the scope is Multisession or Global. When the scope is Object, the security state declaration specifies the state local to each object of the class, while the persistent state is equivalent to the security state of scope Session, that is the security state of the application for a single execution.  Val. The types of objects are not further specified here; it is sufficient to assume that the policies are type-correct.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1.">ConSpec automata</head><p>In ConSpec automata, security relevant actions are method calls, represented by the class name and the method name of the method, along with a sequence of values that represent the actual argument list of the method. We partition the set of security relevant actions into a set of pre-actions A and a set of post-actions A , corresponding to method invocations and returns. Both refer to the heap prior to method invocation, while the latter also refers to the heap upon termination and to a return value from RVal = Val ∪ {exc, ε} where ε and exc are used to model return from a void method and return on an exception raised during the method call.</p><formula xml:id="formula_0">A ⊆ C × M × Val * × H A ⊆ RVal× C × M × Val * × H × H.</formula><p>The partitioning on security relevant actions induces a corresponding partitioning on the transition function δ of ConSpec automata. We present a deterministic version of security automata.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1 (ConSpec Automaton).</head><p>A ConSpec automaton is a tuple A = (Q , A, δ, q 0 ), where:</p><formula xml:id="formula_1">(i) Q is a countable set of states, (ii) q 0 ∈ Q is the initial state, (iii) A = A ∪ A is</formula><p>a countable set of security relevant actions as described above, and (iv) δ = δ ∪ δ is a (partial) transition function, where δ :</p><formula xml:id="formula_2">Q × A Q and δ : Q × A Q .</formula><p>Methods which are considered security relevant are API methods and hence the actions of a ConSpec automaton corresponds to method calls and returns. In general, it may not be possible to determine the value that will be returned by a method just by inspecting its arguments (e.g. when the method is interacting with the user or when the method is native and its semantics is not available). Furthermore, in the context of runtime enforcement, it might not be possible to prevent a method return. For instance, this is the case when inline monitoring is used and libraries are to be shared between applications with different security constraints. Therefore, the enforcement language of a ConSpec automaton A is defined as the set L A ∪ L A • A , where L A is the language of A in the standard sense. It is the enforcement language which defines the security policy induced by a ConSpec automaton. This means that, for any ConSpec policy, even if there is no transition for a post-action from the current state, the sequence is compliant with the policy as long as no more security relevant actions are performed by the application.</p><p>The translation from policy text to ConSpec automata is described below. It is sometimes more desirable to work with symbolic entities, however. In <ref type="bibr" target="#b0">[1]</ref>, symbolic security automata are introduced. These automata are symbolic since the single state is the set of security state variables of the policy, and transitions are labeled by an action (class name, method name, formal arguments), a boolean ConSpec expression which is the guard, and a function from security state variables to ConSpec expressions which represents an update block. The conversion from such symbolic automata to ConSpec automata involves constructing the state space reachable from the initial values of the security variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2.">The automaton induced by a policy</head><p>The semantics of a ConSpec policy P is given in terms of a ConSpec automaton A P = (Q , A, δ, q 0 ) as described below.</p><p>States. The set of states Q of A P , also called security states, is determined by the declarations in the SECURITY STATE block of the policy P . Consider the security state declaration of P :</p><formula xml:id="formula_3">SECURITY STATE τ s 1 s 1 = v 1 . . . τ s k s k = v k</formula><p>The set of variable names that are induced by such a state declaration is the set of security state variables. SVar = {s 1 , . . . , s k }.</p><p>The states q ∈ Q of the automaton are mappings from variable names to values which respect the types of the security state variables: q : SVar → Val. The initial state q 0 simply maps the security state variables to their initial values:</p><formula xml:id="formula_4">∀s i ∈ SVar. q 0 (s i ) = v i .</formula><p>Actions. The actions A of the automaton are determined by the events mentioned in event clauses of the policy.</p><p>• An action a = c, m, (v 1 , . . . , v n ), h is a security relevant pre-action, if and only if the ConSpec policy contains an event clause with the BEFORE modifier and the event c.m (τ 1 x 1 , . . . , τ n x n ),</p><p>• Similarly, an action a = r, c, m, (v 1 , . . . , v n ), h, h where r is a value v or ε is a security relevant (non-exceptional) post-action, if and only if the ConSpec policy contains an event clause with modifier AFTER followed by ''τ x = '' and the event c.m (τ 1 x 1 , . . . , τ n x n ) or only the event c.m (τ 1 x 1 , . . . , τ n x n ), respectively.</p><p>• Finally, an action a = exc, c, m, (v 1 , . . . , v n ), h is a security relevant (non-exceptional) post-action, if and only if the ConSpec policy contains an event clause with modifier EXCEPTIONAL and the event c.m (τ 1 x 1 , . . . , τ n x n ).</p><p>In all three cases, the types of the arguments (and the type of the return value) specified in the event clause should match the components of the action, i.e.</p><formula xml:id="formula_5">v 1 ∈ τ 1 , . . . , v n ∈ τ n , v ∈ τ .</formula><p>Notice that the set of actions is to be a countable set, although it may be infinite (for instance if one of the arguments of a method is not of a primitive type). Care must be taken on the heap components when constructing the set of actions. In order to assure countability, the set of all heaps H can be taken as the set of all partial heaps, where a partial heap is the part of the heap reachable through a field access. It is always possible to determine the field access expression with the most number of accesses in a policy and use this depth to bound the size of the set H.</p><p>Transitions. Each event clause of the policy induces a partial transition function. The transition functions δ and δ of the automaton are the union of the partial functions corresponding to event clauses with the BEFORE and AFTER/EXCEPTIONAL modifier, respectively. The definition of the partial functions is similar for both types of event clauses. For brevity, here we only describe the latter case, which is slightly more general.</p><p>Consider an AFTER event clause φ :</p><formula xml:id="formula_6">AFTER τ r = c.m (τ 1 x 1 , . . . , τ n x n ) PERFORM G 1 -&gt; U 1 . . . G m -&gt; U m</formula><p>Let AVar = {x 1 , . . . , x n } be the set of formal arguments of the event and PVar = {r} ∪ AVar be the set of all program variables of the event clause. Below, let states q ∈ Q be as defined above, and let σ : PVar → Val range over the set Σ of mappings from program variables to values which respect the declared types of the variables. For guards G j and update blocks U j of the event clause, we assume the semantic functions:</p><formula xml:id="formula_7">G j : Q × Σ × H × H → {true, false} U j : Q × Σ × H × H → Q</formula><p>where the two heaps in the function types refer to the heap of the program before and after the execution of the method call, respectively. The ELSE keyword used as a guard would then correspond to the guard true.</p><p>Semantics of field access expressions occurring in guards and update blocks are relativized on heaps. The heap is not changed by the automata, but is used to look up fields of object references. To fetch the field values of method arguments, the heap at the time of call is accessed. In order to get the field values of the return value, however, heap at the time of return is used. Below, we denote the heap before the call with h , and the heap after the call with h . Then, the value of a field access expression with depth k is as follows:</p><formula xml:id="formula_8">x.f 1 .f 2 . . . .f k = (h (. . . (h (h σ (x) f 1 ) f 2 ) . . .) f k ) if x ∈ AVar (h (. . . (h (h σ (x) f 1 ) f 2 ) . . .) f k ) if x = r.</formula><p>Then, the event clause φ induces a partial mapping f φ : Q × A Q as follows. For a security state q and postaction a = v, c, m, (v 1 , . . . , v n ), h , h , we define f φ (q, a) = q if there exists 1 ≤ i ≤ m such that:</p><p>• G j (q, σ , h , h ),</p><p>• ∀i &lt; j.¬( G i (q, σ , h , h )) and • U j (q, σ , h , h ) = q where σ : PVar → Val is the valuation given by the correspondence of actual (v 1 , . . . , v n , v) to formal parameters (x 1 , . . . , x n , r). This definition captures that the guards are evaluated in order from top to bottom in order to select the right update block.</p><p>Finally, the post-transition function δ is the union of the functions induced by each event clause (with disjoint domains):</p><formula xml:id="formula_9">δ = φ ∈P f φ .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">ConSpec in use</head><p>The main advantage of ConSpec is that it allows for a formal treatment of the various enforcement techniques mentioned in Section 2 through its automata-based semantics. Here we briefly explain how this can be achieved. Matching. One way to match a ConSpec contract against a ConSpec policy is to check that the language of the contract automaton is included in the language of the policy automaton. Since the domains of the security state variables are bounded, the extracted automata have finitely many states (but possibly infinitely many transitions) and standard methods for checking language inclusion for automata (see for instance <ref type="bibr" target="#b3">[4]</ref>) can be facilitated for contract-policy matching. Such an approach is taken in <ref type="bibr" target="#b13">[14]</ref> for matching contracts against policies, when both are expressed as automata modula theory (AMT ), a type of symbolic Büchi automata. ConSpec policies can be converted to AMT s in order to make use of the matching algorithms provided in <ref type="bibr" target="#b13">[14]</ref>.</p><p>Monitoring. Given a program and a ConSpec policy with scope Session, the concept of monitoring can be formalized by defining the co-execution of the corresponding ConSpec automaton with the program <ref type="bibr" target="#b0">[1]</ref>. Such co-executions are a subset of the set of interleavings of the individual executions of the program and the automaton. Co-executions satisfy the following condition: when the execution of the program component is projected to its security relevant action executions, each preaction is immediately preceded by a transition of the automaton for the same action; dually, each post-action is immediately followed by a corresponding automaton transition. Therefore, it is simple to show that the program component of the coexecution adheres to the given policy, as the co-execution includes an accepting trace of the automaton for the program execution.</p><p>Monitor inlining. Inlining a ConSpec policy with scope Session can be performed similar to inlining a PSLang policy (see <ref type="bibr" target="#b5">[6]</ref> for details on inlining PSLang policies). A class definition is added to the target program which stores the security state variables. Then the program is rewritten so that each security relevant method call is wrapped with code compiled from the corresponding event clause(s) of the policy. Such a code segment evaluates the guards of the event clause from top to bottom and executes the updates associated with the first guard that is satisfied. If none of the guards evaluate to true, the program is terminated. The modifier of the event clause determines where this segment is placed relative to the method call.</p><p>In <ref type="bibr" target="#b0">[1]</ref>, the inlining is performed by inserting the check/update code in the methods of the untrusted program, around method invocation instructions that may call security relevant API methods. It is also possible to monitor the program by ''compiling'' the security policy into a single module which is included in the program. This module is enquired prior to all security relevant method calls. The module then keeps the security state and performs all checks and updates. The original program methods are then altered only by calls to interface methods of the module. This approach simplifies proving inlining correct as all security code resides in one module. Vanoverberghe and Piessens describe such an inliner in <ref type="bibr" target="#b17">[18]</ref>.</p><p>The correctness of various monitor inlining schemes can be proven by setting up a bisimulation relation between the states of the inlined program and the states of the co-execution of the original program with the ConSpec automaton (of the policy). Verification of monitor inlining using PCC. Showing that the program has an inlined monitor for the contract it guarantees is much less en effort than showing the correctness of a particular inlining algorithm. In <ref type="bibr" target="#b0">[1]</ref>, an annotation scheme is described which characterizes, in terms of JVM class files annotated by formulas in a suitable Floyd-like program logic, policy-adherence of the program and the existence of a concrete representation of the monitor state inside the program. The verification of a concrete monitor inliner then reduces to proof of validity of the corresponding annotations. It is also sketched how the annotations can be completed automatically, for a simple inliner, to produce a fully annotated program. This process can then be used, provided a bytecode weakest precondition checker, in a proof-carrying code setting to certify monitor compliance to a third party such as a mobile device. The authors prove the correctness of their inlining algorithm using this annotation scheme, i.e. show that each program which has been inlined for policy P validates the assertions produced using P .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Static analysis.</head><p>Verification of safety properties is a well-studied subject. The method that is most commonly used for this purpose is model checking, where a model of both the program and the property are constructed. Then various techniques are used to check whether the program is a model for the temporal logic formula that represents the property. For ConSpec properties, a suitable method is to use pushdown model checking. Alternatively. the annotation scheme described above can be used to statically verify contract adherence. The assertions produced characterize all programs which have a concrete representation of the monitor. When the program has been inlined, references to this concrete representation in the assertions are instantiated by the inlined variables. For an arbitrary, contract-adherent program, the verification step would involve finding suitable candidates for the concrete representation of the monitor as a function of the program state, besides proving the resulting verification conditions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Related work</head><p>There exists a number of automata-based languages for security policy specification. Amongst these, ConSpec is closest to PSLang <ref type="bibr" target="#b5">[6]</ref> which has also introduced the modifiers used in ConSpec. The language is intended solely for runtime monitoring and freely uses programming language constructs such as abstractions and functions. This enables a larger class of policies to be specified but also complicates the task of providing a formal semantics. Since the authors do not provide such a formalisation, their monitor inlining algorithm for PSLang is to be trusted on intuition as no proof of its correctness can be constructed.</p><p>The Polymer language <ref type="bibr" target="#b1">[2]</ref> has the same drawback. Polymer policies consist of Java classes which, when inlined, may trigger various action in case of violation. For instance it is possible to execute some recovery action as a response to the violation, after which the application is allowed to progress. Polymer policies implement edit automata <ref type="bibr" target="#b12">[13]</ref>, which extend security automata <ref type="bibr" target="#b6">[7]</ref>. But the correctness of the Polymer policy inlining cannot be proven either, as its semantics is not formally presented. In a recent work <ref type="bibr" target="#b2">[3]</ref>, a simpler version of the Polymer language is presented with its semantics, in the context of a lambda calculus. Using this semantics, the authors prove uncircumventability of the monitor, i.e. that the untrusted program can not perform security relevant actions by circumventing the monitor. However, the result applies to the toy language and not to any Polymer implementation.</p><p>Many logic-based formalisms are used to express security properties for monitoring purposes (e.g. <ref type="bibr" target="#b7">[8]</ref>). Temporal logic formulae can be translated to automata by applying, for instance, a tableaux procedure <ref type="bibr" target="#b11">[12]</ref>. It is therefore conceivable that temporal logic formulae being translated to ConSpec, so to enable the use of this type of formalism in the framework.</p><p>Model-carrying code (MCC) <ref type="bibr" target="#b16">[17]</ref> method is based on the idea of supplying untrusted code with additional information to simplify its verification against user policies. In MCC, this additional information is an extended FSA (EFSA) that represents the model of the program. This approach has much in common with ours, and EFSA is very similar to ConSpec automata. The difference is that EFSA allows for unbounded variables to be used as the security state, but in turn allows only equality conditions for comparing variables. ConSpec allows, however, more sophisticated expressions, including basic arithmetic operations and comparisons of numeric values. Also, our framework does not rely entirely on monitoring for enforcing code-contract compliance. In many cases the compliance can be verified statically and run without performance overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusion</head><p>In this paper, we present the policy language ConSpec, which has been designed for formalizing security requirements as well as representing the security-relevant behavior of the application. ConSpec specifications can be used for various tasks during all stages of the application lifecycle to ensure that the application conforms to the user policy. The main features of ConSpec are this universality and its tight connection with the underlying formalism, which is a fundamental component of any formal proof of policy adherence.</p><p>The semantics presented in this paper covers only policies for a single execution of the untrusted program. We leave devising semantics for policies with other scopes (i.e. Multisession, Object and Global) to future work. In the scope of the S3MS project, we have formalized techniques for enforcing ConSpec policies on sequential programs as summarized in Section 4. Efficient static verification of ConSpec properties is another interesting subject to explore. The main challenge, however, is extending the approach to handle multi-threaded applications. Such a setting brings about synchronization issues as mutually dependent events may occur in different threads and data used by the monitor for decision-making may be shared between threads.</p><p>As extensions to the current ConSpec language, introducing object reference and list types as security state types emerge as beneficial features considering real-life policies. The list type makes simple iteration meaningful to include in the update language, to enable, for instance, updating all elements. The update language then can be extended with a simple construct that iterates over flat lists. Extensions to the language should be considered thoroughly, as these may introduce undecidability of various tasks identified in our framework. Below we provide a table that shows which extensions to the language can be handled by which tasks in the framework. The constructs of ConSpec are specified in the rows of the tables below, whereas the activities are specified in the columns.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Security enforcement through application development phases.</figDesc><graphic coords="2,114.20,52.13,312.12,180.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Open(string path, string mode, string access) PERFORM mode.equals("CreateNew") -&gt; { skip; } mode.equals("Open") &amp;&amp; access.equals("OpenRead") -&gt; { accessed= true; } BEFORE Connection.Open(string type, string address) PERFORM !accessed -&gt; { permission = false; } accessed &amp;&amp; permission -&gt; { permission = false; } AFTER bool answer= GUI.AskConnect() PERFORM answer -&gt; { permission=true; } !answer -&gt; { permission=false; }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>(a) Policy syntax. (b) Event clause syntax.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. ConSpec syntax.</figDesc><graphic coords="5,286.31,115.49,165.60,91.08" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Example 3 .</head><label>3</label><figDesc>The personal information manager (PIM) saves personal information (e.g. phonebook) in mobile devices. Secure connections are established by connecting to destinations starting with ''https://''. The policy ''An application must not access the PIM while unsecure connections are open and must only open secure connections after the PIM is accessed'' is expressed by the following ConSpec policy: active -&gt; { opened = true; } BEFORE Connection.open(string url) PERFORM !opened &amp;&amp; url.startsWith("https") -&gt; { active = true; secure = true; } !opened &amp;&amp; !url.startsWith("https") -&gt; { active = true; secure = false; } opened &amp;&amp; url.startsWith("https") -&gt; { active = true; } AFTER Connection.close() PERFORM true -&gt; { active = false;}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>We give semantics to ConSpec policies on single executions (i.e. policies with scope Session) through a particular class of security automata which we term ConSpec automata. Notation. In the text below, we fix a set of class names C, a set of method names M and a set of field names F ranged over by c ∈ C, m ∈ M, and f ∈ F, respectively. We assume that types are ranged over by τ . The set of all values of type τ is denoted as τ . The set of all values is Val, while the set of values of the type int, boolean or string is PrimVal. Values of object type are (typed) locations ∈ Loc, mapped to objects by a heap h ∈ H = Loc</figDesc><table><row><cell>3.2. ConSpec semantics</cell></row><row><cell>O. Objects map field names to</cell></row><row><cell>values o ∈ O = F</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The authors thank Dilian Gurov and Fabio Massacci for valuable comments and discussions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix. ConSpec features for different tasks</head></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Provably correct runtime monitoring</title>
		<author>
			<persName><forename type="first">I</forename><surname>Aktug</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gurov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th International Symposium on Formal Methods, FM&apos;08</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 15th International Symposium on Formal Methods, FM&apos;08<address><addrLine>Turku, Finland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-05">May 2008</date>
			<biblScope unit="volume">5014</biblScope>
			<biblScope unit="page" from="262" to="277" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Composing security policies with Polymer</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ligatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the ACM SIGPLAN Conf. on Prog. Lang. Design and Implementation</title>
		<meeting>of the ACM SIGPLAN Conf. on Prog. Lang. Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="305" to="314" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Composing expressive run-time security policies</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ligatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Software Engineering and Methodology</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
	<note>in press</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Memory-efficient algorithms for the verification of temporal properties</title>
		<author>
			<persName><forename type="first">C</forename><surname>Courcoubetis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wolper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Methods in System Design</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<biblScope unit="page" from="275" to="288" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Security-by-contract: Toward a semantics for digital signatures on mobile code</title>
		<author>
			<persName><forename type="first">N</forename><surname>Dragoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Massacci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Naliuka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Siahaan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European PKI Workshop: Theory and Practice</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
	<note>in press</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">The inlined reference monitor approach to security policy enforcement</title>
		<author>
			<persName><forename type="first">Ú</forename><surname>Erlingsson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
		<respStmt>
			<orgName>Dep. of Computer Science, Cornell University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Computability classes for enforcement mechanisms</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">W</forename><surname>Hamlen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Morrisett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">B</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="175" to="205" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Efficient monitoring of safety properties</title>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rosu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal on Software Tools for Technology Transfer</title>
		<imprint>
			<biblScope unit="issue">STTT</biblScope>
			<biblScope unit="page" from="158" to="173" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The model checker SPIN</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Holzmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software Engineering</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="279" to="295" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">On the equivalence and containment problems for context-free languages</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Hopcroft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory of Computing Systems</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="119" to="124" />
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">On equivalence and containment problems for formal languages</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">B</forename><surname>Hunt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Rosenkrantz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of ACM</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="387" to="396" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">A decision algorithm for full propositional temporal logic</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kesten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mcguire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>CAV</publisher>
			<biblScope unit="page" from="97" to="109" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Edit automata: Enforcement mechanisms for run-time security policies</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ligatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Information Security</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="2" to="16" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>Published online 26 Oct 2004</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Matching midlet&apos;s security claims with a platform security policy using automata modulo theory</title>
		<author>
			<persName><forename type="first">F</forename><surname>Massacci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Siahaan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of The 12th Nordic Workshop on Secure IT Systems, NordSec&apos;07</title>
		<meeting>of The 12th Nordic Workshop on Secure IT Systems, NordSec&apos;07</meeting>
		<imprint>
			<date type="published" when="2007-10">October 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Proof-carrying code</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">C</forename><surname>Necula</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL &apos;97: Proceedings of the 24th ACM SIGPLAN-SIGACT symposium on Principles of programming languages</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="106" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Enforceable security policies</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">B</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Infinite Systems Security</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="30" to="50" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Model-carrying code: A practical approach for safe execution of untrusted applications</title>
		<author>
			<persName><forename type="first">R</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">N</forename><surname>Venkatakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Basu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bhatkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Duvarney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGOPS Operating Systems Review</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A caller-side inline reference monitor for an object-oriented intermediate language</title>
		<author>
			<persName><forename type="first">D</forename><surname>Vanoverberghe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Piessens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 10th IFIP International Conference on Formal Methods for Open Object-based Distributed Systems, FMOODS&apos;08</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>of the 10th IFIP International Conference on Formal Methods for Open Object-based Distributed Systems, FMOODS&apos;08<address><addrLine>Oslo, Norway</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">June 4-6, 2008. 2008</date>
			<biblScope unit="volume">5051</biblScope>
			<biblScope unit="page" from="240" to="258" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Zobel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Simoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Piazza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Nunez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Rodriguez</surname></persName>
		</author>
		<ptr target="http://s3ms.org" />
		<title level="m">Business case and security requirements, Public Deliverable D5.1.1, S3MS</title>
		<imprint>
			<date type="published" when="2006-10">October 2006</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
