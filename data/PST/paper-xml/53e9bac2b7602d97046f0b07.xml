<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Theory of Inductive Query Answering</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Luc</forename><surname>De Raedt</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Manfred</forename><surname>Jaeger Ý Þ</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Helsinki Institute of Information Technology</orgName>
								<orgName type="institution">Univ. of Helsinki</orgName>
								<address>
									<postBox>PO Box 26</postBox>
									<postCode>FIN-00014</postCode>
									<country key="FI">Finland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sau</forename><surname>Dan</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Lee</forename><forename type="middle">Ý</forename><surname>Heikki</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Helsinki Institute of Information Technology</orgName>
								<orgName type="institution">Univ. of Helsinki</orgName>
								<address>
									<postBox>PO Box 26</postBox>
									<postCode>FIN-00014</postCode>
									<country key="FI">Finland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Inst</forename><surname>Für Informatik</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Georges</forename><surname>Koehler Allee</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of Freiburg</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<address>
									<postCode>D-79110</postCode>
									<settlement>Freiburg</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">MPI Informatik</orgName>
								<address>
									<addrLine>Stuhlsatzenhausweg 85</addrLine>
									<postCode>D-66123</postCode>
									<settlement>Saarbrücken</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Theory of Inductive Query Answering</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">48103E5AC30429AB623A1C909968A943</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:03+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We introduce the boolean inductive query evaluation problem, which is concerned with answering inductive queries that are arbitrary boolean expressions over monotonic and anti-monotonic predicates. Secondly, we develop a decomposition theory for inductive query evaluation in which a boolean query É is reformulated into sub-queries É É É Å that are the conjunction of a monotonic and an anti-monotonic predicate. The solution to each subquery can be represented using a version space. We investigate how the number of version spaces needed to answer the query can be minimized. Thirdly, for the pattern domain of strings, we show how the version spaces can be represented using a novel data structure, called the version space tree, and can be computed using a variant of the famous Apriori algorithm. Finally, we present some experiments that validate the approach.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Many data mining problems address the problem of finding a set of patterns that satisfy a constraint. Formally, this can be described as the task of finding the set of patterns Ì ´É Äµ ³ ¾ Ä É´³ µ, i.e. those patterns ³ satisfying query É on database . Here Ä is the language in which the patterns or rules are described and É is a predicate or constraint that determines whether a pattern ³ is a solution to the data mining task or not <ref type="bibr" target="#b14">[15]</ref>. This framework allows us to view the predicate or the constraint É as an inductive query to an inductive database system. It is then the task of the inductive database management system to efficiently generate the answers to the query. This view of data mining as a declarative querying process is also appealing as the basis for a theory of data mining. Such a theory would be analogous to traditional database theory in the sense that one could study properties of different pattern languages Ä, different types of queries (and query languages), as well as different types of databases. Such a theory could also serve as a sound basis for developing algorithms that solve inductive queries.</p><p>It is precisely such a theory that we introduce in this paper. More specifically, we study inductive queries that are boolean expressions over monotonic and anti-monotonic predicates. An example query could ask for molecular fragments that have frequency at least 30 per cent in the active molecules or frequency at most 5 per cent in the inactive ones <ref type="bibr" target="#b13">[14]</ref>. To the best of our knowledge this type of boolean inductive query is the most general type of inductive query that has been considered so far in the data mining literature. Indeed, most contemporary approaches to constraint based data mining use either single constraints (such as minimum frequency), e.g. <ref type="bibr" target="#b1">[2]</ref>, a conjunction of monotonic constraints, e.g. <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b9">10]</ref>, or a conjunction of monotonic and anti-monotonic constraints, e.g. <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b13">14]</ref>. However, <ref type="bibr" target="#b5">[6]</ref> has studied a specific type of boolean constraints in the context of association rules and item sets. It should also be noted that even these simpler types of queries have proven to be useful across several applications, which in turn explains the popularity of constraint based mining in the literature.</p><p>Our theory of boolean inductive queries is first of all concerned with characterizing the solution space Ì ´É Äµ using notions of convex sets (or version spaces <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b15">16]</ref>) and border representations <ref type="bibr" target="#b14">[15]</ref>. This type of representations have a long history in the fields of machine learning <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b15">16]</ref> and data mining <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b2">3]</ref>. These data mining and machine learning viewpoints on border sets have recently been unified by <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b13">14]</ref>, who introduced the level-wise version space algorithm that computes the S and G set w.r.t. a conjunction of monotonic and anti-monotonic constraints.</p><p>In the present paper, we build on these results to develop a decomposition approach to solving arbitrary boolean queries over monotonic and anti-monotonic predicates. More specifically, we investigate how to decompose arbitrary queries É into a set of sub-queries É such that Ì ´É Äµ Ë Ì ´É Äµ, is minimal, and each Ì ´É Äµ can be represented using a single version space. This results in an operational and effective decomposition procedure for solving queries. Indeed, the overall query É is first reformulated into the sub-queries É , which can then be solved by existing algorithms such as the levelwise version space algorithm of <ref type="bibr" target="#b3">[4]</ref>.</p><p>Our theory is then instantiated to answer boolean queries about string patterns. String patterns are widely applicable in the many string databases that exist today, e.g. in DNA or in proteins. Furthermore, the present work is to a large extent motivated by the earlier MolFea system <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b3">4]</ref>, in which conjunctive queries (over anti-monotonic and monotonic constraints) for molecular features were solved using a version space approach. MolFea features are essentially strings that represent sequences of atoms and bonds. For string patterns, we introduce a novel data structure, i.e. version space trees, for compactly representing version spaces of strings. Version space trees combine ideas of version spaces with those of suffix trees. They have various desirable properties. Most notably, they can be computed using a variant of traditional level wise algorithms for tries, recognizing whether a string belongs to the version space is linear in the size of the string, and the size of the version space tree is at most quadratic in the size of the elements in the S set of the version space.</p><p>This paper is organized as follows. In Section 2, we define the inductive query evaluation problem and illustrate it on the pattern domains of strings and item-sets; in Section 3, we introduce a decomposition approach to reformulate the original query in simpler sub-queries; in Section 4, we introduce version space trees that compactly represent the solutions to a sub-query in the pattern domain of strings; in Section 5, we report on some experiments in this domain, and, finally, in Section 6, we conclude.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Boolean Inductive Queries</head><p>A pattern language Ä is a formal language for specifying patterns. Each pattern ¾ Ä matches (or covers) a set of examples , which is a subset of the universe Í of possible examples. In general, pattern languages will not allow to represent all subsets È´Íµ of the universe We now introduce a number of pattern predicates that will be used for illustrative purposes throughout this paper. Most of these predicates are inspired by MolFea <ref type="bibr" target="#b13">[14]</ref>. Our first pattern predicates are very general in that they can be used for arbitrary pattern languages: ¯Ñ Ò Ö Õ(Ô,Ò, ) evaluates to true iff Ô is a pattern that occurs in database with frequency at least Ò ¾ AE.</p><p>The frequency ´ µ of a pattern in a database is the (absolute) number of data items in covered by . Analogously, the predicate Ñ Ü Ö Õ(Ô Ò ) is defined.</p><p>¯ ×ÑÓÖ Ò Ö Ð(Ô, ) is a predicate that evaluates to true iff pattern Ô is more general than pattern . Dual to the ×ÑÓÖ Ò Ö Ð predicate one defines the ×ÑÓÖ ×Ô ¬ predicate.</p><p>The following predicate is an example predicate tailored towards the specific domain of string-patterns over Ä ¦ .</p><p>¯Ð Ò Ø ØÑÓ×Ø(Ô,Ò) evaluates to true for Ô ¾ Ä ¦ iff Ô has length at most Ò. Analogously the Ð Ò Ø ØÐ ×Ø(Ô,Ò) predicate is defined.</p><p>In all the preceding examples the pattern predicates have the form ÔÖ (Ô,params) or ÔÖ (Ô, ,params), where params is a tuple of parameter values, is a data set and Ô is a pattern variable.</p><p>We also speak a bit loosely of ÔÖ alone as a pattern predicate, and mean by that the collection of all pattern predicates obtained for different parameter values params.</p><p>We say that Ñ is a monotonic predicate, if for all possible parameter values params and all data sets :</p><formula xml:id="formula_0">¾ Ä such that Ñ´ paramsµ Ñ´ paramsµ</formula><p>The class of anti-monotonic predicates is defined dually. Thus, Ñ Ò Ö Õ, ×ÑÓÖ Ò Ö Ð, and Ð Ò Ø ØÑÓ×Ø are monotonic, their duals are anti-monotonic.</p><p>A pattern predicate ÔÖ (Ô, ,params) that can be applied to the patterns from a language Ä defines relative to the solution set Ì ´ÔÖ ´Ô paramsµ Äµ ¾ Ä ÔÖ ´ paramsµ true . Furthermore, for monotonic predicates Ñ these sets will be monotone, i.e. for all ¾ Ä ¾ Ì ´Ñ Äµ ¾ Ì ´Ñ Äµ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 2.3 Consider the string data set = abc abd cd d cd .</head><p>Here we have pattern frequencies ´abc µ ½, ´cd µ ¾, ´c µ ¿, ´abcd µ ¼ . And trivially, ´¯ µ</p><p>. Thus, the following predicates evaluate to true: Ñ Ò Ö Õ(c;</p><formula xml:id="formula_1">2; D), Ñ Ò Ö Õ(cd; 2; D), Ñ Ü Ö Õ(abc; 2; D), Ñ Ü Ö Õ(cd; 2; D). The pattern predicate Ñ Ñ Ò Ö Õ´Ô ¾ µ de- fines Ì ´Ñ Ä ¦ µ ¯</formula><p>, and the pattern predicate</p><formula xml:id="formula_2">Ñ Ü Ö Õ´Ô ¾ µ defines the infinite set Ì ´ Ä ¦ µ Ä ¦ Ò ¯ .</formula><p>The definition of Ì ´ÔÖ ´p paramsµ Äµ is extended in the natural way to a definition of the solution set Ì ´É Äµ for boolean combinations É of pattern predicates over a unique pattern variable:</p><formula xml:id="formula_3">Ì ´ É Äµ Ä Ò Ì ´É Äµ, Ì ´É½ É ¾ Äµ Ì ´É½ Äµ Ì ´É¾ Äµ.</formula><p>The predicates that appear in É may reference one or more data sets ½ Ò . To emphasize the different data sets that the solution set of a query depends on, we also write</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ì ´É ½</head><p>Ò Äµ or Ì ´É Äµ for Ì ´É Äµ.</p><p>We are interested in computing solution sets Ì ´É Äµ for boolean queries É that are constructed from monotonic and anti-monotonic pattern predicates. As anti-monotonic predicates are negations of monotonic predicates, we can, in fact, restrict our attention to monotonic predicates. We can thus formally define the boolean inductive query evaluation problem addressed in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Given</head><p>¯a language Ä of patterns,</p><formula xml:id="formula_4">¯a set of monotonic predicates Å Ñ ½ ´Ô ½ params ½ µ Ñ Ò ´Ô Ò params Ò µ ,</formula><p>¯a query É that is a boolean expression over the predicates in Å (and over a single pattern variable),</p><p>Find the set of patterns Ì ´É ½ Ò Äµ, i.e. the solution set of the query É in the language Ä with respect to the data sets ½ Ò .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">A decomposition approach</head><p>The query evaluation problem for a query É will be solved by decomposing É into sub-queries É such that É is equivalent to É ½ É , and then computing Ì ´É Äµ as Ì ´É Äµ. Furthermore, each of the sub-queries É will be such that Ì ´É Äµ is a version space (also called a convex space), and therefore can be efficiently computed for a wide class of pattern languages Ä, and queries É . Definition 3.1 Let Ä be a pattern language, and Á Ä.</p><formula xml:id="formula_5">Á has dimension 1, if ¼ ¾ Ä ¼ and ¼ ¾ Á µ ¾ Á. Á has dimension if it is the union of subsets of dimension 1, but not the union of ½ subsets of dimension 1.</formula><p>A query É has dimension (with respect to the pattern language Ä) if is the maximal dimension of any solution set Ì ´É Äµ of É (where the maximum is taken w.r.t. all possible data sets and w.r.t. the fixed language Ä).</p><p>If É has dimension 1 w.r.t. Ä, then Ì ´É Äµ is a version space <ref type="bibr" target="#b15">[16]</ref> or a convex space <ref type="bibr" target="#b12">[13]</ref>. Version spaces are particularly useful when they can be represented by boundary sets, i.e. by the sets ´É Äµ of their maximally general elements, and Ë´É Äµ of their minimally general elements. For the theoretical framework of the present section we need not assume boundary representability for convex sets. However, concrete instantiations of the general method we here develop, like the one described in sections 4 and 5, usually will assume pattern languages in which convexity implies boundary representability. With the following definition and lemma we provide an alternative characterization of dimension sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 3.2 Reconsider the string domain. Let</head><formula xml:id="formula_6">É ½ ×ÑÓÖ Ò Ö Ð´Ô µ Ð Ò Ø ØÐ ×Ø´Ô ¿µ É ¾ ×ÑÓÖ ×Ô ¬ ´Ô µ ×ÑÓÖ ×Ô ¬ ´Ô ÙÛµ ´Ð Ò Ø ØÐ ×Ø´Ô µ Ñ Ò Ö Õ´Ô ¿ µµ</formula><formula xml:id="formula_7">Lemma 3.3 Let Á Ä. Call a chain ½ ¾ ¾ ½</formula><p>Ä an alternating chain (of length ) for I if ¾ Á for all odd , and ¾ Á for all even . Then the dimension of Á is equal to the maximal for which there exists in Ä an alternating chain of length for Á. </p><formula xml:id="formula_8">É ¿ ×ÑÓÖ Ò Ö Ð´Ô µ ×ÑÓÖ ×Ô ¬ ´Ô µ, É ×ÑÓÖ Ò Ö Ð´Ô µ, and É É ¿ É . Then , ,</formula><p>is an alternating chain of length 2 for Ì ´É Ä ¦ µ.</p><p>Given É and Ä we are now interested in computing the dimension of É, and transforming É into a disjunction ½ É , such that each Th´É Äµ is a version space. The approach we take is to first evaluate É in a reduced pattern language Ä adm Å´Éµ , so that the desired partition É can be derived from the structure of Th´É Ä adm Å´Éµ µ. </p><formula xml:id="formula_9">Ñ ¾ Ñ Ñ ¾ Ñ Äµ is not empty. Let Ä adm Å´Éµ ¾ Ä Å´Éµ admissible .</formula><p>For the predicates Ñ we define Th´Ñ Ä Å´Éµ µ, respectively Th´Ñ Ä adm Å´Éµ µ, as the set of (admissible) that con- tain Ñ . By the general definition this also determines Th´É Ä Å´Éµ µ and Th´É Ä adm Å´Éµ µ.</p><p>Example 3.6 Using only monotonic predicates, the query É ¾ from example 3.2 can be rewritten as</p><formula xml:id="formula_10">Ñ ½ Ñ ¾ ´ Ñ ¿ Ñ µ, with Ñ ½ ÒÓØ¹ ×ÑÓÖ ×Ô ¬ ´Ô µ Ñ ¾ ÒÓØ¹ ×ÑÓÖ ×Ô ¬ ´Ô ÙÛµ Ñ ¿ ÒÓØ¹Ð Ò Ø ØÐ ×Ø´Ô µ Ñ Ñ Ò Ö Õ´Ô ¿ µ</formula><p>(where e.g. ÒÓØ¹ ×ÑÓÖ ×Ô ¬ is the (monotonic) complement of the anti-monotonic predicate ×ÑÓÖ ×Ô ¬ ; note that this is distinct from ×ÑÓÖ Ò Ö Ð).</p><p>Here every Ñ ½ Ñ is admissible (a witness for the admissibility of Ñ ¿ Ñ , for instance, is a dataset in which the string abuw appears at least three times, i.e. Here not every The dimension of Th´É Ä Å´Éµ µ is greater or equal the dimension of Th´É Ä adm Å´Éµ µ, and therefore also can serve as an upper bound for the dimension of Ì ´É Äµ. In general, this will be a coarser bound: for É , for instance, we obtain for Th´É Ä Å´É µ µ the same structure as shown for É ¾ in figure 1 (a), and therefore only the bound 2.</p><formula xml:id="formula_11">abuw ¾ Th´ Ñ ½ Ñ ¾ Ñ ¿ Ñ Ä ¦ µ).</formula><formula xml:id="formula_12">Ñ ½ Ñ ¾ Ñ ¼ ¿ Ñ is admissi- ble: as ×ÑÓÖ ×Ô ¬ ´Ô µ ×ÑÓÖ ×Ô ¬ ´Ô ÙÛµ im- plies Ð Ò Ø ØÐ ×Ø´Ô µ, we have that neither Ñ ¼ ¿ nor Ñ ¼ ¿ Ñ</formula><p>When Th´É Ä adm Å´Éµ µ is of dimension , we can define each of its convex components Á as a solution to a query É in the predicates Ñ : if ½ Ð are the maximal and ½ Ñ the minimal elements of Á , then Äµ. This factorization of É facillitates the computation of the border sets ´É Äµ and Ë´É Äµ, for which the level wise version space algorithm <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b13">14]</ref> can be used. In the following section we will present an algorithm that for queries in the string domain uses the syntactic form of the É for efficiently computing and representing the solution sets Th´É Äµ with version space trees.</p><formula xml:id="formula_13">Á Th´É Ä adm Å´Éµ µ for É ´ Ð ½ Ñ ¾ Ñ µ ´ Ñ ½ Ñ ¾ Ñ µ (1)<label>Theorem</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Version space trees</head><p>In this section, we introduce a novel data structure, called the version space tree, that can be used to elegantly represent and index a version space of strings, e.g. the Th´É Ä ¦ µ introduced in the previous section. Furthermore, we present effective algorithms that compute version space trees containing all strings that satisfy the conjunction of a monotonic and an anti-monotonic predicate (as in the queries É ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">The data structure</head><p>A trie is a tree where each edge is labelled with a symbol from the alphabet ¦. Moreover, the labels on every edge emerging from a node must be unique. Each node Ò in a trie thus uniquely represents the string ×´Òµ containing the characters on the path from the root Ö to the node Ò. The root node itself represents the empty string</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>¯.</head><p>A suffix trie is a trie with the following properties:</p><p>¯For each node Ò and for each suffix Ø of ×´Òµ, there is also a node Ò ¼ in the trie representing Ø, i.e. Ø ×´Ò ¼ µ. ¯Each node Ò has a suffix link suffix´Òµ Ò ¼ , where ×´Ò ¼ µ represents the suffix obtained from ×´Òµ by dropping the first symbol. The root node represents</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>¯,</head><p>which has no suffixes. We define suffix´ÖÓÓØµ , where is a unique entity. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 2. An example version space tree</head><p>Suffix tries have been well studied in the literature <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref>. However, we make some important deviations from the main stream approach: ¯instead of building a suffix trie on all the suffixes of a single string, we are indexing all the suffixes of a set of strings; thus multiple strings are stored in the trie.</p><p>¯we use fully labelled tries, in which each node is labelled with either "¨" or "©"; the ¨label to indicate nodes that are interesting to us (say: belong to the version space) and © for those that are not. ¯because we need to store labels and counts for all substrings represented in the trie, we do not coalesce chains of nodes with only one out-going edge into a single edge label.</p><p>Note that a fully labelled trie may contain nodes for which its label as well as those of its descendants are all ©. Thus the node as well as the subtrie below it are uninteresting. Therefore, in practice we will often use a pruned labelled trie. This is a fully labelled trie with the additional property that all leaf nodes have the sign ¨. Both trees have the same semantics and each fully labelled tree has a unique equivalent pruned tree. Furthermore,as most of our results are valid for both types of trees, we will often employ the term "labelled trie". Now a version space tree Î is a labelled trie that represents a version space of strings over Ä ¦ . More formally, let Î be a set of strings of dimension 1. Then the corresponding (pruned) version space trie Ì is such that Î Ú Ò is a node in Ì with label ¨and ×´Òµ Ú . A version space tree VST representing version space Î has the following properties:</p><p>1. All leaf nodes are labelled ¨.</p><p>2. Along every path from root to a leaf there is at most one sign change (from © to ¨); cf. Lemma 3.3.</p><p>3. If Ë Ñ Ò Î then VST will 1) have a leaf corresponding to each × ¾ Ë and 2) have a node corresponding to each suffix × ¼ of each × ¾ Ë for which × ¼ ¾ Î .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Therefore, the number of nodes in the version space</head><p>tree VST is at most ¦ ¾Ë × ¾ , where × denotes the length of the string. However, the size of a VST is usually much smaller.</p><p>5. Testing whether a string × belongs to the version space represented by a version space Î Ë Ì is linear in × , as the VST can be interpreted as a deterministic automaton on input ×.</p><p>6. Property 3 can be used as the basis for an algorithm for constructing a version space tree based on Ë and .</p><p>7. For a given version space tree, one can easily and efficiently construct the Ë and -sets. Indeed, the Ëset will contain all leafs Ð of the version space tree to whom no suffix pointer points; and the -set will contain all nodes with label ¨whose parent node has label © and for which the node suffix´ µ either does not exist or also has the label ©.</p><p>As one can see, there is a close correspondence between version spaces of strings and version space trees. We will now show that there is also a close correspondence between version space trees and algorithms such as Apriori <ref type="bibr" target="#b1">[2]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">The algorithms</head><p>In this section, we sketch the ÎËÌ algorithm to build a version space tree that satisfies the conjunction É É Å of an anti-monotonic predicate É and a monotonic one É Å . This form of query corresponds to the one of the queries É that would be generated by our decomposition (over anti-monotonic and monotonic constraints) approach. Algorithm ÎËÌ is a level-wise algorithm based on the wellknown Apriori <ref type="bibr" target="#b1">[2]</ref> algorithm. The algorithm assumes 1) that the version space tree to be computed is finite and 2) that the alphabet ¦ is given. It consists of two phases: DESCEND: top-down growing of the version space tree using the monotonic predicate É Å . ASCEND: bottom-up marking of the version space tree using the anti-monotonic predicate É . Both phases are designed to minimize the number of database scans<ref type="foot" target="#foot_1">2</ref> . As such, they both exhibit the cyclic pattern: candidate generation, candidate testing (database scan) and pruning. The cycle terminates when no more new candidates patterns are generated.</p><p>Since only the monotonic pattern predicate is handled in the descend phase, we can reuse the idea of Apriori. The algorithm searches the strings satisfying É Å in a top-down, breadth-first manner. At each depth level , the descend algorithm first expands the ¨nodes found in the previous iteration (Ä ½ ). The nodes resulting from the expansion constitute the set . These candidate nodes are then tested against the predicate É Å . The testing involves one database scan for the whole iteration. The candidate patterns in that satisfy the constraints are put into Ä . Those that do not are pruned away from the tree. This process is repeated in a level wise fashion until becomes empty. All generated nodes are labelled with ¨and the necessary suffix links are set up during this phase. Note that the sets and Ä are the same as the candidate sets and "large" sets in the Apriori algorithm. Moreover, the generation of from Ä ½ also mimics the Apriori-join operation in the Apriori algorithm. 3 The descend algorithm makes use of the suffix like and parentchild relationship of a suffix trie to perform the join efficiently. More specifically, the candidate child nodes of a node Ò in Ä ½ (as well as the edges) correspond to the children of the node suffix´Òµ. So, the major difference between DESCEND and Apriori is that the former also organizes the discovered strings into a suffix trie, facilitating the join operation and the second phase of the VST algorithm.</p><p>The second phase is implemented with algorithm AS-CEND.</p><p>This phase handles the anti-monotonic constraint É . Here we assume that we have the set ¼ of leaf nodes in the tree Ì generated during the descend phase.</p><p>While DESCEND works top-down, ASCEND starts from the leaves and works upwards. It first checks the leaf nodes against the predicate É . The labels of all the nodes Ò that do not satisfy É , are changed into ©. In addition, all their ancestors are also labelled as ©. This is sound due to the anti-monotonicity. So, we can propagate these © marks upwards until we have marked the root with ©.</p><p>Actually, we can stop as soon as we reach an ancestor already marked with ©, as another such leaf node Ò ¼ may share some ancestors with Ò. So, all the ancestors from that point upwards have already been marked with ©. Secondly, for those nodes Ô in ¼ that satisfy É , the label remains unchanged (i.e. ¨). Furthermore, we will enter their parent into the set ½ (and remove possible duplicates). ½ contains the nodes to be considered at the next iteration. This process is then repeated until becomes empty. So, after these two phases, namely DESCEND and then ASCEND, both the monotonic and the anti-monotonic constraints are handled. With a simple tree traversal, we can prune away those subtrees that contain only © labels. The 3 There are some differences here since we are dealing with strings instead of sets. E.g., while Apriori-join generates item set a, b, c from a, b and a, c , the descend algorithm generates abc from ab and bc, because these are the only immediately shorter substrings of abc. At the same time, it is not hard to imagine a variant of the version space tree algorithm for use with item sets. Indeed, the kind of trie searched is quite similar to some of the data structures used by e.g. <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b10">11]</ref>.</p><p>result is a tree that is a pruned suffix trie representing the version space of strings that satisfy the query É É Å . Theorem 4.1 The ÎËÌ algorithm performs at most ¾Ñ database scans, where Ñ is length of the longest strings satisfying the monotonic query É Å .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Experiments</head><p>We have implemented the ÎËÌ algorithm and performed experiments on datasets of command histories collected from 168 Unix users over a period of time <ref type="bibr" target="#b6">[7]</ref>. The users are divided into four groups: computer scientists, experienced programmers, novice programmers and non-programmers. The corresponding data sets are denoted "sci", "exp", "nov" and "non", respectively. When each user accesses the Unix system, he first logs in, then types in a sequence of commands, and finally logs out. Each command is recorded as a symbol in the database. The sequence of commands from log in to log out constitutes a login session, and is mapped to a string in our experiment. Each user contributes to many login sessions in the database. Table <ref type="table" target="#tab_4">1</ref> gives some statistics on the data.</p><p>In the first set of experiments we determined solutions of queries Ñ Ò Ö Õ´Ô Ò µ for the four different datasets and for thresholds Ò that were selected so as to produce solution sets of around 300 frequent string patterns. Table <ref type="table" target="#tab_4">1</ref> summarizes the datasets, the queries, and their solutions. Timings (wall-clock time on a Pentium III 600 Mhz) are reported as well.</p><p>Whereas the first set of experiments only used the Ñ Ò Ö Õ predicate, the second set of experiments involves the computation of two version space trees Ì ½ and Ì ¾ corresponding to the queries É and É : É Ñ Ò Ö Õ´Ô ÒÓÒ ¾ µ Ñ Ü Ö Õ´Ô × ¼µ É Ñ Ò Ö Õ´Ô ÒÓÚ ¼µ Ñ Ü Ö Õ´Ô ÜÔ ¿ µ É and É are conjunctions of an anti-monotonic predicate and a monotonic one, thus their solution space is a version space. Furthermore, they are the sub-queries that are generated for the query É ½¼ É É using the decomposition approach outlined in Section 3.</p><p>The results of the second experiment are shown in Table 2. Each row shows the time the algorithm spent on building that tree. The columns of the table show the number of nodes and total length of strings represented by those nodes. Each of the five sub-column in each case shows the number for a subset of the nodes in the final trie. The column "all" shows the figure for all trie nodes. The columns "¨" and "©" show the figure aggregated over nodes with the respective labels only. The columns "Ë" and " " show the figures for the maximally specific strings and the minimally specific strings, respectively. For what concerns the query É ½¼ , there are in total 401 strings in its answer set, and together they have length 1953.</p><p>Our experimental results confirm our claim that the sets Ë and constitute a compact representation of the set of all patterns satisfying the given constraints É Å and É . From Table <ref type="table" target="#tab_5">2</ref>, it can be seen that the total length of strings for Ë and together is always smaller than that for all interesting patterns (i.e. ¨). In the case of Ì ¾ , the space saving is significant. Moreover, algorithm ÎËÌ is also very efficient in terms of time and space. This shows that using suffix tries in the mining of string patterns is a promising approach. The longest pattern found (represented by the deepest node in either Ì ½ or Ì ¾ having a ¨label) was "pix umacs pix umacs pix umacs pix umacs pix umacs pix umacs pix umacs pix umacs pix umacs pix", which has a length of 19.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions</head><p>We have described an approach to the general pattern discovery problem in data mining. The method is based on the decomposition of the answer set to a collection of components defined by monotonic and anti-monotonic predicates. Each of the components is a convex set or version space, the borders of which can be computed using the level wise version space algorithm or -for the pattern domain of strings -using the ÎËÌalgorithm, which employs a novel data structure called the version space tree. Experiments have been presented that validate the approach.</p><p>The results we have presented in this paper are by no means complete, a lot of open problems and questions remain. First, it seems possible to adapt the version space trees and algorithm for use in other domains (such as itemsets). However, at present it is unclear how to do this for some more expressive domains such as Datalog queries or even the string domain where one is using a coverage relation based on subsequence matching rather than substring matching. Secondly, for the string domain, it is possible to further optimize these algorithms for specific predicates (e.g. involving frequency counting on a database of strings). Thirdly, we are at present also studying set operations on version space trees. Such operations would allow us to perform some of the logical operations directly on solution spaces. Fourthly, the framework seems also useful in the context of optimizing a sequence of inductive queries. Here, it would be interesting to see how the results to previous (sub) queries could be reused for more efficiently answering the next question.</p><p>Although there are many remaining questions, the authors hope that the introduced framework provides a sound theoretical framework for studying these open questions as well as for developing practical inductive database systems based on the idea of inductive querying. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Example 3 . 4</head><label>34</label><figDesc>Consider the following queries:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 (</head><label>1</label><figDesc>Figure 1 (a) shows Ä Å´É¾µ Ä admÅ´É¾µ , where e.g. pattern Ñ ¿ Ñ is just represented by its "index string" 34. Now consider a variant É of É ¾ obtained by replacing Ñ ¿ with Ñ ¼ ¿</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1 .Theorem 3 . 7</head><label>137</label><figDesc>Figure 1. Pattern languages Ä adm Å´Éµ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig- ure 2</head><label>2</label><figDesc>illustrates the (pruned) version space tree representing Ì ´É Ä ¦ µ, where É × ÑÓÖ Ò Ö Ð´Ø µ ´ × ÑÓÖ ×Ô ¬ ´Ø µ × ÑÓÖ ×Ô ¬ ´Ø µµ.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>1 . Example 2.1 Let Á</head><label></label><figDesc>The traditional pattern language for this domain is Ä Á Í Á . A pattern ¾ Ä Á covers the set Á</figDesc><table><row><cell></cell><cell cols="2">over Á. . An alternative, less expressive, pattern lan-guage is the language Ä Á Ä Á of item sets of size at</cell></row><row><cell></cell><cell>most .</cell></row><row><cell></cell><cell cols="2">Example 2.2 Let ¦ be a finite alphabet and Í ¦ ¦ £ the universe of all strings over ¦. We will denote the empty string with ¯. The traditional pattern language in this do-main is Ä ¦ Í ¦ . A pattern ¾ Ä ¦ covers the set ¾ ¦ £ Ú , where Ú denotes that</cell></row><row><cell></cell><cell cols="2">is a substring of . An alternative, more expressive, lan-guage is the language of all regular expressions over ¦.</cell></row><row><cell></cell><cell cols="2">One pattern is more general than a pattern , written</cell></row><row><cell></cell><cell>, if and only if</cell><cell>.</cell></row><row><cell></cell><cell cols="2">A pattern predicate defines a primitive property of a pat-</cell></row><row><cell></cell><cell cols="2">tern, usually relative to some data set (a set of examples),</cell></row><row><cell></cell><cell cols="2">and sometimes other parameters. For any given pattern, it</cell></row><row><cell></cell><cell cols="2">evaluates to either true or false.</cell></row><row><cell>sible items, and Í Á</cell><cell>½ ¾ Á be the universe of item sets Ò be a finite set of pos-</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>The query É ½ does not reference any dataset, and Ì ´É½ Ä ¦ µ</figDesc><table><row><cell>This set of solutions is completely characterized by Ë´É ½ Ä ¦ µ and ´É½ Ä ¦ µ</cell></row></table><note><p><p>.</p>Ì ´É¾ Ä ¦ µ cannot in general be represented using a single version space. However, as our general method will show, the dimension of Ì ´É¾ Ä ¦ µ is at most two, so that it can be represented as the union of two version spaces.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>The solution set Th´É Ä adm Å´Éµ µ does not depend on the datasets that É references, and the complexity of its computation only depends on the size of É, but not on the size of any datasets.</figDesc><table><row><cell cols="2">Definition 3.5 For a query É, let Å´Éµ Ñ ½ be the set of monotonic predicates contained in É (where Ñ Ò</cell></row><row><cell cols="2">predicates that only differ with respect to parameter values also are considered distinct). Define Ä Å´Éµ ¾ Å´Éµ . A subset Å´Éµ is called admissible if there exists</cell></row><row><cell>data sets</cell><cell>such that Th´</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 1 . Summary statistics of the data</head><label>1</label><figDesc></figDesc><table><row><cell cols="2">Data number</cell><cell>number</cell><cell cols="4">minimum frequent execution memory</cell></row><row><cell>set</cell><cell>of</cell><cell>of</cell><cell cols="2">frequency strings</cell><cell>time</cell><cell>used</cell></row><row><cell>( )</cell><cell>users</cell><cell>sequences</cell><cell>(Ò)</cell><cell>found</cell><cell cols="2">(seconds) (bytes)</cell></row><row><cell>nov</cell><cell>55</cell><cell>5164</cell><cell>24</cell><cell>294</cell><cell>3.24</cell><cell>56994</cell></row><row><cell>exp</cell><cell>36</cell><cell>3859</cell><cell>80</cell><cell>292</cell><cell>2.88</cell><cell>88706</cell></row><row><cell>non</cell><cell>25</cell><cell>1906</cell><cell>80</cell><cell>293</cell><cell>0.72</cell><cell>59754</cell></row><row><cell>sci</cell><cell>52</cell><cell>7751</cell><cell>48</cell><cell>295</cell><cell>4.89</cell><cell>94290</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 2 . Results on finding the union of two version spaces</head><label>2</label><figDesc></figDesc><table><row><cell>Suffix Time Trie (sec) Ì ½ 2.55 166 40 206 104 68 472 75 547 305 147 number of nodes total length of strings ¨© all Ë ¨© all Ë Ì ¾ 5.51 237 18 255 85 15 1489 23 1512 416 24</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The terminology used here is similar to that in concept-learning, where Í would be the space of examples, È´Í µ the set of possible concepts, and Ä the set of concept-descriptions.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>As in Apriori, one only needs to scan the data sets at most once for each level of the tree.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>This work was partly supported by the European IST FET project cInQ.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Fast algorithms for mining association rules</title>
		<author>
			<persName><forename type="first">R</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Srikant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB</title>
		<meeting>VLDB</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Mining association rules between sets of items in large databases</title>
		<author>
			<persName><forename type="first">R</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Imielinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Swami</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD</title>
		<meeting>SIGMOD</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="207" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Efficiently mining long patterns from databases</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bayardo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD</title>
		<meeting>SIGMOD</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The level wise version space algorithm and its application to molecular fragment finding</title>
		<author>
			<persName><forename type="first">L</forename><surname>De Raedt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kramer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IJCAI</title>
		<meeting>IJCAI</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Query evaluation and optimisation in inductive databases using version spaces</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">De</forename><surname>Raedt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EDBT Workshop on DTDM</title>
		<meeting>EDBT Workshop on DTDM</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">On supporting interactive association rule mining</title>
		<author>
			<persName><forename type="first">B</forename><surname>Goethals</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van Den Bussche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAWAK, LNCS</title>
		<meeting>DAWAK, LNCS</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1874</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Using unix: Collected traces of 168 users</title>
		<author>
			<persName><forename type="first">S</forename><surname>Greenberg</surname></persName>
		</author>
		<idno>88/333/45</idno>
	</analytic>
	<monogr>
		<title level="j">Canada</title>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Calgary</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Research Report</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Discovering All Most Specific Sentences by Randomized Algorithms</title>
		<author>
			<persName><forename type="first">D</forename><surname>Gunopulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mannila</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Saluja</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICDT</title>
		<meeting>ICDT</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1186</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">DMQL: A Data Mining Query Language for Relational Databases</title>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Koperski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Zaiane</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD&apos;96 Workshop on Research Issues on Data Mining and Knowledge Discovery</title>
		<meeting>SIGMOD&apos;96 Workshop on Research Issues on Data Mining and Knowledge Discovery<address><addrLine>Montreal, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-06">June 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Constraint-Based, Multidimensional Data Mining</title>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">V S</forename><surname>Lakshmanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">T</forename><surname>Ng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="46" to="50" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Mining frequent patterns without candidate generation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD</title>
		<meeting>SIGMOD</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Generalizing Version Spaces</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hirsh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine Learning</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="5" to="46" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Theoretical underpinnings of versionspaes</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hirsh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IJCAI</title>
		<meeting>IJCAI</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Molecular Feature Mining in HIV Data</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kramer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>De Raedt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Helma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGKDD</title>
		<meeting>SIGKDD</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Levelwise search and borders of theories in knowledge discovery</title>
		<author>
			<persName><forename type="first">H</forename><surname>Mannila</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Toivonen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Mining and Knowledge Discovery</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<author>
			<persName><forename type="first">T</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Generalization as Search</title>
		<imprint>
			<date type="published" when="1980">1980</date>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="203" to="226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Exploratory mining and pruning optimizations of constrained associations rules</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">T</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">V S</forename><surname>Lakshmanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD</title>
		<meeting>SIGMOD</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">On-line construction of suffix trees</title>
		<author>
			<persName><forename type="first">E</forename><surname>Ukkonen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="249" to="260" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Linear pattern matching algorithm</title>
		<author>
			<persName><forename type="first">P</forename><surname>Weiner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th IEEE Symposium on Switching and Automata Theory</title>
		<meeting>14th IEEE Symposium on Switching and Automata Theory</meeting>
		<imprint>
			<date type="published" when="1973">1973</date>
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
