<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Sumit</forename><surname>Gulwani</surname></persName>
							<email>sumitg@microsoft.com</email>
							<affiliation key="aff0">
								<orgName type="institution">Microsoft Research</orgName>
							</affiliation>
							<affiliation key="aff1">
								<address>
									<addrLine>PLDI&apos;06 June 11-14</addrLine>
									<postCode>2006</postCode>
									<settlement>Ottawa</settlement>
									<region>Ontario</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">6E7CD692E5A7432DCA9446DC7688CDE0</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:05+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.2.4 [Software Engineering]: Software/Program Verification</term>
					<term>F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs</term>
					<term>F.3.2 [Logics and Meanings of Programs]: Semantics of Programming Languages-Program analysis General Terms Algorithms, Theory, Verification Interpreter, Logical Product, Reduced Product, Nelson-Oppen Combination</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present a methodology for automatically combining abstract interpreters over given lattices to construct an abstract interpreter for the combination of those lattices. This lends modularity to the process of design and implementation of abstract interpreters.</p><p>We define the notion of logical product of lattices. This kind of combination is more precise than the reduced product combination. We give algorithms to obtain the join operator and the existential quantification operator for the combined lattice from the corresponding operators of the individual lattices. We also give a bound on the number of steps required to reach a fixed point across loops during analysis over the combined lattice in terms of the corresponding bounds for the individual lattices. We prove that our combination methodology yields the most precise abstract interpretation operators over the logical product of lattices when the individual lattices are over theories that are convex, stably infinite, and disjoint.</p><p>We also present an interesting application of logical product wherein some lattices can be reduced to combination of other (unrelated) lattices with known abstract interpreters.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Establishing full correctness for general programs is computationally intractable. Hence, program analysis and verification is typically performed over some (sound) abstraction or approximation of the program. This gives rise to false positives, i.e., some properties that are true in the original program may not be true in the abstract version. Abstract Interpretation is a well-known methodology to analyze programs over a given abstraction <ref type="bibr" target="#b4">[5]</ref>. There is an efficiency-precision trade-off in the choice of the abstraction. A Figure <ref type="figure">1</ref>. This program illustrates the difference between precision of performing analysis over direct product, reduced product, and logical product of the linear arithmetic lattice and uninterpreted functions lattice. Analysis over direct product can verify the first two assertions, while analysis over reduced product can verify the first three assertions. The analysis over logical product can verify all assertions. F denotes some function without any side-effects and can be modeled as an uninterpreted function for purpose of proving the assertions. more precise abstraction leads to fewer false positives but is also harder to reason about.</p><p>One commonly used method to create more precise abstract domains is by combining simpler ones. There are two commonly used notions of lattice combinations in the literature: the direct product, and the reduced product <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b3">4]</ref>. Both these combinations yield a lattice whose elements are a cartesian product of the elements of the individual lattices. The difference is that the lattice operations in the direct product are performed component-wise (also referred to as the independent attribute method <ref type="bibr" target="#b19">[20]</ref>), while in case of the reduced product the lattice operations take into account both components simultaneously. Hence, the direct product "discovers in one shot the information found separately by the component analyses but we do not learn more by performing all analyses simultaneously than by performing them one after another and finally taking their conjunctions". In case of reduced product the advantage is that "each analysis in the abstract composition benefits from the information brought by the other analyses" <ref type="bibr" target="#b3">[4]</ref>.</p><p>Consider, for example, the program shown in Figure <ref type="figure">1</ref>. Note that all assertions at the end of the program are true. If this program is analyzed over the linear equalities lattice (using, for example, the abstract interpreter described in <ref type="bibr" target="#b15">[16]</ref> or <ref type="bibr" target="#b4">[5]</ref>), then only the first assertion can be validated. This is because discovering the relationship between b1 and b2, between c1 and c2, and between d1 and d2 involves reasoning about uninterpreted functions. Similarly, if this program is analyzed over the uninterpreted functions lattice (using, for example, the abstract interpreter described in <ref type="bibr" target="#b11">[12]</ref>), then only the second assertion can be validated. Hence, an analysis over the direct product of these lattices can only verify the first two assertions (since performing an analysis over the direct product of these lattices is equivalent to performing analyses over the individual lattices independently and then putting the results together).</p><p>An analysis over the reduced product of these lattices can verify the third assertion too. Such an analysis computes at each program point the invariants that involve only linear arithmetic operators or only uninterpreted functions. In particular, it is able to discover the loop invariant c1 = c2, which is required to prove the third assertion. Hence, the reduced product combination is more precise than the direct product combination. However, there is no automatic way to construct the abstract interpretation operations for the reduced product lattice. In fact, Cousot and Cousot <ref type="bibr" target="#b5">[6]</ref> have pointed out that it is not possible to combine two abstract interpreters in a "blackbox" manner to obtain the most precise abstract interpreter for the reduced product lattice. The algorithms for the reduced product lattice need to be designed and implemented from scratch.</p><p>In this paper, we show how to automatically construct the most precise abstract interpretation for the reduced product combination of lattices that satisfy some constraint (namely, the elements of these lattices are conjunctions of atomic facts over theories that are convex, stably infinite, and disjoint). This constraint is general enough to describe several abstract domains that have been used to build existing abstract interpreters. In fact, we go one step further and define a new notion of combination for such lattices called logical product, which is more precise than the reduced product, and we show how to automatically construct abstract interpretation operations for the logical product lattice. The approach of automatically combining abstract interpretation operators lends modularity to the design and implementation of program analyses based on abstract interpretations. It avoids the need for proof of correctness of the analysis over combined domains (in fact, these proofs can be quite involved like our generic proof of correctness of our combination algorithms) and allows for reuse of implementations of analyses over the individual domains.</p><p>The logical product of lattices whose elements are conjunctions of atomic facts from theories T1 and T2 is the lattice whose elements are conjunctions of atomic facts over the combined theory T1 ∪ T2. Note that the logical product lattice consists of more elements than simply the direct product of the lattices, and hence it is more precise than the reduced product. Consider again the program shown in Figure <ref type="figure">1</ref>. Note that an analysis over the reduced product combination of linear arithmetic and uninterpreted functions lattice cannot verify the fourth assertion because the relevant loop invariant d2 = F (d1 + 1) is not expressible as an element of the reduced product lattice, which involves conjunctions of only linear equalities and equalities between uninterpreted function terms as opposed to equalities between mixed expressions (i.e., expressions that involve both linear arithmetic and uninterpreted functions). However, analysis over the logical product of linear arithmetic and uninterpreted functions lattices can verify all four assertions in the program.</p><p>Our methodology for combining abstract interpretation operators is inspired by the classic Nelson-Oppen methodology for combining decision procedures <ref type="bibr" target="#b18">[19]</ref>. Nelson and Oppen have showed how to combine decision procedures for convex, stably infinite and disjoint theories to obtain a decision procedure for the combined theory with only a polynomial-time blowup in the computational complexity. It turns out that abstract interpretation operators for a lattice over some theory are harder than the decision procedure for that theory. Hence, the problem of combining abstract interpretation operators is harder than the problem of combining decision procedures. As a result, the restrictions on theories that allow for efficient combination of their decision procedures (namely, convexity, stably infiniteness, and disjointness) also transfer to the context of combining abstract interpreters for lattices over those theories.</p><p>One of the attractive features of our combination algorithms is that the complexity of the abstract interpretation operators for the logical product lattice is at most quadratic in the complexity of the operations for the individual lattices. Also, our combination methodology is more general than being restricted to lattices over convex, stably infinite, and convex theories. In cases when the lattices to be combined do not satisfy the desired constraint, our combination methodology still gives abstract interpretation operations that are more precise than those for the direct product lattice; however they may not in general be as precise as the reduced product lattice.</p><p>In Section 5, we provide an interesting application of reasoning about logical product of lattices. It turns out that some lattices can be modeled as logical product of other unrelated lattices with known abstract interpreters. Hence, abstract interpreters for such decomposable lattices can be constructed by combining abstract interpretation operators for those other unrelated lattices using our combination methodology.</p><p>This paper is organized as follows. In Section 2, we introduce some basic terminology and discuss some basic operations in the Nelson-Oppen method for combining decision procedures. We use this terminology and operations in both Section 3 and Section 4. Section 3 defines the logical product combination of lattices, while Section 4 describes how to construct an abstract interpreter for the logical product of lattices given the abstract interpreter for the individual lattices. We describe an interesting application of our logical product combination methodology in Section 5. We then discuss some related work in Section 6 and future work in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Background</head><p>Our methodology for combining abstract interpreters is based on the Nelson-Oppen method of combining decision procedures <ref type="bibr" target="#b18">[19]</ref>. In this section, we introduce some terminology and algorithms that are used in the Nelson-Oppen method. We use this terminology and algorithms as part of our combination methodology described in Section 3 and Section 4.</p><p>A theory T consists of a signature Σ T , which is a set of function and predicate symbols, and some axioms A T , which define the meaning of the function and predicate symbols in Σ T . The combination of two theories T1 and T2 is the theory T1 ∪ T2 such that</p><formula xml:id="formula_0">Σ T 1 ∪T 2 = Σ T 1 ∪ Σ T 2 and A T 1 ∪T 2 = A T 1 ∪ A T 2 .</formula><p>A term t over theory T is an expression consisting of variables, and function symbols from Σ T . In this paper, we consider the following theories in our examples.</p><p>• Theory of parity.</p><p>This theory has the signature {=, even, odd , +, -, 0, 1}, where even and odd are unary predicates, while +, -are binary functions, and 0 and 1 are constants (nullary functions). The axioms of this theory include all standard axioms of even and odd numbers like even(0), even(t) ∧ odd (t ) ⇒ odd (t + t ), etc. In the latter axiom, t and t are universally quantified.</p><p>• Theory of sign. This theory has the signature {=, positive, negative, +, -, 0, 1}, where positive and negative are unary predicates.</p><formula xml:id="formula_1">E = x3 ≤ F (2x2 -x1) ∧ x3 ≥ x1 ∧ x1 = F (x1) ∧ x2 = F (F (x1)) AlienTerms T 1 ,T 2 (E) = {2x2 -x1, F (2x2 -x1)} Purify T 1 ,T 2 (E) = V, E1, E2 where E1 is t1 = 2x2 -x1 ∧ x3 ≤ t2 ∧ x3 ≥ x1 and E2 is t2 = F (t1) ∧ x1 = F (x1) ∧ x2 = F (F (x1)) and V is {t1, t2} NOSaturation T 1 ,T 2 (E1, E2) = E1 ∧ E , E2 ∧ E where E is x1 = x2 ∧ x1 = t1 ∧ x1 = t2 ∧ x1 = x3 Figure 2.</formula><p>This example illustrates the functions AlienTerms T 1 ,T 2 , Purify T 1 ,T 2 and NOSaturation T 1 ,T 2 , which are used in the Nelson-Oppen method of combining decision procedures. E is a conjunction of atomic facts over the combined theory of linear arithmetic (T1) and uninterpreted functions (T2).</p><p>• Theory of linear arithmetic. This theory has the signature {=, ≤, +, -, 0, 1}. We sometimes use the phrase theory of linear arithmetic with only equality to refer to the theory with signature {=, +, -, 0, 1}.</p><p>• Theory of uninterpreted functions. The signature of this theory consists of uninterpreted functions and the equality predicate. The theory of uninterpreted functions (UFS) has only one axiom for each function F a , namely,</p><formula xml:id="formula_2">a V i=1 ti = t i ⇒ F a (t1, . . , ta) = F a (t 1 , .</formula><p>. , t a ). Alternatively, we can reason about uninterpreted functions using the theory of term algebra (TA), where it is also the case that (1) F (t1, . . . , ta) = G(t 1 , . . . , t b ) iff a = b, F is same as G, and for all i, ti = t i , and (2) any term properly containing x is not equal to x. Due to a technical observation <ref type="bibr" target="#b12">[13]</ref>, using either of these theories gives the same results in the context of program analysis.</p><p>• Theory of lists. This theory has the signature {car , cdr , cons, =} with the usual axioms.</p><p>An atomic fact f over theory T is a predicate of the form p(t1, . . , ta), where p is a predicate symbol from Σ T and t1, . . , ta are terms over T. We use the notation Vars(γ) and Symbols(γ) to denote the set of variables and symbols respectively that occur in γ, where γ may be a term, fact, or conjunction of facts. We use the term definition for an atomic fact of the form x = t, where the variable x does not occur in the term t.</p><p>Let E be any conjunction of atomic facts over combination of two theories T1 ∪T2. We define AlienTerms T 1 ,T 2 (E) to be the set of all alien terms that occur in E. A term t in E is alien if the toplevel function symbol in t belongs to Σ T 1 (or Σ T 2 ) and t occurs as an argument of some function or predicate symbol from Σ T 2 (or Σ T 1 respectively) in E. For example, consider the conjunction E over the combination of the theories of linear arithmetic and uninterpreted functions in Figure <ref type="figure">2</ref>. Note that 2x2 -x1 is an alien term because it is a linear arithmetic term that occurs as an argument of uninterpreted function F (in the term F (2x2 -x1)). Similarly, the term F (2x2 -x1) is an alien term because its toplevel operator is the uninterpreted function F while it occurs as an argument of the inequality predicate in x3 ≤ F (2x2 -x1).</p><p>The Purify T 1 ,T 2 operator takes as input a conjunction of atomic facts E over combination of two theories T1 ∪ T2 and returns V, E1, E2 , where E1 and E2 are conjunctions of atomic facts over theories T1 and T2 respectively, and V is the set of all fresh variables that occur in E1 or E2 (but do not occur in E). Furthermore, E1 ∧ E2 is a conservative extension of E, i.e., for all facts f that do not involve variables in V , the following holds:</p><formula xml:id="formula_3">E T 1 ∪T 2 ⇒ f iff E1 ∧ E2 T 1 ∪T 2 ⇒ f</formula><p>Purification (i.e., the operation Purify T 1 ,T 2 (E)) decomposes a conjunction of atomic facts over combined theory T1 ∪ T2 into conjunctions of atomic facts, each of which is either over theory T1 or over theory T2. The purification of E involves introducing a fresh variable for each alien term in E. For example, consider the conjunction of atomic facts E in Figure <ref type="figure">2</ref>. Purify T 1 ,T 2 (E) is obtained from E by introducing new variables t1 and t2 to represent the alien terms of E.</p><p>The NOSaturation T 1 ,T 2 (E1, E2) operator takes as input two conjunctions of atomic facts E1 and E2 over theories T1 and T2 respectively, and returns E 1 and E 2 that are obtained from E1 and E2 respectively by saturating them with variable equalities that are implied by E1 ∧ E2.</p><formula xml:id="formula_4">E 1 = E1 ∧ E E 2 = E2 ∧ E E = P (x,y)</formula><p>x = y where P (x, y) is the following predicate:</p><formula xml:id="formula_5">(x, y ∈ Vars(E1 ∧ E2)) ∧ (E1 ∧ E2 T 1 ∪T 2 ⇒ x = y)</formula><p>E can be computed by repeatedly sharing variable equalities between E1 and E2. For example, consider the conjunction of atomic facts E1 and E2 over theories T1 and T2 respectively in Figure <ref type="figure">2</ref>. E 1 and E 2 are obtained from E1 and E2 by sharing variable equalities between them as follows:</p><formula xml:id="formula_6">E2 x 1 =x 2 -----→ E1 x 1 =t 1 -----→ E2 x 1 =t 2 -----→ E1 x 1 =x 3 -----→ E2</formula><p>A corollary of the correctness of the Nelson-Oppen combination method <ref type="bibr" target="#b18">[19]</ref> is that the NOSaturation T 1 ,T 2 operator has the following interesting property when theories T1 and T2 are convex, stably infinite and disjoint.</p><p>PROPERTY 1 (NOSaturation T 1 ,T 2 ). Let T1 and T2 be two convex and stably infinite theories that are disjoint. Let E be any conjunction of atomic facts over T1 ∪ T2. Let f be any atomic fact over</p><formula xml:id="formula_7">T1. Let V, E1, E2 = Purify T 1 ,T 2 (E) and E 1 , E 2 = NOSaturation T 1 ,T 2 (E1, E2). Then, E T 1 ∪T 2 ⇒ f iff E 1 T 1 ⇒ f A theory T is convex iff for every quantifier-free formula φ, φ T ⇒ W i xi = yi implies φ T ⇒ xj = yj</formula><p>for some j. A theory T is stably infinite iff for every quantifier-free formula φ, φ is satisfiable in T iff φ is satisfiable in an infinite model of T. Two theories T1 and T2 are disjoint if their signatures Σ T 1 and Σ T 2 are disjoint, while ignoring the equality symbol. For example, the theories of uninterpreted functions, linear arithmetic, and lists are all disjoint with respect to each other. In contrast, the theories of parity and</p><formula xml:id="formula_8">E1 = (x = a) ∧ (y = b) E2 = (x = b) ∧ (y = a) JL 1 (E1, E2) = (x + y = a + b) JL 2 (E1, E2) = true E1 ∨ E2 T 1 ∪T 2 ⇒ ĉ F (x + c) + F (y + c) = F (a + c) + F (b + c)</formula><p>L1: logical lattice over theory of linear arithmetic (T1) L2: logical lattice over theory of term algebra (T2) Figure <ref type="figure">3</ref>. This figure demonstrates why the implication relationship over finite conjunctions of atomic facts in the combined theory of linear arithmetic and term algebra does not form a lattice. Note that x + y = a + b is the only (independent) atomic fact that is implied by both E1 and E2 over the theory of linear arithmetic. Hence the join (i.e., least upper bound) of E1 and E2 in the logical lattice L1, denoted by JL 1 (E1, E2), is x + y = a + b. Also, note that there is no atomic fact over uninterpreted functions that is implied by both E1 and E2. However, over the combined theory of linear arithmetic and term algebra, there are infinite number of atomic facts that are implied by both E1 and E2; one such infinite family is:</p><formula xml:id="formula_9">F (x + c) + F (y + c) = F (a + c) + F (b + c) for all linear arithmetic constants c.</formula><p>sign are not disjoint. However, all of these five theories are convex and stably infinite.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Logical Lattices and Their Combination</head><p>A lattice L consists of a set DL and a partial order L among elements of DL. In this paper, we consider logical lattices, as defined below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DEFINITION 1 (Logical Lattice).</head><p>A lattice L is a logical lattice over some theory T if DL is the set of all finite conjunctions of atomic facts from theory T, and the partial order L is the implication relationship</p><formula xml:id="formula_10">T ⇒ in theory T, i.e., E L E iff E T ⇒ E .</formula><p>Any abstract domain can be viewed as a logical lattice over an appropriate theory. (However, the theory may not be convex or stably infinite, which are the assumptions required to guarantee the precision of our combination methodology.) For example, the abstract lattice used for discovering linear equalities between program variables <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b17">18]</ref> is a logical lattice over the theory of linear arithmetic with only equality, while the one used for discovering linear inequality relationships <ref type="bibr" target="#b6">[7]</ref> is over the general theory of linear arithmetic. The abstract lattice used for global value numbering for discovering Herbrand equivalences <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref> is a logical lattice over the theory of term algebra.</p><p>The implication relation in any theory T always defines a semilattice. A sufficient condition for this semi-lattice to be a lattice is that T have a finite basis property, that is, every infinite conjunction of atomic formulas over a finite number of variables be equivalent to a finite conjunction in the theory.</p><p>Let L1 and L2 be two logical lattices over theories T1 and T2 respectively. In the next section, we describe algorithms that perform abstract interpretation over the semi-lattice induced by T1 ∪ T2. Since T1 ∪ T2 need not induce a logical lattice even if T1 and T2 do, see Figure <ref type="figure">3</ref> for example, we precisely characterize the power of our combination algorithms by introducing the notion of logical product of lattices induced by convex, stably infinite, and disjoint theories.  DEFINITION 2 (Logical Product of Logical Lattices). Let T1 and T2 be two convex, stably-infinite, and disjoint theories. The logical product of the two logical lattices L1 and L2 over theories T1 and T2 respectively is defined to be the lattice L1 L2 where DL 1 L 2 is the set of all finite conjunction of atomic facts from theory T1 ∪ T2, and L 1 L 2 is the following partial order:</p><formula xml:id="formula_11">E L 1 L 2 E def = (E T 1 ∪T 2 ⇒ E ) ∧ (AlienTerms T 1 ,T 2 (E ) ⊆ Terms T 1 ,T 2 (E))</formula><p>For any conjunction of facts E in combination of two theories T1 and T2, we define Terms T 1 ,T 2 (E) to be the following set.</p><formula xml:id="formula_12">Terms T 1 ,T 2 (E) = {t | ∃t ∈ Vars(E) ∪ AlienTerms T 1 ,T 2 (E) such that E T 1 ∪T 2 ⇒ t = t }</formula><p>It would have been more natural to define L 1 L 2 to be simply T 1 ∪T 2 ⇒ ; but then as mentioned above, unfortunately,</p><formula xml:id="formula_13">T 1 ∪T 2</formula><p>⇒ does not necessarily form a lattice even when L 1 and L 2 define a logical lattice. One way to solve this problem would be to relax the domain DL 1 L 2 to also include infinite conjunction of atomic facts; in that case the choice of</p><formula xml:id="formula_14">T 1 ∪T 2 ⇒ as L 1 L 2 defines</formula><p>a lattice (and we refer to this as the strict logical product combination). However, this is not a good practical solution because we now need to represent and manipulate infinite conjunctions of atomic facts. Our recent results <ref type="bibr" target="#b12">[13]</ref> on hardness of assertion checking for programs that involve only linear arithmetic and uninterpreted functions imply that there cannot be any efficient data structure and algorithms to reason about such infinite conjunctions of atomic facts in general (unless P=coNP). <ref type="foot" target="#foot_0">1</ref>Our solution to solve the above problem is to define L 1 L 2 to have an additional restriction that is as weak as possible and along with the implication relationship defines a lattice. This additional restriction is AlienTerms T 1 ,T 2 (E ) ⊆ Terms T 1 ,T 2 (E). The failure of E1 and E2 (as defined in Figure <ref type="figure">3</ref>) to have a least upper bound under the implication relationship can be attributed to the fact that the number of alien terms that can be constructed over combination of two theories, even with a finite number of program variables, is unbounded. Considering that, the restriction AlienTerms T 1 ,T 2 (E ) ⊆ Terms T 1 ,T 2 (E) in the definition of L 1 L 2 is quite natural; it has the effect of including only those atomic facts in the least upper bound of E and E whose alien terms occur semantically in both elements E and E . By semantic (as opposed to syntactic) occurrence of an alien term t of E in E, we mean that there is some variable or alien term t in E such that E <ref type="figure" target="#fig_1">4</ref> illustrates the differences between the precision of strict logical product combination and logical product combination of lattices.</p><formula xml:id="formula_15">T 1 ∪T 2 ⇒ t = t , i.e., t ∈ Terms T 1 ,T 2 (E) (as opposed to t ∈ AlienTerms T 1 ,T 2 (E)). The program in Figure</formula><p>Note that the syntactic restriction t ∈ AlienTerms T 1 ,T 2 (E) would have been an (unnecessarily) stronger restriction compared to the semantic restriction t ∈ Terms T 1 ,T 2 (E). For example, consider the facts E1 = (x = F (a+1))∧(y = a) and E2 = (x = F (b + 1)) ∧ (y = b) over the combined theory of linear arithmetic and uninterpreted functions. The result of join of E1 and E2 is x = F (y + 1) under our definition of L 1 L 2 , while it is true in case of the stronger syntactic restriction</p><formula xml:id="formula_16">AlienTerms T 1 ,T 2 (E ) ⊆ AlienTerms T 1 ,T 2 (E). This is because the alien term y + 1 in x = F (y+1) belongs to Terms T 1 ,T 2 (E1) (since E1 T 1 ∪T 2 ⇒ y+1 = a + 1 and a + 1 is an alien term in E1) and Terms T 1 ,T 2 (E2) but it is not an alien term in E1 or E2.</formula><p>The following theorem states that L 1 L 2 as defined in Definition 2 indeed defines a lattice. THEOREM 1. The partial order L 1 L 2 between finite conjunctions of facts from theory T1 ∪ T2 defines a lattice under the assumptions made in Definition 2.</p><p>The proof of Theorem 1 follows from the fact that any two elements E, E ∈ DL 1 L 2 have a least upper bound (which is computed by the algorithm described in Figure <ref type="figure" target="#fig_3">6(a)</ref>) and a greatest upper bound (which is E ∧ E ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Abstract Interpreter for Combination of Logical Lattices</head><p>Let L1 and L2 be some logical lattices over theories T1 and T2 respectively. In this section, we show how to efficiently combine the abstract interpreters that operate over the lattices L1 and L2 to obtain an abstract interpreter that operates over the combined lattice L1 L2. Our combination methodology yields the most precise abstract interpreter for the combined lattice L1 L2 when (a) the theories T1 and T2 are convex, stably infinite, and disjoint, and (b) the individual abstract interpreters that operate over the lattices L1 and L2 are most precise themselves. The key idea of our combination methodology is to combine the corresponding transfer functions of the abstract interpreters that operate over the lattices L1 and L2 to yield the transfer functions of the abstract interpreter that operates over the lattice L1 L2.</p><p>An abstract interpreter performs a forward analysis on the program computing invariants (which are elements of the underlying lattice over which the analysis is being performed) at each program point. The invariants are computed at each program point can represent and perform abstract interpretation operations on infinite conjunctions of atomic facts in polynomial time unless P=coNP. from the invariants at the preceding program points in an iterative manner using appropriate transfer functions. The abstract interpreter that operates over the lattice L1 L2 uses the following transfer functions to compute these invariants across the different flowchart nodes shown in Figure <ref type="figure">5</ref>.</p><p>• Join Node. See Figure <ref type="figure">5(a)</ref>.</p><p>The element E after a join node is obtained by computing the least upper bound of the elements E1 and E2 before the join node (in the lattice L1 L2).</p><formula xml:id="formula_17">E = JL 1 L 2 (E1, E2)</formula><p>The join operator JL for any lattice L takes as input two elements E1 and E2 from DL and computes their least upper bound (under the partial order L). In Section 4.1, we show how to obtain JL 1 L 2 from JL 1 and JL 2 .</p><p>• Assignment Node. See Figure <ref type="figure">5</ref>(b). First note that an assignment x := e is general enough to model any programming language assignment. Memory, for example, can be modeled using array variables and select and update expressions, without losing any precision.</p><p>The element E after an assignment node x := e is the strongest postcondition of the element E before the assignment node. It is computed by using an existential quantification operator QL 1 L 2 as described below.</p><formula xml:id="formula_18">E = QL 1 L 2 (E1, {x }) where E1 = E [x /x] ∧ E 1 and E 1 = ( x = e[x /x] if Symbols(e) ⊆ Σ T 1 ∪T 2 true otherwise</formula><p>The existential quantification operator QL for any lattice L takes as input an element E from DL and a set of variables V , and produces the least upper bound of E (in the lattice L) that does not involve any variables in V . In Section 4.2, we show how to obtain QL 1 L 2 from QL 1 and QL 2 .</p><p>• Conditional Node. See Figure <ref type="figure">5(c</ref>).</p><p>The elements E1 and E2 on the two branches of a conditional are obtained by computing the meet (i.e., the greatest lower bound) of the element E before the join node with any atomic fact over the theory T1 ∪ T2 that is implied by the conditional on the corresponding branch.</p><formula xml:id="formula_19">E1 = ML 1 L 2 (E, E 1 ) E 1 = ( p if p is an atomic fact over theory T1 ∪ T2 true otherwise JL 1 L 2 (E , E r ) = 1 V , E 0 1 , E 0 2 := Purify T 1 ,T 2 (E ); 2 E 1 1 , E 1 2 := NOSaturation T 1 ,T 2 (E 0 1 , E 0 2 ); 3 V r , E r0 1 , E r0 2 := Purify T 1 ,T 2 (E r ); 4 E r1 1 , E r1 2 := NOSaturation T 1 ,T 2 (E r0 1 , E<label>r0</label></formula><p>2 );</p><formula xml:id="formula_20">5 V := { x, y | x ∈ V ∪ Vars(E ), y ∈ V r ∪ Vars(E r )}; 6 E 2 := V x,y ∈V x = x, y ; 7 E r2 := V x,y ∈V y = x, y ; 8 E1 := JL 1 (E 1 1 ∧ E 2 , E r1 1 ∧ E r2 ); 9 E2 := JL 2 (E 1 2 ∧ E 2 , E r1 2 ∧ E r2 );<label>10</label></formula><formula xml:id="formula_21">E := QL 1 L 2 (E1 ∧ E2, V );</formula><p>11 return E;</p><p>Inputs: Similarly,</p><formula xml:id="formula_22">E = (u = F (w)) ∧ (w = v + 1) E r = (u = F (u)) ∧ (v = F (u) -1) Trace of JL 1 L 2 (E1, E2): V , E 0 1 , E 0 2 = {}, w = v + 1, u = F (w) E 1 1 , E 1 2 = w = v + 1, u = F (w) V r , E r0 1 , E r0 2 = {b}, v = b -1, b = F (u) ∧ u = F (u) E r1 1 , E r1 2 = v = b -1 ∧ u = b, b = F (u) ∧ u = F (u) V = { w, b , w, u , w, v , u, b , u, u , u, v , . . .} E 2 = (w = w, b ) ∧ (w = w, u ) ∧ (w = w, v ) . . . E r2 = (b = w, b ) ∧ (u = w, u ) ∧ (v = w, v ) . . . E1 = (v = w, b + 1) E2 = (u = F ( w, b )) E = (u = F (v + 1)) (a) Algorithm (b) Example</formula><formula xml:id="formula_23">E2 = ML 1 L 2 (E, E 2 ) E 2 = ( ¬p</formula><p>if ¬p is an atomic fact over theory T1 ∪ T2 true otherwise Here ML 1 L 2 denotes the meet operator for the lattice L1 L2 and can be implemented simply as a conjunction operator.</p><formula xml:id="formula_24">ML 1 L 2 (E , E ) = E ∧ E</formula><p>In presence of loops in programs, the abstract interpreter goes around each loop until a fixed point is reached. A fixed point is said to be reached when the elements at any program point inside the loop in two successive iterations of that loop represent the same lattice element. We show in Section 4.3 that the number of steps required to reach a fixed point across a loop (when the analysis is performed over the lattice L1 L2) is linear in the number of steps required to reach a fixed point across that loop when the analysis is performed over the lattices L1 or L2. If the lattices L1 or L2 have infinite chains above a given element, then fixed point for a loop may not be reached in a finite number of steps. In that case, a widening operation may be used to over-approximate the analysis results at loop headers. A widening operator for a lattice L takes as input two elements from DL and produces an upper bound of those elements (which may not necessarily be the least upper bound). A widening operator has the property that it guarantees fixed point computation across loops terminates in a finite number of steps even for infinite height lattices. A widening operator for the lattice L1 L2 can be constructed from widening operators for the lattices L1 and L2 respectively in exactly the same way as JL 1 L 2 is constructed from JL 1 and JL 2 . Section 4.3 discusses these issues in more detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Combining Join Operators</head><p>The join operator JL for a lattice L takes as input two elements E1 and E2 from DL and computes the least upper bound of E1 and E2 with respect to the partial order L. The following definition makes this more precise. DEFINITION 3 (Join Operator JL). Let E = JL(E1, E2). Then,</p><p>• Soundness: E1 L E and E2 L E.</p><formula xml:id="formula_25">• Completeness: If E is such that E1 L E and E2 L E , then E L E .</formula><p>Figure <ref type="figure" target="#fig_3">6</ref> shows how to implement the join operator JL 1 L 2 for the combined lattice L1 L2 using the join operators JL 1 and JL 2 for the logical lattices L1 and L2. Lines 1 and 2 perform purification and NO-saturation of the input E . Purification of E (which involves atomic facts over combination of two theories T1 ∪ T2) serves the purpose of splitting the input E into two parts E 0 1 and E 0 2 each of which involves facts over either T1 or T2, and hence can be understood by either JL 1 or JL 2 . The NO-saturation of E 0 1 and E 1 2 serves the purpose of sharing information between E 0 1 and E 1 2 so that each of them can independently imply the atomic facts in corresponding theories that are implied by E (Property 1). Similarly, lines 3 and 4 perform purification and NO-saturation of the other input E r .</p><p>Lines 5 through 7 introduce some dummy variables and definitions for purpose of creating variable names for some potential alien terms in the output. If we leave out lines 5 through 7 in the combination algorithm, then we simply obtain a join operator for the reduced product combination of lattices L1 and L2 because both E1 and E2 are atomic facts involving only those variables that occur in E and E r . However, presence of these dummy variables and definitions allow the individual join operators JL 1 and JL 2 to output result in terms of these dummy variables along with their definitions. Elimination of these dummy variables in line 10 (using the existential quantification operator QL 1 L 2 described in the next section) results in mixed facts over the combined theory T1 ∪ T2. In the example in Figure <ref type="figure" target="#fig_3">6</ref>(b), v + 1 is such an alien term in the output, which is represented by the dummy variable a, b in E 1  1 ∧ E 2 as well as in E r2</p><p>1 ∧ E r2 . The operator NOSaturation T 1 ,T 2 involves sharing variable equalities between its input elements until no more equalities can be shared. It can be implemented using an operator VE T that takes as input a conjunction of atomic facts in theory T and discovers all variable equalities implied by it. The VE T operator for any theory T is theoretically at most as hard as the join operator JL for the logical lattice L over theory T, as is exhibited by the following construction.</p><formula xml:id="formula_26">QL 1 L 2 (E, V ) = 1 V 0 , E 0 1 , E 0 2 := Purify T 1 ,T 2 (E); 2 E 1 1 , E 1 2 := NOSaturation T 1 ,T 2 (E 0 1 , E 0 2 ); 3 V 1 := V 0 ∪ V ; 4 V 2 , Defs := QSaturation T 1 ,T 2 (E 1 1 , E 1 2 , V 1 ); 5 E 2 1 := QL 1 (E 1 1 , V 2 ); 6 E 2 2 := QL 2 (E 1 2 , V 2 ); 7 E 3 1 := E 2 1 [Defs(y)/y] for all y ∈ V 2 -V 1 ; 8 E 3 2 := E 2 2 [Defs(y)/y] for all y ∈ V 2 -V 1 ; 9 return E 3 1 ∧ E 3 2 ; QSaturation T 1 ,T 2 (E 1 1 , E 1 2 , V 1 ) = 1 V 2 := V 1 ; 2 Defs := ∅; 3 repeat 4 for all y ∈ V 1 5 t := Alternate T 1 (E 1 1 , y, V 2 ); 6 if t = ⊥, then t := Alternate T 2 (E 1 2 , y, V 2 ); 7 if t = ⊥, then Defs := Defs ∧ y = t; 8 V 2 := V 2 -{y}; 9</formula><p>until no change in V 2 ; 10 return V 2 ,Defs ;</p><p>Inputs: However, for several theories, the VE T operator for a theory can be implemented in a simpler and more efficient manner than the join operator for the corresponding logical lattice. For example, the VE T operator for the theory of uninterpreted functions can be implemented using congruence closure algorithm, while the join operator for the theory of uninterpreted functions is based on automata intersection <ref type="bibr" target="#b14">[15]</ref>. The VE T operator for the theory of linear arithmetic with only equality (i.e., no inequalities) can be implemented simply using Gaussian elimination, while the join algorithm is more involved <ref type="bibr" target="#b15">[16]</ref>.</p><formula xml:id="formula_27">E = (x ≤ y) ∧ (y ≤ u) ∧ (x = F (F (1 + y))) ∧ (v = F (y + 1)) V = {x, y} Trace of QL 1 L 2 (E, V ): V 0 , E 0 1 , E 0 2 = {a}, x ≤ y ∧ y ≤ u ∧ a = 1 + y ∧ b = y + 1, x = F (F (a)) ∧ v = F (b) E 1 1 , E 1 2 = x ≤ y ∧ y ≤ u ∧ a = 1 + y ∧ b = y + 1, x = F (F (a)) ∧ v = F (b) ∧ a = b V 1 = {x, y, a, b} V 2 , Defs = {y, a, b}, x = F (v) E 2 1 = x ≤ u E 2 2 = true E 3 1 = F (v) ≤ u E 3 2 = true</formula><p>The following theorem states that our algorithm for the join operator JL 1 L 2 (E , E r ) (as described in Figure <ref type="figure" target="#fig_3">6(a)</ref>) computes an upper bound of E and E r .</p><formula xml:id="formula_28">THEOREM 2 (Soundness of JL 1 L 2 algorithm). If E = JL 1 L 2 (E , E r ), then E L 1 L 2 E and E r L 1 L 2 E.</formula><p>The proof of Theorem 2 is not difficult and can be found in the full version of this paper <ref type="bibr" target="#b13">[14]</ref>.</p><p>The following theorem states that the upper bound computed by our algorithm for the join operator JL 1 L 2 (E , E r ) is least if the underlying theories are convex, stably infinite, and disjoint. THEOREM 3 (Completeness of JL 1 L 2 algorithm). Suppose the theories T1 and T2 are convex, stably infinite and disjoint. Let</p><formula xml:id="formula_29">E = JL 1 L 2 (E , E r ). Let E be such that E L 1 L 2 E and E r L 1 L 2 E . Then E L 1 L 2 E .</formula><p>The proof of Theorem 3 is non-trivial and is given in the appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Combining Existential Quantification Operators</head><p>QL(E, V ) computes the best approximation to the existentially quantified element ∃xE (where V is some set of variables) in the lattice L. The following definition makes this more precise.</p><p>DEFINITION 4 (Existential Quantification Operator QL). Let E = QL(E, V ). Then,</p><p>• Soundness:</p><formula xml:id="formula_30">E L E and Vars(E ) ∩ V = ∅ • Completeness: If E is such that E L E and Vars(E ) ∩ V = ∅, then E L E .</formula><p>Figure <ref type="figure" target="#fig_4">7</ref> shows how to combine existential quantification operators for logical lattices. Lines 1 and 2 perform purification and NO-saturation of the input E (for the same reasons as in case of our algorithm for JL 1 L 2 operator). Purification introduces some new variables V 0 , which also need to be eliminated. V 1 on line 3 represents the set of all variables that need to be eliminated. We first filter out those variables from V 1 that have some definition t such that Vars(t) ∩ V = ∅ using the operator QSaturation T 1 ,T 2 (E1, E2, V 1 ). The following claim states this more formally.</p><formula xml:id="formula_31">CLAIM 1. Let (V 2 , Defs) = QSaturation T 1 ,T 2 (E 1 1 , E 1 2 , V 1 )</formula><p>, where E 1</p><p>1 and E 1 2 are purified and NO-saturated.</p><formula xml:id="formula_32">If E 1 1 ∧E 1 2 T 1 ∪T 2 ⇒ y = t and Vars(t) ∩ V 1 = ∅, then y ∈ V 2 .</formula><p>In lines 5 and 6, we use the existential quantification operators for the individual lattices to eliminate the variables V 2 from E 1  1 and E 1 2 . We then eliminate all variables in the set V 1 -V 2 by replacing them by their definitions (lines 7 and 8).</p><p>The implementation of QSaturation T 1 ,T 2 operator makes use of operators Alternate T 1 and Alternate T 2 . Alternate T (E, y, V ) returns a term t (if it exists) such that E T ⇒ y = t and Vars(t) ∩ (V ∪ {y}) = ∅. If no such term exists, then Alternate T (E, y, V ) returns ⊥. The implementation of Alternate T operator is theory-specific. For example, the Alternate T operator for the theory of uninterpreted functions involves constructing a congruence closed EDAG representing E, erasing all variables in V ∪ {y} from the EDAG, and then returning any term t from the equivalence class of y. The Alternate T operator for the theory of linear arithmetic can be implemented by discovering all equalities implied by E (by using a linear inequalities reasoning algorithm like simplex or ellipsoid algorithm), eliminating all variables in V using Gaussian elimination, and then returning any term t from any equality that involves variable y. We do not know of any general algorithm for implementing Alternate T , however we conjecture that the Alternate T operator for any theory T is at most as hard as the existential quantification operator QL for the corresponding logical lattice L since QL(E, V ∪ {y}) should ideally replace all occurrences of y in E by the desired term t (if it exists) unless it rewrites the facts in a different manner.</p><p>The following theorem states that our algorithm for the existential quantification operator QL 1 L 2 (E, V ) (as described in Figure <ref type="figure" target="#fig_4">7(a)</ref>) computes an upper bound of E that does not involve any variables in V . The proof of this theorem is not difficult and can be found in the full version of this paper <ref type="bibr" target="#b13">[14]</ref>.</p><formula xml:id="formula_33">THEOREM 4 (Soundness of QL 1 L 2 algorithm). Let E = QL 1 L 2 (E, V ). Then, E L 1 L 2 E and Vars(E ) ∩ V = ∅.</formula><p>The following theorem states that the upper bound of E computed by our algorithm for the existential quantification operator JL 1 L 2 (E, V ) is least if the underlying theories are convex, stably infinite, and disjoint. THEOREM 5 (Completeness of QL 1 L 2 algorithm). Suppose the theories T1 and T2 are convex, stably infinite and disjoint. Let</p><formula xml:id="formula_34">E = QL 1 L 2 (E, V ). Let E be such that E L 1 L 2 E and Vars(E ) ∩ V = ∅. Then, E L 1 L 2 E .</formula><p>The proof of Theorem 5 is non-trivial and can be found in the full version of this paper <ref type="bibr" target="#b13">[14]</ref>. Figure <ref type="figure">8</ref> describes an example that illustrates why the completeness of our combination algorithm for existential quantification operator relies on the fact that the underlying theories are disjoint. This example is adapted from Cousots' early work <ref type="bibr" target="#b5">[6]</ref> in which they argued that it is not possible to combine abstract interpreters for any two arbitrary abstractions in a blackbox manner to obtain the most precise abstract interpreter for the combined lattice. The example used to illustrate this point was the computation of strongest postcondition of even(x) ∧ positive(x) with respect to the assignment x := x -1. The abstract interpreter operating over the parity abstraction will compute odd (x) while the abstract interpreter operating over the sign abstraction will compute true, and there is no way to combine the results of these abstract interpreters in a black-box manner to generate the most precise result, which is odd (x) ∧ positive(x).</p><p>It is interesting to note that if we define V 2 on line 4 to be V 1 (and not invoke the QSaturation T 1 ,T 2 operator), then we obtain an existential quantification operator for the reduced product combination of lattices L1 and L2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Fixed Point Computation</head><p>In presence of loops, the abstract interpreter goes around each loop until a fixed point is reached. The number of times a node η inside a loop is processed is bounded above by the maximum number of elements above E along any chain in the lattice L1 L2, where E is the element before the node η when it is first processed. Let HL(E) denote the maximum number of elements above E in any chain in any lattice L. The following theorem specifies a bound on HL 1 L 2 (E) in terms of HL 1 (E1) and HL 2 (E2), where E1 and E2 are obtained by purification and NO-saturation of E.</p><formula xml:id="formula_35">E1 = even(x ) ∧ x = x -1 E2 = positive(x ) ∧ x = x -1 QL 1 (E1, {x }) = odd (x) QL 2 (E2, {x }) = true QL 1 L 2 (E1 ∧ E2, {x }) = odd (x) ∧ positive(x)</formula><p>Figure <ref type="figure">8</ref>. This figure illustrates the incompleteness of our algorithm for QL 1 L 2 in presence of theories that share common function symbols. Since, E1 ∧ E2 is already purified and NO-saturated, and QSaturation T 1 ,T 2 does not return any definitions, our algorithm for QL 1 L 2 (E1 ∧ E2, {x }) outputs QL 1 (E1, {x }) ∧ QL 2 (E2, {x }), i.e., odd (x), which is less precise than the result odd (x) ∧ positive(x). The example in this figure is adapted from <ref type="bibr" target="#b5">[6]</ref>.</p><formula xml:id="formula_36">THEOREM 6. Let E ∈ DL 1 L 2 , V, E 0 1 , E 0 2 = Purify T 1 ,T 2 (E),<label>and</label></formula><formula xml:id="formula_37">E1, E2 = NOSaturation T 1 ,T 2 (E 0 1 , E 0 2 ). Then, HL 1 L 2 (E) ≤ HL 1 (E1) + HL 2 (E2) + |AlienTerms T 1 ,T 2 (E)|</formula><p>where E1 and E2 are obtained by purification and NO-saturation of</p><formula xml:id="formula_38">E. |AlienTerms T 1 ,T 2 (E)| denotes the size of the set AlienTerms T 1 ,T 2 (E).</formula><p>The proof of Theorem 6 is non-trivial and is given in the appendix. It follows from Theorem 6 that the number of times each node inside a loop is processed is linear in the number of times each node is processed when analysis is done over the lattices L1 and L2. However, if the lattice L1 (or L2) has infinite chains above some elements, then fixed point may not be reached across the loop in a finite number of steps when the analysis is performed over the lattice L1 L2 or even the lattice L1 (or lattice L2). In that case, a widening operation is needed to over-approximate the analysis results at loop headers. A widening operator for the lattice L1</p><p>L2 can be constructed from the widening operations for the lattices L1 and L2 using the same algorithm that combines join operators (described in Figure <ref type="figure" target="#fig_3">6</ref>). The proof of correctness of the construction of the widening operator is same as the soundness proof of the combination of join algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Complexity</head><p>Let TJ L (n), TQ L (n), TM L (n) and TA T (n) denote the time taken by the join operator JL, existential quantification operator QL, meet operator ML and Alternate T operator respectively to operate on inputs of size n. It follows from reduction of NOSaturation T 1 ,T 2 operator in terms of the join operators JL 1 and JL 2 (as described in Section 4.1) that the complexity of NOSaturation T 1 ,T 2 operator (for two input elements of size n over theories T1 and T2 is at most n times the sum of TJ L 1 (n) + TJ L 2 (n). It now follows from Figure <ref type="figure" target="#fig_3">6</ref> and Figure <ref type="figure" target="#fig_4">7</ref> that:</p><formula xml:id="formula_39">TJ L 1 L 2 (n) = O(TJ L 1 (n 2 ) + TJ L 2 (n 2 ) + TQ L 1 L 2 (n 2 )) TQ L 1 L 2 (n) = O(TQ L 1 (n) + TQ L 2 (n) + n × TA T 1 (n) + n × TA T 2 (n) + n × TJ L 1 (n) + n × TJ L 2 (n)) TM L 1 L 2 (n) = O(n)</formula><p>Above we use the fact that complexity of NOSaturation T 1 ,T 2 operator on inputs of size</p><formula xml:id="formula_40">n is O(n × TJ L 1 (n) + n × TJ L 2 (n)), which is also O(TJ L 1 (n 2 ) + TJ L 2 (n 2 )).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Applications of Combination Methodology</head><p>The obvious application of our combination methodology to combine abstract interpreters for given lattices is to analyze programs over the logical product combination of those lattices. However, there is another interesting application of this combination methodology. It turns out that certain lattices L can be reduced to strict logical product combination of some other lattices, which may be unrelated to L. If analyses for those other lattices are already known, then the analyses can be combined using our combination methodology to construct an analysis for L<ref type="foot" target="#foot_1">2</ref> . We next describe some lattices L that can be reduced to strict logical product combination of other (unrelated) lattices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Commutative Functions</head><p>Commutative functions are useful in modeling binary program operators that are commutative, e.g. floating-point addition and multiplication. Note that these floating-point operators should not be abstracted as linear arithmetic operators since they do not obey associativity because of overflow issues.</p><p>The lattice of commutative functions can be reduced to the strict logical product combination of the lattice of single unary uninterpreted function and the linear arithmetic lattice. This can be done by using some injective mapping to transform terms that use commutative functions to terms that use a single unary uninterpreted function and linear arithmetic as described below.</p><p>Consider the following language of terms that use commutative functions. Here x denotes some variable, while Gi denotes some uninterpreted function.</p><formula xml:id="formula_41">t ::= x | Gi(t1, t2)</formula><p>The following mapping M maps these terms that use commutative functions Gi's to terms that use a single uninterpreted function F and linear arithmetic.</p><formula xml:id="formula_42">M (x) = x M (Gi(t1, t2)) = F (i + M (t1) + M (t2))</formula><p>The following claim implies that the mapping M is injective and equivalence preserving. Hence, this transformation of lattices (obtained by mapping terms) is both sound and complete. CLAIM 2. t1 = t2 iff M (t1) = M (t2) Claim 2 can be proved by induction on structure of term e.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Uninterpreted Functions</head><p>Uninterpreted functions are commonly used to model programming language operators that are otherwise hard to reason about. They are also used to abstract procedure calls with no side-effects.</p><p>The lattice of uninterpreted functions can be reduced to the strict logical product of the lattice of a single unary uninterpreted function and the linear arithmetic lattice. For this purpose, we describe a transformation that converts terms involving (potentially multiple) uninterpreted function symbols of any finite arity to terms that use only one unary uninterpreted function symbol.</p><p>Consider the following language of terms. Here x denotes some program variable, while G a i denotes some uninterpreted function of arity a. t ::= x | G a i (t1, . . . , ta)</p><p>The following mapping M maps these terms to terms that use a single uninterpreted function F and linear arithmetic.</p><formula xml:id="formula_43">M (x) = x</formula><p>M (G a i (t1, . . . , ta)) = F (i + 2 1 M (t1) + . . . + 2 a M (ta)) Claim 2 holds for this mapping too. Hence, this transformation of lattices is both sound and complete.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Related Work</head><p>The problem of combining abstract interpreters for combination of abstract lattices was first considered by Cousot and Cousot <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b3">4]</ref>. They defined different notions of combination of lattices: the direct product and the more precise reduced product. The notion of reduced product of combination of lattices does not specify any automatic way to construct the abstract interpretation operations for the combined lattice. In this paper, we introduce a new notion of combination of lattices called logical product, which is more powerful than the reduced product. We also describe algorithms to automatically construct the abstract interpretation operations for the logical product lattice from the abstract interpretation operations for the individual logical lattices. Our algorithms can be simplified to yield abstract interpretation operations for the reduced product of the underlying logical lattices.</p><p>An abstract lattice can be lifted to its powerset lattice (called disjunctive completion), which is more precise since there is no loss of information in join computations <ref type="bibr" target="#b5">[6]</ref>. It is interesting to note that the precision of logical product combination is incomparable with the disjunctive completion of a reduced product combination. The former yields more precise information across assignment nodes since it can represent atomic facts that involve combination of signatures of the individual lattices. The latter yields more precise information across join points since it can represent disjunction of atomic facts (each of which is pure though).</p><p>Codish et. al. <ref type="bibr" target="#b1">[2]</ref> have studied the problem of automatically generating abstract interpretation for reduced product combination of lattices. However, their work has focused on logic programs, while we are concerned with imperative programs. Also, their combination methodology does not provide any precision guarantees with respect to the reduced product lattice. On the other hand, our combination methodology gives precision guarantees over reduced product (in fact, even over a more precise logical product) combination of a general class of lattices.</p><p>Chang and Leino <ref type="bibr" target="#b0">[1]</ref> have presented preliminary results on combining a given abstract domain with the domain of uninterpreted symbols, but do not define and prove correctness for their combination. They point out several subtleties that can arise when dealing with the semi-lattice induced by uninterpreted symbol (see also <ref type="bibr" target="#b14">[15]</ref>). Our results here consolidate and build a nontrivial framework under which to define and modularly prove correctness of these past approaches.</p><p>Lerner, Grove and Chambers have described how to automatically combine dataflow analyses in the context of compiler optimizations <ref type="bibr" target="#b16">[17]</ref>. Their technique involves implicit communication between the individual components of a super-analysis based on graph transformations. They have shown that under a certain monotonicity condition, their combination algorithm produces no worse results than running arbitrarily iterated sequences of the individual analyses.</p><p>Reps, Sagiv and Yorsh <ref type="bibr" target="#b20">[21]</ref> show that an abstract interpreter can be constructed using only a decision procedure (that can also produce models) and a join operator. This suggests that abstract interpreter for combination lattices can be constructed assuming a combination decision procedure and a join algorithm for the combined lattice. In our work, we make no such assumptions. Also, unlike our algorithms, the complexity of the procedure for computing meet and SP suggested by Reps et. al. is linear in the height of the lattice, which is usually unbounded in rich domains.</p><p>The idea of decomposing a lattice into a reduced product of simpler lattices has been formally studied by Cortesi et. al. <ref type="bibr" target="#b2">[3]</ref>. However, the results in Section 5 present nontrivial reductions of some specific lattices into logical products of other (unrelated) lattices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion and Future Work</head><p>This paper describes how to automatically combine the power of abstract interpreters in a non-trivial manner. We define a notion of logical product of lattices, which is more precise than the commonly known reduced product. Our combination methodology yields the most precise abstract interpreter for the logical product combination of lattices, when the individual lattices are over theories that are convex, stably infinite, and disjoint. In other cases, our combination methodology acts as an efficient heuristic to combine the power of given abstract interpreters in a non-trivial manner.</p><p>The process of analyzing a program using abstract interpretation over a given abstract domain involves two main steps: designing the abstract interpretation operators for the abstract domain, and implementing them. The combination methodology described in this paper helps in modularizing both these steps. A user can focus on designing and/or implementing abstract interpreters for potentially simple domains, and then use our combination methodology to automatically construct abstract interpreter for the combination of those domains, which is more precise than the individual domains.</p><p>The concept of logical product suggests several directions for future work. It may be worthwhile to explore logical products and compare them to reduced products in the framework of abstract domains and closures <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9]</ref>. The conditions under which our combination methodology generates the most precise abstract interpreter over logical product are inherited from the Nelson-Oppen combination result for combining decision procedures. It would be useful to see if our results can be extended to perform a precise analysis for non-convex theories (e.g., the theory of arrays), or combination of non-disjoint theories. There has been a lot of work in the theorem-proving community to extend Nelson-Oppen combination methodology for decision procedures to reason about nonconvex or non-disjoint theories that could also be relevant here. On the other hand, it would be interesting to experimentally evaluate the imprecision of our combination methodology in reasoning over combination of non-convex or non-disjoint theories. Since the notion of logical product is more precise than reduced product and direct product, another interesting piece of experimentation would be to compare the cost and precision of an analysis over logical product as opposed to direct product or reduced product. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Proof of Theorem 3</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Proof of Theorem 6</head><p>Let E be such that E L 1 L 2 E and E L 1 L 2 E. Let E 1 and E 2 be obtained by purification and NO-saturation of E . Since AlienTerms T 1 ,T 2 (E ) ⊆ Terms T 1 ,T 2 (E), we can assume without loss of generality that E has been purified using the variables and definitions used to purify E. It suffices to show the following. (i) E1 L 1 E 1 and E2 L 2 E 2 . (ii) Either E 1 L 1 E1 or E 2 L 2 E2 or AlienTerms T 1 ,T 2 (E ) ⊂ AlienTerms T 1 ,T 2 (E).</p><p>We first prove (i). Let Defs be the conjunction of definitions required for purification of E. Since E T 1 ∪T 2 ⇒ E , we have that:</p><formula xml:id="formula_44">E ∧ Defs T 1 ∪T 2 ⇒ E ∧ Defs<label>(4)</label></formula><p>Note that E ∧Defs </p><formula xml:id="formula_45">E ∧ Defs T 1 ∪T 2 ⇒ E ∧ Defs (<label>8</label></formula><formula xml:id="formula_46">)</formula><p>Since Defs is simply a conjunction of definitions for variables that do not occur in E and E, it follows from Equation <ref type="formula" target="#formula_45">8</ref>that</p><formula xml:id="formula_47">E T 1 ∪T 2 ⇒ E<label>(9)</label></formula><p>It follows from Equation <ref type="formula">7</ref>and Equation 8 that E L 1 L 2 E. This is a contradiction.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>False True x := F(a+1); y := a, x := F(b+1); y := b, Assert(x = F(y+1)); Assert(F(a)+F(b) = F(y)+F(a+b-y));</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. This program illustrates the difference between precision of strict logical product combination and logical product combination of lattices (over linear arithmetic and uninterpreted functions). Abstract interpretation over strict logical product combination can verify both assertions because the join of x = F (a + 1) ∧ y = a and y = F (b + 1) ∧ y = b includes equalities in both assertions. (This involves representing and manipulating infinite conjunctions of atomic facts, which is inefficient.) On the other hand, abstract interpretation over the logical product combination can verify only the first assertion because the result of the join is x = F (y + 1).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>1 Figure 5 .</head><label>15</label><figDesc>Figure 5. Flowchart Nodes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. This figure describes the algorithm for join operator for combined lattice L1 L2 in terms of the join operators for the lattices L1 and L2 along with an example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. This figure describes the algorithm for existential quantification operator for combined lattice L1 L2 in terms of the existential quantification operators for the lattices L1 and L2 along with an example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Let {z1, . . . , zm}, E 1 , E 2 = Purify T 1 ,T 2 (E ). Since E L 1 L 2 E , we have that E T 1 ∪T 2 ⇒ E and AlienTerms T 1 ,T 2 (E ) ⊆ Terms T 1 ,T 2 (E ). This implies that there exist variables x1, . . . , xm in V ∪ Vars(E ) such that It follows from Property 1 (property of NOSaturation T 1 ,T 2 ) that ⇒ E 2 [x1/z1, . . . , xm/zm] Similarly, there exist variables y1, . . . , ym ∈V r ∪ Vars(E r ) s.t. ∧ E 2 T 1 ⇒ E 1 [ x1, y1 /z1, . . . , xm, ym /zm] E 1 2 ∧ E 2 T 2 ⇒ E 2 [ x1, y1 /z1, . . . , xm, ym /zm] E r1 1 ∧ E r2 T 1 ⇒ E 1 [ x1, y1 /z1, . . . , xm, ym /zm] E r1 2 ∧ E r2 T 2 ⇒ E 2 [ x1, y1 /z1, . . . , xm, ym /zm]It follows from completeness of join algorithms JL 1 and JL 2 that⇒ E . It now follows from the completeness of QL 1 L 2 that We now show that AlienTerms T 1 ,T 2 (E ) ⊆ Terms T 1 ,T 2 (E). Consider any t ∈ AlienTerms T 1 ,T 2 (E ). ∃i s.t. 1 ≤ i ≤ m and E 1 ∧ E 2 T 1 ∪T 2This implies that the variable xi, yi does not belong to the set V2 (on Line 4) in our algorithm of the operator QL 1 L 2 when QL 1 L 2 is called from within JL 1 L 2 . Hence, QL 1 L 2 eliminates variable xi, yi in E1 ∧ E2 by substitution with some term t . Note that E1 ∧ E2 T 1 ∪T 2 ⇒ t = t . The variable zi (introduced during the purification step) occurs in a non-trivial manner in both E 1 and E 2 and hence it follows from Equation 1 and Equation 2 that the variable xi, yi occurs in both E1 and E2. This implies that the term t occurs in both E3  1 and E 3 2 (as defined on Lines 7 and 8 in pseudo-code of QL 1 L 2 ) and hence t ∈ Terms T 1 ,T 2 (E) (note that E = E 3 1 ∧ E 3 2 ). Since E1 ∧ E2 T 1 ∪T 2 ⇒ t = t , we have that E T 1 ∪T 2 ⇒ t = t . Thus, t ∈ Terms T 1 ,T 2 (E).</figDesc><table><row><cell></cell><cell cols="2">E 1 1</cell><cell>T 1 ⇒ E 1 [x1/z1, . . . , xm/zm]</cell></row><row><cell></cell><cell cols="2">2 E 1</cell><cell>T 2</cell></row><row><cell></cell><cell cols="2">E r1 1</cell><cell>T 1 ⇒ E 1 [y1/z1, . . . , ym/zm]</cell></row><row><cell></cell><cell cols="2">E r1 2</cell><cell>T 2 ⇒ E 2 [y1/z1, . . . , ym/zm]</cell></row><row><cell>Hence,</cell><cell></cell><cell></cell></row><row><cell>E 1 1 E1</cell><cell cols="3">T 1 ⇒ E 1 [ x1, y1 /z1, . . . , xm, ym /zm]</cell><cell>(1)</cell></row><row><cell>E2</cell><cell cols="3">T 2 ⇒ E 2 [ x1, y1 /z1, . . . , xm, ym /zm]</cell><cell>(2)</cell></row><row><cell cols="2">Hence, E1 ∧ E2</cell><cell cols="2">T 1 ∪T 2</cell></row><row><cell></cell><cell></cell><cell></cell><cell>E</cell><cell>T 1 ∪T 2 ⇒ E</cell></row><row><cell></cell><cell></cell><cell></cell><cell>⇒ zi = t</cell><cell>(3)</cell></row><row><cell cols="4">It follows from Equation 1, Equation 2, and Equation 3 that</cell></row><row><cell></cell><cell cols="3">E1 ∧ E2</cell></row><row><cell></cell><cell></cell><cell></cell><cell>E 0 1 ∧ E 0 2</cell><cell>T 1 ∪T 2</cell></row></table><note><p>⇒ (E 1 ∧ E 2 )[x1/z1, . . . , xm/zm] T 1 ∪T 2 ⇒ xi, yi = t</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>T 1 ∪T 2 ⇐⇒ E1 ∧E2, and E ∧DefsT 1 ∪T 2 ⇒ E 1 ∧E 2 .Hence, it follows from Eq. 4 that Since E1 and E2 are NO-saturated, it follows from Eq. 5 thatWe now prove (ii). Suppose for the purpose of contradiction that ⇐⇒ E1 ∧ E2, and E ∧ DefsT 1 ∪T 2 ⇒ E 1 ∧ E 2 , it follows from Equation 6 that</figDesc><table><row><cell></cell><cell>E1 ∧ E2</cell><cell>T 1 ∪T 2 ⇒</cell><cell>E 1 ∧ E 2</cell><cell>(5)</cell></row><row><cell>E1</cell><cell cols="2">T 1 ⇒ E 1 and E2</cell><cell>T 2 ⇒ E 2</cell></row><row><cell cols="2">E 1 L 1 E1</cell><cell>and</cell><cell>E 2 L 2 E2</cell><cell>(6)</cell></row><row><cell cols="2">AlienTerms T 1 ,T 2 (E )</cell><cell>=</cell><cell cols="2">AlienTerms T 1 ,T 2 (E) (7)</cell></row><row><cell>Since E ∧ Defs</cell><cell>T 1 ∪T 2</cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>We have shown that the problem of assertion checking in programs whose expressions involve linear arithmetic and uninterpreted functions, and whose conditionals have been abstracted as non-deterministic branches, is coNP-hard. This problem can be solved by performing abstract interpretation over the lattice whose elements are (potentially infinite) conjunctions of atomic facts over the combined theory of linear arithmetic and uninterpreted functions, and whose partial order is the implication relationship. This implies that there cannot be any data-structures and algorithms that</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>The analysis thus obtained for L is not the most precise one since our reduction is in terms of strict logical product combination, while the combination methodology yields an analysis for the logical product combination, which is less precise than the strict logical product combination.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank the anonymous reviewers of this paper for their useful and insightful comments.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Research of the second author was supported in part by NSF grant CCR-ITR-0326540.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Abstract interpretation with alien expressions and heap structures</title>
		<author>
			<persName><forename type="first">E</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Leino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VMCAI</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3385</biblScope>
			<biblScope unit="page" from="147" to="163" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Improving abstract interpretations by combining domains</title>
		<author>
			<persName><forename type="first">M</forename><surname>Codish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mulkers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bruynooghe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">G</forename><surname>De La Banda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hermenegildo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="28" to="44" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Complementation in abstract interpretation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cortesi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Filé</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Giacobazzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Palamidessi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ranzato</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="7" to="47" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Iterative reduced product</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cousot</surname></persName>
		</author>
		<ptr target="http://web.mit.edu/16.399/www/.2005" />
	</analytic>
	<monogr>
		<title level="m">Lecture Notes on Abstract Interpretation</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cousot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cousot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">4th ACM Symposium on POPL</title>
		<imprint>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="234" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Systematic design of program analysis frameworks</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cousot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cousot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">6th ACM Symp. on POPL</title>
		<imprint>
			<date type="published" when="1979">1979</date>
			<biblScope unit="page" from="269" to="282" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Automatic discovery of linear restraints among variables of a program</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cousot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Halbwachs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">5th ACM Symposium on POPL</title>
		<imprint>
			<date type="published" when="1978">1978</date>
			<biblScope unit="page" from="84" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Refining and compressing abstract domains</title>
		<author>
			<persName><forename type="first">R</forename><surname>Giacobazzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ranzato</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 24th ICALP</title>
		<meeting>24th ICALP</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1256</biblScope>
			<biblScope unit="page" from="771" to="781" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Making abstract interpreters complete</title>
		<author>
			<persName><forename type="first">R</forename><surname>Giacobazzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ranzato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Scozzari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of the ACM</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="361" to="416" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Discovering affine equalities using random interpretation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">C</forename><surname>Necula</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">30th ACM Symposium on POPL</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003-01">Jan. 2003</date>
			<biblScope unit="page" from="74" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Global value numbering using random interpretation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">C</forename><surname>Necula</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">31st ACM Symposium on POPL</title>
		<imprint>
			<date type="published" when="2004-01">Jan. 2004</date>
			<biblScope unit="page" from="342" to="352" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A polynomial-time algorithm for global value numbering</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">C</forename><surname>Necula</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th Static Analysis Symposium</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004-08">Aug. 2004</date>
			<biblScope unit="volume">3148</biblScope>
			<biblScope unit="page" from="212" to="227" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Assertion checking over combined abstraction of linear arithmetic and uninterpreted functions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tiwari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">15th European Symposium on Programming</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006-03">Mar. 2006</date>
			<biblScope unit="volume">3924</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Combining abstract interpreters</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tiwari</surname></persName>
		</author>
		<idno>MSR-TR-2006-25</idno>
		<imprint>
			<date type="published" when="2006-03">Mar. 2006</date>
			<publisher>Microsoft Research</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Join algorithms for the theory of uninterpreted symbols</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tiwari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">C</forename><surname>Necula</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conf. on Foundations of Software Tech. and Theor. Comp. Sci., FST&amp;TCS &apos;2004</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3328</biblScope>
			<biblScope unit="page" from="311" to="323" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Affine relationships among variables of a program</title>
		<author>
			<persName><forename type="first">M</forename><surname>Karr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Acta Informatica</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1976">1976</date>
			<biblScope unit="page" from="133" to="151" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Composing dataflow analyses and transformations</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lerner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grove</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Chambers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">29th ACM Symposium in POPL</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="270" to="282" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A note on Karr&apos;s algorithm</title>
		<author>
			<persName><forename type="first">M</forename><surname>Müller-Olm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Seidl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="1016" to="1028" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Simplification by cooperating decision procedures</title>
		<author>
			<persName><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Oppen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="245" to="257" />
			<date type="published" when="1979-10">Oct. 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Principles of Program Analysis</title>
		<author>
			<persName><forename type="first">F</forename><surname>Nielson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Nielson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hankin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Symbolic implementation of the best transformer</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">W</forename><surname>Reps</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Yorsh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VMCAI</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">2937</biblScope>
			<biblScope unit="page" from="252" to="266" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
