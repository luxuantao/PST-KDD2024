<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Hierarchical Face Clustering on Polygonal Surfaces</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Michael</forename><surname>Garland</surname></persName>
							<email>garland@uiuc.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Andrew</forename><surname>Willmott</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Carnegie Mellon University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Paul</forename><forename type="middle">S</forename><surname>Heckbert</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">Carnegie Mellon University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Hierarchical Face Clustering on Polygonal Surfaces</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">EF28AB5CB4AA2AC9BFCE9A609D7959D4</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>CR Categories: I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling-surface and object representations face clusters</term>
					<term>dual contraction</term>
					<term>quadric error metrics</term>
					<term>surface simplification</term>
					<term>spatial data structures</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Many graphics applications, and interactive systems in particular, rely on hierarchical surface representations to efficiently process very complex models. Considerable attention has been focused on hierarchies of surface approximations and their construction via automatic surface simplification. Such representations have proven effective for adapting the level of detail used in real time display systems. However, other applications such as ray tracing, collision detection, and radiosity benefit from an alternative multiresolution framework: hierarchical partitions of the original surface geometry.</p><p>We present a new method for representing a hierarchy of regions on a polygonal surface which partition that surface dinto a set of face clusters. These clusters, which are connected sets of faces, represent the aggregate properties of the original surface at different scales rather than providing geometric approximations of varying complexity. We also describe the combination of an effective error metric and a novel algorithm for constructing these hierarchies.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Modern graphics and visualization systems are often called upon to process and display scenes of tremendous geometric complexity. Individual surface models acquired from the physical world with laser scanners, for example, might easily contain a million or more polygonal faces. Such complexity is often useful. For instance, visualizations of architectural spaces can achieve a much more convincing level of realism if intricately detailed models are available. However, this realism comes at a price: computations involving models of such complexity are typically very expensive. To address this fundamental tradeoff between accuracy and efficiency, we must have effective methods to control the level of detail at which we process and display surface models. This need is particularly acute for interactive or real-time applications, which must maintain suitable update rates.</p><p>In recent years, considerable progress has been made on developing techniques for the automatic simplification of highly detailed polygonal models into faithful approximations using fewer polygons <ref type="bibr" target="#b8">[9]</ref>. Methods are now available that can take excessively detailed models, say from laser range scanners, medical data sources, or CAD systems, and produce more economical models which approximately describe the same shape with far fewer polygons. Simplification algorithms have also been used to construct progressive representations of polygonal surfaces <ref type="bibr" target="#b13">[14]</ref> and real-time display systems which can adapt the level of detail of the surface to fit the current viewing conditions <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b30">31]</ref>. All these prior methods focus on the problem of generating geometric approximations of the original surface. However, there is another class of applications where a hierarchical representation of the original surface itself is more suitable than a family of approximate surfaces.</p><p>We have developed an algorithm which produces a hierarchy of regions on a given polygonal surface. Each region is a connected set of faces, which we term a face cluster, and they completely partition the input surface. As we will see, our method is closely related to prior surface simplification methods. However, unlike simplification methods, this algorithm does not alter the original surface geometry in any way, nor does it produce any new approximate surfaces. Instead, it associates aggregate properties, such as a representative surface normal for instance, with each cluster in the hierarchy, thus representing the structure of the surface at multiple scales. The primary contributions of the work described in this paper are <ref type="bibr" target="#b0">(1)</ref> a new hierarchical structure for representing surface partitions, (2) a novel algorithm for constructing these hierarchies, and (3) an effective error metric to guide this construction process.</p><p>Various computational tasks in graphics and visualization systems can potentially benefit from the face cluster hierarchies produced by our method. By enclosing each face cluster with a bounding volume, we can produce hierarchies suitable for ray tracing, collision detection, or other algorithms which perform spatial queries. Alternatively, we can use the cluster hierarchies as a basis for efficient simulation algorithms. For example, hierarchical finite element methods often subdivide the input geometry to an appropriate level of detail to obtain an accurate solution. By using our face cluster hierarchies, we can formulate methods which can conceptually "unsubdivide" and treat entire surface regions as a single unit. We previously described how radiosity simulation <ref type="bibr" target="#b29">[30]</ref> can be made dramatically more efficient by applying such hierarchies but did not detail how they could be constructed. Here we focus on the precise representation and efficient construction of face cluster hierarchies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">SURFACE HIERARCHIES</head><p>For applications such as real-time rendering, we typically desire multiresolution models that can provide geometric approximations of the original surface. Depending on the viewing conditions, the run-time system will select the appropriate geometric level of detail to display. However, there are other applications in which we are more interested in the aggregate properties of surface regions. Rather than extracting a single approximation from the hierarchy, we would like to perform computations using the hierarchy itself. For applications which rely heavily on spatial queries, we might like a hierarchy of bounding volumes that enclose successively larger regions of the surface. For other simulation-oriented applications (e.g., finite element methods), we might want to compute coarse solutions over entire surface regions, successively refining the result by considering smaller scale elements in selected areas. We might, for instance, want to approximate successively larger regions of the surface with planar elements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Vertex Hierarchies from Simplification</head><p>Most current surface simplification algorithms begin with a triangulated polygonal surface and iteratively apply a simplification operator to remove elements at each step. One such operator, which has become an increasingly popular choice, is edge contraction (see Figure <ref type="figure" target="#fig_0">1</ref>). Thus, starting with the original model, iterative contraction algorithms generate a sequence of approximate surfaces until arriving at a final approximation.</p><formula xml:id="formula_0">contract v i v j v -</formula><p>When we generate approximations using iterative contraction, we also construct a vertex hierarchy. This is a binary tree whose leaves are the vertices of the original model. When we contract two vertices together, we create a new node in the tree and make the two vertices being contracted its children. The resulting tree provides a means of encoding the dependencies in the sequence of contractions built during simplification and has been used successfully for viewdependent reconstruction of surface approximations at run time <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b30">31]</ref>. But we can also think of them as hierarchies of vertex neighborhoods <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10]</ref>. At the leaves of the tree are the vertices of the original model: their neighborhoods correspond to their adjacent faces. When we contract two vertices together, we merge their neighborhoods and construct a new approximate neighborhood for the resulting vertex. Each node in the hierarchy corresponds to a disjoint set of vertices on the original surface. Consequently, it also corresponds to a surface region that is the union of the neighborhoods of all the vertices in its set. Note that very similar hierarchies result from the iterative application of other simplification operators, such as vertex removal.</p><p>This hierarchy of neighborhoods is itself a useful construction. For instance, Kobbelt et al. <ref type="bibr" target="#b19">[20]</ref> and Lee et al. <ref type="bibr" target="#b20">[21]</ref> use the resulting hierarchy to define a multiresolution parameterization of the surface. This parameterization facilitates applications such as multiresolution surface editing and morphing.</p><p>While useful, these hierarchical neighborhoods have some drawbacks for certain applications. First and foremost, local neighborhoods high in the tree are generally nonplanar (e.g., cone-shaped with the vertex at the apex). This is because any planar vertex neighborhood will be removed very early during simplification. In addition, the set of triangles on the original surface corresponding to a particular vertex in the hierarchy may have a very irregular shape. For some applications it is preferable that the shape of this region be regular, yet most standard simplification algorithms provide no means to control this shape. They are also generally unsuitable for building spatial data structures: the bounding box of a node is not guaranteed to fully contain the surface of its children.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Face Hierarchies from Clustering</head><p>Face hierarchies, which are the focus of this paper, are a natural alternative to vertex hierarchies, and their properties complement those of vertex hierarchies very nicely. Instead of iteratively merging vertex neighborhoods, we can iteratively cluster neighboring groups of faces. This allows us to avoid some of the specific drawbacks of vertex hierarchies listed above. Because the clusters are disjoint sets of faces, they partition the surface in a well-defined way and consequently have a well-defined surface area and perimeter. Face clusters are also more likely to have a single normal which is a good match for the surface normals of the faces in the cluster, and thus be more likely to be nearly planar.</p><p>To highlight the difference between these kinds of hierarchies, consider the example of a cube. Near the root of a vertex hierarchy, there will be a level at which we have eight "conical" neighborhoods, one for each corner of the cube. In contrast, near the top of a face hierarchy we will have 6 planar face clusters, one for each face of the cube. If we are trying to formulate a single planar approximating element, or a single normal for the entire region, we will get a much better result with the face hierarchies than with the vertex hierarchies. And because the surface geometry never changes, we can trivially guarantee that bounding volumes within the hierarchy fully enclose the surface of all the nodes below them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">FACE CLUSTERING ALGORITHM</head><p>To construct a face hierarchy, we begin by forming the dual graph of the surface. The dual graph is defined by mapping every face of the surface to a node in the dual graph, and connecting two dual nodes by an edge if the corresponding faces are adjacent on the surface. While the algorithm we present can be applied to non-manifolds, we will assume that the surface is a manifold with boundary<ref type="foot" target="#foot_0">1</ref> for efficiency reasons. Consequently, every surface edge has at most 2 adjacent faces. This guarantees that the complexity of the dual graph will not be too great; the number of dual edges will be no greater than the number of edges in the surface mesh. To simplify the discussion, we will also assume that all input polygons have been triangulated; thus, every dual node will have at most 3 neighbors.</p><p>In the dual graph, each node will correspond to a face cluster : a connected set of faces that have been grouped together. For the initial dual graph, each cluster consists of a single face of the input model, and these clusters will form the leaves of the hierarchy. An edge contraction in this graph merges two dual nodes into one. This corresponds to grouping their associated faces, which must necessarily be adjacent, into a single cluster. Thus in general, dual edge contraction corresponds to merging two adjacent face clusters into a single cluster. Figure <ref type="figure" target="#fig_1">2</ref> illustrates a simple example. The underlying mesh and the dual graph are shown in dashed and solid lines, respectively. On the left is a mesh where each dual node corresponds to a single face; in other words, each face is its own cluster. After contracting a single contract dual edge, the two darkened triangles have been merged into a single cluster.</p><p>To construct a complete hierarchy, we use a simple greedy procedure very similar to existing simplification algorithms. Each dual edge is assigned a "cost" of contraction, and the system iteratively contracts the dual edge of least cost. After each iteration i, we will have constructed a partition N i of the surface into disjoint sets of connected faces. This is in contrast to simplification, where at each iteration we would have constructed an approximate surface.</p><p>Let us emphasize that the geometry of the original surface is not altered in any way by this clustering process; every vertex remains in its original position and the connectivity of the surface mesh is unchanged. Instead, we begin with an initial surface partition where every face belongs to its own singleton cluster. The process of iterative dual contraction produces a sequence of partitions with successively fewer clusters. If run to completion, this will produce a single face cluster for each connected component of the surface. Also note that while clusters are always connected sets of faces, they need not be simple -they may have holes. Just as with iterative edge contraction, iterative dual contraction produces a natural hierarchy. When two dual nodes are contracted together (i.e., two face clusters are merged), we can make them both children of their new parent node which represents the union of their associated clusters. See Figure <ref type="figure" target="#fig_2">3</ref> for a simple example. At the bottom of the hierarchy are four face clusters, each of which already contain two or three faces. The two leftmost clusters are merged together, forming a single parent node. The two rightmost clusters are also merged. The two parent clusters, which together partition the mesh into two disjoint sets of faces, are merged together to produce a single root cluster which spans the entire mesh.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Related Clustering Methods</head><p>Iterative clustering, as a general class of algorithms, has been in use for decades <ref type="bibr" target="#b0">[1]</ref>. While a substantial number of algorithms have been developed, most appear only tangentially related to the problem of building face cluster hierarchies on surfaces. In particular, most clustering algorithms have focused on the problem of clustering point sets, frequently in high dimensions, rather than clustering surface elements. And since surface elements possess adjacency and orientation which point sets do not, they require a different sort of clustering approach.</p><p>The process of face clustering which we have just described is closely related to the simplification algorithm of Kalvin and Taylor <ref type="bibr" target="#b18">[19]</ref>. They also partitioned the surface into a set of disjoint face clusters, or "superfaces." Their algorithm was based on growing a single cluster around a random seed face, adding one face at a time until the cluster exceeded a planarity threshold. In contrast, our algorithm is based on pairwise cluster merging. The primary advantage of pairwise merging is that it produces a hierarchical structure of clusters rather than a single static partition. It also avoids the need to designate special seed faces.</p><p>DeRose et al. <ref type="bibr" target="#b6">[7]</ref> proposed a related algorithm for generating hierarchies of bounding boxes on subdivision surfaces to support collision detection. Given an initial quadrilateral mesh, they iteratively merge a maximal independent set of adjoining clusters until only a single cluster remains. Since no criterion, other than adjacency, is used to select which clusters to merge, the individual clusters may or may not contain roughly coplanar elements. Faugeras and Hebert <ref type="bibr" target="#b7">[8]</ref> iteratively merged regions of range images in order to segment them for approximation by planar or quadric patches.</p><p>Delingette <ref type="bibr" target="#b5">[6]</ref> used a geometric construction based on the dual graph, which he called simplex meshes, to represent surfaces during reconstruction. Finally, Willersinn and Kropatsch <ref type="bibr" target="#b28">[29]</ref> used the method of dual edge contraction to construct irregular image pyramids. While this method is designed for an entirely different domain -images rather than surfaces -it uses the same formalism of iterative dual contraction thus producing a hierarchy of pixel regions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Dual Quadric Metric</head><p>In order to evaluate the cost of a dual contraction, we need some idea of what qualities a face cluster should have. Naturally, there are many potential criteria from which to choose. But for many applications, a good criterion is the planarity of the cluster. This means that a given face cluster can be approximated by a planar element without undue inaccuracy. We will adopt planarity as our primary criterion, modified by selected bias terms discussed in succeeding sections. As we will see, this planarity criterion can be expressed using a dual form of the quadric error metric <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b9">10]</ref>.</p><p>Every cluster has an associated set of faces {f1, . . . , fn} and a set of points {v1, . . . , v k } determined by the vertices of these faces. Let us suppose that we want to find the least squares best fit plane to this set of points. For a plane specified by a unit normal n and a scalar offset d, the distance of a point v to this plane is n T v + d. The fit error of a given plane n T v + d = 0 is the average squared distance of all the points in the cluster to the plane</p><formula xml:id="formula_1">E fit = 1 k k i=1 (n T vi + d) 2<label>(1)</label></formula><p>The least squares best plane is the one which minimizes this error. Notice that this error formula is nearly identical to the error metric used in quadric-based simplification <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b9">10]</ref>. Aside from the averaging factor, the sole difference is that we are summing over a set of points with a fixed normal rather than a set of normals with a fixed point. We can define a fit quadric</p><formula xml:id="formula_2">Pi = (Ai, bi, ci) = (vivi T , vi, 1) (2) Pi(n, d) = n T Ain + 2bi T (dn) + cid 2<label>(3)</label></formula><p>which requires ten coefficients to represent the symmetric 3×3 matrix A, the 3-vector b, and the scalar c. Now, we can expand and rewrite the inner term of E fit</p><formula xml:id="formula_3">(n T vi + d) 2 = (n T vi + d)(vi T n + d) = n T (vivi T )n + 2dn T vi + d 2 (4)</formula><p>so that we can evaluate this error using a corresponding set of quadrics:</p><formula xml:id="formula_4">E fit = 1 k i Pi(n, d) = 1 k i Pi (n, d)<label>( 5 )</label></formula><p>where the addition of quadrics is defined by component-wise addition of the constituent matrices, vectors, and scalars. Every dual node will have an associated fit quadric P and a best-fit plane (n, d) such that P (n, d) measures the planarity of the cluster associated with the node. The cost of contracting two dual nodes together is reflected by the sum of the fit quadrics of each node (P i + Pj)(n, d). Note that the form of this dual quadric error (3) differs slightly from the original due to the presence of the d and d 2 terms.</p><p>This kind of least squares planarity measure is of course quite common. For example, Faugeras and Hebert <ref type="bibr" target="#b7">[8]</ref> used it in their region merging algorithm. However, we believe its formulation as a quadric error metric is novel, and is critical for the overall efficiency of the algorithm. <ref type="bibr" target="#b18">[19]</ref> used a closely related planarity metric which measured the maximum distance of any point to the plane, as opposed to the average squared distance. They attempted to create clusters which would respect a given L∞ error bound whereas we attempt to minimize an L2 error for a given number of clusters.</p><p>Finding the optimal plane which minimizes P (n, d) is not quite as simple as finding the optimum of the original quadric metric. The standard technique, based on principal component analysis (PCA) <ref type="bibr" target="#b17">[18]</ref>, is to construct the sample covariance matrix:</p><formula xml:id="formula_5">Z = 1 k -1 k i=1 (vi -v)(vi -v) T (<label>6</label></formula><formula xml:id="formula_6">)</formula><p>where v is the mean of the vertices v = i vi /k. The three eigenvectors of the matrix Z determine a local frame with v as the origin. The eigenvector corresponding to the smallest eigenvalue is the normal of the least squares best plane through the set of points {vi}. This method, which is identical to the least squares method of normal equations, is frequently used to estimate or define local tangent planes <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b4">5]</ref> when reconstructing surfaces from sets of points. Note that the normal computed in this fashion is only unique up to sign. In practice, it is helpful to track the average normal n of all the faces in the cluster to resolve this sign ambiguity. For the remainder of the discussion, we will drop the 1/(k -1) averaging factor from the covariance matrix formula. This has no effect on the algorithm because we are only interested in the eigenvectors of Z and the relative scales of its eigenvalues.</p><p>The covariance matrix Z is symmetric and positive semidefinite; thus its eigenvalues will always be real and nonnegative. And note that, as long as the points viv span three dimensional space, it will have three non-zero eigenvalues. Since the points vi form the vertices of a set of triangles, we know that they must at minimum span a two dimensional space, and thus Z has at most one zero eigenvalue. Consequently, we can always successfully derive three orthogonal vectors for our local frame. However, if two or more of the eigenvalues are equal, the optimal fitting plane is not uniquely defined. For example, all three eigenvalues will be equal if the points are uniformly distributed on a sphere. In such cases, we must simply choose any one of the possible orientations for the plane.</p><p>Looking at the definition of Z, we might expect that it can be expressed in terms of the fit quadric P , and this is indeed the case. If we expand the equation for Z and collect terms, we find that</p><formula xml:id="formula_7">Z = vivi T -k(vv T ) ( 7 ) = A - bb T c (8)</formula><p>Thus, the optimal plane through the set of points can be computed directly from the corresponding fit quadric P . Its normal n will be the eigenvector of Abb T /c corresponding to its smallest eigenvalue, and if we make the standard assumption that the plane passes through the mean, then</p><formula xml:id="formula_8">d = -n T v = -n T b/c.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Orientation Bias</head><p>Minimizing the planarity term E fit will naturally tend to merge clusters which are collectively nearly planar. However, a surface may locally fold back on itself. It will seem nearly planar, but the normal of the optimal plane will not be a good fit for all the surface normals in the region. For some applications, this may be irrelevant, but for many others it is a problem we would like to avoid. To combat this problem, we will also use an additional error term which measures the average deviation of the plane normal n from the surface normals:</p><formula xml:id="formula_9">E dir = 1 w i wi(1 -n T ni) 2<label>(9)</label></formula><p>where wi is the area of face fi and w = i wi is the total area of the face cluster. We can write this metric as a quadric as well</p><formula xml:id="formula_10">E dir = 1 w i wiRi(n) = 1 w i wiRi (n)<label>(10)</label></formula><p>where  and</p><formula xml:id="formula_11">Ri = (Di, ei, fi) = (nini T , -ni, 1)<label>(11)</label></formula><formula xml:id="formula_12">Ri(n) = n T Din + 2ei T n + fi (<label>12</label></formula><formula xml:id="formula_13">)</formula><p>Kalvin and Taylor <ref type="bibr" target="#b18">[19]</ref> proposed a related "face-axis rule" which limited the range of orientations permitted within a cluster. As with our planarity metric, the primary difference is that we use the average deviation as a penalty rather than placing a bound on the maximum deviation. It is this formulation that allows us to use the quadric metric representation. Rather than having to traverse a list of faces every time we evaluate errors, we merely need to evaluate the value of the quadric. Given these error metrics, the clustering algorithm has a very simple form. For every initial dual node, it computes quadrics P and R. And for every initial dual edge, we sum the quadrics of the endpoints, find the optimal plane, and evaluate its error as E fit + E dir . Following this initialization step, we place all dual edges in a heap keyed on cost, and greedily contract the minimal cost edge. Every time we contract two nodes together, we assign the quadrics of the resulting node to be the sums Pi+Pj and Ri+Rj and update the costs for each edge connected to the resulting node. Some examples of the results produced by this algorithm are shown in Figure <ref type="figure" target="#fig_4">4</ref>. The original model (a) has 11,036 faces, each of which corresponds to an individual cluster. The partition of the surface shown in (b) contains only 6000 clusters. Note how the clusters are growing along the cylindrical parts of the surface and curving along the rounded parts. This effect is even more apparent in partition (c) containing 1000 clusters. Also note how each planar region has been grouped into a single cluster. As clustering proceeds, the regions will expand over more and more of the surface. Naturally, at some point an individual region may no longer be well-approximated by any plane, since it corresponds to a significant part of the model. If run to completion, the algorithm will produce a final root cluster which contains the entire surface.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Compact Shape Bias</head><p>If planarity is our only clustering criterion, then the algorithm described above performs quite well. However, there are applications where we are also interested in the shape of these regions. In particular, we might want them to have a fairly compact shape; in other words, we might like each cluster to be as nearly circular as possible. For example, using long skinny regions in radiosity simulation would greatly increase the likelihood of a shadow discontinuity falling across the cluster. Irregularly shaped regions are problematic in applications such as simplification where we might want to retessellate clusters <ref type="bibr" target="#b18">[19]</ref>. They also interfere with the construction of tight-fitting bounding volumes. Fortunately, it is fairly easy to add a simple compactness heuristic which significantly improves the regularity of the clusters.</p><p>Given a cluster with area w and perimeter ρ, we define the irregularity γ of the cluster as a ratio of its squared perimeter ρ 2 to its area</p><formula xml:id="formula_14">w γ = ρ 2 4πw (<label>13</label></formula><formula xml:id="formula_15">)</formula><p>This can also be interpreted as the ratio of the squared perimeter ρ 2 to the squared perimeter of a circle with area w. A circle will have irregularity γ = 1 and larger values of γ correspond to more irregular (less compact) regions. This definition of irregularity is fairly natural and has been widely used in fields ranging from image processing <ref type="bibr" target="#b16">[17]</ref> to the analysis of U.S. Congressional districts to detect gerrymandering <ref type="bibr" target="#b23">[24]</ref>. Kalvin and Taylor <ref type="bibr" target="#b18">[19]</ref> used this definition of irregularity (without the 4π term) for directing the construction of superfaces for simplification. Now suppose we have have two adjacent clusters with irregularity γ1 and γ2, respectively. Let γ be the irregularity of the cluster formed by merging them together. We define the shape penalty as the relative change in irregularity due to merging the two regions together</p><formula xml:id="formula_16">E shape = γ -max(γ1, γ2) γ (<label>14</label></formula><formula xml:id="formula_17">)</formula><p>If the irregularity of the cluster arising from a dual contraction is worse than the two original clusters, that contraction will incur a penalty (E shape &gt; 0). On the other hand, if the irregularity improves it will incur a negative penalty, or bonus. Based on our experience, requiring the irregularity to improve at each iteration over-constrains the clustering algorithm and leads to bad results. It can also lead to cases where the greedy algorithm cannot make progress because every possible contraction would result in more irregular regions. No doubt part of the problem is due to the fact that  we are using a greedy algorithm which only looks one step ahead. Nevertheless, within the framework of greedy contraction, using a penalty term such as E shape seems to be more effective.</p><p>In order to compute this shape penalty, we need to know both the area and the perimeter of our clusters. Clearly, the area is quite easy to track; it is merely the sum w = w1 + w2 of the constituent areas. While the perimeters are not additive, we can track them quite simply. For each cluster, we record its perimeter ρi in the relevant dual node. When two clusters are merged, the perimeter of the resulting cluster will be the sum of the perimeters of the constituent clusters minus twice the length of the boundary which separated them. We associate these boundary lengths with the corresponding dual edges. This allows us to compute the perimeter of the merged cluster directly from the perimeters of the merging clusters and the length associated with the dual edge being contracted.</p><p>Figure <ref type="figure" target="#fig_6">5</ref> demonstrates the effect of using the additional shape penalty. Clustering without bias (a) can produce highly irregular regions. Note the clusters that stretch all along the rear leg. In terms of finding clusters which are best fit by a plane, this behavior is desirable, but it does not produce compact regions. In contrast, when we use the shape bias term (b), the algorithm produces very regularly shaped regions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Combined Error Metric</head><p>To produce the total error metric for our clustering algorithm, we combine the planarity metric E fit with the two bias terms E dir and E shape . The cost of a dual contraction will be determined by the error metric E = E fit + α1E dir + α2E shape <ref type="bibr" target="#b14">(15)</ref> where α1 and α2 are constants which must be chosen by the user. For the results reported here and in the description of our companion radiosity algorithm <ref type="bibr" target="#b29">[30]</ref>, we have simply chosen the values α1 = 1 and α2 = 0 when the shape bias is disabled and α2 = 1 when the shape bias is enabled. However, a more careful selection of coefficients might potentially result in improved results. Assuming that the planarity term E fit is meant to be the dominant term, we could normalize the error be choosing values for α1, α2 which are some user-specified fraction of the diameter<ref type="foot" target="#foot_1">2</ref> of the model. Alternatively, if regularity of region shape is the paramount concern, we would want to select a substantially larger value for α2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">APPLICATIONS</head><p>We believe that the face hierarchies produced by our clustering algorithm are potentially useful in several application areas. In particular, they are intended for use in applications which are more concerned with the aggregate properties of surface regions rather than their exact geometry.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Distance &amp; Intersection Queries</head><p>One natural application of these face hierarchies is for constructing hierarchical bounding volumes. Recall that, for each cluster in the hierarchy, we compute a best fit plane.</p><p>Given this plane, it is a fairly simple task to compute an oriented bounding box which tightly encloses the cluster. A simple, but relatively inefficient, method is to enumerate all the points in the cluster, project into the local frame defined by the plane, and compute an axis-aligned bounding box in this local frame. Alternatively, we can avoid having to traverse large sets of points by tracking the convex hull <ref type="bibr" target="#b24">[25]</ref> of the point set <ref type="bibr" target="#b11">[12]</ref>. Hierarchies of oriented boxes such as this can be used to efficiently measure the distance from a point to a surface, an operation common in many modeling systems. They are also an effective means of accelerating the kind of spatial queries common in applications such as ray tracing <ref type="bibr" target="#b1">[2]</ref>. They can be constructed over both curves <ref type="bibr" target="#b2">[3]</ref> and surfaces <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b11">12]</ref>. In contrast to spatial partitions such as octrees <ref type="bibr" target="#b26">[27]</ref>, hierarchies which are attached to the surface, like those produced by our algorithm, are guaranteed to have a size linear in the size of the input model <ref type="bibr" target="#b3">[4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Collision Detection</head><p>Another natural application for this bounding box hierarchy is collision detection, which finds uses in a number of areas, from physical simulation to haptic interfaces. Indeed, the set of bounding boxes constructed from our face cluster hierarchy is very similar to the OBBTree structure introduced by Gottschalk et al. <ref type="bibr" target="#b11">[12]</ref>. They also used PCA to compute best fit planes, and thus oriented bounding boxes. However, they produced the vertex sets by a top-down partition of the vertices of the original model. In contrast, our clustering algorithm computes a bottom-up hierarchical partition of the surface and can subsequently derive bounding boxes for each region. This provides an interesting additional benefit. By design, our hierarchies produce regions which are, to the extent possible, well approximated by a plane. This means that, except at the very top of the hierarchy, most interior nodes will correspond to surface regions with a fairly welldefined orientation. Thus, we can approximate collisions against the object with collisions against bounding boxes, and the normals of the associated planes will actually allow us to predict the change in motion resulting from the collision.</p><p>Another related hierarchical representation useful for collision detection is the BOXTREE developed by Barequet et al. <ref type="bibr" target="#b3">[4]</ref>. It also builds a bottom-up hierarchy of boxes by merging "adjacent" boxes. However, their algorithm is much more focused on the properties of the bounding boxes rather than the surface regions being bounded. Their definition of box adjacency is based on spatial overlap rather than the connectivity of corresponding regions on the surface. And they rank pairs of boxes for merging based on properties of the resulting boxes, such as volume, rather than any property of the local surface.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Surface Simplification</head><p>Our algorithm can also easily be used for surface simplification. Following Kalvin and Taylor <ref type="bibr" target="#b18">[19]</ref>, we can partition the surface into clusters, simplify their boundaries, and retriangulate the resulting simplified clusters. The results of such a system would likely be similar to Kalvin and Taylor's "Superfaces" algorithm, with some key differences. While Superfaces provides guaranteed bounds on the maximum deviation of any point from its approximating plane, our dual quadric error metric seeks to minimize the average deviation without any guaranteed bounds on the maximum.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Multiresolution Radiosity</head><p>Radiosity is commonly used to simulate global illumination in diffuse environments -interactive architectural walkthroughs are a particularly popular application area. It is also a computationally intensive process that can benefit enormously from hierarchical representations. We have shown elsewhere <ref type="bibr" target="#b29">[30]</ref> that face cluster hierarchies constructed using the algorithm developed here can be used to provide an effective means for accelerating such simulations.</p><p>The standard hierarchical radiosity method <ref type="bibr" target="#b12">[13]</ref> has a time complexity of O(n + k 2 ) for scenes containing k polygons and for which n elements are necessary for accurate simulation. The initial input polygons can be adaptively subdivided, producing a hierarchy of surface elements. These methods allow light transport to be simulated at an appropriate level of detail. Nearby surface patches can interact at a fairly fine grain while interactions between distant patches can be represented at a coarser level. While efficient for simple scenes where n k, it is not as effective for very complex scenes where objects contain excess geometric detail, and hence n k. To handle complex scenes, we need to group input polygons into higher-level clusters in addition to allowing subdivision of input polygons, thus eliminating the k 2 term from the time complexity. Consider the scene shown in Figure <ref type="figure" target="#fig_11">9</ref> which contains several geometrically complex models. The serpentine dragon on the table, for example, contains 870,000 triangles. But given its relatively small size, an accurate radiosity solution could be computed on a much coarser set of surface patches than these input triangles.</p><p>One proposed method for building hierarchies above the input polygon level is volume clustering <ref type="bibr" target="#b27">[28]</ref>. Faces of the model are grouped into spatial cells, typically axis-aligned boxes, and these cells are grouped into higher and higher levels. This approach appears to work well for clustering objects, such as the leaves of a tree. However, it does not perform as well for clustering surface regions. A particular region on a smooth surface will tend to have a dominant orientation, which is not captured by enclosing the region in an axis-aligned box. Since these volumetric hierarchies provide poor approximations of the surface geometry, the radiosity simulation is forced to descend very deep in the hierarchies to achieve an acceptable solution, thus losing much of the benefits that the hierarchy could provide. An object-aligned box will produce a much tighter fit to the surface, and it will have an orientation that reflects the orientation of the surface. The iterative face clustering algorithm that we have presented provides a convenient way to construct a hierarchy of exactly this sort of tight-fitting box.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RESULTS</head><p>Figure <ref type="figure" target="#fig_7">6</ref> illustrates the performance of our clustering algorithm on surface models of various sizes. All performance measurements for the clustering algorithm were made on a 450 MHz Intel Pentium III system, and the algorithm was run with the shape bias enabled (α 2 = 1). The running time of the system has been decomposed into three parts. First is initialization, where the dual graph and initial quadrics are constructed. Second is clustering, where the system greedily contracts dual edges until each connected component has been merged into a single cluster. Finally there is bounding box construction, where each leaf in the tree propagates its vertices up to the root to compute bounding boxes for every node.</p><p>Given an input surface with n faces, both the initialization and clustering phases of the algorithm will take O(n log n) time. This is because each of them performs O(n) heap operations, which themselves have O(log n) complexity. The bounding box computation phase will also have O(n log n) running time, if the resulting hierarchy is balanced. If it is not, this final phase may take O(n 2 ) time. The algorithm we have given does not attempt to produce balanced hierarchies, and the potentially greater cost of bounding box construction would seem to be apparent in the empirical data shown in Figure <ref type="figure" target="#fig_7">6</ref>. Also note that this analysis relies on the fact that there are O(n) dual edges, which is a consequence of our assumption that the input surface is a manifold (possibly with boundary), and that the degree of every node must be bounded by a constant.</p><p>Our preliminary performance analysis indicates that the Jacobi iteration procedure <ref type="bibr" target="#b25">[26]</ref> for computing the eigenvectors of the covariance matrices can account for up to one half of the total running time. This suggests that efficiency could be increased quite a bit by applying PCA only at the upper levels of the hierarchy and using a cheaper method to compute approximating planes at the lower levels.</p><p>Figure <ref type="figure" target="#fig_10">8</ref> shows the result of clustering on a simple paraboloid surface with 1896 triangles. Shown with each face cluster partition are the corresponding fit planes derived by minimizing the planarity term E fit . The extent of each plane is limited by the bounding box fit during the final phase of clustering. Note that the planes do fit the surface fairly well, but that they seem tilted somewhat in partition (b). When the cluster is fairly flat and extends roughly equally in all directions in the plane, PCA does not always orient the local frame in a way which would minimize the bounding box size. A much more complex surface, containing about 376,000 triangles, is shown in Figure <ref type="figure" target="#fig_12">10</ref>. Note how the size and shape of the clusters conform to the shape of the surface: broad in smooth areas; small and narrow in highly curved areas. However, when few clusters remain (e) the algorithm is forced to choose between either irregular planar clusters or regular non-planar clusters. Since we favor planarity over regularity, large irregular regions may develop.</p><p>To demonstrate the significant advantages of face clustering for radiosity, we briefly summarize the performance of our system <ref type="bibr" target="#b29">[30]</ref>. Figure <ref type="figure" target="#fig_8">7</ref> illustrates the comparative running times for the simulation phase of three different radiosity algorithms running on a 195 MHz R10000 SGI machine with 1 GB of main memory. The performance of the algorithms is shown as a function of input scene complexity, which was controlled by using surface approximations generated using the QSlim simplification package <ref type="bibr" target="#b9">[10]</ref>. Progressive radiosity, which uses all of the input polygons during the so-lution process, requires rapidly increasing amounts of time and memory as the input complexity increases. Hierarchical radiosity with volume clustering requires substantially less resources, but its requirements also grow fairly rapidly with complexity. This is largely due to the fact that volume clusters do not provide an accurate fit for surface regions. Consequently, the solution computed at high levels in the hierarchy is quite inaccurate, and the algorithm is forced to descend far down in the tree to achieve an acceptable solution. In fact, it must typically descend all the way to the level of the input polygons. In contrast, the algorithm based on face cluster hierarchies exhibits essentially unchanging running times once the input complexity has risen to the level of 30,000 polygons. The algorithm is able to find a level in the hierarchy, far above the level of the input triangles, at which an acceptable solution can be computed. Because it never needs to descend deeper into the hierarchy, it requires much less time and far less resident data than the other algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION</head><p>We have described an efficient clustering algorithm which partitions a given surface into a hierarchy of disjoint face clusters. The resulting clusters are chosen so that they may be reasonably approximated with planar elements. To provide an efficient means of assessing the planarity of clusters during clustering, we have introduced a dual quadric error metric. The face cluster hierarchies produced by our algorithm can be used in a number of applications. Collision detection, ray tracing, and shape analysis for simplification appear particularly promising. We have previously demonstrated the use of these face cluster hierarchies to perform some of the largest, fastest radiosity simulations to date <ref type="bibr" target="#b29">[30]</ref>.</p><p>There are a number of promising directions in which this work could be extended. We suspect that the efficiency of the basic algorithm we have presented here may be improved by selectively using cheaper methods to compute fitting planes rather than always using PCA. Our choice of a planarity criterion was motivated by the application to radiosity, but other alternative error metrics could also be considered. A more flexible combination of the planarity and bias terms would be useful, particularly if it provided finer control over the tradeoff between them. Because certain applications might benefit from balanced hierarchies, it might also be useful to consider modifying the algorithm to provide them, either by parallel merging of a maximal independent set of dual edges <ref type="bibr" target="#b30">[31]</ref> or by adding a balance bias to the error metric <ref type="bibr" target="#b14">[15]</ref>.</p><p>Further information, including our experimental implementation, can be found online at http://graphics.cs.uiuc. edu/ ∼ garland/research/cluster.html.     </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Edge (vi, vj) is contracted; two faces and one vertex are removed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Edge contraction in the dual graph (shown with solid lines). The two faces of the surface (shown with dashed lines) corresponding to the endpoints of the dual edge are merged to form a single face cluster.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Part of a face hierarchy superimposed on the local geometry. The four clusters at the bottom are merged into one root cluster at the top.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Face cluster partitions produced by iterative pairwise merging.</figDesc><graphic coords="5,57.48,64.04,160.50,120.38" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Face cluster partitions of the cow model, with 1000 clusters each. The shape bias produces much more compactly shaped clusters.</figDesc><graphic coords="6,93.74,214.20,160.15,108.17" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Running time of clustering algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Running time of radiosity algorithms on the museum scene. Running time for face cluster radiosity is relatively independent of scene complexity.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>(a) 250 clusters (b) fit planes (c) 50 clusters (d) fit planes (e) 12 clusters (f) fit planes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Face clusters &amp; associated fit planes on a paraboloid. Corresponding clusters and planes are drawn in same color.</figDesc><graphic coords="10,57.07,64.49,75.13,76.60" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Face cluster radiosity solution, computed in only 3 minutes, for a scene with 2.7 million input polygons.</figDesc><graphic coords="10,162.00,201.32,288.64,199.68" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>(a) 10</head><label>10</label><figDesc>,000 clusters (b) 5000 clusters (c) 2500 clusters (d) 1000 clusters (e) 100 clusters</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Face clusters computed for Isis statue, composed of 375,736 triangles. Cluster shape adapts to surface shape.</figDesc><graphic coords="10,70.68,451.34,59.57,216.33" type="bitmap" /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Recall that a manifold with boundary is a surface all of whose points have a neighborhood which is topologically equivalent to a disk or half-disk.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>The diameter of a surface is the distance between the pair of points on the surface which are farthest apart.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">ACKNOWLEDGEMENTS</head><p>This research was funded in part by the National Science Foundation (grants CCR-9505472, CCR-9619853, and DMI-9813259). We would like to thank Joel Welling for arranging access to the large SGI server and Tom Stahovich for helping to fund this work.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Cluster Analysis for Applications</title>
		<author>
			<persName><forename type="first">R</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><surname>Anderberg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1973">1973</date>
			<publisher>Academic Press</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A survey of ray tracing acceleration techniques</title>
		<author>
			<persName><forename type="first">James</forename><surname>Arvo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Kirk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">An Introduction to Ray Tracing</title>
		<editor>
			<persName><forename type="first">Andrew</forename><surname>Glassner</surname></persName>
		</editor>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="201" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Strip trees: A hierarchical representation for curves</title>
		<author>
			<persName><forename type="first">H</forename><surname>Dana</surname></persName>
		</author>
		<author>
			<persName><surname>Ballard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="310" to="321" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">BOXTREE: A hierarchical representation for surfaces in 3D</title>
		<author>
			<persName><forename type="first">Gill</forename><surname>Barequet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernard</forename><surname>Chazelle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonidas</forename><forename type="middle">J</forename><surname>Guibas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Joseph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ayellet</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><surname>Tal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="387" to="396" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Computation of surface geometry and segmentation using covariance techniques</title>
		<author>
			<persName><forename type="first">Jens</forename><surname>Berkmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Terry</forename><surname>Caelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1114" to="1116" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Simplex meshes: A general representation for 3D shape reconstruction</title>
		<author>
			<persName><forename type="first">Hervé</forename><surname>Delingette</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conf. on Computer Vision and Pattern Recognition (CVPR &apos;94)</title>
		<imprint>
			<date type="published" when="1994-06">June 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Subdivision surfaces in character animation</title>
		<author>
			<persName><forename type="first">Tony</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Kass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tien</forename><surname>Truong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Proceedings SIGGRAPH</title>
		<imprint>
			<biblScope unit="volume">98</biblScope>
			<biblScope unit="page" from="85" to="94" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The representation, recognition, and positioning of 3-D shapes from range data</title>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">D</forename><surname>Faugeras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hebert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Three-Dimensional Machine Vision</title>
		<editor>
			<persName><forename type="first">Takeo</forename><surname>Kanade</surname></persName>
		</editor>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="301" to="353" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Multiresolution modeling: Survey &amp; future opportunities</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Garland</surname></persName>
		</author>
		<ptr target="http://www.uiuc.edu/∼garland/papers.html" />
	</analytic>
	<monogr>
		<title level="m">State of the Art Report</title>
		<imprint>
			<date type="published" when="1999-09">September 1999</date>
			<biblScope unit="page" from="111" to="131" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Quadric-Based Polygonal Surface Simplification</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Garland</surname></persName>
		</author>
		<ptr target="http://www.uiuc.edu/∼garland/research/thesis.html" />
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University ; CS Dept.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rept. CMU-CS-99-105</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Surface simplification using quadric error metrics</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Garland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><forename type="middle">S</forename><surname>Heckbert</surname></persName>
		</author>
		<ptr target="http://www.uiuc.edu/∼garland/research/quadrics.html" />
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 97 Proc</title>
		<imprint>
			<date type="published" when="1997-08">August 1997</date>
			<biblScope unit="page" from="209" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">OBBTree: A hierarchical structure for rapid interference detection</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gottschalk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings SIGGRAPH 96</title>
		<meeting>SIGGRAPH 96</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="171" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A rapid hierarchical radiosity algorithm</title>
		<author>
			<persName><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Salzman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Larry</forename><surname>Aupperle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;91 Proc.)</title>
		<imprint>
			<date type="published" when="1991-07">July 1991</date>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="197" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Progressive meshes</title>
		<author>
			<persName><forename type="first">Hugues</forename><surname>Hoppe</surname></persName>
		</author>
		<ptr target="http://research.microsoft.com/∼hoppe/" />
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH &apos;96 Proc</title>
		<imprint>
			<date type="published" when="1996-08">August 1996</date>
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">View-dependent refinement of progressive meshes</title>
		<author>
			<persName><forename type="first">Hugues</forename><surname>Hoppe</surname></persName>
		</author>
		<ptr target="http://research.microsoft.com/∼hoppe/" />
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 97 Proc</title>
		<imprint>
			<date type="published" when="1997-08">August 1997</date>
			<biblScope unit="page" from="189" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Surface reconstruction from unorganized points</title>
		<author>
			<persName><forename type="first">Hugues</forename><surname>Hoppe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tony</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tom</forename><surname>Duchamp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Mc-Donald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Werner</forename><surname>Stuetzle</surname></persName>
		</author>
		<ptr target="http://research.microsoft.com/∼hoppe/" />
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIG-GRAPH &apos;92 Proceedings)</title>
		<imprint>
			<date type="published" when="1992-07">July 1992</date>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="71" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><forename type="first">K</forename><surname>Anil</surname></persName>
		</author>
		<author>
			<persName><surname>Jain</surname></persName>
		</author>
		<title level="m">Fundamentals of Digital Image Processing</title>
		<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall International</publisher>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Principal Component Analysis</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">T</forename><surname>Jolliffe</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Superfaces: Polygonal mesh simplification with bounded error</title>
		<author>
			<persName><forename type="first">Alan</forename><forename type="middle">D</forename><surname>Kalvin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Russell</forename><forename type="middle">H</forename><surname>Taylor</surname></persName>
		</author>
		<ptr target="http://www.computer.org/pubs/cg&amp;a/articles/g30064.pdf" />
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Appl</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1996-05">May 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Interactive multi-resolution modeling on arbitrary meshes</title>
		<author>
			<persName><forename type="first">Leif</forename><surname>Kobbelt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Swen</forename><surname>Campagna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jens</forename><surname>Vorsatz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hans-Peter</forename><surname>Seidel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGGRAPH 98</title>
		<meeting>SIGGRAPH 98</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="105" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">MAPS: Multiresolution adaptive parameterization of surfaces</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">F</forename><surname>Aaron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wim</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Sweldens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lawrence</forename><surname>Schröder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Cowsar</surname></persName>
		</author>
		<author>
			<persName><surname>Dobkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGGRAPH 98</title>
		<meeting>SIGGRAPH 98</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="95" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Representation and recognition of surface shapes in range images: A differential geometry approach</title>
		<author>
			<persName><forename type="first">Ping</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">S</forename><surname>Todhunter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Vision, Graphics, and Image Processing</title>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="page" from="78" to="109" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">View-dependent simplification of arbitrary polygonal environments</title>
		<author>
			<persName><forename type="first">David</forename><surname>Luebke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carl</forename><surname>Erikson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIG-GRAPH 97 Proc</title>
		<imprint>
			<date type="published" when="1997-08">August 1997</date>
			<biblScope unit="page" from="199" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Measuring compactness and the role of a compactness standard in a test for partisan and racial gerrymandering</title>
		<author>
			<persName><forename type="first">Richard</forename><forename type="middle">G</forename><surname>Niemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernard</forename><surname>Grofman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carl</forename><surname>Carlucci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Hofeller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Politics</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1155" to="1181" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Computational Geometry: an Introduction</title>
		<author>
			<persName><forename type="first">P</forename><surname>Franco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">I</forename><surname>Preparata</surname></persName>
		</author>
		<author>
			<persName><surname>Shamos</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York, NY</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>William</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Saul</forename><forename type="middle">A</forename><surname>Press</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">T</forename><surname>Teukolsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brian</forename><forename type="middle">P</forename><surname>Vetterling</surname></persName>
		</author>
		<author>
			<persName><surname>Flannery</surname></persName>
		</author>
		<ptr target="http://www.nr.com" />
		<title level="m">Numerical Recipes in C: The Art of Scientific Computing</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
	<note>Second edition</note>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Applications of Spatial Data Structures</title>
		<author>
			<persName><forename type="first">Hanan</forename><surname>Samet</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A clustering algorithm for radiosity in complex environments</title>
		<author>
			<persName><forename type="first">Brian</forename><surname>Smits</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Arvo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Donald</forename><surname>Greenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH &apos;94</title>
		<meeting>SIGGRAPH &apos;94</meeting>
		<imprint>
			<date type="published" when="1994-07">July 1994</date>
			<biblScope unit="page" from="435" to="442" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Dual graph contraction for irregular pyramids</title>
		<author>
			<persName><forename type="first">Dieter</forename><surname>Willersinn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Walter</forename><forename type="middle">G</forename><surname>Kropatsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th IAPR Intl. Conf. on Pattern Recognition</title>
		<meeting>12th IAPR Intl. Conf. on Pattern Recognition</meeting>
		<imprint>
			<date type="published" when="1994-10">October 1994</date>
			<biblScope unit="volume">III</biblScope>
			<biblScope unit="page" from="251" to="256" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Face cluster radiosity</title>
		<author>
			<persName><forename type="first">Andrew</forename><forename type="middle">J</forename><surname>Willmott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><forename type="middle">S</forename><surname>Heckbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Garland</surname></persName>
		</author>
		<ptr target="http://www.cs.cmu.edu/∼ajw/paper/fcr-eg99/" />
	</analytic>
	<monogr>
		<title level="m">Eurographics Workshop on Rendering</title>
		<imprint>
			<date type="published" when="1999-06">June 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Dynamic viewdependent simplification for polygonal models</title>
		<author>
			<persName><forename type="first">Julie</forename><forename type="middle">C</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amitabh</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;96</title>
		<meeting>Visualization &apos;96</meeting>
		<imprint>
			<date type="published" when="1996-10">October 1996</date>
			<biblScope unit="page" from="327" to="334" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
