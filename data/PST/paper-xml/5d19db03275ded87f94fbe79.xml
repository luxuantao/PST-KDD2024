<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Blockchain-Based Software-Defined Industrial Internet of Things: A Dueling Deep Q-Learning Approach</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><roleName>Student Member, IEEE</roleName><forename type="first">Qiu</forename><surname>Chao</surname></persName>
						</author>
						<author>
							<persName><roleName>Fellow, IEEE</roleName><forename type="first">F</forename><forename type="middle">Richard</forename><surname>Yu</surname></persName>
						</author>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Haipeng</forename><surname>Yao</surname></persName>
						</author>
						<author>
							<persName><roleName>Senior Member, IEEE</roleName><forename type="first">Chunxiao</forename><surname>Jiang</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Fangmin</forename><surname>Xu</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Chenglin</forename><surname>Zhao</surname></persName>
						</author>
						<title level="a" type="main">Blockchain-Based Software-Defined Industrial Internet of Things: A Dueling Deep Q-Learning Approach</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">FB9F4A0EB8EE91C8B0963791C42186C5</idno>
					<idno type="DOI">10.1109/JIOT.2018.2871394</idno>
					<note type="submission">This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2018.2871394, IEEE Internet of Things Journal</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:19+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Industrial Internet of Things (IIoT)</term>
					<term>softwaredefined networking (SDN)</term>
					<term>multiple controllers</term>
					<term>blockchain</term>
					<term>dueling deep Q-learning</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>With the development of communication technologies and smart manufacturing, industrial Internet of Things (IIoT) has emerged. Software-defined networking (SDN), a promising paradigm shift, has provided a viable way to manage IIoT dynamically, called software-defined industrial Internet of Things (SDIIoT). In SDIIoT, lots of data and flows are generated by industrial devices, where a physically distributed but logically centralized control plane is necessary. However, one of the most intractable problems is how to reach consensus among multiple controllers under complex industrial environments. In this paper, we propose a blockchain-based consensus protocol in SDIIoT, along with detailed consensus steps and theoretical analysis, where blockchain works as a trusted third party to collect and synchronize network-wide views between different SDN controllers. Specially, it is a permissioned blockchain. In order to improve the throughput of this blockchain-based SDIIoT, we jointly consider the trust features of blockchain nodes and controllers, as well as the computational capability of the blockchain system. Accordingly, we formulate view change, access selection, and computational resources allocation as a joint optimization problem. We describe this problem as a Markov decision process by defining state space, action space, and reward function. Due to the fact that it is difficult to solve this joint problem by traditional methods, we propose a novel dueling deep Q-learning approach. Simulation results are presented to show the effectiveness of our proposed scheme.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Recently, there are a growing number of applications that use Internet of Things (IoT) technologies in several industries. Industrial Internet of Things (IIoT) has emerged and attracted lots of attentions from industry and academia <ref type="bibr" target="#b0">[1]</ref>. In order to meet the demands of high bandwidth, ubiquitous accessibility, and dynamic management, software-defined networking (SDN) <ref type="bibr" target="#b1">[2]</ref> has been used in IIoT, called SDIIoT <ref type="bibr" target="#b2">[3]</ref>. In addition, software-defined routing management, edge computing, flow scheduling, and energy harvesting have been researched in excellent literature <ref type="bibr" target="#b3">[4]</ref>- <ref type="bibr" target="#b6">[7]</ref>. With the increasing number of industrial devices, more than one controller is employed in SDIIoT, known as distributed SDIIoT. How to reach consensus among multiple controllers is challenging in distributed SDIIoT.</p><p>Although some traditional methods enable to reach consensus among multiple controller instances, numerous nontrivial issues in the current consensus methods prevent SDIIoT from being used as a generic platform for different services and applications, including 1) the extra overheads, 2) the poor safety and liveness properties, 3) the limited scope of available network size. These challenges need to be broadly tackled by comprehensive research efforts.</p><p>Recently, Blockchain (BC) <ref type="bibr" target="#b7">[8]</ref> has been emerged as a novel technique, which can be used to address the above challenges. BC is a distributed ledger to record transactions, and provide trustworthy services to a group of nodes without central authority <ref type="bibr" target="#b8">[9]</ref>. For the distributed SDIIoT, BC can act as a trusted third and 'out-of-band' party to collect and synchronize network-wide views (e.g., network events, network topology, and OpenFlow commands, etc) between different SDN controllers safely, dependably, and traceably. In general, there are two kinds of BC <ref type="bibr" target="#b9">[10]</ref>, including permissionless BC and permissioned BC. In permissionless BC, enrollment is open to anyone, and nodes enable to join and leave dynamically and frequently, using Nakamoto consensus protocol and coupled to cryptocurrency, such as proof of work (PoW) in Bitcoin <ref type="bibr" target="#b7">[8]</ref> and proof of stake (PoS) in Ethereum <ref type="bibr" target="#b10">[11]</ref>. All BC participants (miners) contribute their CPU power to work on an extra hard task, and only the winner of them enables to propose a block and synchronize it with others. Thus, lots of resources and time are imposed in the permissionless BC. Moreover, another BC, the permissioned BC, uses Byzantine fault tolerance (BFT) consensus protocol. It employs state machine replication mechanism to deal with Byzantine nodes that are subverted by adversaries and against the common goal of reaching consensus maliciously <ref type="bibr" target="#b11">[12]</ref>, such as practical Byzantine fault tolerance (PBFT) <ref type="bibr" target="#b12">[13]</ref> and Paxos <ref type="bibr" target="#b13">[14]</ref>. They always operate in a partially trusted environment, such as Hyperledger Fabric <ref type="bibr" target="#b14">[15]</ref>. Thus, the advantages of permissioned BC are low costs, low latency, and low band-intensive. Considering partial trust, limited communication time, high loads and narrow bandwidth in SDIIoT, as well the advantages of permissioned BC, we consider to use permissioned BC in this paper.</p><p>In this paper, we propose a BC-based consensus protocol in distributed SDIIoT, where BC works as a trusted third party to collect and synchronize network-wide views between different SDN controllers. Specifically, it is a permissioned BC. Due to the fact that the throughput of permissioned BC is constrained with respect to the performance of BFT consensus protocol, we jointly consider the trust features of BC nodes and controllers, as well as the computational capability of BC system, so as to further improve the throughput of BC. Accordingly, we formulate view change, access selection, and computational resources allocation as a joint optimization problem. We describe this problem as a Markov decision process by defining state space, action space, and reward function. Inspired by the works to achieve the optimal decisions by improved learning methods <ref type="bibr" target="#b15">[16]</ref>- <ref type="bibr" target="#b17">[18]</ref>, and the fact that it is difficult to solve this joint problem by traditional methods, we use a novel dueling deep Q-learning approach to solve this problem. A preliminary version of our work appeared in <ref type="bibr" target="#b18">[19]</ref>. The distinct contributions of this paper are as follows.</p><p>• We propose a BC-based consensus protocol to simplify and secure the collection and synchronization of network views between different SDN controllers. And we give consensus steps in detail, along with theoretical analysis. • Due to the fact that lots of network views need to be collected and synchronized by BC system, we jointly consider the trust features of BC nodes and controllers, as well as computational capability of the BC system, so as to improve the throughput. Accordingly, we formulate view change, access selection, and computational resources allocation as a joint optimization problem. We describe it as a Markov decision process by defining state space, action space, and reward function. • In order to address this joint problem, we propose a novel dueling deep Q-learning approach to learn the optimal strategy. Simulation results with different system parameters are presented to show the effectiveness of the proposed scheme. The rest of this paper is organized as follows. In Section II, we present some related works about SDIIoT and distributed SDN. Section IV describes the BC-based consensus protocol, followed by the system model in Section III. In Section V, we describe view change, access selection, and computational resources allocation as a Markov decision process. We then use a novel dueling deep Q-learning approach to solve this issue in Section VI. Simulation results are presented and discussed in Section VII. Finally, conclusions and future works are given in Section VIII.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. RELATED WORK</head><p>In this section, we briefly present the recent advances in SDIIoT and distributed SDN. Some challenges are discussed as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Software-Defined Industrial Internet of Things</head><p>There are a number of advances in IIoT, such as industrial wireless sensor networks, industrial big data, cloud computing, and fog computing. These emerging techniques bring the explosion of intelligent devices, industrial robots that are supported by wired or wireless networks. In order to meet the demands of high bandwidth, ubiquitous accessibility, and dynamic management, lots of works have employed SDN in IIoT. For example, Wan et al. in <ref type="bibr" target="#b19">[20]</ref> proposed a software-defined industrial network to manage manufacturing resources dynamically. Moness et al. in <ref type="bibr" target="#b20">[21]</ref> employed a hybrid software-defined approach in IIoT. Silva et al. in <ref type="bibr" target="#b21">[22]</ref> expanded OpenFlow protocol in industrial scenarios. Duan et al. in <ref type="bibr" target="#b22">[23]</ref> described a software-defined and virtual multiple networks control framework in IIoT.</p><p>As we can see that there is an emerging trend to employ SDN in IIoT. Due to the fact that there are lots of data and flows in SDIIoT, more than one controller is necessary, called distributed SDIIoT. One of the most intractable problems in distributed SDIIoT is how to reach consensus among multiple controllers. Whether or not traditional distributed SDN architectures are suitable in IIoT, and how to reach consensus among controllers need to be further researched. Therefore, we will present some traditional distributed SDN architectures, along with the corresponding consensus methods and their challenges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Distributed SDN Architectures</head><p>Traditionally, there are lots of works to design distributed SDN architectures <ref type="bibr" target="#b23">[24]</ref>. Based on the configuration methods between controllers and switches, we classify them as statically configured control architecture and dynamically configured control architecture <ref type="bibr" target="#b24">[25]</ref>.</p><p>1) Statically Configured Control Architecture: The authors in <ref type="bibr" target="#b25">[26]</ref> designed the first distributed SDN control plane for OpenFlow, called HyperFlow. It synchronized controllers' network-wide views (i.e., local controller instance's events) by a publish/subscribe messaging paradigm. <ref type="bibr">Koponen et al. in [27]</ref> considered a Onix architecture. They used network information base (NIB) to aggregate and share network-wide views.</p><p>2) Dynamically Configured Control Architecture: Statically configured control architectures lead to the uneven load distribution among controllers. Therefore, Berde et al. in <ref type="bibr" target="#b27">[28]</ref> designed an elastic and experimental distributed SDN control plane, called ONOS. The work in <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b29">[30]</ref> presented a hierarchical SDN control architecture with the joint consideration of load balancing and energy consumption of multiple controllers.</p><p>As we can see from the above researches, one of the most important problems in distributed SDN architectures is how to reach consensus among multiple controller instances. No matter which consensus protocols (e.g., publish/subscribe, slicing, NIB, and controllers pool, etc.), lots of challenges are remained to be solved when they are employed in SDIIoT.</p><p>• The traditional consensus protocols are implemented 'in-band', which leads to the extra overheads in each controller to weaken the inherent functions of controllers (e.g. routing decisions, and network management, etc.). Especially, due to the limited capacities of industrial devices, this problem is more severe. Therefore, a third party and 'out-of-band' consensus protocol is necessary in SDIIoT. works, the limited scopes of these consensus protocols are challenging. A large-scale consensus protocol should be employed in SDIIoT. These challenges have fueled the needs to explore new consensus protocols in SDIIoT. Inspire by the successful integration BC with secure key synchronization <ref type="bibr" target="#b30">[31]</ref>, and data sharing <ref type="bibr" target="#b31">[32]</ref> in intelligent transportation systems, we consider that BC could be a potential approach to address the challenges in distributed SDIIoT. BC is a distributed system to provide dependable services to a group of nodes that don't fully trust each other. It can be seen as a third party system to achieve an agreement among nodes without a central trust broker, with the features of dependability, and in largely available system scale. In addition, considering the fact that distributed SDIIoT operates in partially trusted environment, and the advantages of permissioned BC, we utilize the permissioned BC in distributed SDIIoT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. SYSTEM MODEL</head><p>In this section, we introduce the system model that we use. We first present the network model, followed by the trust feature model and the computation model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Network Model</head><p>We assume that there are C controllers in distributed SDI-IoT, which are represented by C = {1, ..., C}. Each of them can communicate with the third-party BC system. This BC system consists of N nodes, i.e., physical machines, denoted by N = {1, ..., N }. Like other robust BFT protocols <ref type="bibr" target="#b32">[33]</ref>, these N nodes are under Byzantine failure model to make consensus, where at most f nodes are faulty <ref type="bibr" target="#b12">[13]</ref>, where f = N -1 3 . And any finite number of controllers can behave arbitrarily to issue correct or incorrect transactions to the BC system. Some strong adversaries can collude with each other to compromise the replicated service. However, they can't break cryptographic technologies, i.e., signatures, message authentication code (MAC), and collision-resistant hashing. We denote the messages with cryptographic technologies as follows <ref type="bibr" target="#b33">[34]</ref>.</p><p>• ⟨m⟩ σi means that message m is signed with a pubilc key from node i. • ⟨m⟩ σi,j means that message m is authenticated by node i with a MAC for node j.</p><formula xml:id="formula_0">• ⟨m⟩ σ ⃗ i</formula><p>means that message m is authenticated by an array of MACs with node i for every replicas. Fig. <ref type="figure" target="#fig_0">1</ref> shows the different network structures between traditional scheme and BC-based scheme. It is worth mentioning that we use edge computing servers to do some computations related to the above cryptography so as to improve the throughput of BC system. There are E edge computing servers, and the set of computing servers is represented by E = {1, 2, ..., E}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Trust Feature Model</head><p>We consider trust features of nodes and controllers in the system. Due to the lack of centralized security services and prior security association, all nodes and controllers have diverse trust features, such as safe or compromised. It is barely possible to exactly know what the trust feature is for one node or one controller at the next time instant. Thus, the trust features of a node n ∈ {1, 2, ..., N } and a controller c ∈ {1, 2, ..., C} can be modelled as random variables δ n and η c . δ n and η c can be divided into discrete levels, denoted by ξ = {ξ 0 , ξ 1 , ..., ξ L-1 }, and D = {D 0 , D 1 , ..., D H-1 }, respectively, where L and H are the number of available trust features for nodes and controllers. We assume the trust features realization of δ n and η c to be δ n (t) and η c (t) at time slot t, respectively. There are T time slots during the period of time, which starts from when the controller issues an un-validated block, and terminates when the controller is replied with a validated block. Let t ∈ {0, 1, 2, ..., T -1} denote the time instant.</p><p>Considering the time correlation of real trust features in BC nodes and controllers, we use Markov chain to model the transition of trust features in BC nodes and controllers, as follows:</p><p>• For node n, let the transition probability of δ n (t) from one state X s to another state Y s be κ XsYs (t). The L×L transition probability matrix K n (t) of the trust feature in node n is denoted as</p><formula xml:id="formula_1">K n (t) = [κ XsYs (t)] L×L ,<label>(1)</label></formula><p>where κ XsYs (t) = P r(δ</p><formula xml:id="formula_2">n (t + 1) = Y s |δ n (t) = X s ), and X s , Y s ∈ ξ. • For controller c, the transition probability of η c (t) is γ θsϕs (t)</formula><p>. The H ×H transition probability matrix Υ c (t) of the trust feature in controller c is denoted as where γ θsϕs (t) = P r(η c (t + 1) = ϕ s |η c (t) = θ s ), and θ s , ϕ s ∈ D.</p><formula xml:id="formula_3">Υ c (t) = [γ θsϕs (t)] H×H ,<label>(2)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Computation Model</head><p>There are a number of computation tasks in the BC nodes, such as verifying signatures, generating MACs, and verifying MACs. Let T m = {s m , q m } denote a computation task related to message m, where s m means the size of message m, and q m is the required number of CPU cycles to complete this task.</p><p>In order to improve the throughput of BC, we use virtual computing resources from edge computing servers to do computation tasks in the BC system. There are lots of edge computing servers and some other computation tasks that also use the computation resources in edge computing servers, thus we don't exactly know the computational resources for the BC system at the next time instant. Therefore, we model the computation resources of edge computing server e for the BC system as a random variable </p><formula xml:id="formula_4">Π n (t) = [ϑ asbs (t)] Y ×Y ,<label>(3)</label></formula><p>where ϑ asbs (t) = P r(ζ e (t + 1) = b s |ζ e (t) = a s ), and</p><formula xml:id="formula_5">a s , b s ∈ Y.</formula><p>The execution time of computation task T m can be denoted as</p><formula xml:id="formula_6">t m = q m ζ e (t) . (<label>4</label></formula><formula xml:id="formula_7">)</formula><p>Thus, the computation rate is</p><formula xml:id="formula_8">CompR e (t) = a e (t) s m t m = a e (t) ζ e (t)s m q m ,<label>(5)</label></formula><p>where a e (t) means whether or not edge computing server e is allocated to the BC system at time slot t. a e (t) = 1 denotes edge computing server e is allocated to the BC system; otherwise a e (t) = 0. At one time slot, there is only one edge computing server allocated to the BC system, thus ∑ E e=1 a e (t) = 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. BLOCKCHAIN-BASED CONSENSUS PROTOCOL</head><p>We have presented that the existing consensus protocols are challenging in SDIIoT, and BC could be a potential approach to address these issues in the previous section. In this section, we propose a novel BC-based consensus protocol in distributed SDIIoT. We begin with an overview of BC-based consensus protocol. Then, we present the detailed steps of the consensus protocol, along with theoretical analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Overview of BC-Based Consensus Protocol</head><p>Each controller collects its local events and OpenFlow commands as Transaction #1, Transaction #2, ..., Transaction #n, which is called the collection period. The format of a transaction is shown in Table <ref type="table" target="#tab_1">I</ref>. The number of this transaction denotes the position of this transaction. The signature and MAC make sure the integrity and authentication of this transaction. The payloads include local events and OpenFlow   commands that need to be synchronized between different SDN controllers.</p><p>After the collection period, all controllers issue consensus requests to the third-party BC system. According to a policy, which will be introduced in the following Section, called access selection, the BC system only enables one controller to access, and replies it by an admission message. Then, this controller sends an un-validated block with block header and transactions, whose format is presented in Table <ref type="table" target="#tab_2">II</ref>. After reaching consensus, the BC system sends the corresponding validated block to the entire controllers. Finally, all controllers learn the payloads in each transaction to know the events and OpenFlow commands from other controller. These steps are in the consensus period. By this way, network-wide views can be synchronized between different SDN controllers.</p><p>For a comprehensive perspective, Fig. <ref type="figure" target="#fig_2">2</ref> offers the consensus procedures in blockchain structure. Here, controller 1 is the selected controller to access to the BC system. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Detailed Steps and Theoretical Analysis</head><p>After giving the overview of BC-based consensus protocol, we will introduce the detailed steps inside the permissioned BC, along with the theoretical analysis of each step.</p><p>Based on PBFT <ref type="bibr" target="#b12">[13]</ref>, the detailed steps inside the permissioned BC is depicted in Fig. <ref type="figure" target="#fig_3">3</ref>. The numbering of each step in this figure is the same as the one used in the remainder of this subsection. PBFT protocol has been used in real scenario, such as Hyperledger Fabric project <ref type="bibr" target="#b14">[15]</ref>, and Hyperledger Indy project <ref type="bibr" target="#b34">[35]</ref>. They are hosted by The Linux Foundation, and develop applications with a modular architecture. Thus, we consider that it can be used in real scenario when meeting with SDN controllers.</p><p>1. The controller sends an un-validated block to all nodes. The selected controller sends an un-validated block to the BC system. The agent chooses one node in the BC as the primary node p. Making decisions about which node is the primary node is known as view change protocol. The view change protocol used in our proposed scheme will be introduced in the following Section. This selected controller sends a block message ⟨⟨block⟩ σc , c⟩ σ ⃗ c to all nodes, where c denotes the controller ID. It is encrypted with the private signature of controller c, and authenticated with MACs for all nodes. When receiving this message, only primary node p verifies the MAC. If valid, the signature will be verified then. If still valid, it verifies the signature and the MAC of each transaction in this block, then moves to the following steps. The success rate of all verification will be recorded by the agent. If this block has already been executed, the primary will resend the validated block to this controller.</p><p>Theoretical analysis. We consider an uncivil execution during which a fraction g of transactions sent by the controller are correct <ref type="bibr" target="#b33">[34]</ref>. The more trusted controller has the bigger g. We assume verifying one signature, generating one MAC, and verifying one MAC require θ, α, and α cycles, respectively, and the controller issues batches of transactions of size b. As the work in <ref type="bibr" target="#b12">[13]</ref>, we ignore the cost of sending and receiving transactions. Therefore, the cost at the primary is</p><formula xml:id="formula_9">(1 + b g )(θ + α), (<label>6</label></formula><formula xml:id="formula_10">)</formula><p>and there is no cost at non-primary nodes.</p><p>2. The primary node multicasts PRE-PREPARE message to other replica nodes. Finishing the verification, primary p sends a PRE-PREPARE message to all other replica nodes, as ⟨P RE -P REP ARE, p, c, H(m)⟩ σ ⃗ p , which is authenticated with MACs for each replica node. Here, p and H(m) mean the primary node ID and the hashed result of the issued block, respectively. The replica node verifies the MAC of primary p, as well as the signature and the MAC of each transaction. Then it enters the following steps.</p><p>Theoretical analysis. In this phase, primary p generates (N -1) MACs for all replicas. Each replica verifies one MAC from primary p, as well as b g signatures and MACs from transactions. Thus, the cost at the primary is</p><formula xml:id="formula_11">(N -1)α,<label>(7)</label></formula><p>and the cost at each replica node is</p><formula xml:id="formula_12">α + b g (θ + α). (<label>8</label></formula><formula xml:id="formula_13">)</formula><p>3. The replicas send PREPARE message to others. After verifying the validity of MACs and signatures, each replica replies the PRE-PREPARE message with sending a PREPARE message to all nodes, as ⟨P REP ARE, p, c, H(m), n⟩ σn , where n denotes the replica node ID. When each replica node collects 2f matching PREPARE messages with its local PRE-PREPARE message, it will enter the following steps.</p><p>Theoretical analysis. In this phase, primary p needs to verify 2f MACs. Each replica node generates (N -1) MACs and verifies 2f MACs. Therefore, the cost at the primary is 2f α, <ref type="bibr" target="#b8">(9)</ref> and the cost at each replica is</p><formula xml:id="formula_14">(N -1 + 2f )α.<label>(10)</label></formula><p>4. All nodes send COMMIT message to others. Following the reception of 2f matching PREPARE messages, node n sends a COMMIT message to all others, as ⟨COM M IT, p, c, H(m), n⟩ σ ⃗ n . After receiving 2f matching COMMIT messages, it will enter the following steps.</p><p>Theoretical analysis. In this phase, primary p needs to generate (N -1) MACs, and verify 2f MACs. Each replica generates (N -1) MACs, and verifies 2f MAC. Therefore, the costs at the primary and the replica are both</p><formula xml:id="formula_15">(N -1 + 2f )α. (<label>11</label></formula><formula xml:id="formula_16">)</formula><p>5. The nodes send the validated block to all controllers. Node n sends a REPLY message ⟨REP LY, block, n⟩ σn,c to all controllers, where block is the validated block. When each controller receives 2f valid and matching REPLY messages, it accepts this validated block and updates the corresponding network views.</p><p>Theoretical analysis. In this phase, the primary and the replicas need to generate b g MACs for one controllers. Therefore, the total costs at the primary and the replica are both b g Cα. <ref type="bibr" target="#b11">(12)</ref> Thus, for one transaction, the cost at the primary is</p><formula xml:id="formula_17">( 1 g + 1 b )θ + ( 1 b + C + 1 g )α + 2N + 4f -2 b α (<label>13</label></formula><formula xml:id="formula_18">)</formula><p>For one transaction, the cost at the replica is</p><formula xml:id="formula_19">1 g θ + 2 + C g α + 2N + 4f -2 b α (<label>14</label></formula><formula xml:id="formula_20">)</formula><p>We assume that multi-core computation modules run in parallel on distinct cores. Each core has the computation speed of φ Hz. In addition, we consider an uncivil execution where the primary is not fully trusted. The primary has k trust to affect the system performance, and k ∈ [0, 1]. The more trusted primary node has the bigger k. Therefore, the throughput of the consensus protocol is at most</p><formula xml:id="formula_21">min[ kφ ( 1 g + 1 b )θ + ( 1 b + C+1 g )α + 2N +4f -2 b α , kφ 1 g θ + 2+C g α + 2N +4f -2 b α ]trx/s.<label>(15)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. PROBLEM FORMULATION</head><p>We have presented the throughput of the BC system. In order to improve the throughput, we need to make the joint decisions about view changes, access selection, and computational resources allocation. In this section, we formulate this joint problem as a Markov decision process by defining state space, action space, and reward function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. State Space</head><p>In order to improve the throughput, the learning agent needs to sense state s(t) at time slot t. As we have mentioned, the learning agent should make the joint decisions about view changes, access selection, and computational resources allocation. Accordingly, the learning agent needs to sense the trust features of all nodes and controllers, as well as the computational capabilities of all edge computing servers. Therefore, the state space can be represented as follows.</p><formula xml:id="formula_22">s(t) =   δ 1 (t) δ 2 (t) ... δ N (t) η 1 (t) η 2 (t) ... η C (t) ζ 1 (t) ζ 2 (t) ... ζ E (t)   . (<label>16</label></formula><formula xml:id="formula_23">)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Action Space</head><p>The agent mainly needs to decide view changes (i.e., which node is the primary node), access selection (i.e., which controller can access to the BC system), and computational resources allocation (i.e., which edge computing server should be allocated to the BC system). Thus, the action space is denoted by</p><formula xml:id="formula_24">A(t) = {A N (t), A C (t), A E (t)},<label>(17)</label></formula><p>where A N (t), A C (t), and A E (t) represent:</p><p>• A N (t) = [a 1 (t), a 2 (t), ..., a n (t), ..., a N (t)], which means whether or not node n is the primary. And a n (t) ∈ {0, 1}, where a n (t) = 1 means node n is the primary node, otherwise it is the replica node. Note that the BC system only has one primary node, thus</p><formula xml:id="formula_25">∑ N n=1 a n (t) = 1. • A C (t) = [a 1 (t)</formula><p>, a 2 (t), ..., a c (t), ..., a C (t)] decides which controller can access to the BC system. And a c (t) ∈ {0, 1}, where a c (t) = 1 represents controller c can access, otherwise a c (t) = 0. Note that at one time slot, only one controller enables to access to the BC system, thus</p><formula xml:id="formula_26">∑ C c=1 a c (t) = 1. • A E (t) = [a 1 (t)</formula><p>, a 2 (t), ..., a e (t), ..., a E (t)] determines which edge computing server is allocated to the BC system. And a c (t) ∈ {0, 1}, where a e (t) = 1 denotes edge computing server e is allocated, otherwise a e (t) = 0. Similarly, ∑ E e=1 a e (t) = 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Reward Function</head><p>In order to improve the throughput, we model the throughput of the BC system as reward function. According to <ref type="bibr" target="#b14">(15)</ref>, state space, and action space, we define the reward function as:</p><formula xml:id="formula_27">r(t) = min[ k ′ φ ′ ( 1 g ′ + 1 b )θ + ( 1 b + C+1 g ′ )α + 2N +4f -2 b α , kφ 1 g ′ θ + 2+C g ′ α + 2N +4f -2 b α ]trx/s,<label>(18)</label></formula><p>where</p><formula xml:id="formula_28">k ′ = ∑ N n=1 a n (t)δ n (t), φ ′ = ∑ E</formula><p>e=1 a e (t)CompR e (t), and g ′ = ∑ C c=1 a c (t)η c (t). Based on the above problem formulation, the learning agent senses state s(t) at time slot t, and outputs a policy π that determines which action a(t) should be taken. Then this action will be executed, i.e., one controller will enable to access to the BC system, one node will be the primary node, and one edge computing server will be allocated to the BC system. In order to let the learning agent remember the experience and act better next time, the immediate reward r(t) will be fed back to the learning agent. The trust features of nodes and controllers, as well as the computational capabilities of edge computing servers change to next state s(t + 1). Then the learning agent senses them and outputs Fig. <ref type="figure" target="#fig_6">4</ref>: The interaction of the learning agent and the environment.</p><p>another new policy, and so on so forth. The final goal is to achieve the maximum long-term reward. Summarily, the interaction of the learning agent and the environment is shown in Fig. <ref type="figure" target="#fig_6">4</ref>.</p><p>There are some challenges to solve the above problem formulation as follows.</p><p>1) The target is to maximize the long-term reward by stepand-step control. However, the learning agent only senses the state at time slot t, and the action taken at time slot t will affect the environment at time slot t + 1. The state cannot be obtained ahead of time. Thus, the traditional optimization method, only considering current state, is not feasible.</p><p>2) Considering the trust features of nodes and controllers, as well as the computational capabilities of edge computing servers, the system is high-dimensional and high-dynamical. It is hard to make the joint and optimal decisions by traditional methods.</p><p>3) In the BC system, taking which action has no relationship with what happens in the next time slot. For example, when the learning agent selects one controller to access to the BC system, its trust feature in the next time slot still changes according to its transition probability matrix, not the action. Therefore, the traditional optimization method, learning the relationship between states and actions, is not suitable.</p><p>To address the above challenges, we will propose a dueling deep Q-learning approach in the next Section to achieve the maximum long-term reward.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. DUELING DEEP Q-LEARNING</head><p>After the problem formulation, we consider a dueling deep Q-learning approach to address this problem. In this section, we begin with the introduction of Q-learning and deep Qlearning. Then we present dueling deep Q-learning that is used in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Q-Learning</head><p>In the Q-learning model, the agent interacts with the environment by perceptions and actions. In one interaction step, the agent receives current state s(t) from the environment, then selects an action a(t) as the output, and the value of this action is measured by a scalar reward r(t). This action generates next state s(t+1). The agent selects actions to obtain the maximum long-term rewards. It learns to do this over several interaction steps by systematic trials and errors, guided by Q-learning <ref type="bibr" target="#b35">[36]</ref>. Q-learning is a modelfree algorithm using delay rewards. It aims to find a policy π, mapping states and actions, to maximize the long-term rewards.</p><p>There are two popular approaches to denote the feedback from each step in terms of long-term rewards, namely state-value function V π (s) and action-state value function Q π (s, a). V π (s) means the expected total reward in state s:</p><formula xml:id="formula_29">V π (s) = E π [ ∞ ∑ k=1 γ k r t+k+1 |s t = s], (<label>19</label></formula><formula xml:id="formula_30">)</formula><p>where E π [ * ] means mathematical expectation, r t+k+1 means the immediate reward at time slot t + k + 1, and γ ∈ (0, 1) is discount factor to balance immediate reward and future reward. Moreover, Q π (s, a) denotes the expected total rewards in state s and action a:</p><formula xml:id="formula_31">Q π (s, a) = E π [ ∞ ∑ k=1 γ k r t+k+1 |s t = s, a t = a]. (<label>20</label></formula><formula xml:id="formula_32">)</formula><p>Q-learning evaluates Q(s, a) by a temporal difference method as follows.</p><formula xml:id="formula_33">Q(s, a) ← Q(s, a)+α(r+γ max a ′ Q(s ′ , a ′ )-Q(s, a)), (<label>21</label></formula><formula xml:id="formula_34">)</formula><p>where α is learning rate, and α ∈ (0, 1]. The action with maximum Q(s, a) may be chosen by the agent at each step. In the traditional Q-learning, each Q(s, a) is put into Qtable. However, with the rapid increase of data dimension, it is challenging to put all Q(s, a) into Q-table.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Deep Q-Learning</head><p>The rise of deep learning has provided a new tool to overcome the challenges. The most important property of deep learning is that deep networks enable to find the lowdimensional features of high-dimensional data by crafting weights and biases in deep networks. Therefore, many researches have advocated to use deep networks to approximate Q(s, a) instead of Q-table, i.e., Q(s, a, ω) ≈ Q(s, a), where ω is the set of weights and biases in deep networks <ref type="bibr" target="#b36">[37]</ref>. This is the core idea of deep Q-learning (DQL).</p><p>In order to address the fundamental instability problem of approximating Q(s, a), there are two improvements in DQL, including experience replay and fixed target networks: 1) Experience replay stores the transitions as a set of  <ref type="bibr" target="#b21">(22)</ref> where ω -is the weights and biases set in target networks, and ω is the weights and biases set in evaluated networks. During training, the weights and biases in target networks are updated with evaluated networks periodically. For a comprehensive perspective, we present the workflows of DQL in Fig. <ref type="figure" target="#fig_4">5</ref>.</p><formula xml:id="formula_35">L(ω) = E[(r + γmax a ′ Q(s ′ , a ′ , ω -) -Q(s, a, ω)) 2 ],</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Dueling Deep Q-Learning Approach</head><p>However, for the majority of states in our system, the choice of actions in the agent has no repercussion with what happens, i.e., actions have no relationship with states. According to the work in <ref type="bibr" target="#b37">[38]</ref>, dueling DQL is more efficient than natural DQL. Based on this approach, some training processes have been carried out in real scenario, such as drive games <ref type="bibr" target="#b37">[38]</ref>, which are simulated with better performance.</p><p>In the dueling DQL, there is another value function, A(s, a), which represents the relative advantage of a action, called state-action value function. Learning A(s, a) is easier to know which action has better consequences. Instead of one single stream following the output layer of deep networks, there are two separate streams in dueling DQL, where one computes state-value function V (s), and another computes state-action value function A(s, a), called dueling architecture as shown in Fig. <ref type="figure" target="#fig_7">6</ref>. Finally, these two streams are aggregated as a output Q(s, a). This combination module is denoted as follows: Reset the environment with a randomly initial observation s ini , and s(t) = s ini . Select action a(t) based on ϵ-greedy policy.</p><formula xml:id="formula_36">Q(s, a; ω, ϱ, ζ) = V (s; ω, ϱ) + A(s, a; ω, ζ),<label>(24)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6:</head><p>Obtain immediate reward r(t) and next observation s(t + 1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7:</head><p>Store experience (s(t), a(t), r(t), s(t + 1)) into experience replay memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>8:</head><p>Randomly sample some batches of (s(i), a(i), r(i), s(i + 1)) from experience replay memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>9:</head><p>Calculate two streams of evaluated deep networks, including V (s; ω, ϱ) and A(s, a; ω, ζ), and combine them as Q(s, a; ω, ϱ, ζ) using <ref type="bibr" target="#b24">(25)</ref>.</p><formula xml:id="formula_37">10: Calculate target Q-value Q target (s) in target deep networks: if s ′ is s terminal Q target (s) = r s , else Q target (s) = r s + γmax a ′ Q(s ′ , a ′ ; ω ′ , ϱ ′ , ζ ′ ).</formula><p>11:</p><p>Train evaluated deep networks to minimize loss function L(w)</p><formula xml:id="formula_38">L(ω, ϱ, ζ) = E[(Q target (s) -Q(s, a; ω, ϱ, ζ)) 2 ].<label>(23) 12:</label></formula><p>Every some steps, update target deep networks.</p><p>13:</p><formula xml:id="formula_39">s(t) ← s(t + 1) 14:</formula><p>end while 15: end for where V (s; ω, ϱ) is a scalar <ref type="figure">,</ref> and<ref type="figure">A(s, a; ω, ζ</ref>) is an |A|-dimensional vector. ϱ and ζ are the parameters of two separate streams.</p><p>According to the work in <ref type="bibr" target="#b37">[38]</ref>, considering the unidentifiability of (24), we replace <ref type="bibr" target="#b23">(24)</ref> as:</p><formula xml:id="formula_40">Q(s, a; ω, ϱ, ζ) = V (s; ω, ϱ)+ (A(s, a; ω, ζ) - 1 |A| ∑ a ′ A(s, a ′ ; ω, ζ)).</formula><p>(25) As the output of dueling architecture is Q(s, a), it can be trained by many existing algorithms. In this paper, we use dueling architecture in natural DQL. Therefore, the of dueling DQL is presented in Algorithm 1, ϵ-greedy policy is used to balance the exploitation and the exploration. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. SIMULATION RESULTS AND DISCUSSIONS</head><p>In this section, we use computer simulation to evaluate the performance of our proposed scheme. First, we present simulation settings, followed by simulation results and the corresponding discussions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Simulation Settings</head><p>In this simulation, hardware environment is a GPU-based server, and this server has 8GB 1867MHz LPDDR3, 2GHz Intel Core i5, and 256G memory. Software environment is Python 2.7.10 with TensorFlow 1.4.0 <ref type="bibr" target="#b38">[39]</ref>. These two kinds of simulation tools have been widely used from business to academic. TensorFlow is a flexible, high-performance serving system, used by machine learning models, and designed for production environments. TensorFlow enables to keep the same server architecture and application program interface (APIs), when different machine learning algorithms are deployed. Thus, it has been widely used to deploy new machine learning algorithms and experiments. We use these real simulation environments, thus we can make sure that the performance of simulation results can estimate and approximate the performance in real scenario.</p><p>We assume that there are four BC nodes, two controllers, and two edge computing servers. The trust feature of each node is very safe, safe, medium, compromised, and very compromised, whose transition probability matrix is</p><formula xml:id="formula_41">K =      </formula><p>0.5 0.15 0.125 0.12 0.105 0.15 0.5 0.125 0.12 0.105 0.105 0.15 0.5 0.125 0.12 0.105 0.12 0.125 0.5 0.15 0.105 0.12 0.125 0.15 0.05</p><formula xml:id="formula_42">      . (<label>26</label></formula><formula xml:id="formula_43">)</formula><p>Similarly, the trust feature of each controller can be very safe, safe, medium, compromised, and very compromised. We set the transition probability matrix as</p><formula xml:id="formula_44">Υ =      </formula><p>0.45 0.16 0.14 0.13 0.12 0.16 0.45 0.14 0.13 0.12 0.12 0.16 0.45 0.14 0.13 0.12 0.13 0.16 0.45 0.14 0.12 0.13 0.14 0.16 0.45 (</p><formula xml:id="formula_45">      . (<label>27</label></formula><formula xml:id="formula_46">)</formula><formula xml:id="formula_47">)<label>28</label></formula><p>The values of the rest of parameters summarized in Table <ref type="table" target="#tab_3">III</ref>. We use TensorBoard to visualize the TensorFlow graph, as shown in Fig. <ref type="figure" target="#fig_8">7</ref>.</p><p>For the performance comparison, there are four schemes simulated:</p><p>• Proposed dueling DQL-based scheme with view changes, access selection, and edge computing servers. We call it duelingDQL-based scheme in the remainder of this section. In other words, in duelingDQL-based scheme, the learning agent enables to select more trusted BC node as the primary, more trusted controller to access to the BC system, and edge computing server with more computing capabilities. Thus, this scheme should have the best performance. • Proposed dueling DQL-based scheme with view changes, edge computing servers, but without access selection. We call it dueling DQL-based scheme without controller choice in the remainder of this section. That is to say, in this scheme, the learning agent only enables to select more trusted BC node as the primary, and edge computing server with more computing capabilities, but controllers access to the BC system randomly. Thus, some malicious controllers may issue incorrect transactions to slow down the performance. Compared with the duelingDQL-based scheme, the advantage of selecting trusted controller can be indicated. • Proposed dueling DQL-based scheme with access selection, edge computing servers, but with the traditional view change protocol in <ref type="bibr" target="#b12">[13]</ref>. We call it duelingDQLbased scheme without node choice in the remainder of this section. In other words, in this scheme, the learning agent only selects more trusted controller to access to the BC system, and edge computing server with more computing capabilities, but using the traditional view change protocol without considering historical trust reputation. Thus, some malicious nodes may be selected as the primary to weaken the throughput. Compared with the duelingDQL-based scheme, the merit of selecting trusted BC node can be shown. • Proposed dueling DQL-based scheme with view changes, access selection, but without edge computing servers, which only uses the local computing capabilities in the BC system. We call it duelingDQLbased scheme without computation offloading in the remainder of this section. That is to say, the learning agent only selects more trusted BC node as the primary, and more trusted controller to access to the BC system, but only using the local computing capabilities. Without the assistance of edge computing servers, it is difficult to do cryptographic tasks only by local computation, which may slow down the performance. Compared with the duelingDQL-based scheme, the advantage of using edge computing servers can be indicated. • Existing scheme with traditional view changes, without access selection, and with local computational capabilities. We call it existing scheme in the remainder of this section. The dueling DQL approach is not employed in this scheme. This scheme allows controllers to access to the BC system randomly, uses the traditional view change protocol and local computing capabilities.</p><p>Compared with the duelingDQL-based scheme, the advantage of using the dueling DQL approach can be shown.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Simulation Results</head><p>Fig. <ref type="figure" target="#fig_9">8</ref> shows the relationship between training episodes and the throughput of the BC system under different schemes. Each point is the average throughput per episode. The agent runs in AdamOptimizer <ref type="bibr" target="#b39">[40]</ref> with the learning rate of 1e -5 . As we can see from this figure, with the joint consideration of node's trust feature, controller's trust feature, and offloading the computation task to edge computing servers, the BC system has the better performance. The reason is that the more trusted node is less possible to slow the system performance down, the more trusted controller issues the higher fraction of correct transactions, and with the help of edge computing servers, computation tasks can be executed more quickly. This figure shows the convergence performance of dueling DQL as well. At the beginning of learning and training, dueling DQL takes some trials and errors. With the increase of episodes, the throughput turns to be stable, which means the agent has learned the optimal policies to maximize the long-term rewards.</p><p>In addition, Fig. <ref type="figure" target="#fig_10">9</ref> shows the relationship between the learning loss in <ref type="bibr" target="#b21">(22)</ref> and the training steps of DuelingDQLbased scheme, when the agent runs in the same parameters  as above. At the beginning of learning, deep networks have no knowledge of the uncertain environment, and with the increase of new experiences, the learning loss is higher and higher. When the cyclic buffer of experiences in dueling DQL is full, the agent has some knowledge of the environment, which leads to the decrease of the learning loss. Such increasing and decreasing of the learning loss indicate the effectiveness of deep networks. Fig. <ref type="figure" target="#fig_11">10</ref> shows the relationship between training episodes and the throughput under different learning rates in Dueling DQL-based scheme. As we can see from this figure, the learning rate has effects on the convergence performance. The learning rate means the length of learning step to minimize the loss function. The bigger learning rate denotes the longer learning step. The longer learning steps are likely to miss the global optimum, which leads to the highly scaled curves when learning rates are 0.01 and 0.001. The shorter learning steps may lead to the slower convergence speed, because more steps are necessary to achieve the global optimum. Compared with two curves of blue and orange, although the orange one has the faster convergence speed, its curve is unstable after the convergence. Therefore, we choose the learning rate as 1e -5 in the simulation. Because its convergence speed is acceptable and it has better learning stability.     <ref type="figure" target="#fig_12">11</ref> shows the learning loss of natural DQL and dueling DQL. As we can see, the learning loss in dueling DQL decreases more quickly than natural DQL, which indicates dueling DQL has better learning effectiveness. The reason is that in our BC system, the choices of which node is the primary, which controller can access to the BC system, and which edge computing server should execute the computation tasks have no relationship with states. Learning which action has better consequence is more efficient than learning which state is better. In dueling DQL, one stream learns state-action value function A(s, a), which is more useful to help the agent make the good choices. Therefore, the learning loss in dueling DQL decreases more fast than natural DQL.</p><p>After the effective training of deep networks, we use them in the following simulations. Fig. <ref type="figure" target="#fig_14">12</ref> shows the relationship between the number of controllers and the system throughput under different schemes. This figure also can be used to show the performance of these schemes in large real SDIIoT environment, where up to 30 controllers are considered in this simulation. As the increase of the number of controllers, the throughput of the BC system decreases. The reason is that more controllers need more computational operations about verifying signatures, MACs. But with the joint consideration of trust features of controllers and nodes, as well as using edge computing servers, our proposed scheme, as shown in the blue curve, has better performance. Thus, we can see our proposed scheme still has better performance in large SDIIoT environment. Fig. <ref type="figure" target="#fig_15">13</ref> shows the relationship between the number of BC nodes and the system throughput under different schemes. As we can see, more nodes lead to the less system through-  put. The reason is that with the increase of the number of nodes, more signatures and MACs need to be verified and generated, which need more CPU cycles so as to decrease the system throughput. But, the performance of our proposed scheme is still the best.</p><p>Fig. <ref type="figure" target="#fig_16">14</ref> shows the relationship between the batch size of a block and the system throughput. The bigger block enables to contain more transactions so as to synchronize more local network events among controllers, which increases the system throughput. As we can see, our scheme also has the better performance. VIII. CONCLUSIONS AND FUTURE WORK In this paper, we proposed a blockchain-based consensus protocol in distributed SDIIoT, along with detailed consensus steps and theoretical analysis, where blockchain acted as a trusted third party to collect and synchronize networkwide views between different SDN controllers. In order to improve the throughput of the blockchain system, we jointly considered the trust features of blockchain nodes and controllers, as well as the computational capability of the system. Accordingly, we formulated view changes, access selection, and computational resources allocation as a joint optimization problem. Due to the fact that it is difficult to solve the joint problem by traditional methods, we proposed a novel dueling deep Q-learning approach to solve this problem. Simulation results showed the effectiveness and the convergence performance of our proposed scheme with different scenarios. How to measure the trust features of nodes and controllers in SDIIoT is very important. Some future works are in progress to solve this problem.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 :</head><label>1</label><figDesc>Fig. 1: The different network structures between traditional scheme and BC-based scheme.</figDesc><graphic coords="4,104.40,74.45,403.21,202.65" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>ζ e . To discretize the values of computation capabilities, ζ e can be partitioned into Y discrete intervals as Y = {Y 0 , Y 1 , ..., Y Y -1 }. The computation resources of edge computing server e at time slot t can be denoted as ζ e (t), t ∈ {0, 1, 2, ..., T -1}. Considering the time correlation of computation state in edge computing server, we use a Markov chain to model the transition of computation state in edge computing server. Based on a certain transition probability, ζ e (t) changes from one state to another. Let ϑ asbs (t) denote the transition probability. The Y × Y computation state transition probability matrix is represented as:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 :</head><label>2</label><figDesc>Fig. 2: The overview of consensus procedures in BC-based consensus protocol between different SDN controllers.</figDesc><graphic coords="5,56.69,256.04,244.80,179.44" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 :</head><label>3</label><figDesc>Fig. 3: The detailed procedures inside the permissioned BC.</figDesc><graphic coords="5,311.98,74.49,247.60,120.97" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 :</head><label>5</label><figDesc>Fig. 5: The workflows of DQL.</figDesc><graphic coords="8,313.04,74.45,241.19,129.60" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Algorithm 1</head><label>1</label><figDesc>Dueling DQL 1: Initialization: Initialize evaluated deep networks with weights and biases set ω. Initialize target deep networks with weights and biases set ω -. 2: for k = 1 : K do3:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>4 :</head><label>4</label><figDesc>while s(t)! = s terminal do 5:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 6 :</head><label>6</label><figDesc>Fig. 6: Dueling architecture.</figDesc><graphic coords="9,325.64,74.45,216.00,111.60" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 7 :</head><label>7</label><figDesc>Fig. 7: The visualized TensorFlow graph in TensorBoard.</figDesc><graphic coords="10,63.16,74.45,230.40,129.59" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 8 :</head><label>8</label><figDesc>Fig. 8: Training curves tracking the throughput of the BC system under different schemes.</figDesc><graphic coords="11,56.69,160.12,272.88,212.40" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 9 :</head><label>9</label><figDesc>Fig. 9: Training curves tracking the learning loss under DuelingDQL-based scheme.</figDesc><graphic coords="11,311.98,176.80,272.80,212.40" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 10 :</head><label>10</label><figDesc>Fig. 10: Training curves tracking the throughput of the BC system under different learning rates.</figDesc><graphic coords="11,311.98,463.59,272.81,212.40" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 11 :</head><label>11</label><figDesc>Fig. 11: Training curves tracking the learning loss of natural DQL and dueling DQL.</figDesc><graphic coords="12,56.69,74.45,272.88,212.40" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig.</head><label></label><figDesc>Fig.11shows the learning loss of natural DQL and dueling DQL. As we can see, the learning loss in dueling DQL decreases more quickly than natural DQL, which indicates dueling DQL has better learning effectiveness. The reason is that in our BC system, the choices of which node is the primary, which controller can access to the BC system, and which edge computing server should execute the computation tasks have no relationship with states. Learning which action has better consequence is more efficient than learning which state is better. In dueling DQL, one stream learns state-action value function A(s, a), which is more useful to help the agent make the good choices. Therefore, the learning loss in dueling DQL decreases more fast than natural DQL.After the effective training of deep networks, we use them in the following simulations. Fig.12shows the relationship between the number of controllers and the system throughput under different schemes. This figure also can be used to show the performance of these schemes in large real SDIIoT environment, where up to 30 controllers are considered in this simulation. As the increase of the number of controllers, the throughput of the BC system decreases. The reason is that more controllers need more computational operations about verifying signatures, MACs. But with the joint consideration of trust features of controllers and nodes, as well as using edge computing servers, our proposed scheme, as shown in the blue curve, has better performance. Thus, we can see our proposed scheme still has better performance in large SDIIoT environment. Fig.13shows the relationship between the number of BC nodes and the system throughput under different schemes. As we can see, more nodes lead to the less system through-</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 12 :</head><label>12</label><figDesc>Fig. 12: The throughput versus the number of controllers under different schemes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig. 13 :</head><label>13</label><figDesc>Fig. 13: The throughput versus the number of BC nodes under different schemes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig. 14 :</head><label>14</label><figDesc>Fig.14:The throughput versus the batch size of a blocks under different schemes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE I :</head><label>I</label><figDesc>The format of a transaction.The number of this transaction in the block.The Signature of this transaction. The MAC of this transaction. Payloads, including local events and OpenFlow commands.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE II :</head><label>II</label><figDesc>The format of a block.</figDesc><table><row><cell>Field</cell><cell>Description</cell></row><row><cell>Version</cell><cell>Block version number.</cell></row><row><cell>Timestamp</cell><cell>Creation time of this block.</cell></row><row><cell>Controller ID</cell><cell>The identifier of this controller.</cell></row><row><cell>Block ID</cell><cell>The identifier of this block.</cell></row><row><cell>Block payload</cell><cell>Transactions in this block (Transaction #1, ..., Transaction #n).</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE III :</head><label>III</label><figDesc>Parameters setting in the simulation. Mcycles The required number of CPU cycles to verify one signature. α 0.05 Mcycles The required number of CPU cycles to verify and generate one MAC.</figDesc><table><row><cell cols="2">Parameter Value</cell><cell>Description</cell></row><row><cell cols="2">θ 8 b 1Mb</cell><cell>The batch size of a block.</cell></row><row><cell>γ</cell><cell>0.9</cell><cell>The discount factor.</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>We thank the reviewers for their detailed reviews and constructive suggestions, which have helped to greatly improve the quality of this article. The work is jointly supported by the Key Program of the National Natural Science Foundation of China (Grant No 61431008), BUPT Excellent Ph.D. Students Foundation (Grant No 2015010100), and China Scholarship Council (Grant No 201706470022).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Industrial internet: A survey on the enabling technologies, applications, and challenges</title>
		<author>
			<persName><forename type="first">J.-Q</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">R</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Ming</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Yan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comm. Surveys &amp; Tutorials</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1504" to="1526" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">When big data meets software-defined networking: SDN for big data and big data for SDN</title>
		<author>
			<persName><forename type="first">L</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">R</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Yan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Net</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="58" to="65" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Software-defined industrial internet of things in the context of industry 4.0</title>
		<author>
			<persName><forename type="first">J</forename><surname>Wan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Shu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Imran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Vasilakos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Sensors Journal</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">20</biblScope>
			<biblScope unit="page" from="7373" to="7380" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A cost efficient design of a multi-sink multi-controller WSN in a smart factory</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">R</forename><surname>Faragardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Fotohi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nolte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rahmani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conf. High Performance Comp. and Comm</title>
		<meeting>Conf. High Performance Comp. and Comm</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Edge computing in the industrial internet of things environment: Software-defined-networks-based edge-cloud interplay</title>
		<author>
			<persName><forename type="first">K</forename><surname>Kaur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Aujla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Rodrigues</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Guizani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comm. Mag</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="44" to="51" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Incremental flow scheduling and routing in time-sensitive software-defined networks</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">G</forename><surname>Nayak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dürr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rothermel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Industrial Informatics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="2066" to="2075" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Network association strategies for an energy harvesting aided super-wifi network relying on measured solar activity</title>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hanzo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in Comm</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="3785" to="3797" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Bitcoin: A peer-to-peer electronic cash system</title>
		<author>
			<persName><forename type="first">S</forename><surname>Nakamoto</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Virtualization for distributed ledger technology (vDLT)</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">R</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Si</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Access</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">28</biblScope>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">The difference between permissionless and permissioned networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Group</surname></persName>
		</author>
		<ptr target="https://medium.com/netis-group-blog/" />
		<imprint>
			<date type="published" when="2018-08">Last Accessed Aug. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Ethereum: A secure decentralised generalised transaction ledger</title>
		<author>
			<persName><forename type="first">G</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Ethereum Project Yellow Paper</title>
		<imprint>
			<biblScope unit="volume">151</biblScope>
			<biblScope unit="page" from="1" to="32" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Blockchains consensus protocols in the wild</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cachin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vukolić</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1707.01873</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Practical byzantine fault tolerance and proactive recovery</title>
		<author>
			<persName><forename type="first">M</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Comp. Sys</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="398" to="461" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Paxos made simple</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Sigact News</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="18" to="25" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Architecture of the Hyperledger blockchain fabric</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cachin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Distributed Cryptocurrencies and Consensus Ledgers</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Dynamic chinese restaurant game: Theory and application to cognitive radio networks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-H</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Wireless Comm</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1960" to="1973" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Learning-aided network association for hybrid indoor LiFi-WiFi systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">C</forename><surname>Leung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hanzo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Veh. Tech</title>
		<imprint>
			<biblScope unit="volume">67</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="3561" to="3574" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Indian buffet game with negative network externality and non-bayesian social learning</title>
		<author>
			<persName><forename type="first">C</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Sys., Man, and Cybernetics: Sys</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="609" to="623" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Permissioned blockchain-based distributed software-defined industrial internet of things</title>
		<author>
			<persName><forename type="first">C</forename><surname>Qiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">R</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Globecom Workshops (GC Wkshps)</title>
		<imprint>
			<date type="published" when="2018">2018. 2018</date>
			<biblScope unit="page" from="1" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Toward dynamic resources management for iot-based manufacturing</title>
		<author>
			<persName><forename type="first">J</forename><surname>Wan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Imran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ahmad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comm. Mag</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="52" to="59" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Hybrid controller for a software-defined architecture of industrial internet lab-scale process</title>
		<author>
			<persName><forename type="first">M</forename><surname>Moness</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Moustafa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-R</forename><forename type="middle">H</forename><surname>Muhammad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-S</forename><forename type="middle">A</forename><surname>Younis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conf. Comp. Engineering and Sys</title>
		<meeting>Conf. Comp. Engineering and Sys</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="266" to="271" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Extending openflow with flexible time-triggered real-time communication services</title>
		<author>
			<persName><forename type="first">L</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gonc ¸alves</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Marau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pedreiras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Almeida</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conf. Emerging Tech. and Factory Automation&apos; 17</title>
		<meeting>Conf. Emerging Tech. and Factory Automation&apos; 17</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A multi-network control framework based on industrial internet of things</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Fu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conf. Net., Sensing, and Control&apos; 16</title>
		<meeting>Conf. Net., Sensing, and Control&apos; 16</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Distributed SDN control: Survey, taxonomy and challenges</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bannour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Souihi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mellouk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Commu. Surveys &amp; Tutorials</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A novel QoSenabled load scheduling algorithm based on reinforcement learning in software-defined energy internet</title>
		<author>
			<persName><forename type="first">C</forename><surname>Qiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">R</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Future Generation Comp. Sys</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Hyperflow: A distributed control plane for openflow</title>
		<author>
			<persName><forename type="first">A</forename><surname>Tootoonchian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ganjali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pro. Conf. Internet Netw. Manag</title>
		<imprint>
			<biblScope unit="page" from="3" to="3" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Onix: A distributed control platform for large-scale production networks</title>
		<author>
			<persName><forename type="first">T</forename><surname>Koponen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Casado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Gude</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stribling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Poutievski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ramanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Iwata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Inoue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hama</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">OSDI</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="1" to="6" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">ONOS: towards an open, distributed SDN OS</title>
		<author>
			<persName><forename type="first">P</forename><surname>Berde</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gerola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Higuchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kobayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Koide</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Lantz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>O'connor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Radoslavov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Snow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conf. Hot Topics in Software Defined Net</title>
		<meeting>Conf. Hot Topics in Software Defined Net</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Sleeping mode of multicontroller in green software-defined networking</title>
		<author>
			<persName><forename type="first">C</forename><surname>Qiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EURASIP Journal on Wireless Commu. and Net</title>
		<imprint>
			<biblScope unit="volume">2016</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">282</biblScope>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A multicontroller load balancing approach in software-defined wireless networks</title>
		<author>
			<persName><forename type="first">H</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Qiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Distributed Sensor Net</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page">454159</biblScope>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Blockchain-based dynamic key management for heterogeneous intelligent transportation systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Lei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Cruickshank</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Asuquo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P A</forename><surname>Ogah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Internet of Things Journal</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1832" to="1843" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Blockchain based intelligent vehicle data sharing framework</title>
		<author>
			<persName><forename type="first">M</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kim</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1708.09721</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">RBFT: Redundant byzantine fault tolerance</title>
		<author>
			<persName><forename type="first">P.-L</forename><surname>Aublin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Mokhtar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Quéma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conf. Distributed Comp. Sys.&apos; 13</title>
		<meeting>Conf. Distributed Comp. Sys.&apos; 13</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="297" to="306" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Making byzantine fault tolerant systems tolerate byzantine faults</title>
		<author>
			<persName><forename type="first">A</forename><surname>Clement</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Alvisi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dahlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Marchetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NSDI</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="153" to="168" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Hyperledger indy</title>
		<ptr target="https://cn.hyperledger.org/projects/hyperledger-indy" />
		<imprint>
			<date type="published" when="2018-08">Aug. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Q-learning</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Watkins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Dayan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine learning</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="279" to="292" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Human-level control through deep reinforcement learning</title>
		<author>
			<persName><forename type="first">V</forename><surname>Mnih</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kavukcuoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Silver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Rusu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Veness</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">G</forename><surname>Bellemare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Graves</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Riedmiller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Fidjeland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ostrovski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">518</biblScope>
			<biblScope unit="issue">7540</biblScope>
			<biblScope unit="page">529</biblScope>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Dueling network architectures for deep reinforcement learning</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schaul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hessel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Van Hasselt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lanctot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">De</forename><surname>Freitas</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1511.06581</idno>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Tensorflow: Largescale machine learning on heterogeneous distributed systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Barham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Brevdo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Citro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Corrado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Devin</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1603.04467</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Project Adam: Building an efficient and scalable deep learning training system</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Chilimbi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Suzue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Apacible</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kalyanaraman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">OSDI</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="571" to="582" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
