<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An Architecture for Real-Time Multimedia Communication Systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Cosmos</forename><surname>Nicolaou</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Laboratory</orgName>
								<orgName type="institution">University of Cambridge</orgName>
								<address>
									<postCode>CB2 3QG</postCode>
									<settlement>Cambridge</settlement>
									<country key="GB">England</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">An Architecture for Real-Time Multimedia Communication Systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">34B84CE7BE1A22E3DC4301C5B6458E41</idno>
					<note type="submission">received October 3 I , 1989; revised November 15, 1989.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T02:30+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A multimedia communication system includes both the communication protocols used to transport the real-time data and also the distributed computing system (DCS) within which any applications using these protocols must execute. The architecture presented attempts to integrate these communications protocols with the D C S in a smooth fashion in order to ease the writing of multimedia applications. Two issues are identified as being essential to the success of this integration: namely the synchronization of related real-time data streams, and the management of heterogeneous multimedia hardware. The synchronization problem is tackled by defining explicit synchronization properties at the presentation level and by providing control and synchronization operations within the DCS which operate in terms of these properties. The heterogeneity problems are addressed by separating the data transport semantics (protocols themselves) from the control semantics (protocol interfaces). The control semantics are implemented using a distributed, typed interface, scheme within the DCS (i.e., above the presentation layer), whilst the protocols themselves are implemented within the communication subsystem. The interface hetween the DCS and communications subsystem is referred to as the Orchestration interface and can he considered to lie in the presentation and session layers.</p><p>A prototype implementation conforming to this architecture is currently under construction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION VERY brief survey of recent work in multimedia</head><p>A communication is presented. Work on the real-time transport of voice and video over digital networks [2], [13]. Some work has also been done on extending the OS1 reference model to cope with multimedia communication[ 141 Work on multiservice networks (MSN) and their associated protocols which are designed with the explicit goal of carrying multiple types of traffic, in particular voice and video, in addition to data. So-called asynchronous transmission networks (ATM)' are the prime candidates for the practical implementation of such networks.</p><p>Multimedia document preparation, presentation and asynchronous (i.e., electronic mail) transport. The media used have primarily been text, graphics, images and voice 1311, VI, [221, [171, [201, 1211.    Control of PABX functions from a computer system. These systems allow application programs to be written Manuscript</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>which control and customize the behavior of the PABX in question <ref type="bibr" target="#b23">[24]</ref>, <ref type="bibr">[9]</ref>, <ref type="bibr">[23]</ref>.</p><p>The integration of voice communication into a digital network and distributed computing system. These systems allow for the implementation of software PABX's, voice editing and storage, and multimedia (text and voice) document preparation, as well as the real-time transport of voice over a digital network <ref type="bibr" target="#b31">[32]</ref>, <ref type="bibr">[7]</ref>, <ref type="bibr" target="#b26">[27]</ref>, <ref type="bibr" target="#b27">[28]</ref>.</p><p>The integration of video into a digital network environment. Magnet in particular has concentrated on the architecture of a high speed integrated local area network capable of transporting real-time voice and video, and on the design and implementation of a special purpose workstation to handle the presentation of these media <ref type="bibr">[15]</ref>.</p><p>Given that the demands made on the DCS by voice are modest compared to those made by video communication, it is not surprising that the greatest level of integration achieved in the above systems is in the areas of voice communication over a digital network and on the control of intelligent PABX's. However, as network <ref type="bibr">[30]</ref>, <ref type="bibr">[25]</ref>, <ref type="bibr">[18]</ref>, <ref type="bibr">[19]</ref> and CPU capacity increase, it is becoming possible to handle video as effectively as voice. These higher capacity networks and CPU's will be able to support multiple voice and video streams simultaneously, thus allowing for more complex communication patterns than single media point-to-point (e.g., phone conversation) communication, as has previously been the case. It will also no longer be necessary to build entire workstations specifically to handle voice and video efficiently, thus leading to a desire for open systems. An open system is one which can be incrementally extended by the addition of new functionality without disturbing the existing system components.</p><p>To summarize, real-time voice and video will be able to coexist within the same system, and if past experience with voice is an accurate guide then there will be a strong desire to integrate voice and video communication into the DCS. The existence of multiple simultaneous data streams gives rise to the need for some means of controlling and synchronizing these multiple streams in order to bring about some meaningful communication, while the drive towards open systems carries with it the requirement to effectively manage heterogeneity. The architecture presented here directly addresses the issues of synchronization and heterogeneity.</p><p>The rest of this paper is structured as follows. A survey of the requirements of real-time multimedia communica-0733-8716/90/0400-0391$01 .OO O 1990 IEEE tion and of the distributed computing system is presented along with a discussion of the interrelationships of these two sets of requirements. The issues of synchronization and heterogeneity are then discussed in detail, followed by a description the architecture itself and its relationship to the OS1 reference model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">REAL-TIME MULTIMEDIA COMMUNICATION</head><p>REQUIREMENTS Real-time voice and video data streams are isochronous in nature, that is, they can be thought of as a stream of finite sized samples which are generated, transmitted and received at fixed time intervals, imposing a set of timing constraints which must never be exceeded. The delay between the generation of successive samples at the stream's source introduces a sampling delay; there is also a transmission delay which refers to the delay between the generation of a sample and the presentation of the same sample at the stream's sink. It is important to realize that the transmission delay must be end-to-end, that is, this delay must be measured from the point at which the sample is generated to the point at which it is presented to the user. The transmission delay consists of the packetization delay, the network transmission delay and the presentation delay. The packetization delay is the time taken to generate a sample and transfer it to the network, the network transmission delay is the time taken to transmit the sample over the network, and the presentation delay is the time spent buffering the sample before presenting it to the user. The packetization delay is probably dominant (in a local area network environment) and the choice of sample size dictates the magnitude of this delay, therefore the sample size must be chosen so as to given an acceptable packetization delay and also to give acceptable network utilization. Therefore, the sample size will also be influenced by the protocol data unit size of the network protocol used to transport it.</p><p>If the source, network and sink ran completely synchronously, without errors, and introduced no queuing delay then the source and sink would always remain in synchronization and there would be no need for buffering at the sink. Unfortunately, there are statistical queuing delays introduced at the source and sink and errors (i.e., lost or corrupted packets) introduced by the network. These delay variations are often referred to as jitter and the sink must implement some buffering scheme to smooth out these delay variations before presenting the samples to the next level up in the protocol stack. There is an additional source of jitter which is due to the clocks at the source and sink running at different rates; any buffering scheme must take account of this clock variation. Samples arriving late, i.e., an excessive amount of jitter (greater than the maximum allowable delay for the stream in question) are treated as network errors; a late packet is about as useful as a lost packet. For this same reason there is no point in using ackowledgment packets to detect lost packets at the source, since a retransmitted packet following a timeout on an acknowledgment will almost certainly ar-rive late and therefore is as good as lost! The contentious issue is the error rate which can be tolerated before a noticeable degradation in quality occurs. For voice an error rate of 1 %, provided each error burst is shorter than 4 ms is often quoted as acceptable, while for video the acceptable error rate is entirely dependent on the coding and compression algorithms used. The Island voice protocol <ref type="bibr" target="#b1">[2]</ref> implements such a buffering scheme for a real-time voice stream; Magnet uses a buffering scheme which is heavily influenced by the coding scheme used for video For any stream, with a given size and a bounded jitter value it is possible to implement a buffering scheme which smooths out the jitter introduced by queueing delays. Given that ATM networks have bounded jitter characteristics the assumption that a bounded jitter parameter is available for a given data path is a reasonable one. Detecting varying clock rates can also be implemented provided a reliable clock is available against which to compare the rate of incoming packets. However, it is unlikely that the clock rates will vary by any noticeable amount given the extreme accuracy of modern quartz oscillators.</p><p>The requirements for a given stream can be represented as set of properties usually referred to as a QOS (quality of service) parameter. The QOS can be used to set up the buffering scheme as required for this stream and also to distinguish the differing requirements of this real-time stream from the requirements of other non real-time connections. This usually takes the form of prioritizing packets for the real-time stream in order to minimize queueing delays and therefore jitter, and also using a light weight protocol which does not use acknowledgment and retransmission techniques. Great care must be taken in the implementation of the communication subystems in order to avoid inadvertently introducing jitter due to the subtle interations of buffer management, layering and scheduling operations. A strong case is made in [33] for avoiding unnecessary multiplexing in a layered protocol stack since this can introduce unacceptable amounts of jitter. The real-time message facility in the DASH operating system</p><p>[3] takes essentially this QOS approach to precisely tailor the behavior of the communications subsystem to the requirements of the user application.</p><p>The DCS as the source and sink of a real-time stream must be able to meet the delay and jitter demands made of it, this implies that a real-time operating system and real-time run time system for applications running over that operating system be used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A . Interrelationship of DCS and Communications Subsystem</head><p>The partitioning of functionality between the DCS and communications subsystem must be such that the communications subsystem has sufficient information on the applications communication requirements to efficiently provide them. The application must have sufficient control over and information on the streams provided to effectively control and manage their synchronization. An ~5 1 . elegant solution exists whereby the communications subsystem is informed of the applications requirements via a QOS parameter, whose properties indicate the nature and requirements of the real-time stream and also the details of when and how the synchronization information required by the application is to be presented to it. The communication subsystem is then able to implement fine level synchronization using internal buffering and flow control mechanisms, whilst at the same time supplying the application with the information it requires, (in the format and at the time it is required) to implement synchronization of both individual and separate but related streams at the (probably coarser) granularity with which the controlling application is best able to manage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="111.">DISTRIBUTED COMPUTING SYSTEM REQUIREMENTS</head><p>A typical DCS will provide a rich set of facilities for implementing distributed applications; including remote procedure call, light-weight thread and synchronization primitives, distributed naming, type checked languages, etc. If an effective level of integration is to be achieved these facilities must be applicable to the multimedia communication subsystem. Therefore, the interface provided by the communication subsystem (i.e., the presentation and session level interfaces) must allow for the efficient implementation of these facilities, in particular light weight threads and their associated synchronization primitives must be efficiently implemented.</p><p>If the DCS is to be used to implement control and synchronization of real-time streams then it must have sufficient information on which to base its decisions. In particular an application executing within the DCS must have sufficient information to determine if related streams are synchronized, and if not, to take corrective action. Ideally, the making and acting on of these decisions should be completely integrated with the run-time system. Also any control operations applied to the real-time streams must be synchronized to them, implying that the streams must be structured so as to allow for this synchronization.</p><p>A suitable set of control and synchronization primitives need to be defined which do not introduce unacceptable amounts of jitter, yet provide a concise and powerful programming abstraction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. PRESENTATION LEVEL SYNCHRONIZATION</head><p>It is useful to examine the likely uses of synchronization in order to more fully understand the nature of the synchronization decisions and the ensuing actions required.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Lip-Synching</head><p>Lip-synching refers to the synchronization of spoken voice with the movement of the speaker's lips. This synchronization can be (as it is for film and domestic VCR recordings) achieved mechanically by recording the voice and video on the same physical medium and then using truly concurrent and separate play back equipment for voice and video. For real-time transmission completely synchronous channels may be used for voice and video, as used for television broadcasts for instance. Neither of these approaches is feasible for computer communication over a digital network, since the network and DCS will inevitably introduce some jitter.</p><p>It is possible to multiplex the voice and video samples over a single session layer association; however, this approach has several disadvantages. The primary disadvantage is that even though voice and video have very different characteristics (and therefore QOS properties) they must be transmitted over the same lower level association with a single QOS parameter. This multiplexing onto a single lower level association leads to inefficiencies resulting from the inability to make use of stream specific information. In particular, the job of reducing jitter is very much harder for two independent streams multiplexed onto a single association than if these streams were kept separate. A secondary problem is that the complexity of the source and sink will be considerably increased if, as is highly likely, different, possibly variable bandwidth, codings are used for the voice and video components of the same multiplexed stream. Finally, this scheme dictates that the voice and video originate from a single point.</p><p>An alternative is to use separate session layer associations for the voice and video streams, this scheme allows for separate voice and video sinks, but does require some means for maintaining the synchronization of these related streams. Given that bounded jitter is achievable it is possible to construct a buffering scheme which maintains the synchronization of the individual streams over relatively short (minutes) periods of time. It is then left to the application to ensure that these streams remain synchronized with respect to each other over longer periods of time. Two pieces of information are required to implement this synchronization.</p><p>The rate of change of the jitter per sample over the last n samples.</p><p>The jitter for the current or most recent sample. The first value enables the application to detect if the stream is losing synchronization and to take appropriate corrective action, the second provides some positive feedback enabling the application to determine if its actions are having any effect. Corrective action can take the form of modifying the QOS properties for the stream in question, requiring that the communication subsystem allow these properties to be dynamically changed.</p><p>It is also possible to use this information to determine if the source and sink clocks are running at the same rate. However, a common clock, which is known to be correct, is required to determine that the source and sink clocks are running at the correct, rather than the same, rate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. User Interface Management Systems and Positive Feedback</head><p>There is a strong drive within the User Interface Management System (UIMS) research community towards more concurrent user interfaces and UIMS's which support this concurrency [12]. This drive is motivated by the general belief that concurrent input is a natural way for users to interact with computers, [6], [5], <ref type="bibr">[IO]</ref> and by the desire to build direct manipulation interfaces as described by Schneiderman <ref type="bibr" target="#b25">[26]</ref>. Direct manipulation interfaces are characterized by concurrent input and the provision of timely positive feedback in response to user actions. Hudson <ref type="bibr">[ l l ]</ref> and Tanner <ref type="bibr" target="#b28">[29]</ref> explore in detail the demands made on a UIMS by this type of user interface. An important requirement is that the feedback provided should appear instantaneous to the user, thus imposing a maximum response time on the order of 10-40 ms (human perception threshold time).</p><p>A central aim of multimedia communication is to allow a single user to use a computer as a tool for communication with several other, physically distant, users. This means that the next generation of UIMS which will implement user interfaces to such multimedia communication must extend their view of human computer interaction beyond the current situation of a single user interacting with a single computer. Therefore, the UIMS must cope with multiple sources of human input and the very much larger class of errors introduced by the presence of a network and distribution. These errors include communication errors due to the network itself and partial system failures which occur when part, but not all, of the distributed application managing the communication fails.</p><p>If a direct manipulation user interface is to be implemented then feedback must be provided not only in response to the local users actions, but also in response to remote users actions and in response to errors. The error feedback generated must reflect the error in some meaningful fashion to the user, thus avoiding the situation where a user is left to stumble across the error in the normal course of his or her communication.</p><p>As a simple example consider the situation where a user is running the X window system. This user has a terminal connection to a remote machine, if the remote machine crashes no feedback is given, rather the user is left to determine that the remote machine crashed based on its lack of response. This is largely a result of the fact that the communications protocol used does not generate any indication that it is having difficulty communicating with the remote machine. This may not in itself seem a great hardship for the user, however if more complex conferencing applications which support communication with multiple users using multiple media are to be built, then the provision of positive feedback becomes essential.</p><p>It is useful to think of these errors as synchronization points, since every time such an error occurs synchronization is lost and some action must be taken to resynchronize or to abandon communication in some graceful manner. It is also useful to consider all exceptional, though not necessarily erroneous, events as synchronization points. For instance opening or closing a real-time connection may generate synchronization events when the first and last (respectively) samples are received. This allows for related streams to be synchronized with respect to each other whenever such a synchronization point is reached. In the lip-synching example the controlling application may wish to wait until both streams reach their last sample synchronization point before tidying up the screen display. Similarly, if one of the streams stops due to some error then the application may wish to stop the related stream and display some meaningful message, or take some action to restart the stream. These synchronization points essentially define the points at which the controlling application should consider taking some action, i.e., they are events and actions which warrant some form of response.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. A Synchronization Scheme</head><p>This section presents a scheme for implementing the three types of essential synchronization which have been identified by the previous examples. The first, referred to as isochronous synchronization is concerned with maintaining the real-time synchronization of related streams. The second and third deal with synchronization after some error and after some well-defined point has been reached; both of these can be considered as exceptional and as warranting some form of feedback. Note that the loss of isochronous synchronization is itself an exceptional event requiring some resynchronization action.</p><p>Real-time multimedia streams are considered as having a two-level structure. At the lowest level such a stream is considered to be an ordered sequence of variable, but finite, size samples which are expected to be generated, transmitted and presented at fixed time intervals, i.e., they are isochronous. These samples are referred to as physical synchronization frames (PSF). At the next level the stream is structured as an ordered sequence of logical synchronization frames (LSF), each of which consists of a number of physical synchronization frames. PSF's are intended as the unit of synchronization within the communications subsystem, whereas LSF's are the unit of synchronization for the controlling application. It is possible to have a one-to-one relationship between PSF and LSF; the level of indirection provided 'by this two level structure allows the application to specify the synchronization granularity which it can best handle. The actual values used will be highly specific to the application, DCS, communications subsystem, and network being used, with the restriction that the source and sink within the communication subsystem use the same PSF. Ideally, the LSF should be a QOS property, thus allowing the application to specify the unit of synchronization it requires in a convenient manner.</p><p>Fig. <ref type="figure">1</ref> illustrates how this synchronization scheme would work for a video stream which the application wishes to control at a video frame by video frame level, whilst the video stream is implemented using a protocol which transmits four samples per frame. The upward arrows indicate synchronization points at both levels in the stream, though only the synchronization points occurring at LSF boundaries are communicated to the controlling application.</p><p>Given this synchronization scheme, it is then necessary to define how the synchronization points are indicated to the controlling application, how operations on these streams are synchronized with respect to these streams, and how synchronization information gathered by the communications subsystem is presented to the controlling application.</p><p>The mechanism used to indicate synchronization points represents an asynchronous flow of information upwards from the communication subsystem to the application, the mechanism chosen must be sufficiently efficient so as not to deter application writers from using it. There are two primary candidates for this asynchronous communication, namely upcalls and event queues: the upcall mechanism is to be preferred since it can be easily used to implement an event queue system, while the converse is not true.</p><p>Each stream will have an associated set of stream specific operations. These operations must be synchronized with respect to the streams to which they apply, this synchronization is defined in terms of the streams LSF's. In particular operations only take effect at LSF boundaries, and may be delayed up to some maximum number of such boundaries. These operations are implicitly timed, that is if an operation does not take effect within the stated number of LSF's then the communications subsystem must report a timeout error. The benefits of specifying this synchronization relationship is that both the application writer and the stream implementor have a precise synchronization model within which to work, thus eliminating potential confusion.</p><p>The following figure (Fig. <ref type="figure">2</ref>) shows how a "stop" operation would be synchronized with respect to the video stream used in the previous figure. The completion of the operation can be indicated in either of two ways: the operation in question is blocked until completion, alternatively the operation may return immediately (i.e., is not blocked) and an explicit synchronization event will be generated on its completion. Both blocking and nonblocking modes are illustrated below.</p><p>The synchronization information gathered by the communication subsystem needs to be made available to the controlling application in two distinct situations.</p><p>At regular intervals to monitor the current state. At irregular intervals, usually in response to some other synchronization event.</p><p>The first situation can be dealt with by defining these regular intervals as synchronization points and passing the data as arguments to an upcalled procedure. The second situation is best catered for by a procedural interface, since the application may wish to access this information from within an active upcall.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Synchronization Summary and Complete Example</head><p>We now have a two-level synchronization scheme with upcalls occurring at synchronization points in the upper of the two levels. A procedural interface is provided for setting and modifying QOS properties and for obtaining synchronization information (this information can also be obtained by an upcall).</p><p>Consider a video editor which allows the user to play back stored video in real-time as well as fast and slow rates, and also provides a cut-and-paste facility for editing voice and video segments. In order to implement cut-andpaste some means of delimiting the segment to be cut and a means of indicating the location to paste to are required. A reasonable approach is to accompany the play back of video with some kind of "time line" or "scroll bar" as a visible cue on the current position in the video segment. This time-line needs to be updated in time with the associated video. The QOS properties can be used to define an isochronous upcall at some rate, this upcall can monitor the synchronization of the stream being played and update the time line. If the stream is found to be losing synchronization then this upcall can take corrective action; this may involve modifying the QOS properties or providing some feedback to the user (e.g., making the time-line flash). If the video is played back at a different rate, then since the synchronization points are defined in LSF's, the upcall will be called at the new rate, and the time-line will be automatically updated at the new rate. If an error occurs on the play back stream then a separate upcall will be made which can stop the time-line and inform the user of the error. The following section suggests how this scheme can be integrated into the DCS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Integrating Stream Synchronization into the DCS</head><p>Concurrent activities typically require synchronization points, each such point is represented as a synchronization variable. Such a variable, if set, indicates that the synchronization point has been reached, if unset then this point has not been reached. Synchronization variables (SV) are stream specific and are represented as a triple (stream, synchronization point, value). Three primitives are defined which operate on these variables.</p><p>WaitForSV ( SVexpr, TimeOut ) wait for the expression to become true.</p><p>SignalSV( SV ) set the synchronization variable specified.</p><p>TestSV ( SV ) return the value of the synchronization variable specified.</p><p>SV is a single synchronization variable. SVexpr is an expression involving any number of SV's separated by one of the following operands:</p><p>SVAND boolean and of the operand SV's, SVOR boolean inclusive or of the operand SV's. The WaitForSV will return an indication of which SV's were set and thus cause it to return, a timeout can also be specified which if exceeded will cause WaitForSV to return with a timeout indication. WaitForSV will typically be called by controlling threads within the application, whilst SignalSV will be called from within an upcalled procedure. If an event queue model is implemented, then the central loop waiting on the queue will call SignalSV in response to receiving the associated events.</p><p>The DCS may provide some automatic means of generating a large amount of the interface code required to implement this scheme based on information given in the specification of a stream (see below). The design of the run-time system must be such so as not to introduce unacceptable amounts of jitter, therefore, the run-time scheduler may wish to base its scheduling decisions on the QOS properties whose synchronization variables are being signaled; the scheduling of upcalls should be similarly influenced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. MANAGING HETEROGENEITY</head><p>The desire for open systems carries with it a requirement to effectively manage heterogeneity. This problem is particularly acute for multimedia systems in which there may exist many different pieces of hardware capable of performing the same function. The application writer needs to access the functionality provided by the hardware without being overly burdened with the details and differences of the particular pieces of hardware being used. For instance a program to manage a voice conversation using a specially built digital phone should not need to be modified to work with a software phone implemented using a microphone and speaker.</p><p>The approach taken treats any piece of hardware or software which can generate real-time multimedia streams as a device. Each such device has a strongly typed interface and an associated implementation. There is no checking to ensure that the interface and implementation are consistent with respect to each other. The interfaces are written in a Device Specification Language (DSL), in which an interface has two components: a stream component which specifies the real-time streams and an operations component which specifies the operations on these streams. The stream components represent the protocols which this device can use, while the operations component represents the control interface to the device and its streams.</p><p>The interaction between interfaces is based on the client/server model. A server exports the interfaces it supports and a client must import a previously exported interface in order to use it. An interface is location specific; thus an instance of a server at a given location exports an interface and a client attempts to import an interface exported by a particular location. In a multimedia system which is used to implement user communication, location transparency is of little use, since a person, unlike a replicated software server, cannot be in two places at once. Therefore, import requests may specify a particular location, usually this will be the current location of the user(s). Note that if location transparency is required a logical location such as "network" may be specified. This scheme requires the existence of a run-time binder to manage the export and import of interfaces, this binder is called the DSL Trader.' A server exports its interface to the DSL Trader and a client imports an interface from the Trader, in this way the Trader is solely responsible for matching imports with exports. The Trader is at liberty to use any algorithm it choses to match import and export requests, and it is the properties of the algorithm chosen which allow for the effective management of heterogeneity in this architecture. The two essential components of the algorithm used are described below.</p><p>A given interface may have multiple implementations, the Trader choses the implementation exported by the location specified in the import request.</p><p>If an exact interface match cannot be found, the Trader searchs its export database for different, but functionally equivalent, interfaces exported by the location specified in the import request.</p><p>The first component allows different hardware and software to provide the same functionality without the importer being aware of these differences. The second component uses a set of rules to identify functionally equivalent interfaces and to match an import to a functionally equivalent export if no exact match exists. The rules for functional equivalence are described in detail in the section on "Functional Equivalence." A simple example will illustrate the usefulness of this algorithm. Consider the situation where a given location exports a video phone interface, this location clearly has the capability for point-to-point voice and video connection. If an import request is made on this location for a simple pointto-point phone conversation then the import should succeed since the location in question supports a superset of the required functionality.</p><p>Finally, DSL provides a mechanism for aggregating interfaces to build compound devices. This facility is provided to allow the reuse of existing interfaces and implementations in order to provide a much shorter development time for new and experimental applications.</p><p>The following sections examine the interface structure,</p><p>'The term trader is taken from the A N S A [ I ] project's terminology, and refers to an extended name server which manages typed interfaces rather than uninterpreted strings.</p><p>functional equivalence, and aggregation mechanisms in greater detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A . DSL Streams: Plugs and Sockets</head><p>A DSL stream as specified in an interface is a stream end point, i.e., it can be the source or sink of a stream. For this reason the DSL stream component consists of plugs (stream sources) and sockets (stream sinks). A plug must be connected to a socket in order to create a stream over which data can flow. A plug or socket is named and a name can be used once within the same interface. Each plug or socket is typed by a stream type. A stream type consists of a stream type name and the following properties.</p><p>QOS properties supported, including the format of the stream synchronization information.</p><p>The synchronization points supported, this will be a list of upcalls and their associated arguments which can be registered with this stream. Each such point will have a synchronization variable associated with it.</p><p>Stream type checking is based solely on the name given to the stream type. Therefore, for a stream to be successfully created the plug and socket must be of the same stream type, that is the stream types they specify must have the same name. Fig. <ref type="figure">3</ref> shows a stream of type "VideoStream," created from a plug and socket of the same stream type; the plug is called "Camera" and the socket "Display." The stream, plug, and socket types are given within their representative shapes, with their names appearing below the shapes.</p><p>If the stream types of the plug and socket do not match it may be possible to use a translator interface, this is simply an interface with a socket of the same stream type as the original plug and a plug of the same stream type as the original socket. Translators are found by interrogating the DSL Trader. Fig. <ref type="figure">4</ref> shows an audio stream created using a translator. In this case the end point plug is of type "Audio A-Law'' while the end point socket is of type "Audio Mu-Law"; the translator has a socket of type "Audio A-Law'' which is directly connected to a plug of type "Audio Mu-Law . ' '</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. DSL Operations</head><p>The operations component contains all the operations available for controlling the streams supported by this interface as well as a small set of management operations supported by all interfaces. Each operation is named, and a name can only occur once in the same interface. The management operations are present to provide a uniform means of managing stream connections across all devices, this includes the establishment of connections and access and manipulation of the QOS properties. The remaining operations are entirely interface specific, an operation takes a set of arguments and returns a set of results.</p><p>Sample interfaces for simple camera and display devices are given below in Fig. <ref type="figure" target="#fig_0">5</ref> . The syntax used is only intended to give a general view of the structure of an interface; it is in no way fully defined or finalized. For sim- The synchronization points defined for the video strean will be generated in response to the corresponding CameraDev operations, or error, the Stop operation takes a flag stating whether blocking or nonblocking synchronization is required. The physical camera device may have pause and stop controls which can also generate these synchronization points.</p><p>The set of management operations shown in the examples is not complete; work is underway to determine a full set of such operations and to automate their use to the greatest degree possible. This automation may take the form of a set of library procedures. The provider of an interface implementation must implement the management operations along with all the other operations defined in the interface, again a library of common implementations will ease this task.</p><p>The following pseudocode (Fig. <ref type="figure" target="#fig_1">6</ref> ) illustrates how the above interfaces could be used to realize a unidirectional video stream between two specified locations. The above example gives a general feel of the style of programming required to drive DSL devices, more practical work is required to fully implement this programming model. The mechanism used to listen for user input depends on the input/output system being used; the essential point is that the uniform synchronization mechanism allows the programmer to treat the video stream as structured, without regard to how this structure is imposed. Note that the user who has access to the camera is not necessarily the same user who has access to the controlling application's input. In this example, the user receiving the video stream (i.e., the display end) can have access to this input and thus suspend, resume, or stop the video stream, as a result both users have access to the same control interface.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Functional Equivalence</head><p>Functional equivalence is essentially the same as the notion of conformance as used in the Emerald system, [4] with a simple extension to deal with the streams component of a DSL interface. Conformance is preferred to inheritance as used in the Smalltalk system since it expresses a relationship between interfaces, while inheritance is a relationship between implementations. Informally, the rules for functional equivalence in DSL are as follows.</p><p>An interface S is functionally equivalent to an interface T( written S I T ) if an only if the following conditions hold.</p><p>1) S provides at least the plugs and sockets of T ( S may have more).</p><p>2) For each plug or socket in T, the corresponding plug or socket in S is of the same stream type.</p><p>3) S provides at least the operations of T ( S may have more).</p><p>4) For each operation in T , the corresponding operation in S has the same number of arguments and the same number of results.</p><p>5) The types of the arguments of T's operations conform to the types of the arguments of the corresponding operation in S (i.e., the arguments must conform in the opposite direction to the interfaces).</p><p>If these conditions are met then an import request for interface T can be satisfied with an export of interface S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Aggregation</head><p>The aggregation facility allows compound interfaces to be constructed from existing interfaces, a compound interface consists of a set of subinterfaces plus a streams and operations component. The functional equivalence rules given above apply to simple interfaces, i.e., interfaces which do not contain any subinterfaces. The rules for functional equivalence can be extended to cope with compound interfaces as follows.</p><p>A compound interface S is functionally equivalent to a compound interface T if the following holds.</p><p>1) The streams and operations component of S are functionally equivalent to the streams and operations component of T, as given above.</p><p>2) For each subinterface in T there is a corresponding subinterface in S which is functionally equivalent to the subinterface in T.</p><p>3) Apply rules 1) and 2) recursively for all the subinterfaces in T and corresponding subinterface is S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. THE ARCHITECTURE</head><p>This section places the previous discussions on synchronization and managing heterogeneity into a uniform architectural model, thus providing a consistent and precise design framework within which the system designer and application writer can work.</p><p>A layered approach is taken to decomposing this architecture into its functional components, three such layers exist as shown in Fig. <ref type="figure" target="#fig_2">7</ref>.</p><p>The multimedia mechanism (MMM) layer includes the generation, transport and presentation of real-time multimedia streams. The transport function has previously been referred to as the communications subsystem. The interface to this transport component is specified by the management operations in a DSL interface. The generation component deals with the generation of stream samples, i.e., physical synchronization frames, whilst the presentation component accepts PSF's and presents them to the user. The generation and presentation components present two interfaces, one to the transport function and one to the Orchestration layer. The interface to the transport function is in terms of PSF's and is provided for efficiency reasons, in particular to minimize jitter. The use of this "sideways" interface must be under the control of the Orchestration layer, thus preserving the layering of con-'Conformance as applied to the data types of the arguments is identical to that used in Emerald.  The Orchestration layer performs the two distinct functions of interfacing the application to the MMM and of implementing the heterogeneity management mechanism. The first function requires the implementation of the synchronization scheme presented above while the second requires the implementation of DSL and the DSL Trader. DSL is the glue that binds the functional components of the architecture together, that is, it is used to specify all the interfaces present in the system.</p><p>Finally, the application layer, previously referred to as the distributed computing system, contains the controlling application. It can now be seen that the Orchestration layer provides the integration between the DCS and communications subsystem. This is illustrated in Fig. <ref type="figure">9</ref>. Fig. <ref type="figure">10</ref> shows the relationship between this multimedia architecture and the OS1 reference model. There are two main differences between the two, first, the multimedia architecture layers control interfaces whilst the OS1 reference model layers control and data interfaces. Also, the two take a radically different approach to managing heterogeneity, the OS1 reference model assumes that interworking is managed at the lower levels of the model and that the higher levels need not be aware of any lower level differences, whereas the multimedia architecture provides explicit architectural support for managing heterogeneity and this management is based on out-of-band control techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. WORK PLAN</head><p>Work is currently in progress to implement this multimedia architecture. This work includes extending a prototype multiservice protocol suite (the MSNL protocol suite) [16] to implement the QOS, synchronization data gathering and notification functions described above. This will then be integrated into a prototype DCS, namely the ANSA [ 11 testbench; this system provides light-weight threads, RPC and distributed naming over a variety of operating systems. Both MSNL and the ANSA testbench run over the UNIX'" operating system. MSNL runs over both Ethernet and the Cambridge Fast Ring local area networks. Some applications will be built to test the utility of this architecture, these could include a simple video phone and associated call management, simple voice and video recording, and playback.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. SUMMARY</head><p>The issues involved in providing real-time multimedia communication have been discussed in detail. Extensions to existing communications subsystems and distributed computing systems have been suggested which will enable them to better meet the requirements of multimedia communication. In particular, solutions to the problems of synchronization and heterogeneity have been described in detail. These solutions have been incorporated into an architecture which provides a set of design rules and guidelines within which both the system implementor and application writer can work. The interfaces specified by the architecture are all described using an interface specification language (DSL).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>ENDFig. 5 .</head><label>5</label><figDesc>Fig. 3 . Video stream</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>--Fig. 6 .</head><label>6</label><figDesc>Fig. 6 . Use of camera and display devices.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Architectural layers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Fig. 9. Orchestration layer integration</figDesc></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Cosmos Nicolaou was born in London, England, on July 13, 1965. He received the B.Sc. degree in computer science from University College, London, in 1986. Since January 1987, he has been working towards the Ph.D. degree in computer science at the University of Cambridge, Computer Laboratory. His dissertation work has centered on the integration of multimedia communication into the general purpose distributed computing environment.</p><p>He is currently working for Architecture Proiects Management Limited as part of the Esprit 11,-Integrated Systems Aichitecture (ISA) project, while completing the Ph.D. degree. This work is concerned with extending the ISA project's testbench software to fully support multimedia devices and protocols. His research interests include distributed operating systems and languages, computer networking. and realtime voice, and video communications.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">ANSA Reference Manual, Release 01</title>
		<author>
			<persName><surname>Ansa</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989-03-00">00 Mar. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Protocols for real time voice communication on a packet local network</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ades</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Want</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Calnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Con&amp; Commun</title>
		<meeting>Int. Con&amp; Commun<address><addrLine>Toronto, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986-06">June 1986</date>
			<biblScope unit="page" from="525" to="530" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">IEEE JOURNAL ON SELECTED AREAS IN COMMUNICATIONS</title>
		<imprint>
			<biblScope unit="volume">X</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1990">APRIL 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A software architecture for network communication</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">N</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName><forename type="middle">E</forename><surname>Hutchinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jul</surname></persName>
		</author>
		<author>
			<persName><surname>Levy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Eigrh Inr. Conf. Disrrihured Compur. Svsr</title>
		<meeting>Eigrh Inr. Conf. Disrrihured Compur. Svsr</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1986-09">June 1988. Sept. 1986</date>
		</imprint>
	</monogr>
	<note>OOPSLA&apos;86 Proc.</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Issues and techniques in touchsensitive tablet input</title>
		<author>
			<persName><forename type="first">W</forename><surname>Buxton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rowley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH&apos;85</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1985-07">July 1985</date>
			<biblScope unit="page" from="215" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A study in two-handed input</title>
		<author>
			<persName><forename type="first">W</forename><surname>Buxton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. HC1&apos;86 Con</title>
		<meeting>HC1&apos;86 Con<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1986-04">Apr. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">ISLAND: A distributed multimedia system</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Calnan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987-11">Nov. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Multimedia document presentation, information extraction, and document formation in MINOS: A model and a system</title>
		<author>
			<persName><forename type="first">S</forename><surname>Christodoulakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Theodoridou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Papa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pathria</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Oficelnform. Syst</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="345" to="383" />
			<date type="published" when="1986-10">Oct. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The modular integrated communications environment (MICE): A system for prototyping and evaluating communications services</title>
		<author>
			<persName><forename type="first">G</forename><surname>Herman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ordun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Riley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Woodbury</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bell Commun. Res</title>
		<imprint>
			<date type="published" when="1987-03">Mar. 1987</date>
			<pubPlace>Morristown, NJ</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Supporting concurrency, communication, and synchronization in human-computer interaction-the sassafras UIMS</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graphics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="179" to="210" />
			<date type="published" when="1986-07">July 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">UIMS support for direct manipulation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hudson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title/>
		<author>
			<persName><surname>Graphics</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987-04">Apr. 1987</date>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="120" to="124" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Reference models, window systems and concurrency</title>
		<author>
			<persName><forename type="first">K</forename><surname>Lantz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">P</forename><surname>Tanner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Binding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-T</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dwelly</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Comput</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName><surname>Graphics</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987-04">Apr. 1987</date>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="87" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">MAGNET: Columbia&apos;s integrated network testbed</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Lazar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Patir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Takahashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">El</forename><surname>Zarki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J . Select. Areas Commun</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="859" to="871" />
			<date type="published" when="1985-11">Nov. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A reference model for integrated local area networks</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Lazar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Mays</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hori</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Inr. Conf. Commun., Toronto</title>
		<meeting>Inr. Conf. Commun., Toronto</meeting>
		<imprint>
			<date type="published" when="1986-06">June 1986</date>
			<biblScope unit="page" from="531" to="536" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Protocol design for high speed networks</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Lazar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>White</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mcauley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">paper, Cent. Telecommun. Res., Columbia Univ</title>
		<imprint>
			<date type="published" when="1987-07">July 1987. Sept. 1989</date>
			<pubPlace>New York</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Univ. Cambridge Comput. Lab.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. dissertation</note>
	<note>Packetized video on MAGNET</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Agora-an experiment in multimedia message systems</title>
		<author>
			<persName><forename type="first">N</forename><surname>Naffah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Karmouch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Newman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comput</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="56" to="66" />
			<date type="published" when="1986-05">May 1986. Mar. 1989</date>
		</imprint>
		<respStmt>
			<orgName>Univ. Cambridge Comput. Lab.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep</note>
	<note>Fast packet switching for integrated services</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The QPSX man</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Newman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">L</forename><surname>Budrikis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Hullet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Commun. Mag</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">26</biblScope>
			<biblScope unit="page" from="20" to="28" />
			<date type="published" when="1988-04">Apr. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Usage patterns in an integrated voice and data communications system</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">T</forename><surname>Nicholson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Ofice Inform. Syst</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="78" to="86" />
			<date type="published" when="1985-07">July 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">CCWS: A computer-based, multimedia information system</title>
		<author>
			<persName><forename type="first">A</forename><surname>Poggio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Garci Luna Acheves</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J</forename><surname>Craighill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Moran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Aguilar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Worthington</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hight</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Compur</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="92" to="103" />
			<date type="published" when="1985-10">Oct. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">An experimental multimedia mail system</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Postel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">G</forename><surname>Finn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Reynolds</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. O@ce Inform. Syst</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">I</biblScope>
			<biblScope unit="page" from="63" to="81" />
			<date type="published" when="1988-01">Jan. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A user programmable telephone switch</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">E</forename><surname>Redman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">paper, Bell Commun. Res</title>
		<imprint>
			<date type="published" when="1987-04">Apr. 1987</date>
			<pubPlace>Morristown, NJ</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">DynaMICE: A direct manipulation graphics interface for controlling advanced telecommunications services</title>
		<author>
			<persName><forename type="first">R</forename><surname>Root</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Hawley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bell Commun. Res</title>
		<imprint>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
	<note>NJ</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">FDDI-A tutorial</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">E</forename><surname>Ross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Commun. Mug</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="10" to="17" />
			<date type="published" when="1986-05">May 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Direct manipulation: A step beyond programming languages</title>
		<author>
			<persName><forename type="first">B</forename><surname>Schneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Cornput</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="57" to="69" />
			<date type="published" when="1983-08">Aug. 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Adding voice to an office computer network</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Swinehart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Stewart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Ornstein</surname></persName>
		</author>
		<idno>Rep. CSL-86-1</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE GLOBECOM 1983</title>
		<meeting>IEEE GLOBECOM 1983</meeting>
		<imprint>
			<date type="published" when="1983-11">Nov. 1983. June 1986</date>
		</imprint>
		<respStmt>
			<orgName>Xerox Palo Alto Research Center Tech</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">An experimental environment for voice system development</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Swinehart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Terry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">T</forename><surname>Zellweger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Knowledge Eng</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="39" to="48" />
			<date type="published" when="1987-02">Feb. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Multi-thread input</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">P</forename><surname>Tanner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Graphics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="142" to="144" />
			<date type="published" when="1987-04">Apr. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The design of a ring communication network</title>
		<author>
			<persName><forename type="first">S</forename><surname>Temple</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Tech. Rep</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<date type="published" when="1984-01">Jan. 1984</date>
		</imprint>
		<respStmt>
			<orgName>Univ. Cambridge Comput. Lab.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. dissertation</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Diamond a multimedia message system built upon a distributed architecture</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Compur</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1" to="31" />
			<date type="published" when="1985-11">Nov. 1985</date>
		</imprint>
	</monogr>
	<note>Forsdick er a l .</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Reliable management of voice in a distributed system</title>
		<author>
			<persName><forename type="first">R</forename><surname>Want</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Univ. Cambridge Comput. Lab</title>
		<imprint>
			<date type="published" when="1988-07">July 1988</date>
		</imprint>
	</monogr>
	<note type="report_type">Ph.D. dissertation</note>
	<note>Tech. Rep. 114</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Layered multiplexing considered harmful</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Tennenhouse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Protocols for High Speed Networks</title>
		<imprint>
			<date type="published" when="1989-05">May 1989</date>
		</imprint>
	</monogr>
	<note>IFIP WG6.1/6.4 Workshop</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
