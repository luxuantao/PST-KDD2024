<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient Authentication from Hard Learning Problems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Eike</forename><surname>Kiltz</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Krzysztof</forename><surname>Pietrzak</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">CWI</orgName>
								<address>
									<addrLine>Amsterdam 3 UC San Diego 4 UC</addrLine>
									<settlement>Los Angeles</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Cash</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Abhishek</forename><surname>Jain</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Daniele</forename><surname>Venturi</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Sapienza University of Rome</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">R</forename><forename type="middle">U</forename><surname>Bochum</surname></persName>
						</author>
						<title level="a" type="main">Efficient Authentication from Hard Learning Problems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">6404849128D0D8F6467A9AD91CCB61A0</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We construct efficient authentication protocols and messageauthentication codes (MACs) whose security can be reduced to the learning parity with noise (LPN) problem.</p><p>Despite a large body of work -starting with the HB protocol of Hopper and Blum in 2001 -until now it was not even known how to construct an efficient authentication protocol from LPN which is secure against man-in-the-middle (MIM) attacks. A MAC implies such a (two-round) protocol.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Authentication is among the most basic and important cryptographic tasks. In the present paper we construct efficient (secret-key) authentication schemes from the learning parity with noise (LPN) problem. We construct the first efficient message authentication codes (MACs) from LPN, but also simpler and more efficient two-round authentication protocols that achieve a notion called active security. Prior to our work, the only known way to construct an LPN-based MAC was via a relatively inefficient generic transformation <ref type="bibr" target="#b16">[17]</ref> (that works with any pseudorandom generator), and all interactive LPN-based protocols with security properties similar to our new protocol required at least three rounds and had a loose security reduction. Our constructions and techniques diverge significantly from prior work in the area and will hopefully be of independent interest.</p><p>The pursuit of LPN-based authentication is motivated by two disjoint concerns, one theoretical and one practical. On the theoretical side, the LPN problem provides an attractive basis for provable security <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b26">27]</ref>. It is closely related to the well-studied problem of decoding random linear codes, and unlike most number-theoretic problems used in cryptography, the LPN problem does not succumb to known quantum algorithms. On the practical side, LPNbased authentication schemes are strikingly efficient, requiring relatively few bit-level operations. Indeed, in their original proposal, Hopper and Blum <ref type="bibr" target="#b17">[18]</ref> suggested that humans could perform the computation in their provably-secure scheme, even with realistic parameters. The efficiency of LPN-based schemes also makes them suitable for weak devices like RFID tags, where even evaluating a blockcipher may be prohibitive.</p><p>Each of our theoretical and practical motivations, on its own, would be sufficiently interesting for investigation, but together the combination is particularly compelling. LPN-based authentication is able to provide a theoretical improvement in terms of provable security in addition to providing better efficiency than approaches based on more classical symmetric techniques that are not related to hard problems. Usually we trade one benefit for the other, but here we hope to get the best of both worlds.</p><p>Before describing our contributions in more detail, we start by recalling authentication protocols, the LPN problem, and some of the prior work on which we build.</p><p>Authentication protocols. An authentication protocol is a (shared-key) protocol where a prover P authenticates itself to a verifier V (in the context of RFID implementations, we think of P as the "tag" and V as the "reader"). We recall some of the common definitions for security against impersonation attacks. A passive attack proceeds in two phases, where in the first phase the adversary eavesdrops on several interactions between P and V, and then attempts to cause V to accept in the second phase (where P is no longer available). In an active attack, the adversary is additionally allowed to interact with P in the first phase. The strongest and most realistic attack model is a man-in-the-middle attack (MIM), where the adversary can arbitrarily interact with P and V (with polynomially many concurrent executions allowed) in the first phase.</p><p>The LPN problem. Briefly stated, the LPN problem is to distinguish from random several "noisy inner products" of random binary vectors with a random secret vector.</p><p>More formally, for τ &lt; 1/2 and a vector x ∈ Z 2 , define the distribution Λ τ, (x) on Z 2 × Z 2 by (r, r T x ⊕ e), where r ∈ Z 2 is uniformly random and e ∈ Z 2 is selected according to Ber τ , the Bernoulli distribution over Z 2 with parameter τ (i.e. Pr[e = 1] = τ ). The LPN τ, problem is to distinguish an oracle returning samples from Λ τ, (x), where x ∈ Z 2 is random and fixed, from an oracle returning uniform samples. It was shown by <ref type="bibr">Blum et al. [4]</ref> that this is equivalent to the search version of LPN, where one needs to compute x given oracle access to Λ τ, (x) (cf. <ref type="bibr" target="#b20">[21,</ref><ref type="bibr">Thm.2]</ref> for precise bounds). We note that the search and decision variants are solvable with a linear in number of samples when there is no noise, i.e. when τ = 0, and the best algorithms take time 2 / log when τ &gt; 0 is treated as a constant <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b22">23]</ref>.</p><p>Authentication protocols from LPN. Starting with the work of Hopper and Blum <ref type="bibr" target="#b17">[18]</ref>, several authentication protocols based on the LPN problem have been proposed. Their original elegant protocol is simple enough for us to recall right away. The shared secret key is a binary vector s ∈ Z 2 . The interaction consists of two messages. First V sends a random challenge r ∈ Z 2 , and then P answers with the bit z = r T s ⊕ e, where e ∈ Z 2 is sampled according to Ber τ . Finally, the verifier accepts if z = r T s.</p><p>This basic protocol has a large completeness error τ (as V will reject if e = 1) and soundness error 1/2 (as a random r, z satisfies r T •s = z with probability 1/2). This can be reduced via sequential or parallel composition. The parallel variant, denoted HB, is illustrated in Figure <ref type="figure" target="#fig_0">1</ref> (we represent several r with a matrix R and the noise bits are now arranged in a vector e). The verifier accepts if at least a τ fraction (where τ &lt; τ &lt; 1/2) of the n basic authentication steps are correct.</p><p>The 2-round HB protocol is provably secure against passive attacks, but efficient active attacks are known against it. This is unsatisfying because in several scenarios, and especially in RFID applications, an adversary will be able to mount an active attack. Subsequently, Juels and Weis <ref type="bibr" target="#b18">[19]</ref> proposed an efficient 3 round variant of HB, called HB + , and proved it secure against active attacks. Again the error can be reduced by sequential repetition, and as shown by Katz, Shin and Smith via a non-trivial analysis, parallel repetition works as well <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b20">21]</ref>. The protocol (in its parallel repetition variant) is illustrated in Figure <ref type="figure" target="#fig_3">2</ref>.</p><p>Despite a large body of subsequent work 1 no improvements in terms of round complexity, security or tightness of the reduction over HB + were achieved: 3 round protocols achieving active security √ ε (assuming LPN is ε-hard) are the state of the art. In particular, Gilbert et al. <ref type="bibr" target="#b13">[14]</ref> showed that HB + can be broken by a MIM attack. Several variants HB ++ <ref type="bibr" target="#b8">[9]</ref>, HB * <ref type="bibr" target="#b10">[11]</ref>, HB-MP <ref type="bibr" target="#b23">[24]</ref> were proposed to prevent the particular attack from <ref type="bibr" target="#b13">[14]</ref>, but all of them were later shown to be insecure <ref type="bibr" target="#b14">[15]</ref>. In <ref type="bibr" target="#b15">[16]</ref>, a variant HB # was presented which provably resists the particular attack from <ref type="bibr" target="#b13">[14]</ref>, but was shown susceptible to a more general MIM attack <ref type="bibr" target="#b24">[25]</ref>. </p><formula xml:id="formula_0">Pτ,n(s ∈ Z 2 ) V τ ,n (s ∈ Z 2 ) R ← -R $ ← Z ×n 2 e $ ← Ber n τ z := R T • s ⊕ e z -→ verify: wt(z ⊕ R T • s) &lt; τ • n</formula><formula xml:id="formula_1">Pτ,n(s1, s2) V τ ,n (s1, s2) R1 $ ← Z ×n 2 R 1 -→ R 2 ← -R2 $ ← Z ×n 2 e $ ← Ber n τ z := R T 1 • s1 ⊕ R T 2 • s2 ⊕ e z -→ verify: wt(z ⊕ R T 1 • s1 ⊕ R T 2 • s2) ≤ τ • n</formula><p>Fig. <ref type="figure" target="#fig_3">2</ref>. The HB + protocol, secure against active attacks</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Our Contribution</head><p>We provide new constructions of authentication protocols and even MACs from LPN. Our first contribution is a two-round authentication protocol secure against active adversaries (this is mentioned as an open problem in <ref type="bibr" target="#b18">[19]</ref>) which moreover has a tight security reduction (an open problem mentioned in <ref type="bibr" target="#b20">[21]</ref>). As a second contribution, we build two efficient MACs, and thus also get two-round authentication protocols secure against MIM attacks, from the LPN assumption. Unlike previous proposals, our constructions are not ad-hoc, and we give a reduction to the LPN problem. Our authentication protocol is roughly as efficient as the HB + protocol but has twice the key length. Our MACs perform roughly the same computation as the authentication protocol plus one evaluation of a pairwise independent permutation of an ≈ 2 bit domain, where is the length of an LPN secret.</p><p>2-Round Authentication with Active Security. Our first contribution is a two-round authentication protocol which we prove secure against active attacks assuming the hardness of the LPN problem. Our protocol diverges considerably from all previous HB-type protocols <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b15">16]</ref>, and runs counter to the intuition that the only way to efficiently embed the LPN problem into a tworound protocol is via an HB-type construction. We now sketch our protocol. In HB and its two-round variants, the prover must compute LPN samples of the form R T • s ⊕ e, where R is the challenge chosen by the verifier in the first message. We take a different approach. Instead of sending R, we now let the verifier choose a random subset of the bits of s to act as the "session-key" for this interaction. It represents this subset by sending a binary vector v ∈ Z 2 that acts as a "bit selector" of the secret s, and we write s ↓v for the sub-vector of s which is obtained by deleting all bits from s where v is 0. (E.g. if s = 111000, v = 011100 then s ↓v = 110). The prover then picks R by itself and computes noisy inner products of the form R T • s ↓v ⊕ e. Curiously, allowing the verifier to choose which bits of s to use in each session is sufficient to prevent active attacks. We only need to add a few sanity-checks that no pathological v or R were sent by an active adversary.</p><p>Our proof relies on the recently introduced subspace LPN problem <ref type="bibr" target="#b25">[26]</ref>. In contrast to the active-attack security proof of HB + <ref type="bibr" target="#b20">[21]</ref>, our proof does not use any rewinding techniques. Avoiding rewinding has at least two advantages. First, the security reduction becomes tight. Second, the proofs also works in a quantum setting: our protocol is secure against quantum adversaries assuming LPN is secure against such adversaries. As first observed by van de Graaf <ref type="bibr" target="#b28">[29]</ref>, classical proofs using rewinding in general do not translate to the quantum setting (cf. <ref type="bibr" target="#b30">[31]</ref> for a more recent discussion). Let us emphasise that this only means that there is no security proof for HB + in the quantum setting, but we do not know if a quantum attack actually exists.</p><p>MAC &amp; Man-In-The-Middle Security. In Section 4, we give two constructions of message authentication codes (MACs) that are secure (formally, unforgeable under chosen message attacks) assuming that the LPN problem is hard. Note that a MAC implies a two-round MIM-secure authentication protocol: the verifier chooses a random message as challenge, and the prover returns the MAC on the message.</p><p>As a first attempt, let us try to view our authentication protocol as a MAC. That is, a MAC tag is of the form φ = (R, z = R T • f s (m) ⊕ e), where the secret key derivation function f s (m) ∈ Z 2 first uniquely encodes the message m into v ∈ Z 2 2 of weight and then returns s ↓v by selecting bits from secret s, according to v. However, this MAC is not secure: given a MAC tag φ = (R, z) an adversary can ask verification queries where it sets individual rows of R to zero until verification fails: if the last row set to zero was the ith, then the ith bit of f s (m) must be 1. (In fact, the main technical difficulty to build a secure MAC from LPN is to make sure the secret s does not leak from verification queries). Our solution is to randomize the mapping f , i.e. use f s (m, b) for some randomness b and compute the tag as</p><formula xml:id="formula_2">φ = π(R, R T • f s (m, b) ⊕ e, b)</formula><p>, where π is a pairwise independent permutation (contained in the secret key). We can prove that if LPN is hard then this construction yields a secure MAC. (The key argument is that, with high probability, all non-trivial verification queries are inconsistent and hence lead to reject). However, the security reduction to the LPN problem is quite loose since it has to guess the value v from the adversary's forgery. (In the context of identity-based encryption (IBE) a similar idea has been used to go from selective-ID to full security using "complexity leveraging" <ref type="bibr" target="#b6">[7]</ref>). In our case, however, this still leads to a polynomial security reduction when one commits to the hardness of the LPN problem at the time of the construction. (See the first paragraph of §4 for a discussion).</p><p>To get a strictly polynomial security reduction (without having to commit to the hardness of the LPN problem), in our second construction we adapt a technique originally used by Waters <ref type="bibr" target="#b29">[30]</ref> in the context of IBE schemes that has been applied to lattice based signature <ref type="bibr" target="#b7">[8]</ref> and encryption schemes <ref type="bibr" target="#b1">[2]</ref>. Concretely, we instantiate the above MAC construction with a different secret key derivation function</p><formula xml:id="formula_3">f s (m, b) = s 0 ⊕ i:v[i]=1 s i (where v = h(m, b) and h(•) is a pairwise independent hash</formula><p>). The drawback of our second construction is the larger keysize. Our security reduction uses a technique from <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b1">2]</ref> based on encodings with full-rank differences (FRD) by Cramer and Damgard <ref type="bibr" target="#b9">[10]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Efficiency</head><p>Figure <ref type="figure" target="#fig_1">3</ref> gives a rough comparison of our new protocol and MACs with the HB, HB + protocols and, as a reference, also the classical tree-based GGM construction <ref type="bibr" target="#b16">[17]</ref>. The second row in the table specifies the security notion that is (provably) achieved under the LPN τ, assumption. λ is a security parameter and n denotes the number of "repetitions". Typical parameters can be = 500, λ = 80, n = 250. Computation complexity counts the number of binary operations over F 2 . Communication complexity counts the total length of all exchanged messages<ref type="foot" target="#foot_0">2</ref> . The last row in the table states the tightness of the security reduction, i.e. what exact security is achieved (ignoring constants and higher order terms) assuming the LPN τ, problem is ε-hard.</p><p>The prover and verifier in the HB, HB + and our new protocols have to perform Θ( • n) basic binary operations, assuming the LPN τ, problem (i.e., LPN with secrets of length ) is hard. This seems optimal, as Θ( ) operations are necessary to compute the inner product which generates a single pseudorandom bit. We will thus consider an authentication protocol or MAC efficient, if it requires O( • n) binary operations. Let us mention that one gets a length-doubling PRG under the LPN τ, assumption with Θ( 2 ) binary operations <ref type="bibr" target="#b11">[12]</ref>. Via the classical GGM construction <ref type="bibr" target="#b16">[17]</ref>, we obtain a PRF and hence a MAC. This PRF, however, requires Θ( 2 • λ) operations per invocation (where λ is the size of the domain of the PRF) which is not very practical. (Recall that ≈ 500).</p><p>Communication vs. Key-Size. For all constructions except GGM, there is a natural trade-off between communication and key-size, where for any constant c (1 ≤ c ≤ n), we can decrease communication by a factor of c and increase key-size by the factor c (cf. the full version <ref type="bibr" target="#b0">[1]</ref> for how exactly this can be done). For the first three protocols in the table, the choice of c does not affect the computational efficiency, but it does so for our MACs: to compute or verify a</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Construction Security</head><p>Complexity Key-size Reduction Communication Computation HB <ref type="bibr" target="#b17">[18]</ref> passive (2 rnd) tag one has to evaluate a pairwise independent permutation (PIP) on the entire tag of length m := Θ( • n/c).</p><formula xml:id="formula_4">• n/c Θ( • n) • c ε(tight) HB + [19] active (3 rnd) • n • 2/ c Θ( • n) • 2 • c √ ε AUTH § 3 active (2 rnd) • n • 2.1/c Θ( • n) • 4.2 • c ε (tight) MAC1 § 4.1 MAC → MIM (2 rnd) • n • 2.1/c Θ( • n) + PIP • 12.6 • c √ ε • Q ( ) MAC2 § 4.2 MAC → MIM (2 rnd) • n • 1.1/c Θ( • n) + PIP • λ • c ε• Q GGM [17] PRF → MIM (2 rnd) λ Θ ( 2 • λ) Θ( ) ε • λ</formula><p>The standard way to construct a PIP π over</p><formula xml:id="formula_5">Z 2 m is to define π(x) := a • x + b ∈ F 2 m for random a, b ∈ F 2 m .</formula><p>Thus the computational cost of evaluating the PIP is one multiplication of two m bits values: the PIP term in the table accounts for this complexity. Asymptotically, such a multiplication takes only O(m log m log log m) time <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b12">13]</ref>, but for small m (like in our scheme) this will not be faster than using schoolbook multiplication, which takes Θ(m 2 ) time. For parameters = 500, n = 250 and trade-off c = n (which minimizes the tag-length m) we get m ≈ 1200 for MAC 1 (i.e., 1200 = 2 plus some statistical security parameters) and m ≈ 600 for MAC 2 . Hence, depending on the parameters, the evaluation of the PIP may be the computational bottleneck of our MACs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Definitions</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Notation</head><p>We denote the set of integers modulo an integer q ≥ 1 by Z q . We will use normal, bold and capital bold letters like x, x, X to denote single elements, vectors and matrices over Z q , respectively. For a positive integer k, [k] denotes the set {1, . . . , k}; </p><formula xml:id="formula_6">[0] is the empty set. For a, b ∈ R, ]a, b[= {x ∈ R ; a &lt; x &lt; b}.</formula><formula xml:id="formula_7">[i] = x[i] ⊕ y[i]. For v ∈ Z m</formula><p>2 we denote by v its inverse, i.e. v[i] = 1v[i] for all i. For two vectors v ∈ Z 2 and x ∈ Z q , we denote by x ↓v the vector (of length wt(v)) which is derived from x by deleting all the bits x[i] where v[i] = 0. If X ∈ Z ×m 2 is a matrix, then X ↓v denotes the submatrix we get by deleting the ith row if v[i] = 0. A function in λ is negligible, written negl(λ), if it vanishes faster than the inverse of any polynomial in λ. An algorithm A is probabilistic polynomial time (PPT) if A uses some randomness as part of its logic (i.e. A is probabilistic) and for any input x ∈ {0, 1} * the computation of A(x) terminates in at most poly(|x|) steps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Authentication Protocols</head><p>An authentication protocol is an interactive protocol executed between a prover P and a verifier V, both PPT algorithms. Both hold a secret x (generated using a key-generation algorithm KG executed on the security parameter λ in unary) that has been shared in an initial phase. After the execution of the authentication protocol, V outputs either accept or reject. We say that the protocol has completeness error α if for all secret keys x generated by KG(1 λ ), the honestly executed protocol returns reject with probability at most α.</p><p>Passive attacks. An authentication protocol is secure against passive attacks, if there exists no PPT adversary A that can make the verifier return accept with non-negligible probability after (passively) observing any number of interactions between the verifier and prover.</p><p>Active attacks. A stronger notion for authentication protocols is security against active attacks. Here the adversary A runs in two stages. First, she can interact with the honest prover a polynomial number of times (with concurrent executions allowed). In the second phase A interacts with the verifier only, and wins if the verifier returns accept. Here we only give the adversary one shot to convince the verifier 3 . An authentication protocol is (t, Q, ε)-secure against active adversaries if every PPT A, running in time at most t and making Q queries to the honest prover, has probability at most ε to win the above game.</p><p>Man-in-the-middle attacks. The strongest standard security notion for authentication protocols is security against man-in-the-middle (MIM) attacks. Here the adversary can initially interact (concurrently) with any number of provers and -unlike in an active attacks -also verifiers. The adversary gets to learn the verifiers accept/reject decisions. One can construct two-round authentication schemes which are secure against MIM attacks from basic cryptographic primitives like MACs, which we define next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Message Authentication Codes</head><p>A message authentication code MAC = {KG, TAG, VRFY} is a triple of algorithms with associated key space K, message space M, and tag space T .</p><p>-Key Generation. The probabilistic key-generation algorithm KG takes as input a security parameter λ ∈ N (in unary) and outputs a secret key K ∈ K. -Tagging. The probabilistic authentication algorithm TAG takes as input a secret key K ∈ K and a message m ∈ M and outputs an authentication tag φ ∈ T . -Verification. The deterministic verification algorithm VRFY takes as input a secret key K ∈ K, a message m ∈ M and a tag φ ∈ T and outputs {accept, reject}.</p><p>If the TAG algorithm is deterministic one does not have to explicitly define VRFY, since it is already defined by the TAG algorithm as VRFY(K, m, φ) = accept iff TAG(K, m) = φ.</p><p>Completeness. We say that MAC has completeness error α if for all m ∈ M and λ ∈ N</p><formula xml:id="formula_8">Pr[VRFY(K, m, φ) = reject ; K ← KG(1 λ ) , φ ← TAG(K, m)] ≤ α.</formula><p>Security. The standard security notion for a MAC is unforgeability under a chosen message attack (uf-cma). We denote by Adv uf-cma MAC (A, λ, Q), the advantage of the adversary A in forging a message under a chosen message attack for 3 By using a hybrid argument one can show that this implies security even if the adversary can interact in k ≥ 1 independent instances concurrently (and wins if the verifier accepts in at least one instance). The use of the hybrid argument looses a factor of k in the security reduction.</p><p>MAC when used with security parameter λ. Formally this is the probability that the following experiment outputs 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Experiment Exp</head><formula xml:id="formula_9">uf-cma MAC (A, λ, Q) K ← KG(1 λ ) Invoke A TAG(K,•),VRFY(K,•,•) who can make up to Q queries to TAG(K, •) and VRFY(K, •, •). Output 1 if A made a query (m, φ) to VRFY(K, •, •) where 1. VRFY(K, m, φ) = accept 2.</formula><p>A did not already make the query m to TAG(K, •) Output 0 otherwise.</p><p>We say that MAC is (t, Q, ε)-secure against uf-cma adversaries if for any A running in time t in the experiment above, we have Adv uf-cma</p><formula xml:id="formula_10">MAC (A, λ, Q) ≤ ε.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Hard Learning Problems</head><p>Let Ber τ be the Bernoulli distribution over Z 2 with parameter (bias) τ ∈ ]0, 1/2[ (i.e., Pr[x = 1] = τ if x ← Ber τ ). For ≥ 1, Ber τ denotes the distribution over Z 2 where each vector consists of independent samples drawn from Ber τ . Given a secret x ∈ Z 2 and τ ∈]0, 1  2 [ , we write Λ τ, (x) for the distribution over Z 2 × Z 2 whose samples are obtained by choosing a vector r $ ← Z 2 and outputting (r, r T • x ⊕ e) with e $ ← Ber τ . The LPN assumption, formally defined below, states that it is hard to distinguish Λ τ, (x) (with a random secret x ∈ Z 2 ) from the uniform distribution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1 (Learning Parity with Noise). The (decisional) LPN τ, problem is (t, Q, ε)-hard if for every distinguisher D running in time t and making</head><formula xml:id="formula_11">Q queries, Pr x $ ← Z 2 : D Λ τ, (x) = 1 -Pr D U +1 = 1 ≤ ε.</formula><p>Below we define the (seemingly) stronger subspace LPN assumption (SLPN for short) recently introduced in <ref type="bibr" target="#b25">[26]</ref>. Here the adversary can ask for inner products not only with the secret x, but even with A • x ⊕ b where A and b can be adaptively chosen, but A must have sufficiently large rank. For minimal dimension </p><formula xml:id="formula_12">d ≤ , a secret x ∈ Z 2 and A ∈ Z × 2 , b ∈ Z 2 , we define the distribution Γ τ, ,d (x, A, b) = ⊥ if rank(A) &lt; d Λ τ, (A • x ⊕ b) otherwise</formula><formula xml:id="formula_13">Pr x $ ← Z 2 : D Γ τ, ,d (x,•,•) = 1 -Pr D U +1 (•,•) = 1 ≤ ε, where U +1 (•, •) on input (A, b) outputs a sample of U +1 if rank(A) ≥ d and ⊥ otherwise.</formula><p>The following proposition states that the subspace LPN problem mapping to dimension d + g is almost as hard as the standard LPN problem with secrets of length d. The hardness gap is exponentially small in g. Proposition 1 (From <ref type="bibr" target="#b25">[26]</ref>). For any , d, g ∈ Z (where</p><formula xml:id="formula_14">≥ d + g), if the LPN τ,d problem is (t, Q, ε)-hard then the SLPN τ, ,d+g problem is (t , Q, ε )-hard where t = t -poly( , Q) ε = ε + 2Q/2 g+1 .</formula><p>For some of our constructions, we will only need a weaker version of the SLPN τ, ,d problem that we call subset LPN. As the name suggests, here the adversary does not ask for inner products with A • x ⊕ b for any A (of rank ≥ d), but only with subsets of x (of size ≥ d). It will be convenient to explicitly define this special case. For x, v ∈ Z 2 , let diag(v) ∈ Z × 2 denote the zero matrix with v in the diagonal, and let is needed, the remaining bits r ↓v ∈ Z -wt(v) 2 are irrelevant. We use this observation to improve the communication complexity (for protocols) or tag length (for MACs), by using "compressed" samples of the form (r ↓v , r</p><formula xml:id="formula_15">Γ * τ, ,d (x, v) := Γ τ, ,d (x, diag(v), 0 ) = ⊥ if wt(v) &lt; d Λ τ, (x ∧ v) otherwise.</formula><formula xml:id="formula_16">T ↓v • x ↓v ⊕ e) ∈ Z wt(v)+1<label>2</label></formula><p>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Two-Round Authentication with Active Security</head><p>In this section we describe our new 2-round authentication protocol and prove its active security under the hardness of the SLPN * τ,2 ,d problem, where d = /(2+γ) for some constant γ &gt; 0. (Concretely, γ = 0.1 should do for all practical purposes).</p><p>-Public parameters. The authentication protocol has the following public parameters, where τ, τ are constants and , n depend on the security parameter λ.</p><p>∈ N length of the secret key s ∈ Z  <ref type="figure">4</ref>. </p><formula xml:id="formula_17">Prover Pτ,n(s ∈ Z 2 2 ) Verifier V τ ,n (s ∈ Z 2 2 ) v ← -v $ ← {x ∈ Z 2 2 : wt(x) = } if wt(v) = abort R $ ← Z ×n 2 ; e $ ← Ber n τ z := R T • s ↓v ⊕ e ∈ Z n 2 (R,z) ---→ if rank(R) = n reject if wt(z ⊕ R T • s ↓v ) &gt; n • τ reject, else accept</formula><formula xml:id="formula_18">t = t -poly(Q, ) ε = ε + Q • 2 -cγ • + 2 -cτ •n = ε + 2 -Θ(n) .</formula><p>The protocol has completeness error 2 -c τ •n where c τ &gt; 0 depends only on τ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Proof of Completeness</head><p>For any n ∈ N, τ ∈]0, 1/2[, let</p><formula xml:id="formula_19">α τ,n := Pr[wt(e) &gt; n • τ : e $ ← Ber n τ ] = 2 -c τ •n (3.1)</formula><p>denote the probability that n independent Bernoulli samples with bias τ contain more than a τ := 1/4 + τ/2 fraction of 1's. The last equality in eq.(3.1) follows from the Hoeffding bound, where the constant c τ &gt; 0 depends only on τ . We now prove that the authentication protocol has completeness error α ≤ 2 -+n + α τ,n . The verifier performs the following two checks. In the first verification step, the verifier rejects if the random matrix R does not have full rank. In the full version <ref type="bibr" target="#b0">[1]</ref> we prove that the probability of this event is ≤ 2 -n . Now, let e := z⊕ R T •s ↓v denote the noise added by P τ,n . Then, in the second verification step, the verifier rejects if wt(e) &gt; n • τ . From equation 3.1, we have that this happens with probability α τ,n . This completes the proof of completeness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Proof of Security</head><p>We first define some terms that will be used later in the security proof. For a constant γ &gt; 0, let d = /(2 + γ) (as in Theorem 1). Let α ,d denote the probability that a random substring of length chosen from a string of length 2 with Hamming weight , has a Hamming weight less than d. Using the fact that the expected Hamming weight is <ref type="formula">1</ref>)), one can show that there exists a constant c γ &gt; 0 (only depending on γ), such that</p><formula xml:id="formula_20">/2 = d(1 + γ/2) = d(1 + Θ(</formula><formula xml:id="formula_21">α ,d := d-1 i=0 i -i 2 ≤ 2 -cγ • . (3.2)</formula><p>For τ = 1/4 + τ/2, let α τ ,n denote the probability that a random bitstring y ∈ Z n 2 has Hamming weight wt(y) ≤ n • τ . From the Hoeffding bound, it follows that there exists a constant c τ &gt; 0 (only depending on τ ), such that</p><formula xml:id="formula_22">α τ ,n := 2 -n • n•τ i=0 n i ≤ 2 -cτ •n . (3.3)</formula><p>We now prove security of the authentication protocol. Consider an oracle O which is either the subset LPN oracle Γ * τ,2 ,d (x, •) or U 2 +1 (•), as defined in Definition 3. We will construct an adversary B O that uses A (who breaks the active security of AUTH with advantage ε ) in a black-box way such that:</p><formula xml:id="formula_23">Pr[B Γ * τ,2 ,d (x,•) → 1] ≥ ε -Q • α ,d and Pr[B U 2 +1 (•) → 1] ≤ α τ ,n .</formula><p>Thus B O can distinguish between the two oracles with advantage ε Setup. Initially, B O samples</p><formula xml:id="formula_24">:= ε -Q • α ,d -α τ ,</formula><formula xml:id="formula_25">x * $ ← Z 2 2 , v * $ ← {y ∈ Z 2 2 : wt(y) = }.</formula><p>The intuition of our simulation below is as follows. Let us first assume O is a subset LPN oracle Γ * τ,2 ,d (x, •) with secret x. In the first phase we have to produce answers (R, z) to a query v ∈ {y ∈ Z 2 2 : wt(y) = } by A. The simulated answers have exactly the same distribution as the answers of an honest prover P τ,n (s ∈ Z 2 2 ) where</p><formula xml:id="formula_26">s = (x * ∧ v * ) ⊕ (x ∧ v * ) (3.4)</formula><p>Thus one part of s's bits come from x * , and the other part is from the unknown secret x (for which we use the oracle O). In the second phase we give A the challenge v * . As s ↓v * = (x * ∧ v * ) ↓v * is known, we will be able to verify if A outputs a valid forgery.</p><p>If O is the random oracle U 2 +1 (•), then after the first phase s ↓v * = (x * ∧ v * ) ↓v * is information theoretically hidden, and thus A cannot come up with a valid forgery but with exponentially small probability.</p><p>First phase. In the first phase B O invokes A who expects access to P τ,n (s ∈ Z 2 2 ) . We now specify how B O samples the answer (R, z) to a query v ∈ {y ∈ Z </p><formula xml:id="formula_27">= RT 0 • (x * ∧ u * ). 3. Return (R = R↓v ∈ Z ×n 2 , z = z 0 ⊕ z 1 ∈ Z n 2 )</formula><p>, where R is uniquely determined by requiring R↓v * = R0 and R↓v * = R1 . Second phase. Eventually, A enters the second phase of the active attack, expecting a challenge from</p><formula xml:id="formula_28">V τ ,n (s ∈ Z 2 2 ). 1. B O forwards v * as the challenge to A. 2. A answers with some (R * , z * ). 3. B O checks if rank(R * ) = n and wt(z * ⊕ R * T • x * ↓v * ) ≤ n • τ . (3.5)</formula><p>The output is 1 if both checks succeed and 0 otherwise.</p><formula xml:id="formula_29">Claim 2. Pr[B U 2 +1 (•) → 1] ≤ α τ ,n .</formula><p>Proof (of Claim). If R * does not have full rank then B outputs 0 by definition. Therefore, we now consider the case where rank(R * ) = n. The answers (R, z) that the adversary A obtains from B U 2 +1 (•) are independent of x * (i.e., z = z 0 ⊕ z 1 is uniform as z 1 is uniform). Since x * ↓v * is uniformly random and R * has full rank, the vector</p><formula xml:id="formula_30">y := R * T • x * ↓v * ⊕ z * is uniformly random over Z n 2 .</formula><p>Thus the probability that the second verification in eq. <ref type="bibr">(3.5)</ref> </p><formula xml:id="formula_31">does not fail is Pr[wt(y) ≤ n • τ ] = α τ ,n . Claim 3. Pr[B Γ * τ,2 ,d (x,•) → 1] ≥ ε -Q • α ,d .</formula><p>Proof (of Claim). We split the proof in two parts. First we show that B outputs 1 with probability ≥ ε if the subset LPN oracle accepts subsets of arbitrary small size (and does not simply output ⊥ on inputs v where wt(v) &lt; d), i.e.,</p><formula xml:id="formula_32">Pr[B Γ * τ,2 ,0 (x,•) → 1] ≥ ε . (3.6)</formula><p>Then we'll upper bound the gap between the probability that B outputs 1 in the above case and the probability that B outputs 1 when given access to the oracle that we are interested in as:</p><formula xml:id="formula_33">Pr[B Γ * τ,2 ,d (x,•) → 1] -Pr[B Γ * τ,2 ,0 (x,•) → 1] ≤ Q • α ,d .<label>(3.7)</label></formula><p>The claim then follows by the triangle inequality from the two equations above.</p><p>Eq. (3.6) holds as:</p><p>-The answers (R, z) that B Γ * τ,2 ,0 (x,•) gives to A's queries in the first phase of the attack have exactly the same distribution as what A would get when interacting with an honest prover P τ,n (s ∈ Z 2</p><p>2 ) where the "simulated" secret s is defined in eq. <ref type="bibr">(3.4)</ref>.</p><p>To see this, recall that on a query v from A, B Γ * τ,2 ,0 (x,•) must compute n SLPN samples ( R, z = RT • (s ∧ v) ⊕ e) and then forward the compressed version of this samples to A (that is, (R, z = R T • s ↓v ⊕ e) where R = R↓v , cf. Remark 1). We next show that the z computed by B indeed have exactly this distribution. In the first step, B queries its oracle with u = v ∧ v * and obtains noisy inner products ( R1 , z 1 ) with the part of s ↓v that contains only bits from x, i.e.,</p><formula xml:id="formula_34">z 1 = RT 1 • (x ∧ u) ⊕ e = RT 1 • (s ∧ u) ⊕ e.</formula><p>In the second step, B samples n inner products ( R0 , z 0 ) (with no noise) with the part of s ↓v that contains only bits from the known x * , i.e.,</p><formula xml:id="formula_35">z 0 = RT 0 • (x * ∧ u * ) = RT 0 • (s ∧ u * ).</formula><p>In the third step, B then generates ( R, RT • (s ∧ v) ⊕ e) from the previous values where R is defined by R↓v * = R0 and R↓v * = R1 . Using v = u ⊕ u * , we get</p><formula xml:id="formula_36">z = z 0 ⊕ z 1 = RT 0 • (s ∧ u * ) ⊕ RT 1 • (s ∧ u) ⊕ e = RT • (s ∧ v) ⊕ e</formula><p>-The challenge v * sent to A in the second phase of the active attack is uniformly random (even given the entire view so far), and therefore has the same distribution as a challenge in an active attack. -B Γ * τ,2 ,0 (x,•) outputs 1 if eq.(3.5) holds, which is exactly the case when A's response to the challenge was valid. By assumption this probability is at least ε . This concludes the proof of Eq. <ref type="bibr">(3.6)</ref>. It remains to prove eq.(3.7). Note that Γ * τ,2 ,0 (x, •) behaves exactly like Γ * τ,2 ,d (x, •) as long as one never makes a query v where wt(v ∧ v * ) &lt; d.</p><p>Since v * $ ← {y ∈ Z 2 2 : wt(y) = }, for any v, the probability that wt(v ∧ v * ) &lt; d is (by definition) α ,d as defined in eq.(3.2). Using the union bound, we can upper bound the probability that wt(v ∧ v * ) &lt; d for any of the Q different v's chosen by the adversary as Q • α ,d .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Avoid Checking</head><p>One disadvantage of the protocol in Figure <ref type="figure">4</ref>, compared to HB style protocols, is the necessity to check whether the messages exchanged have the right from: the prover checks if v has weight , while the verifier must make the even more expensive check whether R has full rank. Eliminating such verification procedures can be particularly useful if for example the prover is an RFID chip where even the simple verification that a vector has large weight is expensive. We note that it is possible to eliminate these checks by blinding the exchanged messages v and z using random vectors b v ∈ Z 2 2 and b z ∈ Z n 2 respectively, as shown in Figure <ref type="figure" target="#fig_8">5</ref>. The security and completeness of this protocol is basically the same as for the protocol in Figure <ref type="figure" target="#fig_8">5</ref>. The security proof is also very similar and is therefore omitted.</p><formula xml:id="formula_37">Pτ,n(s ∈ Z 2 2 , b v ∈ Z 2 2 , b z ∈ Z n 2 ) V τ ,n (s, b v , b z ) v ← -v $ ← Z 2 2 R $ ← Z 2 ×n 2 ; e $ ← Ber n τ z := R T • (s ∧ (v ⊕ b v )) ⊕ b z ⊕ e z,R --→ if wt( R T • (s ∧ (v ⊕ b v )) ⊕ b z ) &gt; n • τ reject otherwise accept</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Message Authentication Codes</head><p>In this section, we construct two message authentication codes whose security can be reduced to the LPN assumption. Our first construction is based on the 2round authentication protocol from Section 3. We prove that if the LPN problem is ε-hard, then no adversary making Q queries can forge a MAC with probability more than Θ( √ ε • Q). However, the construction has the disadvantage that one needs to fix the hardness of the LPN problem at the time of the construction, c.f. Remark 2. Our second construction has no such issues and achieves better security Θ(ε • Q). The efficiency of this construction is similar to that of the first construction, but a larger key is required.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">First Construction</head><p>Recall the 2-round authentication protocol from Section 3. In the protocol the verifier chooses a random challenge subset v. To turn this interactive protocol into a MAC, we will compute this v from the message m to be authenticated as v = C(h(m, b)), where h is a pairwise independent hash function, b ∈ Z ν 2 is some fresh randomness and C is some encoding scheme. The code C is fixed and public, while the function h is part of the secret key. The authentication tag φ is computed in the same manner as the prover's answer in the authentication protocol. That is, we sample a random matrix R ∈ Z ×n 2 and compute a noisy inner product z := R T • s ↓v ⊕ e, where e $ ← Ber n τ . We note that using (R, z) as an authentication tag would not be secure, and we need to blind these values. This is done by applying an (almost) pairwise independent permutation (PIP) π -which is part of the secret key -to (R, z, b) ∈ Z ×n+n+ν </p><formula xml:id="formula_38">= /(2 + γ), if the SLPN * τ,2 ,d problem is (t, nQ, ε)-hard then MAC 1 is (t , Q, ε )-secure against uf- cma adversaries, where t ≈ t, ε = min ε /2 - Q 2 2 μ-2 , ε 2 μ+1 -2 -Θ(n) . MAC 1 has completeness error 2 -cτ •n where c τ &gt; 0 depends only on τ . Corollary 1. Choosing μ s.t. 2 μ = Q 2 •2 4 ε in the above theorem, we get ε = min{ε /4, (ε ) 2 /(2 5 Q 2 ) -2 -Θ(n) }.</formula><p>The 2nd term is the minimum here, and solving for ε gives</p><formula xml:id="formula_39">ε := √ 32 • Q • ε + 2 -Θ(n) . (4.1)</formula><p>Remark 2 (about μ). Note that to get security as claimed in the above corollary, we need to choose μ as a function of Q and ε such that 2 μ ≈ Q 2 • 2 4 /ε for ε as in eq.(4.1). Of course we can just fix Q (as an upper bound to the number of queries made by the adversary) and ε (as our guess on the actual hardness of SLPN * τ,2 ,d ). But a too conservative guess on μ (i.e. choosing μ too small) will result in a construction whose security is worse than what is claimed in the above corollary. A too generous guess on the other hand will make the security reduction meaningless (we don't have any actual attacks on the MAC for large μ though).</p><p>We now give an intuition for the proof of Theorem 4. For space reasons, a full proof will only be given in the full version of this paper <ref type="bibr" target="#b0">[1]</ref>. Every query (m, φ) to VRFY and query m to TAG defines a subset v (as computed in the second step in the definitions of both VRFY and TAG). We say that a forgery (m, φ) is "fresh" if the v contained in (m, φ) is different from all v's contained in all the previous VRFY and TAG queries. The proof makes a case distinction and uses a different reduction for the two cases where the forgery found by the adversary is more likely to be fresh, or more likely to be non-fresh. In both cases we consider a reduction B O which has access to either a uniform oracle O = U or a subset LPN oracle O = Γ * . B O uses an adversary A who can find forgeries for the MAC to distinguish those cases and thus break the subset LPN assumption. In the first case, where the first forgery is likely to be non-fresh, we can show (using the fact that a pairwise independent permutation is used to blind the tag) that if B O 's oracle is O = U , even a computationally unbounded A cannot come up with a message/tag pair (m, φ) that contains a non-fresh v. Thus we can distinguish the cases O = U and O = Γ * by just observing if A ever makes a VRFY query (m, φ) that contains a non-fresh v (even without being able to tell if (m, φ) is valid or not).</p><p>If the forgery found by A is more likely to be fresh, we can use a similar argument as in the proof of our authentication protocol in the last section. An additional difficulty here is that the reduction has to guess the fresh v ∈ Z μ 2 contained in the first forgery and cannot choose it as in the protocol. This is the reason why the reduction looses a factor 2 μ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Second Construction</head><p>We now give the construction of another MAC based on the hardness of the LPN problem. The main difference to MAC 1 from the last subsection is the way we generate the values s(v). In the new construction, we define s(v) := s 0 ⊕ i:v[i]=1 s i , where each s i is a part of the secret key. The construction uses ideas from Waters' IBE scheme <ref type="bibr" target="#b29">[30]</ref>, and parts of the security reduction use simulation tricks from <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b1">2]</ref> that we need to adapt to the binary case.</p><p>Construction. The message authentication code MAC 2 = {KG, TAG, VRFY} with associated message space M is defined as follows.</p><p>-Public parameters. MAC 2 has the following public parameters. , τ, τ , n as in the authentication protocol from Section 3 μ ∈ N output length of the hash function ν ∈ N length of the randomness -Key generation. Algorithm KG(1 λ ) samples s i $ ← Z 2 (for 0 ≤ i ≤ μ) and chooses a pairwise independent hash function h : M × Z ν 2 → Z μ 2 , as well as a pairwise independent permutation π over Z ×n+n+ν </p><formula xml:id="formula_40">t ≈ t ε = min ε /2 - Q 2 2 μ-2 , ε 4Q -2 -Θ(n) .</formula><p>MAC 2 has completeness error 2 -cτ •n where c τ only depends on τ .</p><p>We now give an intuition for the proof of Theorem 5. For space reasons, a full proof will only be given in the full version of this paper <ref type="bibr" target="#b0">[1]</ref>. Similar to the proof of Theorem 4, we distinguish fresh and non-fresh forgeries. Here the new and interesting case is the fresh forgery. The idea is that in the reduction to the SLPN problem we define the function s(v) = A(v) • s ⊕ b(v) (where s is the LPN secret) such that the following holds with non-negligible probability: (i) for each v i from the TAG queries, A(v i ) has full rank and hence the tags can be simulated using the provided Γ τ, , (s, •, •) oracle; (ii) for the first fresh forgery we have A(v) = 0 such that s(v) is independent of s and the reduction can check the forgery's correctness. The above two properties allow to maintain the simulation. The setup of the function s(•) is the crucial step and here we adapt a technique recently introduced by Boyen <ref type="bibr" target="#b7">[8]</ref> based on homomorphic encodings with full-rank differences that allows us to arbitrarily control the probability that the above simulation works.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. The HB protocol, secure against passive attacks</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. A comparison of our new authentication protocol and MACs with the HB, HB + protocols and the classical GGM construction. The trade-off parameter c, 1 ≤ c ≤ n and the term PIP will be explained in the "Communication vs. Key-Size" paragraph below. ( ) See discussion in §4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>For a vector x ∈ Z m q , |x| = m denotes the length of x; wt(x) denotes the Hamming weight of the vector x, i.e. the number of indices i ∈ {1, . . . , |x|} where x[i] = 0. The bit-wise XOR of two binary vectors x and y is represented as z = x ⊕ y, where z</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Definition 2 (</head><label>2</label><figDesc>and let Γ τ, ,d (x, •, •) denote the oracle which on input A, b outputs a sample from Γ τ, ,d (x, A, b). Subspace LPN). Let , d ∈ Z where d ≤ . The (decisional) SLPN τ, ,d problem is (t, Q, ε)-hard if for every distinguisher D running in time t and making Q queries,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Definition 3 ($← Z 2 :$←</head><label>32</label><figDesc>Subset LPN). Let , d ∈ Z where d ≤ . The SLPN * τ, ,d problem is (t, Q, ε)-hard if for every distinguisher D running in time t and making Q queries, Pr x D Γ * τ, ,d (x,•) = 1 -Pr D U +1 (•) = 1 ≤ ε, where U +1 (•) on input v (where wt(v) ≥ d) outputs a sample of U +1 and ⊥ otherwise. Remark 1. Γ * τ, ,d (x, v) samples are of the form (r, r T ↓v • x ↓v ⊕ e) ∈ Z +1 2 , where e Ber τ . To compute the inner product only r ↓v ∈ Z wt(v) 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 4 .Theorem 1 .</head><label>41</label><figDesc>Fig. 4. Two-round authentication protocol AUTH with active security from the LPN assumption Theorem 1. For any constant γ &gt; 0, let d = /(2+γ). If the SLPN * τ,2 ,d problem is (t, nQ, ε)-hard then the authentication protocol from Figure 4 is (t , Q, ε )secure against active adversaries, where for constants c γ , c τ &gt; 0 that depend only on γ and τ respectively,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>n as claimed in the statement of the Theorem. Below we define B O .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>2 2 :Z 2 ×n 2 , z 1 ← Z 2 ×n 2 and set z 0</head><label>22120</label><figDesc>wt(y) = } made by A. Letu * := v ∧ v * u := v ∧ v * 1. B O queriesits oracle n times on the input u. If the oracle's output is ⊥ (which happens iff wt(u) &lt; d), B O outputs 0 and stops. Otherwise let R1 ∈ ∈ Z n 2 denote the n outputs of the oracle. 2. Sample R0 $</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. By blinding the values v, z with secret random vectors b v , b z we can avoid checking whether wt(v) = and rank(R) = n as in the protocol from Figure 4</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>2 .Theorem 4 .</head><label>24</label><figDesc>Construction. The message authentication code MAC 1 = {KG, TAG, VRFY} with associated message space M is defined as follows.-Public parameters. MAC 1 has the following public parameters. , τ, τ , n as in the authentication protocol from Section 3 μ ∈ N output length of the hash function ν ∈ N length of the randomness C : Z μ 2 → Z 2 2 encoding, where ∀ x = x ∈ Z μ 2 we have wt(C(x)) = and wt(C(x) ⊕ C(x )) ≥ 0.9 .-Key generation. Algorithm KG(1 λ ) samples s For μ = ν ∈ N, a constant γ &gt; 0 and d :</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>2 . 2 . 2 , z ∈ Z n 2 ,</head><label>2222</label><figDesc>It returns K = (s 0 , . . . , s μ , h, π) as the secret key.-Tagging. Given secret key K = (s 0 , . . . , s μ , h, π) and message m ∈ M, algorithm TAG proceeds as follows.v := h(m, b) 3. s(v) := s 0 ⊕ i:v[i]=1 s i 4. Return φ := π(R, R T • s(v) ⊕ e, b) -Verification. On input a secret-key K = (s 0 , . . . , s μ , h, π), message m ∈ Mand tag φ, algorithm VRFY proceeds as follows.1. Parse π -1 (φ) as (R ∈ Z ×n b ∈ Z ν 2 ). If rank(R) = n, then return reject 2. v := h(m, b) 3. s(v) := s 0 ⊕ i:v[i]=1 s i 4. If wt(z ⊕ R T • s(v)) &gt; n • τ return reject,otherwise return accept Theorem 5. If the SLPN τ, , problem is (t, nQ, ε)-hard, then MAC 2 is (t , Q, ε )secure against uf-cma adversaries, where</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>The 2-round authentication protocol with prover P τ,n and verifier V τ ,n is given in Figure</figDesc><table><row><cell></cell><cell></cell><cell>2 2</cell></row><row><cell>τ ∈]0, 1/2[</cell><cell cols="2">parameter of the Bernoulli error distribution Ber τ</cell></row><row><cell cols="2">τ = 1/4 + τ/2 acceptance threshold</cell></row><row><cell>n ∈ N</cell><cell cols="2">number of parallel repetitions (we require n ≤ /2)</cell></row><row><cell cols="2">-Key Generation. Algorithm KG(1 λ ) samples s</cell><cell>$ ← Z 2 2 and returns s as the</cell></row><row><cell>secret key.</cell><cell></cell></row><row><cell cols="2">-Authentication Protocol.</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>For MACs, we consider the communication one incurs by constructing a MIM secure 2-round protocol from the MAC by having the prover compute the tag on a random challenge message.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>Krzysztof would like to thank Vadim Lyubashevsky for many interesting discussions on LPN while being in Tel Aviv and Eyjafjallajökull for making this stay possible.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Funded by a Sofja Kovalevskaja Award of the Alexander von Humboldt Foundation and the German Federal Ministry for Education and Research. Supported by the European Research Council under the European Union's Seventh Framework Programme (FP7/2007-2013) / ERC Starting Grant (259668-PSPC). Supported by NSF CCF-0915675. Research done while visiting CWI Amsterdam. † Research done while visiting CWI Amsterdam.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<ptr target="http://eprint.iacr.org/" />
		<title level="m">The full version of this paper will be posted on the Cryptology ePrint Archive</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Efficient lattice (H)IBE in the standard model</title>
		<author>
			<persName><forename type="first">S</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Boyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2010</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Gilbert</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6110</biblScope>
			<biblScope unit="page" from="553" to="572" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">On the inherent intractability of certain coding problems</title>
		<author>
			<persName><forename type="first">E</forename><surname>Berlekamp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mceliece</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Van Tilborg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="384" to="386" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Cryptographic primitives based on hard learning problems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Furst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Kearns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Lipton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 1993</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Stinson</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">773</biblScope>
			<biblScope unit="page" from="278" to="291" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Noise-tolerant learning, the parity problem, and the statistical query model</title>
		<author>
			<persName><forename type="first">A</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kalai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wasserman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">32nd ACM STOC</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2000-05">May 2000</date>
			<biblScope unit="page" from="435" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Noise-tolerant learning, the parity problem, and the statistical query model</title>
		<author>
			<persName><forename type="first">A</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kalai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wasserman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="506" to="519" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Efficient selective-ID secure identity-based encryption without random oracles</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Boyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2004</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Cachin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Camenisch</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3027</biblScope>
			<biblScope unit="page" from="223" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Lattice mixing and vanishing trapdoors: A framework for fully secure short signatures and more</title>
		<author>
			<persName><forename type="first">X</forename><surname>Boyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC 2010</title>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">Q</forename><surname>Nguyen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Pointcheval</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6056</biblScope>
			<biblScope unit="page" from="499" to="517" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">HB ++ : a lightweight authentication protocol secure against some attacks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bringer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Chabanne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Dottax</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="28" to="33" />
		</imprint>
		<respStmt>
			<orgName>SecPerU</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">On the amortized complexity of zero-knowledge protocols</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Damgard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2009</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5677</biblScope>
			<biblScope unit="page" from="177" to="191" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Securing HB+ against GRS man-in-the-middle attack</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">N</forename><surname>Duc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SCIS</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">An efficient pseudo-random generator provably as secure as syndrome decoding</title>
		<author>
			<persName><forename type="first">J.-B</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 1996</title>
		<editor>
			<persName><forename type="first">U</forename><forename type="middle">M</forename><surname>Maurer</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1070</biblScope>
			<biblScope unit="page" from="245" to="255" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Faster integer multiplication</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fürer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="979" to="1005" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">An active attack against HB+ -a provably secure lightweight authentication protocol</title>
		<author>
			<persName><forename type="first">H</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Robshaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sibert</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="volume">237</biblScope>
			<date type="published" when="2005">2005. 2005</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Good variants of hB + are hard to find</title>
		<author>
			<persName><forename type="first">H</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J B</forename><surname>Robshaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Seurin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FC 2008</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Tsudik</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5143</biblScope>
			<biblScope unit="page" from="156" to="170" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">HB # : Increasing the security and efficiency of HB +</title>
		<author>
			<persName><forename type="first">H</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J B</forename><surname>Robshaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Seurin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2008</title>
		<editor>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Smart</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">4965</biblScope>
			<biblScope unit="page" from="361" to="378" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">How to construct random functions</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="792" to="807" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Secure human identification protocols</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">J</forename><surname>Hopper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Blum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2001</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Boyd</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2248</biblScope>
			<biblScope unit="page" from="52" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Authenticating pervasive devices with human protocols</title>
		<author>
			<persName><forename type="first">A</forename><surname>Juels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Weis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2005</title>
		<editor>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3621</biblScope>
			<biblScope unit="page" from="293" to="308" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Parallel and concurrent security of the HB and HB + protocols</title>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Shin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2006</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Vaudenay</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4004</biblScope>
			<biblScope unit="page" from="73" to="87" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Parallel and concurrent security of the HB and HB+ protocols</title>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="402" to="421" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Efficient noise-tolerant learning from statistical queries</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Kearns</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="983" to="1006" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">An improved LPN algorithm</title>
		<author>
			<persName><forename type="first">É</forename><surname>Levieil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-A</forename><surname>Fouque</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SCN 2006</title>
		<editor>
			<persName><forename type="first">R</forename><surname>De Prisco</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4116</biblScope>
			<biblScope unit="page" from="348" to="359" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">HB-MP: A further step in the HB-family of lightweight authentication protocols</title>
		<author>
			<persName><forename type="first">J</forename><surname>Munilla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Peinado</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Networks</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="2262" to="2267" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">On the security of hB # against a man-inthe-middle attack</title>
		<author>
			<persName><forename type="first">K</forename><surname>Ouafi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Overbeck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vaudenay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2008</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Pieprzyk</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5350</biblScope>
			<biblScope unit="page" from="108" to="124" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><forename type="first">K</forename><surname>Pietrzak</surname></persName>
		</author>
		<ptr target="http://homepages.cwi.nl/~pietrzak/publications/SLWE.pdf" />
		<title level="m">Subspace LWE</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
	<note>manuscript</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">On lattices, learning with errors, random linear codes, and cryptography</title>
		<author>
			<persName><forename type="first">O</forename><surname>Regev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">37th ACM STOC</title>
		<editor>
			<persName><forename type="first">H</forename><forename type="middle">N</forename><surname>Gabow</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="84" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">A</forename><surname>Schönhage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Strassen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Schnelle Multiplikation grosser Zahlen. Computing</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Towards a formal definition of security for quantum protocols</title>
		<author>
			<persName><forename type="first">J</forename><surname>Van De Graaf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AAINQ</title>
		<imprint>
			<biblScope unit="volume">35648</biblScope>
			<date type="published" when="1998">1998</date>
			<pubPlace>Monreal, P.Q., Canada</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Efficient identity-based encryption without random oracles</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">R</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2005</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3494</biblScope>
			<biblScope unit="page" from="114" to="127" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Zero-knowledge against quantum attacks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Watrous</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="25" to="58" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
