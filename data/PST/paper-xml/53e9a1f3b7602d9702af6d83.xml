<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Machine Learning for Sequential Data: A Review</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Thomas</forename><forename type="middle">G</forename><surname>Dietterich</surname></persName>
							<email>tgd@cs.orst.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Oregon State University</orgName>
								<address>
									<settlement>Corvallis</settlement>
									<region>Oregon</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Machine Learning for Sequential Data: A Review</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T13:22+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Statistical learning problems in many fields involve sequential data. This paper formalizes the principal learning tasks and describes the methods that have been developed within the machine learning research community for addressing these problems. These methods include sliding window methods, recurrent sliding windows, hidden Markov models, conditional random fields, and graph transformer networks. The paper also discusses some open research issues.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The classical supervised learning problem is to construct a classifier that can correctly predict the classes of new objects given training examples of old objects <ref type="bibr" target="#b18">[19]</ref>. A typical application is in optical character recognition where the objects are images of hand-written characters and the classes are the 26 alphabetic letters. The classifier takes an image as input and produces a letter as output. This task is typically formalized as follows.</p><p>Let x denote an image of a hand-written character and y ∈ {A, . . . , Z} denote the corresponding letter class. A training example is a pair (x, y) consisting of an image and its associated class label. We assume that the training examples are drawn independently and identically from the joint distribution P (x, y), and we will refer to a set of N such examples as the training data.</p><p>A classifier is a function h that maps from images to classes. The goal of the learning process is to find an h that correctly predicts the class y = h(x) of new images x. This is accomplished by searching some space H of possible classifiers for a classifier that gives good results on the training data without overfitting.</p><p>Over the past 10 years, supervised learning has become a standard tool in many fields, and practitioners have learned how to take new application problems and view them as supervised learning problems. For example, in cellular telephone fraud detection, each x describes a telephone call, and y is 0 if the call is legitimate and 1 if the call originated from a stolen (or cloned) cell phone <ref type="bibr" target="#b7">[8]</ref>. Another example involves computer intrusion detection where each x describes a request for a computer network connection and y indicates whether that request is part of an intrusion attempt. A third example is part-of-speech tagging in which each x describes a word and each y gives the part-of-speech of that word (noun, verb, adjective, etc.).</p><p>One thing that is apparent in these (and other) applications is that they do not quite fit the supervised learning framework. Rather than being drawn independently and identically (iid) from some joint distribution P (x, y), the training data actually consist of sequences of (x, y) pairs. These sequences exhibit significant sequential correlation. That is, nearby x and y values are likely to be related to each other.</p><p>For example, before a cell phone is stolen, all of the y values will be 0. Afterwards, all of the y values will be 1. Similarly, computer intrusions exhibit significant clustering-particularly denial of service attacks. Other kinds of attacks are deliberately spaced over time to avoid detection, which is a form of temporal anti-correlation. In part-of-speech tagging, sequences of parts of speech are constrained by the grammar of the language. Hence, in English, a sequence such as (verb verb adjective verb verb) would be very unlikely. Sequential patterns are present even in the original task of character recognition: Character sequences usually form words rather than random sequences of letters.</p><p>Sequential patterns are important because they can be exploited to improve the prediction accuracy of our classifiers. In English, for example, if the classifier determines that one letter is Q, then the next letter is almost certain to be U. In telephone fraud detection, it is only possible to detect fraud by looking at the distribution of typical (legitimate) phone calls and then to see that this distribution changes when the telephone is stolen. Any single phone call, viewed in isolation, appears to be perfectly legitimate.</p><p>The sequential supervised learning problem can be formulated as follows. Let {(x i , y i )} N i=1 be a set of N training examples. Each example is a pair of sequences (x i , y i ), where x i = x i,1 , x i,2 , . . . , x i,Ti and y i = y i,1 , y i,2 , . . . , y i,Ti . For example, in part-of-speech tagging, one (x i , y i ) pair might consist of x i = do you want fries with that and y i = verb pronoun verb noun prep pronoun . The goal is to construct a classifier h that can correctly predict a new label sequence y = h(x) given an input sequence x.</p><p>This task should be contrasted with two other, closely-related tasks. The first of these is the time-series prediction problem. Here the task is to predict the t + 1 st element of a sequence y 1 , . . . , y t . This can be extended in two ways. First, we can consider the case where each y t is a vector y t . The time-series task becomes to predict simultaneously a whole collection of parallel time series: Predict y t+1 given y 1 , . . . , y t . Second, we can consider the case when there are other "features" or co-variates x 1 , . . . , x t , x t+1 available.</p><p>There are two key differences between time-series prediction and sequential supervised learning. First in sequential supervised learning, the entire sequence x 1 , . . . , x T is available before we make any predictions of the y values, whereas in time-series prediction, we have only a prefix of the sequence up to the current time t + 1. Second, in time-series analysis, we have the true observed y values up to time t, whereas in sequential supervised learning, we are not given any y values and we must predict them all.</p><p>The second closely-related task is sequence classification. In this task, the problem is to predict a single label y that applies to an entire input sequence x 1 , x 2 , . . . , x T . For example, given a sequence of images of hand-written characters, the task might be to determine the identity of the person who wrote those characters (hand-writing identification). In these kinds of problems, each training example consists of a pair (x i , y i ), where x i is a sequence x i,1 , . . . , x i,Ti and each y i is a class label (such as a person's identification number). A similar problem arises in recognizing whole words on handwritten checks. The x i could be a sequence of hand-written letters, and y i could be a word such as "hundred".</p><p>All of these problems are closely related, and sometimes a solution to one can be converted into a solution for another. For example, one strategy for recognizing a handwritten word (e.g., "hundred") would be first to solve the sequential supervised learning problem of recognizing the individual letters H, U, N, D, R, E, D , and then assembling them into the entire word. This works for cases where the class label y can be decomposed into sub-parts (in this case, individual letters). But no similar strategy would work for recognizing an individual's identity from their handwriting.</p><p>Similarly, some methods for sequential supervised learning make their predictions by scanning the sequence from left-to-right, and such methods can typically be applied to time-series problems as well. However, methods that analyze the entire sequence of x t values before predicting the y t labels typically can give better performance on the sequential supervised learning problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Research Issues in Sequential Supervised Learning</head><p>Now let us consider three fundamental issues in sequential supervised learning: (a) loss functions, (b) feature selection, and (c) computational efficiency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Loss Functions</head><p>In classical supervised learning, the usual measure of success is the proportion of (new) test data points correctly classified. This is known as the 0/1 loss, since a loss of 1 is received for every misclassified test point and a loss of 0 for every correctly-classified test point. More recently, researchers have been studying nonuniform loss functions. These are usually represented by a cost matrix C(i, j), which gives the cost of assigning label i to an example whose true label is j. In such cases, the goal is to find a classifier with minimum expected cost. One strategy for developing such a classifier is to learn a conditional density estimator P (y|x) and then classify a new data point x according to the formula y = argmin</p><formula xml:id="formula_0">i j P (j|x)C(i, j).</formula><p>This formula chooses the class whose expected cost is minimum.</p><p>In sequential supervised learning problems, many different kinds of loss functions are encountered. Statistical learning methods are needed that can minimize the expected loss for all of these different loss functions. First, we will consider some of the loss functions that have appeared in various applications. Second, we will discuss how these different loss functions might be incorporated into learning and prediction.</p><p>In some problems, the goal is to predict the entire output sequence of labels y i correctly, and any error in this sequence counts as an error for the entire sequence. Other problems exhibit the opposite extreme: the goal is to predict correctly as many individual labels y i,t in the sequence as possible. One can imagine problems intermediate between these extremes.</p><p>In many applications, different kinds of errors have different costs. Consider cellular telephone fraud. The real goal here is to determine the time t * at which the telephone was stolen (or cloned). As described above, we can view this as a sequential supervised learning problem in which y t = 0 for t &lt; t * and y t = 1 for t ≥ t * . Consider the problem of making a prediction t for the value of t * . One strategy would be to apply the learned classifier h to classify each element x i,t and predict t = t for the earliest time t for which h(x i,t ) = 1. A typical form for the loss function assesses a penalty of c 1 (t * − t) if t &lt; t * and a penalty of c 2 (t − t * ) if t &gt; t * . In the telephone fraud case, the first penalty is the cost of lost business if we prematurely declare the telephone to be stolen. The second penalty is the cost of the fraudulent calls when we are late in declaring the telephone to be stolen. More complex loss functions can be imagined that take into account the cost of each individual telephone call. This argument applies to any form of monitoring of financial transactions. It also applies to systems that must determine when manufacturing equipment begins to malfunction.</p><p>Another kind of loss function applies to problems of event detection. Suppose that the input sequence x i consists of infrequent events superimposed on "normal" signals. For example, in high-energy physics, these might be detections of rare particles. In astronomy, these might be sightings of events of interest (e.g., gamma ray bursts). The loss function should assign a cost to missed events, to extra events, and to events that are detected but not at the correct time.</p><p>Finally, a loss function closely related to event detection arises in the problem of hyphenation. Consider the problem of learning to hyphenate words so that a word processor can determine where to break words during typesetting (e.g., "porcupine" → "00101000"). In this case, the input sequence x i is a string of letters, and the output sequence y i is a sequence of 0's and 1's, such that y i,t = 1 indicates that a hyphen can legally follow the letter x i,t . Each opportunity for a hyphen can be viewed as an event. False positive hyphens are very expensive, because they lead to incorrectly-hyphenated words that distract the reader. False negative hyphens are less of a problem-provided that at least one hyphen is correctly identified. Furthermore, hyphens near the middle of long words are more helpful to the typesetting program than hyphens near the ends of the words. This is a case where the loss function involves a global analysis of the predicted sequence y i but where not all of the individual y t predictions need to be correct.</p><p>How can these kinds of loss functions be incorporated into sequential supervised learning? One approach is to view the learning problem as the task of predicting the (conditional) joint distribution of all of the labels in the output sequence: P (y i |x i ). If this joint distribution can be accurately predicted, then all of the various loss functions can be evaluated, and the optimal decisions can be chosen. There are two difficulties with this: First, predicting the entire joint distribution is typically very difficult. Second, computing the optimal decisions given the joint distribution may also be computationally infeasible.</p><p>Some loss functions only require particular marginal probabilities. For example, if the loss function is only concerned with the number of correct individual predictions y i,t , then the goal of learning should be to predict the individual marginal probabilities P (y i,t |x i ) correctly. If the loss function is only concerned with classifying the entire sequence correctly, then the goal should be to predict argmax yi P (y i |x i ) correctly. We will see below that there are learning algorithms that directly optimize these quantities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Feature Selection and Long-Distance Interactions</head><p>Any method for sequential supervised learning must employ some form of divideand-conquer to break the overall problem of predicting y i given x i into subproblems of predicting individual output labels y i,t given some subset of information from x i (and perhaps other predicted values y i,u ). One of the central problems of sequential supervised learning is to identify the relevant information subset for making accurate predictions.</p><p>In standard supervised learning, this is known as the feature selection problem, and there are four primary strategies for solving it. The first strategy, known as the wrapper approach <ref type="bibr" target="#b11">[12]</ref>, is to generate various subsets of features and evaluate them by running the learning algorithm and measuring the accuracy of the resulting classifier (e.g., via cross-validation or by applying the Akaiki Information Criterion). The feature subsets are typically generated by forward selection (starting with single features and progressively adding one feature at a time) or backward elimination (starting with all of the features and progressively removing one feature at a time). For some learning algorithms, such as linear regression, this can be implemented very efficiently.</p><p>The second strategy is to include all possible features in the model, but to place a penalty on the values of parameters in the fitted model. This causes the parameters associated with useless features to become very small (perhaps even zero). Examples of this approach include ridge regression <ref type="bibr" target="#b9">[10]</ref>, neural network weight elimination <ref type="bibr" target="#b23">[24]</ref>, and L 1 -norm support vector machines (SVMs; <ref type="bibr" target="#b4">[5]</ref>).</p><p>The third strategy is to compute some measure of feature relevance and remove low-scoring features. One of the simplest measures is the mutual information between a feature and the class. This (or similar measures) forms the basis of recursive-partioning algorithms for growing classification and regression trees. These methods incorporate the choice of relevant features into the treegrowing process <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b20">21]</ref>. Unfortunately, this measure does not capture interactions between features. Several methods have been developed that identify such interactions including RELIEFF <ref type="bibr" target="#b13">[14]</ref>, Markov blankets <ref type="bibr" target="#b12">[13]</ref>, and feature racing <ref type="bibr" target="#b16">[17]</ref>.</p><p>The fourth strategy is to first fit a simple model and then analyze the fitted model to identify the relevant features. For example, Chow and Liu <ref type="bibr" target="#b3">[4]</ref> describe an efficient algorithm for fitting a tree-structured Bayesian network to a data set. This network can then be analyzed to remove features that have low influence on the class. Kristin Bennett (personal communication, 2001) fits L 1 -norm SVMs to drug binding data to remove irrelevant features prior to fitting a more complex SVM regression model.</p><p>In sequential supervised learning, most authors have assumed that a fixedsized neighborhood of features is relevant for predicting each output value. For example, suppose we assume a neighborhood of size 3. Then we will employ x i,t−1 , x i,t , and x i,t+1 to predict y i,t . However, this has two drawbacks. First, not all of the features in each feature vector {x i,u } t+1 u=t−1 are necessarily relevant. Second, there may be longer-range interactions that are missed. For example, consider the problem of predicting the pronunciation of English words from their spelling. The only difference between the words "thought" and "though" is the final "t", yet this influences the pronunciation of the initial "th" (changing it from unvoiced to voiced). An even more extreme case is the pair "photograph" and "photography" in which the final "y" changes the pronunciation of every vowel in the word.</p><p>Of the four feature-selection strategies discussed above, it is unlikely that the first two are feasible for sequential supervised learning. There are so many potential features to consider in a long sequence, that a direct search of possible feature subsets becomes completely intractable (even with greedy algorithms). The third and fourth approaches are more promising, but with long sequences, they still raise the possibility of overfitting. Hence, any successful methodology for feature selection (and for handling long distance interactions) will probably need to combine human expertise with statistical techniques rather than applying statistical techniques alone.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Computational Efficiency</head><p>A third challenge for sequential supervised learning is to develop methods for learning and classification that are computationally efficient. We will see below that some of the learning algorithms that have been proposed for sequential supervised learning are computationally expensive.</p><p>Even after learning, it may be computationally expensive to apply a learned classifier to make minimum-cost predictions. Even relatively efficient methods such as the Viterbi algorithm can be slow for complex models. These computational challenges are probably easier to solve than the statistical ones. As in many other computational problems, it is usually possible to identify a series of approximate methods that are progressively more expensive and more accurate. The cheapest methods can be applied first to generate a set of possible candidate solutions which can then be evaluated more carefully by the more expensive methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Machine Learning Methods for Sequential Supervised Learning</head><p>In this section, we will briefly describe six methods that have been applied to solve sequential supervised learning problems: (a) sliding-window methods, (b) recurrent sliding windows, (c) hidden Markov models, (d) maximum entropy Markov models, (e) input-output Markov models, (f) conditional random fields, and (g) graph transformer networks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The Sliding Window Method</head><p>The sliding window method converts the sequential supervised learning problem into the classical supervised learning problem. It constructs a window classifier h w that maps an input window of width w into an individual output value y. Specifically, let d = (w − 1)/2 be the "half-width" of the window. Then h w predicts y i,t using the window x i,t−d , x i,t−d+1 , . . . , x i,t , . . . , x i,t+d−1 , x i,t+d . In effect, the input sequence x i is padded on each end by d "null" values and then converted into N i separate examples. The window classifier h w is trained by converting each sequential training example (x i , y i ) into windows and then applying a standard supervised learning algorithm. A new sequence x is classified by converting it to windows, applying h w to predict each y t and then concatenating the y t 's to form the predicted sequence y.</p><p>The obvious advantage of this sliding window method is that permits any classical supervised learning algorithm to be applied. Sejnowski and Rosenberg <ref type="bibr" target="#b22">[23]</ref> applied the backpropagation neural network algorithm with a 7-letter sliding window to the task of pronouncing English words. A similar approach (but with a 15-letter window) was employed by Qian and Sejnowski <ref type="bibr" target="#b19">[20]</ref> to predict protein secondary structure from the protein's sequence of amino acid residues. Provost and Fawcett <ref type="bibr" target="#b7">[8]</ref> addressed the problem of cellular telephone cloning by applying the RL rule learning system to day-long windows from telephone calling logs.</p><p>Although the sliding window method gives adequate performance in many applications, it does not take advantage of correlations between nearby y t values. To be more precise, the only relationships between nearby y t values that are captured are those that are predictable from nearby x t values. If there are correlations among the y t values that are independent of the x t values, then these are not captured.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Recurrent Sliding Windows</head><p>One way that sliding window methods can be improved is to make them recurrent. In a recurrent sliding window method, the predicted value y i,t is fed as an input to help make the prediction for y i,t+1 . Specifically, with a window of half-width d, the most recent d predictions, y i,t−d , y i,t−d+1 , . . . , y i,t−1 , are used as inputs (along with the sliding window x i,t−d , x i,t−d+1 , . . . , x i,t , . . . , x i,t+d−1 , x i,t+d ) to predict y i,t . Bakiri and Dietterich <ref type="bibr" target="#b0">[1]</ref> applied this technique to the English pronunciation problem using a 7-letter window and a decision-tree algorithm. Table <ref type="table" target="#tab_0">1</ref> summarizes the results they obtained when training on 1000 words and evaluating the performance on a separate 1000-word test data set. The baseline sliding window method correctly pronounces 12.5% of the words and 69.6% of the individual letters in the words. A recurrent sliding window moving left-to-right improves the word-level performance but worsens the pronunciations of individual letters. However, a right-to-left sliding window improves both the word-level and letterlevel performance. Indeed, the percentage of correct word-level pronunciations has nearly doubled! Clearly, the recurrent method captures predictive information that was not being captured by the simple 7-letter sliding window. But why is the right-to-left scan superior? It appears that in English, the right-to-left scan is able to capture long-distance effects such as those mentioned above for "thought" and "photography". For example, the right-most window can correctly pronounce the "y" of "photography". This information is then available when the system attempts to pronounce the "a". And this information in turn is available when the system is pronouncing the second "o", and so on. Because the stress patterns in English are determined by the number of syllables to the right of the current syllable, a right-to-left recurrent window is able to correctly predict these stresses, and hence, choose the correct pronunciations for the vowels in each syllable.</p><p>One issue arises during training: What values should be used for the y i,t inputs when training the window classifier? One approach would be to first train a non-recurrent classifier, and then use its y i,t predictions as the inputs. This process can be iterated, so that the predicted outputs from each iteration are employed as inputs in the next iteration. Another approach is to use the correct labels y i,t as the inputs. The advantage of using the correct labels is that training can be performed with the standard supervised learning algorithms, since each training example can be constructed independently. This was the choice made by Bakiri and Dietterich.</p><p>In addition to recurrent decision trees, many other classifiers can be made recurrent. Recurrent neural networks are of particular interest. Figure <ref type="figure" target="#fig_0">1</ref> shows two of the many architectures that have been explored. Part (a) shows a network in which the output units are fed as inputs to the hidden units at the next time step. This is essentially identical to the recurrent decision trees employed by Bakiri and Dietterich, except that during training, the predicted outputs y i,t−1 are used as the inputs at time t. Networks similar to this were first introduced by Jordan <ref type="bibr" target="#b10">[11]</ref>. Part (b) shows a network in which the hidden unit activations at time t − 1 are fed as additional inputs at time t. This allows the network to develop a representation for the recurrent information that is separate from the representation of the output y values. This architecture was introduced by Elman <ref type="bibr" target="#b6">[7]</ref>. These networks are usually trained iteratively via a procedure known as backpropagation-through-time (BPTT) in which the network structure is "unrolled" for the length of the input and output sequences x i and y i <ref type="bibr" target="#b21">[22]</ref>. Recurrent networks have been applied to a variety of sequence-learning problems <ref type="bibr" target="#b8">[9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Hidden Markov Models and Related Methods</head><p>The hidden Markov Model (HMM; see Figure <ref type="figure" target="#fig_1">2(a)</ref>) is a probabilistic model of the way in which the x i and y i strings are generated-that is, it is a representation of the joint distribution P (x, y). It is defined by two probability distributions: the transition distribution P (y t |y t−1 ), which tells how adjacent y values are related, and the observation distribution P (x|y), which tells how the observed x values are related to the hidden y values. These distributions are assumed to be stationary (i.e., the same for all times t).</p><p>In most problems, x is a vector of features (x 1 , . . . , x n ), which makes the observation distribution difficult to handle without further assumptions. A common assumption is that each feature is generated independently (conditioned on y). This means that P (x|y) can be replaced by the product of n separate distributions P (x j |y), j = 1, . . . , n.</p><p>The HMM generates x i and y i as follows. Suppose there are K possible labels 1, . . . , K. Augment this set of labels with a start label 0 and a terminal label K + 1. Let y i,0 = 0. Then, generate the sequence of y values according to P (y i,t |y i,t−1 ) until y i,t = K + 1. At this point, set T i := t. Finally, for each t = 1, . . . , T i , generate x i,t according to the observation probabilities P (x i,t |y i,t ). In a sequential supervised learning problem, it is straightforward to determine the transition and observation distributions. P (y i,t |y i,t−1 ) can be computed by looking at all pairs of adjacent y labels (after prepending 0 at the start and appending K + 1 to the end of each y i ). Similarly, P (x j |y) can be computed by looking at all pairs of x j and y.</p><p>The most complex computation is to predict a value y given an observed sequence x. This computation depends on the nature of the loss function. Because the HMM is a representation of the joint probability distribution P (x, y), it can be applied to compute the probability of any particular y given any particular x: P (y|x). Hence, for an arbitrary loss function L(y, y), the optimal prediction is y = argmin z y P (y|x)L(z, y).</p><p>However, if the sequences are of length L and there are K labels, then direct evaluation of this equation requires O(K L ) probability evaluations, which is usually impractical.</p><p>There are two notable cases where this computation can be performed in O(K 2 L) time. The first is where the loss function depends on the entire sequence. In this case, the goal is usually to find the y with the highest probability: y = argmax y P (y|x). This can be computed via the Viterbi algorithm, which is a dynamic programming algorithm that computes, for each class label u and each time step t, the probability of the most likely path starting at time 0 end ending at time t with class u. When the algorithm reaches the end of the sequence, it has computed the most likely path from time 0 to time T i and its probability.</p><p>The second interesting case is where the loss function decomposes into separate decisions for each y t . In this case, the so-called Forward-Backward algorithm can be applied. It performs a left-to-right pass, which fills a table of α t (y t ) values which represent P (y 1 , . . . , y t |x 1 , . . . , x t ), and a right-to-left pass, which fills a table of β t (y t ) values which represent P (y t , . . . , y Ti |x t+1 , . . . , x Ti ). Once these two passes are complete, the quantity</p><formula xml:id="formula_1">γ t (u) = α t (u) • β t (u) v α t (v) • β t (v)</formula><p>gives the desired probability: P (y t = u|x). This probability can be applied to choose the predicted value y t that minimizes the loss function.</p><p>Although HMMs provide an elegant and sound methodology, they suffer from one principal drawback: The structure of the HMM is often a poor model of the true process producing the data. Part of the problem stems from the Markov property. Any relationship between two separated y values (e.g., y 1 and y 4 ) must be communicated via the intervening y's. A first-order Markov model (i.e., where P (y t ) only depends on y t−1 ) cannot in general capture these kinds of relationships.</p><p>Sliding window methods avoid this difficulty by using a window of x t values to predict a single y t . However, the second problem with the HMM model is that it generates each x t only from the corresponding y t . This makes it difficult to use an input window. In theory, one could replace the output distribution P (x t |y t ) by a more complex distribution P (x t |y t−1 , y t , y t+1 ) which would then allow an observed value x t to influence the three y values. But it is not clear how to represent such a complex distribution compactly.</p><p>Several directions have been explored to try to overcome the limitations of the HMM: Maximum Entropy Markov models (MEMMs), Input-Output HMMs (IOHMMs), and conditional random fields (CRFs); see Figure <ref type="figure" target="#fig_1">2</ref>. All of these are conditional models that represent P (y|x) rather than P (x, y). They do not try to explain how the x's are generated. Instead, they just try to predict the y values given the x's. This permits them to use arbitrary features of the x's including global features, features describing non-local interactions, and sliding windows.</p><p>The Maximum Entropy Markov Model learns P (y t |y t−1 , x t ). It is trained via a maximum entropy method that attempts to maximize the conditional likelihood of the data: N i=1 P (y i |x i ). The maximum entropy approach represents P (y t |y t−1 , x t ) as a log-linear model:</p><formula xml:id="formula_2">P (y t |y t−1 , x) = 1 Z(y t−1 , x) exp α λ α f α (x, y t ) ,</formula><p>where Z(y t−1 , x) is a normalizing factor to ensure that the probabilities sum to 1. Each f α is a boolean feature that can depend on y t and on any properties of the input sequence x. For example, in their experiments with MEMMs, McCallum, et al. <ref type="bibr" target="#b17">[18]</ref> employed features such as "x begins with a number", "x ends with a question mark", etc. Hence, MEMMs support long-distance interactions.</p><p>The IOHMM is similar to the MEMM except that it introduces hidden state variables s t in addition to the output labels y t . Sequential interactions are modeled by the s t variables. To handle these hidden variables during training, the Expectation-Maximization (EM; <ref type="bibr" target="#b5">[6]</ref>) algorithm is applied. Bengio and Frasconi <ref type="bibr" target="#b1">[2]</ref> report promising results on various artificial sequential supervised learning and sequence classification problems.</p><p>Unfortunately, the MEMM and IOHMM models suffer from a problem known as the label bias problem. To understand the origins of the problem, consider the MEMM and note that yt</p><formula xml:id="formula_3">P (y t |y t−1 , x 1 , . . . , x t ) = yt P (y t |y t−1 , x t ) • P (y t−1 |x 1 , . . . , x t−1 ) = 1 • P (y t−1 |x 1 , . . . , x t−1 ) = P (y t−1 |x 1 , . . . , x t−1 )</formula><p>This says that the total probability mass "received" by y t−1 (based on x 1 , . . . , x t−1 ) must be "transmitted" to labels y t at time t regardless of the value of x t . The only role of x t is to influence which of the labels receive more of the probability at time t. In particular, all of the probability mass must be passed on to some y t even if x t is completely incompatible with y t .</p><p>For example, suppose that there are two labels {1, 2} and that the input string x ="rob" is supposed to get the label string "111" and x ="rib" is supposed to get the label string "222". Consider what happens with the input string x ="rib". After observing the x 1 = r, the probability of y 1 is evenly split between labels "1" and "2": P (y 1 = 1|x 1 = r) = P (y 1 = 2|x 1 = r) = 0.5. After observing x 2 = i, the probability remains equally split, because the 0.5 probability for P (y 1 = 1|x 1 = r) must be passed on to P (y 2 = 1|x 1 = r, x 2 = i), since the y 1 = 1 → y 2 = 2 transition has probability 0. After observing x 3 = b, the probability of y 3 = 1 and y 3 = 2 remains equally split. So the MEMM has completely ignored the "i"! The same problem occurs with the hidden states s t of the IOHMM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Conditional Random Fields</head><p>Lafferty, McCallum, and Pereira <ref type="bibr" target="#b14">[15]</ref> introduced the conditional random field (CRF; Figure <ref type="figure" target="#fig_1">2(d)</ref>) to try to overcome the label bias problem. In the CRF, the relationship among adjacent pairs y t−1 and y t is modeled as an Markov Random Field conditioned on the x inputs. In other words, the way in which the adjacent y values influence each other is determined by the input features.</p><p>The CRF is represented by a set of potentials M t (y t−1 , y t |x) defined as</p><formula xml:id="formula_4">M t (y t−1 , y t |x) = exp   α λ α f α (y t−1 , y t , x) + β λ β g β (y t , x)   ,</formula><p>where the f α are boolean features that encode some information about y t−1 , y t , and arbitrary information about x, and the g β are boolean features that encode some information about y t and x. As with MEMM's and IOHMM's, arbitrarily long-distance information about x can be incorporated into these features.</p><p>As with HMM's, CRF's assume two special labels 0 and K + 1 to indicate the start and end of the sequence. Let M t (x) be the (K + 2) × (K + 2) matrix of potentials for all possible pairs of labels for y t−1 and y t .</p><p>The CRF computes the conditional probability P (y|x) according to</p><formula xml:id="formula_5">P (y|x) = L t=1 M t (y t−1 , y t |x) L t=1 M t (x) 0,K+1</formula><p>, where L is one more than the length of the strings, y 0 = 0, y L = K + 1, and the denominator is the (0, K + 1) entry in the matrix product of the M t potential matrices. The normalizer in the denominator is needed because the potentials M t are unnormalized "scores".</p><p>The training of CRFs is expensive, because it requires a global adjustment of the λ values. This global training is what allows the CRF to overcome the label bias problem by allowing the x t values to modulate the relationships between adjacent y t−1 and y t values. Algorithms based on iterative scaling and gradient descent have been developed both for optimizing P (y|x) and also for separately optimizing P (y t |x) for loss functions that depend only on the individual labels.</p><p>Lafferty, et al. compared the performance of the HMM, MEMM, and CRF models on a part-of-speech tagging problem. For a basic configuration, in which the MEMM and CRF features were defined to provide the same information as the HMM, the error rates of the three methods were HMM: 5.69%, MEMM: 6.37%, and CRF: 5.55%. This is consistent with the hypothesis that the MEMM suffers from the label bias problem but the HMM and the CRF do not. Lafferty et al. then experimented with providing a few simple spelling-related features to the MEMM and CRF models, something that is impossible to incorporate into the HMM. The resulting error rates where MEMM: 4.81% and CRF: 4.27%. Even more dramatic results are observed if we consider only "out of vocabulary" words (i.e., words that did not appear in any training sentence): HMM: 45.99%, MEMM: 26.99%, CRF: 23.76%. The spelling-related features provide powerful information for describing out of vocabulary words, whereas the HMM must rely on default observation probabilities for these words.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Graph Transformer Networks</head><p>In a landmark paper on handwritten character recognition, LeCun, Bottou, Bengio, and Haffner <ref type="bibr" target="#b15">[16]</ref> describe a neural network methodology for solving complex sequential supervised learning problems. The architecture that they propose is shown in Figure <ref type="figure" target="#fig_2">3</ref>. A graph transformer network is a neural network that transforms an input graph into an output graph. For example, the neural network in the figure transforms an input graph, consisting of the linear sequence of x t , into an output graph, consisting of a collection of u t values. Each x t is a feature vector attached to an edge of the graph; each u t is a pair of a class label and a score. The Viterbi transformer analyzes the graph of u t scores and finds the path through the graph with the lowest total score. It outputs a graph containing only this path, which gives the predicted y t labels.</p><p>The architecture is trained globally by gradient descent. In order to do this, each graph transformer must be differentiable with respect to any internal tunable parameters. LeCun et al. describe a method called discriminative forward training that adjusts the parameters in the neural network to reduce the score along paths in the u graph corresponding to the correct label sequence y and to increase the scores of the other paths. An advantage of this approach is that arbitrary loss functions can be connected to the output of the Viterbi transformer, and the network can be trained to minimize the loss on the training data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Concluding Remarks</head><p>Sequential supervised learning problems arise in many applications. This paper has attempted to describe the sequential supervised learning task, discuss the main research issues, and review some of the leading methods for solving it. The four central research issues are (a) how to capture and exploit sequential correlations, (b) how to represent and incorporate complex loss functions, (c) how to identify long-distance interactions, and (d) how to make the learning algorithms fast. Our long-term goal should be to develop a toolkit of off-theshelf techniques for sequential supervised learning. Although we are still some distance from this goal, substantial progress has already been made, and we can look forward to more exciting work in the near future.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Two recurrent network architectures: (a) outputs are fed back to hidden units; (b) hidden units are fed back to hidden units. The ∆ symbol indicates a delay of one time step.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Probabilistic models related to hidden Markov models: (a) HMM, (b) maximum entropy Markov model, (c) input-output HMM, and (d) conditional random field</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. The GTN architecture containing two graph transformers: a neural network and a Viterbi transformer.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>left-to-right and right-to-left.</figDesc><table><row><cell></cell><cell>Direction of</cell><cell cols="2">% correct</cell></row><row><cell></cell><cell>letter</cell><cell cols="2">Level of Aggregation</cell></row><row><cell>Method</cell><cell>processing</cell><cell>Word</cell><cell>Letter</cell></row><row><cell>Sliding Window</cell><cell></cell><cell>12.5</cell><cell>69.6</cell></row><row><cell cols="2">Recurrent Sliding Window Left-to-Right</cell><cell>17.0</cell><cell>67.9</cell></row><row><cell cols="2">Recurrent Sliding Window Right-to-Left</cell><cell>24.4</cell><cell>74.2</cell></row></table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Achieving high-accuracy text-to-speech with machine learning</title>
		<author>
			<persName><forename type="first">G</forename><surname>Bakiri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">G</forename><surname>Dietterich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Data Mining Techniques in Speech Synthesis</title>
				<editor>
			<persName><forename type="first">R</forename><forename type="middle">I</forename><surname>Damper</surname></persName>
		</editor>
		<meeting><address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<publisher>Chapman and Hall</publisher>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Input-output HMM&apos;s for sequence processing</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Frasconi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Neural Networks</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1231" to="1249" />
			<date type="published" when="1996-09">September 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Classification and Regression Trees</title>
		<author>
			<persName><forename type="first">L</forename><surname>Breiman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Friedman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Olshen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Stone</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984">1984</date>
		</imprint>
		<respStmt>
			<orgName>Wadsworth International Group</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Approximating discrete probability distributions with dependence trees</title>
		<author>
			<persName><forename type="first">C</forename><surname>Chow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="462" to="467" />
			<date type="published" when="1968">1968</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">An Introduction to Support Vector Machines</title>
		<author>
			<persName><forename type="first">N</forename><surname>Cristianini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shawe-Taylor</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Maximum-likelihood from incomplete data via the EM algorithm</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Dempster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">M</forename><surname>Laird</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Rubin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Royal Stat. Soc</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="1" to="38" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Finding structure in time</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Elman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cognitive Science</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="179" to="211" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Adaptive fraud detection. Knowledge Discovery and Data Mining</title>
		<author>
			<persName><forename type="first">T</forename><surname>Fawcett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Provost</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="291" to="316" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Special issue on dynamic recurrent neural networks</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Giles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Kuhn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Neural Networks</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Ridge regression: biased estimation of nonorthogonal components</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">E</forename><surname>Hoerl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Kennard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Technometrics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="55" to="67" />
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Serial order: A parallel distributed processing approach</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Jordan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICS Rep</title>
				<imprint>
			<publisher>UC San Diego</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">8604</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Wrappers for feature subset selection</title>
		<author>
			<persName><forename type="first">Ron</forename><surname>Kohavi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><forename type="middle">H</forename><surname>John</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">97</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="273" to="324" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Toward optimal feature selection</title>
		<author>
			<persName><forename type="first">Daphne</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mehran</forename><surname>Sahami</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 13th Int. Conf. Machine Learning</title>
				<meeting>13th Int. Conf. Machine Learning</meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="284" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Overcoming the myopic of inductive learning algorithms with RELIEFF</title>
		<author>
			<persName><forename type="first">Igor</forename><surname>Kononenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edvard</forename><surname>Šimec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marko</forename><surname>Robnik-Šikonja</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Applied Intelligence</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="39" to="55" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Conditional random fields: Probabilistic models for segmenting and labeling sequence data</title>
		<author>
			<persName><forename type="first">John</forename><surname>Lafferty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Mccallum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fernando</forename><surname>Pereira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conf. Machine Learning</title>
				<meeting><address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Gradient-based learning applied to document recognition</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bottou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Haffner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the IEEE</title>
		<imprint>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="2278" to="2324" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Hoeffding races: Accelerating model selection search for classification and function approximation</title>
		<author>
			<persName><forename type="first">Oded</forename><surname>Maron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><forename type="middle">W</forename><surname>Moore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Adv. Neural Inf. Proc. Sys</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="59" to="66" />
			<date type="published" when="1994">1994</date>
			<publisher>Morgan Kaufmann</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Maximum entropy Markov models for information extraction and segmentation</title>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Mccallum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dayne</forename><surname>Freitag</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fernando</forename><surname>Pereira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conf. on Machine Learning</title>
				<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="591" to="598" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">M</forename><surname>Mitchell</surname></persName>
		</author>
		<title level="m">Machine Learning</title>
				<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>McGraw-Hill</publisher>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Predicting the secondary structure of globular proteins using neural network models</title>
		<author>
			<persName><forename type="first">N</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Sejnowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Molecular Biology</title>
		<imprint>
			<biblScope unit="volume">202</biblScope>
			<biblScope unit="page" from="865" to="884" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">C4.5: Programs for machine learning</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Quinlan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Morgan Kaufmann</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Learning internal representations by error propagation</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Rumelhart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Parallel Distributed Processing -Explorations in the Microstructure of Cognition</title>
				<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="318" to="362" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Parallel networks that learn to pronounce english text</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Sejnowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Rosenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Complex Systems</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="145" to="168" />
			<date type="published" when="1987-02">February 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Generalization by weightelimination with application to forecasting</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Weigend</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Rumelhart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Huberman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Adv. Neural Inf. Proc. Sys</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="875" to="882" />
			<date type="published" when="1991">1991</date>
			<publisher>Morgan Kaufmann</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
