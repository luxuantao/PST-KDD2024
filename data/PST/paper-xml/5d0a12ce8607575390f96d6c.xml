<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">CECI: Compact Embedding Cluster Index for Scalable Subgraph Matching</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Bibek</forename><surname>Bhattarai</surname></persName>
							<email>bhattarai_b@gwu.edu</email>
						</author>
						<author>
							<persName><forename type="first">Hang</forename><surname>Liu</surname></persName>
							<email>hang_liu@uml.edu</email>
							<affiliation key="aff3">
								<orgName type="department">Work done at George</orgName>
								<orgName type="institution">Washington University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">H</forename><forename type="middle">Howie</forename><surname>Huang</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">George Washington University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University of Massachusetts Lowell</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">George Washington University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<address>
									<addrLine>16 pages</addrLine>
									<postCode>2019</postCode>
									<settlement>Amsterdam, New York</settlement>
									<region>Netherlands. ACM, NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">CECI: Compact Embedding Cluster Index for Scalable Subgraph Matching</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/3299869.3300086</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T14:01+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>subgraph listing</term>
					<term>subgraph matching</term>
					<term>graph pattern matching</term>
					<term>subgraph isomorphism</term>
					<term>CECI</term>
					<term>extreme cluster</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Subgraph matching finds all distinct isomorphic embeddings of a query graph on a data graph. For large graphs, current solutions face the scalability challenge due to expensive joins, excessive false candidates, and workload imbalance. In this paper, we propose a novel framework for subgraph listing based on Compact Embedding Cluster Index (CECI), which divides the data graph into multiple embedding clusters for parallel processing. The CECI system has three unique techniques: utilizing the BFS-based filtering and reverse-BFSbased refinement to prune the unpromising candidates early on, replacing the edge verification with set intersection to speed up the candidate verification, and using search cardinality based cost estimation for detecting and dividing large embedding clusters in advance. The experiments performed on several real and synthetic datasets show that the CECI system outperforms state-of-the-art solutions on average by 20.4× for listing all embeddings and by 2.6× for enumerating the first 1,024 embeddings.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Given a query graph G q and a data graph G, subgraph listing is a problem of finding all the subgraphs of G that are isomorphic to G q . As an example in Figure <ref type="figure">1</ref>, subgraph listing for the query graph {u 1 , u 2 , u 3 , u 4 , u 5 } finds two possible matches in the data graph, i.e., {v 1 , v 3 , v 4 , v 11 , v 12 } and {v 1 , v 5 , v 6 , v 13 , v 14 }. Note that this paper uses the terms subgraph matching and subgraph listing interchangeably. This NP-hard problem is important in many application domains including sub-compound search in chem-informatics <ref type="bibr" target="#b53">[54]</ref>, analysis of protein-protein interaction networks <ref type="bibr" target="#b43">[44]</ref>, computer aided design <ref type="bibr" target="#b40">[41]</ref>, and graph pattern mining <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b50">51]</ref>. Although many techniques such as search order optimization <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b45">46,</ref><ref type="bibr" target="#b58">59]</ref>, join cardinality reduction <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b49">50]</ref>, and index based filtering <ref type="bibr" target="#b51">[52,</ref><ref type="bibr" target="#b56">[57]</ref><ref type="bibr" target="#b57">[58]</ref><ref type="bibr" target="#b58">[59]</ref> have been developed in recent times, subgraph matching for large graphs still faces three main challenges.</p><p>First, scalability has been an Achilles heel for existing solutions, the majority of which adopt one of the two approaches, one embedding at a time listing <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b41">42,</ref><ref type="bibr" target="#b53">54]</ref> or all embeddings at once listing <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b46">47</ref>]. An embedding is a unique subgraph of the data graph that matches the query graph. While the former requires small amount of memory for intermediate results, this strictly sequential approach is not viable for larger graphs. Instead of listing all embeddings, most current solutions return the first 1,000 or so embeddings. On the other hand, relying on parallel computing frameworks such as MapReduce, the latter approach aims to process all the embeddings concurrently. However, exponential memory consumption and expensive join operation makes their performance vastly unsatisfactory.</p><p>Second, existing algorithms spend a considerable amount of time working on false candidates that yield no embeddings in the end. For example, join based listings <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b49">50]</ref>  decompose the query graph into several sub-patterns, collect the candidates for each sub-pattern, and join them to form the complete embedding. This approach suffers from false cardinality because it cannot limit the join operations to true candidates only <ref type="bibr" target="#b49">[50]</ref>. In contrast, exploration based approaches <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b49">50,</ref><ref type="bibr" target="#b53">54]</ref> list the embeddings by exploring the data graph from predetermined nodes in a specific order. While it avoids the false cardinality associated with joins, this approach suffers from exploring false search paths, leading to incomplete backtracking branches especially when the query graph becomes non-trivial.</p><p>The third challenge arises from the power law nature of the real world graphs. This imposes a huge disparity in workload distribution among different machines while parallelizing the solution. Among several projects that have attempted to address this issue, PsgL <ref type="bibr" target="#b46">[47]</ref> chooses a worker machine for each intermediate embedding after every expansion, which is an overkill in the sense that it needs to calculate the cost and make a machine selection for every incomplete embedding. In comparison, TTJ <ref type="bibr" target="#b31">[32]</ref> uses a nodedegree-based threshold to reduce the workload skew. This approach is less costly, however, node degree alone is insufficient to achieve insightful workload estimation. We believe that a workload balancing method that provides a good tradeoff between computation overhead and workload balance is of essence to scale subgraph listing.</p><p>To address these challenges, we utilize a new concept of embedding cluster, which is a special subgraph of the data graph. An embedding cluster contains a group of the embeddings which share the same data node (pivot node) as a match of the first query node for a given matching order. For simplicity, we have used the Breadth-first search (BFS) order as the matching order, but our methods work with any other matching orders. In this paper, we use the terms node and vertex interchangeably, and data node and query node are used to refer to a node in the data and query graph, respectively. A data graph may have a number of embedding clusters and each cluster may contain several distinct embeddings. For example, in Figure <ref type="figure">1</ref>, there are two  embedding clusters, EC1 and EC2, where the embeddings in EC1 match the pivot node v 1 to the query node u 1 , and in EC2, v 2 to u 1 .</p><p>Traditionally to enumerate the embeddings, one first collects the candidate set for each query node u, i.e. nodes in the data graph that can be matched to u in an isomorphic embedding. For example, {v 1 , v 2 } for u 1 , {v 3 , v 5 , v 7 , v 9 } for u 2 , {v 4 , v 6 , v 8 , v 10 } for u 3 , and so on. Next, each candidate of the query nodes is joined with the candidates of adjacent query nodes, following the matching order in a backtracking fashion. However, even though node v 1 of the data graph is connected to only three candidates {v 3 , v 5 , v 7 } of u 2 and two candidates {v 4 , v 6 } of u 3 , the backtrack search tree still tries to join with all four candidates of both u 2 and u 3 . This leads to a search cardinality of 32, i.e, (4 × 4 × 2).</p><p>With the help of embedding clusters, we can now separate the candidates of the query nodes by different pivot nodes, reducing the overall search cardinality of subgraph listing. For the same example, two embedding clusters EC1 and EC2 yield a cardinality reduction of more than three times to 10, i.e., (3 × 2 + 2 × 2). Another benefit of embedding clusters is that such clusters naturally become many smaller local computations, which can be worked upon concurrently.</p><p>To incorporate this idea, we design an auxiliary data structure, Compact Embedding Cluster Index (CECI) <ref type="foot" target="#foot_0">1</ref> , which represents all the embedding clusters and is used to facilitate parallel embedding enumeration. Each node in CECI contains all the data nodes that can be matched with a given query node. The size of CECI is polynomial to the size of the data and query graphs, i.e. O(|E q | × |E д |). CECI not only enables listing all the embeddings in parallel but also reduces the number of unpromising candidates significantly.</p><p>Figure <ref type="figure" target="#fig_1">2</ref> shows the workflow of our subgraph listing framework. Two main steps are logical decomposition of the data graph into embedding clusters with BFS order based filtering and reverse BFS based refinement to reduce the amount of false candidates, and parallel embedding enumeration by searching different embedding clusters concurrently. The work distribution is equipped with proactive workload balancing based on cardinality based cost function. We characterize our approach as k embeddings at a time listing, where k different workers enumerate isomorphic subgraphs in parallel from different parts of the data graph, i.e., different embedding clusters.</p><p>The evaluation result on a large variety of real and synthetic datasets shows that our method is able to significantly outperform the state-of-the-art algorithms. Specifically, it computes all isomorphic embeddings faster than DualSim <ref type="bibr" target="#b23">[24]</ref> and PsgL <ref type="bibr" target="#b46">[47]</ref>, on average by 6.08× and 34.82× respectively. Also, it outperforms CFLMatch <ref type="bibr" target="#b3">[4]</ref> and Tur-boIso <ref type="bibr" target="#b16">[17]</ref> by 2.7× and 2.72× to enumerate the first 1,024 embeddings.</p><p>The rest of the paper is organized as follows. Section 2 introduces the problem and the preprocessing steps. Section 3 discusses the CECI creation and refinement, and Section 4 presents parallel embedding enumeration. In Section 6, the experimental results are discussed. Section 7 presents the related work and Section 8 concludes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">BACKGROUND 2.1 Problem Statement</head><p>A graph can be represented as G = (V , E, L) where V is the set of vertices, E ⊆ (V × V ) is the set of all edges and L is the function that assigns one or more labels to each vertex from the set Σ of labels. A graph G sд = (V sд , E sд , L sд ) is a subgraph of G if and only if there exists an injective mapping µ :</p><formula xml:id="formula_0">V sд → V , such that (v 1 , v 2 ) ∈ E sд only if (µ(v 1 ), µ(v 2 )) ∈ E.</formula><p>Further, a subgraph G sд of data graph G is isomorphic to the query graph G q = (V q , E q , L q ), if and only if there exists a bijective function f : V q → V sд such that ∀u ∈ V q , L q (u) ⊆ L sд (f (u)) and ∀(u i , u j ) ∈ E q , (f (u i ), f (u j )) ∈ E sд . All the query graphs are assumed to be a connected, undirected graph, and the data graph can be directed or undirected. The subgraph listing problem is to find all distinct subgraphs G sд of the data graph G that are isomorphic to a query graph G q .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Preprocessing</head><p>Preprocessing is crucial to subgraph listing as it can significantly reduce the memory consumption, as well as the total run-time of the algorithm, up to several orders of magnitude. The necessary preprocessing tasks for subgraph listing are described below. Finding the root query node: Root query node u s is the query node from which one starts the matching process. Intuitively, one prefers the root node to have the smallest number of matches to minimize the number of embedding clusters. Similar to TurboIso <ref type="bibr" target="#b16">[17]</ref>, we choose the root vertex</p><formula xml:id="formula_1">u s based on the cost function u s ← argmin u |candidate(u)| deдree(u)</formula><p>where candidate(u) is all the candidates of u in the data graph G, and deдree(u) is the number of edges of node u. The candidate list of u is obtained by verifying each data node by the label, degree, and neighborhood label count (discussed in Section 3.2). In Figure <ref type="figure">1</ref>, the costs for u 1 , u 2 , u 3 , u 4 , and u 5 are 1, 1.33, 1.25, 2, and 3 respectively. Hence u 1 is chosen as the root query node.</p><p>Generating the query tree: we perform a BFS traversal of the query graph starting from the root query node u s to create a query tree. BFS has been obvious choice for the query tree in several existing works <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b16">17]</ref> because they represent the topology of the query graph accurately and minimize the diameter of the search space. The edges from the query graph that are also present on the query tree are called tree edges (TE). Each tree edge connects a parent node with a child node, where the former appears earlier than the latter in the BFS order. If an edge is on the query graph but not on the BFS tree, it is called non-tree edge (NTE). The BFS query tree shown in Figure <ref type="figure">1</ref>(a) has four tree edges, (u 1 , u 2 ), (u 1 , u 3 ), (u 2 , u 4 ), and (u 3 , u 5 ), as well as two non-tree edges (u 2 , u 3 ) and (u 3 , u 4 ).</p><p>Determining the matching (visit) order, i.e., the sequence of the query nodes to follow when matching them to the data nodes. Several heuristics have been developed over the years such as the least frequent node first <ref type="bibr" target="#b45">[46]</ref>, the least frequent path first <ref type="bibr" target="#b58">[59]</ref>, locally optimized order for each exploration <ref type="bibr" target="#b16">[17]</ref>, and dense region first <ref type="bibr" target="#b3">[4]</ref>. Generally speaking, the order puts more selective query nodes, i.e., the one with fewer candidates earlier to lower the size of intermediate result sets. Also, the next node in order is selected from the neighbors of already selected nodes such that the search space can be limited.</p><p>For the simplicity of illustration, BFS traversal order of the query graph from the root node, i.e., (u 1 , u 2 , u 3 , u 4 , u 5 ) in Figure <ref type="figure">1</ref> is used. Nonetheless, the techniques we have developed in this work can easily adopt other matching orders without the need for a major modification. In our experiments, adopting edge-ranked visit order <ref type="bibr" target="#b52">[53]</ref> or path-ranked order <ref type="bibr" target="#b16">[17]</ref> provided up to 34.5% speedup over using naive BFS matching order. The improvement is more significant on larger query graphs. Breaking automorphism: When multiple query vertices are symmetric to each other, an identical embedding can be listed repeatedly. Formally, such repeated listings of the same embedding are called automorphisms. For example, an embedding of QG1 in Figure <ref type="figure" target="#fig_10">6</ref>(a) can be listed for six times:{{0, 1, 2}, {0, 2, 1}, {1, 2, 0}, {1, 0, 2}, {2, 0, 1}, and {2, 1, 0}}.</p><p>To list each embedding only once, we have combined the concepts proposed by TurboIso <ref type="bibr" target="#b16">[17]</ref> for finding NECequivalence group with ordering based symmetry breaking rules proposed by <ref type="bibr" target="#b15">[16]</ref>. First, we explore the equivalence rules advocated by TurboIso to find similar query vertices   and place them in equivalence groups. For example, the vertices 0, 1, and 2 in QG1 in Figure <ref type="figure" target="#fig_10">6</ref>(a) are equivalent to each other as they have the same label and are connected to the same set of neighbors or with each other. Second, as <ref type="bibr" target="#b15">[16]</ref> suggests, a specific order is enforced within each group to break automorphism. Since the values of the query vertex IDs follow 0 &lt; 1 &lt; 2 in our equivalence group, a matching order of map(0) &lt; map(1) &lt; map(2) should also be enforced in each embedding to eliminate the automorphisms. Finding the cluster pivots, i.e., a set {v s } of data nodes that matches with the root query node u s . Each node in {v s } identifies a distinct embedding cluster. In Figure <ref type="figure">1</ref>, the cluster pivots for EC1 and EC2 are v 1 and v 2 , from which parallel graph exploration starts to create CECI as we will discuss shortly.</p><formula xml:id="formula_2">5 v 1 v 7 v 3 v 5 v 7 v 3 v 13 v 15 v 11 v 6 v 1 v 4 v 3 v 4 v 5 v 7 v 4 v 6 v 6 v 11 v 13 v 4 v 6 v 6 v 4 v 14 v 12 v 1 v 2 v 9 v 2 v 7 v 8 v 2 v 8 v 5 v 1 v 7 v 3 v 5 v 7 v 3 v 13 v 15 v 11 v 6 v 1 v 4 v 3 v 4 v 5 v 7 v 4 v 6 v 6 v 11 v 13 v 4 v 6 v 6 v 4 v 14 v 12 v 1 v 5 v 1 v 3 v 5 v 3 v 13 v 11 v 6 v 1 v 4 v 3 v 4 v 5 v 4 v 6 v 11 v 13 v 4 v 6 v 6 v 4 v 14 v 12</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">CECI CREATION, FILTERING, AND REFINEMENT</head><p>This section discusses the techniques to find the candidates, i.e. potential matches of each query node. The candidates undergo several filtering and refinement stages so that the number of false candidates in the verification stage is as small as possible. By traversing the data graph following the BFS traversal order, we create the embedding clusters in form of CECI from the data graph, which accurately captures the topological structure and connectivity of the query graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">CECI Structure</head><p>Given the query tree T q of a query graph G q , CECI represents a data graph G in the structure similar to T q , where each node in CECI contains the set of data nodes that are the candidates of the corresponding query node u. Each query node u has a tree edge connecting it with its parent u p . Each CECI node consists of tree edge candidates (TE_Candidates), which are key-value pairs of &lt;v p , {v}&gt;, where v p is the candidate of u p and {v} is the set of candidates of u that are adjacent to v p .</p><p>Figure <ref type="figure">3</ref> shows the CECI for the query graph and the data graph from Figure <ref type="figure">1</ref>. For the tree edge (u 1 , u 2 ), the TE_Candidates consist of &lt;v 1 , {v 3 , v 5 , v 7 }&gt; and &lt;v 2 , {v 7 , v 9 }&gt;. In other words, the edges (v 1 , v 3 ), (v 1 , v 5 ), (v 1 , v 7 ), (v 2 ,v 7 ), and (v 2 ,v 9 ) are candidates of the query edge (u 1 , u 2 ).</p><p>If there is a non-tree edge incident upon it, a CECI node contains the non-tree edge candidates (NTE_Candidates), which are also key-value pairs, &lt;v n , {v}&gt;. For a non-tree edge (u n , u), v n is the candidate of a query node u n , an NTE neighbor of u, and {v} is candidate set of u that are adjacent to v n . For the non-tree edge (u 2 , u 3 ) in our example, the NTE_Candidates are &lt;v 3 , {v 4 }&gt;, &lt;v 5 , {v 4 , v 6 }&gt;, and &lt;v 7 , {v 6 }&gt;.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">CECI Creation and BFS Based Filtering</head><p>Following the BFS traversal order, we explore the data graph starting from the pivot nodes level by level to obtain the candidates of each query node. Algorithm 1 presents the steps for creating the TE_Candidates of CECI. The NTE_Candidates can be computed in a similar fashion.</p><p>For each node u in the query tree, we first determine the frontiers, i.e., the set of nodes from which we expand the CECI. The union of TE_Candidates of node u p (the parent of u) on CECI generates such frontier set (line 3). In Figure <ref type="figure">3(a)</ref>, the parent of the query node u 4 is u 2 , whose TE candidates are {v 3 , v 5 , v 7 } and {v 7 , v 9 }. The union of these sets produces the frontiers {v 3 , v 5 , v 7 , v 9 }. Note that v 9 is not expanded because it is removed by filtering before we explore u 4 . If the parent is the root query node, the frontiers are the cluster pivots. In Figure <ref type="figure">3</ref>(a), for query node u 2 and u 3 , the frontiers for their parent u 1 consist of nodes v 1 and v 2 .</p><p>For each frontier node v f , CECI applies four filters to its neighbor nodes N (v f ). First, a label filter (LF) collects adjacent nodes {v} of v f that have the label of u (line 5) i.e., the nodes with different labels are removed. In our example, query nodes u 2 and u 3 have labels B and C respectively. For u 2 , data nodes {v 3 , v 5 , v 7 } adjacent to v 1 and {v 7 , v 9 } adjacent to v 2 are selected as they have label B. Similarly for u 3 , data Algorithm 1: TE_Candidates Construction and Filtering.</p><p>Input: T q , and G Output: TE_Candidates and Frontiers of CECI 1 function BFSFilter (T q , G)</p><formula xml:id="formula_3">2 forall u ∈ T q in BFS order do 3 CECI[u p ].Frontiers=∪ CECI[u p ].TE_Candidates 4 forall v f ∈ CECI[u p ].Frontiers do // Label Filter 5 LF (N (v f ), L q (u)) // Degree Filter 6 D F (u, v) // Neighborhood Label Count Filter 7 N LC F (u, v) 8 CECI[u].TE_Candidates[v f ].add(v) // No Tree Edge Candidate 9 if (|CECI[u].TE_Candidates[v f ]| = 0) then 10 CECI[u p ].Frontiers.delete(v f ) 11 forall u c ∈ children of u p do 12 CECI[u c ].TE_Candidates.delete(v f ) 13</formula><p>return TE_Candidates nodes {v 4 , v 6 } adjacent to v 1 and {v 8 } adjacent to v 2 have label C. Note that v 8 will later be removed by NLC filter. Next, for each selected candidate v, we apply lightweight degree filter (DF) and then more expensive neighborhood label count filter (NLCF) on the remaining candidates (line 6 -8). The former ensures that the degree of data node v is larger than or equal to that of the query node u, and the latter requires that the count count v (l) of label l nodes in the neighborhood of v must be equal to or greater than the count u (l) for all distinct labels l in the neighborhood of u. If v passes all these filters, it is added to the value set for the key-value pair &lt;v p , {v}&gt; on the TE_Candidates of the node u. For example, the nodes v 3 , v 5 , v 7 , v 9 on candidate of u 2 have degree no less than that of u 2 , i.e., 3 and have at least one adjacent nodes with labels A, C, and D each. Thus, all of them are retained on TE_Candidates. For u 3 , the nodes {v 4 , v 6 } have degree 5 and have each A, B, D, and E labeled node in the neighborhood. However, {v 8 } is filtered out because v 8 does not have label E node among its neighbors.</p><p>The last filter (line 9 -12) is based on the fact that if the TE_Candidates for node u has no entry for key v p , then there will be no embedding that matches v p to u p . Therefore, CECI removes v p from the candidates of u p , and the TE_Candidates corresponding to v p from all children of u p . In our example, after the first three filters, the TE_Candidates of u 3 for key v 2 becomes empty, thus we remove the node v 2 from the candidates of u 1 and the entry corresponding to v 2 from TE_Candidates of u 2 .</p><p>For the construction of NTE_Candidates, for each nontree edge, the node appearing earlier in the matching order acts as the parent and the other as child. The expansion starts from the frontiers of parent node which can be obtained by the union of TE_Candidates and NTE_Candidates for the parent node, and follows the similar steps as in Algorithm 1. For node u 3 in our example, the non tree edge (u 2 , u 3 ) finds its NTE_Candidates by expanding the frontiers of u 2 , i.e. {v 3 , v 5 , v 7 }. The nodes {v 4 } adjacent to v 3 , {v 4 , v 6 } adjacent to v 5 , and {v 6 , v 8 } adjacent to v 7 pass the Label filter. Later, v 8 is pruned as it does not pass NLCF. The resulting NTE_Candidates are &lt;v 3 , {v 4 }&gt;, &lt;v 5 , {v 4 , v 6 }&gt; and &lt;v 7 , {v 6 }&gt;.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Reverse BFS Based Refinement</head><p>The BFS order based exploration to create TE_Candidates and NTE_Candidates only filters a portion of the unpromising candidates. This section introduces a reverse BFS ordered refinement to further prune them. The key idea here is to focus on the child nodes, in contrast to the parent node in filtering. Refinement traverses the CECI created in the previous section in the reverse BFS order, e.g., (u 5 , u 4 , u 3 , u 2 , u 1 ) in our example, and removes the disqualified candidates.</p><p>To facilitate the refinement, we calculate the cardinality for each candidate of a given query node, which also acts as the cost function for the given query and data node pair (u, v). The cardinality for (u, v) represents the maximum possible number of embeddings that can be obtained by matching v with u. The cardinality for the candidates of leaf query nodes, i.e., degree one nodes in the query tree, are one. For other query nodes, the cardinality (u, v) for a query node u and a data node v is obtained from the cardinalities of their children.</p><p>Formally, cardinality can be represented as</p><formula xml:id="formula_4">cardinality (u, v) = u c v c cardinality(u c , v c )</formula><p>Here u c are the children of u in query tree, while v c are nodes adjacent to v that are candidates of u c . For a given u c , the list {v c } is the list of the nodes that are in TE_Candidates of u c for key of v and also in the NTE_Candidates of u c . This algorithm works iteratively from leaf nodes to root query node eventually finding the cardinality for every query node on CECI.</p><p>In Figure <ref type="figure">3</ref>(b), the cardinalities of nodes {v 11 , v 13 , v 15 } and {v 12 , v 14 } in TE_Candidates of u 4 and u 5 are all one, as these two nodes are leaves in T q . For u 2 , the cardinality of v 3 and v 5 are one, as they have one node each as their child i.e., on TE_Candidates of u 4 . However, the cardinality of v 7 is zero since its only child v 15 is not in the NTE_Candidates of u 4 .</p><p>The process of CECI refinement is illustrated in Algorithm 2. If the cardinality of pair (u, v) is zero, that means the node v is guaranteed not to match u and hence should be removed from TE_Candidates as well as NTE_Candidates of u. In addition, the entry of v from TE_Candidates and NTE_Candidates of all children (including non tree edge neighbors) of u also has to be removed. In our example, we remove v 7 from the candidates of u 2 . Also, the &lt;v 7 , {v 6 }&gt; entry from NTE_Candidates of u 3 is removed although it has the valid cardinality of one for v 6 . Figure <ref type="figure">3</ref>(c) shows the CECI after refinement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Time and Space Complexity</head><p>The size of CECI for a data and query graph pair is O(|E q | × |E д |). Intuitively, for each edge in the query graph, at most all the edges in the data graph can be its candidates. The space complexity of index for TurboIso <ref type="bibr" target="#b16">[17]</ref> and CFLMatch <ref type="bibr" target="#b3">[4]</ref> are O(|E д | |V q |−1 ) and O(|V q | × |E д |) respectively. Compared to CFLMatch, CECI incurs higher space cost due to the inclusion of NTE_Candidates, but it accelerates the embedding enumeration process. The time complexity of CECI creation and refinement is O(|E q | × |E д |).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Correctness</head><p>The CECI created is complete, i.e., for every pair of nodes u and u p in the query graph, if there is an embedding of the query graph on the data graph that maps v to u and v p to u p , then &lt; v p , v &gt; is guaranteed to be in either the TE_Candidates or the NTE_Candidates of node u on CECI, contingent upon whether (u p , u) is a tree or non-tree edge.</p><p>Lemma 1: Given a complete CECI, all embeddings of a query G q in a data graph G can be computed by traversing all embedding clusters in CECI.</p><p>First, every edge contained on TE_Candidates or NTE_Candidates is also an edge in G. Second, every candidate edge that is removed during CECI creation and refinement is guaranteed not to match the corresponding query edge. The former ascertains that every embedding found by exploring CECI is a true embedding from the data graph, while the latter ensures that no legitimate candidates are eliminated during refinement and filtering.</p><p>The complete CECI may not be minimal. A minimal CECI is the one where TE_Candidates and NTE_Candidates only contain the candidates that are guaranteed to be part of at least one embedding. Obtaining the complete and minimal candidate CECI is an NP-hard problem <ref type="bibr" target="#b3">[4]</ref>. Thus, our work only provides the completeness guarantee, i.e., all the embeddings in the data graph can be found by exploring CECI. Since there can be false candidates for some query vertices in non-minimal CECI, we need further verification while enumerating the embeddings. In particular, Section 4 discusses our set intersection based embedding enumeration technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Implementation</head><p>The TE_Candidates and NTE_Candidates for the given query node u are constructed using C++ STL vectors, where each element of the vector holds a pair. The first part of the pair (key) is a scalar, node v f from frontier of the parent query node u p . The second part of the pair (value) is an STL vector, which holds all candidates of u that are adjacent to the key. The lists, once constructed are sorted by key so that lookup algorithms like binary search and lower bound can be used <ref type="bibr" target="#b38">[39]</ref>.</p><p>The filtering and refinement has been parallelized using OpenMP. In the BFS ordered filtering, TE_Candidates and NTE_Candidates are calculated by expanding the frontiers which are dynamically distributed among the threads using traditional pull-based workload distribution model. Allowing each thread to write the TE_Candidates or NTE_Candidates creates serialization in writing. To solve the problem, an intermediate private bin is created for each thread, and they are merged only when all the frontier nodes are expanded. Similarly, during the reverse BFS exploration, the nodes on TE_Candidates are distributed among multiple thread dynamically. To reduce the workload skew, if a certain frontier node has degree more than a predefined threshold (1M by default), it is broken down to multiple pieces and fed to different workers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">PARALLEL EMBEDDING ENUMERATION</head><p>CECI generated in Section 3 is a collection of embedding clusters, each of which has different size as determined by the cardinality defined in Section 3.3. Figure <ref type="figure" target="#fig_6">4</ref>(a) describes the overall workflow of embedding enumeration using CECI. As Section 4.3 discusses, the large clusters can be further decomposed into smaller sub-clusters. The clusters are assigned to multiple processors and searched upon concurrently. Each processor explores the assigned cluster iteratively starting from its pivot following a specific matching order to generate all embeddings. In the running example, we use the BFS matching order, i.e., (u 1 , u 2 , u 3 , u 4 , u 5 ).</p><p>Embedding enumeration in this work is based on set intersection between the TE candidates and NTE candidates. The effectiveness of intersection-based approach for speeding up triangle counting <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b20">21]</ref> motivated us to adopt such technique. This method is different from existing subgraph enumeration solutions <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b16">17]</ref> because they only have auxiliary data structure equivalent to TE_Candidates. Without NTE_Candidates, these solutions only obtain the candidate nodes for each query node, which require further verification in order to confirm the presence of non-tree edges.</p><p>In the example above, after matching v 1 with u 1 and v 3 with u 2 , we get the partial embedding (v 1 , v 3 ). Candidates of u 3 is obtained from TE_Candidates, i.e., {v 4 , v 6 }. Each of these candidate nodes has to have an edge with v 3 , the match for u 2 , in order to get mapped with u 3 . This requires verification of edges (v 3 , v 4 ) and (v 3 , v 6 ) on the data graph.</p><p>Our enumeration starts by mapping the pivot of the embedding cluster to the root query node, e.g., v 1 to u 1 . For a query node u, the TE_Candidates for v p , where v p is the data node mapped to u p , are obtained. Additionally, if node u has nontree edges, then NTE_Candidates for node v n matched with u n are collected. The set intersection between TE_Candidates and NTE_Candidates provides matching nodes {v} that can be mapped to u in the current embedding.</p><p>In the running example, the matching nodes for u 2 are obtained from its TE_Candidates for v 1 , which are {v 3 , v 5 }. Mapping v 3 to u 2 , the matching nodes for u 3 are obtained by intersection of two lists, TE_Candidates of u 3 for v 1 , i.e., {v 4 , v 6 }, and NTE_Candidates of u 3 for v 3 , i.e., {v 4 }, resulting on the matching node {v 4 }.</p><p>Each entry in {v} can be matched with u if it has not been matched with another query node already. The matching node is appended to the current embedding, and the process is repeated for the next query node in the matching order until the embedding is complete or the whole embedding cluster is searched upon. In our example, after matching v 4 to u 3 , the current embedding becomes (v 1 , v 3 , v 4 ,). Repeating the process for u 4 and u 5 gives one complete embedding</p><formula xml:id="formula_5">(v 1 , v 3 , v 4 , v 11 , v 12 ).</formula><p>When an embedding is complete or it can no longer be expanded, the process backtracks to the previous query node in the visit order and repeats the process for its next matching node. In our example, we backtrack back to u 2 , match v 5 to u 2 , and advance again to find the second embedding (v 1 , v 5 , v 6 , v 13 , v 14 ). If the process backtracks back to the root query node, the search on the specific embedding cluster is complete. Figure <ref type="figure" target="#fig_6">4(b)</ref> shows the workflow of this process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Benefits of Intersection-Based Method</head><p>In addition of having to keep both data graph and auxiliary structure in memory, edge verification is also time costly. Using the adjacency list based graph format, to check whether there is an edge between nodes v x and v y , it requires a runtime proportional to the degree of v x or v y whichever is the smaller. Even if the adjacency list is sorted, the run-time reduces to log of that degree. To overcome this overhead, CFLMatch <ref type="bibr" target="#b3">[4]</ref> uses an adjacency matrix representation (with size |V | × |V |) of the data graph, which limits it to small data graphs only.</p><p>Lemma 2: The cost of intersection based enumeration is always less than or equal to using edge verification.</p><p>Let's consider a non-tree edge connecting u i and u j with m and n candidates respectively. The cost of edge verification is m ×n multiplied with the cost of verifying each edge. With O(n) intersection time (sorted adjacency list), the total time for intersection is m × n. Since the intersection result can be readily added into the embedding, the cost is reduced by a factor of average time for edge verification in data graph. Even with the sparse matrix representation i.e., constant time for edge verification, intersection based approach will outperform edge verification by a constant factor.</p><p>Adopting intersection based enumeration provides average improvement of 13% to 170% on run-time for query graphs listed in Figure <ref type="figure" target="#fig_10">6</ref>. The speedup is higher for the query graphs with larger number of non-tree edges.  Naturally, we can now employ multiple machines (workers) to perform subgraph listing on each of these subgraphs, i.e, embedding clusters. These embedding clusters are identified uniquely by their pivot nodes.</p><p>Considering each cluster as a single work unit, the naive approach to distribute the total work is to assign an equal number of embedding clusters to each worker. This approach is referred to as static (ST) workload distribution, since there is no re-adjustment of the workload once it is assigned. In Figure <ref type="figure" target="#fig_8">5</ref>, there are two clusters EC1 and EC2. If we have two workers available, it will assign one cluster to each worker.</p><p>Due to the power law nature of real world graphs, the static distribution suffers from huge disparity among the clusters in term of workload. The obvious solution is to adopt a dynamic workload distribution to supply variable number of embedding clusters to different workers depending on the size of each cluster. We have used a classical pull-based dynamic workload balancing model <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b26">27]</ref>, which allows each worker to start with a certain number of clusters and can request an additional cluster. This approach is called coarse grained dynamic (CGD) due to its cluster level granularity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Handling Extreme Clusters</head><p>In CECI, we aim to identify ExtremeCluster which are large embedding clusters that dominate the total subgraph listing time ahead of the time. If assigned to a single machine, these clusters would largely limit the speedup of parallel processing. For example, in Figure <ref type="figure" target="#fig_8">5</ref>, cluster EC2 contains nine of the total ten embeddings. Assigning EC2 to one worker would limit the maximum parallelization speedup to 1.11.</p><p>At this point, we advocate the use of cardinality calculated during CECI refinement in Section 3.3. Recall that the cardinality is defined for each pair (u, v) between query node u and data node v. It represents the maximum number of embeddings that can be obtained by matching v with u. Following this convention, the cardinality for the root query node and pivot (u s , v s ) gives the maximum number of embeddings possible on a given embedding cluster. In Figure <ref type="figure" target="#fig_8">5</ref>, the total cardinality for (u 1 , v 1 ) and (u 1 , v 4 ) are 1 and 9 respectively, which reflects the total embeddings on clusters EC1 and EC2.</p><p>We empirically choose a parameter β, and flag a given cluster as ExtremeCluster if the cardinality of that cluster is greater than the threshold of β × cardinality exp , where cardinality exp is the expected workload per worker. If a cluster is found to be ExtremeCluster, it is decomposed into several sub-clusters, each of which must have a cardinality less than the threshold β × cardinality exp . The sub-clusters are further decomposed if it is an ExtremeCluster. Algorithm 3 describes the routine for decomposing the ExtremeClusters. Conceptually, if we detect an ExtremeCluster while matching node v to query node u (line 8-10), the expansion of v to the next query node u nex t in the matching order is accomplished using multiple workers. First, the matching nodes for u nex t adjacent to v are obtained from its TE_candidates and NTE_Candidates (line 13). For each entry v ′ in matching nodes, effective workload is calculated as</p><formula xml:id="formula_6">car dinal ity(u ne x t ,v ′ ) t ot al (v ′ )</formula><p>× cardinality(u, v), where total(v ′ ) is the sum of cardinalities of all the matching nodes. If workload of v ′ is greater than β × cardinality exp , the function is called again recursively.</p><p>In Figure <ref type="figure" target="#fig_8">5</ref>, let us assume β = 1 and the number of workers k = 2. Then the threshold β × cardinality exp = 5 which means cardinality(u 1 , v 4 ) = 9 is greater than the threshold, therefore EC2 is broken down into three sub-clusters with respect to three matching nodes of u 2 in that cluster. After decomposition, all three sub-clusters have a cardinality of 3, i.e, smaller than the threshold. Those three sub-clusters along with EC1 is then distributed between two workers. This distributed solution will be referred as fine-grained distributed (FGD) in subsequent sections.</p><p>The value of β provides a trade-off between workload balance obtained and overhead for doing so. A smaller β increases one time cluster decomposition cost, but provides more balanced workload distribution. To smooth the finishing time of different threads, we sort the clusters and sub-clusters in the work pool by cardinality. This allows the larger clusters to be searched earlier and keeps small clusters in the end.</p><p>Note that the cardinality overestimates the total number of embeddings present on each embedding cluster. However, it still serves as an effective reflection of workload because larger embedding clusters in general tend to have bigger number of isomorphic embeddings, and the clusters that do not follow above-mentioned trend contain high false candidate count which needs verification before discarding them thereby increasing the amount of work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">DISTRIBUTED IMPLEMENTATION</head><p>In addition to a multi-threaded (OpenMP) version, we have implemented the CECI system on a distributed-memory cluster (with OpenMP and MPI). To manage the graph data in the cluster, two methods have been explored: replicating the whole data graph on the memory of each machine (inmemory data graph), and storing the graph on a lustre file system, shared by several compute machines (shared data graph). Efficient decomposition of graph into different machines is a non-trivial problem and is left out for now.</p><p>In the first approach, all machines hold the same data and query graph but work on the disjoint set of embedding clusters creating different CECI on each machine. For the second approach, there is only one copy of the data graph shared on the networked storage, in the Compressed Sparse Row (CSR) format <ref type="bibr" target="#b27">[28]</ref>. Each machine uses a beginning_position array to locate the adjacency list for a given vertex. Both methods distribute the cluster pivots to multiple machines by using MPI library's synchronous communication functions MPI_Send and MPI_Recv.</p><p>While distributing pivots {v s } among machines, two major concerns need to be addressed. First, since cardinality is not available before CECI creation, we rely on a lightweighted approximation to balance the workload. In the in-memory setting, the workload for each vertex v is proportional to the sum of degree of v and degree of all neighbors of v. In the second approach, only the degree of a node v is used since the neighbor information is not available. In both cases, the workload is scaled using vertex ID to account for imbalance inflicted by automorphism breaking orders, i.e., effective workload for v is equal to |V |−v  |V | × workload(v). Since CECI creation takes a small portion (&lt;5%) of the total run-time, even such a coarse method is able to deliver an acceptable performance.</p><p>Second, two embedding clusters can overlap with each other (e.g., in Figure <ref type="figure">1</ref>). When highly overlapping clusters fall in different machines, it incurs significantly redundant exploration. We estimate the similarity between two embedding clusters via Jaccard distance. If v i and v j are the pivots of clusters EC i and EC j , respectively, the similarity between these two clusters is</p><formula xml:id="formula_7">J (v i , v j )= N (v i )∩N (v j ) N (v i )∪N (v j ) . If J (v i , v j ) ≥ 0.5,</formula><p>these two clusters will be handled by the same machine provided that the total workload does not exceed the maximum allowed workload. To reduce the overhead of similarity calculation, CECI system only runs similarity measure on the largest 1, 000 clusters (as defined by light-weighted workload). In our second approach, this method cannot be applied as each machine does not have the whole graph.</p><p>During embedding enumeration, the CECI system proceeds as follows: (1) Each machine starts enumeration on embedding clusters from its CECI. These machines also keep record of unexplored clusters in their CECI. ( <ref type="formula">2</ref>) When all the embedding clusters in the local CECI are done, it steals the work from the machine with the maximum number of unexplored clusters (victim machine). Work stealing is implemented by using one-directional function MPI_Get. (3) Finally, if needed, the results from all machines are accumulated to a single machine.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EXPERIMENTS</head><p>We have implemented the CECI system with around 3,000 lines of OpenMP, MPI, and C++ code and evaluated it on three different machines. ( <ref type="formula">1</ref>  real graphs while the last one, rand_500k, is a synthetic graph generated by Graph500 Kronecker Generator <ref type="bibr" target="#b14">[15]</ref>. The numbers of vertices and edges range from 0.5 million to 1.5 billion, and 2 million to 12.9 billion, respectively. All real graphs are obtained from Stanford Large Network Dataset Collection <ref type="bibr" target="#b48">[49]</ref>, except Yahoo <ref type="bibr" target="#b54">[55]</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Small Query Graphs</head><p>We have run the experiment to find all embeddings of query graphs QG1 to QG5 from Figure <ref type="figure" target="#fig_10">6</ref> on eight real world datasets.</p><p>Only one automorphism of each embedding is listed by utilizing vertex numbering based automorphism breaking technique as described in Section 2.2. The performance numbers of DualSim are quoted from their paper <ref type="bibr" target="#b23">[24]</ref>. Although the DualSim paper reports the result for 6-core machine, it is unlikely to achieve very high performance in a machine with higher core count. Its algorithm is IO bound in nature since DualSim iteratively loads a fixed set of disk pages, each of which contains the adjacency list for one node, and runs isomorphism with that set at each time. To achieve better scalability, DualSim needs to process the whole graph together, which will result in an exponential memory requirement. We implemented PsgL (for optimal setting α = 0.5) on shared memory using OpenMP. Hence, the communication overhead for PsgL is minimized.</p><p>Figure <ref type="figure" target="#fig_11">7</ref> compares the performance of the CECI system with state-of-the-art solutions -DualSim <ref type="bibr" target="#b23">[24]</ref> and PsgL <ref type="bibr" target="#b46">[47]</ref> on QG1 and QG4. The run-time reported here includes the time for preprocessing, CECI creation, and enumeration of the embeddings. The last step takes more than 95% of the total run-time.</p><p>On average, our system outperforms DualSim and PsgL by 1.86× and 4.08× respectively for QG1 and 4.54× and 14.31× respectively for QG4. For QG1, we obtain the highest speedup of 4.8× on LJ and 22.6× on WT against DualSim and PsgL respectively. Similarly, for QG4, the highest speedup is 12.8× on CP and 63.7× on WT.</p><p>Figure <ref type="figure" target="#fig_12">8</ref> shows the performance of CECI system against DualSim and PsgL for three remaining query graphs on WG, WT and LJ data graphs. The average speedup of 19.7×, 49.3×, and 86.7× is obtained over PsgL on QG2, QG3 and QG5 respectively. Similarly, the average speedup of 2.5×, 1.7×, and 19.8× is obtained against DualSim. We omit the other bigger data graphs because PsgL cannot finish the query in an extensively long period of time (days) and the DualSim manuscript does not include the results for those data and query combination. In general, PsgL is slower because it lacks the ability to prune the unpromising paths prior to exhaustive expansion (Figure <ref type="figure" target="#fig_25">18</ref>) and has weaker thread scalability as compared to CECI (Section 6.5) due to exhaustive work distribution method. The speedup over DualSim comes from the better utilization of compute power. Since DualSim loads a set of few slotted pages from graph at a time to run listing algorithm, it incurs multiple IO loads and is able to supply very limited amount of workload in a given time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Larger and Labeled Query Graphs</head><p>In this section, we evaluate CECI system with larger and labeled query graphs. We perform Depth-first search (DFS) traversal of data graphs from random source nodes in order to generate connected query graphs of different size from 3 to 50 nodes similar to existing works <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b49">50]</ref>. Iteratively, a new node is selected and every backward edge from that node to already selected nodes is added to query graph until the required node count is achieved. Thus, at least one isomorphic embedding will be found for each query. For each node count, 100 query graphs are generated.</p><p>First, we compare CECI system with CFLMatch <ref type="bibr" target="#b3">[4]</ref>, a stateof-the-art subgraph matching solution on labeled graphs. However, we restrict the comparison with only two data graphs -RD and HU due to CFLMatch's inability to handle larger data graphs. We randomly inject each node of RD with one of the 100 different labels. HU dataset comes with one or more of 90 different labels on each node. The node labels are transferred to query graph while doing DFS based query generation. If the data node has multiple labels, only the first label is used in the query node. Both CFLMatch and CECI runs single threaded solutions, and only return the first 1,024 embeddings. All of the 100 queries for each size is run for five times and the average of 500 execution is reported. As shown in Figure <ref type="figure" target="#fig_13">9</ref>, CECI system outperforms CFLMatch by average 3.5× and 1.9× on RD and HU graph respectively. The speedup comes mainly from intersection based embedding enumeration. The speedup in HU is smaller than in RD because CFLMatch uses only one label per node for HU while CECI system uses multiple labels. The speedup decreases slightly as the query graph gets larger because CECI system has used naive BFS matching order while CFLMatch has their optimized core-forest-leaf matching order, which offers bigger advantage on larger query graphs.</p><p>Additionally, we compare our solution with TurboIso 2 on the HU graph to find the first 1024 embeddings. Figure <ref type="figure" target="#fig_14">10</ref> shows that our system is on average 2.71× and 2.52× faster than TurboIso and Boosted-TurboIso respectively. The 2 We obtain the source code from authors of BoostIso <ref type="bibr" target="#b44">[45]</ref>, which contains two versions of TurboIso. The first implementation, TurboIso, replicates the works on <ref type="bibr" target="#b16">[17]</ref> while the second version, Boosted-TurboIso, speeds up TurboIso further by exploiting the vertex symmetry in data graph. speedup comes from intersection based enumeration, reduction of redundancy in filtering, and better utilization of tree-edge and non-tree edge connectivities to filter the unpromising candidates early.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Workload Balancing</head><p>This section uses QG1, QG3, and QG5 as the query graphs so that CECI system experiences workload imbalance at various backtracking tree depths: 3, 4 and 5 respectively. The speedup obtained by adopting Coarse Grained Dynamic (CGD), and Fine Grained Dynamic (FGD), against static workload distribution (ST) are measured. The value of β is fixed to 0.2, i.e., the embedding clusters that are larger than one fifth of expected cardinality per thread are ExtremeClusters.</p><p>From Figure <ref type="figure" target="#fig_15">11</ref>, one can see that FGD and CGD techniques clearly outperform ST. FGD is on average 16.8× better than CGD, and CGD is 10.7× faster than ST. In rare cases (WT on QG3), FGD is slightly slower than CGD because those cases do not have ExtremeCluster and treating some clusters as ExtremeCluster increases one time distribution overhead slightly.    Filtering and refinement reduces the size of CECI significantly below the theoretical limit. For example, QG5 and YH pair has theoretical size of 624 GB since |E q | is 6, d | is 12.9 Billion and 8 bytes is used to store each edge. However after usage of BFS filtering and reverse-BFS refinement, the CECI size is only 290 GB, reduced by 2.2×. For larger graphs whose CECI does not fit inside memory, we plan to store it in non-volatile memory <ref type="bibr" target="#b29">[30]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">CECI size</head><p>Among existing solution, CFLMatch <ref type="bibr" target="#b3">[4]</ref>, due to its usage of adjacency matrix based graph representation failed to run data graphs graph larger than 500K nodes on Server 1. Similarly, PsgL <ref type="bibr" target="#b46">[47]</ref> due to its exponential intermediate result sets failed to run on Server 1 for YH graphs, i.e., it needed more than 512 GB. DualSim <ref type="bibr" target="#b23">[24]</ref> masks the problem of exponential memory requirement by loading only a small portion of graph into memory at a time. On the other hand, TurboIso <ref type="bibr" target="#b16">[17]</ref> saves memory by serializing the auxiliary data creation and verification thereby making the solution unsuitable for larger number of embeddings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Scalability</head><p>This part evaluates the scalability of CECI system under both shared and distributed memory settings. The results presented accounts for the time for both CECI creation and embedding enumeration.</p><p>Figure <ref type="figure" target="#fig_19">13</ref> and 14 display the speedup obtained with the increasing number of threads while running QG1 and QG4 respectively on FS and OK on Server 1. We compare the result against speedup on PsgL. CECI system is able to obtain a near linear speedup up to 16 workers. However, the trend slightly flats out beyond 16 threads due to the lack of adequate workload. In general, the better speedup for CECI as compared to PsgL is due to light-weighted workload balancing and better locality on candidate set access.    We evaluate the CPU usage of CECI system over the lifetime of the program. Initially, CPU usage is low since the process is either heavily serialized or dominated by IO loads. During CECI creation, the cpu usage gets only slightly larger due to massive serialization on creating CECI. During embedding enumeration phase, which constitutes more than 95% of the overall execution time, all cores are used to the maximal resulting in near 100% utilization on each core. The scalability of two distributed solutions described in Section 5 is examined on Cluster 1. We vary the machine count from 1 to 16 while running four OpenMP threads on each machine. In general, the distributed systems have speedup curve that flats out earlier as compared to the shared memory setup because of the higher communication overhead. The reason for having flat line beyond 4 machines (each running 4-OpenMP thread) is due to insufficient workload on smaller graphs. Scalability on smaller graphs YT, WT, and LJ had the same effect on the shared memory framework beyond 16 threads. Note that larger graphs OK and FS have much better speedup with more machines.</p><p>Figure <ref type="figure" target="#fig_23">16</ref> shows the speedup of distributed system while the data graph is loaded in the memory of each machine. For 16 machines, we see maximum of 13.72× speedup for QG1 and 14.92 × speedup for QG4 while querying on FS graph. Figure <ref type="figure" target="#fig_24">17</ref> shows the scalability of distributed CECI when the shared data graph is accessed from a lustre file system. Here, the CECI creation overhead increases by a factor up to 100 due to increased IO overhead. However, the parallelization of CECI creation makes the solution scalable and the memory requirement in each compute node is reduced by up to |E|. As a result, we are still able to achieve speedup as high as 12.6 × for QG1 and 13.57× for QG4 with 16 machines.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6">CECI: Advantages and Overheads</head><p>After filtering and refinement, CECI reduces the number of false search paths significantly, more so when the query graph is complex. We compare the number of recursive calls made by CECI against that by PsgL. In backtracking matching algorithm, a new recursive call to matching routine has to be made every time an intermediate match is expanded by one tree-edge. The total number of recursive call is approximation of total search space <ref type="bibr" target="#b32">[33]</ref>. The result in Figure <ref type="figure" target="#fig_25">18</ref> shows up to 44% reduction on the total number of recursive calls. Note that, the benefit increases as the query graph becomes more complex. The overhead for constructing and using CECI for subgraph listing is insignificant as compared to it's benefits. We implement a baseline parallel subgraph listing solution using graphs only and compared it with CECI based listing. As shown in Figure <ref type="figure" target="#fig_26">19</ref>, subgraph listing with CECI, including creation overhead, is up to 2 orders magnitude faster than running listing with bare graph. This speedup comes from several factors including reduced search space, batched filtering and refinement, better locality of candidates. With the whole graph in memory, CECI construction always took less than 5% of total run-time reported in Section 6.1. Loading graph accounts for less than 15% of total overhead and the majority of overhead is dominated by preprocessing, filtering and refinement. For network stored large graphs, the CECI construction can take up to 40% of the total run-time. In Figure <ref type="figure" target="#fig_27">20</ref>, we have presented the breakdown of IO/compute/communication time for constructing CECI on FS graph. The majority of increased overhead comes from loading the partitioned sections of the data graph on demand basis as explained in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">RELATED WORK</head><p>Subgraph Matching: The inception of subgraph matching is backtracking based approach <ref type="bibr" target="#b53">[54]</ref>. Later works VF2 <ref type="bibr" target="#b9">[10]</ref> and QuickSI <ref type="bibr" target="#b45">[46]</ref> enhance the matching order by picking the vertex connected to one of the already matched nodes. In addition, QuickSI <ref type="bibr" target="#b45">[46]</ref> reduces the search space by selecting infrequent nodes and edges first. Later, several solutions such as Spath <ref type="bibr" target="#b58">[59]</ref>, GraphQL <ref type="bibr" target="#b18">[19]</ref>, GADDI <ref type="bibr" target="#b56">[57]</ref> are developed with the application of several heuristics such as pruning rules, join orders, and auxiliary data. Lee et al. <ref type="bibr" target="#b32">[33]</ref> have carried out a comprehensive survey on subgraph matching and have experimentally demonstrated that there is no universally best visit order and each filtering approach is good for only some datasets. Later, TurboIso <ref type="bibr" target="#b16">[17]</ref> exploits the vertex similarity on query graph to reduce the overall workload. BoostIso <ref type="bibr" target="#b44">[45]</ref> extends this idea to the data graph to further exploit the symmetries in data and query graphs for reducing the computation cost. CFLMatch <ref type="bibr" target="#b3">[4]</ref> removes cardinality cost imposed by the low degree nodes by processing the dense portion of query earlier with the help of core-forest-leaf decomposition.</p><p>With the help of an efficient visit order and auxiliary data structures, it is possible to perform subgraph matching in reasonable time for small to medium sized data graphs. Unfortunately, these solutions fail to accommodate large graphs due to their inherent sequential nature -they list embeddings one by one. Parallel Subgraph Listing solutions have gained popularity in recent years. Prior works <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b42">43,</ref><ref type="bibr" target="#b49">50]</ref> decompose the query graph into sub-components, find the matches of each sub-component in parallel machines, and join the result from multiple machines to compute the embedding list. In contrary, <ref type="bibr" target="#b21">[22]</ref> decomposes the data graph into distributed machines and applies the ideas from distributed relational query optimizations into subgraph matching. PsgL <ref type="bibr" target="#b46">[47]</ref> enumerates all embeddings together by forming new intermediate embedding after each expansion and allocating it to suitable machine. DualSim <ref type="bibr" target="#b23">[24]</ref> develops a disk based solution on which the adjacency list of each node is stored as a slotted page and at any time a specific combination of pages is loaded and subgraph listing is performed upon that section using dual approach. Despite providing significant parallelism, these solutions suffer from expensive join operation, huge amount of false candidates, and exponentialsized intermediate result. Our system improves upon these methods via a join-free approach, which only expands one embedding at a time on each worker in parallel. Approximate Subgraph Matching: These solutions <ref type="bibr" target="#b51">[52,</ref><ref type="bibr" target="#b57">58]</ref> are useful for querying noisy and dynamic graph databases because they have better error tolerance. Similarly, approximate subgraph count estimators calculates the number of a given query graph in data graphs <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b11">12]</ref>. Although these works have better scalability, they do not provide the individual embeddings unlike CECI system. Subgraph Containment Search is slightly different research area <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b55">56,</ref><ref type="bibr" target="#b59">60,</ref><ref type="bibr" target="#b60">61]</ref> that finds whether a data graph contains at least one isomorphic embedding of given query graph. Although both subgraph containment search and subgraph listing involve subgraph isomorphism, the latter is considered more difficult since it requires enumerating every single embedding. Subgraph Isomorphism in Streaming Graph is gaining more popularity as most of the real world graph data are continuously evolving. Several works <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b33">34]</ref> have already provided a solution for performing isomorphic subgraph search in streaming graphs. Recent framework <ref type="bibr" target="#b30">[31]</ref> provides a framework to manage and analyze the evolving graph, which can be good platform to run streaming subgraph matching. Graph data mining exploits subgraph isomorphism to extract the frequent subgraphs from data graphs <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b50">51]</ref>. Graph mining is essential for several problems involving topological as well as label feature based patterns in the data graphs. Examples of such applications include discovering 3D motifs in protein structures or chemical compounds, extracting network motifs or significant subgraphs from protein-protein network. Other than subgraph isomorphism, several recent works on optimizing graph exploration <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b37">38]</ref> and triangle counting <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b20">21]</ref> have been helpful in designing the CECI system. Finally, graph computing frameworks designed for in-memory <ref type="bibr" target="#b39">[40,</ref><ref type="bibr" target="#b47">48]</ref>, distributed <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b12">13]</ref>, external <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b35">36]</ref>, and heterogeneous <ref type="bibr" target="#b36">[37]</ref> systems can also be integrated with CECI.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSION AND FUTURE WORK</head><p>In this work, we have introduced a novel approach for subgraph listing with the help of CECI constructed by traversing the data graph. Particularly, with logical decomposition of data graph into embedding clusters we are able to parallelize the subgraph listing problem. In addition, with the help of intersection based embedding enumeration and workload balancing backed by cardinality based cost function, we are able to outperform state of the art parallel solutions, i.e. DualSim and PsgL by 6.08× and 34.82× on average respectively. One possible future research is to translate the logical decomposition into physical decomposition which enables subgraph listing in trillion edge graphs.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>19 Figure 1 :</head><label>191</label><figDesc>Figure 1: Query graph, data graph and embedding clusters. The solid lines in the BFS tree of the query graph are tree edges and the dotted lines non-tree edges.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Framework Overview. The solid arrow represents the workflow and the dotted arrow shows the interaction between data structure (in oval) and processing steps (in box).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>(a) CECI before BFS based Filtering</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>v</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>4 Figure 3 :</head><label>43</label><figDesc>Figure 3: CECI with BFS based filtering and reverse BFS based refinement for the query and data graphs of Figure 1. TE_Candidates and NTE_Candidates are colored in blue and gray respectively. The red and green portions are removed by BFS based and reverse BFS based filtering steps respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Algorithm 2 :</head><label>2</label><figDesc>Reverse BFS Based RefinementInput: T q , and CECI Output: refined CECI 1 function revBFSRefine ( G q , CECI, G ) 2 forall u ∈ T q in reverse-BFS order do 3 score = 0 4 foreach v ∈ CECI[u].TE_Candidates do 5 if v CECI[u].NTE_Candidates then 6 car dinality(u, v) = 0 7 score += car dinality(u, v) // if v is guaranteed not to match u 8 if car dinality(u, v) == 0 then 9 CECI[u].TE_Candidates.delete(v) 10 forall u c ∈ children of u do 11 CECI[u c ].TE_Candidates.clear(u) CECI[u c ].NTE_Candidates.clear(u) 12 car dinality(u p , uList.key) *= score 13 return CECI</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Parallel embedding enumeration with CECI.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>graph q2 b) Data graph g2, with 2 embedding clusters</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Example for imbalanced workload</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Algorithm 3 : 8 t 9 forall w ∈ work_unit do 10 myWork = c ar d (u i ,w ) t ot al * car d ol d 11 12 if myWork ≤ β × Car d e x p then 13 work</head><label>389101213</label><figDesc>Extreme Cluster Decomposition 1 work = { }; i = 0; prev = { } 2 work_unit = CECI[u s ].frontiers 3 Car d ol d = v ∈w or k _uni t (CECI[u s ].cardinality[v]) 4 Car d e x p = C ar d ol d w or k e r _count 5 β = 1 6 work = prepare_work(i, prev, work_unit , CECI[0].cardinality, Car d ol d ) 7 function prepare_work ( i, prev, work_unit, cardinality, car d ol d ) ot al = v ∈w or k _uni t (cardinality[v]) [i + 1].TE_Candidates[w ]∩ {∪CECI[i + 1].NTE_candidates} 16 workloads = CECI[i + 1].cardinality 17 prepare_work(i + 1, prev ⊕w , work_unit , workloads, myWork) 18 return work</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Different simple query graphs used for testing. Note that all the nodes have same label 0.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Performance comparison with DualSim and PsgL on query QG1 and QG4. The standard deviation of run-time is less than 2% of the average.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Performance comparison with DualSim and PsgL on query graphs QG2, QG3, and QG5. Standard deviation of runtime is less than 2% of the average.In general, PsgL is slower because it lacks the ability to prune the unpromising paths prior to exhaustive expansion (Figure18) and has weaker thread scalability as compared to CECI (Section 6.5) due to exhaustive work distribution method. The speedup over DualSim comes from the better utilization of compute power. Since DualSim loads a set of few slotted pages from graph at a time to run listing algorithm, it incurs multiple IO loads and is able to supply very limited amount of workload in a given time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>9 :</head><label>9</label><figDesc>Performance comparison with CFLMatch on larger query graphs. The standard deviation of runtime is less than 5% of the average.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Performance comparison with TurboIso and Boosted TurboIso on larger query graphs. The standard deviation of runtime is less than 5% of the average.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Speedup obtained by adopting dynamic workload balancing method, and ExtremeCluster decomposition over static workload distribution method.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 12 shows</head><label>12</label><figDesc>Figure 12 shows the effect of different β on time spent by each worker while running QG3 on FS graph. As we decrease β, the time spent by fastest processor increases, but the high skew at the end is reduced significantly. Scheduling overhead for β = 1, 0.2, and 0.1 are 14.76, 16.53, and 23.96 Sec respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: Effect of different β.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: Scalability comparison against PsgL for increasing thread count on Server 1 while running QG1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>Figure 14 :</head><label>14</label><figDesc>Figure 14: Scalability comparison against PsgL for increasing thread count on Server 1 while running QG4.We evaluate the CPU usage of CECI system over the lifetime of the program. Initially, CPU usage is low since the process is either heavily serialized or dominated by IO loads. During CECI creation, the cpu usage gets only slightly larger due to massive serialization on creating CECI. During embedding enumeration phase, which constitutes more than 95% of the overall execution time, all cores are used to the maximal resulting in near 100% utilization on each core.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>Figure 15 :</head><label>15</label><figDesc>Figure 15: CPU usage while running different query graphs on OK data graph. The results are collected while running 32 OpenMP threads on Server 1.The scalability of two distributed solutions described in Section 5 is examined on Cluster 1. We vary the machine</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>Figure 16 :</head><label>16</label><figDesc>Figure16: Speedup with increasing machine count for listing QG1 and QG4 on distributed solution that loads whole graph into the memory of each machine.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>Figure 17 :</head><label>17</label><figDesc>Figure 17: Scalability with increasing node count for listing QG1 and QG4 on distributed solution that uses networked graph storage (lustre).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head>Figure 18 :</head><label>18</label><figDesc>Figure 18: Percentage of reduction on recursive calls by CECI over PsgL for different queries.The overhead for constructing and using CECI for subgraph listing is insignificant as compared to it's benefits. We implement a baseline parallel subgraph listing solution using graphs only and compared it with CECI based listing. As shown in Figure19, subgraph listing with CECI, including creation overhead, is up to 2 orders magnitude faster than running listing with bare graph. This speedup comes from several factors including reduced search space, batched filtering and refinement, better locality of candidates.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head>Figure 19 :</head><label>19</label><figDesc>Figure 19: Breakdown of speedup obtained upon baseline technique into several techniquesWith the whole graph in memory, CECI construction always took less than 5% of total run-time reported in Section 6.1. Loading graph accounts for less than 15% of total overhead and the majority of overhead is dominated by preprocessing, filtering and refinement. For network stored large graphs, the CECI construction can take up to 40% of the total run-time. In Figure20, we have presented the breakdown of IO/compute/communication time for constructing CECI on FS graph. The majority of increased overhead comes from loading the partitioned sections of the data graph on demand basis as explained in Section 5.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head>Figure 20 :</head><label>20</label><figDesc>Figure 20: Breakdown of CECI construction overhead into IO, communication and computation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>)</head><label></label><figDesc>Server 1: A server with dualsocket Intel Xeon CPU E5-2683 CPUs with 28 cores and 512 GB memory for main memory. (2) Server 2: A quadsocket Intel Xeon CPU E7-8857 CPUs with 48 cores and 2 TB memory which is used to run yahoo graph only. (3) Cluster 1: 16 8-core nodes cluster with dual-socket Intel Xeon CPU E5-2650 CPUs with 128 GB memory each for distributed implementation. All machines run Linux 3.10.0 kernel with GCC 4.8.5 and compilation flag -O3. All reported results are the average of five runs. Query graph: Five unlabeled query graphs from Figure 6, which are also used by recent projects PsgL, TTJ, and Dual-Sim are used. Section 6.2 experiments on larger, and labeled query graphs. Data graph: The experiments run on both undirected and directed data graphs listed in Table 1. The first nine are</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc>Graph datasets used in the experiments. |V | and |E| are the vertex count and edge count respectively.</figDesc><table><row><cell>Datasets</cell><cell cols="2">Abbr. |V|</cell><cell>|E|</cell><cell>Directed</cell></row><row><cell>citPatent</cell><cell>CP</cell><cell cols="2">3.77M 16.5M</cell><cell>Y</cell></row><row><cell>Friendster</cell><cell>FS</cell><cell cols="2">65.6M 1.8B</cell><cell>N</cell></row><row><cell>Human</cell><cell>HU</cell><cell>4.6K</cell><cell>0.7M</cell><cell>N</cell></row><row><cell cols="2">live-journal LJ</cell><cell cols="3">3.99M 34.68M N</cell></row><row><cell>Orkut</cell><cell>OK</cell><cell>3.0M</cell><cell cols="2">117.2M N</cell></row><row><cell cols="2">Webgoogle WG</cell><cell>0.9M</cell><cell>8.6M</cell><cell>Y</cell></row><row><cell>wiki-talk</cell><cell>WT</cell><cell>2.3M</cell><cell>5.0M</cell><cell>Y</cell></row><row><cell>Yahoo</cell><cell>YH</cell><cell>1.4B</cell><cell>12.9B</cell><cell>N</cell></row><row><cell>Youtube</cell><cell>YT</cell><cell>1.1M</cell><cell>3.0M</cell><cell>N</cell></row><row><cell>rand_500k</cell><cell>RD</cell><cell>0.5M</cell><cell>2.0M</cell><cell>N</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2</head><label>2</label><figDesc>shows the size of CECI for different data and query graph pairs. Since TE_Candidates and NTE_Candidates only store candidate edges once, CECI system can drastically reduce the space consumption to O|E д | × |E q | as compared to |E д | |E q | of aggressive instance expansion approach in PsgL<ref type="bibr" target="#b46">[47]</ref>. Here, |E q | and |E д | are the query and data graph edge counts.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 :</head><label>2</label><figDesc>CECI size in GB for different query and data graph combinations. The numbers inside the parentheses and brackets are theoretical memory requirement, and % of space saved by CECI, respectively.</figDesc><table><row><cell cols="2">Graph FS</cell><cell>LJ</cell><cell>OK</cell><cell>WT</cell><cell>YH</cell><cell>YT</cell></row><row><cell>QG1</cell><cell>20 (40) [51%]</cell><cell>0.9 (1.5) [45%]</cell><cell>1.3 (2.6) [51%]</cell><cell>0.01 (0.1) [83%]</cell><cell>121 (288) [58%]</cell><cell>0.07 (0.1) [31%]</cell></row><row><cell>QG2</cell><cell>26 (54) [52%]</cell><cell>1.1 (2.1) [48%]</cell><cell>1.7 (3.5) [50%]</cell><cell>0.02 (0.2) [88%]</cell><cell>160 (384) [58%]</cell><cell>0.09 (0.2) [45%]</cell></row><row><cell>QG3</cell><cell>32 (67) [52%]</cell><cell>1.3 (2.6) [50%]</cell><cell>2.1 (4.4) [52%]</cell><cell>0.03 (0.2) [86%]</cell><cell>225 (481) [53%]</cell><cell>0.09 (0.2) [57%]</cell></row><row><cell>QG4</cell><cell>38 (81) [54%]</cell><cell>1.5 (3.0) [49]</cell><cell>2.5 (5.3) [53%]</cell><cell>0.03 (0.2) [85%]</cell><cell>274 (577) [52%]</cell><cell>0.11 (0.3) [66%]</cell></row><row><cell>QG5</cell><cell>39 (81) [52%]</cell><cell>1.6 (3.0) [47%]</cell><cell>2.6 (5.3) [52%]</cell><cell>0.03 (0.2) 84%</cell><cell>290 (577) [50%]</cell><cell>0.12 (0.3) [62%]</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">CECI is used to represent the data structure or whole system depending on the context. When needed, the CECI system is used to represent the system</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>The authors thank the anonymous reviewers for their feedback and suggestions. This work was supported in part by National Science Foundation CAREER award 1350766 and grants 1618706 and 1717774 to George Washington University.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">ScaleMine: Scalable parallel frequent subgraph mining in a single large graph</title>
		<author>
			<persName><forename type="first">Ehab</forename><surname>Abdelhamid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ibrahim</forename><surname>Abdelaziz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Panos</forename><surname>Kalnis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zuhair</forename><surname>Khayyat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fuad</forename><surname>Jamour</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SC16: International Conference for High Performance Computing, Networking, Storage and Analysis</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="716" to="727" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Enumerating subgraph instances using map-reduce</title>
		<author>
			<persName><forename type="first">Dimitris</forename><surname>Foto N Afrati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">D</forename><surname>Fotakis</surname></persName>
		</author>
		<author>
			<persName><surname>Ullman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Data Engineering (ICDE)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013">2013. 2013</date>
			<biblScope unit="page" from="62" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Biomolecular network motif counting and discovery by color coding</title>
		<author>
			<persName><forename type="first">Phuong</forename><surname>Noga Alon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iman</forename><surname>Dao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fereydoun</forename><surname>Hajirasouliha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S Cenk</forename><surname>Hormozdiari</surname></persName>
		</author>
		<author>
			<persName><surname>Sahinalp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pattern Recognition in Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="241" to="249" />
			<date type="published" when="2008">2008. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Efficient subgraph matching by postponing cartesian products</title>
		<author>
			<persName><forename type="first">Fei</forename><surname>Bi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lijun</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuemin</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lu</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenjie</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Management of Data</title>
				<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1199" to="1214" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Enhancing graph database indexing by suffix tree structure</title>
		<author>
			<persName><forename type="first">Vincenzo</forename><surname>Bonnici</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alfredo</forename><surname>Ferro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rosalba</forename><surname>Giugno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alfredo</forename><surname>Pulvirenti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Shasha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pattern Recognition in Bioinformatics</title>
		<imprint>
			<biblScope unit="page" from="195" to="203" />
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Mining large networks with subgraph counting</title>
		<author>
			<persName><forename type="first">Ilaria</forename><surname>Bordino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Debora</forename><surname>Donato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aristides</forename><surname>Gionis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefano</forename><surname>Leonardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Data Mining</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008">2008. 2008</date>
			<biblScope unit="page" from="737" to="742" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Powerlyra: Differentiated graph computation and partitioning on skewed graphs</title>
		<author>
			<persName><forename type="first">Rong</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiaxin</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yanzhe</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haibo</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Tenth European Conference on Computer Systems</title>
				<meeting>the Tenth European Conference on Computer Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Fg-index: towards verification-free query processing on graph databases</title>
		<author>
			<persName><forename type="first">James</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yiping</forename><surname>Ke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wilfred</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">An</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">international conference on Management of data, SIGMOD</title>
				<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007. 2007</date>
			<biblScope unit="page" from="857" to="872" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A Selectivity based approach to Continuous Pattern Detection in Streaming Graphs</title>
		<author>
			<persName><forename type="first">Sutanay</forename><surname>Choudhury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lawrence</forename><forename type="middle">B</forename><surname>Holder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Chin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Khushbu</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Feo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 18th International Conference on Extending Database Technology</title>
				<meeting>18th International Conference on Extending Database Technology</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">A (sub) graph isomorphism algorithm for matching large graphs</title>
		<author>
			<persName><forename type="first">Pasquale</forename><surname>Luigi P Cordella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlo</forename><surname>Foggia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mario</forename><surname>Sansone</surname></persName>
		</author>
		<author>
			<persName><surname>Vento</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004. 2004</date>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="1367" to="1372" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Dynamic processor self-scheduling for general parallel nested loops</title>
		<author>
			<persName><forename type="first">Zhixi</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peiyi</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P-C</forename><surname>Yew</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C-Q</forename><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="919" to="929" />
			<date type="published" when="1990">1990. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Counting stars and other small subgraphs in sublinear-time</title>
		<author>
			<persName><forename type="first">Mira</forename><surname>Gonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dana</forename><surname>Ron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuval</forename><surname>Shavitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Discrete Mathematics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1365" to="1411" />
			<date type="published" when="2011">2011. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Powergraph: distributed graph-parallel computation on natural graphs</title>
		<author>
			<persName><forename type="first">Yucheng</forename><surname>Joseph E Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haijie</forename><surname>Low</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Danny</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlos</forename><surname>Bickson</surname></persName>
		</author>
		<author>
			<persName><surname>Guestrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th USENIX Symposium on Operating Systems Design and Implementation</title>
				<meeting>the 10th USENIX Symposium on Operating Systems Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">GraphX: Graph Processing in a Distributed Dataflow Framework</title>
		<author>
			<persName><forename type="first">Reynold</forename><forename type="middle">S</forename><surname>Joseph E Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ankur</forename><surname>Xin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Dave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">J</forename><surname>Crankshaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ion</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th USENIX Symposium on Operating Systems Design and Implementation</title>
				<meeting>the 11th USENIX Symposium on Operating Systems Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="599" to="613" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title/>
		<author>
			<persName><surname>Graph500</surname></persName>
		</author>
		<ptr target="http://www.graph500.org/" />
		<imprint>
			<date type="published" when="2018-08-07">2018-08-07</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Network motif discovery using subgraph enumeration and symmetry-breaking</title>
		<author>
			<persName><forename type="first">Joshua</forename><forename type="middle">A</forename><surname>Grochow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manolis</forename><surname>Kellis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RECOMB</title>
				<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4453</biblScope>
			<biblScope unit="page" from="92" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Turboiso: Towards Ultrafast and Robust Subgraph Isomorphism Search in Large Graph Databases</title>
		<author>
			<persName><forename type="first">Wook-Shin</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jinsoo</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeong-Hoon</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Management of Data</title>
				<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013. 2013</date>
			<biblScope unit="page" from="337" to="348" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">TurboGraph: a fast parallel graph engine handling billion-scale graphs in a single PC</title>
		<author>
			<persName><forename type="first">Wook-Shin</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sangyeon</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kyungyeol</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeong-Hoon</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Min-Soo</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jinha</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hwanjo</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th ACM SIGKDD international conference on Knowledge discovery and data mining</title>
				<meeting>the 19th ACM SIGKDD international conference on Knowledge discovery and data mining</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="77" to="85" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Graphs-at-a-time: Query Language and Access Methods for Graph Databases</title>
		<author>
			<persName><forename type="first">Huahai</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ambuj</forename><forename type="middle">K</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Management of Data, SIGMOD 2008</title>
				<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="405" to="418" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">High-Performance Triangle Counting on GPUs</title>
		<author>
			<persName><forename type="first">Yang</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Howie</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE High Performance extreme Computing Conference (HPEC)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Tricore: Parallel triangle counting on gpus</title>
		<author>
			<persName><forename type="first">Yang</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Howie</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TriCore: Parallel Triangle Counting on GPUs</title>
				<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Query optimization of distributed pattern matching</title>
		<author>
			<persName><forename type="first">Jiewen</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kartik</forename><surname>Venkatraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">J</forename><surname>Abadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 30th International Conference on</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014">2014. 2014</date>
			<biblScope unit="page" from="64" to="75" />
		</imprint>
	</monogr>
	<note>Data Engineering (ICDE)</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">iSpan: Parallel Identification of Strongly Connected Components with Spanning Trees</title>
		<author>
			<persName><forename type="first">Yuede</forename><surname>Ji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Howie</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 SC18: The International Conference for High Performance Computing, Networking, Storage, and Analysis (SC)</title>
				<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="731" to="742" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">DUAL-SIM: Parallel Subgraph Enumeration in a Massive Graph on a Single Machine</title>
		<author>
			<persName><forename type="first">Hyeonji</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juneyoung</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sourav</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wook-Shin</forename><surname>Bhowmick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeonghoon</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seongyun</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><surname>Ko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">A</forename><surname>Moath</surname></persName>
		</author>
		<author>
			<persName><surname>Jarrah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 International Conference on Management of Data</title>
				<meeting>the 2016 International Conference on Management of Data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1231" to="1245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Tur-boFlux: A Fast Continuous Subgraph Matching System for Streaming Graph Data</title>
		<author>
			<persName><forename type="first">Kyoungmin</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">In</forename><surname>Seo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wook-Shin</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeong-Hoon</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sungpack</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hassan</forename><surname>Chafi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hyungyu</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geonhwa</forename><surname>Jeong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 International Conference on Management of Data</title>
				<meeting>the 2018 International Conference on Management of Data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="411" to="426" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">CT-index: Fingerprint-based graph indexing combining cycles and trees</title>
		<author>
			<persName><forename type="first">Karsten</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nils</forename><surname>Kriege</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Petra</forename><surname>Mutzel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Data Engineering (ICDE)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2011">2011. 2011</date>
			<biblScope unit="page" from="1115" to="1126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Allocating independent subtasks on parallel processors</title>
		<author>
			<persName><forename type="first">Clyde</forename><forename type="middle">P</forename><surname>Kruskal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><surname>Weiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software engineering</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="1001" to="1016" />
			<date type="published" when="1985">1985. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">G-Store: High-Performance Graph Store for Trillion-Edge Processing</title>
		<author>
			<persName><forename type="first">P</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">H</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SC &apos;16: Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis</title>
				<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="830" to="841" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Falcon: Scaling IO Performance in multi-SSD Volumes</title>
		<author>
			<persName><forename type="first">Pradeep</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">Howie</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 USENIX Conference on Usenix Annual Technical Conference. USENIX Association</title>
				<meeting>the 2017 USENIX Conference on Usenix Annual Technical Conference. USENIX Association</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="41" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">SafeNVM: A Non-Volatile Memory Store with Thread-Level Page Protection</title>
		<author>
			<persName><forename type="first">Pradeep</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Howie</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Big Data</title>
				<imprint>
			<publisher>BigData Congress</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="65" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">GraphOne: A Data Store for Real-time Analytics on Evolving Graphs</title>
		<author>
			<persName><forename type="first">Pradeep</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">Howie</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th Usenix Conference on File and Storage Technologies (FAST&apos;19)</title>
				<meeting>the 17th Usenix Conference on File and Storage Technologies (FAST&apos;19)</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Scalable subgraph enumeration in mapreduce</title>
		<author>
			<persName><forename type="first">Longbin</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lu</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuemin</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lijun</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
				<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2015">2015. 2015</date>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="974" to="985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">An in-depth comparison of subgraph isomorphism algorithms in graph databases</title>
		<author>
			<persName><forename type="first">Jinsoo</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wook-Shin</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Romans</forename><surname>Kasperovics</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeong-Hoon</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<title level="s">VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="133" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Time Constrained Continuous Subgraph Search over Streaming Graphs</title>
		<author>
			<persName><forename type="first">Youhuan</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lei</forename><surname>Zou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tamer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dongyan</forename><surname>Özsu</surname></persName>
		</author>
		<author>
			<persName><surname>Zhao</surname></persName>
		</author>
		<idno>abs/1801.09240</idno>
		<imprint>
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
	<note type="report_type">Computing Research Repository</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Enterprise: Breadth-first graph traversal on GPUs</title>
		<author>
			<persName><forename type="first">Hang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Howie</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis</title>
				<meeting>the International Conference for High Performance Computing, Networking, Storage and Analysis</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page">68</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Graphene: Fine-grained IO Management for Graph Computing</title>
		<author>
			<persName><forename type="first">Hang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">Howie</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th Usenix Conference on File and Storage Technologies (FAST&apos;17)</title>
				<meeting>the 15th Usenix Conference on File and Storage Technologies (FAST&apos;17)</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="285" to="299" />
		</imprint>
	</monogr>
	<note>USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">SIMD-X: Programming and Processing of Graph Algorithms on GPUs</title>
		<author>
			<persName><forename type="first">Hang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">Howie</forename><surname>Huang</surname></persName>
		</author>
		<idno>abs/1812.04070</idno>
		<ptr target="https://arxiv.org/abs/1812.04070" />
		<imprint>
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">iBFS: Concurrent Breadth-First Search on GPUs</title>
		<author>
			<persName><forename type="first">Hang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">Howie</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yang</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 International Conference on Management of Data</title>
				<meeting>the 2016 International Conference on Management of Data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="403" to="416" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Effective STL: 50 specific ways to improve your use of the standard template library</title>
		<author>
			<persName><forename type="first">Scott</forename><surname>Meyers</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>Pearson Education</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">A lightweight infrastructure for graph analytics</title>
		<author>
			<persName><forename type="first">Donald</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Lenharth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keshav</forename><surname>Pingali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles</title>
				<meeting>the Twenty-Fourth ACM Symposium on Operating Systems Principles</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="456" to="471" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Subgemini: Identifying subcircuits using a fast subgraph isomorphism algorithm</title>
		<author>
			<persName><forename type="first">Miles</forename><surname>Ohlrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carl</forename><surname>Ebeling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eka</forename><surname>Ginting</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lisa</forename><surname>Sather</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">international Design Automation Conference</title>
				<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="31" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">MODA: an efficient algorithm for network motif discovery in biological networks</title>
		<author>
			<persName><forename type="first">Saeed</forename><surname>Omidi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Falk</forename><surname>Schreiber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ali</forename><surname>Masoudi-Nejad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genes &amp; genetic systems</title>
		<imprint>
			<biblScope unit="volume">84</biblScope>
			<biblScope unit="page" from="385" to="395" />
			<date type="published" when="2009">2009. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Inexact subgraph isomorphism in MapReduce</title>
		<author>
			<persName><forename type="first">Todd</forename><surname>Plantenga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Parallel and Distrib. Comput</title>
		<imprint>
			<biblScope unit="volume">73</biblScope>
			<biblScope unit="page" from="164" to="175" />
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Efficient estimation of graphlet frequency distributions in protein-protein interaction networks</title>
		<author>
			<persName><forename type="first">Derek</forename><forename type="middle">G</forename><surname>Pržulj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Igor</forename><surname>Corneil</surname></persName>
		</author>
		<author>
			<persName><surname>Jurisica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="974" to="980" />
			<date type="published" when="2006">2006. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Exploiting Vertex Relationships in Speeding Up Subgraph Isomorphism over Large Graphs</title>
		<author>
			<persName><forename type="first">Xuguang</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Junhu</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
				<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2015-01">2015. Jan. 2015</date>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="617" to="628" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Taming verification hardness: an efficient algorithm for testing subgraph isomorphism</title>
		<author>
			<persName><forename type="first">Haichuan</forename><surname>Shang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ying</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuemin</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the VLDB Endowment</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="364" to="375" />
			<date type="published" when="2008">2008. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Parallel subgraph listing in a large-scale graph</title>
		<author>
			<persName><forename type="first">Yingxia</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bin</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lei</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lin</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Junjie</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ning</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Management of Data</title>
				<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014. 2014</date>
			<biblScope unit="page" from="625" to="636" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Ligra: a lightweight graph processing framework for shared memory</title>
		<author>
			<persName><forename type="first">Julian</forename><surname>Shun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guy</forename><forename type="middle">E</forename><surname>Blelloch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Sigplan Notices</title>
				<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="135" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<ptr target="http://snap.stanford.edu/data" />
		<title level="m">SNAP Datasets: Stanford Large Network Dataset Collection</title>
				<imprint>
			<date type="published" when="2018-08-07">2018-08-07</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Efficient subgraph matching on billion node graphs</title>
		<author>
			<persName><forename type="first">Zhao</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hongzhi</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haixun</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bin</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jianzhong</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
				<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2012">2012. 2012</date>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="788" to="799" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Arabesque: a system for distributed graph mining</title>
		<author>
			<persName><forename type="first">Alexandre</forename><forename type="middle">J</forename><surname>Carlos Hc Teixeira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georgos</forename><surname>Serafini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohammed</forename><forename type="middle">J</forename><surname>Siganos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ashraf</forename><surname>Zaki</surname></persName>
		</author>
		<author>
			<persName><surname>Aboulnaga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Operating Systems Principles</title>
				<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="425" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Tale: A tool for approximate large graph matching</title>
		<author>
			<persName><forename type="first">Yuanyuan</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jignesh</surname></persName>
		</author>
		<author>
			<persName><surname>Patel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Data Engineering</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008">2008. 2008</date>
			<biblScope unit="page" from="963" to="972" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Fast subgraph matching on large graphs using graphics processors</title>
		<author>
			<persName><forename type="first">Ha-Nguyen</forename><surname>Tran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jung-Jae</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bingsheng</forename><surname>He</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Database Systems for Advanced Applications</title>
				<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="299" to="315" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">An Algorithm for Subgraph Isomorphism</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Ullmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="31" to="42" />
			<date type="published" when="1976-01">1976. Jan. 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title level="m" type="main">Marketing Advertiser-Phrase Bipartite Graph</title>
		<author>
			<persName><forename type="first">!</forename><surname>Yahoo</surname></persName>
		</author>
		<author>
			<persName><surname>Search</surname></persName>
		</author>
		<ptr target="https://webscope.sandbox.yahoo.com/catalog.php?datatype=g.Ac-cessed" />
		<imprint>
			<biblScope unit="page" from="2018" to="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Graph indexing: a frequent structure-based approach</title>
		<author>
			<persName><forename type="first">Xifeng</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philip</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiawei</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">international conference on Management of data</title>
				<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2004">2004. 2004</date>
			<biblScope unit="page" from="335" to="346" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">GADDI: distance index based subgraph matching in biological networks</title>
		<author>
			<persName><forename type="first">Shijie</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shirong</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiong</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Extending Database Technology: Advances in Database Technology</title>
				<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="192" to="203" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Sapper: Subgraph indexing and approximate matching in large graphs</title>
		<author>
			<persName><forename type="first">Shijie</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiong</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wei</forename><surname>Jin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
				<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2010">2010. 2010</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="1185" to="1194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">On graph query optimization in large networks</title>
		<author>
			<persName><forename type="first">Peixiang</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiawei</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
				<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2010">2010. 2010</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="340" to="351" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Graph indexing: tree+ delta&lt;= graph</title>
		<author>
			<persName><forename type="first">Peixiang</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">Xu</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philip</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">international conference on Very large data bases. VLDB Endowment</title>
				<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="938" to="949" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">A novel spectral coding in a large graph database</title>
		<author>
			<persName><forename type="first">Lei</forename><surname>Zou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lei</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">Xu</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yansheng</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">international conference on Extending database technology</title>
				<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="181" to="192" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
