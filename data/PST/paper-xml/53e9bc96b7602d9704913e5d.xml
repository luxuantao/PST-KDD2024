<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Secure Voting Using Partially Compatible Homomorphisms</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Kazue</forename><surname>Sako'</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">NEC Research Institute</orgName>
								<address>
									<addrLine>4 Independence Way</addrLine>
									<postCode>N J 08540</postCode>
									<settlement>Princeton</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Joe</forename><surname>Kilian' Nec</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">NEC Research Institute</orgName>
								<address>
									<addrLine>4 Independence Way</addrLine>
									<postCode>N J 08540</postCode>
									<settlement>Princeton</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Miyazaki</forename><surname>Miyamae</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">NEC Research Institute</orgName>
								<address>
									<addrLine>4 Independence Way</addrLine>
									<postCode>N J 08540</postCode>
									<settlement>Princeton</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><surname>Kawasaki</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">NEC Research Institute</orgName>
								<address>
									<addrLine>4 Independence Way</addrLine>
									<postCode>N J 08540</postCode>
									<settlement>Princeton</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Secure Voting Using Partially Compatible Homomorphisms</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">CC9607DF5A7726EC02C29EA9F0E9DFB5</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:31+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We introduce a new number-theoretic based protocol for secure electronic voting. Our scheme is much more communication efficient than previous schemes of its type, and has a much lower round complexity than is currently possible using the anonymous-channel/mixer techniques. Preprocessing allows for nearly all of the communication and computation to be performed before any voting takes place. Unlike the mixer-based protocols, anyone can verify that everyone's vote has been properly counted. Also, our techniques allow for a wide variety of different schemes. Our protocols are based on families of homomorphic encryptions which have a partial compatibility property, generalizing a method of Benaloli and Yung <ref type="bibr" target="#b1">[2]</ref>. We use these functions to generate very simple interactive proofs on encrypted shares. We also develop amortization techniques yielding dramatic efficiency improvements over our simple protocols. Our protocols can be realized by current-generation PC's with access to an electronic bulletin board.</p><p>There is usually no way for an outside observer to later verify that the election was properly performed.</p><p>Another approach is the use of number theoretic techniques without anonymous channels or mixers [6, 3, 21. The protocol has desirable security properties, but as we will discuss in detail, their communication complexity is quite high for realistic scenarios.</p><p>In this paper, we give a new number-theoretic scheme for secure electronic voting. This scheme has a number of features including moderate communication cost, low round complexity, preprocessing potential, security, universal verifiability and flexibility, which we outline below.</p><p>Communication Cost: Our protocol requires much less communication than the previous number-theoretic protocols. For one realistic setting of the parameters, we estimate that our protocol conservatively requires less than 1/20th the communication of Benaloh-Yung's scheme <ref type="bibr" target="#b1">[2]</ref>. Furthermore, when more than one election is t o be held, we can use an amortization technique that will boost our per-vote advantage to a factor of between 150 and 250. We note however that the communication complexity of each vote remains much greater than that required by the anonymous channel/mixer-based protocols. However, it is well within the range of feasibility, as we will discuss in greater detail in the Section 4.</p><p>Round Complexity: Our protocol enjoys an extremely low round complexity.</p><p>Once the system has been set up, a voter can cast a vote in an election simply by posting a single message. The counting process consists of each counting center posting a single, very short message.</p><p>Preprocessing: Ideally, one would like to do the bulk of ones communication and computation in advance of an actual vote. In our scheme, one can preprocess ones vote with a single message. This preprocessing step doesn't depend on the</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Secure electronic voting is arguably the most important single application of secure multi-party computation. Yet. despite extensive work on this subject, no complete solution has been found in either the theoretical or practical domains.</p><p>Even the general solutions to secure multiparty protocols fail to exhibit all of the desired properties of elections (for example, the "rcceipt-free" property [l]).</p><p>While these general solutions d o have a wide breadth of security properties, and some hope of rigorous analysis, they are hopelessly impractical both in their computational and communication costs.</p><p>A number of more practical voting prot,ocols have been proposed, with widely differing security properties. Schemes based on anonymous channels/mixers <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr">121</ref> have become very popular due to their superior efficiency and the arbitrary nature of the votes that are allowed. However, a price is paid for this efficiency. T h e simplest of these schemes cannot allow a voter to securely protest the omission of his vote without allowing a malicious voter to block the election. In all the schemes we know of there is a high round complexityone round for each mixer used to implement the anonymous channel. Also, after the election each voter is typically responsible for checking that his vote was correctly tallied. Y.G. Desmedt (Ed.): Advances in Cryptology -CRYPT0 '94, LNCS 839, pp. 411-424, 1994. 0 Springer-Verlag Berlin Heidelberg 1994 vote that is eventually cast, and may be done at the time the voter "registers" to vote. When it comes time to actually vote, the voter can often simply post a single bit (or a bit along with a small integer in the worst case). Thus even with the signatures needed for identification, the communication cost is negligible. Similarly, after preprocessing, a PC acting as a voting center can easily count a hundred incoming votes per second.</p><p>Security: Under reasonable heuristic assumptions, no coalition of voters or centers can unfairly influence an election or significantly delay its outcome. A voter keeps his vote private as long as two of the centers he deals with are honest. The two honest center requirement can be reduced to a single honest center requirement by a simple doubling trick: each center simulates two centers of the original schemes.</p><p>While we use heuristic assumptions (such as the Fiat-Shamir method for noninteractive proofs) the only attack we know requires one to compute discretelogarithms over the group we are working in. We can thus use elliptic curves for which the discrete-log problem is currently thought to be much harder than factoring. Previous number-theoretic approaches were based on the r t h residue problem over 2; , and are guaranteed breakable if one can factor n.</p><p>Universal Verifiability: Every action by a voter, whether preprocessing a vote or actually voting, is accompanied by a proof that the ballot is correctly constructed. The output of the counting center may also be easily checked for correctness. Any participant can verify that everyone's vote has been included in the tally. Once a party posts their message, it does not need t o cooperate in the checking of its work. We can distribute the checking of the election over many parties, and if someone is still not satisfied they may check the results themselves. Thus, a voter has the option of minimally participating in an election by simply sending in their vote and then ceasing all involvement.</p><p>Flexibility: Our scheme is readily a.daptable. For example, the number of centers can be made quite large. Voters may choose their own security/efficiency tradeoff and individually choose how many and which centers they use. Thus, we can practically support an election in which there are a 100 centers of which a typical voter chooses 10 and is protected as long as two of them are honest. For giant elections we can construct hierarchical counting schemes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Techniques Used</head><p>New Techniques for Using Homomorphic Encryptions The main contribution of this paper is the use of a new tool: families of partially compatible homomorphic encryption functions. There are well known encryption functions with additive ( E ( z + y) = E ( z ) E ( y ) ) or multiplicative E(zy) = E(z)E(y) homomorphisms. These properties can be exploited to make very efficient zeroknowledge proofs, but can also work against security. For example, suppose that one has E ( z ) and E(y) and wishes to know whether z + y is 1 or -1. If E is a function (as opposed to a probabilistic encryption) with an additive homomorphism then one can compute E ( z + y) and check if it is equal to E(1) or <ref type="bibr">Benaloh and Yung [2]</ref> circumvent this difficulty by using a family of probabilistic encryption functions, { E l , . . . , En]. Each Ei probabilistically encrypts an element 2 E Z,, where T is a moderately large prime independent of i . While each Ei satisfies Ei(x + y) = E;(z)E;(y), there is no obvious way of combining Ei(z) and Ej(y) to learn obtain an encryption of some simple function of 2 and y. A key requirement of their technique was that the encryptions Ed be probabilistic, a condition we weaken in the formalism below.</p><p>We consider a family of additive homomorphic, possibly deterministic encryption functions, { E l , . . . , En}. Within this family we have a single group 2, (where p is large) such that Ei(z + y) = Ei(z)Ed(y), where z, y E 2,. Thus, they are all basically compatible. However, we require that for all ( i , j ) the following two distributions are computationally indistinguishable: E(-1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">( E i ( z ) ,</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ej(y))</head><p>, where z and y are chosen uniformly from Z,, and 2. ( E i ( z ) , E j ( z ) ) , where 2 is chosen uniformly from 2,. This implies that for any v, (Ei(z), Ej(v-z)) is indistinguishable from ( E i ( z ) , Ej(y)). Thus, if z and y are chosen uniformly such that z+y = 21, then seeing ( E i ( z ) , Ej(y)) doesn't reveal anything about v. Similarly, if z1 , . . . , x, are chosen uniformly to sum to v, then knowing n -2 of the values {XI,., . , 2,) tells one nothing about We call such families of encryption functions with this property partially compatible homomorphic encryption functions. We don't know how to reduce the existence of such families t o any well-known algebraic assumption. However, there are a number of candidates for such a family of encryption functions. For example, let primes pi = kig + 1 , where q is a prime, let ga be a randomly (or pseudorandomly) chosen generator for Z;, and let a* = g f l . If we define E i ( z ) = af then we know of no way of obtaining any information about xi + 22 given El(z1) and Ez(z2) without computing discrete logarithms. The only weakness we know of is that if pl = pz and e such that C Y ~ = a! is known, then one can compute E l ( q +zz)' = E1(21)'E2( <ref type="formula">22</ref>), which allows one to determine if z1Sx2 is equal to a given number. We know of no such attack when pl # p 2 .</p><p>We can also incorporate encryption functions based on elliptic curves or other groups. Furthermore, we can mix which types of groups we use arbitrarily. For ease of exposition, we will use multiplicative notation for the cyclic group generated by cri , regardless if the group is normally treated as multiplicative or additive.</p><p>Using these families of partially compatible homomorphic encryption functions, we construct very efficient interactive proofs for assertions such as:</p><p>V .</p><p>2 1 + . . . + zn = a + b, given the encryptions for these values, and x + y E { 1 , -1) , given the encryptions for 2 and y.</p><p>Because of the efficiency of these proofs, we can afford t o run them many times, and use the heuristic trick of Fiat-Shamir [7] to make them noninteractive.</p><p>Reduced Costs Through Amortization Our improved proof techniques brings the complexity of the number-theoretic techniques down to the point where they can be used by a PC that can post messages to a bulletin board. However, when we use very strong confidence parameters (2-40 or even 2-60 error rates are recommended when using the Fiat-Shamir trick) and allow the voter t o prot.ect his vote by using many (e.g., 10) of the available centers, our costs are at the outer margin of usability. Hence, we have developed techniques for making these burdens easier to bear.</p><p>By allowing nearly all of the work t o be done in advance of any election, we can amortize the computational and communication burden over a much larger period of time and still have very fast elections. To lower the computational burden of a proof, we use table lookup techniques to reduce the number of group operations required. Finally, we show how a voter can process many votes using much less communication and computation than would be required to process them individually.</p><p>We note that the use of amortization in cryptography is not new. Kurosawa and Tsujii [ll] construct a zero-knowledge proof for two assertions that is more efficient than simply concatenating the zero-knowledge proofs for each assertion.</p><p>Boyar, Brassard and Peralta <ref type="bibr" target="#b3">[4]</ref> and <ref type="bibr">Kilian [lo]</ref> consider the problem of achieving ultra-high confidence zero-knowledge proofs for N P using less communication than is required by simple sequential repetition. <ref type="bibr">Franklin and Yung [8]</ref> show how to implement k instances of a secure multiparty computation much less expensively than k times the cost of a single secure computation. 1. Greater generality: The encryption used by <ref type="bibr">[a]</ref> was tuned to the factoring problem. Each center i had the prime factorization of ni as part of its secret information. This secret information complicated the protocol in that the voters needed to verify the correctness of the centers' public information and the correctness of their subtallies through interactive protocols. Also, we can apply our method to "discrete-log type" problemswe don't know how to attack our scheme without computing discrete logarithms. 2. Amortization techniques: Unlike most previous work in voting, we consider how to run multiple elections more efficiently. Since there are usually many voters, and checking each vote involves many subchecks, we can effectively use amortization techniques to speed up single elections as well. 3. Improved zero-knowledge proofs: We give direct and efficient protocols to show, for example, that 3 : + y is either 1 or -1, without conveying which is the case. These proofs are more efficient than the cryptographic capsule (c.f. [3]) methods used in <ref type="bibr">[6, 21.</ref> Also, we incorporate techniques, such as the Fiat-Shamir heuristic for removing interaction, that were not available at the time of <ref type="bibr" target="#b1">[2]</ref>. Some of these techniques can also be applied to the original <ref type="bibr" target="#b1">[2]</ref> protocol (with varying degrees of difficulty and utility). By using more modern techniques we can better realize the basic approach laid out by Benaloh and Yung.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Comparison to Related Work</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The Basic Scheme</head><p>We now describe the basic voting scheme. For simplicity, we assume that there are only two centers counting the votes, and that a single yes/no vote is being held. This scenario is solely to help understand the protocol given in Section 3. We note that this basic scheme does not protect privacy of one's vote against the centers. This issue will be overcome in Section 3, where we involve more than 2 centers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Preliminaries and Initial Preparation</head><p>We denote the two centers by C 1 and C2. Each vote v will be broken into shares x1 and x2, where xi is a member of Z,, and q is a prime. Before being posted, each share 26 is encrypted using encryption function Ei, where { E l , E2) form a family of partially compatible homomorphic encryption functions.</p><p>As part of the setup process, which need only be done once for all time, the parties agree on { E l , Ez}. Note that implementations based on discrete-log functions, there is no trapdoor information that need be kept hidden. Thus, for example a few bits from some global source can be fed into a pseudorandom bit generator and these random bits could be used t o choose the moduli and generators needed to specify the desired functions. Heuristically, anyone can provide the seed t o the pseudorandom generator, and it is unlikely that they will make it output a weak set of functions.</p><p>Along with setting up the family of encryption functions, we assume that basic primitives such as public-key cryptography and secure bit-string commitment have already been established. Let H ( s ) denote a possibly probabilistic hash function that commits the sender to x without giving away any useful information about 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">The Election Procedure</head><p>The basic election runs in three stages: vote preparation, vote casting and vote counting.</p><p>Vote Preparation Each voter i chooses his vote oi, 1 for yes-vote and -1 for no-vote. He uniformly generates xi1) and x i 2 ) such that</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1)</head><p>He then posts El(;t.il)) = a;' and E ~( z $ ' ) )</p><p>= a;'a) and proves xi(') + xi') E</p><p>(1, -1) without disclosing xi1), x i 2 ) nor 2ii. We discuss this proof in Section 2.3.</p><p>Voting Casting Each voter i encrypts xi1) and 2i2) using the public keys of C 1 and C2 respectively. Each center j computes E j ( z p ) ) and checks that it agrees with the previously posted value.</p><p>Counting Votes Each ccnter j sums up zp) modulo q for all voters i and posts sub-tally, tj. Each voter verifies that E j ( t j ) = n E j ( z P ) ) , j and computes T = tl + t 2 , which is equal to the number of "yes" votes minus the number of votes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Proving x1 + x2 E (1, -1)</head><p>In Figure <ref type="figure" target="#fig_3">1</ref> we exhibit a simple protocol for proving that zl +z2 E { 1, -1) mod q given E1(x1) and E2 <ref type="bibr" target="#b11">(12)</ref>. 2a. With probability $, the verifier asks the prover to reveal r and s. The verifier checks that T is consistent with R and that the above identities for YI and Y2 hold.  Each execution of the above protocol will catch a cheating prover with probability i. We note that the distribution of (Yl,Y,) is easy to simulate given ( E l ( z l ) , E z ( c 2 ) ) . Indeed, if R is a perfect zero-knowledge bit commitment then the protocol is perfect zero-knowledge. We note that a conceptually more simple protocol would have the prover reveal s(z2 -rj in Step 2b. We chose the above protocol for its reduccd communication complexity. Both s and t could also be eliminated by having the verifier check both possibilities, but this would save only 2 bits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>prove&amp;l(zl,</head><p>While we give this protocol in terms of a verifier, a more round efficient solution is to use the Fiat-Shamir method of eliminating interaction. First, the protocol is run many times (on the order of 40 or 60) in order to make the probability of withstanding all of the challenges vanishingly small. Then the verifier is replaced by a suitably "random looking" hash function which generates the challenges from the prover's posting in Step 1 of the protocol. If the prover is trying t o prove an incorrect statement, then heuristically his only strategy is to run different postings through the hash function until he finds one whose challenges he can meet. However, the cost of this attack is prohibitive if the error probability is truly small ( T 4 0 or 2-60).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Many Centers and Many Votes</head><p>In the basic scheme we outline above, there were only two centers and a single yes-no vote. However, in more practical scenarios a voter will want to divide his vote among as many centers as possiblethe more centers the more priva.te t,he vote. Also, a voter is likely to participate in many elections and a given election is likely to have many yes/no votes. For example, Benaloh points out that approval voting (where a voter may cast a vote for any number of the given candidat,es) is really just a case of several independent yes/no votes <ref type="bibr" target="#b2">[3]</ref>. In this section, we show how to split many votes over many centers with substantial amortized savings over preparing each vote separately.</p><p>For simplicity, we assume that there are only n centers and that each voter will split his votes over all n centers. For each center i we have an encryption function Ei from this family. Following the basic scheme, the voter breaks his vote v E { 1, -1) into shares X ( l ) , . . . , X ( " ) such that t i = X(l) + . . . + X ( " ) , and then proves that these shares are correctly constructed. The most straightforward solution is to adapt protocol prove*l to handle more than two shares. Instead, we break the proof into two stages. First, the prover randomly generates a , b such that 1) = a + b and proves that X ( l ) + . . . + X(n) = A + B . Then he uses p r o v e f l to prove that v = a + b. This gives us chance to handle multiple votes efficiently as shown in Subsection 3.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.1</head><p>Figure <ref type="figure" target="#fig_5">2</ref> gives our protocol, prove-sum, for reducing a sum of n encrypted shares t o a sum of 2 shares. We assume that the encryptions E i ( X ( i ) ) , E a ( A ) and Ea(B) are known, and that is a family of partially compatible homomorphic encryptions with domain Z,.</p><p>If the summation assertion is not triie, then in each iteration of the protocol the prover will fail a check with probability at least 3. As before, we lower this error rate to a very small value by repeated repetition, and then use the Fiat-Shamir heuristic t o make the proof noninteractive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P r o v i n g X ( ' ) + X ( ' ) + ---+ X(") = A + B</head><p>( E l , . . .,En, Ea, Eb)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Proving Equations Simultaneously</head><p>The bulk of computation and communication required for the full n-party scheme is taken up by the proof of the reduction to the 2-share sum. By combining many of these proofs into a single proof, the voter can efficiently prepare many " y e ~/ n o ~~ ballots at once with significant savings in the amortized computation and communication required.</p><p>Suppose that the voter wants to prove that the following equations hold.</p><p>prove-surn(X('), . . . , x("), A , B )</p><p>/* Given G ( X ( ' ) ) , . . . , E,(X(")), Ea(A), Eb(B), prove that X(') + X ( <ref type="formula">2</ref> By a simple probability argument, the following facts hold;</p><p>1. If all of the original linear equations were true, then the new linear equation</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>If at least one of the original linear equations is false, then the new linear will also be true, and equation will be false with probability 1l / q .</p><p>Thus, a proof of the new equation will suffice as a proof of all of the original equations.</p><p>It remains to show how to generate the encryptions for the new variables and how to choose the coefficients. The encryptions are given by j = 1 m j =1 rn . .</p><formula xml:id="formula_0">Eb(B) = n Eb(Aj)"' j = 1</formula><p>We can view the ci coefficients as challenges. As before, we can use the Fiat-Shamir trick and generate the ci by a hash function of the original encryptions. Note that in this case, we do not have to perform the operation multiple times, since for a random setting of the coefficients an error in the original set of equations will result in an error in the final equation with all but vanishing probability. Indeed, for computational efficiency it suffices to choose cj from { 1 , . . . , 260), which will greatly speed up the exponentiations.</p><p>We give a summary of the election scheme in Figure <ref type="figure">3</ref>.</p><p>m votes n centers Election Scheme Precomputation (In the following description, z ranges over 1,. . . , n , j ranges over 1,. . . , r n , and k ranges over the indices of dl valid voters v k . ) 1. T h e vote counters, C1, Cz,. . . , C,, agree on a randomly selected family of par- randomly chooses two representations for V k , j , V k , j = + XLZI + ' ' ' -t x i : :</p><formula xml:id="formula_1">= A k , J -t-B k , J .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>He posts E i ( x t { ) , E , ( A k , J ) and E b ( B k , j ) .</head><p>3 . v k executes the reduction given in Section 3.2 and obtains a single equation</p><formula xml:id="formula_2">X t ) + xp + . . . + xz"' = Ak + G k ,</formula><p>equality of which implies that the given two representations of masking vote l ) k , J are equal for all j. v k then proves the validity of the equation using prove-sum.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">. v k executes protocol provefl t o show that</head><p>A k , , + B k , 3 E (1, -1) for dl j.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">. V k encrypts</head><p>Xi:! using C,'s public encryption algorithm, for all j and i, and posts the encryptions.</p><p>Vote Casting 1. To use his j t h vote, voter k computes S k , 3 {-1,1} such that his actual vote is equal to s k , J V k , J , and posts j and S k , J . Note that often j is known and thus need not be sent. We assume that the correct j for each voter is known, and henceforth drop j from our notation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Vote Counting</head><p>1. Each center C, decrypts X i i ) for all k and j , and verifies whether it is consistent with E i ( X 2 ) ) . He calculates his subtdly t(') = ck s k . x:) and posts t(i).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Each person checking the vote verifies that n , ( E i ( X ~' ) ) u k is equal t o E i ( d i ) ) ,</head><p>If so, they accept c, &amp;') as the tally of the vote.</p><p>If precomputation is not used, then U k can be used as the a c t u d vote and s k i: omitted.</p><p>Fig. <ref type="figure">3</ref>. Overview of the general protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Efficiency</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Communication Cost</head><p>In this subsection, we roughly estimate communication cost of o u r scheme. While there are many possible variations of our scheme, a good understanding of their complexity can be had by analyzing the cost of splitting a vote into encrypted shares and proving that the shares are well formed.</p><p>A number of security parameters come into play in this analysis. First, let US assume that our encryption functions are based on modular exponentiation over Z;,, and let k be an upper bound on the length of pa. (if different moduli are uses, then they will not exactly the same size). Let h be the out,put of the hash function H used for commitments and let 1 be the security parameter that effectively denotes how many times the proofs are run.</p><p>We consider the most general case of splitting m votes t o n centers. Note that for m large, we achieve a higher amortized efficiency due to the method used in Section 3.2. Not counting the cost of the proof, representing these pieces along with the additional 2 shares used in our reduction requires ( n f 2 ) k m bits. The cost of proving the correctness of the combined equation (from Section </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Computation Cost for Voters</head><p>In this subsection, we roughly estimate computation cost for the voters. In the scheme, the costly computations are mainly modular multiplication and modular exponentiation. Note that many modular exponentiations with the same base are being done. We can exploit this fact by computing lookup tables that will reduce the number of multiplications required by the exponentiations. For example, we can precompute a: for all i's that are powers of 2. This will reduce the average Note that these figures are only approximate. However, the cost of the other modular addition or such operations as computing hash functions is comparatively negligible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.3</head><p>In this subsection, we roughly estimate the computation cost needed for verification. Here again, k is the length of p , and 1 is a security parameter which determines maximum probability of cheating. c is the length of coefficients used in the protocol which can be set, small. Also, modular exponentiation can exploit the previously mentioned table lookup techniques.</p><p>We again consider the case of splitting m votes into n shares each. f ( n +</p><p>2)1cl(m -1) multiplications are needed for generating the encryption of the shares, including their representation. i ( n + Z ) ( k + 1)1 multiplications are needed to verify that the combined equation is correct. (k + 1)lm multiplications are needed to complete the proofs that the shares are well formed. Altogether, this yields f[((n + 2)lcl+ 2Z(k -1))m + (n + 2)(kI -1 -IC~)] modular multiplications for each voter.</p><p>We can reduce this number by using techniques for verifying many modular exponentiations, resulting in a factor of 4 improvement over actually computing the exponentiations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Computation Cost for Verifying Other Voters</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.4</head><p>The work of [a] gave the first protocol where votes are divided into pieces and the verifiable subtally yields total outcome of voting. However, their scheme suffers from large communication complexity and seems not yet practical for implementation on existing networks. One of the reasons they need large communication complexity is that each centers i generate secret prime factors of their public key Nj . Therefore the scheme involves an interactive protocol to detect possible cheating at the setting of the public keys, together with an interactive protocol to show detected cheat was not due to a malicious voter. Also, since extra information of subtally may reveal these secret primes, an interactive protocol was necessary to prove the correctness of subtally. For above reasons, their protocol needed (41' + 51 + 2)kn bits for communication, where k is the size of the public keys of the n centers, and 1 is a security parameter.</p><p>The computation complexity is rather small for each iteration of their scheme, since the computation is based on yegr mod n where e and T are much smaller than n. However, since this interactive proof takes place many times, the total cost does not remain so small. We estimate their total computation assuming that they use the same trick constructing a table of yi mod n j that requires nrk bits. Then, there will be 3(1' + 31 + 1)lg rn + 2(12 + I + 1)" + [# of votersln n bit modular multiplication in total, where k is the size of public keys of the n centers, r determines number of votjers and 1 is a security parameter. We give a rough numerical comparison in Table <ref type="table" target="#tab_2">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Efficiency Comparisons with Previous Work</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Our work has been motivated by the work of Benaloh [GI and the later work of Benaloh and Yung [2]. The latter protocol enjoys most of desirable security properties we obtain, and is based on partially compatible homomorphisms of the form Ei(x) = y i + gf mod ni. The technical advances made by our work include:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>22) /* Given E1(21), E2(22), prove that 21 + xz E (1, -1) mod q */ 1. The prover uniformly chooses r E Z, and s E (1, -1). He computes R = H ( r ) , the secure commitment for r , computes YI = El(s(z1 + r ) ) = (EI(ZI)J%(~))' and Yz = E 2 ( s ( z zr ) ) = ( E z ( ~~) E z ( ~) -~) ' , and posts (Yi, yZ, R).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>2b.</head><label></label><figDesc>With probability f , the verifier asks the prover to reveal s(z1 + r ) and t = s(z1 + r ) + s ( z z -T ) E {l,-l}. He then checks that YI = (EI(Z~)EI(T))' and that Y2 = E2(ts(x1 + r ) ) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Protocol for proving validity of shares.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>1 Fig. 2 .</head><label>12</label><figDesc>Fig. 2 . Protocol for proving summation assertions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>2 .</head><label>2</label><figDesc>Each voter v k randomly chooses his "masking vote" ~1 1 , ~ E 11, -1} and then tially compatible encryption functions, E,, E b , { E , } and post them.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>(n+l)mk+[(2n+2)k+(n+l)h+(3k+h)m]l bits</head><label></label><figDesc>3.2)    is [2(n + 2)k + (n + l)h]l bits. At this point, the voter has proved that each set of n shares representing a vote is equal to the two auxiliary shares. The proof that the two auxiliary shares sum to 1 or -1 costs [3k + h]lm bits. The cost of revealing these shares to the proper counting authorities is approximately nkm bits. Altogether, this gives a total of 2. Some of the resulting numbers are shown in Tablel. If one uses the "center doubling" trick so as to need only one good center instead of two, then the costs are all doubled.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>from % k to $k, requiring a table size of (TI + 2 ) k 2 bits</head><label></label><figDesc>number of multiplications needed to compute crz mod p . Using a more sophisticated table, we can obtain a further factor of 3 for the typical number ranges.We again consider the case of splitting m votes into n shares each. Splitting for proving the reduction to the the reduced 2-share representation of a vote, klm multiplications are needed t o complete the proof that the votes are well formed. Verifying the subtallies of each center requires</figDesc><table><row><cell>( $ k + [# of voters])nrn modular multiplications.</cell></row><row><cell>Altogether, our protocol requires approximately</cell></row><row><cell>1 -[(%I + 2 + 21)m + ( n + 2)l]k + [# of voterslnrn</cell></row></table><note><p>m votes to mn pieces requires f ( n + 2)km multiplications. + ( T I + 2 ) k l multiplications are needed 2 modular multiplications. A PC running at 33MHz can executes 768 multiplicalions in a second. Based on this, some of the resulting numbers are shown in</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 .</head><label>1</label><figDesc></figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We would like to thank M r . Masumoto of Central Labs for pointing out a vulnerability in our earlier scheme and for supplying us with data on t h e computational capabilities of various machines. We would further like to thank Josh Benaloh, Moti Yung and anonymous referees for their valuable comments.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Receipt-free secret-ballot elections</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Benaloh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tuinstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC 94</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Distributing the power of a government to enhance the privacy of voters</title>
		<author>
			<persName><forename type="first">J</forename><surname>Benaloh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Distributed Computing</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Verifiable secret-ballot Elections</title>
		<author>
			<persName><forename type="first">J</forename><surname>Benaloh</surname></persName>
		</author>
		<idno>1987. YALEU/DCS/TR-561</idno>
		<imprint/>
	</monogr>
	<note>PhD thesis Yale University</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Subquadratic zero-knowledge</title>
		<author>
			<persName><forename type="first">J</forename><surname>Boyar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Brassard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Peralta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS 91</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Untraceable electronic mail, return addresses, and digital pseudonyms</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Communications of the ACM</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1981">1981</date>
			<biblScope unit="page" from="84" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A robust and verifiable cryptographically secure election scheme</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Fischer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="volume">85</biblScope>
			<biblScope unit="page" from="372" to="382" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">How to prove yourself: Practical solutions to identification and signature problems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Fiat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -Crypt0 &apos;86</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Communication complexity of secure computation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">92</biblScope>
			<biblScope unit="page" from="699" to="710" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A practical secret voting scheme for large scale elections</title>
		<author>
			<persName><forename type="first">A</forename><surname>Fujioka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ohta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -Auscrypt &apos;92</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="244" to="251" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A note on efficient zero-knowledge proofs and arguments</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC 92</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Multi-language zero knowledge interactive proof systems</title>
		<author>
			<persName><forename type="first">K</forename><surname>Kurosawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tsujii</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">All/Nothing election scheme and anonymous</title>
		<author>
			<persName><forename type="first">C</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Itoh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kurosawa</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1994. 1986. 1991. 1986. 1992</date>
			<biblScope unit="page" from="722" to="732" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">channel</title>
	</analytic>
	<monogr>
		<title level="m">Advances in Crypt,ology -EUROCRYPT &apos;93</title>
		<imprint>
			<date type="published" when="1991">1991. 1993</date>
			<biblScope unit="page" from="248" to="259" />
		</imprint>
	</monogr>
	<note>Advances in Cryptology -Crypt0 &apos;90</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
