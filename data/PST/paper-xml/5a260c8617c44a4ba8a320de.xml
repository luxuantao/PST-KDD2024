<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">SMASH: One-Shot Model Architecture Search through HyperNetworks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Andrew</forename><surname>Brock</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Engineering and Physical Sciences</orgName>
								<orgName type="institution">Heriot-Watt University Edinburgh</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Theodore</forename><surname>Lim</surname></persName>
							<email>t.lim@hw.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department">School of Engineering and Physical Sciences</orgName>
								<orgName type="institution">Heriot-Watt University Edinburgh</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Ritchie</surname></persName>
							<email>j.m.ritchie@hw.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department">School of Engineering and Physical Sciences</orgName>
								<orgName type="institution">Heriot-Watt University Edinburgh</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Nick</forename><surname>Weston</surname></persName>
							<email>nick.weston@renishaw.com</email>
							<affiliation key="aff1">
								<orgName type="institution">Renishaw plc Research Ave, North Edinburgh</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">SMASH: One-Shot Model Architecture Search through HyperNetworks</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T12:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Designing architectures for deep neural networks requires expert knowledge and substantial computation time. We propose a technique to accelerate architecture selection by learning an auxiliary HyperNet that generates the weights of a main model conditioned on that model's architecture. By comparing the relative validation performance of networks with HyperNet-generated weights, we can effectively search over a wide range of architectures at the cost of a single training run. To facilitate this search, we develop a flexible mechanism based on memory read-writes that allows us to define a wide range of network connectivity patterns, with ResNet, DenseNet, and FractalNet blocks as special cases. We validate our method (SMASH) on CIFAR-10 and CIFAR-100, STL-10, ModelNet10, and Imagenet32x32, achieving competitive performance with similarly-sized handdesigned networks.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The high performance of deep neural nets is tempered by the cost of extensive engineering and validation to find the best architecture for a given problem. High-level design decisions such as depth, units per layer, and layer connectivity are not always obvious, and the success of models such as Inception <ref type="bibr" target="#b38">[39]</ref>, ResNets <ref type="bibr" target="#b12">[13]</ref>, FractalNets <ref type="bibr" target="#b19">[20]</ref> and DenseNets <ref type="bibr" target="#b14">[15]</ref> demonstrates the benefits of intricate design patterns. Even with expert knowledge, determining which design elements to weave together requires ample experimental time.</p><p>In this work, we propose to bypass the expensive procedure of fully training candidate models by instead training an auxiliary model, a HyperNet <ref type="bibr" target="#b11">[12]</ref>, to dynamically generate the weights of a main model with variable architecture. Though these generated weights are worse than freely learned weights for a fixed architecture, we leverage the observation <ref type="bibr" target="#b20">[21]</ref> that the relative performance of different networks early in training (i.e. some distance from the eventual optimum) often provides a meaningful indication of performance at optimality. By comparing validation performance for a set of architectures using generated weights, we can approximately rank numerous architectures at the cost of a single training run.</p><p>To facilitate this search, we develop a flexible scheme based on memory read-writes that allows us to define a diverse range of architectures, with ResNets, DenseNets, and FractalNets as special cases. We validate our one-Shot Model Architecture Search through Hypernetworks (SMASH) for Convolutional Neural Networks (CNN) on CIFAR-10 and CIFAR-100 <ref type="bibr" target="#b18">[19]</ref>, Imagenet32x32 <ref type="bibr" target="#b6">[7]</ref>, ModelNet10 <ref type="bibr" target="#b40">[41]</ref>, and STL-10 <ref type="bibr" target="#b7">[8]</ref>, achieving competitive performance with similarly-sized hand-designed networks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>arXiv:1708.05344v1 [cs.LG] 17 Aug 2017</head><p>Modern practical methods for optimizing hyperparameters rely on random search <ref type="bibr" target="#b3">[4]</ref> or Bayesian Optimization (BO) <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b33">34]</ref>, treating the model performance as a black box. While successful, these methods require multiple training runs for evaluation (even when starting with a good initial model) and, in the case of BO, are not typically used to specify variable-length settings such as the connectivity and structure of the model under consideration. Relatedly, bandit-based methods <ref type="bibr" target="#b20">[21]</ref> provide a framework for efficiently exploring the hyperparameter space by employing an adaptive early-stopping strategy, allocating more resources to models which show promise early in training.</p><p>Evolutionary techniques <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b37">38,</ref><ref type="bibr" target="#b39">40]</ref> offer a flexible approach for discovering variegated models from trivial initial conditions, but often struggle to scale to deep neural nets where the search space is vast, even with enormous compute power <ref type="bibr" target="#b25">[26]</ref>.</p><p>Reinforcement learning methods <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b43">44]</ref> have been used to train an agent to generate network definitions using policy gradients. These methods start from trivial architectures and discover models that achieve very high performance, but can require twelve to fifteen thousand full training runs to arrive at a solution.</p><p>The method that most resembles our own is that of Saxe et al. <ref type="bibr" target="#b28">[29]</ref>, who propose to efficiently explore various architectures by training only the output layer of convolutional networks with random convolutional weights. While more efficient than fully training an entire network end-to-end, this method does not appear to scale to deeper networks <ref type="bibr" target="#b41">[42]</ref>. Our method is conceptually similar, but replaces random weights with weights generated through HyperNets <ref type="bibr" target="#b11">[12]</ref>, which are one of a class of techniques for dynamically adapting weights through use of an auxiliary model <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b30">31]</ref>. In our case we learn a transform from a binary encoding of an architecture to the weight space, rather than learning to adapt weights based on the model input.</p><p>Our method is explicitly designed to evaluate a wide range of model configurations (in terms of connectivity patterns, and units per layer) but does not address other hyperparameters such as regularization, learning rate schedule, weight initialization, or data augmentation. Unlike the aforementioned evolutionary or RL methods, we explore a somewhat pre-defined design space, rather than starting with a trivial model and designating a set of available network elements. While we still consider a rich set of architectures, our method cannot discover wholly new structures on its own and is constrained in that it only dynamically generates a specific subset of the model parameters. Additionally, although our method is not evolutionary, our encoding scheme is reminiscent of CGP <ref type="bibr" target="#b22">[23]</ref>.</p><p>Stochastic regularization techniques such as Dropout <ref type="bibr" target="#b34">[35]</ref>, Swapout <ref type="bibr" target="#b31">[32]</ref>, DropPath <ref type="bibr" target="#b19">[20]</ref> or stochastic depth <ref type="bibr" target="#b13">[14]</ref> superficially resemble our method, in that they obtain variable configurations by randomly dropping connectivity paths in a fixed network architecture. Convolutional neural fabrics <ref type="bibr" target="#b29">[30]</ref>, for example, leverage this idea to attempt to train one large network as an implicit ensemble of all subnetworks produced through dropping paths. A key element that sets our method apart is that the weights for each node in our network are dynamically generated, rather than fixed; if a Dropout ensemble were to visit a unit that had not previously been trained, the unit's weights would be completely untuned. Our method generalizes even to previously unseen architectures, and the network we train under stochastic conditions is merely a proxy we use to evaluate various network configurations, rather than the final model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">One-Shot Model Architecture Search through HyperNetworks</head><p>In SMASH (Algorithm 1), our goal is to rank a set of neural network configurations relative to one another based on each configuration's validation performance, which we accomplish using weights generated by an auxiliary network. At each training step, we randomly sample a network architecture, generate the weights for that architecture using a HyperNet, and train the entire system end-to-end through backpropagation. When the model is finished training, we sample a number of random architectures and evaluate their performance on a validation set, using weights generated by the HyperNet. We then select the architecture with the best estimated validation performance and train its weights normally. </p><formula xml:id="formula_0">E v = f c (H(c), x v ) end loop</formula><p>Fix architecture and train normally with freely-varying weights W SMASH comprises two core components: the method by which we sample architectures, and the method by which we sample weights for a given architecture. For the former, we develop a memorybank view of feed-forward networks that permits sampling complex, branching topologies, and encoding said topologies as binary vectors. For the latter, we employ a HyperNet <ref type="bibr" target="#b11">[12]</ref> that learns to map directly from the binary architecture encoding to the weight space.</p><p>We hypothesize that so long as the HyperNet learns to generate reasonable weights, the validation error of networks with generated weights will correlate with the performance when using normally trained weights, with the difference in architecture being the primary factor of variation. Throughout the paper, we refer to the entire apparatus during the first part of training (the HyperNet, the variable architecture main network, and any freely learned main network weights) as the SMASH network, and we refer to networks with freely learned weights but SMASH-derived architectures as resulting networks. In order to explore a broad range of architectures with variable depth, connectivity patterns, layer sizes and beyond, we require a flexible mechanism for defining such architectures, which we can also easily encode into a conditioning vector for the HyperNet. To this end, we espouse a "memory-bank" view of feed-forward networks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Defining Variable Network Configurations</head><p>Rather than viewing a network as a series of operations applied to a forward-propagating signal, we view a network as having a set of memory banks (initially tensors filled with zeros) which it can read and write. Each layer is thus an operation that reads data from a subset of memory, modifies the data, and writes the result to another subset of memory. For a single-branch architecture, the network has one large memory bank it reads and overwrites (or, for a ResNet, adds to) at each op. A branching architecture such as a DenseNet reads from all previously written banks and writes to an empty bank, and a FractalNet follows a more complex read-write pattern, as shown in Figure <ref type="figure" target="#fig_0">1</ref>.</p><p>Our base network structure consists of multiple blocks (Figure <ref type="figure" target="#fig_1">2(b)</ref>), where each block has a set number of memory banks at a given spatial resolution, with successively halved spatial resolutions as in most CNN architectures. Downsampling is accomplished via a 1x1 convolution followed by  average pooling <ref type="bibr" target="#b14">[15]</ref>, with the weights of the 1x1 convolution and the fully-connected output layer being freely learned, rather than generated.</p><p>When sampling an architecture, the number of banks and the number of channels per bank are randomly sampled at each block. When defining each layer within a block, we randomly select the read-write pattern and the definition of the op to be performed on the read data. When reading from multiple banks we concatenate the read tensors along the channel axis, and when writing to banks we add to the tensors currently in each bank. For all reported experiments, we only read and write from banks at one block (i.e. one spatial resolution), although one could employ resizing to allow reading and writing from any block, similar to <ref type="bibr" target="#b29">[30]</ref>.</p><p>Each op comprises a 1x1 convolution (reducing the number of incoming channels), followed by a variable number of convolutions interleaved with nonlinearities, as shown in Figure <ref type="figure" target="#fig_1">2</ref>(a). We randomly select which of the four convolutions are active, along with their filter size, dilation factor, number of groups, and the number of output units (i.e. the layer size). The number of output channels of the 1x1 conv is some chosen "bottleneck ratio" of the number of output channels of the op.</p><p>The weights for the 1x1 convolution are generated by the HyperNet as described in Section 3.2, while the other convolutions are normally learned parameters. To ensure variable depth, we learn a single set of 4 convolutions for each block, and share it across all ops within a block. We limit the max filter size and number of output units, and when a sampled op uses less than the maximum of either, we simply slice the weight tensor to the required size. The fixed transition convolutions and output layer employ this same slicing based on the number of incoming non-empty memory banks. Exact details regarding this scheme are available in the appendix.</p><p>In designing our scheme, we strive to minimize the number of static learned parameters, placing the majority of the network's capacity in the HyperNet. A notable consequence of this goal is that we only employ BatchNorm <ref type="bibr" target="#b15">[16]</ref> at downsample layers and before the output layer, as the layer-specific running statistics are difficult to dynamically generate. We experimented with several different normalization schemes including WeightNorm <ref type="bibr" target="#b27">[28]</ref>, LayerNorm <ref type="bibr" target="#b1">[2]</ref> and NormProp <ref type="bibr" target="#b0">[1]</ref> but found them to be unstable in training.</p><p>Instead, we employ a simplified version of WeightNorm where we divide the entirety of each generated 1x1 filter by its Euclidean norm (rather than normalizing each channel separately), which we find to work well for SMASH and to only result in a minor drop in accuracy when employed in fixed-architecture networks. No other convolution within an op is normalized. A HyperNet <ref type="bibr" target="#b11">[12]</ref> is a neural net used to parameterize the weights of another network, the main network. For a Static HyperNet with parameters H, the main network weights W are some function (e.g. a multilayer perceptron) of a learned embedding z, such that the number of learned weights is typically smaller than the full number of weights for the main network. For a Dynamic HyperNet, the weights W are generated conditioned on the network input x, or, for recurrent networks, on the current input x t and the previous hidden state h t−1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Learning to map architectures to weights</head><p>We propose a variant of a Dynamic Hypernet which generates the weights W based on a tensor encoding of the main network architecture c. Our goal is to learn a mapping W = H(c) that is reasonably close to the optimal W for any given c, such that we can rank each c based on the validation error using HyperNet-generated weights. We thus adopt a scheme for the layout of c to enable sampling of architectures with wildly variable topologies, compatibility with the toolbox available in standard libraries, and to make c's dimensions as interpretable as possible.</p><p>Our HyperNet is fully convolutional, such that the dimensionality of the output tensor W varies with the dimensionality of the input c, which we make a 4D tensor of the standard format BCHW, with a batch size of 1 so that no output elements are wholly independent. This allows us to vary the depth and width of the main network by increasing the height or width of c. Under this scheme, every slice of the spatial dimensions of W corresponds to a specific subset of c. Information describing the op that uses that W subset is embedded in the channel dimension of the corresponding c slice.</p><p>For example, if an op reads from memory banks 1, 2, and 4, then writes to 2 and 4, then the first, second, and fourth channels of the corresponding slice of c will be filled with 1s (indicating the read pattern) and the sixth and eighth channels of that slice will be filled with 1s (indicating the write pattern). The rest of the op description is encoded in the remaining channels in a similar 1-hot fashion.</p><p>We only encode into the width-wise extent of c based on the number of output units of the op, so elements of c which do not correspond to any elements of W are empty.</p><p>A naïve implementation of this scheme might require the size of c to be equal to the size of W , or have the HyperNet employ spatial upsampling to produce more elements. We find these choices to work poorly, and instead employ a channel-based weight-compression scheme that reduces the size of c and keeps the representational power of the HyperNet proportional to that of the main networks. We make the spatial extent of c some fraction k of the size of W , and place k units at the output of the HyperNet, then reshape the resulting 1 × k × height × width tensor to the required size of W . k is chosen to be DN 2 , where N is the minimum memory bank size, and D is a "depth compression" hyperparameter that represents how many slices of W correspond to a single slice of c. Complete details regarding this scheme (and the rest of the encoding strategy) are available in Appendix B.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Experiments</head><p>We apply SMASH to several datasets, both for the purposes of benchmarking against other techniques, and to investigate the behavior of SMASH networks. Principally, we are interested in determining whether the validation error of a network using SMASH-generated weights (the "SMASH score") correlates with the validation of a normally trained network, and if so, the conditions under which the correlation holds. We are also interested in the transferability of the learned architectures to new datasets and domains, and how this relates to normal (weight-wise) transfer learning.</p><p>Our code<ref type="foot" target="#foot_0">1</ref> is written in PyTorch <ref type="bibr" target="#b23">[24]</ref> to leverage dynamic graphs, and explicitly defines each sampled network in line with the memory-bank view to avoid obfuscating its inner workings behind (potentially more efficient) abstractions. We omit many hyperparameter details for brevity; full details are available in the appendices, along with visualizations of our best-found architectures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Testing the SMASH correlation</head><p>First, we train a SMASH network for 300 epochs on CIFAR-100, using a standard annealing schedule <ref type="bibr" target="#b14">[15]</ref>, then sample 250 random architectures and evaluate their SMASH score on a held-out validation set formed of 5,000 random examples from the original training set. We then sort the architectures by their SMASH score and select every 5th architecture for full training and evaluation, using an accelerated training schedule of 30 epochs. For these networks, which we deem SMASHv1, the architecture uses a fixed memory bank size (though a variable number of banks in each block), a single fixed 3x3 conv in the main body of the op (rather than the variable 2x2 array of convs), a single group, and a fixed bottleneck ratio of 4. The variable elements comprise the read-write pattern, the number of output units, and the dilation factor of the 3x3 filter. When sampling architectures, we allocate a random, upper-bounded compute budget to each block.</p><p>Under these conditions, we observe a correlation (Figure <ref type="figure">4</ref>) between the SMASH score and the true validation performance, suggesting that SMASH-generated weights can be used to rapidly compare architectures. It is critical not to overstate this claim; this test is arguably a single datapoint indicating that the correlation holds in this scenario, but neither guarantees the correlation's generality nor implies the range of conditions for which it will hold. The expense of running this experiment prohibits a satisfactory number of repeat trials, so we instead construct different experiments.</p><p>For our second experiment, we train a low-budget SMASH network (to permit more rapid testing) with a much smaller HyperNet relative to the main network (though still the standard ratio of generated to freely learned weights). We expect the decreased capacity HyperNet to be less able to learn to generate good weights for the full range of architectures, and for the correlation between SMASH score and true performance to therefore be weak or nonexistent. The results of this study are shown in Figure <ref type="figure" target="#fig_3">5</ref>(a), where we arguably observe a breakdown of the correlation.</p><p>For our third experiment, we train a high-budget SMASH network and drastically increase the ratio of normally learned parameters to HyperNet-generated parameters, such that the majority of the net's model capacity is in non-generated weights. Under these conditions, the validation errors achieved with SMASH-generated weights are much lower than validation errors achieved with an equivalent SMASH network with the typical ratio, but the resulting top models are not as performant and we found that (in the very limited number of correlation tests we performed) the SMASH score did not correlate with true performance. This highlights two potential pitfalls: first, if the HyperNet is not responsible for enough of the network capacity, then the aggregate generated and learned weights may not be sufficiently well-adapted to each sampled architecture, and therefore too far from optimal to be used in comparing architectures. Second, comparing SMASH scores for two separate SMASH networks can be misleading, as the SMASH score is a function of both the normally learned and generated weights, and a network with more fixed weights may achieve better SMASH scores even if the resulting nets are no better.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Architectural Gradient Descent by Proxy</head><p>As an additional test of our method, we examine whether or not the HyperNet has learned to take into account the architecture definition in c, or whether it ignores c and naively generates an unconditional subspace of weights that happen to work well. We "trick" the HyperNet by sampling one architecture, but asking it to generate the weights for a different architecture by corrupting the encoding tensor c (e.g. by shuffling the dilation values). For a given architecture, we find that SMASH validation performance is consistently highest when using the correct encoding tensor, suggesting that the HyperNet has indeed learned a passable mapping from architecture to weights.</p><p>Following this, we posit that if the HyperNet learns a meaningful mapping W = H(c), then the classification error E = f (W, x) = f (H(c), x) can be backpropagated to find dE dc , providing an approximate measure of the error with respect to the architecture itself. If this holds true, then perturbing the architecture according to the dE dc vector (within the constraints of our scheme) should allow us to guide the architecture search through a gradient descent-like procedure. Our preliminary tests with this idea did not yield better SMASH scores than randomly perturbing the architectural definition, though we suspect that this was in part due to our lack of an intuitively satisfying update rule for the discrete architecture space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Transfer Learning</head><p>Models with weights initially learned on one large dataset frequently outperform models trained from scratch on a smaller dataset; it follows that architectures might display the same behavior. We test on STL-10 [8], a small dataset of 96x96 images similar to the CIFAR datasets. We compare the performance of the best-found architecture from CIFAR-100 (with weights trained from scratch on STL-10) to the best-found architecture from running SMASH on STL-10, and a WRN baseline. For these experiments, we make use of the full 5,000 images in the training set; in the following section we also include comparisons against a WRN baseline using the recommended 10-fold training split.</p><p>In this case, we find that the best-found architecture from CIFAR-100 outperforms the best-found architecture from STL-10, achieving 17.54% and 20.275% error, respectively. For reference, a baseline WRN28-10 and WRN40-4 achieve respective 15.43% and 16.06% errors. This presents an interesting phenomenon: one the one hand, one might expect the architecture discovered on STL-10 to be better-tuned to STL-10 because it was specifically learned on that dataset. On the other hand, CIFAR-100 has significantly more training examples, potentially making it a better dataset for distinguishing between good architectures, i.e. accuracy on CIFAR-100 is more indicative of generality. The better performance of the architecture found on CIFAR-100 would seem to favor the latter hypothesis, suggesting that architecture search benefits from larger training sets moreso than domain specificity.</p><p>We next investigate how well our best-found CIFAR-100 architecture performs on ModelNet10 <ref type="bibr" target="#b40">[41]</ref>, a 3D object classification benchmark. We train on the voxelated instances of the ModelNet10 training set using the settings of <ref type="bibr" target="#b4">[5]</ref>, and report accuracy on the ModelNet10 test set. Our 8M parameter model achieves an accuracy of 93.28%, compared to a 93.61% accuracy from a hand-designed Inception-ResNet <ref type="bibr" target="#b4">[5]</ref> with 18M parameters trained on the larger ModelNet40 dataset.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Benchmarking</head><p>We run SMASH on CIFAR-10 and 100, augmenting our search space from the initial correlation experiment to include variable filter sizes, variable groups, and the full variable op structure shown in Figure <ref type="figure" target="#fig_1">2</ref>, and denote the resulting networks SMASHv2. We report the final test performance of the two resulting networks with the highest SMASH scores on CIFAR-10 and 100 in Table <ref type="table" target="#tab_3">1</ref>.</p><p>Next, we take our best-found SMASHv2 architecture from CIFAR-100 and train it on STL-10 [8] using the recommended 10-fold training splits, and ImageNet32x32 <ref type="bibr" target="#b6">[7]</ref>. We compare against Wide ResNet baselines from our own experiments in Tables 2 and those reported by <ref type="bibr" target="#b6">[7]</ref> in 3. Noting the better performance of WRN40-4 on STL-10, we also train a variant of our best architecture with only a single main convolution and 3x3 filters, to comparably reduce the number of parameters. Our SMASHv2 nets with 16M parameters achieve final test errors of 20.60% on CIFAR-100 and 4.03% on CIFAR-10. This performance is not quite on par with state-of-the-art hand-designed networks, but compares favorably to other automatic design methods that employ RL <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b43">44]</ref> or evolutionary methods <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b37">38]</ref>. Our networks outperform Large-Scale Evolution <ref type="bibr" target="#b25">[26]</ref> despite requiring significantly less time to discover (though not starting from trivial models) and 10 orders of magnitude less compute. Our method outperforms MetaQNN <ref type="bibr" target="#b2">[3]</ref> but lags behind Neural Architecture Search <ref type="bibr" target="#b43">[44]</ref>, though both methods require vastly more computation time, and unlike Neural Architecture Search, we do not postprocess our discovered architecture through hyperparameter grid search.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>In this work, we explore a technique for accelerating architecture selection by learning a model over network parameters, conditioned on the network's parametric form. We introduce a flexible scheme for defining network connectivity patterns and generating network weights for highly variable architectures. Our results demonstrate a correlation between performance using suboptimal weights generated by the auxiliary model and performance using fully-trained weights, indicating that we can efficiently explore the architectural design space through this proxy model. Our method achieves competitive, though not state-of-the-art performance on several datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A: Hyperparameters</head><p>We briefly describe they hyperparameters used for the SMASH network in our experiments. The SMASHv1 network has memory banks with N = 6 channels each, a maximum of 240 memory banks per block (though on average less than half that number), and a depth compression ratio of D = 3. Each layer's number of units is uniformly sampled between 6 and 42 (along even multiples of 6), and its dilation factor is uniformly sampled between 1 and 3 (with 1 representing no dilation and 3 representing 2 zeros inserted between each filter). We employ a constant bottlneck ratio of 4 as in <ref type="bibr" target="#b14">[15]</ref>, so the output of the HyperNet-generated 1x1 convolution is always 4 times the number of output units. We constrain the main network to have a maximum budget of 16M parameters, though due to our sampling procedure we rarely sample networks with more than 5M parameters.</p><p>Our SMASHv2 networks have variable memory bank sizes at each blocks, which we constrain to be multiples of N = 8 up to Nmax = 64. We sample filter sizes from <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b6">7]</ref>, and sample dilation values such that the max spatial extent of a filter in any direction is 9. We sample convolutional groups as factors of the base N value (so <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b7">8]</ref> for these networks). We put some hand-designed priors on the choice of op configuration (i.e. which convolutions are active), giving slight preference to having all four convolutions active. For SMASHv2 nets we employ a slightly more complex bottleneck ratio: the output of the 1x1 conv is equal to the number of incoming channels while that number is less than twice the number of output units, at which point it is capped (so, a maximum bottleneck ratio of 2).</p><p>Our HyperNet is a DenseNet, designed ad-hoc to resemble the DenseNets in the original paper <ref type="bibr" target="#b14">[15]</ref> within the confines of our encoding scheme, and to have round numbers of channels. It consists of a standard (nonbottleneck) Dense Block with 8 3x3 convolutional layers and a growth rate of 10, followed by a 1x1 convolution that divides the number of channels in two, a Dense Block with 10 layers and a growth rate of 10, another compressing 1x1 convolution, a Dense Block with 4 layers and a growth rate of 10, and finally a 1x1 convolution with the designated number of output channels. We use Leaky ReLU with a negative slope of 0.02 as a defense against NaNs, as standard ReLU would obfuscate their presence when we had bugs in our early code revisions; we have not experimented with other activations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix B: Encoding Scheme Details</head><p>We adopt a scheme for the layout of the embedding tensor to facilitate flexibility, compatibility with the convolutional toolbox available in standard libraries, and to make each dimension interpretable. First, we place some constraints on the hyperparameters of the main network: each layer's number of output units must be divisible by the memory bank size N and be less than Nmax, and the number of input units must be divisible by D, where N is the number of channels in each memory bank, and Nmax and D are chosen by the user. Applying these constraints allows us to reduce the size of the embedding vector by DN 2 , as we will see shortly.</p><p>The input to a standard 2D CNN is x ∈ R B×C×H×L , where B, C, H, and L respectively represent the Batch, Channel, Height, and Length dimensions. Our embedding tensor is c ∈ R 1×(2M +dmax)×(Nmax/N ) 2 ×n ch /D where M is the maximum number of memory banks in a block, dmax is the maximum kernel dilation, and n ch is the sum total of input channels to the 1x1 convs of the main network.</p><p>The conditional embedding c is a one-hot encoding of the memory banks we read and write at each layer. It has 2M + dmax channels, where the first M channels represent which banks are being read from, the next M channels represent which banks are being written to, and the final dmax channels are a one-hot encoding of the dilation factor applied to the following 3x3 convolution. The height dimension corresponds to the number of units at each layer, and the length dimension corresponds to the network depth in terms of the total number of input channels. We keep the Batch dimension at 1 so that no signals propagate wholly independently through the HyperNet. Figure <ref type="figure" target="#fig_2">3</ref> shows an example of a small randomly sampled network, its equivalent memory bank representation, and how the read-write pattern is encoded in c. The dilation encoding is omitted in Figure <ref type="figure" target="#fig_2">3</ref> for compactness.</p><p>Our HyperNet has 4DN 2 output channels, such that the output of the HyperNet is</p><formula xml:id="formula_1">W = H(c) ∈ R 1×4DN 2 ×(Nmax/N ) 2 ×n ch /D</formula><p>, which we reshape to W ∈ R Nmax×4Nmaxn ch ×1×1 . We generate the weights for the entire main network in a single pass, allowing the HyperNet to predict weights at a given layer based on weights at nearby layers. The HyperNet's receptive field represents how far up or down the network it can look to predict parameters at a given layer. As we traverse the main network, we slice W along its second axis according to the number of incoming channels, and slice along the first axis according to the width of the given layer.  ks: [ <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b2">3]</ref>, <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5]</ref>, <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5]</ref>, <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b4">5]</ref>] d: [ <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3]</ref>, <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b0">1]</ref>, <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b0">1]</ref>, <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b0">1]</ref>]</p><formula xml:id="formula_2">+ + + + + trans0 N: 32, op: [1, 1, 1, 1]</formula><p>, groups: <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b3">4]</ref> ks: [ <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b4">5]</ref>, <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b6">7]</ref>, <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b4">5]</ref>, <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b4">5]</ref> ks: [ <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b4">5]</ref>, <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b4">5]</ref>, <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b6">7]</ref>, <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b2">3]</ref>   ks: [ <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b2">3]</ref>, <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b2">3]</ref>, <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b2">3]</ref>, <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b4">5]</ref>] d: [ <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b0">1]</ref>, <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b2">3]</ref>, <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b1">2]</ref>, <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref>] N: 56, op: [1, 0, 0, 0], groups: [2, X, X, X] ks: [ <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b4">5]</ref>, X, X, X] d: [ <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref>, X, X, X] N: 56, op: [1, 1, 1, 1], groups: [1, 2, 1, 1] ks: [ <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b6">7]</ref>, <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b4">5]</ref>, <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b2">3]</ref>, <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5]</ref>] d: [ <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b0">1]</ref>, <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b0">1]</ref>, <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b1">2]</ref>, <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b1">2]</ref>] N: 56, op: [1, 1, 1, 1], groups: <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b3">4]</ref> ks: [ <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b6">7]</ref>, <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5]</ref>, <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b6">7]</ref>, <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b2">3]</ref>     </p><formula xml:id="formula_3">d: [[1, 3], [1, 1], [3, 1], X] N: 40, op: [1, 1, 0, 0], groups: [2, 4, X, X] ks: [[3, 7], [5, 7], X, X] d: [[1, 1], [1, 1], X, X] + + + N: 8, op: [1, 1, 1, 1], groups: [4, 2, 1, 2] ks: [[3, 7], [7, 5], [3, 3], [3, 7]] d: [[3, 1], [1, 1], [2, 1], [2, 1]] + + + + N: 16, op: [1, 1, 1, 0], groups: [1, 4, 4, X] ks: [[7, 5], [3, 7], [5, 7], X] d: [[1, 1], [1, 1], [1, 1], X] + + N: 56, op: [1, 1, 1, 1], groups: [1, 4, 1, 1] ks: [[7, 5], [3, 3], [3, 3], [3, 3]] d: [[1, 1], [1, 2], [2, 1], [3, 1]] N: 40, op: [1, 1, 1, 1], groups: [1, 4, 4, 2] ks: [[3, 3], [3, 5], [5, 3], [3, 3]] d: [[1, 3], [1, 1], [1, 3], [<label>3, 2]]</label></formula></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Memory-Bank representations of ResNet, DenseNet, and FractalNet blocks.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: (a) Structure of one op: A 1x1 conv operating on the memory banks, followed by up to 2 parallel paths of 2 convolutions each. (b) Basic network skeleton.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: An unrolled graph, its equivalent memory-bank representation, and its encoded embedding.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: (a) SMASH correlation with a crippled HyperNet. Error bars represent 1 standard deviation. (b) SMASH scores vs. rank using average scores from three HyperNets with different seeds.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure</head><label></label><figDesc>Figure 6: A simplified version of our best-found SMASHv2 architecture from CIFAR-100 with the highest SMASH score. N represents number of output units, op</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>, op: [1, 1, 1, 1], groups: [4, 2, 2, 1] ks: [<ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b2">3]</ref>,<ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b2">3]</ref>,<ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b2">3]</ref>,<ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b6">7]</ref>] d: [[2, 2], [3, 1], [1, 3], [1, 1]] N: 32, op: [1, 1, 0, 0], groups: [2, 4, X, X] ks: [[3, 3], [3, 3], X, X] d: [[1, 1], [1, 2], X, X] N: 32, op: [1, 1, 0, 0], groups: [4, 2, X, X] ks: [[5, 3], [3, 7], X, X] d: [[2, 2], [2, 1], X, X]N: 64, op: [1, 0, 1, 0], groups: [2, X, 1, X] ks: [<ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b6">7]</ref>, X,<ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5]</ref></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: An expanded (though still partially simplified) view of the first block of our best SMASHv2 net.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>trans0N:</head><label></label><figDesc>56, op: [1, 0, 0, 0], groups: [1, X, X, X] ks: [<ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b6">7]</ref>, X, X, X] d: [[2, 1], X, X, X] N: 56, op: [1, 0, 1, 0], groups: [1, X, 1, X] ks: [<ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b4">5]</ref>, X,<ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b4">5]</ref>, X] d: [[1, 2], X, [2, 2], X] N: 56, op: [1, 1, 1, 1], groups: [1, 2, 1, 1]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: An expanded (though still partially simplified) view of the final block of our best SMASHv2 net. Floating paths are an artifact of the graph generation process, and are actually attached to the nearest rectangular node.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: An expanded (though still partially simplified) view of the first block of our best SMASHv1 net. Floating paths are an artifact of the graph generation process, and are actually attached to the nearest rectangular node.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>1 Figure 12 :</head><label>112</label><figDesc>Figure 12: An expanded (though still partially simplified) view of the second block of our best SMASHv1 net. Floating paths are an artifact of the graph generation process, and are actually attached to the nearest rectangular node.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: An expanded (though still partially simplified) view of the final block of our best SMASHv1 net. Floating paths are an artifact of the graph generation process, and are actually attached to the nearest rectangular node.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Algorithm 1 SMASH input Space of all candidate architectures, R c Initialize HyperNet weights H loop Sample input minibatch x i , random architecture c and architecture weights W = H(c) Get training error E t = f c (W, x i ) = f c (H(c), x i ), backprop and update H end loop loop Sample random c and evaluate error on validation set</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1 :</head><label>1</label><figDesc>Error rates (%) on CIFAR-10 and CIFAR-100 with standard data augmentation (+).</figDesc><table><row><cell>Method FractalNet [20] with Dropout/Drop-path Wide ResNet [43] DenseNet-BC (k = 24) [15] DenseNet-BC (k = 40) Shake-Shake [11] Neural Architecture Search w/ RL[44] MetaQNN [3] Large-Scale Evolution [26] CGP-CNN [38] SMASHv1 SMASHv2</cell><cell>Depth 21 21 16 28 250 190 26 39 9 ---116 211</cell><cell>Params 38.6M 38.6M 11.0M 36.5M 15.3M 25.6M 26.2M 32.0M 11.18M 5.4M 40.4 M 1.68M 4.6M 16M</cell><cell>C10+ 5.22 4.60 4.81 4.17 3.62 3.46 2.86 3.84 6.92 5.40 -5.98 5.53 4.03</cell><cell>C100+ 23.30 23.73 22.07 20.50 17.60 17.18 15.85 -27.14 -23.7 -22.07 20.60</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 :</head><label>2</label><figDesc>Error rates (%) on STL-10.</figDesc><table><row><cell>Model</cell><cell>Params</cell><cell>Error</cell></row><row><cell cols="3">WRN-40-4 WRN-28-10 SMASHv2 SMASHv2 (3x3) 4.38M 37.76 ± 0.58 8.95M 35.02 ± 1.14 36.5M 36.69 ± 2.06 16.2M 41.52 ± 2.10</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 3 :</head><label>3</label><figDesc>Error rates (%) on Imagenet32x32.</figDesc><table><row><cell>Model</cell><cell>Params Top-1 Top-5</cell></row><row><cell cols="2">WRN-28-2 1.6M 56.92 30.92 WRN-28-5 9.5M 45.36 21.36 WRN-28-10 37.1M 40.96 18.87 SMASHv2 16.2M 38.62 16.33</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">https://github.com/ajbrock/SMASH</note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix C: Experiment Details</head><p>At each training step, we sample a network architecture block-by-block, with a random (but upper bounded) computational budget allocated to each block. For SMASHv1, We use memory banks with N = 6 channels each, constrain the number of incoming memory banks to be a multiple of 3 (D = 3), and constrain the number of output units at each layer to be a multiple of 6 (with Nmax = 42) for compatibility with the memory layout.</p><p>Our HyperNet is a 26 layer DenseNet, each layer of which comprises a Leaky ReLU activation followed by a 3x3 convolution with simplified WeightNorm and no biases. We do not use bottleneck blocks, dropout, or other normalizers in the HyperNet.</p><p>When sampling our SMASHv2 networks for evaluation, we first sample 500 random architectures, then select the architecture with the highest score for further evaluation. We begin by perturbing this architecture, with a 5% chance of any individual element being randomly resampled, and evaluate 100 random perturbations from this base. We then proceed with 100 perturbations in a simple Markov Chain, where we only accept an update if it has a better SMASH score on the validation set.</p><p>When training a resulting network we make all parameters freely learnable and replace simple WeightNorm with standard BatchNorm. We tentatively experimented with using SMASH generated weights to initialize a resulting net, but found standard initialization strategies to work better, presumably because of the disparity between the dynamics of the SMASH network using WeightNorm against the resulting network using BatchNorm.</p><p>In line with our claim of "one-shot" model search, we keep our exploration of the SMASH design space to a minimum. We briefly experimented with three different settings for N and D, and use a simple, ad-hoc DenseNet architecture for the HyperNet, which we do not tune.</p><p>When training SMASH, we use Adam <ref type="bibr" target="#b17">[18]</ref> with the initial parameters proposed by <ref type="bibr" target="#b24">[25]</ref> When training a resulting network, we use Nesterov Momentum with an initial step size of 0.1 and a momentum value of 0.9. For all tests other than the initial SMASHv1 experiments, we employ a cosine annealing schedule <ref type="bibr" target="#b21">[22]</ref> without restarts <ref type="bibr" target="#b10">[11]</ref>.</p><p>For the CIFAR experiments, we train the SMASH network for 100 epochs and the resulting networks for 300 epochs, using a batch size of 50 on a single GPU. On ModelNet10, we train for 100 epochs. On ImageNet32x32, we train for 55 epochs. On STL-10, we train for 300 epochs when using the full training set, and 500 epochs when using the 10-fold training splits.</p><p>For ModelNet-10 tests, we employ 3x3x3 filters (rather than fully variable filter size) to enable our network to fit into memory and keep compute costs manageable, hence why our model only has 8M parameters compared to the base 16M parameters.</p><p>All of our networks are pre-activation, following the order BN-ReLU-Conv if BatchNorm is used, or ReLU-Conv if WeightNorm is used. Our code supports both pre-and post-activation, along with a variety of other options such as which hyperparameters to vary and which to keep constant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix D: Future Directions</head><p>We believe that this work opens up a number of future research paths. The SMASH method itself has several simplistic elements that might easily be improved upon. During training, we sample each element of the configuration one-by-one, independently, and uniformly among all possible choices. A more intelligent method might employ Bayesian Optimization <ref type="bibr" target="#b33">[34]</ref> or HyperBand <ref type="bibr" target="#b20">[21]</ref> to guide the sampling with a principled tradeoff between exploring less-frequently sampled architectures against those which are performing well. One might employ a second parallel worker constantly evaluating validation performance throughout training to provide signal to an external optimizer, and change the optimization objective to simultaneously maximize performance while minimizing computational costs. One could also combine this technique with RL methods <ref type="bibr" target="#b43">[44]</ref> and use a policy gradient to guide the sampling. Another simple technique (which our code nominally supports) is using the HyperNet-generated weights to initialize the resulting network and accelerate training, similar to Net2Net <ref type="bibr" target="#b5">[6]</ref>.</p><p>Our architecture exploration is fairly limited, and for the most part involves variable layer sizes and skip connections. One could envision a multiscale SMASH that also explores low-level design, varying things such as the activation at each layer, the order of operations, the number of convolutions in a given layer, or whether to use convolution, pooling, or more exotic blocks. Alternatively, one could consider varying which elements of the network are generated by the HyperNet, which are fixed learned parameters, and one might even make use of fixed unlearned parameters such as Gabor Filters.</p><p>Our memory-bank view also opens up new possibilities for network design. Each layer's read and write operations could be designed to use a learned softmax attention mechanism, such that the read and write locations are determined dynamically at inference time. We also do not make use of memory in the traditional "memory-augmented" sense, but we could easily add in this capacity by allowing information in the memory banks to persist, rather than zeroing them at every training step. We also only explore one definition of reading and writing, and one might for example change the "write" operation to either add to, overwrite, or perhaps even multiply (a la gated networks <ref type="bibr" target="#b35">[36]</ref>) the existing tensor in a given bank. ks: [ <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5]</ref>, <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b6">7]</ref>, <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b2">3]</ref>, X] d: [ <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b1">2]</ref>, <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b0">1]</ref>, <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b0">1]</ref>, X]</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix E: Visualizations of Discovered Architectures</head></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Normalization propagation: A parametric technique for removing internal covariate shift in deep networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Arpit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">U</forename><surname>Kota</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Govindaraju</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Layer normalization</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Ba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Kiros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Designing neural network architectures using reinforcement learning</title>
		<author>
			<persName><forename type="first">B</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Naik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Raskar</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Random search for hyperparameter optimization</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<idno>JMLR 2012</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Generative and discriminative voxel modeling with convolutional neural networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Brock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Ritchie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Weston</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1608.04236</idno>
	</analytic>
	<monogr>
		<title level="m">3D Deep Learning Workshop at NIPS</title>
				<imprint>
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Net2net: Accelerating learning via knowledge transfer</title>
		<author>
			<persName><forename type="first">T</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shiens</surname></persName>
		</author>
		<idno>ICLR 2016</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">A downsampled variant of imagennet as an altetrnative to the cifar datasets</title>
		<author>
			<persName><forename type="first">P</forename><surname>Chrabaszcz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Loshchilov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Hutter</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1707.08819</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv Preprint</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">n analysis of single layer networks in unsupervised feature learning</title>
		<author>
			<persName><forename type="first">A</forename><surname>Coates</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Ng</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Predicting parameters in deep learning</title>
		<author>
			<persName><forename type="first">M</forename><surname>Denil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Shakibi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Dinh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Ranzato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>De Freitas</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Neuroevolution: from architectures to learning</title>
		<author>
			<persName><forename type="first">D</forename><surname>Floreano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Durr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Mattiussi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Evolutionary Intelligence</title>
				<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Shake-shake regularization of 3-branch residual networks</title>
		<author>
			<persName><forename type="first">X</forename><surname>Gastaldi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017 Workshop, 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">D</forename><surname>Ha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><surname>Hypernetworks</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Deep residual learning for image recognition</title>
		<author>
			<persName><forename type="first">K</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Deep networks with stochastic depth</title>
		<author>
			<persName><forename type="first">G</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sedra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">Q</forename><surname>Weinberger</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Densely connected convolutional networks</title>
		<author>
			<persName><forename type="first">G</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">Q</forename><surname>Weinberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Van Der Maaten</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Batch normalization: Accelerating deep network training by reducing internal covariate shift</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ioffe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Szegedy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Dynamic filter networks</title>
		<author>
			<persName><forename type="first">X</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>De Brabandere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Tuytelaars</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">V</forename><surname>Gool</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Kingma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ba</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1412.6980</idno>
		<title level="m">Adam: A method for stochastic optimization</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv Preprint</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Learning multiple layers of features from tiny images</title>
		<author>
			<persName><forename type="first">A</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hinton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Fractalnet: Ultra-deep neural networks without residuals</title>
		<author>
			<persName><forename type="first">G</forename><surname>Larsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Maire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Shakhnarovich</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Hyperband: Bandit-based configuration evaluation for hyperparameter optimization</title>
		<author>
			<persName><forename type="first">L</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Jamieson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Desalvo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rostamizadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Talwalkar</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Sgdr: Stochastic gradient descent with warm restarts</title>
		<author>
			<persName><forename type="first">I</forename><surname>Loshchilov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Hutter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Cartesian genetic programming</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Thomson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">A</forename><surname>Paszke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chintala</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note>Pytorch. github.com/pytorch/pytorch</note>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Unsupervised representation learning with deep convolutional generative adversarial networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Radford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Metz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chintala</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1511.06434</idno>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Large-scale evolution of image classifiers</title>
		<author>
			<persName><forename type="first">E</forename><surname>Real</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Selle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Saxena</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">L</forename><surname>Suematsu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kurakin</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1703.01041</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv Preprint</note>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Learning multiple visual domains with residual adapters</title>
		<author>
			<persName><forename type="first">S.-A</forename><surname>Rebuffi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Bilen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vedaldi</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1705.08045</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv Preprint</note>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Weight normalization: A simple reparameterization to accelerate training of deep neural networks</title>
		<author>
			<persName><forename type="first">T</forename><surname>Salimans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Kingma</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">On random weights and unsupervised feature learning</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Saxe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">W</forename><surname>Koh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bhand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Suresh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Ng</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Convolutional neural fabrics</title>
		<author>
			<persName><forename type="first">S</forename><surname>Saxena</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Verbeek</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Learning to control fast-weight memories: An alternative to dynamic recurrent networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Schmidhuber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Neural Computation</title>
				<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="131" to="139" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Swapout: Learning an ensemble of deep architectures</title>
		<author>
			<persName><forename type="first">S</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hoiem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Forsyth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Practical bayesian optimization of machine learning algorithms</title>
		<author>
			<persName><forename type="first">J</forename><surname>Snoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Larochelle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Adams</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Practical bayesian optimization of machine learning algorithms</title>
		<author>
			<persName><forename type="first">J</forename><surname>Snoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Rippel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Swersky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kiros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Satish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sundaram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M A</forename><surname>Patwary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Prabhat</surname></persName>
		</author>
		<author>
			<persName><surname>Adams</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Improving neural networks by preventing co-adaptation of feature detectors</title>
		<author>
			<persName><forename type="first">N</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Salakhutdinov</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1207.0580</idno>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv Preprint</note>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Training very deep networks</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Greff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schmidhuber</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A hypercube-based encoding for evolving large-scale neural networks</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">O</forename><surname>Stanley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>. D'ambrosio</surname></persName>
		</author>
		<author>
			<persName><surname>Gauci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Artificial Life</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="185" to="212" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">A genetic programming approach to designing convolutional neural network architectures</title>
		<author>
			<persName><forename type="first">M</forename><surname>Suganuma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shirakawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nagao</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Inception-v4, inception-resnet and the impact of residual connections on learning</title>
		<author>
			<persName><forename type="first">C</forename><surname>Szegedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ioffe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vanhoucke</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1602.07261</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv Preprint</note>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Modeling systems with internal state using evolino</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wierstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Gomez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schmidhuber</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">3d shapenets: A deep representation for volumetric shapes</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Khosla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Xiao</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Yosinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Clune</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lipson</surname></persName>
		</author>
		<title level="m">How transferable are features in deep neural networks? In NIPS</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Zagoruyko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Komodakis</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1605.07146</idno>
		<title level="m">Wide residual networks</title>
				<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv Preprint</note>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">Neural architecture search with reinforcement learning</title>
		<author>
			<persName><forename type="first">B</forename><surname>Zoph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Le</surname></persName>
		</author>
		<idno>ICLR 2017. N: 16</idno>
		<imprint>
			<pubPlace>2, 1, X, X] ks</pubPlace>
		</imprint>
	</monogr>
	<note>1, 1, 0, 0. 5, 5], [3, 5], X, X] d: [[1, 1], [3, 1], X, X</note>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">X</forename></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename></persName>
		</author>
		<author>
			<persName><forename type="first">X] N</forename></persName>
		</author>
		<imprint>
			<biblScope unit="page">64</biblScope>
			<pubPlace>1, X, X, X] ks; X, X, X] d</pubPlace>
		</imprint>
	</monogr>
	<note>1, 0, 0, 0. 5, 3. 2, 1],. 1, 1, 1, 1], groups: [1, 1, 4, 2] ks: [[5, 5], [5, 3], [5, 3], [7, 5]] d: [[2, 1], [1, 1], [2, 1], [1, 1]</note>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">X</forename></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>] D</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">40</biblScope>
			<pubPlace>2, X, X, X] ks</pubPlace>
		</imprint>
	</monogr>
	<note>1, 0, 0, 0], groups. 7, 5],. 1, 2], X, X, X] output N: 24, op: [1, 1, 1, 0], groups: [2, 2, 4, X] ks: [[5, 5], [5, 3], [5, 5], X] d: [[1, 1], [1, 2], [1, 2], X</note>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">X</forename></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>] D</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">56</biblScope>
			<pubPlace>2, X, X, X] ks; 1, 1], X, X, X] N: 56, op; 1, X, 1, X] ks</pubPlace>
		</imprint>
	</monogr>
	<note>1, 0, 0, 0], groups. 7, 7],. 1, 0, 1, 0], groups. 7, 7], X, [5, 7], X] d: [[1, 1], X, [2, 1], X</note>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">X</forename></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>] D ; ]</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename></persName>
		</author>
		<author>
			<persName><forename type="first">X] N</forename></persName>
		</author>
		<imprint>
			<biblScope unit="page">64</biblScope>
			<pubPlace>1, X, X, X] ks</pubPlace>
		</imprint>
	</monogr>
	<note>1, 0, 0, 0. 7, 7],. 1, 1. 1, 1, 1, 1], groups: [1, 2, 4, 2] ks: [[5, 5], [7, 5], [7, 7], [7, 3]] d: [[1, 2], [1, 1], [1, 1], [1, 3</note>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">N represents number of output units, and d represents the dilation factor for the 3x3 filter</title>
	</analytic>
	<monogr>
		<title level="m">A simplified version of our best-found SMASHv1 architecture</title>
				<imprint/>
	</monogr>
	<note>trans1 N: 40, op: [1, 1, 1, 0], groups: [4, 2, 2, X] ks: [[3, 5], [5, 7], [3, 3], X] d: [[2, 2], [1, 1], [3, 1], X</note>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">]</forename></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename></persName>
		</author>
		<author>
			<persName><forename type="first">X] N</forename></persName>
		</author>
		<imprint>
			<biblScope unit="page">48</biblScope>
			<pubPlace>2, X, X, X] ks; X, X, X] d</pubPlace>
		</imprint>
	</monogr>
	<note>1, 0, 0, 0], groups. 3, 7. 1, 1. 1, 1, 1, 0], groups: [4, 2, 1, X] ks: [[3, 5], [7, 5], [7, 5], X] d: [[3, 2], [1, 2], [1, 2], X</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
