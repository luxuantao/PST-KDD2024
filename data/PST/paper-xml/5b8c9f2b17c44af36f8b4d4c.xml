<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Distributed Representations of Tuples for Entity Resolution</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Muhammad</forename><surname>Ebraheem</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Saravanan</forename><surname>Thirumuruganathan</surname></persName>
							<email>sthirumuruganathan@hbku.edu.qa</email>
						</author>
						<author>
							<persName><forename type="first">Shafiq</forename><surname>Joty</surname></persName>
							<email>srjoty@ntu.edu.sg</email>
							<affiliation key="aff1">
								<orgName type="institution">Nanyang Technological University</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mourad</forename><surname>Ouzzani</surname></persName>
							<email>mouzzani@hbku.edu.qa</email>
						</author>
						<author>
							<persName><forename type="first">Nan</forename><surname>Tang</surname></persName>
							<email>ntang@hbku.edu.qa</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Qatar Computing Research Institute</orgName>
								<orgName type="institution" key="instit2">HBKU</orgName>
								<address>
									<country key="QA">Qatar</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">The 44th International Conference on Very Large Data Bases</orgName>
								<address>
									<postCode>2018</postCode>
									<settlement>August, Rio de Janeiro</settlement>
									<country key="BR">Brazil</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Distributed Representations of Tuples for Entity Resolution</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">3DE1C790DDDABFEF43B350E47DF1912D</idno>
					<idno type="DOI">10.14778/3236187.3236198</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:14+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Despite the efforts in 70+ years in all aspects of entity resolution (ER), there is still a high demand for democratizing ER -by reducing the heavy human involvement in labeling data, performing feature engineering, tuning parameters, and defining blocking functions. With the recent advances in deep learning, in particular distributed representations of words (a.k.a. word embeddings), we present a novel ER system, called DeepER, that achieves good accuracy, high efficiency, as well as ease-of-use (i.e., much less human efforts). We use sophisticated composition methods, namely uni-and bi-directional recurrent neural networks (RNNs) with long short term memory (LSTM) hidden units, to convert each tuple to a distributed representation (i.e., a vector), which can in turn be used to effectively capture similarities between tuples. We consider both the case where pre-trained word embeddings are available as well the case where they are not; we present ways to learn and tune the distributed representations that are customized for a specific ER task under different scenarios. We propose a locality sensitive hashing (LSH) based blocking approach that takes all attributes of a tuple into consideration and produces much smaller blocks, compared with traditional methods that consider only a few attributes. We evaluate our algorithms on multiple datasets (including benchmarks, biomedical data, as well as multi-lingual data) and the extensive experimental results show that DeepER outperforms existing solutions.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Entity resolution (ER) (a.k.a. record linkage), a fundamental problem in data integration, has been extensively studied for 70+ years <ref type="bibr" target="#b20">[20]</ref>, from different aspects such as declarative rules <ref type="bibr">[8,</ref><ref type="bibr" target="#b46">46,</ref><ref type="bibr" target="#b50">50]</ref>, machine learning (or probabilistic) <ref type="bibr" target="#b23">[23,</ref><ref type="bibr">8,</ref><ref type="bibr" target="#b44">44,</ref><ref type="bibr" target="#b13">13]</ref>, and crowdsourcing <ref type="bibr" target="#b49">[49,</ref><ref type="bibr" target="#b26">26]</ref>, to name a few, and in many domains such as health care <ref type="bibr" target="#b20">[20]</ref>, ecommerce <ref type="bibr" target="#b26">[26]</ref>, data warehouses <ref type="bibr" target="#b53">[53]</ref>, and many more.</p><p>Despite the great efforts in all aspects of ER, there is still a long journey ahead in democratizing ER. Adding to the difficulty is the rapidly increasing size, number, and variety of sources of big data. Consider Figure <ref type="figure" target="#fig_0">1</ref> for a typical ER pipeline that consists of four main steps: (1) labeling entity pairs as either matching or non-matching pairs; (2) learning rules/ML models using the labeled data<ref type="foot" target="#foot_0">1</ref> ; (3) blocking for reducing the number of comparisons; and (4) applying the learned rules/ML models.</p><p>Step <ref type="bibr" target="#b1">(1)</ref> decides what are the matched entities. Step (2) reasons about why they match. Step (3) reduces the number of pairwise comparisons for step (4) (i.e., how), usually by expert specified blocking functions, which generate blocks such that matched entities co-exist in the same block.</p><p>Challenges. The major challenge of current solutions in democratizing ER is that each step needs human-in-the-loop. Even a "simple" step, such as step <ref type="bibr" target="#b1">(1)</ref>, which is thought to be trivial, turned out to be difficult in practice <ref type="bibr" target="#b19">[19]</ref>. Moreover, the human resources required in each step might be different -knowing what (i.e., step <ref type="bibr" target="#b1">(1)</ref>) is easier than telling why (i.e., step (2)) or how (i.e., step (3)). Wouldn't it be great if we significantly reduce human cost for each step, but with a comparable if not better accuracy?</p><p>Observations. (i) In practice, step (1) is tedious because humans can only label up to several hundred (or few thousands) entity pairs and are error-prone. Intuitively, the hope to reduce this effort is to have a "prior knowledge" about what values would most likely match. (ii) Regardless of using rule-based <ref type="bibr" target="#b46">[46,</ref><ref type="bibr" target="#b50">50]</ref> or ML-based <ref type="bibr" target="#b23">[23,</ref><ref type="bibr">8]</ref> methods, step (2) requires experts to provide (domain-specific) similarity functions from a large pool, for example, SimMetrics (https://github.com/Simmetrics/simmetrics) has 29 symbolic similarity functions. In addition, experts may also need to specify the thresholds. Ideally, this step needs a unified metric that can decide different cases of matched entities, from both syntactic and semantic perspectives. (iii) For step <ref type="bibr" target="#b3">(3)</ref>, a blocking function is typically defined over few attributes, e.g., country and gender in a table about demographic information, without a holistic view over all attributes or the semantics of the entities.</p><p>Our Methodology. We present DeepER, a system for democratizing ER that needs much less labeled data by considering prior knowledge of matched values (observation (i)), captures both syntactic and semantic similarities without feature engineering and parameter tuning (observation (ii)), and provides an automated and customizable blocking method that takes a holistic view of all attributes (observation (iii)) -all of these targets are achieved by gracefully using distributed representations, or DRs for short, (of tuples), a fundamental concept in deep learning (DL).</p><p>DRs of tuples is an extension of DRs of words (a.k.a. word embeddings) where a word is mapped to a high dimensional dense vector such that the vectors for similar words are close to each other in their semantic space. Well known methods include word2vec <ref type="bibr" target="#b40">[40]</ref> and GloVe <ref type="bibr" target="#b43">[43]</ref>. Word embeddings have become conventional wisdom in other fields such as NLP and have many appealing properties: (a) They are known to well capture semantic string similarities, e.g., "William" and "Bill", and "Apple Phone" and "iPhone". (b) Using pre-trained word embeddings (e.g., GloVe is trained on a corpus with 840 billion tokens), we can tremendously reduce the human effort of labeling matched values per dataset. (c) Due to their generality, it is possible that the same intermediate representation (such as from word2vec, GloVe, or fastText) can work for multiple datasets outof-the-box. In contrast, traditional ER approaches require hand tuning for each dataset. (d) DR toolkits such as fast-Text <ref type="bibr" target="#b9">[9]</ref> provide support for almost 294 languages allowing them, and thereby DeepER, to work seamlessly on different languages. (e) They provide a new opportunity of blocking over the vectors representing the tuples.</p><p>Contributions. In this paper, we present DeepER, a novel ER system powered by DRs of tuples, which is accurate, efficient, and easy-to-use.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">[Distributed representations of tuples for ER.]</head><p>We present two methods for effectively computing DRs of tuples by composing the DRs of all the tokens within all attribute values of a tuple. The first method is a simple averaging of the tokens' DRs while the second uses uni-and bi-directional recurrent neural networks (RNNs) with long short term memory (LSTM) hidden units to convert each tuple to a DR (i.e., a vector).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">[Learning/tuning distributed representations.]</head><p>We introduce an end-to-end approach to tune the DRs that is customized for a specific ER task which improves the performance of DeepER (Section 3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">[Blocking for distributed representations.]</head><p>We propose two efficient and effective blocking algorithms based on the DRs for tuples and locality sensitive hashing, which takes the semantic relatedness of all attributes into account (Section 4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">[Experiments.]</head><p>We conducted extensive experiments (Section 5). DeepER shows superior performance compared to a state-of-the-art ER solution as well to published meth-ods on several benchmark datasets from citations, products, and proteomics. Finally, the proposed blocking delivers outstanding results under different conditions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">DISTRIBUTED REPRESENTATIONS OF TUPLES FOR ENTITY RESOLUTION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Entity Resolution</head><p>Let T be a set of entities with n tuples and m attributes {A1, . . . , Am}. Note that these entities can come from one table or multiple tables (with aligned attributes). We denote by t[Ai] the value of attribute Ai on tuple t. The problem of entity resolution (ER) is, given all distinct tuple pairs (t, t ) from T where t = t , to determine which pairs of tuples refer to the same real-world entities (a.k.a. a match).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Distributed Representations of Words</head><p>We briefly describe the concept of distributed representations (DRs) of words (please refer to <ref type="bibr" target="#b27">[27]</ref> for more details). DRs of words (a.k.a.word embeddings) are learned from the data in such a way that semantically related words are often close to each other; i.e., the geometric relationship between words often also encode a semantic relationship between them. This embedding method seeks to map each word in a given vocabulary into a high dimensional vector with a fixed dimension d (e.g., d = 300 for GloVe). In other words, each word is represented as a distribution of weights (positive or negative) across these dimensions. Figure <ref type="figure">2</ref> shows some sample word embeddings.</p><p>Often, many of these dimensions can be independently varied. The representation is considered "distributed" since each word is represented by setting appropriate weights over multiple dimensions while each dimension of the vector contributes to the representation of many words. DRs can express an exponential number of "concepts" due to the ability to compose the activation of many dimensions <ref type="bibr" target="#b27">[27]</ref>. In contrast, the symbolic (a.k.a. discrete) representation often leads to data sparsity and requires substantially more data to train ML models successfully <ref type="bibr" target="#b6">[6]</ref>. Word embeddings have been successfully used to solve various tasks such as topic detection, document classification, and named entity recognition.</p><p>A number of methods have been proposed to compute the DRs of words including word2vec <ref type="bibr" target="#b40">[40]</ref>, GloVe <ref type="bibr" target="#b43">[43]</ref>, and fast-Text <ref type="bibr" target="#b9">[9]</ref>. Generally speaking, these approaches attempt to capture the semantics of a word by considering its relations with neighboring words in its context. In this paper, we use GloVe, which is based on a key observation that the ratios of co-occurrence probabilities for a pair of words have some potential to encode a notion of its meaning. GloVe formalizes this observation as a log-bilinear model with a weighted least-squares objective function. This objective function has a number of appealing properties such as the vector difference between the representations for (man, woman) and (king, queen) are roughly equal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Distributed Representations of Tuples</head><p>Similar to word embeddings, given a tuple, we need to convert it to a vector representation, such that we can measure the similarity between two tuples by computing the distance between their corresponding vectors.</p><p>Consider a tuple t with m attributes {A1, . . . , Am}. Let v(t[A k ]) be the vector representation of value t[A k ], and v(t) </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>d-dimension</head><p>Figure <ref type="figure">2</ref>: Sample Word Embeddings be the vector representation of tuple t. Also, we write v(x) the vector representation of a word x. We also write |v| as the number of dimensions of vector v.</p><p>Running Example. We use the following example to illustrate our approaches. Below, we describe two approaches for computing v(t): a simple approach and a compositional approach. We then explain how we compute the similarity between two vectors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Simple Approach -Averaging</head><p>For each attribute value t[A k ], we first break it into individual words using a standard tokenizer. For each token (word) x, we look up the GloVe pre-trained dictionary and retrieve the d-dimensional vector v(x). If a word is not found in the GloVe dictionary (dubbed out-of-vocabulary scenario) or if the attribute has a NULL value, GloVe contains a special token Unk to represent such out-of-vocabulary word (we postpone the discussion of a better handling of out-ofvocabulary values to Section 3). Tokens such as IDs and some numeric values are often assigned Unk.</p><p>In our initial approach, the vector representation for an attribute value v(t   </p><formula xml:id="formula_0">vectors of its tokens x in t[A k ]. The vector representation v(t) of tuple t is the concatenation of all vectors v(t[A k ]) (k ∈ [1, m]). That is, if each attribute value corresponds to a d-dimensional vector, |v(t)| = d × m. Algorithm 1 describes this process.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Compositional Approach -RNN with LSTM</head><p>We can see that the averaging based approach ignores the word order. However, it has the appealing property of being simple and very efficient to train. An alternative approach for computing v(t) is to use a compositional technique motivated by the linguistic structures (e.g., n-grams, sequence, and tree) in Natural Language Processing (NLP). In this approach, instead of simple averaging, we use a neural network to semantically compose the word vectors (retrieved from GloVe) into an attribute-level vector. Considering the word order (and linguistic structure in general) could be important as many attributes contain multi-word content such as title in the citation dataset and description in the product dataset. As we shall show in our experiments, there are certain challenging datasets where being cognizant of word order improves performance. Furthermore, a tuple binds the attributes of a single entity, thus the attributes are related. Thus, an appropriate compositional approach should consider the relation between them rather than treating them separately. Different neural network architectures have been proposed to consider different types of linguistic structures, the most popular of which use a recurrent structure <ref type="bibr" target="#b36">[36]</ref>.</p><p>We use uni-and bi-directional recurrent neural networks (RNN) with long short term memory (LSTM) hidden units <ref type="bibr" target="#b28">[28]</ref>, a.k.a. LSTM-RNNs. As shown in Figure <ref type="figure" target="#fig_1">3</ref>, RNNs encode a sequence of words for all attribute values (i.e., words of a tuple) into a composed vector by processing its word vectors sequentially (i.e., the word embedding lookup layer), at each time step, combining the current input word vector with the previous hidden state (i.e., the RNN composition layer). The outputted composed vector of v[t] has x dimensions, where x is determined by LSTM and may be different than d. RNNs thus create internal states by remembering the output of the previous time step, which allows them to exhibit dynamic temporal behavior. We can interpret the hidden state hi at time i as an intermediate representation summarizing the past. The output of the last time step h k thus represents the tuple. LSTM cells contain specifically designed gates to store, modify or erase information, which allow RNNs to learn long range sequential dependencies. The LSTM-RNN shown in Figure <ref type="figure" target="#fig_1">3</ref> is unidirectional in the sense that it encodes information from left to right.</p><p>Bidirectional RNNs <ref type="bibr" target="#b45">[45]</ref>  Algorithm 2 gives the overall compositional process. For each word token in an attribute, we first look up its GloVe vector. Then we use a "shared" 2 LSTM-RNN to compose each attribute value in a tuple into a vector. This results in a vector v(t) of d dimensions. It is important to note that the parameters of the LSTM-RNN model need to be learned on the ER task in a DL framework before it can be used to compose vectors for other off-the-shelf classifiers.</p><p>The order of attributes might not have a big effect when the number of attributes is small (such as 4 for the citations benchmark datasets). However, it might become significant when the number of attributes is large. In this case, a simple heuristic would be to ensure that semantically related attributes are close to each other. This is performed by profiling the data to find possible data dependencies. For example, if one identified that two attributes Ai and Aj are closely related (e.g. Country often determines Capital), then these can be ordered so that they are closer to each other.</p><p>Example 2: Assume that we used a LSTM with output dimension of 2. In other words, it processes the entire tuple and produces a DR of dimension 2. Assume that v(t1) = [0.45, 0.23] and v(t2) = [0.42, 0.28].</p><p>2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Computing Distributional Similarity</head><p>Given the DR of a pair of tuples t and t , the next step is to compute the similarity between their DRs v(t) and v(t ). Note that for the DRs computed by averaging, each vector has d × m dimensions. We apply the cosine similarity on every d dimensions (each d dimension corresponds to one attribute), which results in a m-dimensional similarity vector. For the DRs computed by LSTM, each vector has x dimensions, we can use methods including subtracting (vector difference) or multiplying (hadamard product) the corresponding vector entries, resulting in a x-dimensional similarity vector.</p><p>Example 3: Continuing our running example, the similarity vector for tuples t1 and t2 for averaging is [0.99, 1.0]. The  <ref type="bibr" target="#b23">[23,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b42">42,</ref><ref type="bibr">8]</ref>. Given a pair of tuples (t, t ), the classifier outputs true (resp. false) to indicate that t and t match (resp. mismatch). The Fellegi-Sunter model <ref type="bibr" target="#b23">[23]</ref> is a formal framework for probabilistic ER and most prior machine learning (ML) works are simple variants of this approach.</p><p>Intuitively, given two tuples t and t , we compute a set of similarity scores between aligned attributes based on predefined similarity functions. The vectors of known matching (resp. non-matching) tuple pairs -that are also referred to as positive (resp. negative) examples -are used to train a binary classifier (e.g., SVMs, decision trees, or random forests). The trained binary classifier can then be used to predict whether an arbitrary tuple pair is a match.</p><p>It is fairly straightforward to build a classifier for ER using the above steps. For each pair of tuples in the training dataset, we compute their DRs through either Algorithm 1 or Algorithm 2. We then compute the similarity between tuple pairs using different metrics. Given a set of positive and negative matching examples, we pass their similarity vectors to a classifier such as SVM along with their labels. Algorithm 3 provides the pseudocode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">LEARNING AND TUNING DISTRIBUTED REPRESENTATIONS</head><p>Composing DRs of words to generate DRs of tuples, as discussed in Section 2, works effectively for an ER task based on two assumptions: (i) there exist pre-trained word embeddings for most (if not all) words in the dataset; and (ii) the pre-trained word embeddings that were trained in a task agnostic manner are sufficient for the ER task. However, the above two assumptions may not hold for many real-world scenarios. The datasets that follow the above assumptions are considered as general data with full coverage (Section 3.1); the datasets that are not well covered, are considered as general data with partial coverage (Section 3.2); and the datasets that are minimally covered, are considered as specific data with minimal coverage (Section 3.3). Finally, we discuss how to tune word embeddings for an ER task (Section 3.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">General Data with Full Coverage</head><p>Many of the benchmark datasets used in ER <ref type="bibr" target="#b18">[18]</ref> such as Citations, Products, Restaurants, and Movies, are often generic and do not require substantial specialized knowledge. While they may be noisy and incomplete, the content is often in English and use common words. For such generic datasets, the approach that we have proposed so far -convert pairs of tuples to similarity vectors using GloVe -is often adequate. As we shall show in the experiments, we obtain competitive results for all of them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">General Data with Partial Coverage</head><p>Another case is where a significant number of words that are relevant for an ER task in a dataset are not present in the word embedding dictionary. It is well known that natural languages exhibit a Zipfian distribution with a heavy tail of infrequently used words. For computational efficiency, these "rare" words are often pruned. For example, even though GloVe was trained on a very large document corpus with 840 billion tokens and a vocabulary size of 2.2 million, it can miss many words such as from technical domains, names of people, or institutions, which would be useful for performing ER on a Citation dataset. Our approach from Section 2 replaces any word not present in the dictionary with a unique token UNK (Unknown). However, it is possible that these words are especially relevant for identifying duplicate tuples.</p><p>Vocabulary Expansion is the process of expanding the embedding dictionary to words that were not observed during training. The naive approach of adding new documents to the original corpus and re-run the whole algorithm is not always possible or feasible. For example, the popular GloVe dictionary is trained on the Common Crawl corpus, which is almost 2 TB requiring exorbitant computing resources. Given an unseen word, another simplistic approach is to take the top-K words that co-occur the most with the unseen word in the ER dataset and simply average them. Another popular approach is to use character level embeddings such as fastText instead of word level embeddings or use subword information <ref type="bibr" target="#b9">[9]</ref>. These approaches can recognize that the rare word "dendritic" is similar to "dendrites" even if it is not explicitly present in the dictionary. While these approaches are simple and often effective, in this paper, we advocate an alternative approach inspired from <ref type="bibr" target="#b22">[22]</ref>, as described below.</p><p>Vocabulary Retrofitting. Intuitively, this approach seeks to adapt word embeddings such as GloVe by using auxiliary semantic resources such as WordNet. If there are two words that are related in WordNet, <ref type="bibr" target="#b22">[22]</ref> seeks to refine their word embeddings to be similar. This approach is especially relevant to our scenario where our input is a tuple with explicit attribute structure and has relational interpretations.</p><p>Let W = {w1, w2, . . .} be the set of words from the ER dataset. Let U ⊆ W be the set of words with no word embeddings. We begin by creating an undirected graph with one vertex for each word in W . Two vertices (vi, vj) are connected if they co-occur in some tuple. One can also define other additional edge semantics such as an edge connecting two vertices if they occur in the same attribute and so on. For vertex v ∈ W \ U , we assign its word embedding from the dictionary. For vertex v ∈ U , we assign its initial value as the average of K of its most frequent co-occurring words. We then create a set of new vertices W for each word w ∈ W and connect it to its corresponding vertex from W . These vertices correspond to the retrofitted word embeddings that will be learned through probabilistic inference. We set the objective function such that we learn the word embeddings for each vertex w ∈ W such that they are both closer to its counterpart in W and also closer to its other neighboring vertices. Figure <ref type="figure" target="#fig_3">4</ref> shows an example. This approach has a number of appealing properties. First, this is an efficient mechanism to learn the word embeddings of unknown words such as IDs. Second, it provides an elegant mechanism to "tune" the word embeddings that is in sync with the ER dataset. For example, if two words do not co-occur a lot in Common Crawl (such as SIGMOD and Stonebraker) but does in our dataset, this approach tunes the embeddings appropriately. Finally, it allows one to encode a diverse array of options to define relatedness (such as present in the same attribute or tuple) that is more generic than the simple co-occurrence idea used by GloVe.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Specific Data with Minimal Coverage</head><p>Another common scenario occurs when one performs ER on datasets with specialized information. Examples include performing ER on scientific articles for specialized fields or in data that is specific to an organization. In this case, the attributes often contain esoteric words that are not present in GloVe dictionary. What is worse, it might not know that two terms such as p53 and cancer are related. If most of the words are not present in the dictionary, then approaches such as retrofitting might be applicable. This problem could be exacerbated if the ER dataset belongs to complex domains such as Genomics. Finding if two tuples describe the same protein might not be possible with GloVe or word2vec.</p><p>We use one of the following approaches to handle such scenarios:</p><p>(1) Unsupervised Representation from Datasets. If the two datasets that are to be merged are large enough (typically in the order of millions of tuples), they might contain enough patterns to automatically learn word embeddings from them. One could pool all the tuples from both datasets and train GloVe/word2vec on them by treating each tuple as a document.</p><p>(2) Unsupervised Learning from related Corpus.</p><p>If the datasets are not large enough, then one can find another surrogate resource to learn word embeddings. GloVe and word2vec learned the word embeddings by training on a large corpus such as Common Crawl and Google News respectively. If one can find an analogous vast corpus of domain information in the form of unstructured data such as documents, it could be used to learn the word embeddings for this specialized dataset. For example, while word embeddings from GloVe might not know that p53 and cancer are related, the word embeddings trained from PubMed articles would be able to. Similarly, one could learn word embeddings from the enterprise's document repository for ER on data in the same organization.</p><p>(3) Customized Word Embeddings. In some cases, it is possible that direct application of GloVe or word2vec does not solve the problem. For example, when given a huge amount of training they might not find if, for example, two strings encode the same protein. In such cases, one has to check if there exist prior methods for learning word embeddings for the task of interest. For example, there exist prior work on word embeddings for proteins and genes from sequences of amino acids and DNA respectively <ref type="bibr" target="#b3">[3]</ref>.</p><p>Of course, the worst case scenario is a specialized database where no auxiliary resources are available to automatically learn the representation for key concepts. In this scenario, any machine learning approach is doomed to fail unless one provides hand crafted features or a substantially large number of training examples that are sufficient for learning representations using deep learning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Tuning Word Embeddings for an ER Task</head><p>Recall that word embeddings such as GloVe/word2vec are learned in an unsupervised task-agnostic manner so that they can be used for arbitrary tasks. If the corpus used to train them is large and representative enough, the learned word embeddings can be used in a turn-key manner for ER tasks. While unsupervised pre-training on a large corpus does give the DL model better generalization, in many cases the learned representations often lack task-specific knowledge. One can achieve the best of both worlds by fine-tuning the pre-trained word representations to achieve better accuracy. In fact, this paradigm of unsupervised pre-training followed by supervised fine-tuning often beats methods that are based on only supervision <ref type="bibr" target="#b15">[15]</ref>.</p><p>Our proposed approach can be easily extended for this purpose. Let us now consider our deep neural network in Figure <ref type="figure" target="#fig_4">5</ref>. We train this network using Stochastic Gradient Descent (SGD) based learning algorithms, where gradients (errors) are obtained via backpropagation. In other words, errors in the output layer (i.e., the classification layer) are backpropagated through the hidden layers using the chain rule of derivatives. The parameters of the hidden layers are slightly altered such that when the model accuracy improves. For learning or fine-tuning the embeddings, we allow these errors to be backpropagated all the way till the word embedding layer. In contrast, our approach from Section 2 can only tune parameters up to the composition layer. Allowing error to be back propagated to the embedding layer allows one additional level of freedom to tinker model parameters. Instead of limiting ourselves to how the attributes are composed or how similarity is computed, we can also modify the word embeddings themselves (if necessary).</p><p>One common issue with backpropagation through a deep neural network (i.e., neural networks with many hidden layers such as RNNs) is that as the errors get propagated, they may soon become very small (a.k.a. gradient vanishing problem) or very large (a.k.a. gradient exploding problem) that can lead to undesired values in weight matrices, causing the training to fail <ref type="bibr" target="#b7">[7]</ref>. We did not observe such problems in our end-to-end training with simple averaging compositional method, and the gates in LSTM cells automatically tackle these issues to some extent <ref type="bibr" target="#b28">[28]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">BLOCKING FOR DISTRIBUTED REP-RESENTATIONS</head><p>Efficient ER systems avoid comparing all possible pairs of tuples ( n 2 for one table of n×m for two tables) through the use of blocking <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b12">12]</ref>. Blocking identifies groups of tuples (called blocks) such that the search for duplicates need to be done only within these blocks, thus greatly reducing the search space. While blocking often substantially reduces the number of comparisons, it may also miss some duplicates that fall in two different blocks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">New Opportunities for Blocking</head><p>We observe that blocking is very related to the classical problem of approximate nearest neighbor (ANN) search in a similarity space, which has been extensively studied (see <ref type="bibr" target="#b51">[51]</ref>). Locality sensitive hashing (LSH) <ref type="bibr" target="#b29">[29]</ref> is a popular probabilistic technique for finding ANNs in a high dimensional space. In the blocking context, the more similar input vectors are, the higher the probability that they both will be put in the same block. While we are not the first to propose LSH for blocking or automated tuning for blocking (see Section 6), we are the first to propose a series of truly turn-key algorithms for blocking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Challenges in Traditional Blocking Approaches</head><p>(i) Identifying good blocking rules often requires the assistance of domain experts. (ii) Blocking rules often consider few (e.g., 2-3) attributes which could result in comparing tuples that agree on those attributes but have very different values on other attributes. (iii) Prior blocking methods often do not take semantic similarity between tuples into consideration. (iv) It is usually hard to tune the blocking strategy to control the recall and/or the size of the blocks.</p><p>We can readily see that LSH for blocking over DRs of tuples obviates many of these issues. First, we free the domain experts from providing a blocking function. Instead the combination of LSH and DRs transforms the problem of blocking into finding tuples in a high dimensional similarity space. Note that a DR encodes semantic similarity into the mix and that LSH considers the entire tuple for computing similarity. The extensive amount of theoretical work on LSH (see Section 4.5) can be used to both tune and provide rigorous theoretical guarantees on the performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">LSH Primer</head><p>Definition 1: (Locality Sensitive Hashing <ref type="bibr" target="#b25">[25,</ref><ref type="bibr" target="#b51">51]</ref>): A family H of hash functions is called (R, cR, P1, P2)-sensitive if for any two items p and q,</p><p>• if dist(p, q) ≤ R, then P rob[h(p) = h(q)] ≥ P1, and</p><formula xml:id="formula_1">• if dist(p, q) ≥ cR, then P rob[h(p) = h(q)] ≤ P2, where c &gt; 1, P1 &gt; P2, h ∈ H. 2</formula><p>The smaller the value of ρ (ρ = log(1/P 1 ) log(1/P 2 ) ), the better the search performance. For many popular distance measures such as cosine, Euclidean, and Jaccard, there exists an algorithm for the (R, c)-nearest neighbor problem that requires O(dn + n 1+ρ ) space (where d is the dimensionality of p, q), O(n ρ ) query time, and O(n ρ log 1/P 2 n) invocations of hash functions. In practice, LSH requires linear space and time <ref type="bibr" target="#b25">[25,</ref><ref type="bibr" target="#b51">51]</ref>.</p><p>Implementing LSH. Given a table T , LSH seeks to index all the tuples in a hash table that is composed of multiple buckets each of which is identified by a unique hash code. Given a tuple t, the bucket in which it is placed by a (single) hash function h is denoted as h(t) -which is often a binary value. If two tuples t and t are very similar, then h(t) = h(t ) with high probability. Typically, one uses K hash functions h1(t), h2(t), . . . , hK (t), hi ∈ H, to encode a single tuple t. We represent t as a K dimensional binary vector which in turn is represented by its hash code g(t) = (h1(t), h2(t), . . . , hK (t)). Since the usage of K hash functions reduces the likelihood that similar items will obtain the same (K dimensional) hash code, we repeat the above process L times -g1(t), g2(t), . . . , gL(t). Intuitively, we build L hash tables where each bucket in a hash table is represented by a hash code of size K. Each tuple is then hashed into L different hash tables where its hash codes are g1(t), . . . , gL(t). For example, if K = 10 and L = 2, every tuple is represented as a 10-dimensional binary vector that is stored in 2 different hash tables.</p><p>Hash Families for Cosine Distance. Cosine similarity provides an effective method for measuring semantic similarity between two DRs <ref type="bibr" target="#b43">[43]</ref>. Since the DRs can have both positive and negative real numbers, the cosine similarity varies between -1 and +1. The family of hash functions for cosine is obtained using the random hyperplane method. Intuitively, we choose a random hyperplane through the origin that is defined by a normal unit vector v. This defines a hash function with two buckets where h(t) = +1 if v • t ≥ 0 and h(t) = -1 if v • t &lt; 0 where "•" denotes the dot product between vectors. Since we require K hash functions h1, . . . , hK , we randomly pick K hyperplanes and each tuple is hashed with them to obtain a K dimensional hash code. This process is then repeated for all L hash tables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">LSH-based Blocking</head><p>We begin by generating hash codes h1, . . . , hK for each of the L hash tables using the random hyperplane method. for each non-empty bucket H in g do 8:</p><p>for each pair of tuples (t, t ) in H do 9:</p><p>Apply classifier on (t, t )</p><p>The set of hash functions h1, . . . , hK is analogous to a single blocking rule. The K dimensional binary hash code is equivalent to an identifier to a distinct block where t falls into. Each hash table performs "blocking" using a different blocking rule.</p><p>We index the DR of every tuple t in each of the L hash tables. LSH guarantees that similar tuples get the same hash code (and hence fall into the same block) with high probability. Then, we consider each of the blocks for every hash table and invoke the classifier over the distinct pairs of tuples found in them. Algorithm 4 provides the corresponding pseudocode.</p><p>Example 4: For simplicity, let us only hash the DR for attribute A1 of tuples t1 and t2. Let K = 4 and L = 1. Let the hash functions be h1 2 Algorithm 4 is a fairly straightforward adaptation of LSH to ER. As we shall see in the experiments, it works well empirically. However, the number of times a classifier would be invoked can be as much as O(L × b 2 max × Bmax) where L is the number of hash tables, bmax is the size of the largest block in any hash table and Bmax is the maximum number of non-empty blocks in any hash table. While the traditional LSH based approach is often efficient and effective, one can achieve improved performance with some additional domain knowledge. We next describe a sophisticated approach to reduce the impact of L and bmax.</p><formula xml:id="formula_2">= [-1, 1, 1], h2 = [1, 1, 1], h3 = [-1, -1, 1] and h4 = [-1, 1, -1]. Recall that v1[t1] = [0.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Multi-Probe LSH for Blocking</head><p>Recall that by increasing K, we ensure that the probability of dissimilar tuples falling into the same block is reduced. By increasing L, we ensure that similar tuples fall into the same block in at least one of the L hash tables. Hence while increasing L ensures that we will not miss a true duplicate pair, it is achieved at the additional cost of making extraneous comparisons between non-duplicate tuples. We wish to come up with a LSH based approach that achieves two objectives: (a) reduce the number of unnecessary comparisons and (b) reduce the number of hash tables L without seriously affecting recall.</p><p>Reducing Unnecessary Comparisons. Intuitively, we expect duplicate tuples to have a high similarity with each Algorithm 5 Approximate Nearest Neighbor Blocking 1: Index all tuples using LSH 2: for each tuple t do 3: Get candidate tuples using Multiprobe-LSH 4:</p><p>Sort tuples in candidates based on similarity with t 5:</p><p>Invoke classifier on t and each of top-N neighbors of t other and thereby more likely to be "near" each other. Hence, even if a block has a large number of tuples, it is not necessary to compare all pairs of tuples. Instead, given a tuple t, we retrieve the top-N nearest neighbors of t and invoke the classifier between t and these N nearest neighbors. This is achieved by collating all the tuples that fall into the same block as t in each of the L hash tables. We then compute the similarity between t and each of the candidates and return the top-N tuples. If the block is large with b tuples, then we only require Θ(b × N ) classifier invocations instead of Θ(b 2 ). We can see that by choosing N &lt; b, we can achieve considerable reduction in classifier invocations.</p><p>Reducing L. Naively decreasing the number of hash tables L can decrease the recall as a pair of duplicate tuples might fall into different blocks. The key idea is to augment a traditional LSH scheme with a carefully designed probing sequence that looks for multiple buckets (of the same hash table) that could contain similar tuples with high probability. This approach is called multi-probe LSH <ref type="bibr" target="#b37">[37]</ref>. Consider a tuple t and another very similar tuple t . It is possible that t and t do not fall into the same bucket (especially if K is large). However, due to the design of LSH, we would expect t to fall into a "close by" bucket whose hash code is very similar to the bucket in which t fell. Multi-probe leverages this observation by perturbing t in a systematic manner and looking at all buckets in which the perturbed t fell into. By carefully designing the perturbation process one can consider the buckets that have the highest probability of containing similar tuples. For example, a multi-probe of size 1 will consider all buckets whose hash codes have a hamming distance of 1 and so on. It has been shown that this approach often requires substantially less number of hash tables (as much as 20x) than a traditional approach <ref type="bibr" target="#b37">[37]</ref>. Algorithm 5 provides the pseudocode of this approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Tuning LSH Parameters for Blocking</head><p>In contrast to traditional blocking rules that are often heuristics, the hash functions in LSH allow us to provide rigorous theoretical guarantees. While the list of LSH guarantees is beyond the scope of this paper (see <ref type="bibr" target="#b47">[47]</ref> for details), we highlight two major ones.</p><p>Parameter Tuning for Recall. We can control the false positive and negative values (and thereby recall) by varying the values of c and R, such as by setting the values that get the best results for the tuples in the training dataset. We can obtain a fixed approximation ratio of c = 1 + by setting <ref type="bibr" target="#b51">[51]</ref>,</p><formula xml:id="formula_3">K = log n log 1/P2 L = n ρ where ρ = log(1/P1) log(1/P2)<label>(1)</label></formula><p>Parameter Tuning for Occupancy. LSH also allows us to control the occupancy -the expected number of tuples in any given block. This can be achieved by varying the size K of the number of hash functions in every hash table. Informally, if one uses multiple hash functions, we would expect very similar items to be stored in the same blocks but at the expense of low occupancy and a large number of blocks. On the other hand, a smaller number of hash functions results in less similar tuples being put in the same block. Intuitively, if we use only one hash function, this results in 2 buckets -one for +1 and -1. Since the hyperplane for the hash function is chosen randomly, we would expect each bucket to have an occupancy around 50% for all but most of the skewed data distributions. One can reduce the occupancy rate by increasing the number of hash functions. Alternatively, one can also use sophisticated methods such as <ref type="bibr" target="#b16">[16]</ref> to achieve guaranteed limits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EXPERIMENTAL RESULTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experimental Setup</head><p>Hardware and Platform. All our experiments were performed on a Core i7 6700HQ Skylake chip, with four cores running eight threads at speeds of up to 3.5GHz, along with 16GB of DDR4 RAM and the GTX 980M, complete with 8GB of DDR5 RAM. We used Torch <ref type="bibr" target="#b14">[14]</ref> and Keras <ref type="bibr" target="#b11">[11]</ref>, a deep learning framework, to train and test our models.</p><p>Datasets. We conducted extensive experiments over 7 different datasets covering diverse domains such as citations, e-commerce, and proteomics. Table <ref type="table" target="#tab_7">3</ref> provides some statistics of these datasets. All are popular benchmark datasets and have been extensively evaluated by prior ER work using both ML and non-ML based approaches. We partition our datasets into two categories: "easy" and "challenging". The former consists of datasets that are mostly structured and often have less noise in terms of typos and missing information. On the "easy" datasets most of the best existing ER approaches routinely exceed an F-score of 0.9. The challenging datasets often have unstructured attributes (such as product description) which are also noisy. On the "challenging" datasets that we study, both ML and rule based methods have struggled to achieve high F measures, with values between 0.6 and 0.7 being the norm. What these two categories have in common is that they require extensive effort from domain experts for cleaning, feature engineering and blocking to achieve good results. As we shall show later, our approach exceeds best existing results on all the datasets with minimal expert effort.</p><p>DeepER Setup. Our experimental setup was an adaptation of prior ER evaluations methods <ref type="bibr" target="#b32">[32,</ref><ref type="bibr" target="#b33">33,</ref><ref type="bibr" target="#b46">46]</ref> to handle DRs. For example, <ref type="bibr" target="#b32">[32]</ref> used an arbitrary threshold (such as 0.1) on Jaccard similarity of trigram to eliminate tuple pairs that are clearly non-matches. We make two changes to this procedure. First, we use Cosine similarity to compute similarity between tuple pairs as it is more appropriate for DRs <ref type="bibr" target="#b40">[40,</ref><ref type="bibr" target="#b43">43]</ref>. Second, instead of picking an arbitrary threshold, we set it to the minimum similarity of matched tuple pairs in the training dataset. We obtain the negative examples (non duplicates) by picking one tuple from the positive example and randomly picking another tuple from the relation that is not its match. For example, if (ti, tj) is a duplicate, we pick a pair (t k , t l ) as a negative example such that (t k , t l ) is not a duplicate already given in the training data and has cosine similarity with (ti, tj) below the above computed threshold. This approach is chosen to verify the robustness of our models against near matches. For each of the datasets, we performed K-fold cross validation with K=5. We report the average of the F-measure values obtained across all the folds. We observed that in all cases, the standard deviation of the F-measure values was below 1%.</p><p>DeepER Architecture. Since our objective is to highlight the turn-key aspect of DeepER, we choose the simplest possible architecture. We use GloVe <ref type="bibr" target="#b43">[43]</ref> as our DR. Figure <ref type="figure" target="#fig_4">5</ref> shows the architecture of DeepER. We used Adam for optimizing the DL model that were trained for 20 epochs with a batch size of 16. The learning rate was set to 0.01 and a regularization of 1e-3. For RNN-LSTM composition, we used a single RNN layer where the memory dimension for LSTM is 150. The dimension of the similarity layer is 50. When end-to-end learning is enabled, the embeddings update rate was set to 0.01. Each tuple is represented as a m × d dimensional vector where m is the number of attributes with d being the dimension of DRs. For each attribute, we apply a standard tokenizer and average the DR obtained from GloVe (as against more sophisticated approaches such as Bi-LSTM). Given a pair of tuples, the compositional similarity is computed as the Cosine similarity of the corresponding attributes resulting in a m dimensional similarity vector. As mentioned above, we used K-fold validation with a duplicate to nonduplicate ratio of 1:100 that is comparable to the ratio used by the competing approaches. This is to ensure fair comparison. Note that the non-duplicates are sampled automatically from the positive examples. This is achieved by selecting other tuple pairs that have a low cosine similarity with the duplicate being perturbed. This approach was inspired from <ref type="bibr" target="#b34">[34]</ref> where they demonstrate that an informative negative example is one that is far from the positive example. Quoting from their example, "truck" is selected over "dog" as the negative example for "cat". We also do not tune the DR for the ER task. Even with this restricted setup, DeepER is competitive with existing approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Comparison with Existing Methods</head><p>We first compare the performance of DeepER with the best reported results from non-learning, learning and crowd based approaches in <ref type="bibr" target="#b33">[33,</ref><ref type="bibr" target="#b26">26,</ref><ref type="bibr" target="#b17">17]</ref>. Table <ref type="table" target="#tab_8">4</ref> shows that the simple DeepER architecture has better performance, except for one dataset, namely Prod-WA, where a crowd-based approach does slightly better.</p><p>Performing ER on a large dataset requires a number of design choices from the expert such as feature engineering, selection of appropriate similarity functions and thresholds, parameter tuning for ML models, selection of appropriate blocking functions, and so on. Hence, it is incredibly hard to take any of the existing approaches and apply it as-is on a new dataset. A key advantage of DeepER is the ability to dramatically reduce this effort. In order to highlight this feature, we evaluated DeepER against Magellan <ref type="bibr" target="#b31">[31]</ref> that also has a end-to-end EM pipeline. We would like to emphasize that both DeepER and Magellan share the dream of making the EM process as frictionless as possible. While Magellan uses a series of sophisticated heuristics internally, DeepER leverages DRs as a foundational technique. It is very easy to incorporate features from DeepER and Magellan to each other. For example, one can augment Magellan's automatically derived similarity based features to DeepER while Magellan can readily use the blocking of DeepER and so on. Table <ref type="table" target="#tab_8">4</ref> compares the performance of DeepER and Magellan using their default settings. Specifically, we adapted the end-to-end EM workflow for Magellan <ref type="bibr" target="#b38">[38]</ref>. We can see that DeepER beats Magellan on two datasets, while performing slightly worst in one datasets. Both systems delivered perfect results in the rather simple Fodors-Zagat dataset.</p><p>Evaluating DeepER for Other Domains. In order to show that our approach can be readily applied to other domains, we consider the problem of determining duplicates in a nucleotide database. We assumed that we were provided with an appropriate dictionary for biomedical embeddings. We evaluated our model on a large benchmark dataset <ref type="bibr" target="#b10">[10]</ref> consisting of 21 most heavily studied organisms in molecular biology. Our method was able to beat ML models with hand-crafted approach in 11 of these cases while it was within a F1-score of ± 5 for the remaining. Overall, our approach achieved an F1-measure of 87.4 for the automatic curation benchmark where the state-of-the-art is 83.9. This shows that our approach can be readily applied to other domains given the availability of effective embeddings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Understanding DeepER Performance</head><p>We next investigate how each of the enhancements to the basic DeepER architecture impacts its performance. For this subsection, we use a positive to negative ratio of 1:4. This is different from the ratio we used when compared to competing approaches as this turned to be best for DeepER.</p><p>Varying the Size of Training Data. Figure <ref type="figure">6</ref> shows the results of varying the amount of training data. DeepER is robust enough to be competitive with other approaches with as little as 10% of training data. Note that 10% translates to as little as 11 examples to label in the case of Rest-FZ and to 543 in the case of Pub-DS. As expected, our method improves its excellent results with larger training data. This is due to two key aspects: (a) the ability of DeepER to leverage/transfer the semantic similarity learned by DRs for ER      Impact of Incorrect Labels. Most of the prior work on ER assumes that the training data is perfect. However, this assumption might not always hold in practice. Given the increasing popularity of crowdsourcing for obtaining training data, it is likely that some of the labels for matching and non-matching pairs are incorrect. We investigate the impact of incorrect labels in this experiment. For a fixed set of training data (10%), we vary the fraction of labels that are marked incorrectly. Figure <ref type="figure">7</ref> shows the results. While the F-measure reduces with larger fraction of incorrect labels, the experiments also show that our approach is very robust. The average drop in F-measure values compared to the perfect labeling case across all datasets at 10% noise is just 2.6 with a standard deviation of 2.6. At 30% the average drop is 8% with a standard deviation of 7%. We can also see that at 10% noising, our approach is still competitive with state-of-the-art approaches.</p><p>Dynamic vs Static Word Embeddings. In this set of experiments, we evaluated the effect of updating (or finetuning) the initial word embeddings obtained from GloVe as part of training the model. In other words, we evaluated if tuning the DR for ER tasks improves the performance of our model. Figure <ref type="figure" target="#fig_6">8</ref> shows the results. The results matched our intuition that for the "challenging" datasets, updating the word embeddings in an end-to-end learning framework helped boost the results a little, whilst for the "easy" ones, it had either a small negative effect or no effect at all. Thus, we advise that in general, it is better to use the end-to-end framework.</p><p>Varying Composition. In this set of experiments, we vary the compositional method we use to combine the individual word embeddings into a single representative vector for the tuple/attribute. In addition to word averaging and LSTM, we added a method based on Sentence2Vec <ref type="bibr" target="#b35">[35]</ref> and that is tuned using our end-to-end learning methods (Section 3.4), for completeness. Figure <ref type="figure" target="#fig_8">9</ref> shows that for the "easy" datasets, simple word averaging work usually better than recurrent compositional models (LSTM or BiLSTM). This flips for the "challenging" datasets where sophisticated compositional approaches perform slightly better. This is especially noticeable for Prod-AG. Understanding and automatically recommending the appropriate architecture for a given dataset is a key focus of our future research. In order to use the more complex compositional methods (LSTM or BiLSTM) one has to pay the price of its longer training times, one also has to tune its additional hyperparameters. However, even the simple averaging compositional technique is competitive with prior approaches on all datasets. We also observe that both methods are superior to Sentence2Vec with a slight exception on the Prod-AG dataset where it is superior to Average.</p><p>Varying Word Embedding Dictionaries. Here, we study the impact of the dictionary used for DRs. GloVe has two major dictionaries : one trained on Common Crawl web corpus (840B tokens, 2.2M words) and one on Wikipedia (6B tokens, 400K words). We used the vocabulary retrofitting to handle words not present in the dictionary. Table <ref type="table" target="#tab_12">5</ref> shows the result of the experiments. As expected, there is a steep drop in F1 score when trained on a smaller dictionary. The larger the corpus used for training the word embeddings, the better they are identifying semantic relationships. Varying Word Embedding Models. We conducted experiments on three popular models, GloVe, Word2Vec, and FastText, which were trained on a corpus with 840B tokens, 100B tokens and 600B tokens, respectively. The number of words identified are 2.2M, 3M, and 1M, respectively. Note that for fairness of comparison, we only considered word embeddings in FastText even though it also allows character embeddings. We used the vocabulary retrofitting to handle words not present in the dictionary. Table <ref type="table" target="#tab_13">6</ref> shows the results of the experiments. In general, there are only minor variations between the different approaches.</p><p>Multi-Lingual Datasets. We now show an auxiliary benefit of using a DR-based approach. We took three datasets that were originally in English and translated them to Spanish. We then used the DRs for Spanish and repeated our approach. Table <ref type="table" target="#tab_14">7</ref> shows that while there is a reduction in F1-score, our approaches can seamlessly work on multilingual datasets. Since we used "Google translate", we had </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Evaluating LSH-based Blocking</head><p>In this subsection, we evaluate the performance of our LSH based blocking approach. Our approach allows us to vary K (the size of the hash code) and L (the number of hash tables) in order to achieve a tunable performance. Recall that one can use Equation 1 to derive K and L based on the task requirements. Suppose we wish that similar tuples should fall into same bucket with probability P1 = 0.95 and dissimilar tuples should fall into the same bucket with probability P2 ≤ 0.5. Suppose that we index the DBLP dataset of Pub-DS. Then based on Equation <ref type="formula" target="#formula_3">1</ref>, we need a LSH with K = 12 and L = 2.</p><p>In our first set of experiments, we verify that the behavior of blocking is synchronous with the theoretical expectations. We evaluate the performance of blocking based on two metrics widely used in prior research <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b39">39]</ref>. The first metric, efficiency or reduction ratio (RR), is the ratio of the number of tuple pairs compared by our approach to the number of all possible pairs in T . In other words, a smaller value indicates a higher reduction in the number of comparisons made. The second metric, recall or pair completeness (PC), is the ratio of the number of true duplicates compared by our approach against the total number of duplicates in T . A higher value for PC means that our approach places the duplicate tuple pairs in the same block.</p><p>Figures <ref type="figure" target="#fig_9">10(a</ref>)-10(d) show the results of our experiments. As K is increased, the value of PC decreases. This is due to the fact that for a fixed L, increasing K reduces the likelihood that two similar tuples will be placed in the same block which in turn reduces the number of duplicates that falls into the same block. However, for a fixed L, increasing K dramatically decreases the RR. This is to be expected as a larger value of K increases the number of LSH buckets into which tuples can be assigned to.</p><p>A complementary behavior can be observed when we fix K and vary L. When L increases, PC also increases. This is to be expected as the probability that two similar tuples being assigned to the same bucket increases when more than one hash table is involved. In other words, even if a true duplicate does not fall into the same bucket in one hash table, it can fall into the same bucket in other hash tables. However, increasing L has a negative impact on RR as some false positive tuple pairs can fall into the same bucket in at least one hash table thereby increasing the value of RR.</p><p>Evaluating DeepER End-to-End. We next evaluate the performance of DeepER by combining both the blocker and the matcher. The results are shown in Figure <ref type="figure" target="#fig_2">11</ref>. First, we study how precision and recall are impacted by varying K for a fixed L. The recall decreases with increased K as more and more duplicates are not put in the same block which results in DeepER missing them. The precision increases mildly with increasing K as an increasing number of spurious non-duplicates are no longer being compared. For example, when K = 1, almost half of all possible pairs are classified by DeepER, which reduces the precision with potential false positives. However, when K = 10, only a quarter of all possible pairs are classified, resulting in mild increase of precision. The reason for the mild increase is that the classifier of DeepER is relatively robust and achieved high precision even for low value of K.</p><p>Figures <ref type="figure" target="#fig_9">10 c-d</ref> study the impact of varying L for a fixed K on precision and recall. As expected, the recall increases with higher L as almost all the true duplicates are put in the same block and end up being classified as such by DeepER. Since DeepER is quite accurate, this results in increased recall. The precision declines mildly with increasing L. The reason is that more and more non-duplicates are put in the same block resulting in potential false positives. Once again, the impact is mild as the classifier is relatively robust.</p><p>Evaluating Multi-Probe LSH. We evaluate Algorithm 5 using Multi-probe and comparing a tuple only with top-N most similar tuples instead of all tuples in a block. Figure <ref type="figure" target="#fig_2">12</ref> shows the result for Pub-AG. We vary the number of multi-probes and pick the top-N most similar tuples to be classified. We measure the recall of this approach for K = 10 and an extreme case with a single hash table where L = 1. We wish to highlight two trends. First, even using a single multi-probe sequence can dramatically increases the recall. This supports our claim that one can increase recall using a small number of hash tables by using multi-probe LSH. Second, increasing the size of N does not dramatically increase the recall. This is due to the fact that duplicate tuples have high similarity between their corresponding distributed representations. Our top-N based approach would be preferable to reduce the number of classifier invocations when the block size is much higher than 10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED WORK</head><p>Entity Resolution. A good overview of ER can be found in surveys such as <ref type="bibr" target="#b21">[21,</ref><ref type="bibr" target="#b42">42]</ref>. Prior work can be categorized as based on (a) declarative rules, (b) ML and (c) expert or crowd based. Declarative rules, such as DNF which specify rules for matching tuples, are easily interpretable <ref type="bibr" target="#b46">[46]</ref> but often requires a domain expert. Most of the ML approaches are variants of the classical Fellegi-Sunter model <ref type="bibr" target="#b23">[23]</ref>. Popular approaches include SVM <ref type="bibr">[8]</ref>, active learning <ref type="bibr" target="#b44">[44]</ref>, clustering <ref type="bibr" target="#b13">[13]</ref>. Recently, ER using crowdsourcing has become popular <ref type="bibr" target="#b49">[49,</ref><ref type="bibr" target="#b26">26]</ref>. While there exist some work for learning similarity functions and thresholds <ref type="bibr">[8,</ref><ref type="bibr" target="#b50">50]</ref>, ER often requires substantial involvement of the expert.</p><p>There has been extensive work on building EM systems. <ref type="bibr" target="#b31">[31]</ref> provides a comprehensive survey of the current EM systems. Most of the prior works often do not cover the entire EM pipeline, require extensive interaction with experts and          are not turn-key systems. The key objective of DeepER is the same as Magellan <ref type="bibr" target="#b31">[31]</ref>. We propose a end-to-end EM system based on DR that minimizes the burden on the experts. Our techniques are modular enough and can be easily incorporated into any of the existing systems.</p><p>There has been extensive interest in applying DL in data cleaning <ref type="bibr" target="#b48">[48]</ref>. A recent work that extends DeepER <ref type="bibr" target="#b41">[41]</ref> explored the design space of ER using DRs. The authors introduce four different choices for the attribute summarization process, namely, SIF, RNN, Attention, and Hybrid. The first two methods are similar to our AVG and LSTM-RNN methods. Attention uses decomposable attention for attribute summarization and vector concatenation to perform attribute comparison. Hybrid uses a bidirectional RNN with decomposable attention for attribute summarization and a vector concatenation and element-wise absolute difference during attribute comparison. While this work shares some similarities with DeepER, there are two notable differences. We present solutions for the practical situations where for dealing with data with partial or minimal coverage. We also propose efficient and effective blocking solutions.</p><p>Blocking. Blocking has been extensively studied as a way to scale ER systems and a good overview can be found in sur-veys such as <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b12">12]</ref>. Common approaches include key-based blocking that partitions tuples into blocks based on their values on certain attributes and rule-based blocking where a decision rule determines which block a tuple falls into. There has been limited work on simplifying this process by either learning blocking schemes such as <ref type="bibr" target="#b39">[39]</ref> or tuning the blocking <ref type="bibr" target="#b30">[30]</ref>. In contrast, our work automates the blocking process by requiring minimal input from the domain expert. Some recent works used LSH for blocking. <ref type="bibr" target="#b47">[47]</ref> uses Min-Hashing where tuples with high Jaccard similarity are likely to be assigned to the same block. <ref type="bibr" target="#b52">[52]</ref> improves it by proposing a MinHashing with semantic similarity based on concept hierarchy to assign conceptually similar tuples to the same block. <ref type="bibr" target="#b24">[24]</ref> proposed a clustering based method to satisfy size constraints with upper and lower size thresholds for blocks for performance and privacy reasons.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">FINAL REMARKS</head><p>In this paper, we introduced DeepER, a DL-based approach for ER. Our fundamental contribution is the identification of the concept of DRs as a key building block for designing effective ER classifiers. We also propose algorithms to transform a tuple to a DR, building DR-aware classifiers and an efficient blocking strategy based on LSH. Our extensive experiments show that our approach is promising and already achieves or surpasses the state-of-the-art on multiple benchmark datasets. We believe that DL is a powerful tool that has applications in databases beyond ER and it is our hope that our ideas be extended to build practical and effective ER systems.</p><p>There are several avenues for improving DeepER. First, understand and automatically recommend the appropriate DL architecture for a given dataset, especially complex ones. Another line of work is to design a hybrid system that leverages both automatic features, such as DRs, and manual features, such as a similarity metric for IDs. Finally, we will also need to address the cases where the data is dirty.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: A Typical ER Pipeline</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: RNN with LSTM in the Hidden Layer</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Example 1 :</head><label>1</label><figDesc>Using our running example, v1[t1] = [0.45, 0.8, 0.85] and v1[t2] = [0.4, 0.85, 0.75]. v2[t1] = v2[t2] = [0.1, 0.1, 0.2]. The DR for t1 and t2 are obtained by concatenating the DRs for A1 and A2. 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: A Sample for Vocabulary Retrofitting</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Deep Entity Resolution Framework</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>45, 0.8, 0.85] and v1[t2] = [0.4, 0.85, 0.75]. If you do a dot product of v1[t1] with each of the hi's, you get [0.86, 1.53, -0.26, -0.39]. The corresponding output for v1[t2] is [0.86, 1.46, -0.33, -0.26]. Note that the LSH hash code is obtained by thresholding the values such that positive values get +1 and negative values -1. So the hash code of both these tuples is [1, 1, -1, -1].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :</head><label>8</label><figDesc>Figure 10-a Prod-AG Pub-DS 1 1 1 2 1 1 3 1 1 4 0.98 1 5 0.96 0.99 6 0.93 0.97 7 0.89 0.94 8 0.84 0.9 9 0.8 0.85 10 0.74 0.81</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Figure 10-b Prod-AG Pub-DS 1 0.4 0.08 2 0.4 0.08 3 0.4 0.08 4 0.39 0.08 5 0.37 0.08 6 0.34 0.07 7 0.31 0.06 8 0.28 0.05 9 0.24 0.04 10 0.2 0.04</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Varying Composition and (b) a DL architecture that is customized for ER. Please refer to<ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b27">27,</ref><ref type="bibr" target="#b54">54]</ref> for additional details about the beneficial impact of effective representation/transfer learning and well designed DL architectures.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 10 :</head><label>10</label><figDesc>Impact of varying K and L on Pair Completeness (PC) and Reduction Ratio (RR).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 11 :Figure 12 :</head><label>1112</label><figDesc>Figure 11: Impact of varying K and L on Precision and Recall of DeepER</figDesc><graphic coords="12,350.37,181.07,91.46,64.20" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Algorithm 1 A Simple Averaging Approach 1: Input: Tuple t, a pre-trained dictionary such as GloVe 2: Output: Distributed representation v(t) for t 3: for each attribute A k of t do 4: Tokenize t[A k ] into a set of words W 5: Look up vectors for tokens w l ∈ W in GloVe 6: v k (t) := average of vectors of tokens in t[A k ] 7: v(t) := concatenation of v(t[A k ]), for k ∈ [1, m]</figDesc><table><row><cell>king</cell><cell>0.9 0.9</cell><cell>0.7 0.9</cell><cell>0.2</cell><cell>-0.2</cell><cell>0.7</cell><cell>0 .1</cell></row><row><cell>queen</cell><cell>0.9 0.9</cell><cell>0.7 -0.1</cell><cell>0.2</cell><cell>0.8</cell><cell>-0.2</cell><cell>0.1</cell></row><row><cell>woman</cell><cell>0.9 0.2</cell><cell>0.7 -0.2</cell><cell>0.2</cell><cell>0.9</cell><cell>0.9</cell><cell>0.1</cell></row><row><cell>man</cell><cell>0.9 0.3</cell><cell>0.7 0.8</cell><cell>0.2</cell><cell>-0.1</cell><cell>0.1</cell><cell>0.1</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1</head><label>1</label><figDesc></figDesc><table /><note><p><p><p>provides a toy relation with 2 tuples and Table</p>2</p>provides word embeddings with 3 dimensions.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1</head><label>1</label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell cols="2">: Toy Dataset for ER</cell></row><row><cell cols="2">Tuple ID</cell><cell>A1 : Name</cell><cell>A2 : City</cell></row><row><cell>t1</cell><cell></cell><cell>Bill Gates</cell><cell>Seattle</cell></row><row><cell>t2</cell><cell></cell><cell>William Gates</cell><cell>Seattle</cell></row><row><cell cols="4">Table 2: Sample Word Embeddings</cell></row><row><cell>Word</cell><cell cols="3">Distributed Representation</cell></row><row><cell>Bill</cell><cell></cell><cell cols="2">[0.4, 0.8, 0.9]</cell></row><row><cell>William</cell><cell></cell><cell cols="2">[0.3, 0.9, 0.7]</cell></row><row><cell>Gates</cell><cell></cell><cell cols="2">[0.5, 0.8, 0.8]</cell></row><row><cell>Seattle</cell><cell></cell><cell cols="2">[0.1, 0.1, 0.2]</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>Algorithm 4 ER Classifier with LSH based Blocking 1: Input: Table T , training set S, L 2: Output: All matching tuple pairs in Table T 3: Generate hash functions for g1, . . . , gL using the random hyperplane method 4: for each tuple t do 5: Index the DR of t into L hash tables using g1, . . . , gL 6: for each hash table g in [g1, . . . , gL] do 7:</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 3 :</head><label>3</label><figDesc>Data Statistics: * (Easy), ‡ (Hard).</figDesc><table><row><cell cols="4">Walmart-Amazon (Prod-WA), Amazon-Google</cell></row><row><cell cols="4">(Prod-AG), DBLP-ACM (Pub-DA), DBLP-</cell></row><row><cell cols="4">Scholar (Pub-DS), DBLP-Citeseer (Pub-DC),</cell></row><row><cell cols="2">Fodors-Zagat (Rest-FZ)</cell><cell></cell><cell></cell></row><row><cell>Dataset</cell><cell>#Tuples</cell><cell cols="2">#Matches #Attr</cell></row><row><cell>Walmart-Amazon  ‡ [18]</cell><cell>2,554 -22,074</cell><cell>1,154</cell><cell>17</cell></row><row><cell>Amazon-Google  ‡ [1]</cell><cell>1,363 -3,226</cell><cell>1,300</cell><cell>5</cell></row><row><cell>DBLP-ACM  *  [1]</cell><cell>2,616 -2,294</cell><cell>2,224</cell><cell>4</cell></row><row><cell>DBLP-Scholar  *  [1]</cell><cell>2,616 -64,263</cell><cell>5,347</cell><cell>4</cell></row><row><cell cols="2">DBLP-Citeseer  *  [18] 1,823,978-2,512,927</cell><cell>558,787</cell><cell>4</cell></row><row><cell>Fodors-Zagat  *  [2]</cell><cell>533 -331</cell><cell>112</cell><cell>7</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 4 :</head><label>4</label><figDesc>Comparing DeepER with state-of-theart published results from existing rule-, MLand crowd-based approaches. We also compared against Magellan, another end-to-end EM system.</figDesc><table><row><cell>Dataset</cell><cell cols="2">Magellan DeepER</cell><cell>Published</cell></row><row><cell>Prod-WA</cell><cell>82.99</cell><cell>88.06</cell><cell>89.3 [26] (Crowd)</cell></row><row><cell>Prod-AG</cell><cell>87.68</cell><cell>96.029</cell><cell>62.2 [33] (ML)</cell></row><row><cell>Pub-DA</cell><cell>97.6</cell><cell>98.6</cell><cell>N/A</cell></row><row><cell>Pub-DS</cell><cell>98.84</cell><cell>97.67</cell><cell>92.1 [26] (Crowd)</cell></row><row><cell>Pub-DC</cell><cell>96.4</cell><cell>99.1</cell><cell>95.2 [17] (Crowd)</cell></row><row><cell>Rest-FZ</cell><cell>100</cell><cell>100</cell><cell>96.5 [26] (Crowd)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>on Recall Precision G Pub-DS L Prod-AG Pub-DS L Prod-AG Pub-DS 88</head><label></label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>10</cell><cell>0.16</cell><cell>0.33</cell><cell>0.42</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">20 0.173</cell><cell>0.36 0.469</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>30</cell><cell>0.18</cell><cell>0.38</cell><cell>0.49</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>40</cell><cell>0.18</cell><cell>0.39</cell><cell>0.51</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">50 0.186</cell><cell>0.41</cell><cell>0.53</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>100</cell><cell>0.19</cell><cell>0.44</cell><cell>0.58</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>1</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>No MP</cell><cell>MP=1</cell><cell>MP=2</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0.75</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Recall</cell><cell>0.5</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0.25</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0</cell><cell>10</cell><cell>20</cell><cell>30</cell><cell>40</cell><cell>50</cell><cell>100</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>top-N</cell></row><row><cell></cell><cell>95</cell><cell>1</cell><cell>48</cell><cell>59</cell><cell>1</cell><cell>88</cell><cell>95</cell></row><row><cell>88</cell><cell>95</cell><cell>2</cell><cell>65</cell><cell>78</cell><cell>2</cell><cell>88</cell><cell>95</cell></row><row><cell>88</cell><cell>95</cell><cell>3</cell><cell>75</cell><cell>86</cell><cell>3</cell><cell>86</cell><cell>95</cell></row><row><cell>88</cell><cell>95</cell><cell>4</cell><cell>82</cell><cell>92</cell><cell>4</cell><cell>85</cell><cell>95</cell></row><row><cell>88</cell><cell>95</cell><cell>5</cell><cell>84</cell><cell>93</cell><cell>5</cell><cell>84</cell><cell>95</cell></row><row><cell>89</cell><cell>95</cell><cell>6</cell><cell>88</cell><cell>95</cell><cell>6</cell><cell>84</cell><cell>93</cell></row><row><cell>89</cell><cell>97</cell><cell>7</cell><cell>90</cell><cell>96</cell><cell>7</cell><cell>83</cell><cell>92</cell></row><row><cell>89</cell><cell>97</cell><cell>8</cell><cell>91</cell><cell>97</cell><cell>8</cell><cell>83</cell><cell>92</cell></row><row><cell>90</cell><cell>97</cell><cell>9</cell><cell>92</cell><cell>97</cell><cell>9</cell><cell>83</cell><cell>92</cell></row><row><cell>92</cell><cell>99</cell><cell>10</cell><cell>92</cell><cell>98</cell><cell>10</cell><cell>82</cell><cell>92</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head>Table 5 :</head><label>5</label><figDesc>Impact of Word Embedding Dictionaries</figDesc><table><row><cell>Dataset</cell><cell cols="2">GloVe GloVe-Wiki</cell></row><row><cell>Pub-DA</cell><cell>98.6</cell><cell>82.1</cell></row><row><cell>Pub-DS</cell><cell>97.67</cell><cell>77.8</cell></row><row><cell>Pub-DC</cell><cell>99.1</cell><cell>79.2</cell></row><row><cell>Prod-WA</cell><cell>88.06</cell><cell>77.4</cell></row><row><cell>Prod-AG</cell><cell>96.029</cell><cell>87.2</cell></row><row><cell>Rest-FZ</cell><cell>100</cell><cell>91.2</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head>Table 6 :</head><label>6</label><figDesc>Impact of Word Embedding Used</figDesc><table><row><cell cols="4">Dataset GloVe Word2Vec FastText</cell></row><row><cell>Pub-DA</cell><cell>98.6</cell><cell>97.9</cell><cell>98.2</cell></row><row><cell>Pub-DS</cell><cell>97.6</cell><cell>96.9</cell><cell>97.2</cell></row><row><cell>Pub-DC</cell><cell>99.1</cell><cell>99</cell><cell>99</cell></row><row><cell>Prod-WA</cell><cell>88.06</cell><cell>86.1</cell><cell>88.89</cell></row><row><cell>Prod-AG</cell><cell>96.03</cell><cell>95.1</cell><cell>95.7</cell></row><row><cell>Rest-FZ</cell><cell>100</cell><cell>100</cell><cell>100</cell></row><row><cell cols="4">to limit how much we could translate. However, we expect</cell></row><row><cell cols="3">to see similar results with the other datasets.</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14"><head>Table 7 :</head><label>7</label><figDesc>Showcasing ER on Multilingual Datasets</figDesc><table><row><cell cols="3">Dataset English Spanish</cell></row><row><cell>Prod-AG</cell><cell>96.029</cell><cell>89.1</cell></row><row><cell>Rest-FZ</cell><cell>100</cell><cell>92.6</cell></row><row><cell>Pub-DS</cell><cell>97.67</cell><cell>88.1</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Rules can also be hand-crafted based on domain knowledge.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="https://dbs.uni-leipzig.de/en/research/projects/object_matching/fever/benchmark_datasets_for_entity_resolution" />
		<title level="m">Benchmark datasets for entity resolution</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<ptr target="http://www.cs.utexas.edu/users/ml/riddle/data.html" />
		<title level="m">Duplicate detection, record linkage, and identity uncertainty: Datasets</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Continuous distributed representation of biological sequences for deep proteomics and genomics</title>
		<author>
			<persName><forename type="first">E</forename><surname>Asgari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Mofrad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PloS one</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page">141287</biblScope>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A comparison of fast blocking methods for record linkage</title>
		<author>
			<persName><forename type="first">R</forename><surname>Baxter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Christen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Churches</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGKDD Workshop on Data Cleaning, Record Linkage, and Object Consolidation</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Representation learning: A review and new perspectives</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Courville</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Vincent</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE transactions on pattern analysis and machine intelligence</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1798" to="1828" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A neural probabilistic language model</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ducharme</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Vincent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Janvin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JMLR</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Learning long-term dependencies with gradient descent is difficult</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Simard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Frasconi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trans. Neur. Netw</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="157" to="166" />
			<date type="published" when="1994-03">Mar. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Adaptive duplicate detection using learnable string similarity measures</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bilenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Mooney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KDD</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Bojanowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Grave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Joulin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mikolov</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1607.04606</idno>
		<title level="m">Enriching word vectors with subword information</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Benchmarks for measurement of duplicate detection methods in nucleotide databases</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zobel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Verspoor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Database</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Deep learning with Python</title>
		<author>
			<persName><forename type="first">F</forename><surname>Chollet</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018">2018</date>
			<publisher>Manning Publications</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A survey of indexing techniques for scalable record linkage and deduplication</title>
		<author>
			<persName><forename type="first">P</forename><surname>Christen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TKDE</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Learning to match and cluster large high-dimensional data sets for data integration</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Richman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">KDD</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Torch7: A matlab-like environment for machine learning</title>
		<author>
			<persName><forename type="first">R</forename><surname>Collobert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kavukcuoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Farabet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">BigLearn, NIPS Workshop</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Natural language processing (almost) from scratch</title>
		<author>
			<persName><forename type="first">R</forename><surname>Collobert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Weston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bottou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Karlen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kavukcuoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kuksa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JMLR</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Lsh banding for large-scale retrieval with memory and recall constraints</title>
		<author>
			<persName><forename type="first">M</forename><surname>Covell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Baluja</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICASSP</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Falcon: Scaling up hands-off crowdsourced entity matching to build cloud services</title>
		<author>
			<persName><forename type="first">S</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S G C</forename></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Doan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Naughton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Krishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Deep</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Arcaute</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Raghavendra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Park</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1431" to="1446" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Doan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S G C</forename></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gokhale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Konda</surname></persName>
		</author>
		<ptr target="https://sites.google.com/site/anhaidgroup/projects/data" />
		<title level="m">The magellan data repository</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Human-in-the-loop challenges for entity matching: A midterm report</title>
		<author>
			<persName><forename type="first">A</forename><surname>Doan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ardalan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Ballard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Govind</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Konda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mudgal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Paulson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S G C</forename></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HILDA@SIGMOD</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Record linkage</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>Dunn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">American Journal of Public Health</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">12</biblScope>
			<date type="published" when="1946">1946</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Duplicate record detection: A survey</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Elmagarmid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Ipeirotis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Verykios</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TKDE</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Faruqui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dodge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Jauhar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Dyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Hovy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">A</forename><surname>Smith</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1411.4166</idno>
		<title level="m">Retrofitting word vectors to semantic lexicons</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A theory for record linkage</title>
		<author>
			<persName><forename type="first">I</forename><surname>Fellegi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sunter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the American Statistical Association</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="issue">328</biblScope>
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A clustering-based framework to control block sizes for entity resolution</title>
		<author>
			<persName><forename type="first">J</forename><surname>Fisher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Christen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rahm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">KDD</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Similarity search in high dimensions via hashing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gionis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Indyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PVLDB</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">99</biblScope>
			<biblScope unit="page" from="518" to="529" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Corleone: hands-off crowdsourcing for entity matching</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gokhale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Doan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Naughton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Rampalli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Shavlik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="601" to="612" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Deep Learning</title>
		<author>
			<persName><forename type="first">I</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Courville</surname></persName>
		</author>
		<ptr target="http://www.deeplearningbook.org" />
		<imprint>
			<date type="published" when="2016">2016</date>
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Long short-term memory</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hochreiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schmidhuber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural computation</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1735" to="1780" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Approximate nearest neighbors: Towards removing the curse of dimensionality</title>
		<author>
			<persName><forename type="first">P</forename><surname>Indyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirtieth Annual ACM Symposium on the Theory of Computing</title>
		<meeting>the Thirtieth Annual ACM Symposium on the Theory of Computing<address><addrLine>Dallas, Texas, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998">May 23-26, 1998. 1998</date>
			<biblScope unit="page" from="604" to="613" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Mfiblocks: An effective blocking algorithm for entity resolution</title>
		<author>
			<persName><forename type="first">B</forename><surname>Kenig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Systems</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Magellan: Toward building entity matching management systems</title>
		<author>
			<persName><forename type="first">P</forename><surname>Konda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Suganthan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">C</forename></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Doan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ardalan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Ballard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Panahi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Naughton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">13</biblScope>
			<biblScope unit="page" from="1581" to="1584" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Training selection for tuning entity matching</title>
		<author>
			<persName><forename type="first">H</forename><surname>Köpcke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rahm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">QDB/MUD</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Evaluation of entity resolution approaches on real-world match problems</title>
		<author>
			<persName><forename type="first">H</forename><surname>Köpcke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Thor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rahm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="484" to="493" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Hubness and pollution: Delving into cross-space mapping for zero-shot learning</title>
		<author>
			<persName><forename type="first">A</forename><surname>Lazaridou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Dinu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Baroni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing</title>
		<meeting>the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="270" to="280" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Distributed representations of sentences and documents</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mikolov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">When are tree structures necessary for deep learning of representations?</title>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Luong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Jurafsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Hovy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EMNLP</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Multi-probe lsh: efficient indexing for high-dimensional similarity search</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Lv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Josephson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Charikar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PVLDB</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="950" to="961" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">End-to-end em workflows</title>
		<author>
			<persName><surname>Magellan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Learning blocking schemes for record linkage</title>
		<author>
			<persName><forename type="first">M</forename><surname>Michelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Knoblock</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAAI</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="440" to="445" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Distributed representations of words and phrases and their compositionality</title>
		<author>
			<persName><forename type="first">T</forename><surname>Mikolov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Corrado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Deep learning for entity matching: A design space exploration</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mudgal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rekatsinas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Doan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Krishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Deep</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Arcaute</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Raghavendra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">An introduction to duplicate detection</title>
		<author>
			<persName><forename type="first">F</forename><surname>Naumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Herschel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Synthesis Lectures on Data Management</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="87" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Glove: Global vectors for word representation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pennington</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Socher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Manning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EMNLP</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Interactive deduplication using active learning</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sarawagi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bhamidipaty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KDD</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Bidirectional recurrent neural networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Schuster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">K</forename><surname>Paliwal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TSP</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Synthesizing entity matching rules by examples</title>
		<author>
			<persName><forename type="first">R</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Meduri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Elmagarmid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Madden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Papotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Quiané-Ruiz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Tang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="189" to="202" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m" type="main">A comparison of blocking methods for record linkage</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Steorts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">L</forename><surname>Ventura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sadinle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">E</forename><surname>Fienberg</surname></persName>
		</author>
		<editor>PSD</editor>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Data curation with deep learning : Towards self driving data curation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Thirumuruganathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ouzzani</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1803.01384</idno>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Crowder: Crowdsourcing entity resolution</title>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kraska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Feng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1483" to="1494" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Entity matching: How similar is similar</title>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">X</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Feng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="622" to="633" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title level="m" type="main">Hashing for similarity search: A survey</title>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">T</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ji</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1408.2927</idno>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Semantic-aware blocking for entity resolution</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TKDE</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Data quality in data warehouses</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename><surname>Winkler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Encyclopedia of Data Warehousing and Mining</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="550" to="555" />
		</imprint>
	</monogr>
	<note>Second Edition (4 Volumes</note>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">How transferable are features in deep neural networks?</title>
		<author>
			<persName><forename type="first">J</forename><surname>Yosinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Clune</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lipson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="3320" to="3328" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
