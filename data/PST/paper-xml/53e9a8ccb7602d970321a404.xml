<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Internally Deterministic Parallel Algorithms Can Be Fast</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Guy</forename><forename type="middle">E</forename><surname>Blelloch</surname></persName>
							<email>guyb@cs.cmu.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Carnegie Mellon University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jeremy</forename><forename type="middle">T</forename><surname>Fineman</surname></persName>
							<email>jfineman@cs.georgetown.edu</email>
							<affiliation key="aff1">
								<orgName type="laboratory">Georgetown University ‡ Intel Labs</orgName>
								<address>
									<settlement>Pittsburgh</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Phillip</forename><forename type="middle">B</forename><surname>Gibbons</surname></persName>
							<email>phillip.b.gibbons@intel.com</email>
						</author>
						<author>
							<persName><forename type="first">Julian</forename><surname>Shun</surname></persName>
							<email>jshun@cs.cmu.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Carnegie Mellon University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Internally Deterministic Parallel Algorithms Can Be Fast</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">AD490DEBB73BA758ECC7982229C4C3F3</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:14+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.1 [Concurrent Programming]: Parallel programming General Terms Algorithms</term>
					<term>Experimentation</term>
					<term>Performance Parallel algorithms</term>
					<term>deterministic parallelism</term>
					<term>parallel programming</term>
					<term>commutative operations</term>
					<term>graph algorithms</term>
					<term>geometry algorithms</term>
					<term>sorting</term>
					<term>string processing</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The virtues of deterministic parallelism have been argued for decades and many forms of deterministic parallelism have been described and analyzed. Here we are concerned with one of the strongest forms, requiring that for any input there is a unique dependence graph representing a trace of the computation annotated with every operation and value. This has been referred to as internal determinism, and implies a sequential semantics-i.e., considering any sequential traversal of the dependence graph is sufficient for analyzing the correctness of the code. In addition to returning deterministic results, internal determinism has many advantages including ease of reasoning about the code, ease of verifying correctness, ease of debugging, ease of defining invariants, ease of defining good coverage for testing, and ease of formally, informally and experimentally reasoning about performance. On the other hand one needs to consider the possible downsides of determinism, which might include making algorithms (i) more complicated, unnatural or special purpose and/or (ii) slower or less scalable.</p><p>In this paper we study the effectiveness of this strong form of determinism through a broad set of benchmark problems. Our main contribution is to demonstrate that for this wide body of problems, there exist efficient internally deterministic algorithms, and moreover that these algorithms are natural to reason about and not complicated to code. We leverage an approach to determinism suggested by <ref type="bibr" target="#b41">Steele (1990)</ref>, which is to use nested parallelism with commutative operations. Our algorithms apply several diverse programming paradigms that fit within the model including (i) a strict functional style (no shared state among concurrent operations), (ii) an approach we refer to as deterministic reservations, and (iii) the use of commutative, linearizable operations on data structures. We describe algorithms for the benchmark problems that use these deterministic approaches and present performance results on a 32core machine. Perhaps surprisingly, for all problems, our internally deterministic algorithms achieve good speedup and good performance even relative to prior nondeterministic solutions.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>One of the key challenges of parallel programming is dealing with nondeterminism. For many computational problems, there is no inherent nondeterminism in the problem statement, and indeed a serial program would be deterministic-the nondeterminism arises solely due to the parallel program and/or due to the parallel machine and its runtime environment. The challenges of nondeterminism have been recognized and studied for decades <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b41">42</ref>]. Steele's 1990 paper, for example, seeks "to prevent the behavior of the program from depending on any accidents of execution order that can arise from the indeterminacy" of asynchronous programs <ref type="bibr" target="#b41">[42]</ref>. More recently, there has been a surge of advocacy for and research in determinism, seeking to remove sources of nondeterminism via specially-designed hardware mechanisms <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b27">28]</ref>, runtime systems and compilers <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b44">45]</ref>, operating systems <ref type="bibr" target="#b3">[4]</ref>, and programming languages/frameworks <ref type="bibr" target="#b10">[11]</ref>.</p><p>While there seems to be a growing consensus that determinism is important, there is disagreement as to what degree of determinism is desired (worth paying for). Popular options include:</p><p>• Data-race free <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b21">22]</ref>, which eliminate a particularly problematic type of nondeterminism: the data race. Synchronization constructs such as locks or atomic transactions protect ordinary accesses to shared data, but nondeterminism among such constructs (e.g., the order of lock acquires) can lead to considerable nondeterminism in the execution. • Determinate (or external determinism), which requires that the program always produces the same output when run on the same input. Program executions for a given input may vary widely, as long as the program "converges" to the same output each time. • Internal determinism, in which key aspects of intermediate steps of the program are also deterministic, as discussed in this paper. • Functional determinism, where the absence of side-effects in purely functional languages make all components independent and safe to run in parallel. • Synchronous parallelism, where parallelism proceeds in lock step (e.g., SIMD-style) and each step has a deterministic outcome.</p><p>There are trade-offs among these options, with stronger forms of determinism often viewed as better for reasoning and debugging but worse for performance and perhaps programmability. Making the proper choice for an application requires understanding what the trade-offs are. In particular, is there a "sweet spot" for determinism, which provides a particularly useful combination of debuggability, performance, and programmability? In this paper, we advocate a particular form of internal determinism as providing such a sweet spot for a class of nestedparallel (i.e., nested fork-join) computations in which there is no inherent nondeterminism in the problem statement. An execution of a nested-parallel program defines a dependence DAG (directed acyclic graph) that represents every operation executed by the computation (the nodes) along with the control dependencies among them (the edges). These dependencies represent ordering within sequential code sequences, dependencies from a fork operation to its children, and dependencies from the end of such children to the join point of the forking parent. We refer to this DAG when annotated with the operations performed at each node (including arguments and return values, if any) as the trace. Informally, a program/algorithm is internally deterministic if for any input there is a unique trace. This definition depends on the level of abstraction of the operations in the trace. At the most primitive level the operations could represent individual machine instructions, but more generally, and as used in this paper, it is any abstraction level at which the implementation is hidden from the programmer. We note that internal determinism does not imply a fixed schedule since any schedule that is consistent with the DAG is valid.</p><p>Internal determinism has many benefits. In addition to leading to external determinism <ref type="bibr" target="#b36">[37]</ref> it implies a sequential semantics-i.e., considering any sequential traversal of the dependence DAG is sufficient for analyzing the correctness of the code. This in turn leads to many advantages including ease of reasoning about the code, ease of verifying correctness, ease of debugging, ease of defining invariants, ease of defining good coverage for testing, and ease of formally, informally and experimentally reasoning about performance <ref type="bibr">[3-5, 11, 19, 20, 28, 36, 45]</ref>. Two primary concerns for internal determinism, however, are that it may restrict programmers to a style that (i) is complicated to program, unnatural, or too specialpurpose and (ii) leads to slower, less scalable programs than less restrictive forms of determinism. Indeed, prior work advocating less restrictive forms of determinism has cited these concerns, particularly the latter concern <ref type="bibr" target="#b24">[25]</ref>.</p><p>This paper seeks to address these two concerns via a study of a set of benchmark problems. The problems are selected to cover a reasonably broad set of applications including problems involving sorting, graphs, geometry, graphics and string processing. Our main contribution is to demonstrate that for this wide body of problems, there exist fast and scalable internally deterministic algorithms, and moreover that these algorithms are natural to reason about and not complicated to code.</p><p>Our approach for implementing internal determinism for these benchmarks is to use nested parallel programs in which concurrent operations on shared state are required to commute <ref type="bibr" target="#b41">[42,</ref><ref type="bibr" target="#b43">44]</ref> in their semantics and be linearizable <ref type="bibr" target="#b26">[27]</ref> in their implementation. Many of the algorithms we implement use standard algorithmic techniques based on nested data parallelism where the only shared state across concurrent operations is read-only (e.g., divide-and-conquer, map, reduce, and scan) <ref type="bibr" target="#b5">[6]</ref>. However, a key aspect to several of our algorithms is the use of non-trivial commutative operations on shared state. The notion of commutativity has a long history, dating back at least to its use in analyzing when database transactions can safely overlap in time <ref type="bibr" target="#b43">[44]</ref>. A seminal paper by Steele <ref type="bibr" target="#b41">[42]</ref> discusses commutativity in the context of deterministic nestedparallel programs, showing that when applied to reads and writes on memory locations, commutativity of concurrent operations is sufficient to guarantee determinism.</p><p>Although there has been significant work on commutativity, there has been little work on the efficacy or efficiency of using nontrivial commutativity in the design of deterministic parallel algorithms. Much of the prior work on commutativity focuses on enforcing commutativity assuming the program was already written within the paradigm (e.g., using type systems <ref type="bibr" target="#b11">[12]</ref>), automatically parallelizing sequential programs based on the commutativity of operations <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b42">43]</ref>, or using commutativity to relax the con-straints in transactional systems <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b29">30]</ref>, an approach that does not guarantee determinism. In contrast, this paper identifies useful applications of non-trivial commutativity that can be used in the design of internally deterministic algorithms. We describe, for example, an approach we refer to as deterministic reservations for parallelizing certain greedy algorithms. In the approach the user implements a loop with potential loop carried dependencies by splitting each iteration into reserve and commit phases. The loop is then processed in rounds in which each round takes a prefix of the unprocessed iterates applying the reserve phase in parallel and then the commit phase in parallel. Some iterates can fail during the commit due to conflicts with earlier iterates and need to be retried in the next round, but as long as the operations commute within the reserve and commit phases and the prefix size is selected deterministically, the computation is internally deterministic (the same iterates always fail).</p><p>We describe algorithms for the benchmark problems using these approaches and present performance results for our Cilk++ <ref type="bibr" target="#b30">[31]</ref> implementations on a 32-core machine. Perhaps surprisingly, for all problems, our internally deterministic algorithms achieve good speedup and good performance even relative to prior nondeterministic and externally deterministic solutions, implying that the performance penalty of internal determinism is quite low. We achieve speedups of up to 31.6 on 32 cores with 2-way hyperthreading (for sorting). Almost all our speedups are above <ref type="bibr">16.</ref> Compared to what we believe are quite good sequential implementations we range from being slightly faster on one core (sorting) to about a factor of 2 slower (spanning forest). All of our algorithms are quite concise (20-500 lines of code), and we believe they are "natural" to reason about (understandable, not complicated, not special purpose). The paper presents code for two of the algorithms as illustrative examples; code for all of the algorithms (as well as complete descriptions of the benchmarks) can be found at www.cs.cmu.edu/~pbbs. We believe that this combination of performance and understandability provides significant evidence that internal determinism is a sweet spot for a broad range of computational problems.</p><p>The paper is organized as follows. Section 2 defines key terms and our programming model. Section 3 presents useful commutative building blocks. Section 4 describes the benchmark problems studied. Section 5 presents our approaches and algorithms. Our experimental study is in Section 6, and conclusions in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Programming Model</head><p>This paper focuses on achieving internally deterministic behavior in "nested-parallel" programs through "commutative" and "linearizable" operations. Each of these terms limits the programs permitted by the programming model, but as Section 5 exhibits, the model remains expressive. This section defines each of these terms.</p><p>Nested parallelism. Nested-parallel computations achieve parallelism through the nested instantiation of fork-join constructs, such as parallel loops, parallel map, parbegin/parend, parallel regions, and spawn/sync. More formally, nested parallel computations can be defined inductively in terms of the composition of sequential and parallel components. At the base case a strand is a sequential computation. A task is then a sequential composition of strands and parallel blocks, where a parallel block is a parallel composition of tasks starting with a fork and ending with a join. Figure <ref type="figure">1</ref> shows an example of a nested-parallel program using a syntax similar to Dijkstra's parbegin <ref type="bibr" target="#b20">[21]</ref>.</p><p>A nested parallel computation can be modeled (a posteriori) as a series-parallel control-flow DAG over the operations of the computation: the tasks in a parallel block are composed in parallel, and the operations within a strand as well as the strands and parallel blocks of a task are composed in series in the order they are 1. x := 0 2. in parallel do 3.</p><p>{ r3 := AtomicAdd(x, 1) } 4.</p><p>{ r4 := AtomicAdd(x, 10) 5.</p><p>in parallel do 6.</p><p>{ r6 := AtomicAdd(x, 100) } 7.</p><p>{ r7 := AtomicAdd(x, 1000) } } 8. return x Figure <ref type="figure">1</ref>. A sample nested-parallel program. Here, the in parallel keyword means that the following two {. . .} blocks of code may execute in parallel. AtomicAdd(x, v) atomically updates x to x := x + v and returns the new value of x.</p><p>executed. We assume all operations take a state and return a value and a new state (any arguments are part of the operation). Nodes in the control-flow DAG are labeled by their associated operation (including arguments, but not return values or states). We say that an operation (node) u precedes v if there is a directed path from u to v in the DAG. If there is no directed path in either direction between u and v, then u and v are logically parallel, meaning that they may be executed in parallel.</p><p>The support of nested parallelism dates back at least to Dijkstra's parbegin-parend construct. Many parallel languages support nested parallelism including NESL, Cilk, the Java fork-join framework, OpenMP, the TBB, and TPL. Although not appropriate for certain types of parallelism, e.g., pipeline parallelism, nested parallelism has many theoretical and practical advantages over more unstructured forms of parallelism, including simple schedulers for dynamically allocating tasks to cores, compositional analysis of work and span, and good space and cache behavior (e.g., <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b9">10]</ref>).</p><p>Languages with nested parallelism rely on runtime schedulers to assign subcomputations to cores. Whereas these runtime schedulers are inherently nondeterministic to handle load balancing and changes in available resources, our goal is to guarantee that the program nevertheless behaves deterministically.</p><p>Internal determinism. We adopt a strong notion of determinism here, often called internal determinism <ref type="bibr" target="#b34">[35]</ref>. Not only must the output of the program be deterministic, but all intermediate values returned from operations must also be deterministic. We note that this does not preclude the use of pseudorandom numbers, where one can use, for example, the approach of Leiserson et al. <ref type="bibr" target="#b32">[33]</ref> to generate deterministic pseudorandom numbers in parallel from a single seed, which can be part of the input.</p><p>This paper defines determinism with respect to abstract operations and abstract state, not with respect to machine instructions and memory state. Nevertheless, the definition supplied here is general and applies to both cases. The difference hinges on the notion of "equivalence." Given a definition of equivalent operations, states, and values, we define internal determinism as follows.</p><p>For a (completed) computation its trace is the final state along with the control-flow DAG on which operation nodes are (further) annotated with the values returned (if any). Figure <ref type="figure" target="#fig_0">2</ref>   <ref type="figure">1</ref>. The diamonds, squares, and circles denote forks, joins, and data operations, respectively. Nodes are numbered by line number, as a short hand for operations such as AtomicAdd(x, 1). The left trace corresponds to the interleaving/schedule 1, 2, 3, 4, 5, 6, 7, 8, whereas the right trace corresponds to 1, 2, 4, 5, 7, 6, 3, 8. Because the intermediate return values differ, the program is not internally deterministic. It is, however, externally deterministic as the output is always the same. If AtomicAdd did not return a value, however, then the program would be internally deterministic.</p><p>Note that since the parallelism is dynamic, a nondeterministic program may result in dramatically different DAGs. Because all decisions in a computation are based only on the result of operations performed, however, if operations return equivalent results despite different schedulings, then the structure of the DAG is guaranteed to remain the same.</p><p>For primitive types like integers, it is clear what equivalence means. When working with objects and dynamic memory allocation, however, a formal definition of equivalent objects and states becomes more complicated, and not within the scope of this paper. Informally, when we say that states or values are equivalent, we mean semantically equivalent, i.e., that no sequence of valid operations can distinguish between them (see, e.g., <ref type="bibr" target="#b25">[26]</ref>).</p><p>Commutativity. Internally deterministic programs are a subset of parallel programs, and thus programming methodologies that yield internal determinism restrict a program's behaviors. The methodology we adopt in this paper is to require all logically parallel accesses of shared objects to use operations that commute. The fact that this restriction yields internally deterministic programs is observed in many works, see for example <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b41">42]</ref> among others.</p><p>We adopt Steele's notation and definition of commutativity <ref type="bibr" target="#b41">[42]</ref>. We use f (S) → S ⇒ v to denote that when the operation f is executed (without any concurrent operations) starting from system (object) state S, the system transitions to state S and f returns the value v. To simplify notation, operations not returning values are viewed as returning v = ∅. Definition 2. Two operations f and g commute with respect to state S if the order in which they are performed does not matter. That is, if</p><formula xml:id="formula_0">f (S) → S f ⇒ v f g(S f ) → S f g ⇒ vg and g(S) → S g ⇒ v g f (S g ) → S gf ⇒ v f</formula><p>then f and g commute with respect to S if and only if S f g = S gf , v f = v f , and vg = v g , where "=" here denotes equivalence. (Note that there is no requirement that S f = S g .) Moreover, we say that two operations commute if they commute with respect to all valid states S. It is possible to relax this definition (e.g., <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b43">44]</ref>), but we found this definition sufficient for our purposes.</p><p>Linearizability. Commutativity is not a sufficient condition for deterministic behavior, as commutativity alone does not guarantee that the implementation of the operations work correctly when their instructions are interleaved in time. To guarantee safety of concurrent execution of operations we use the standard definition of linearizability <ref type="bibr" target="#b26">[27]</ref>, which enforces atomicity of the operations. In our setting, operations are concurrent if and only if they are logically parallel. Thus, linearizability guarantees that there is a total order (or history), H, of the annotated operations in a trace T such that H is a legal sequential execution of those operations, starting from the initial state. That is, (i) H is a valid scheduling of T 's controlflow DAG, and (ii) each annotated operation in T remains legal (including its return value) when executed atomically in the order of H. We note that linearizability is a property of the implementation and not the semantics of the operation (e.g., two insertions into a dictionary might semantically commute, but an implementation might fail when interleaved). One way to guarantee linearizability is to use a lock around all commuting operations, but this is inefficient. In this paper we use only non-blocking techniques to achieve linearizability among commuting operations. We however do not guarantee that all commuting operations are linearizable, just that the logically parallel ones are.</p><p>Summary. The model we will use for internally deterministic behavior is summarized by the following theorem.</p><p>Theorem 1. Let P be a nested-parallel program. If for all inputs, all logically parallel operations commute and are linearizable, then P is internally deterministic.</p><p>Proof. (sketch) Consider any fixed input I and any fixed (completed) execution of P with input I. Let G (T ) be the resulting control-flow DAG (trace, respectively), and let H be its linearizability history. We will show that T is equivalent to a canonical trace T * obtained by executing P with input I using only a single core. Let G * and H * be the control-flow DAG and linearizability history for T * . We show by induction on the length of H * that (i) G and G * are equivalent and (ii) H permuted to match the order in H * of equivalent nodes is also a linearizability history for T , implying equivalent return values. We construct such a permutation, H , inductively, with H = H initially. Assume inductively that (i) the subgraph of G * corresponding to the nodes in H * [1..i] has an equivalent subgraph in G, and (ii) H is a linearizability history for T such that H [1..i] and H * [1..i] are equivalent ([j..k] denotes subsequence). Consider i + 1, and let σ * be the i + 1'st annotated node in H * . It follows inductively that there is a node σ in T with equivalent parent(s) and an equivalent operation, say the jth node in H . If j = i + 1, we are done, so assume j &gt; i + 1. None of the nodes in H [i + 1..j -1] can precede or be preceded by σ, so σ must commute with each such node. Thus, σ can be pairwise swapped up to position i + 1 in H while preserving a linearizability history, establishing both inductive invariants. The argument is readily extended to show the equivalence of the final states by augmenting each execution with operations that read the final state. The theorem follows.</p><p>Our approach is similar to previous models for enforcing deterministic behavior <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b41">42]</ref> except that in Steele <ref type="bibr" target="#b41">[42]</ref> commutativity is defined in terms of memory operations and memory state, and in Cheng et al. <ref type="bibr" target="#b14">[15]</ref> commutativity is defined with respect to critical sections and memory state. Here we define commutativity in terms of linearizable abstract operations and abstract state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Commutative Building Blocks</head><p>Achieving deterministic programs through commutativity requires some level of (object or operation) abstraction. Relying solely on memory operations is doomed to fail for general purpose programming. For example requiring a fixed memory location for objects allocated in the heap would severely complicate programs and/or inhibit parallelism, possibly requiring all data to be preallocated. Instead, this section defines some useful higher-level operations that we use as commutative operations in many of our algorithms. They are all defined over abstract data types supporting a fixed set of operations. We also describe non-blocking linearizable implementations of each operation. These implementations do not commute at the level of single memory instructions and hence the abstraction is important.</p><p>Priority write. Our most basic data type is a memory cell that holds a value and supports a priority write and a read. The priority write on a cell x, denoted by x.pwrite(v) updates x to be the maximum of the old value of x and a new value v. It does not return any value. x.read() is just a standard read of the cell x returning its value. We often use priority write to select a deterministic winner among parallel choices, e.g., claiming a next-step neighbor in breadth first search (Section 5.3).</p><p>Any two priority writes x.pwrite(v1) and x.pwrite(v2) commute, in accordance with Definition 2, because (i) there are no return values, and (ii) the final value of x is the maximum among its original value, v1, and v2, regardless of which order these operations execute. A priority write and a read do not commute since the priority write can change the value at the location. We implement non-blocking and linearizable priority writes using a compare and swap. With this implementation the machine primitives themselves do not commute. Priority reserve. In our "deterministic reservation" approach described later in Section 5, multiple program loop iterates attempt to reserve the same object in parallel, and later the winner operates on the reserved object. For deterministic reservations we use a data type that supports three operations, a priority reserve (x.reserve(p)), a check (x.check(p)), and a check-and-release (x.checkR(p)), where p is a priority. As with a priority write, a higher priority value overwrites a lower priority and hence the highest priority will "reserve" the location. The one difference is that we require a unique priority tag ⊥ to denote when the location is currently unreserved. The priority ⊥ has the lowest priority, and it is invalid to make a pwrite call with p = ⊥. As with pwrite, any number of reserves commute, and we implement a linearizable non-blocking version using compare and swap.</p><p>The x.checkR(p) call requires p = ⊥. If the current value at location x has priority p, then the reservation is released (i.e., the value ⊥ is written to x), and TRUE is returned to indicate that p was the highest priority reservation on x. If the current priority is not p, then the state does not change and FALSE is returned. Operations x.checkR(p1) and x.checkR(p2) commute if and only if p1 = p2.</p><p>A check is the same as a checkR without the release and commutes in the same way. A priority reserve and either form of check do not commute.</p><p>Our algorithms ensure that for any given location, (i) priority reserves are not called logically in parallel with either form of check, and (ii) all logically parallel operations use distinct priorities. Thus, the commutativity and resulting internal determinism extend to those algorithms. Dynamic map. The purpose of our dynamic map is to incrementally insert keyed elements and, once finished inserting, to return an array containing a pseudorandom permutation of these elements, omitting duplicates. A dynamic map supports two operations: M.insert(x), which inserts keyed element x into the map M without returning any value, and M.elements(), which returns an arbitrary, but deterministic, permutation of all the elements in the map M . The map removes duplicate keys on insert: if elements y and x have the same key and y is already in the map when M.insert(x) is called, one of the elements (chosen deterministically based on a user specified priority) is discarded.</p><p>We implement our dynamic map using a history-independent hash table <ref type="bibr" target="#b6">[7]</ref>. In a history-independent data structure the final layout does not depend on the operation order. In particular, the key of each element is treated as a priority, and the hash table is equivalent to one in which all insertions were performed sequentially in a nonincreasing priority order using linear probing. Elements are inserted by first hashing the key and going to the corresponding hash location, then scanning consecutive hash-table slots until finding either an empty slot or a slot containing and equal-or lower-priority element. If empty, the new element is inserted and the operation completes. If the slot is occupied by an equal-priority element, either the new or old element is discarded (deterministically based on priority) and the operation completes. If the slot is occupied by a lower-priority element, the higher-priority element is put in that slot (using compare and swaps to provide linearizability), and the lower-priority element is evicted. The linear probe continues to find a slot for the lower-priority element. An elements call simply filters the underlying array (using the parallel filter operation discussed in Section 5), finding all the nonempty slots and placing them in order in a return array. Our implementation is non-blocking requiring no locks.</p><p>To see that two inserts commute, it is easy to show inductively that after each insert, the hash table is identical to one in which those elements present were inserted in priority order. This property implies that the ordering between two insertions does not matter. The M.insert(x) operation does not commute with M.elements() operation since for some states of S, x is not in M and will affect the result of elements.</p><p>Disjoint sets. Our spanning-forest algorithms rely on a structure for maintaining a collection of disjoint sets corresponding to connected components. Each set is associated with a unique element acting as the identifier for the set. A disjoint-set data type supports two operations: a find and a link. For an instance F , the F.find(x) operation returns the set identifier for the set containing x. The F.link(S, x) operation requires that S be a set identifier and the set containing x be disjoint from the set S. It logically unions the set S with the set containing x such that the identifier for the resulting unioned set is the identifier of the set containing x. Here, x and S denote references or pointers to elements in the sets.</p><p>We implement an instance F of the disjoint set data type as a collection of trees with parent pointers, where the root of each tree acts as a unique identifier for the set <ref type="bibr" target="#b16">[17]</ref>. A F.find(x) operation simply follows parent pointers up the tree and returns the root. It may also perform path compression <ref type="bibr" target="#b16">[17]</ref>, which points nodes along the query-to-root path directly to the root, thereby accelerating future queries. A link(S, x) operation is implemented by pointing S to the root-node of the set containing x.</p><p>Two find operations commute with each other as they cause no semantic modifications-i.e. any changes to the pointer structure caused by path compression cannot be discerned by future operations on F . Two link operations commute with each other as long as they do not share the same first argument. That is to say, F.link(S1, x1) and F.link(S2, x2) commute as long as S1 = S2; having x1 and x2 be equal or from the same set is al-lowed, as is having x1 in set S2 or x2 in set S1. The link(S1, x1) and find(x2) only commute if x1 = x2.</p><p>We now consider linearizability. Even with path compression, find operations are linearizable (and non-blocking) since there is only one possible update to each pointer (the a priori root of the tree). This requires no compare and swap or any other special memory operations. Logically parallel link operations with distinct first arguments, and no cycles among the linked sets, are also linearizable and non-blocking with no special memory operations since they only require updating a pointer which is not shared by any other logically parallel operation. In our implementation we do not guarantee that finds and links are linearizable. Hence, in our algorithms that use disjoint sets, finds are never logically parallel with links: they alternate phases of only finds and only links.</p><p>We note that we use an asymmetric link operation instead of the standard symmetric union. This is because union does not commute in our definition which requires two operations to commute for all start states. In a more relaxed definition of commutativity, union can be made to commute <ref type="bibr" target="#b29">[30]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Benchmark Problems</head><p>For testing the utility of nested-parallel internally deterministic algorithms we use a set of problem-based benchmarks. These benchmarks are defined in terms of the problem they solve instead of any particular code or algorithm to solve the problem. We feel that this is important for our purposes since it might be that very different algorithmic approaches are suited for a deterministic algorithm vs. a nondeterministic algorithm. The benchmark suite is selected to cover a reasonable collection of fundamental problems. The focus, however, is on problems involving unstructured data since there is already very good coverage for such benchmarks for linear algebra and typically deterministic algorithms are much simpler for these problems. The problems are selected to be simple enough to allow reasonably concise implementations, but interesting enough to be non-trivial. For all problems we use a variety of different inputs and avoid just random inputs. Here we define the problems. Comparison Sort: For a sequence S and comparison function &lt; defining a total order on elements of S, return the values of S sorted by &lt;. Sorting is a fundamental problem and a subroutine in many algorithms. The benchmark code must work with any element type and comparison function. Remove Duplicates: For a sequence of elements of type t, a hash function h : t → int, and comparison function f , return a sequence in which any duplicates (equal valued elements) are removed. This is an example of a dictionary-style operation that can use hashing. Breadth First Search: For a connected undirected graph G, and source vertex s, return a breadth-first-search (BFS) tree, rooted at s, of the vertices in G. Spanning Forest: For an undirected graph</p><formula xml:id="formula_1">G = (V, E), return edges F ⊂ E, such that for each connected component Ci = (Vi, Ei) in G, a spanning tree Ti (|Ti| = |Vi|-1) of Ci is contained in F. Furthermore, |F | = C i ⊂G (|Vi| -1).</formula><p>Minimum Spanning Forest: For an undirected graph G = (V, E) with weights w : E → , return a spanning forest of minimum total weight. Maximal Independent Set: For a connected undirected graph G = (V, E), return U ⊂ V such that no vertices in U are neighbors and all vertices in V \ U have a neighbor in U . This is an important subroutine in many parallel algorithms because it can be used to identify a set of vertices that can be operated on deterministically in parallel (due to disjoint edge sets). Triangle Ray Intersect: For a set of triangles T and rays R in three dimensions, return the first triangle each ray intersects, if any. This is a common operation in graphics and is the most widely used special case of ray casting. Suffix Array: For a string S of n characters return an equal length integer array A that specifies the sorted order of the suffixes of S. This is an important operation used in many applications in computational biology, compression, and string processing.</p><p>Delaunay Triangulation: For a set of n points in two dimensions, return a triangulation such that no point is contained in the circumcircle of any triangle in the triangulation <ref type="bibr" target="#b17">[18]</ref>. Delaunay triangulations are likely the most widely used partitioning of space in two and three dimensions and used in many CAD applications. Delaunay Refine: For a Delaunay Triangulation on a set of n points, and an angle α, add new points such that in the resulting Delaunay Triangulation, no triangle has an angle less than α. N-body: For a set of n point sources in three dimensions, each point p with coordinate vector p and a mass mp, return the force induced on each one by the others based on the Coulomb force Fp = q∈P,q =p mqmp( q -p)/|| q -p|| 3 . The N-body problem is important in protein folding, astrophysics, and slight generalizations are now often used for solving PDEs. K-Nearest Neighbors: For n points in two or three dimensions, and a parameter k, return for each point its k nearest neighbors (euclidean distance) among all the other points. The problem is fundamental in data analysis and computational geometry.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Internally Deterministic Parallel Algorithms</head><p>In this section we describe the approaches we used when designing our internally deterministic parallel algorithms and outline the resulting algorithms for each of the benchmarks. Many of the approaches used are standard, but we introduce what we believe to be a new approach for greedy algorithms based on deterministic reservations. This approach plays a key role in our implementation of five of the problems. We also make use of our commuting and linearizable implementations of various operations for five problems.</p><p>Table <ref type="table" target="#tab_0">1</ref> summarizes what approaches/techniques are used in which of our algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Nested Data Parallelism and Collection Operations</head><p>The most common technique throughout the benchmark implementations is the use of nested data parallelism. This technique is ap-plied in a reasonably standard way, particularly in the use of forkjoin and parallel loops (with arbitrary nesting) in conjunction with parallel operations on collections. For the operations on collections we developed our own library of operations on sequences. We make heavy use of divide and conquer. In the divide-and-conquer algorithms we almost always use parallelism within the divide step (to partition the input data), and/or the merge step (to join the results), typically using the collection operations in our sequence library. The three collection operations reduce, scan, and filter are used throughout our algorithms. As is standard, reduce takes a sequence S and a binary associative function f and returns the "sum" of elements with respect to f , while scan (prefix sum) takes a sequence S and a function f and returns a sequence of equal length with each element containing the sum with respect to f of all preceding elements in S. Our implementations of reduce and scan are deterministic even if f is not associative-e.g., with floating point addition. The filter operation takes a sequence S and a function f returning a boolean and returns a new sequence containing only the elements e for which f (e) is true, in the same order as in S. Filter uses a scan in its implementation.</p><p>Reduce is used to calculate various "sums": e.g., to calculate the bounding box (maximum and minimum in each coordinate) of a set of points. Filter is used in most of our algorithms. In the divide-andconquer algorithms it is typically used to divide the input into parts based on some condition. In the other algorithms it is used to filter out elements that have completed or do not need to be considered. It plays a key role in deterministic reservations. Scan is used in a variety of ways. In the sorting algorithm it is used to determine offsets for the sample sort buckets, in the suffix array algorithm it is used to give distinct elements unique labels, and in the breadth first search algorithm it is used to determine the positions in the output array to place distinct neighbor arrays.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Deterministic Reservations</head><p>Several of our algorithms (maximal independent set, spanning forest, minimum spanning forest, Delaunay triangulation, and Delaunay refine) are based on a greedy sequential algorithm that processes elements (e.g., vertices) in linear order. These can be implemented using speculative execution on a sequential loop that iterates over the elements in the greedy order.</p><p>Various studies have suggested both compiler <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b39">40]</ref> and runtime techniques <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b42">43]</ref> to automate the process of simulating in parallel the sequential execution of such a loop. These approaches rely on recognizing at compile and/or run time when operations in the loop iterates commute and allowing parallel execution when they do. Often the programmer can specify what operations commute. We are reasonably sure that the compiler-only techniques would not work for our benchmark problems because the conflicts are highly data dependent and any conservative estimates allowing for all possible conflicts would serialize the loop. The runtime techniques typically rely on approaches similar to software transactional memory: the implementation executes the iterations in parallel or out of order but only commits any updates after determining that there are no conflicts with earlier iterations. As with software transactions, the software approach is expensive, especially if required to maintain strict sequential order. In fact in practice the suggested approaches typically relax the total order constraint by requiring only a partial order <ref type="bibr" target="#b38">[39]</ref>, potentially leading to nondeterminism. A second problem with the software approach is that it makes it very hard for the algorithm designer to analyze efficiency-it is possible that subtle differences in the under-thehood conflict resolution could radically change which iterates can run in parallel.</p><p>We present an approach, called deterministic reservations, that gives more control to the algorithm designer and fits strictly within In each round, a prefix of some specified size is selected. All of these prefix iterates perform the reserve component. Then they all perform the commit component. The dark regions in the top array represent iterates that successfully commit. All uncommitted iterates (shown in white) are packed towards the right, as shown in the bottom array. The next round then begins by selecting a prefix of the same size on the bottom array. the nested-parallel framework (needing neither special compiler nor runtime support). In this approach the algorithm designer controls exactly on what data the conflicts occur and these conflicts are deterministic for a given input. The generic greedy algorithm for deterministic reservations works as follows, illustrated in Figure <ref type="figure" target="#fig_1">3</ref>. It is given a sequence of iterates (e.g., the integers from 0 to n -1) and proceeds in rounds until no iterates remain. Each round takes any prefix of the remaining unprocessed iterates, and consists of two phases that are each parallel loops over the prefix, followed by some bookkeeping to update the sequence of remaining iterates. The first phase executes a reserve component on each iterate, using a priority reserve (reserve) with the iterate priority, in order to reserve access to data that might interfere (involve non-commuting or non-linearizable operations) with other iterates. The second phase executes a commit component on each iterate, using a check to see if the reservations succeeded, and if the required reservations succeed then the iterate is processed, otherwise it is not. Typically updates to shared state (at the abstraction level available to the programmer) are only made if successful. After running the commit phase, the processed iterates are removed. In our implementation the unprocessed iterates are kept in a contiguous array ordered by their priority. Selecting a prefix can therefore just use a prefix of the array, and removing processed iterates can be implemented with a filter over the boolean results of the second phase.</p><p>The specifics of the reserve and commit components depend on the application. The work done by the iterate can be split across the two components. We have found, however, that in the unstructured problems in the benchmarks just determining what data might interfere involves most of the work. Therefore the majority of the work ends up in the reserve component. In most cases all reservations are required to succeed, but we have encountered cases in which only a subset need to succeed (e.g., our minimum spanning-forest code reserves both endpoints of an edge but only requires that one succeeds).</p><p>We note that the generic approach can select any prefix size including a single iterate or all the iterates. There is a trade off, however between the two extremes. If too many iterates are selected for the prefix, then many iterates can fail. This not only requires repeated effort for processing those iterates, but can also cause high-contention on the reservation slots. On the other hand if too few iterates are selected then there might be insufficient parallelism. Clearly the amount of contention depends on the specific algorithms and likely also on the input data.</p><p>As long as the prefix size is selected deterministically and all operations commute and are linearizable within the reserve phase and separately within the commit phase, a program will be internally deterministic. This means the algorithm designer only needs to analyze commutativity/linearizability within each phase. In our code we have implemented a function speculative for that takes four arguments: a structure that implements the reserve and commit components (both taking an index as an argument), a start index, an end index, and a prefix size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Algorithms</head><p>We now describe each of the algorithms we use to implement the benchmarks discussed in Section 4. In all cases we considered a variety of algorithms and selected the one we felt would perform the best. In many cases we arrived at the algorithm discussed after trying different algorithms. In all cases the algorithms are either motivated by or directly use results of many years of research on parallel algorithm design by many researchers. Due to limitations of space we only very briefly describe any algorithms that mostly use previous ideas. Comparison Sort: We use a low-depth cache-efficient sample sort <ref type="bibr" target="#b8">[9]</ref>. The algorithm (1) partitions the input into √ n blocks, (2) recursively sorts each block, (3) selects a global sample of size √ n log n by sampling across the blocks, (4) sorts the sample, (5) buckets each of the blocks based on the sample, ( <ref type="formula">6</ref>) transposes the keys so keys from different blocks going to the same bucket are adjacent, and ( <ref type="formula">7</ref>) recursively sorts within the buckets. The transpose uses a cache-efficient block-transpose routine. When the input is small enough, quicksort is used. The algorithm is purely nested parallel. There is nesting of the parallelism (divide-and-conquer) in the overall structure, in the merge used for bucketing blocks, in the transpose, and in the quicksort. Remove Duplicates: We use a parallel loop to concurrently insert the elements into the dynamic map described in section 3. This data structure already removes all duplicates internally and returns the distinct elements with a call to elements (which internally uses a filter). The ordering returned by the routine is deterministic but does not correspond to the input ordering in any natural way and different hash functions will give different orderings. We set the hash table size to be twice the size of the input. Breadth First Search: We use a level-ordered traversal of the graph that guarantees the same BFS tree as the standard sequential queue-based algorithm <ref type="bibr" target="#b16">[17]</ref>. In level-order traversal each vertex u adds each of its unvisited neighbors v to the next frontier and makes u the parent of v in the BFS tree. In standard parallel implementations of BFS <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b38">39]</ref> each level is processed in parallel and nondeterminism arises because vertices at one level might share a vertex v at the next level. These vertices will attempt to add v to the next frontier concurrently. By using a compare-andswap or similar operation, it is easy to ensure that a vertex is only added once. However, which vertex adds v depends on the schedule, resulting in internal nondeterminism in the BFS code and external nondeterminism in the resulting BFS tree.</p><p>We avoid this problem by using a priority write. The vertices in the frontier are prioritized by their position in the array and we process each level in two rounds. In the first round each vertex in the frontier writes its priority to all neighbors that have not been visited in previous rounds. In the second round each vertex v in the frontier reads from each neighbor u the priority. If the priority of u is v (v is the highest priority neighbor in the frontier), then we make v the parent of u and add u to the next frontier. The neighbors are added to the next frontier in the priority order of the current frontier. This uses a scan to open enough space for each neighbor list, and maintains the same ordering on every frontier as the sequential queue-based algorithm maintains.  Spanning Forest: Sequentially a spanning forest can be generated by greedily processing the edges in an arbitrary order using a disjoint sets data structure. When an edge is processed if the two endpoints are in the same component (which can be checked with find) it is removed, otherwise the edge is added to the spanning forest and the components are joined (with union). This algorithm can be run in parallel using deterministic reservations prioritized by the edge ordering and will return the exact same spanning forest as the sequential algorithm. The idea is simply to reserve both endpoints of an edge and check that both reservations succeed in the commit component. Indeed this is how we implement Minimum Spanning Forest, after sorting the edges. However there is an optimization that can be made with spanning forests that involves only requiring one of the reservations to succeed. This increases the probability a commit will succeed and reduces the cost. This approach returns a different forest than the sequential version but is internally deterministic for a fixed schedule of prefix sizes.</p><formula xml:id="formula_2">: E(_E), R(_R), F(_F) {} bool reserve(int i) { u = F.find(E[i].u); v = F.find(E[i].v); if (u == v) return 0; if (u &gt; v) swap(u,v); R[v].reserve(i); return 1;} bool commit(int i) { if (R[v].check(i)) { F.link(v,</formula><p>The C++ code is given in Figure <ref type="figure" target="#fig_2">4</ref>. For an iterate i corresponding to the edge E[i] the reserve component does a find on each endpoint (as in the sequential algorithm) returning u and v (w.l.o.g., assume u ≤ v). If u = v, the edge is within a component and can be dropped returning 0 (false) <ref type="foot" target="#foot_0">1</ref> , otherwise the algorithm reserves v with the index i</p><formula xml:id="formula_3">(R[v].reserve(i)). The commit component for in- dex i performs a R[v].check(i) to see if its reservation succeeded.</formula><p>If it has, it links v to u and otherwise the commit fails. At the end of the algorithm the edges E[i] in the spanning tree can be identified as those where R[i] = ⊥. The only difference from the sequential algorithm is that after determining that an edge goes between components instead of doing the union immediately it reserves one of the two sides. It later comes back to check that the reservation succeeded and if so does the union (link).</p><p>We note that in a round the reservation guarantees that only one edge (the highest priority) will link a vertex v to another vertex. This is the condition required in Section 3 for commutativity of link. Also because the link and find are in different phases they are never logically parallel, as required. Finally we note that </p><formula xml:id="formula_4">{ int ngh = V[i].Neighbors[j]; if (ngh &lt; i) { if (Fl[ngh] == IN) { flag = OUT; return 1;} else if (Fl[ngh] == LIVE) flag = LIVE; } } return 1; } bool commit(int i) { return (Fl[i] = flag) != LIVE;} }; void MIS(FlType* Fl, vertex* V, int n, int psize)</formula><p>speculative_for(MISStep(Fl, V), 0, n, psize); } Figure <ref type="figure">5</ref>. C++ code for maximal independent set using deterministic reservations.</p><p>because we link higher to lower vertex numbers the algorithm will never create a cycle. In this algorithm our code sets psize, the size of the prefix, to be .02|E| and we have observed that on our test graphs less than 10% of the reservations fail.</p><p>Minimum Spanning Forest: We use a parallel variant of Kruskal's algorithm. The idea of Kruskal's algorithm is to sort the edges and then add them one-by-one using disjoint sets as in the spanning forest code. We can therefore use deterministic reservations prioritized by the sorted order to insert the edges. Unlike the spanning forest described above, however, we need to reserve both endpoints of an edge to guarantee the edges are inserted in "sequential" order. However, during the commit component we only need that one of the two endpoint succeeds because to commute link only requires that one of the two arguments is unique. If v succeeds, for example, then we can use link(v, u). Note this is still internally deterministic because which endpoints succeed is deterministic. In our code we also make a further optimization: We sort only the smallest k edges (k = min(|E|, 4|V |/3) in our experiments) and run MSF on those, so that the remaining edges can be filtered out avoiding the need to sort them all. The sequential algorithm to which we compare our code does the same optimization.</p><p>Maximal Independent Set: Sequentially the maximal independent set can easily be calculated using the greedy method: loop over the vertices in an arbitrary order and for each vertex if no neighbors belong in the set add it to the set. There is a particularly simple way to implement this with deterministic reservations without even requiring an explicit reserve. The C++ code based on our interface is given in Figure <ref type="figure">5</ref> and an example of how the algorithm proceeds is shown in Figure <ref type="figure">6</ref>. The struct MISStep defines the code for the reserve and commit components for each loop iteration. The array V stores for each of the n vertices its degree and a pointer to an array of neighbors. The array Fl keeps track of the status of each vertex-LIVE indicates it is still live, IN indicates it is done and in the set, and OUT indicates it is done and not in the set (a neighbor is in the set). The reserve phase for each iteration i loops over the neighbors of V[i] and sets a local variable flag as follows: Triangle Ray Intersect: We use a k-d tree with the surface area heuristic (SAH) <ref type="bibr" target="#b33">[34]</ref> to store the triangles. Our algorithm is similar to the parallel algorithm discussed in <ref type="bibr" target="#b15">[16]</ref> and makes use of divideand-conquer and heavy use of scan and filter. Suffix Array: We use a parallel variant of the algorithm of Karkkainen and Sanders <ref type="bibr" target="#b28">[29]</ref>. It uses sorting and merging as subroutines, which involves nesting, but otherwise only makes use of reduce, scan and filter. Delaunay Triangulation: We use a Boyer-Watson style incremental Delaunay algorithm with deterministic reservations. The points are used as the elements. To reduce contention, the prefix is always selected to be smaller than the current size of the mesh. The algorithm therefore starts out sequentially until enough points have been added. The reserve component of the code, for a point p, identifies all triangles that contain p in their circumcircle, often referred to as the hole for p. Adding p requires removing the hole and replacing it with other triangles. The reserve component therefore reserves all vertices around the exterior of the hole. The majority of the work required by a point p is in locating p in the mesh and then identifying the triangles in the hole. The commit component checks if all the reserved vertices of the mesh have succeeded, and if so, removes the hole and replaces it with triangles surrounding p and filling the hole. The reservations ensure that all modifications to the mesh commute since the triangles in the mesh only interact if they share a vertex. In fact, reserving the edges of the hole would be sufficient and reduce contention, but our mesh implementation has no data structures corresponding to edges on which to reserve. For efficiently locating a point p in the mesh we use the nearest neighbor structure described below.</p><formula xml:id="formula_5">flag =    OUT</formula><p>Delaunay Refine: This algorithm uses the same routines for inserting points as the Delaunay triangulation. However, it does not need a point location structure but instead needs a structure to store the bad triangles. We use dynamic map for this purpose. N-body: We use a parallel variant of the Callahan-Kosaraju algorithm <ref type="bibr" target="#b12">[13]</ref>. This is a variant of Greengard and Rothkin's wellknown FMM algorithm but allows more flexibility in the tree structure. The algorithm makes use of traditional nested parallelism with divide-and-conquer, as well as reduce and scan. K-Nearest Neighbors: We use a quad-and oct-tree built over all input points for 2d and 3d inputs, respectively. As with the k-d tree used in triangle-ray intersection, the tree is built using only divideand-conquer and nested parallelism. Once built, the tree is static and used only for queries of the points.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Experimental Results</head><p>We ran our experiments on a 32-core (with hyper-threading) Dell PowerEdge 910 with 4 × 2.26GHZ Intel 8-core X7560 Nehalem Processors, a 1066MHz bus, and 64GB of main memory. The parallel programs were compiled using the cilk++ compiler (build 8503) with the -O2 flag. The sequential programs were compiled using g++ 4.4.1 with the -O2 flag. This section reports on the results for the benchmarks, as summarized in Table <ref type="table">2</ref>. We discuss six of the benchmarks in some detail, relating the performance to other published results. For each benchmark and given core count, the reported time for each input is the median time over three trials. We give only average timings over all inputs for the remaining benchmarks due to limited space.</p><p>For Comparison Sort, we used a variety of inputs all of length 10 7 . This includes sequences of doubles in three distributions and two sequences of character strings. Both sequences of character strings are the same but in one the strings are allocated in order (i.e., adjacent strings are likely to be on the same cache line) and in the other they are randomly permuted. We compare our internally deterministic sample sort to three other sorts: the standard template library (STL) sort, the parallel STL sort <ref type="bibr" target="#b40">[41]</ref>, and a simple divide-and-conquer quicksort that makes parallel recursive calls but partitions the keys sequentially. The results are summarized in Figure <ref type="figure" target="#fig_4">7</ref>(a) and Table <ref type="table" target="#tab_3">3</ref>(a). Due to the cache-friendly nature of our algorithm, on average it is more efficient than any of the algorithms even on one core. However it is not quite as fast on the doubleprecision values since there the cache effects are less significant. As expected the quicksort with serial partitioning does not scale.</p><p>For Remove Duplicates, our inputs were all of length 10 7 . We use both sequences of integers drawn from three distributions and sequences of integers corresponding to character strings. As shown in Figure <ref type="figure" target="#fig_4">7</ref>(b) and Table <ref type="table" target="#tab_3">3</ref>(b), our parallel internally deterministic algorithm obtains good speedup (over 24x on 64 threads) and outperforms the serial version using 2 or more threads. On a single thread, it is only slightly slower than the serial version.</p><p>For Breadth First Search (BFS), and all of the graph algorithms, we use three types of graphs: random graphs, grid graphs, and rMat graphs <ref type="bibr" target="#b13">[14]</ref>. The rMat graphs have a power-law distribution of degrees. All edge counts are the number of undirected edgeswe actually store twice as many since we store the edge in each direction. We compare our internally deterministic BFS to a serial version and a nondeterministic version (ndBFS). The results are summarized in Figure <ref type="figure" target="#fig_4">7</ref>(c) and  <ref type="table">2</ref>. Weighted average of running times (seconds) over various inputs on a 32-core machine with hyper-threading (32h). A "*" indicates an internally nondeterministic implementation and a "**" indicates an externally (and hence internally) nondeterministic implementation. All other implementations are internally deterministic. † LS-PDFS does not generate the BFS tree, while our programs do. $ Galois-ST generates only a spanning tree, while our code generates the spanning forest. ‡ Galois-Refine does not include the time for computing the triangle neighbors and initial bad triangles at the beginning our code does (takes 10-15% of the overall time).</p><p>version is slightly faster than the deterministic version due to the fact that it avoids the second phase when processing each round.</p><p>We have also compared times to published results. We ran the parallel breadth-first search algorithm from <ref type="bibr" target="#b31">[32]</ref> on our graphs and our performance is very close to theirs (their algorithm is labeled LS-PBFS in our tables and figures). Our performance is 5 to 6 times faster than the times reported in <ref type="bibr" target="#b24">[25]</ref> (both for 1 thread and 32 threads), but their code is written in Java instead of C++ and is on a Sun Niagara T2 processor which has a clock speed of 1.6Ghz instead of 2.26Ghz so it is hard to compare.</p><p>For Minimum Spanning Forest (MSF), we compare our internally deterministic algorithm to an optimized version of Kruskal's serial algorithm (see Section 5). Our results are shown in Figure <ref type="bibr">7(d)</ref> and <ref type="bibr">Table 3(d)</ref>. Our code is about 1.7x slower on a single thread. We also compared our times to the parallel version of Boruvka's algorithm from the recent C++ release (2.1.0) of the Galois benchmark suite <ref type="bibr" target="#b37">[38]</ref> (labeled as Galois-Boruvka in our table) on our inputs. Their code did not terminate in a reasonable amount of time on the random and rMat graphs; for the 2D-grid graph, our code is much faster and achieves much better speedup than their algorithm.</p><p>For Maximum Independent Set (MIS), we compare our internally deterministic algorithm to the very simple and efficient serial algorithm and a nondeterministic version that uses locks (with compare-and-swap) before adding a vertex to the set. The results are summarized in Figure <ref type="figure" target="#fig_4">7</ref>(e) and Table <ref type="table" target="#tab_3">3</ref>(e). As the experiments show, for this problem the deterministic algorithm is actually faster than the nondeterministic one. This is presumably because the deterministic version can avoid the reservation as discussed in Section 5 and therefore has little overhead compared to the serial algorithm. On one thread the nondeterministic algorithm is about a factor of 1.6x slower than the serial algorithm. We view this as quite good given the simplicity of the serial code. We note that MIS is about 5-10x faster than BFS on the same size graph.</p><p>For Delaunay Triangulation, we use two point distributions: points distributed at random and points distributed with the Kuzmin distribution. The latter has a very large scale difference between the largest and smallest resulting triangles. We compare our internally deterministic algorithm to a quite optimized serial version. Our results are shown in Figure <ref type="figure" target="#fig_4">7</ref>(f) and Table <ref type="table" target="#tab_3">3</ref>(f). On one core it is a factor of about 1.4 slower, but it gets good speedup. We compared our code to the implementations in the Galois benchmark suite <ref type="bibr" target="#b37">[38]</ref> (labeled as Galois-Delaunay and Galois-Refine in our tables and figures), and our triangulation code is faster and achieves better speedup on the same machine. We note, however, that on the Delaunay refinement problem we achieve almost the same run time as the Galois benchmarks (after subtracting the time for computing the initial processing of triangles from our times, which is about 10-15% of the overall time, since this is not part of the timing in the Galois code). Since the time for the refinement code is dominated by triangle insertion and the code for triangulation is dominated by point location, it would appear that the reason for our improved performance is due to our point location, and triangle insertion performs about equally well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion</head><p>This paper has provided evidence that internally deterministic programs can remain efficient and indeed even rival the best nondeterministic approaches. In fact, in the case of MIS, using deterministic reservations revealed that some synchronization overheads could be removed, thereby improving performance.</p><p>Our approach uses nested parallelism with commuting and linearizable parallel operations. We have not addressed the issue of how to verify that operations commute or are linearizable, but the techniques we use are simple enough that it is quite easy to reason about the correctness. For example in deterministic reservations a user only needs to verify that the operations within the reserve component and separately within the commit component commute. It should also be feasible to adapt efficient techniques for runtime race detection <ref type="bibr" target="#b14">[15]</ref> to check for parallel non-commuting operations.</p><p>It would also be interesting to conduct an empirical study supporting the programmability and debuggability claims for internal determinism. We have provided evidence that the programs in this paper have short code descriptions, but we have not studied how natural these programs are to develop in the first place. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 .</head><label>2</label><figDesc>Figure2. Two possible traces for the program in Figure1. The diamonds, squares, and circles denote forks, joins, and data operations, respectively. Nodes are numbered by line number, as a short hand for operations such as AtomicAdd(x, 1). The left trace corresponds to the interleaving/schedule 1, 2, 3, 4, 5, 6, 7, 8, whereas the right trace corresponds to 1, 2, 4, 5, 7, 6, 3, 8. Because the intermediate return values differ, the program is not internally deterministic. It is, however, externally deterministic as the output is always the same. If AtomicAdd did not return a value, however, then the program would be internally deterministic.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. A generic example of deterministic reservations. Top and bottom depict the array of iterates during consecutive rounds.In each round, a prefix of some specified size is selected. All of these prefix iterates perform the reserve component. Then they all perform the commit component. The dark regions in the top array represent iterates that successfully commit. All uncommitted iterates (shown in white) are packed towards the right, as shown in the bottom array. The next round then begins by selecting a prefix of the same size on the bottom array.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. C++ code for spanning forest using deterministic reservations (with its operations reserve, check, and speculative for), where m = |E| and n = |V |.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>enum</head><label></label><figDesc>FlType {LIVE, IN, OUT}; struct MISStep { FlType flag; vertex *V; MISStep(char* _F, vertex* _V) : flag(_F), V(_V) {} bool reserve(int i) { int d = V[i].degree; flag = IN; for (int j = 0; j &lt; d; j++)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Log-log plots of running times on a 32-core machine (with hyper-threading). Our deterministic algorithms are shown in red.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Techniques used in our algorithms for each of the benchmarks. D&amp;C indicates divide-and-conquer; Reduce, Scan and Filter are standard collection operations; DR indicates deterministic reservations; and CL indicates the use of a non-trivial commutative and linearizable operation other than reservations: dynamic map (DM), disjoint sets (DS), or priority write (PW). sub indicates that it is not used directly, but inside a subroutine, e.g., inside a sort. See Section 5 for further details.</figDesc><table><row><cell>Problem</cell><cell cols="5">D&amp;C Reduce Scan Filter DR CL</cell></row><row><cell>Comparison Sort</cell><cell>yes</cell><cell></cell><cell>yes</cell><cell></cell></row><row><cell>Remove Duplicates</cell><cell></cell><cell></cell><cell></cell><cell>yes</cell><cell>DM</cell></row><row><cell>Breadth First Search</cell><cell></cell><cell></cell><cell>yes</cell><cell>yes</cell><cell>PW</cell></row><row><cell>Spanning Forest</cell><cell></cell><cell></cell><cell></cell><cell>yes</cell><cell>yes DS</cell></row><row><cell>Min Spanning Forest</cell><cell>sub</cell><cell></cell><cell></cell><cell>yes</cell><cell>yes DS</cell></row><row><cell>Max Independent Set</cell><cell></cell><cell>yes</cell><cell></cell><cell>yes</cell><cell>yes</cell></row><row><cell>Triangle Ray Intersect</cell><cell>yes</cell><cell></cell><cell>yes</cell><cell>yes</cell></row><row><cell>Suffix Array</cell><cell>sub</cell><cell>yes</cell><cell>yes</cell><cell>yes</cell></row><row><cell cols="2">Delaunay Triangulation sub</cell><cell>yes</cell><cell>sub</cell><cell>yes</cell><cell>yes</cell></row><row><cell>Delaunay Refine</cell><cell></cell><cell>yes</cell><cell></cell><cell>yes</cell><cell>yes DM</cell></row><row><cell>N-body</cell><cell>yes</cell><cell>yes</cell><cell>yes</cell><cell></cell></row><row><cell>K-Nearest Neighbors</cell><cell>sub</cell><cell></cell><cell></cell><cell>yes</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>1 u 2 u 3 u 4 u 5 u 6 u 7 u 8 u 2 u 3 u 4 u 5 u 6 u 7 u 8 Figure6. A sample graph and an execution of deterministic reservations for finding a maximal independent set. Here, the subscript of a node corresponds to its priority in the deterministic reservations. The prefix size is chosen to be 4.<ref type="bibr" target="#b0">(1)</ref> shows the initial graph in priority order, and (2)-(4) show subsequent rounds of the algorithm. The vertical line indicates the end of the current prefix. Dark-gray nodes are those that become IN or OUT during that round: nodes with a thick border are IN and accepted into the MIS, and nodes with an "X" are OUT as they have a neighbor already in the MIS. For example, u1 is the only node accepted into the MIS during the first round. Similarly, u2 becomes OUT in the second round as it has a neighbor already in the MIS (namely, u1). White nodes are those belonging to the current prefix that remain LIVE. For example, in the first round u2, u3, and u4 all have a higher priority neighbor in the same prefix and remain live. Only nodes that survive the previous round (LIVE nodes) are displayed in the array and part of the current prefix, so u5 is skipped in<ref type="bibr" target="#b2">(3)</ref>. Nodes in the MIS are also shown with thick border in the graph.The second case corresponds to a conflict since for an earlier neighbor it is not yet known if it is IN or OUT. The commit phase for iteration i simply copies the local flag to Fl[i]. Since Fl is only read in the reserve phase and only written (to location i) in the commit phase, all operations commute.</figDesc><table><row><cell></cell><cell></cell><cell>u 3</cell><cell>u 6</cell><cell></cell></row><row><cell></cell><cell></cell><cell>u 2</cell><cell>u 8</cell><cell>u 5</cell></row><row><cell></cell><cell>u 1</cell><cell></cell><cell>u 7</cell><cell></cell></row><row><cell></cell><cell></cell><cell>u 4</cell><cell></cell><cell></cell></row><row><cell>1)</cell><cell></cell><cell></cell><cell>2)</cell><cell></cell></row><row><cell>3)</cell><cell>u 3 u 4</cell><cell>u 6 u 7 u 8</cell><cell>4)</cell><cell>u 7 u 8</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>any earlier neighbor is IN</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">LIVE any earlier neighbor is LIVE</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>IN</cell><cell>otherwise</cell></row></table><note><p>u</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3</head><label>3</label><figDesc></figDesc><table><row><cell>(c). Our nondeterministic</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>If false is returned by reserve() then the iterate is dropped without proceeding to the commit.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. This work is partially supported by the National Science Foundation under grant number CCF-1018188, and by Intel Labs Academic Research Office for the Parallel Algorithms for Non-Numeric Computing Program.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Table <ref type="table">3</ref>. Running times (seconds) of algorithms over various inputs on a 32-core machine (with hyper-threading). A "*" indicates an internally nondeterministic implementation and a "**" indicates an externally (and hence internally) nondeterministic implementation. † Galois-Boruvka did not terminate in a reasonable amount of time for the first two inputs.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The data locality of work stealing</title>
		<author>
			<persName><forename type="first">U</forename><surname>Acar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Blelloch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Blumofe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory of Computing Systems</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2002">2002</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Weak ordering-a new definition</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">V</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM ISCA</title>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Core-Det: A compiler and runtime system for deterministic multithreaded execution</title>
		<author>
			<persName><forename type="first">T</forename><surname>Bergan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Devietti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grossman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM ASPLOS</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Deterministic process groups in dOS</title>
		<author>
			<persName><forename type="first">T</forename><surname>Bergan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Hunt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Gribble</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Usenix OSDI</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Grace: Safe multithreaded programming for C/C++</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">D</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Novark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">OOPSLA</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Programming parallel algorithms</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Blelloch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CACM</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Strongly history-independent hashing with applications</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Blelloch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Golovin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE FOCS</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A provable time and space efficient implementation of NESL</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Blelloch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Greiner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM ICFP</title>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Low-depth cache oblivious algorithms</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Blelloch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">B</forename><surname>Gibbons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Simhadri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SPAA</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Cilk: An efficient multithreaded runtime system</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Blumofe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">F</forename><surname>Joerg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Kuszmaul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Randall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Parallel and Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="1996">1996</date>
			<publisher>Elsevier</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Parallel programming must be deterministic by default</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Bocchino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">V</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Snir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Usenix HotPar</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Safe nondeterminism in a deterministicby-default parallel language</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Bocchino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Heumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Honarmand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">V</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Welc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Shpeisman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM POPL</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A decomposition of multidimensional point sets with applications to k-nearest-neighbors and n-body potential fields</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">B</forename><surname>Callahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">R</forename><surname>Kosaraju</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">R-MAT: A recursive model for graph mining</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chakrabarti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIAM SDM</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Detecting data races in Cilk programs that use locks</title>
		<author>
			<persName><forename type="first">G.-I</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Randall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">F</forename><surname>Stark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SPAA</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Parallel SAH k-D tree construction</title>
		<author>
			<persName><forename type="first">B</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Komuravelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Bocchino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">V</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Hart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM High Performance Graphics</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">H</forename><surname>Cormen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Stein</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>MIT Press and McGraw-Hill</publisher>
		</imprint>
	</monogr>
	<note>Introduction to Algorithms, Second Edition</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Computational Geometry: Algorithms and Applications</title>
		<author>
			<persName><forename type="first">M</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Cheong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Van Kreveld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Overmars</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">DMP: Deterministic shared memory multiprocessing</title>
		<author>
			<persName><forename type="first">J</forename><surname>Devietti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Lucia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Oskin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM ASPLOS</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">RCDC: A relaxed consistency deterministic computer</title>
		<author>
			<persName><forename type="first">J</forename><surname>Devietti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bergan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grossman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM ASPLOS</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Cooperating sequential processes</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
		<idno>EWD 123</idno>
	</analytic>
	<monogr>
		<title level="j">Dept. of Mathematics, Technological U</title>
		<imprint>
			<date type="published" when="1965">1965</date>
			<pubPlace>Eindhoven</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Memory consistency and event ordering in scalable shared-memory multiprocessors</title>
		<author>
			<persName><forename type="first">K</forename><surname>Gharachorloo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lenoski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Laudon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gibbons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hennessy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM ISCA</title>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A more practical PRAM model</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">B</forename><surname>Gibbons</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SPAA</title>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Multilisp: A language for concurrent symbolic computation</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Halstead</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TOPLAS</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1985">1985</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Ordered vs. unordered: A comparison of parallelism and work-efficiency in irregular algorithms</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Hassaan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Burtscher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pingali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM PPoPP</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Transactional boosting: A methodology for highly-concurrent transactional objects</title>
		<author>
			<persName><forename type="first">M</forename><surname>Herlihy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Koskinen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM PPoPP</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Linearizability: A correctness condition for concurrent objects</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Herlihy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Wing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TOPLAS</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Calvin: Deterministic or not? Free will to choose</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hower</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Dudnik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE HPCA</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Simple linear work suffix array construction</title>
		<author>
			<persName><forename type="first">J</forename><surname>Karkkainen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sanders</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EATCS ICALP</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Exploiting the commutativity lattice</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kulkarni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Prountzos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Sui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pingali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM PLDI</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">The Cilk++ concurrency platform</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Leiserson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Supercomputing</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2010">2010</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A work-efficient parallel breadthfirst search algorithm (or how to cope with the nondeterminism of reducers)</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">B</forename><surname>Schardl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SPAA</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Deterministic parallel random-number generation for dynamic-multithreading platforms</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">B</forename><surname>Schardl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sukha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM PPoPP</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Heuristics for ray tracing using space subdivision</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Macdonald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Booth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Visual Computer</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1990">1990</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">What are race conditions?</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H B</forename><surname>Netzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LOPLAS</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="1992">1992</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Kendo: Efficient deterministic multithreading in software</title>
		<author>
			<persName><forename type="first">M</forename><surname>Olszewski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ansel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Amarasinghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM ASPLOS</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Closure properties of interconnections of determinate systems</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Patil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Record of the Project MAC conference on concurrent systems and parallel computation</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Dennis</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">The tao of parallelism in algorithms</title>
		<author>
			<persName><forename type="first">K</forename><surname>Pingali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kulkarni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Burtscher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Hassaan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kaleem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lenharth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Manevich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Méndez-Lojo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Prountzos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Sui</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM PLDI</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Commutative set: A language extension for implicit parallel programming</title>
		<author>
			<persName><forename type="first">P</forename><surname>Prabhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ghosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">I</forename><surname>August</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM PLDI</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Commutativity analysis: A new analysis technique for parallelizing compilers</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Rinard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Diniz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TOPLAS</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">6</biblScope>
			<date type="published" when="1997">1997</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">MCSTL: The multi-core standard template library</title>
		<author>
			<persName><forename type="first">J</forename><surname>Singler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sanders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Putze</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Euro-Par</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Making asynchronous parallelism safe for the world</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">L</forename><surname>Steele</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM POPL</title>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">A scalable approach to thread-level speculation</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Steffan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">B</forename><surname>Colohan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zhai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">C</forename><surname>Mowry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM ISCA</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Commutativity-based concurrency control for abstract data types</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename><surname>Weihl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computers</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">12</biblScope>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">A case for an interleaving constrained shared-memory multi-processor</title>
		<author>
			<persName><forename type="first">J</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Narayanasamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM ISCA</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
