<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Maneuver-Based Motion Planning for Nonlinear Systems With Symmetries</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><roleName>Associate Member, IEEE</roleName><forename type="first">Emilio</forename><surname>Frazzoli</surname></persName>
							<email>frazzoli@ucla.edu</email>
						</author>
						<author>
							<persName><roleName>Fellow, IEEE</roleName><forename type="first">Munther</forename><forename type="middle">A</forename><surname>Dahleh</surname></persName>
							<email>dahleh@mit.edu</email>
						</author>
						<author>
							<persName><forename type="first">Eric</forename><surname>Feron</surname></persName>
							<email>feron@mit.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Mechanical and Aerospace Engineering Department</orgName>
								<orgName type="institution">University of California Los Angeles</orgName>
								<address>
									<postCode>90095</postCode>
									<settlement>Los Angeles</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="laboratory">Laboratory for Information and De-cision Systems</orgName>
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
								<address>
									<postCode>02139</postCode>
									<settlement>Cambridge</settlement>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Maneuver-Based Motion Planning for Nonlinear Systems With Symmetries</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">A0101653CB87F2435F51FC75A5DCAFBC</idno>
					<idno type="DOI">10.1109/TRO.2005.852260</idno>
					<note type="submission">received December 9, 2004.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Formal languages</term>
					<term>mobile robot motion-planning</term>
					<term>optimal control</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper, we introduce an approach for the efficient solution of motion-planning problems for time-invariant dynamical control systems with symmetries, such as mobile robots and autonomous vehicles, under a variety of differential and algebraic constraints on the state and on the control inputs. Motion plans are described as the concatenation of a number of well-defined motion primitives, selected from a finite library. Rules for the concatenation of primitives are given in the form of a regular language, defined through a finite-state machine called a Maneuver Automaton. We analyze the reachability properties of the language, and present algorithms for the solution of a class of motion-planning problems. In particular, it is shown that the solution of steering problems for nonlinear dynamical systems with symmetries and invariant constraints can be reduced to the solution of a sequence of kinematic inversion problems. A detailed example of the application of the proposed approach to motion planning for a small aerobatic helicopter is presented.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>mechanical systems in a free environment. (For a thorough review of the state of the art, see <ref type="bibr" target="#b1">[2]</ref> and references therein.) However, in many cases of interest, physically accurate models of the dynamics of many vehicles of practical interest do not possess the required properties for direct application of most of the above-mentioned techniques. None of these methods, for example, can be directly applied to realistic aircraft models, subject to nonnegligible aerodynamic forces, actuator saturation, and safety constraints on the state.</p><p>On the other hand, expert human pilots are able to effectively operate vehicles with very complicated and possibly unstable dynamics, often at the edge of their operational envelope. In particular, the approach in this paper was motivated by the observation that human pilots execute aerobatic routines through the concatenation of well-practiced "maneuvers" <ref type="bibr" target="#b2">[3]</ref>. A formal definition of this concept, and its exploitation in the context of motion planning, are the core of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Languages for Motion Description</head><p>A new and promising direction of research in control theory, which will be pursued in this paper, is centered on the purposeful introduction of state and/or control quantization in the design of control systems <ref type="bibr" target="#b3">[4]</ref>- <ref type="bibr" target="#b6">[7]</ref>. The purpose of quantization is, in general, a reduction of the complexity of the control task. In this paper, instead of quantizing time, the state, or the control input values, we select a finite number of state and control trajectories, which we call motion primitives, and combine them to generate feasible trajectories.</p><p>Several approaches to the solution of motion-planning problems have been developed, based on the choice of a finite number of elementary control laws, which are combined to generate more complex behaviors. The approach in this paper is related to other efforts to develop languages and reactive behaviors in robotics; in particular, it can be seen as a structured subclass of the Motion Description Languages in <ref type="bibr" target="#b7">[8]</ref>- <ref type="bibr" target="#b10">[11]</ref>, and a generalization of <ref type="bibr" target="#b4">[5]</ref> and <ref type="bibr" target="#b11">[12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Paper Organization</head><p>In Section II, we define the class of systems we are interested in, and the kind of problem that we want to solve. In Section III, we discuss the geometric properties of systems with symmetries, introduce the notion of motion primitive, and identify classes of primitives of interest. In Section IV, we define rules for the concatenation of primitives in the form of a regular language: each string in the language corresponds to a feasible trajectory. In Section V, we derive conditions on the language guaranteeing the existence of strings which solve the steering problem. In Section VI, we discuss algorithms to solve a class of motion-planning problems. In Section VII, we present more in detail the necessary steps for the application of our methodology to a challenging mechanical system, i.e., a realistic model of a small acrobatic helicopter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. PROBLEM FORMULATION</head><p>In this paper, we are interested in planning the motion of a time-invariant, nonlinear dynamical control system , described by a set of ordinary differential equations (ODE) such as <ref type="bibr" target="#b0">(1)</ref> where the state belongs to an -dimensional manifold , and the control belongs to a set (with ). Under appropriate technical conditions on the function (e.g., boundedness and locally Lipschitz dependence on its arguments <ref type="bibr" target="#b1">[2]</ref>), and given a piecewise-continuous open-loop control law , the ODE (1) can be integrated to compute the state of the system at any time , as a function of the initial conditions, i.e.,</p><p>The function represents the state flow of the time-varying dynamical system , corresponding to <ref type="bibr" target="#b0">(1)</ref> under the action of the assigned open-loop control law . Given an initial condition , and a desired final set , the basic steering problem can be formulated as the problem of finding a control law such that , for some . In practical applications, the motion plan must also satisfy a set of constraints, dictated, for example, by safety considerations and actuator saturation. These conditions can be encoded as a set of inequality constraints on the state and on the control input, of the form <ref type="bibr" target="#b1">(2)</ref> where is a vector of constraints, and the inequality must be understood component-wise. In the following, we will refer to <ref type="bibr" target="#b1">(2)</ref> as operational envelope constraints. Typically, these constraints share the invariance properties of the system , both with respect to time, and with respect to the action of a group. (Invariance properties of will be discussed in the next section.) As a measure of the quality of the motion plan, we will consider a cost functional of the form <ref type="bibr" target="#b2">(3)</ref> As with the constraints, we will assume that the incremental cost function shares the same invariance properties of .</p><p>The general motion-planning problem would involve other pointwise-in-time constraints, such as obstacle avoidance, or integral constraints, such as finite fuel. However, dealing with these constraints is beyond the scope of this paper; an application of the methods proposed in this paper to real-time motion planning in dynamic, obstacle-ridden environments can be found in <ref type="bibr" target="#b12">[13]</ref>.</p><p>Finally, we remark that, as is common in the trajectory-generation literature, we will concentrate on open-loop control design. In practical applications, some form of feedback will be needed to handle uncertainties and disturbances in the plant and in the environment. The addition of feedback to the proposed approach is out of the scope of this paper, and will be the subject of future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. SYMMETRY AND MOTION PRIMITIVES</head><p>A fundamental geometric property characterizing the dynamics of many mechanical systems of interest, including most vehicles and moving robots, is invariance with respect to a certain class of transformations on the state of the system.</p><p>Consider a finite-dimensional Lie group , with identity element . A (left) action of the group on the state manifold is a smooth map , such that for all , and for every , and , . We will often use the shorthand to mean . We say that a dynamical control system , described by (1), is invariant with respect to the group action , or, equivalently, that is a symmetry group for the system , if for all , ,</p><p>, and all piecewise-continuous control laws , the following holds:</p><p>In other words, is a symmetry group for if its action on the state commutes with the state flow. Invariance also implies that if a curve is an integral of (1), then so is , for any . Notice that time invariance of implies that the real axis (with addition) is an additional symmetry group, acting on by time translation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Motion Primitives</head><p>Invariance with respect to a group action leads us to define a notion of equivalence of trajectories, and the concept of motion primitives. We say that two trajectories are equivalent if they can be exactly superimposed through time translation and the action of the symmetry group . Formally, two (state and control) trajectories , and , are equivalent, if , and if there exist , , such that . Consider a time-invariant system , invariant with respect to actions of the group , and a trajectory , satisfying (1) and <ref type="bibr" target="#b1">(2)</ref>. A Motion Primitive is the class of trajectories equivalent to . With a slight abuse of notation, we will also use the symbol to indicate the corresponding motion primitive, i.e., the set of all trajectories equivalent to . Let indicate the time duration of . Denote by the set of all motion primitives for a time-invariant control system , with a symmetry group .</p><p>Remark 3.1: Under the assumption that the constraints (2) share the invariance properties of , i.e., then if a trajectory satisfies the operational envelope constraints, so do all equivalent trajectories. Feasibility with respect to (2) is, hence, a uniform property of a motion primitive. This assumption is typically verified for actuator limits, and for the operational envelope of the vehicle (e.g., bounds on minimum and maximum speed, etc.).</p><p>Remark 3.2: Under a similar assumption on the incremental cost function , i.e., all instances of a motion primitive have the same cost. This assumption is satisfied in a broad class of optimal control problems of interest, including minimum-time, minimumpath-length, minimum-energy, and minimum-fuel problems.</p><p>In the absence of operational envelope constraints (2), a motion primitive can be obtained simply by applying an arbitrary piecewise-continuous control law to the system , starting from arbitrary initial conditions, for a finite time interval, and storing the resulting state and control trajectory . This can be computed through integration of (1), or, for example, by running an experiment on a physical system (which gives, by definition, a feasible trajectory). If operational envelope constraints are present, valid trajectories must satisfy these limitations; naturally, experiments need to be limited to such an envelope for safety and other considerations. Note that any fragment of a stored trajectory defined on a compact time interval can be taken as a valid primitive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Concatenation of Motion Primitives</head><p>The motion-planning method we present in this paper is based on the selection of a family of motion primitives, which are combined to form complete state and control trajectories satisfying the constraints imposed by the steering problem. We call the operation of combining two primitives to form another primitive concatenation. In order to maintain feasibility of trajectories, we cannot concatenate primitives arbitrarily, but must make sure that certain matching conditions are satisfied. More specifically, we need to make sure that the final state of the first primitive coincides with the initial state of the second primitive, modulo an action of . In the remainder of this section, we give a condition for compatibility of two primitives, and formally define the concatenation operation. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Trim Primitives and Maneuvers</head><p>In this section, we identify two classes of motion primitives that can be used to build a "library" for motion planning, with certain desirable properties. Intuitively, one can expect that if we select a finite number of primitives, the set of points that can be reached from an initial state, after the concatenation of a finite number of copies of such primitives, will be a discrete set (for a formal analysis of such a system, see <ref type="bibr" target="#b13">[14]</ref>).</p><p>If a continuous reachable set is desired after the concatenation of a finite number of primitives, one needs to consider a library effectively containing an uncountable number of motion primitives. In order to maintain a finite description for the library, we will look at a particular class of continuously parameterized motion primitives. This class of primitives is identified with steady-state motions, also known as relative equilibria, or trim trajectories in the aeronautical community. Along such a trajectory, controls are kept constant ("trimmed"), and the relative wind has a constant direction with respect to the aircraft.</p><p>Formally, we call a nontrivial motion primitive a trim primitive if <ref type="bibr" target="#b3">(4)</ref> where is an element of , the Lie algebra of . In other words, trim primitives correspond to finite flows along left-invariant vector fields. We indicate the set of all trim primitives for the system with symmetry group as . The simplest example of a trim primitive is an equilibrium point.</p><p>Given a trim primitive , one can build a whole family of trim primitives parameterized by a scalar by extending or restricting its domain of definition, as follows:</p><p>(5) Let be the set of all trim primitives obtained by changing the domain of a trim primitive . We call the nonnegative scalar the coasting time, since it determines how much time is spent executing a trim primitive, and how long the system follows the flow of the corresponding left-invariant vector field.</p><p>Finally, we define a maneuver as a nontrivial primitive which is compatible, from the left and from the right, with trim primitives; in other words, we define a maneuver as a primitive that begins and ends at steady-state conditions. If we denote by the set of all maneuvers, we have that , . We call the set of trim primitives that are compatible with from the left the predecessors of , and indicate it as . Correspondingly, we define, as , successors of , the set of trim primitives that are compatible with from the right. Notice that, if (resp.</p><p>), then (resp.</p><p>). Consider a maneuver , of duration . Since, by definition, the maneuver is compatible with a trim primitive from the left, and with a trim primitive from the right, there must be such that , and . We define the group displacement of the maneuver as . Remark 3.4: While and depend on the choice of particular class representatives, the group displacement is -invariant, i.e., it is an invariant characteristic of a maneuver.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. THE MANEUVER AUTOMATON</head><p>The proposed method for motion planning relies on the choice of a finite set of maneuvers , and the generation of complex trajectories through the concatenation of maneuvers in . Since not all maneuvers are compatible, rules for the choice of "legal" sequences are needed. A convenient way of representing such rules is given by the definition of a formal language. In other words, we will consider the set as the alphabet of a formal language. Words in this language are formed through concatenation of several maneuvers, hence, a word will be an element of the so-called free monoid , i.e., the set of all possible sequences of symbols in . (The identity element is the null string .) In general, not all strings in correspond to feasible trajectories with respect to (1), since only compatible primitives can be concatenated. It is convenient to represent all strings in formed by concatenation of compatible primitives as the set of all strings accepted by a finite state machine, which we will call a Maneuver Automaton (MA). An MA is a tuple MA <ref type="bibr" target="#b5">(6)</ref> where we have the following.</p><p>• is the maneuver alphabet, i.e., a finite collection of maneuvers. • is a finite set of states. The set is a collection of trim primitive closures chosen in such a way that for any , , , and</p><p>. In other words, the set is a minimal set that includes all trim primitives from which maneuvers can start, and at which maneuvers can end. The symbol represents an error state, used to detect unallowed strings.</p><p>• The map is a transition function, relating the state after the execution of a maneuver, to the state before the maneuver. The map is defined as follows: if otherwise.</p><p>• is an initial state. • is a set of final, or accepting, states.</p><p>An MA can be conveniently depicted as a directed graph in which vertices represent states (i.e., trim primitives), and edges represent maneuvers. The initial state is indicated by an arrow, and final states are indicated with a double circle; see Fig. <ref type="figure" target="#fig_0">1</ref> for an example. In the figure, trim primitives are labeled with Greek letters, and maneuvers are labeled with Roman letters. An MA graph need not be connected or strongly connected, admits parallel edges (i.e., more than one maneuver can connect the same trim primitives, as in the case of and in the figure), and edges having the same source and target node, such as in the figure.</p><p>Given an MA, we define the language MA as the set of all strings accepted by it. We will call a string MA a maneuver sequence. Since an MA is a finite state machine, the language MA is a regular language. Other ways to define regular languages include regular grammars. Production rules to obtain all strings in MA can be derived from the compatibility relation; we will not pursue this straightforward task.</p><p>We will make the assumption that the initial and final conditions for the motion-planning problem are such that they can be represented as trim primitives in , i.e., there exist and such that . Similar assumptions are made for the target set, i.e., , . These assumptions are usually verified in motion planning, since initial and final conditions are typically defined at rest, or at some steady-state condition. In (6), , , and depend on the system, and on the choice of primitives to include in the language. On the other hand, and depend on the specific instance of the problem to be solved. When discussing properties that should hold uniformly over any choice of and , such as controllability, we will leave these undefined.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Motion Plans</head><p>The role of trim primitives has been, so far, just that of providing a convenient way of formally defining a special kind of motion primitives, namely, maneuvers, and providing them with a common interface for concatenation. However, trim primitives can be further exploited to enrich trajectories that can be represented using the MA language.</p><p>Consider the maneuver sequence ; by inserting zero-length trim primitives between maneuvers, the primitive can be equivalently represented as , with for , and . We can obtain a much richer set of primitives by interleaving maneuvers with nonnegative flows along trim primitives. In other words, we can consider primitives of the form , . As in the previous case, by construction. Based on this discussion, we define a motion plan on an MA as a pair MA , where is the number of symbols in , and is an array of nonnegative coasting times.</p><p>While a maneuver sequence can be associated with a path on a directed graph representing the MA, a motion plan augments this information by specifying the time spent at the states (trim primitives). The duration of the motion plan is equal to the sum of the duration of the maneuver sequence and the sum of the coasting times in the array .</p><p>A key property of our language for the purpose of motion planning is the ability to recover in a mathematically convenient way the complete state of the system at any time during the execution of a motion plan, without resorting to simulation or numerical integration of the differential equations (1). To see this, consider a motion plan of length one, i.e., a motion plan composed of just one maneuver, preceded and followed by a trim primitive. The motion plan is defined by the primitive . If , the state trajectory is described by otherwise.</p><p>The above formula can be easily extended to a motion plan of arbitrary length. In particular, the final state after the execution of a motion plan of length is given by , where the group displacement can be computed as <ref type="bibr" target="#b6">(7)</ref> In the above, we used the convention that is the th symbol in the maneuver sequence , , , and . Moreover, successive factors in the product between square brackets must be right-multiplied. Equation ( <ref type="formula">7</ref>) can be rewritten in the equivalent form <ref type="bibr" target="#b7">(8)</ref> where is the group displacement corresponding to the motion plan , and the vector fields are defined by <ref type="bibr" target="#b8">(9)</ref> and ; is the adjoint mapping of , i.e., . Equation <ref type="bibr" target="#b7">(8)</ref> shows that the total group dispacement due to a motion plan can be decomposed into a group displacement , due to the maneuver sequence , and the composition of flows along left-invariant vector fields , which can be computed from the maneuver sequence. Remarkably, (8) has the structure of a forward kinematic map in robotics, such as, for example, the map defining the position of the end-effector of a robotic arm, as a function of the joint angles <ref type="bibr" target="#b14">[15]</ref>. In other words, the nonlinear dynamical system (1) can be transformed, using the MA language and formalism, into a system that formally behaves like a kinematic system. The transformation is exact, i.e., no approximations are introduced, but it limits the admissible trajectories to sequential combinations of a finite number of motion primitives, computed a priori.</p><p>Kinematic decoupling, introduced in <ref type="bibr" target="#b15">[16]</ref>, also leads to the reformulation of steering problems for dynamical systems as kinematic inversion problems. However, kinematic decoupling is applicable only to systems with symmetries satisfying certain additional conditions, and requires the system to stop each time motion along a different vector field is desired. Our approach does not suffer from these limitations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Maneuver Automata and Other Languages for Motion Description</head><p>Some remarks about the relationship of the language defined in this section to similar efforts in the literature are appropriate at this point. Languages defined via Maneuver Automata can be seen as a subset of motion-description languages and extensions, such as MDLe, as defined in <ref type="bibr" target="#b7">[8]</ref> and <ref type="bibr" target="#b8">[9]</ref>. The elementary component of MDLe is an atom, composed of a control law, a set of Boolean triggers acting on sensory information, and a timer. Both the triggers and the timer govern transition between atoms. Since we focus on controllability analysis and feasible trajectory generation, as opposed to reactive behavior under external stimuli, we do not model the Boolean triggers. Each primitive in a motion plan can be seen as a triggerless atom, i.e., a control law, initiated at some specified initial conditions, together with a timer. If the motion primitive is a maneuver, the timer is set to its duration; if it is a trim primitive, the timer is set to the corresponding coasting time.</p><p>The additional structure provided by choosing the symbols in the language as equivalence classes under group actions, and further restricting the choice of symbols to well-defined maneuvers, makes it possible to explicitly take symmetries into account, and exploit them to simplify the representation and computation of trajectories. For example, in our language, it is possible to write down explicitly the final state after the execution plan <ref type="bibr" target="#b7">(8)</ref>; in general, this is not possible for an arbitrary motion-description language, without resorting to numerical integration of <ref type="bibr" target="#b0">(1)</ref>.</p><p>Maneuver Automata can be seen as a generalization of other motion-planning techniques, respectively based on control quanta and motion graphs. Control quanta were originally conceived as a motion-planning method for driftless systems with symmetries <ref type="bibr" target="#b4">[5]</ref>. Each control quantum is a finite-time open-loop control law; at the end of the execution of a control quantum, the control input is set to zero, hence bringing the system to a stop. In our language, each control quantum is a maneuver, starting and ending at an equilibrium, i.e., a zero-velocity trim primitive. Maneuvers, according to our definition, differ from control quanta in the sense that they are not constrained to start and end at zero-velocity conditions. As a consequence, the MA formalism allows us to deal in a natural way with systems with drift, and allows the system to flow along nontrivial vector fields, with important consequences on reachability properties.</p><p>Motion graphs were introduced to build complex animations of computer-generated characters from motion-capture sequences <ref type="bibr" target="#b11">[12]</ref>. Given a finite number of motion primitives, a motion graph can be constructed by representing rules for their sequential combination as a directed graph. Motion primitives are constructed from motion-capture sequences by identifying frames at which different segments can be joined. (In computer animation, one is not constrained by the continuity of the state and control trajectories, as long as the viewer does not perceive the discontinuities; hence, the conditions for concatenation are relaxed.) In essence, motion graphs are constructed as Maneuver Automata, using general motion primitives, instead of maneuvers. (In other words, without imposing the constraint that motion primitives start and end at common trim primitives.)</p><p>The key advantage of Maneuver Automata is that our formulation adds the ability to handle flows along nontrivial left-invariant vector fields to both the control quanta and motion graph concepts. The main implications of this added capability are addressed in the following sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. CONTROLLABILITY OF MANEUVER AUTOMATA</head><p>Our approach to the solution of motion-planning problems can be summarized as the following. Instead of looking for a control input in an infinite-dimensional set (e.g., piecewise-continuous functions), we limit our search to motion plans defined on the regular language MA . By limiting our search to plans composed of a finite number of primitives and coasting times, we reformulate a differential problem, such as the steering problem, as a finite-dimensional algebraic problem.</p><p>On the other hand, these computational advantages come at the cost of reducing the set of achievable trajectories for . The main issue at this point is the choice of the finite set of primitives to include in the maneuver library . A key requirement on , and on the resulting MA, is the preservation of reachability properties of the original system . Since we limit the initial and final conditions to be trim primitives, the reachable set from any initial state cannot include the entirety of the set . On the other hand, the MA language has enough expressive power to make it possible, under certain conditions to be derived, to encode in this language a motion plan to reach any point in the orbit of , under the action of . We say that an automaton MA is controllable (uniformly on and ) if, for any initial condition , any final trim primitive , and any compact set , there exists a time which is an upper bound on the time necessary to reach a desired target , with . Because of the invariance to actions of , controllability is a global property.</p><p>We define a fixed-point motion plan as a pair , where is a word describing a closed path on the MA, and is chosen in such a way that , i.e., the group displacement caused by the motion plan is equal to the identity . We want to analyze what happens if a fixed-point motion plan is perturbed by adding a vector to the nominal coasting times . In other words, we are interested in studying the map , . (Obviously, , by definition of fixed-point motion plan.) Given a scalar , define the set , i.e., the set of points which can be reached within time , by perturbing the coasting times .</p><p>Theorem 5.1 (MA Controllability): An MA is controllable, uniformly on and , if and only if:</p><p>(1) for any , , and for any pair , of connected components of , there is a maneuver sequence MA such that . In other words, the directed graph representing the MA is strongly connected, and the symmetry group can be connected through the action of maneuvers;</p><p>(2) there exists a finite-time, fixed-point motion plan , with , such that <ref type="bibr" target="#b9">(10)</ref> Proof: Necessity: The necessity of the first condition is a direct consequence of the definition of controllability; if it were not satisfied, no path would exist between initial and final conditions for some choice of trim primitives, and in arbitrary connected components of . The necessity of the existence of a fixed-point maneuver sequence is proven by contradiction, by breaking the problem into two steps, i.e., proving the necessity of fixed-point motion plans, and then the necessity of <ref type="bibr" target="#b9">(10)</ref>. Assume that the system is controllable, but there are no fixed-point motion plans. Since the system is controllable, it is possible to find a motion plan to steer it from to in finite time, for any . After the first step is done, it is possible to find another motion plan to steer it from to , again in finite time. The composition of the maneuver sequences and is a fixed-point maneuver, which contradicts the assumption.</p><p>The next point is proving that there must exist a single, finite-time, fixed-point motion plan such that the corresponding reachable set under coasting-time perturbations satisfies <ref type="bibr" target="#b9">(10)</ref>. Again, we will proceed by contradiction. Assume that the system is controllable, but that there is no fixed-point sequence with a reachable set with a nonempty interior. Consider a compact set with a nonempty interior. Since the system is controllable, it will be possible to find a finite time such that any point in will be reachable through at least one motion plan of duration . Because of controllability, for any motion plan , it will be possible to find a second motion plan such that the sequential combination of the two results into a fixed-point plan. Since we assumed that there is no fixed-point sequence with a reachable set with a nonempty interior, and any motion plan maps open sets into open sets, we must conclude that the reachable set of any motion plan has an empty interior. The number of all the possible maneuver sequences which result in a total sequence duration smaller that is finite, since each maneuver has a finite time duration, and the number of maneuvers is finite. This, however, results in a contradiction, since it is not possible to cover (a set with a nonempty interior) with a finite number of sets with empty interiors.</p><p>Sufficiency: Assume that there is a fixed-point motion plan , satisfying <ref type="bibr" target="#b9">(10)</ref>. Because of the first condition in the theorem, it is possible to find a motion plan that takes the system from the initial trim primitive to a trim primitive , compatible with one of the maneuvers in ; the motion plan will result a group displacement . Similarly, it is possible to find a motion plan that takes the system from the trim primitive to the final trim primitive ; such a motion plan results in a group displacement . The problem of finding a finite motion plan to steer the system from the initial and final conditions is reduced to finding a motion plan steering the system from to . Because of the first condition in the theorem, it is always possible to construct and in such a way that and are in the same connected component of . Consider a continuous curve , such that and . The second condition, together with invariance with respect to time and to actions of , ensures that it is always possible to find in such a way that , for all . In other words, it is possible to move along the curve by at least through a motion plan of the form ; as a consequence, with at most steps, one can reach the target point exactly. The total duration of a motion plan to reach a set with an open interior containing the target point can thus be bounded by . Since any compact set can be covered by a finite number of sets built as detailed above, it is possible to find a finite bound on the time to reach any point in .</p><p>Given a fixed-point motion plan , we are interested in computational tests to ensure that the corresponding reachable set has a nonempty interior. In the limit , the composition of flows along the vector fields identified by the vectors , defined by <ref type="bibr" target="#b10">(11)</ref> is equivalent to the flow along a linear combination of the same vectors. In other words, as , . Clearly, the set has a nonempty interior if the distribution spans the Lie algebra . Even in the case in which does not satisfy this condition, it could do so if repeated a sufficiently large number of times. Indicate the motion plan obtained through sequential combination of copies of as . A sufficient condition for controllability of an MA is then the following version of the Lie algebra rank condition <ref type="bibr" target="#b16">[17]</ref>.</p><p>Theorem 5.2: The reachable set has a nonempty interior for all and some , if and the involutive closure , under the Lie bracket operation, of the set has the same dimension as the Lie algebra . Proof: The system , with , is an invertible, locally (in the "controls" ) analytic nonlinear discrete-time system. The result follows from the application of <ref type="bibr" target="#b17">[18,</ref><ref type="bibr">Th. 3 and 9]</ref>.</p><p>Note that this is a nontrivial result, because the Lie algebra rank condition cannot be applied directly to the vector fields , since only nonnegative flows are allowed along them.</p><p>The above theorems show that the addition of trim primitives, i.e., the ability to move along left-invariant vector fields on , provides the "slackness" necessary to achieve a continuous reachable set using a finite number of motion primitives. The case in which there is no such capability has been analyzed in <ref type="bibr" target="#b13">[14]</ref>, where it is shown that the reachable set has the structure of a lattice, which can be either dense everywhere, or nowhere. A continuous reachable set results in bounded times to reach exactly any point in a compact set in ; whereas in the case of a discrete reachable set, it is not possible to bound the time needed to get arbitrarily close to some elements of .</p><p>Controllability of an MA implies neither small-time nor local controllability of the underlying dynamical system , but it does imply a form of configuration controllability, where the configuration is restricted to group variables. Conversely, local controllability implies that it is possible to define a set of maneuvers rich enough to yield a controllable MA. The proof of the controllability theorem implies the knowledge of a fixed-point motion plan; simple rules for constructing such motion plans for arbitrary systems, invariant to actions of (e.g., car-like robots) and of (e.g., aircraft) are given in <ref type="bibr" target="#b18">[19]</ref>, and are not reported here due to space limitations. See Section VII for an example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. MANEUVER-BASED MOTION PLANNING</head><p>Given a fixed-point motion plan , the proof of Theorem 5.1 provides a procedure to construct a motion plan satisfying the boundary conditions and the envelope constraints discussed in Section II. However, such a motion plan will be, in general, very inefficient; the objective of this section is to present a method to compute motion plans that minimize a cost of the form (3). Using Maneuver Automata, it is possible to approximate solutions to a class of infinite-dimensional differential problems solving finite-dimensional algebraic problems. On the other hand, restricting trajectories to combinations of a finite number of motion primitives results in the addition of additional constraints: hence, the solutions computed according to the proposed method will not, in general, be optimal. The relationship between initial and final condition in a motion plan is encoded by <ref type="bibr" target="#b7">(8)</ref>. Moreover, any motion plan resulting from the concatenation of feasible motion primitives satisfies the operational envelope constraints, see Remark 3.1. It remains to specify the cost of a motion plan.</p><p>Proposition 6.1: The cost (3) of a motion plan can be written as <ref type="bibr" target="#b11">(12)</ref> where is the cost of the motion primitive , and represents the cost per unit time of the trim primitive , i.e., the cost of .</p><p>Proof: Split the motion plan into two parts, such that . Since the cost ( <ref type="formula">3</ref>) is additive and time-invariant Similarly, it is possible to split the cost of a motion plan into the sum of the costs of each individual motion primitive. As noted in Remark 3.2, the cost of a motion primitive is a primitive-specific constant, i.e., it does not depend on the time or state at which the primitive is initiated. Furthermore, the cost of a trim primitive depends linearly on its duration Hence, <ref type="bibr" target="#b11">(12)</ref> corresponds to the breakdown of the cost of a motion plan into the sum of the primitives from which it is constructed.</p><p>Remark 6.2: The cost of a motion plan is affine in the coasting times .</p><p>Given a library of motion primitives defining a language MA, the most efficient motion plan solving a problem can be found by solving the following nonlinear program: s.t.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MA (13)</head><p>Before proceeding further, we must first ensure that an optimal solution to (13) does indeed exist.</p><p>Theorem 6.3: If the MA is controllable, then there exists a solution of the optimal control problem <ref type="bibr" target="#b12">(13)</ref>. The optimal motion plan will have finite length and finite cost.</p><p>Proof: Since the MA is controllable, there exists a finitelength motion plan which satisfies the boundary conditions, with finite cost. Since the cost of any nonempty motion plan is at least , there is a finite number of maneuver sequences in MA , encoding motion plans with a cost possibly smaller than , e.g., the set of all maneuver sequences of length bounded by . For each of these maneuver sequences, i.e., for a fixed , program <ref type="bibr" target="#b12">(13)</ref>, with the additional constraint , is a smooth optimization problem over a compact domain. Such a problem will either have an (attained) optimal solution, or be unfeasible. Hence, in addition to the solution candidate obtained from the controllability theorem, there will be a finite number of other candidates for an optimal solution. The candidates with the smallest cost are optimal solutions to <ref type="bibr" target="#b12">(13)</ref>. The optimal solution is not necessarily unique.</p><p>The optimization problem posed in ( <ref type="formula">13</ref>) is, in general, nonconvex and difficult to solve; however, since it is a finite-dimensional problem, its solution is, in general, easier than the solution of its differential counterpart. The structure of the group , and of the trim primitives included in the set of Automaton states , can induce further simplifications. For example, we can state the following. Proposition 6.4: Consider an MA MA , such that the set is such that for all . Under these assumptions, the program (13), fixed as maneuver sequence , is a polynomial program in the coasting times . Proposition 6.5: Consider an MA MA , such that the set is such that for all . Under these assumptions, the program (13), fixed as maneuver sequence , is a linear program in the coasting times .</p><p>The structure of ( <ref type="formula">13</ref>) lends itself to a hierarchical decomposition of the search for the optimal motion plan into a combinatorial problem, i.e., the choice of the optimal maneuver sequence , and a smooth, generally nonconvex optimization problem, i.e., the determination of the optimal coasting times , given the optimal maneuver sequence .</p><p>In other words, ; for fixed , the optimal coasting times can be computed solving a kinematics inversion problem, a well-studied problem for the solution of which efficient numerical and symbolic tools are available <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b19">[20]</ref>. Since is a finite string, the search process will stop in a finite number of steps.</p><p>The computational efficiency of the algorithm can be vastly improved by branch-and-bound and pruning techniques. Moreover, in some cases, it is possible to partition in such a way that an explicit solution for the optimal maneuver sequence is available <ref type="bibr" target="#b20">[21]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. MOTION PLANNING FOR A SMALL HELICOPTER</head><p>In this section, we illustrate the application of the proposed motion-planning methodology to a realistic model of an X-Cell 60 SE (manufactured by Miniature Aircraft USA, Orlando, FL) small-size helicopter. The helicopter under consideration has been instrumented at the Massachusetts Institute of Technology <ref type="bibr" target="#b21">[22]</ref>. The helicopter is equipped with an on-board CPU and a full avionics suite, including solid-state angular rate sensors and accelerometers, GPS unit, compass, and air data system. The helicopter dynamics been using a combination of first-principle modeling and system identification, as described in <ref type="bibr" target="#b21">[22]</ref>. The result is a nonlinear simulation that is accurate up to a forward velocity of about 20 m/s. The simulation includes several environmental disturbances and sources of errors, including wind, realistic sensor models including noise, biases, and latency, together with the actual navigation filter and control laws used in the helicopter. The simulation has been successfully validated against flight test data, even during challenging aerobatic maneuvers <ref type="bibr" target="#b21">[22]</ref>.</p><p>The state of the helicopter is described by where is a rotation matrix representing the attitude of the helicopter, is the position of the center of mass, and and are, respectively, the angular and linear velocities in body axes. The scalars and represent the so-called rotor flapping angles in the longitudinal and lateral directions, respectively; in other words, under the assumption that the rotor blades move in a plane, measures the component of the unit normal to the rotor disc along the longitudinal body axis, and measures the component along the transversal body axis. Finally, the scalar represents the angular velocity of the main rotor shaft.</p><p>On board the helicopter, a rotor speed governor automatically regulates the engine throttle to maintain the rotor speed at a nominal value of 1600 rpm. The available control inputs are described by where and are the so-called cyclic commands in the lateral and longitudinal directions, respectively; the effect of the cyclic commands is to modulate the pitch of the rotor blades during a revolution, with the effect of changing the flapping angles, and ultimately affecting mainly the moments acting on the helicopter in the roll and pitch directions. The collective command determines the average pitch of the main rotor blades, and hence, the total thrust produced by the rotor. Similarly, the "rudder" command determines the pitch of the tail rotor blades, and hence, the yawing moment generated by the tail rotor. The magnitude of each component of the control input is bounded as , , , . The dynamics of the helicopter are described by equations of the following form:</p><p>where is the gravity acceleration vector, is the inertia tensor of the helicopter about its center of mass, and is the unique 3 3 skew-symmetric matrix such that for all . A detailed discussion of the dynamics of the helicopter is out of the scope of this paper, and can be found in the referenced sources. It will suffice, for our purposes, to discuss its invariance properties. The external forces and moments acting on the helicopter are gravity, and aerodynamic forces on the fuselage and the rotors. Assuming that the atmosphere is an isotropic and homogeneous medium, i.e., that there is no wind, and that the air density is constant with altitude, the aerodynamic forces, expressed in body axes, do not depend on the attitude or on the position of the helicopter. In other words, aerodynamic forces are invariant with respect to actions of the group of rigid body motions in space . On the other hand, gravity acts along the local vertical, thus breaking this symmetry. Assuming a constant gravitational field, the gravitational forces are invariant with respect to translation and rotations about a vertical axis, i.e., to actions of the group . We can identify with the space of 4 4 matrices of the form where represents a rotation of an angle about the axis, and is a translation. The action of on the state is defined as Steady-state trajectories (trim primitives) correspond to arcs of helices with a vertical axis (including degenerate ones, such as straight lines and horizontal circles), flown at constant speed, constant pitch and roll angles, and constant control settings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Design of a Library of Motion Primitives</head><p>The first step in the application of our methodology to motion planning for the helicopter requires the design of a library of motion primitives. This process can be carried out in several ways, for example, through model-based optimal control design, through the analysis of human-piloted flight data, or through the use of simple on-board controllers. The latter approach is taken here.</p><p>For the sake of clarity, we will consider a very small library of motion primitives, containing only four trim primitives, and seven maneuvers; in practical application, the choice of the number of motion primitives to include in the library is a matter of tradeoff between achievable performance and planning completeness and computational complexity; a typical library can contain hundreds of primitives. The planner in <ref type="bibr" target="#b12">[13]</ref> used 625 primitives, while maintaining real-time computation capabilities.</p><p>1) Invariant Tracking Controller: An invariant tracking controller for small helicopters was introduced in <ref type="bibr" target="#b22">[23]</ref>; this controller was implemented in the simulation environment and used both to generate motion primitives in the offline design phase, and to provide stable tracking of the nominal motion plan during actual flight, in the presence of uncertainties in the system's dynamics and disturbances in the environment. (An invariant tracking controller has the property that open-loop symmetries are preserved under feedback <ref type="bibr" target="#b23">[24]</ref>; this is a key requirement for a tracking controller to be compatible with the approach presented in the paper.)</p><p>The controller provides, in principle, bounded tracking for the simple model of helicopter dynamics considered in <ref type="bibr" target="#b22">[23]</ref>; however, bounds on the tracking error are not available for the realistic simulation model used in this example. In particular, it is not known a priori what is the class of reference trajectories that can be tracked to within a certain error bound. Hence, while it is possible, in principle, to steer the helicopter using the tracking controller alone, no guarantees would be available on the safety and on the quality of the resulting closed-loop trajectories. In particular, it would not be possible, in this case, to predict the configuration of the helicopter during its motion, e.g., in order to ensure collision avoidance, without resorting to simulation. Finally, note that the controller in <ref type="bibr" target="#b22">[23]</ref> is not designed to minimize a physically meaningful cost.</p><p>On the other hand, embedding the helicopter's closed-loop behavior in the formal language discussed in Section IV makes it possible to generate trajectories that can be safely tracked, within error bounds computable a priori, and provides a measure of optimality with respect to a meaningful cost.</p><p>2) Trim Primitives: It is convenient to start by choosing a number of trim primitives of interest. Given the structure of the closed-loop control available on the helicopter, the generation of trim trajectories is trivial, and does not require any detailed knowledge of the actual equations of motion of the helicopter. (This statement is typically true in the vast majority of applications; most control-design methods address the problem of regulating a system around some steady-state condition.) The tracking controller itself is able to find the appropriate values of the state variables and control inputs required for trimming the helicopter at a desired altitude, velocity, sideslip, and turn rate. During the design process, only trim primitives that satisfy the flight envelope constraints are maintained and included in the library.</p><p>For the purpose of this example, four different trim primitives are chosen, namely: hover; forward level flight at 15 m/s; steady turn to the left, by 30 /s at 15 m/s flight speed; and a similar steady turn to the right. Simulation experiments provided a library of trim trajectory data, part of which is shown in Table <ref type="table">I</ref>. In the table, we report the entries of the Lie algebra elements describing trim primitives, as well as the roll and pitch angles (resp., and ), and rudder and collective inputs needed to maintain it.</p><p>3) Maneuvers: Similar considerations can be made for maneuvers; however, more design choices are available for these motion primitives. In this example, we will design a number of simple maneuvers, which entail the direct transition between two different trim primitives; moreover, we will give an example of an aerobatic maneuver.</p><p>Simple transitions between different trim primitives can be generated by commanding a transition, over a time , in the velocity of the reference trajectory. The closed-loop behavior of the helicopter will provide a feasible trajectory achieving the desired velocity change. The choice of the time determines the "aggressiveness" of the maneuver, and is tuned to achieve a fast response, without violating flight-envelope constraints.</p><p>Strictly speaking, since the tracking controller only provides asymptotic tracking, this procedure does not provide a valid maneuver, since maneuvers are defined as finite-time transitions between trim primitives. However, the maneuver can be truncated when the system settles at the desired trim primitives within a certain tolerance. Two examples of such maneuvers, i.e., the transition from hover to forward flight at 15 m/s, and from forward flight to turning flight, are provided in Figs. <ref type="figure" target="#fig_1">2</ref> and<ref type="figure" target="#fig_2">3</ref>. Partial state and control trajectories during the execution of a motion plan are reported in Figs. <ref type="figure" target="#fig_3">4</ref> and<ref type="figure" target="#fig_4">5</ref>. The invariance of the system with respect to time and group actions are evident in these figures; minor deviations and the high-frequency "noise" are due to environmental disturbances (e.g., irregularities in the engine power output) and numerical issues.</p><p>The MA language presented in this paper also allows us to include aerobatic maneuvers in the library of motion primitives. In this example, we will consider a maneuver called "ag turn," similar to the aerobatic figure known as "hammerhead," which allows the helicopter to quickly reverse the direction of flight,   in a very tight space, and with minor changes in velocity and altitude before and after the maneuver. (The name of this maneuver stands for "agricultural turn;" such a maneuver is used by crop-dusting pilots to optimize the flight path.)</p><p>As illustrated in Fig. <ref type="figure">6</ref>, this maneuver is initiated with a pull-up, trading airspeed for altitude. At the apex of the trajectory, when the velocity is reduced to almost zero, a yaw rotation is performed, reversing the heading of the helicopter. A dive then ensues, ending at approximately the original altitude and velocity, but with opposite heading; this is achieved in about 5 s, starting from forward flight conditions at 15 m/s (i.e., from the trim primitive ). A 2-s altitude recovery phase follows, during which the helicopter climbs back to the altitude it had  According to the above discussion, maneuvers are designed to construct a strongly connected graph, as depicted in Fig. <ref type="figure">7</ref>. For each of these maneuvers, information on the time duration and the group displacement are presented in Table <ref type="table">II</ref>. (In addition, the full state and control trajectories defining a prototype of such a primitive are stored in the motion primitive library.) B. Motion Planning 1) Controllability Check: Before proceeding with examples of motion-planning problems, we need to ensure that the collection of motion primitives defined in the preceding section is indeed sufficient for controllability. (All primitives are designed Fig. <ref type="figure">6</ref>. Profile of the "ag turn" maneuver referenced in the text, and included in the MA in the example. For the sake of clarity, one of the axes in the figure represents time; the entirety of the maneuver is executed within 1 m in the east-west direction. The helicopter is shown at 0.25-s intervals along its flight path. Fig. <ref type="figure">7</ref>. MA discussed in the example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TABLE II MANEUVER LIBRARY (PARTIAL)</head><p>with no net altitude change; hence, we will restrict ourselves to motion-planning problems on the plane, even though the dynamics of the helicopter are fully 3-D, and altitude changes occur during the execution of maneuvers.) First of all, the digraph in Fig. <ref type="figure">7</ref> is strongly connected, and the group of rigid motions on the plane is connected. Consider the motion plan . From the data reported in Tables I and II, it can be verified that e f e f</p><p>i.e., that is a fixed-point motion plan. Furthermore, the vectors , defined in <ref type="bibr" target="#b10">(11)</ref>, span the subalgebra . Hence, from Theorem 5.1, we can conclude that our collection Fig. <ref type="figure">8</ref>. Trajectory flown during the execution of the motion plan p = (efefefef; [1; 2; 1; 2; 1 + 1; 2 + 1; 1; 2; 0]). The fixed-point motion plan p mentioned in the text is contained in p. The dashed line shows the composition of unit flows along and .</p><p>of primitives is indeed sufficient to steer the system to any configuration at the same altitude as the initial conditions.</p><p>In order to gain some intuition on how to control the configuration of the helicopter using perturbations on the fixed-point motion plan , in Fig. <ref type="figure">8</ref>, we report the northeast trajectory corresponding to (dark curve), followed by a motion plan equal to . The final group displacement can be computed as The flow along these vector fields is also shown in Fig. <ref type="figure">8</ref>.</p><p>2) Feasible Motion Plan Computation: The same fixedpoint motion plan we used to check controllability can be used to compute a feasible motion plan between two arbitrary configurations of the form , with , and . This is due to the fact that the composition of positive flows along the left-invariant vector fields identified by spans the whole group . For example, consider the following steering problem. Steer the helicopter from the initial state (northward flight at the origin) to the target state , with i.e., forward flight with a (northwest) heading, at position (0, 100).</p><p>A feasible motion plan can be found if there exist nonnegative coasting times that solve the following equation:</p><p>e f e f Fig. <ref type="figure">9</ref>. Feasible motion plan for the example problem, constructed from the fixed-point motion plan used to prove controllability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>that is</head><p>The above underdetermined equation, involving linear and trigonometric functions of the coasting times , can be written as a polynomial equation through the identities , , with . A solution is found as ; the corresponding trajectory is shown in Fig. <ref type="figure">9</ref>.</p><p>3) Optimal Motion-Plan Computation: The total time needed to execute the motion plan is equal to 32.5 s. It is now desired to minimize the total time to steer the helicopter between the two specified configurations.</p><p>In order to do this, we need to consider all maneuver sequences MA , where the initial state of the automaton MA is , and the set of accepting states is , such that . For each of these maneuver sequences, we need to solve the optimization problem <ref type="bibr" target="#b12">(13)</ref>.</p><p>While the number of such maneuver sequences is, in principle, large, bounding and constraint satisfaction arguments result in a substantial pruning of the decision tree describing all feasible maneuver sequences. For example, one can immediately conclude that optimal maneuver sequences will not include any substring of the form ; the trim primitive executed for 6 s results in the same group displacement, and has the same pre-and postconditions, with a lower cost. Maneuver sequences must include at least one substring of the form or in order to set the final heading angle to the desired value. The maneuver sequences and do not solve the steering problem, as program ( <ref type="formula">13</ref>) is infeasible in these cases. Using the maneuver sequence , (13) yields the motion plan , with a cost of 20.68 s. The cost of can now be used as an upper bound on the cost of candidate optimal maneuver sequences, instead of . The corresponding trajectory is shown in Fig. <ref type="figure" target="#fig_6">10</ref>. The optimal maneuver-based motion plan is eventually found to be , with a cost s. As evident from the optimal maneuver sequence, this motion plan includes the "ag turn" maneuver; Fig. <ref type="figure" target="#fig_7">11</ref> shows the trajectory flown by the helicopter.  We remind the reader that "optimality" here must be understood under the constraints of the available motion primitives, i.e., this motion plan is not optimal when the continuous dynamics of the helicopter are considered. On the other hand, the computation of this motion plan, making optimal use of precomputed primitives, took about half a second on a 867 MHz PowerPC G4, running Mac OS X. We remark that a hard bound can be given for the computation time for obtaining a feasible motion plan; this is particularly important for real-time applications. In our case, a feasible motion plan can be obtained in about three-hundredths of a second.</p><p>Finally, to our knowledge, our motion-planning methodology is unique in its ability to include "aggressive" or acrobatic maneuvers in a motion plan, as shown in the example. (The solution of the full optimal control could also include such maneuvers, but at a prohibitive computational cost.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. CONCLUSIONS AND FUTURE WORK</head><p>In this paper, we introduced a formal language for motion description, and computationally efficient algorithms for computing solutions to a certain class of motion-planning problems. The proposed approach is applicable to a large class of nonlinear systems with symmetries, including mobile robots and autonomous vehicles.</p><p>The key advantages of the proposed approach are two-fold: all motion plans generated according to the rules of the language are implicitly feasible with respect to the dynamics of the system; and safe with respect to the operational-envelope constraint. Furthermore, the map relating the initial and final configurations of the system has the same structure of a forward kinematic map, even for systems with complex dynamics. As a consequence, tools developed for motion planning of kinematic systems can be brought to bear onto problems involving dynamical systems, without resorting to approximations or simplifications. Exploiting symmetries, one can extend the "local" knowledge of a set of feasible trajectories, and possibly of locally stabilizing control laws, to achieve global goals. As shown in the example, the method can be successfully applied to very complicated, realistic models of challenging dynamical systems, such as small aerobatic helicopters.</p><p>Future work will include a more detailed treatment of the robustness issues associated with the application of the proposed framework to systems characterized by uncertainty in the dynamics and environmental disturbances. As long as the uncertainties and disturbances can be modeled as being invariant under the action of the group , most of the properties of Maneuver Automata and of the corresponding languages are indeed preserved.</p><p>Another direction of future work includes the analysis of the suboptimality gap induced by reducing feasible trajectories to the sequential combination of motion primitives. This will lead to an accurate tradeoff between the complexity of the MA language, and consequently, of the algorithms defined on it, and the achievable performance. For example, it is of interest to quantify the maximum penalty which must be accepted, given a certain set of motion primitives. Conversely, it is of interest to determine the optimal (e.g., minimal) choice of motion primitives which guarantee a certain optimality gap.</p><p>Emilio Frazzoli (S'99-A'01) received the Laurea degree in aerospace engineering from the University of Rome "La Sapienza," Rome, Italy, in 1994, and the Ph.D. degree in navigation and control systems from the Massachusetts Institute of Technology, Cambridge, in 2001.</p><p>Between 1994 and 1997 he was an officer in the Italian Navy, and a spacecraft dynamics specialist with the European Space Agency, Darmstadt, Germany, and Telespazio, Rome, Italy. From 2001 to 2004, he was an Assistant Professor of Aerospace Engineering with the University of Illinois at Urbana-Champaign. Since 2004, he has been an Assistant Professor of Mechanical and Aerospace Engineering with the University of California, Los Angeles. His current research interests include algorithmic, computational, and geometric approaches to the design and development of decision and control architectures for complex networked and autonomous systems, in aerospace and other domains. Application areas include distributed cooperative control of multiple vehicle systems, guidance and control of agile vehicles, high-confidence software engineering for high-performance dynamical systems, and verification of hybrid systems.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Example of a digraph representing an MA.</figDesc><graphic coords="4,344.16,65.50,168.00,134.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Maneuver example. Transition from hover to forward flight at 15 m/s (top). The helicopter is shown at intervals of 0.25 s.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Maneuver example. Transition from forward flight at 15 m/s to steady turning flight to the left, at a turning rate of 30 /s and a velocity of 15 m/s.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig.<ref type="bibr" target="#b3">4</ref>. Roll and pitch angle history during the execution of the motion plan p = (efef; [1; 2; 1; 2; 0]). The shaded bands identify maneuver execution times (the maneuver id is reported at the bottom left of each band).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Control input history during the execution of the motion plan p = (efef; [1; 2; 1; 2; 0]).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>before the turn. (According to the simulation, the vehicle loses 3 m of altitude in the course of the ag turn maneuver.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. Improved motion plan for the example problem.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Optimal motion plan for the example problem.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the authors and do not necessarily reflect the views of the sponsoring agencies.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper was recommended for publication by Associate Editor K. Lynch and Editor H. Arai upon evaluation of the reviewers' comments. This work was supported in part by the National Science Foundation under Grant CCR-0133869.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Munther A. Dahleh (F'00) was born in 1962. He received the B.S. degree from Texas A &amp; M University, College Station, TX, in 1983, and the Ph.D. degree from Rice University, Houston, TX, in 1987, all in electrical engineering.</p><p>Since then, he has been with the Department of Electrical Engineering and Computer Science, Massachusetts Institute of Technology, Cambridge, where he is now a full Professor. He was a Visiting Professor with the Department of Electrical Engineering, California Institute of Technology, Pasadena, CA, during the spring of 1993. He has held consulting positions with several companies in the U.S. and abroad. His research interests include problems at the interface of robust control, filtering, information theory, and computation, which include control problems with communication constraints and distributed mobile agents with local decision capabilities. He is also interested in model-reduction problems for discrete-alphabet hidden Markov models, universal learning approaches for systems with both continuous and discrete alphabets, and in providing an anatomically consistent model of the motor control system.</p><p>Dr. Dahleh was the recipient of the Ralph Budd award in 1987 for the best thesis at Rice University, the George Axelby outstanding paper award (paper coauthored with J. B. Pearson in 1987), an NSF Presidential Young Investigator Award (1991), the Finmeccanica Career Development Chair (1992), the Donald P. Eckman award from the American Control Council in 1993, the Graduate Students Council teaching award in 1995, and the George Axelby outstanding paper award (paper coauthored with Bamieh and Paganini in 2004).</p><p>Eric Feron is an Associate Professor of Aeronautics and Astronautics with the Laboratory for Information and Decision Systems, Massachusetts Institute of Technology, Cambridge. His research interests include optimization and control theory and their applications to aerial robotics, air transportation and software engineering. His latest book is a translation of Etienne Bézout's General Theory of Algebraic Equations, which sets the foundation for modern linear algebraic techniques in polynomial optimization theory. His latest research achievements include autonomous aerobatic flight of small helicopters and a natural language interface to unmanned aerial vehicles (built with Teragram Corporation and Boeing).</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">E</forename><surname>Bryson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">C</forename><surname>Ho</surname></persName>
		</author>
		<title level="m">Applied Optimal Control</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Hemisphere</publisher>
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Sastry</surname></persName>
		</author>
		<title level="m">Nonlinear Systems: Analysis, Stability, and Control</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">10</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Aggressive maneuvering of small autonomous helicopters: A human-centered approach</title>
		<author>
			<persName><forename type="first">V</forename><surname>Gavrilets</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Frazzoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mettler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Piedmonte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Feron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Robot. Res</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="795" to="807" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Stabilizing a linear system with quantized state feedback</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F</forename><surname>Delchamps</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Autom. Control</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="916" to="926" />
			<date type="published" when="1990-08">Aug. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Steering driftless nonholonomic systems by control quanta</title>
		<author>
			<persName><forename type="first">A</forename><surname>Marigo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bicchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Conf. Decision Control</title>
		<meeting>IEEE Conf. Decision Control</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="4164" to="4169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Quantized feedback stabilization of linear systems</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Brockett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Liberzon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Autom. Control</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1279" to="1289" />
			<date type="published" when="2000-06">Jun. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Stabilization of linear systems with limited information</title>
		<author>
			<persName><forename type="first">N</forename><surname>Elia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Mitter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Autom. Control</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1384" to="1400" />
			<date type="published" when="2001-09">Sep. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Formal languages for motion description and map making</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Brockett</surname></persName>
		</author>
		<editor>Robotics, R. W. Brockett</editor>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Amer. Math. Soc</publisher>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="181" to="193" />
			<pubPlace>Ed. Providence, RI</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Languages, behaviors, hybrid architectures and motion control</title>
		<author>
			<persName><forename type="first">V</forename><surname>Manikonda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Krishnaprasad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hendler</surname></persName>
		</author>
		<editor>Mathematical Control Theory, J. Bailleul and J. C. Willems</editor>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Springer</publisher>
			<biblScope unit="page" from="199" to="226" />
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Feedback can reduce the specification complexity of motor programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Egerstedt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Brockett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Autom. Control</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="213" to="223" />
			<date type="published" when="2003-02">Feb. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">On the structural complexity of the motion description language MDLe</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hristu-Varsakelis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Egerstedt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Krishnaprasad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Conf. Decision Control</title>
		<meeting>IEEE Conf. Decision Control<address><addrLine>Maui, HI</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="3360" to="3365" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Motion graphs</title>
		<author>
			<persName><forename type="first">L</forename><surname>Kovar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gleicher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pighin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graphics (Special Issue: Proc. ACM SIGGRAPH 2002)</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="473" to="482" />
			<date type="published" when="2002-07">Jul. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Real-time motion planning for agile autonomous vehicles</title>
		<author>
			<persName><forename type="first">E</forename><surname>Frazzoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Dahleh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Feron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AIAA J. Guid., Control, Dynam</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="116" to="129" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">On the reachability of quantized control systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bicchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Marigo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Piccoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Autom. Control</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="546" to="563" />
			<date type="published" when="2002-04">Apr. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">A Mathematical Introduction to Robotic Manipulation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Murray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sastry</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>CRC</publisher>
			<pubPlace>Boca Raton, FL</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Kinematic controllability for decoupled trajectory planning in underactuated mechanical systems</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bullo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Lynch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Robot. Autom</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="402" to="412" />
			<date type="published" when="2001-08">Aug. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Controllability of nonlinear systems</title>
		<author>
			<persName><forename type="first">H</forename><surname>Sussmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jurdjevic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Differential Equations</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="95" to="116" />
			<date type="published" when="1972-07">Jul. 1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Controllability of nonlinear discrete time systems: A Lie-algebraic approach</title>
		<author>
			<persName><forename type="first">B</forename><surname>Jakubczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">D</forename><surname>Sontag</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Control Optim</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="1" to="33" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Robust Hybrid Control for Autonomous Vehicle Motion Planning</title>
		<author>
			<persName><forename type="first">E</forename><surname>Frazzoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Massachusetts Inst. Technol</title>
		<imprint>
			<date type="published" when="2001-06">Jun. 2001</date>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Efficient inverse kinematics for general 6R manipulators</title>
		<author>
			<persName><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Canny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Robot. Autom</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="648" to="657" />
			<date type="published" when="1994-10">Oct. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Explicit solutions for optimal maneuver-based motion planning</title>
		<author>
			<persName><forename type="first">E</forename><surname>Frazzoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Conf. Decision Control</title>
		<meeting>IEEE Conf. Decision Control<address><addrLine>Maui, HI</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="3372" to="3377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Nonlinear model for a smallsize acrobatic helicopter</title>
		<author>
			<persName><forename type="first">V</forename><surname>Gavrilets</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mettler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Feron</surname></persName>
		</author>
		<idno>AIAA-2001-4333</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. AIAA Guid., Navig., Control Conf</title>
		<meeting>AIAA Guid., Navig., Control Conf<address><addrLine>Montreal, QC, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Trajectory tracking control design for autonomous helicopters using a backstepping algorithm</title>
		<author>
			<persName><forename type="first">E</forename><surname>Frazzoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dahleh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Feron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Amer. Control Conf</title>
		<meeting>Amer. Control Conf<address><addrLine>Chicago, IL</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="4102" to="4107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Invariant tracking and stabilization: Problem formulation and examples</title>
		<author>
			<persName><forename type="first">P</forename><surname>Rouchon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rudolph</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Stability and Stabilization of Nonlinear Systems</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Aeyels</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Lamnabhi-Lagarrigue</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Van Der Schaft</surname></persName>
		</editor>
		<meeting><address><addrLine>London, U.K.</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">246</biblScope>
			<biblScope unit="page" from="261" to="273" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
