<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Founding Cryptography on Oblivious Transfer -Efficiently</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yuval</forename><surname>Ishai</surname></persName>
							<email>yuvali@cs.technion.il</email>
							<affiliation key="aff0">
								<orgName type="institution">Technion</orgName>
								<address>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Los Angeles</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Manoj</forename><surname>Prabhakaran</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">University of Illinois</orgName>
								<address>
									<settlement>Urbana-Champaign</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Amit</forename><surname>Sahai</surname></persName>
							<email>sahai@cs.ucla.edu</email>
							<affiliation key="aff3">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Los Angeles</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Founding Cryptography on Oblivious Transfer -Efficiently</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">7DF25EB5B212CCD91F8DF8849C610CDA</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:40+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present a simple and efficient compiler for transforming secure multi-party computation (MPC) protocols that enjoy security only with an honest majority into MPC protocols that guarantee security with no honest majority, in the oblivious-transfer (OT) hybrid model. Our technique works by combining a secure protocol in the honest majority setting with a protocol achieving only security against semi-honest parties in the setting of no honest majority.</p><p>Applying our compiler to variants of protocols from the literature, we get several applications for secure two-party computation and for MPC with no honest majority. These include:</p><p>-Constant-rate two-party computation in the OT-hybrid model. We obtain a statistically UC-secure two-party protocol in the OT-hybrid model that can evaluate a general circuit C of size s and depth d with a total communication complexity of O(s) + poly(k, d, log s) and O(d) rounds. The above result generalizes to a constant number of parties.</p><p>-Extending OTs in the malicious model. We obtain a computationally efficient protocol for generating many string OTs from few string OTs with only a constant amortized communication overhead compared to the total length of the string OTs.</p><p>-Black-box constructions for constant-round MPC with no honest majority. We obtain general computationally UC-secure MPC protocols in the OT-hybrid model that use only a constant number of rounds, and only make a black-box access to a pseudorandom generator. This gives the first constant-round protocols for three or more parties that only make a black-box use of cryptographic primitives (and avoid expensive zero-knowledge proofs).</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Secure multiparty computation (MPC) <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b22">22,</ref><ref type="bibr" target="#b42">40]</ref> allows several mutually distrustful parties to perform a joint computation without compromising, to the greatest extent possible, the privacy of their inputs or the correctness of the outputs. MPC protocols can be roughly classified into two types: <ref type="bibr" target="#b0">(1)</ref> ones that only guarantee security in the presence of an honest majority, and (2) ones that guarantee security<ref type="foot" target="#foot_0">1</ref> against an arbitrary number of corrupted parties.</p><p>A qualitatively important advantage of protocols of the second type is that they allow each party to trust nobody but itself. In particular, this is the only type of security that applies to the case of secure two-party computation. Unfortunately, despite the appeal of such protocols, their efficiency significantly lags behind known protocols for the case of an honest majority. (For the potential efficiency of the latter, see the recent practical application of MPC in Denmark <ref type="bibr" target="#b4">[5]</ref>.) This is the case even when allowing parties to use idealized cryptographic primitives such as bit commitment and oblivious transfer.</p><p>In this work we revisit the problem of founding secure two-party computation and MPC with no honest majority on oblivious transfer. Oblivious transfer (OT) <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b40">38]</ref> is a two-party protocol that allows a receiver to obtain one out of two strings held by a sender, without revealing to the sender the identity of its selection. More precisely, OT is a secure implementation of the functionality which takes inputs s 0 , s 1 from the sender and a choice bit b from the receiver, and outputs s b to the receiver. Kilian <ref type="bibr" target="#b35">[33]</ref> showed how to base general secure two-party computation on OT. Specifically, Kilian's result shows that given the ability to call an ideal oracle that computes OT, two parties can securely compute an arbitrary function of their inputs with unconditional security. We refer to secure computation in the presence of an ideal OT oracle as secure computation in the OT-hybrid model. Kilian's result was later generalized to the multi-party setting (see <ref type="bibr" target="#b14">[15]</ref> and the references therein). Unfortunately, these constructions are quite inefficient and should mainly be viewed as feasibility results.</p><p>When revisiting the problem of basing cryptography on OT, we take a very different perspective from the one taken in the original works. Rather than being driven primarily by the goal of obtaining unconditional security, we are mainly motivated by the goal of achieving better efficiency for MPC in "the real world", when unconditional security is typically impossible or too expensive to achieve.<ref type="foot" target="#foot_1">2</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Advantages of OT-based cryptography.</head><p>There are several important advantages to basing cryptographic protocols on oblivious transfer, as opposed to concrete number-theoretic or algebraic assumptions.</p><p>-Preprocessing. OTs can be pre-computed in an off-line stage, before the actual inputs to the computation or even the function to be computed are known, and later very cheaply converted into actual OTs <ref type="bibr" target="#b0">[1]</ref>. -Amortization. The cost of pre-computing OTs can be accelerated by using efficient methods for extending OTs <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b28">27,</ref><ref type="bibr" target="#b30">29]</ref>. In fact, the results of the current paper imply additional improvement to the asymptotic cost of extending OTs, and thus further strengthen this motivation. -Security. OTs can be realized under a variety of computational assumptions, or even with unconditional security under physical assumptions. (See <ref type="bibr" target="#b39">[37]</ref> for efficient realizations of UC-secure OT in the CRS model under various standard assumptions.) Furthermore, since the methods for extending OTs discussed above only require protocols to use a relatively small number of OTs, one could potentially afford to diversify assumptions by combining several candidate OT implementations <ref type="bibr" target="#b29">[28]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Our Results</head><p>Motivated by the efficiency gap between the two types of MPC discussed above, we present a simple and efficient general compiler that transforms MPC protocols with security in the presence of an honest majority into secure two-party protocols in the OT-hybrid model. More generally and precisely, our compiler uses the following two ingredients:</p><p>-An "outer" MPC protocol Π with security against a constant fraction of malicious parties. This protocol may use secure point-to-point and broadcast channels. It realizes a functionality f whose inputs are received from and whose outputs are given to two distinguished parties. -An "inner" two-party protocol ρ for a (typically simple) functionality g Π defined by the outer protocol, where the security of ρ only needs to hold against semi-honest parties. The protocol ρ can be in the OT-hybrid model.</p><p>The compiler yields a two-party protocol Φ Π,ρ which realizes the functionality f of the outer protocol with security against malicious parties in the OT-hybrid model. If the outer protocol Π is UC-secure <ref type="bibr" target="#b8">[9]</ref> (as is the case for most natural outer protocols) then so is Φ Π,ρ . It is important to note that Φ Π,ρ only makes a black-box use of the outer protocol Π and the inner protocol ρ, <ref type="foot" target="#foot_2">3</ref> hence the term "compiler" is used here in a somewhat unusual way. This black-box flavor of our compiler should be contrasted with the traditional GMW compiler <ref type="bibr" target="#b21">[21,</ref><ref type="bibr" target="#b22">22]</ref> for transforming a protocol with security in the semi-honest model into a protocol with security in the malicious model. Indeed, the GMW compiler needs to apply (typically expensive) zero-knowledge proofs that depend on the code of the protocol to which it applies. Our compiler naturally generalizes to yield MPC protocols with more than two parties which are secure (in the OT-hybrid model) in the presence of an arbitrary number of malicious parties.</p><p>Combining our general compiler with variants of protocols from the literature, we get several applications for secure two-party computation and MPC with no honest majority.</p><p>Revisiting the classics. As a historically interesting example, one can obtain a conceptually simple derivation of Kilian's result <ref type="bibr" target="#b35">[33]</ref> by using the BGW protocol <ref type="bibr" target="#b3">[4]</ref> (or the CCD protocol <ref type="bibr" target="#b10">[11]</ref>) as the outer protocol, and the simple version of the GMW protocol in the semi-honest OT-hybrid model <ref type="bibr" target="#b21">[21,</ref><ref type="bibr" target="#b22">22,</ref><ref type="bibr" target="#b23">23]</ref> as the inner protocol. In fact, since the outer protocol is not required to provide optimal resilience, the BGW protocol can be significantly simplified. The resulting protocol has the additional benefits of providing full simulation-based (statistical) UC-security and an easy generalization to the case of more than two parties.</p><p>Constant-rate two-party computation in the OT-hybrid model. Using a variant of an efficient MPC protocol of Damgård and Ishai <ref type="bibr" target="#b16">[17]</ref> combined with secret sharing based on algebraic geometric codes due to Chen and Cramer <ref type="bibr" target="#b11">[12]</ref> as the outer protocol, we obtain a statistically UC-secure two-party protocol in the OT-hybrid model that can evaluate a general circuit C of size s with a total communication complexity of O(s). (For simplicity, we ignore from here on additive terms that depend polynomially on the security parameter k, the circuit depth, and log s. These terms become dominated by the leading term in most typical cases of large circuits.) This improves over the O(k 3 s) complexity of the best previous protocol of Crépeau et al. <ref type="bibr" target="#b14">[15]</ref>, and matches the best asymptotic complexity in the semi-honest model.</p><p>By using preprocessing to pre-compute OTs on random inputs, the protocol in the OT-hybrid model gives rise to a (computationally secure) protocol of comparable efficiency in the plain model. Following off-line interaction that results in each party storing a string of length O(s), the parties can evaluate an arbitrary circuit of size s on their inputs using O(s) bits of communication and no cryptographic computations. Note that the preprocessing stage can be carried out offline, before the actual inputs are available or even the circuit C is known. Furthermore, the cost of efficiently implementing the off-line stage can be significantly reduced by using techniques for amortizing the cost of OTs on which we improve. The above results extend to the case of more than two parties, with a multiplicative overhead that grows polynomially with the number of parties.</p><p>Unlike two-party protocols that are based on Yao's garbled circuit method <ref type="bibr" target="#b42">[40]</ref>, the above protocols cannot be implemented in a constant number of rounds and require O(d) rounds for a circuit of depth d. It seems that in most typical scenarios of large-scale secure computation, the overall efficiency benefits of our approach can significantly outweigh its higher round-complexity.</p><p>Extending OTs in the malicious model. Somewhat unexpectedly, our techniques for obtaining efficient cryptographic protocols which rely on OT also yield better protocols for realizing the OTs consumed by the former protocols. This is done by using an outer protocol that efficiently realizes a functionality which implements many instances of OT. More concretely, we obtain a protocol for generating many OTs from few OTs whose amortized cost in communication and cryptographic computation is a constant multiple of the efficient protocol for the semi-honest model given by Ishai, Kilian, Nissim, and Petrank <ref type="bibr" target="#b30">[29]</ref>. Using the protocol from <ref type="bibr" target="#b30">[29]</ref> inside the inner protocol, we can upgrade the security of this OT extension protocol to the malicious model with only a constant communication and cryptographic overhead. This improves over a recent result from <ref type="bibr" target="#b28">[27]</ref> that obtains similar efficiency in terms of the number of hash functions being invoked, but worse asymptotic communication complexity. Our OT extension protocol can be used for efficiently implementing the off-line precomputation of all the OTs required by our protocols in the OT-hybrid model.</p><p>Black-box constructions for constant-round MPC with no honest majority. We combine our general compiler with a variant of a constant-round MPC protocol of Damgård and Ishai <ref type="bibr" target="#b15">[16]</ref> to obtain general computationally UCsecure MPC protocols in the OT-hybrid model that use only a constant number of rounds, and only make a black-box access to a pseudorandom generator. This provides a very different alternative to a similar result for the two party case that was recently obtained by Lindell and Pinkas <ref type="bibr" target="#b37">[35]</ref>, and gives the first constantround protocols for three or more parties that only make a black-box use of cryptographic primitives (and avoid expensive zero-knowledge proofs).</p><p>Additional results. In Section 5 we describe two additional applications: a constant-rate black-box construction of OT for malicious parties from OT for semi-honest parties (building on a recent black-box feasibility result of <ref type="bibr" target="#b27">[26,</ref><ref type="bibr" target="#b33">31]</ref>), and a construction of asymptotically optimal OT combiners <ref type="bibr" target="#b29">[28]</ref> (improving over <ref type="bibr" target="#b28">[27]</ref>). In the full version we present a two-party protocol in the OT-hybrid model that uses only a single round of OTs and no additional interaction. (This applies to functionalities in which only one party receives an output.) The protocol only makes n + o(n) OT calls, where n is the size of the input of the party which receives the output.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Techniques</head><p>Our main compiler was inspired by the "MPC in the head" paradigm introduced by Ishai, Kushilevitz, Ostrovsky, and Sahai <ref type="bibr" target="#b34">[32]</ref> and further developed by Harnik, Ishai, Kushilevitz, and Nielsen <ref type="bibr" target="#b28">[27]</ref>. These works introduced the idea of having parties "imagine" the roles of other parties taking part in an MPC (which should have honest majority), and using different types of cross-checking to ensure that an honest majority really is present in the imagined protocol. Our approach is similar to the construction of OT combiners from <ref type="bibr" target="#b28">[27]</ref> in that it uses an outer MPC protocol to add privacy and robustness to an inner two-party protocol which may potentially fail. <ref type="foot" target="#foot_3">4</ref> A major difference, however, is that our approach provides security in the malicious model while only requiring the inner protocol to be secure in the semi-honest model.</p><p>The central novelty in our approach is a surprisingly simple and robust enforcement mechanism that we call the "watchlist" method (or more appropriately, the oblivious watchlist method). In describing our approach, we will refer for simplicity to the case of two-party computation involving two "clients" A and B. In our compiler, an outer MPC protocol requiring an honest majority of servers is combined with an inner two-party computation protocol with security against only semi-honest adversaries. This is done by having the outer MPC protocol jointly "imagined" by the two clients. Each server's computation is jointly simulated by the two clients, using the inner semi-honest two-party protocol to compute the next-message-functions for the servers. The only method we use to prevent cheating is that both clients maintain a watchlist of some fraction of the servers, such that client A will have full knowledge of the internal state of all servers in A's watchlist, while client B has no idea which servers are on A's watchlist. Then client A simply checks that the watchlisted servers behave as they should in the imagined outer MPC protocol. If a dishonest client tries to cheat for too many servers, then he will be caught because of the watchlist with overwhelming probability. On the other hand, since the outer MPC protocol is robust against many bad servers, a dishonest client must attempt to cheat in the computation of many servers in order to be able to gain any unfair advantage in the execution of the protocol. Our watchlist-based method for enforcing honest behavior should be contrasted with the non-black-box approach of the GMW compiler <ref type="bibr" target="#b22">[22]</ref> that relies on zero-knowledge proofs.</p><p>It is instructive to contrast our approach with "cut-and-choose" methods from the literature. In standard cut-and-choose protocols, one party typically prepares many instances of some object, and then the other party asks for "explanations" of several of these objects. A central difficulty in such an approach is to prevent the compromised instances from leaking information about secrets, while combining the un-compromised instances in a useful way (see e.g. <ref type="bibr" target="#b37">[35]</ref>). In contrast, our approach achieves these goals seamlessly via the privacy and robustness of the outer MPC protocol. To see how our approach leads to efficiency improvements as well, we will make an analogy to error-correcting codes. In traditional cut-and-choose, one has to prepare many copies of an object that will only be used once, analogous to a repetition-based error-correcting code. Underlying our approach are the more sophisticated error-correcting codes that can be used in MPC protocols in the honest majority setting. While we have to sacrifice some working components (our servers) due to the watchlists, the others perform useful work that is not wasted, and this allows us to get more "bang for the buck", especially in settings where amortization is appropriate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>Model. We use the Universal Composition (UC) framework <ref type="bibr" target="#b8">[9]</ref>, although our protocols can also be instantiated in the stand-alone setting using the composability framework of <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b21">21]</ref>. The parties in the protocols have access to (private, point-to-point) communication channels, as well as possibly one or more ideal functionalities such as OT or broadcast.</p><p>Oblivious Transfer. The basic oblivious transfer primitive we rely on is a 2 1 string-OT, referred to as OT. Below we will also employ q 1 string-OT. There are efficient and unconditionally UC-secure reductions with constant communication overhead of these primitives to 2  1 bit-OT (implicit in <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b17">18]</ref>). Hence, one could also assume bit-OT as our basic primitive. When settling for computational security, OT on long strings can be efficiently reduced to a single instance of OT on short strings via the use of a pseudorandom generator.</p><p>Our watchlist initialization protocol will use Rabin string-OT, which delivers an input string from the sender to the receiver with a fixed probability δ. We point out how a Rabin-string-OT with rational erasure probability p/q (for positive integers p &lt; q) can be securely realized using q 1 string-OT with constant communication overhead. The sender inputs q strings to the q 1 string-OT, of which a random subset of p are the message being transferred and the rest are arbitrary (say the zero string); the receiver picks up one of the q strings uniformly at random; then the sender reveals to the receiver which p-sized subset had the string being transferred; if the receiver picked a string not belonging to this set, it outputs erasure, and else outputs the string it received. <ref type="foot" target="#foot_4">5</ref>Our model of OT is asynchronous: multiple OT's executed in the same round can be executed in an arbitrary, adversarially controlled order. (We note, however, that synchronous OT can be easily and efficiently reduced to asynchronous OT via simultaneous message exchange.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Protocol Compiler</head><p>In this section we describe how to build a protocol Φ OT Π,ρ that securely realizes a functionality F against active corruptions, using two component protocols Π and ρ OT of weaker security. Π is a protocol for F itself, but uses several servers and depends on all but a constant fraction of them being honest. ρ OT is a protocol for a functionality G (which depends on Π), but is secure only against passive corruptions. Below we describe the requirements on Π, ρ OT and the construction of Φ OT Π,ρ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The Outer Protocol Π</head><p>Π is a protocol among n + m parties (we will use n = Θ(m 2 k), k being the security parameter for Π), with m parties C i (i = 1, . . . , m) designated as the clients, and the other parties P j (i = 1, . . . , n) designated as the servers.</p><p>-Functionality: Π is a protocol for some functionality F (which could be deterministic or randomized, and possibly reactive) among the m clients. The servers do not have any inputs or produce any outputs.</p><p>-Security: Π UC-securely realizes the functionality F , against adaptive corruption of up to t servers, and either static or adaptive corruption of any number of clients (see Remark 2). We assume static client corruption by default. We will require t = Ω(n). The corruptions are active (i.e., the corrupt parties can behave arbitrarily) and the security could be statistical or computational.</p><p>-Protocol Structure: The protocol Π proceeds in rounds where in each round each party sends messages to the other parties (over secure point-to-point channels) and updates its state by computing on its current state, and then also incorporates the messages it receives into its state. Each server P j maintains a state Σ j . For the sake of an optimization in our applications, we will write Σ j as (σ j , μ 1↔j , . . . , μ m↔j ), where μ i↔j is just the collection of messages between C i and P j . We will refer to μ i↔j as the "local" parts of the state and σ j as the "non-local" part of the state. Note that client C i is allowed to know the local state μ i↔j of each server P j .</p><p>The servers' program in Π is specified by a (possibly randomized) function π which takes as input a server's current state and incoming messages from clients and servers, and outputs an updated state as well as outgoing messages for the clients and other servers. That is,</p><formula xml:id="formula_0">6 π(σ j ; μ j ; w •→j ; u •→j ) → (σ j , m j→• , u j→• ).</formula><p>where μ j = (μ 1↔j , . . . , μ m↔j ) is the vector of local states, w •→j = (w 1→j , . . . , w m→j ) is messages received in this round by server P j from the clients, and similarly u •→j = (u 1→j , . . . , u n→j ) is the set of messages P j received from the other servers. The outputs m j→• = (m j→1 , . . . , m j→m ) and u j→• = (u j→1 , . . . , u j→n ) stand for messages to be sent by P j to the clients and to the servers respectively. The output σ j is the updated (non-local) state of the server P j . The local states are updated (by definition) as</p><formula xml:id="formula_1">μ i↔j := μ i↔j • (w i→j , m j→i ).</formula><p>Finally, if Π is in the broadcast-hybrid model, one can efficiently implement each broadcast by having the broadcasting party send the message to all clients. While this isn't equivalent to broadcast in the MPC model, our compiler will provide robustness against inconsistent messages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Inner Functionality G and the Inner Protocol ρ OT</head><p>We define a (possibly randomized) m-party functionality G j which will be used to "implement" server P j by the clients C i (i = 1, . . . , m). G j works as follows:</p><p>-From each client C i get input (S i , M i , μ i↔j , w i→j ), where S i will be considered an additive share of the non-local state σ j of the server P j , and M i an additive share of u •→j , all the messages received by P j from the other servers in the previous round. <ref type="foot" target="#foot_6">7</ref>-Compute S 1 + . . . + S m , and M 1 + . . . + M m to reconstruct σ j and u •→j . Evaluate π (as given in the above displayed equation) to obtain (σ j , m j→• , u j→• ).</p><p>-To C i give output (S i , m j→i , M i ) where (S 1 , . . . , S m ) form a random additive sharing of the updated state σ j and (M 1 , . . . , M m ) form a random additive sharing of the messages to the servers u j→• .</p><p>We will need a protocol ρ OT (in the OT-hybrid model) to carry out this computation. But the security requirement on this protocol is quite mild: ρ OT securely realizes G j against passive corruption (i.e., honest-but-curious adversaries). The security could be statistical or computational. Also, the security could be against adaptive corruption or static corruption.</p><p>In all our applications, we shall exploit an important optimization in an inner protocol to implement G j . Suppose an invocation of π (i.e., for some server P j and some round number) depends only on the local state μ i↔j and possibly w i→j , does not change the state σ j , and is deterministic. We call such a computation a type I computation (all other computations are called type II computations). A simple secure implementation of G j for type I computations involves the client C i computing (m j→• , u j→• ) itself, and sending each client C i as output (X i , m j→i , M i ) for each party, where X i is a random sharing of 0 and M i is a random sharing of u j→• . The client C i sets S i := S i + X i . (This last step of adding a share of 0 is in fact redundant in our compiled protocol; we include it only for the sake of modular exposition.)</p><p>Thus what the compiler needs to be given as the inner protocol is an implementation of G j only for type II computations. Then it is the computational complexity of type II computations that will be reflected in the communication complexity of the compiled protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">The Compiled Protocol</head><p>At a high-level, the compiled protocol Φ OT Π,ρ has the following structure. 1. Watchlists initialization: Using OT, the following infrastructure is set up first: each honest client randomly chooses a set of k servers to put on its watchlist (which only that client knows). For each client i and server P j there is a "watchlist channel" W ij such that any of the clients can send a message in W ij , and client C i will receive this message if and only if server P j is on its watchlist. As we shall see, the implementation of this will allow a corrupt client to gain access (albeit partial) to the watchlist channels of more than k servers. Nevertheless, we note that the total number of servers for which the adversary will have access to the watchlist channel will be O(km 2 ) &lt; t/2.</p><p>We shall also require another variant of watchlist channel (that can be set up on top of the above watchlist channel infrastructure): for each server P j there is a "watchlist broadcast channel" W j such that any client can send a message on W j and all the clients who have server P j on their watchlists will receive this message. (Note that when there are only two clients, this variant is no different from the previous one.)</p><p>If the adversary has access to the watchlist channel for server P j , then we allow the adversary to learn which other clients have access to their watchlist channels for server P j . Jumping ahead, we remark that in this case we will consider server P j as corrupted. By the choice of parameters this will corrupt at most t/2 servers (except with negligible probability).</p><p>2. Simulating the execution of Π: Each client C i plays the role of C i in Π. In addition, the clients will themselves implement the servers in Π as follows. At the beginning of each round of Π, the clients will hold a secret sharing of the state of each server. Then they will use the inner protocol to execute the server's next-message and state-evolution functions and update the shared state.</p><p>The purpose of the watchlists is two-fold: firstly it is used to force (to some extent) that the clients do not change their inputs to the inner protocol between invocations; secondly it is used to force honest behavior within the inner protocol executions. The actual use of watchlists is quite simple:</p><p>(a) To enforce consistency between invocations of the inner protocol, each client C i is required to report over the watchlist broadcast channel W j every message that it provides as input to or receives as output from every invocation of the inner protocol for G j . (b) To enforce honest behavior within the protocol execution, each client is required to report over watchlist channels W ij (for all i) every message that it receives within the invocation of the inner protocol for G j . Further, for each invocation of the inner protocol j, the watchlist broadcast channel W j is used to carry out a "coin-tossing into the well" to generate the coins for each client to be used in that protocol. (This coin-tossing step is not necessary when certain natural protocols with a slightly stronger security guarantee -like the basic "passive-secure" GMW protocol in the OT-hybrid model -are used. See Remark 1 below.)</p><p>Any honest client who has server P j in its watchlist must check that the reported values from all clients are according to the protocol and are consistent with the other messages received in the protocol. Note that at the beginning of the execution of the inner protocol, all clients are already committed to their inputs and randomness during the protocol. Further, all honest clients honestly report the messages received from the other protocols. As such a client watching server P j has an almost complete view of the protocol execution, and it knows ahead of time exactly what messages should be reported over the watchlist channels in an honest execution. This is sufficient to catch any deviation in the execution, if the protocol uses only communication channels. However, if the protocol involves the use of OT channels (or more generally, other ideal functionalities) then it creates room for an adversary to actively cheat and possibly gain an advantage over passive corruption. Then the adversary can change its inputs to the OT functionality without being detected (or arrange the probability of being detected to depend on the inputs of honest clients). To prevent this kind of cheating, we shall force that if the adversary changes its input to the OT functionality, then with at least a constant probability this will produce a different output for an honest client (if the adversary is the sender in the OT), or (if the adversary is the receiver in the OT) the adversary will end up reporting a different output over the watchlist. This is easily enforced by using a simple standard reduction of OT to OT with random inputs from both parties.</p><p>Remark 1 (On tossing coins.). A protocol which is secure against passive corruptions is not necessarily secure when the adversary can maliciously choose the random tape for the corrupt players. This is the reason our compiler needs to use a coin-tossing in the well step to generate the coins for the inner protocols. However, most natural protocols remain secure even if the adversary can choose the coins. This is the case for perfectly secure protocols like the basic "passivesecure" GMW protocol (in the OT-hybrid model). When using such an inner protocol, the compiler can simply omit the coin-tossing into the well step.</p><p>Setting up the Watchlist Channels and Broadcast Channels. First we describe how the watchlist channels described above are set up using OTs, and then how to obtain watchlist broadcast channels using them. The basic idea is for the clients to pick up sufficiently long one-time pads from each other using OT, and later send messages masked with a fresh part of these one-time pads.</p><p>For this we shall be using Rabin-string-OT (i.e., erasure channel with a fixed erasure probability, and adequately long binary strings being the alphabet). See Section 2 for implementation details.</p><p>The construction of the watchlist channels is as follows: First each client randomly chooses a set of k servers to put on its watchlist. Next, each pair of clients (i , i) engages in n instances of δ-Rabin-string-OTs where client C i sends a random string r j (of length ) to C i . By choice of δ = Ω(k/n), we ensure that except with negligible probability C i obtains the string in more than k of the n instances. (By the union bound, this will hold true simultaneously for all pairs (i , i), except with negligible probability.) Now, client C i specifies to client C i a random permutation σ on [n] conditioned on the following: if j is in the watchlist of C i and σ(j) = j , then r j was received by C i . Now, to send a message on the watchlist channel W ij , the client C i will use (a fresh part of) r σ(j) to mask the message and send it to C i . Note that if j is in the watchlist of client C i , then this construction ensures that C i can read all messages sent on W ij by any client. If the strings r j are bits long then at most bits can be sent to the watchlist channel constructed this way.</p><p>Finally, we consider obtaining watchlist broadcast channel W j from watchlist channels W ij set up as above. This is similar to how broadcast is obtained from point-to-point channels in <ref type="bibr" target="#b25">[24]</ref>. To send a message on W j first a client sends the message on W ij for every i. Then each client C i on receiving a message on a watchlist channel W ij sends it out on W i j for every i = i. (If C i does not have access to W ij , it sends a special message (of the same length) to indicate this.) Then it checks if all the messages it receives in this step over W ij are the same as the message it received in the previous step, and if not aborts.</p><p>It can be verified that the above constructions indeed meet the specification of the watchlist infrastructure spelled out in the beginning of this section.</p><p>Theorem 1. Let F be a (possibly reactive) m-party functionality. Suppose Π is an outer MPC protocol realizing F , as specified in Section 3.1, with n = Θ(m 2 k) and t = Θ(k), for a statistical security parameter k. Let G be the functionality defined in Section 3.2 and ρ OT a protocol that securely realizes G in the OThybrid model against passive (static) corruptions. Then the compiled protocol Φ OT Π,ρ described above securely realizes F in the OT-hybrid model against active (static) corruptions. If both Π and ρ OT are statistically/computationally secure, then the compiled protocol inherits the same kind of security.</p><p>Φ OT Π,ρ has communication complexity poly(m)•(C Π +nr Π C ρ ), round complexity O(r Π r ρ ), and invokes OT poly(m)•nr Π q ρ times, where C Π is the communication complexity of Π, r Π is the number of rounds of Π, C ρ is the communication plus randomness complexity of ρ OT , r ρ is the round complexity of ρ OT , and q ρ is the number of invocations of OT in ρ OT .</p><p>Here by communication complexity of a protocol in the OT-hybrid model we include the communication with the OT functionality. By randomness complexity of a protocol we mean the total number of random bits used by (honest) parties executing the protocol. We remark that the complexity bounds given above can typically be tightened when analyzing specific inner and outer protocols.</p><p>Remark 2 (On adaptive security.). Above we assumed that the inner protocol ρ OT is secure against static corruptions, and Π is secure against static client corruptions (and up to t adaptive server corruptions). Then the compiled protocol Φ OT Π,ρ is secure against static corruptions. However, if ρ OT is secure against adaptive corruptions, depending on the security of Π we can get Φ OT Π,ρ to be secure against adaptive corruptions. If Π is secure against an adversary who can adaptively corrupt up to m -1 clients and up to t servers, then Φ OT Π,ρ is secure against adaptive corruption up to m -1 clients. All known constant-round protocols are restricted to this type of adaptive security, unless honest parties are allowed to erase data. If Π is secure against an adversary which could in addition, after the protocol execution ends, corrupt all the remaining honest clients and servers together, then Φ OT Π,ρ is secure against adaptive corruption of up to all m clients. This is the typical adaptive security feature of outer protocols whose round complexity depends on the circuit depth, and even of constant-round protocols if data erasure is allowed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof sketch:</head><p>The proof of security for our compiler follows from a conceptually very simple simulator. Full details will be given in the full version of this paper; here we sketch a high-level overview of how our simulator works. At a very high level, the simulator's job is very simple: Since it simulates the OT channels that the adversary uses in the protocol, the simulator will have full knowledge of everything that is sent over the watchlists, as well as in every invocation of OT used within the inner protocol. Thus, the simulator will know immediately if the adversary causes any of the imagined servers to behave dishonestly. It is easy to argue that if the adversary cheats with respect to any server that is on an honest party's watchlist, then it will be caught with constant probability (this is enforced in part by the reduction of OT to OT with random inputs). Since each honest party's watchlist is large, this shows that if the adversary causes too many servers to behave dishonestly, it will be caught by an honest party with overwhelming probability.</p><p>To make this formal, the simulator will invoke Sim outer , the simulator for the outer MPC protocol. The simulator will be allowed to corrupt up to t servers when interacting with Sim outer . When the simulator observes that the adversary is trying to cause dishonest behavior by some server, then it corrupts that server (thereby learning the state and history of that server, allowing the simulator to finish the interaction with the adversary and provide appropriate output to it). As argued above, if the adversary causes dishonest behavior in too many servers, it will get caught with overwhelming probability, and therefore our simulator will not need to exceed t corruptions. The only caveat here is if the adversary simultaneously tries to cause cheating in too many servers (e.g. all the servers at once). To deal with this situation, we ensure that the adversary is caught before it receives any output, and so we can simulate the interaction with the adversary before we have to corrupt the corresponding server in the outer protocol. This follows in a straightforward way from the way that the watchlists are used and the fact that OT's are only used with random inputs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Instantiating the Building Blocks</head><p>For concrete applications of our compiler, we need to choose outer and inner protocols to which the compiler can be applied. The requirements on these components can be considered much easier to meet than security against active corruption in the case of no honest majority. As such the literature provides a wide array of choices that we can readily exploit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Instances of the Outer Protocol.</head><p>For the purpose of feasibility results, the classical BGW protocol <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b8">9]</ref> can be used as the outer protocol. But in our applications, we shall resort to two efficient variants obtained from more recent literature <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17]</ref>. <ref type="foot" target="#foot_7">8</ref>Using a combination of <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b16">17]</ref> (as described below) a boolean circuit C of size s and depth d (with bounded fan-in) can be evaluated with a total communication complexity of O(s) + poly(n, k, d, log s) bits, where k is a statistical security parameter, for n servers and any constant number of clients. <ref type="foot" target="#foot_8">9</ref> The protocol requires O(d) rounds. For this protocol the only type II functions in the servers' program (see Section 3.1) consist of evaluating multiplications in a finite field F whose size is independent of the number of servers. (Here we do not consider linear functions over F, which can be handled "for free" by the inner protocol provided that the servers' states are additively shared over F among the clients.) The total number of multiplications computed by all servers throughout the protocol execution is O(s) + poly(n, d) (for any constant number of clients).</p><p>An MPC protocol as above can be obtained by combining a version of an MPC protocol from <ref type="bibr" target="#b16">[17]</ref> with algebraic geometric secret sharing over fields of constant size <ref type="bibr" target="#b11">[12]</ref>. <ref type="foot" target="#foot_9">10</ref> This combination directly yields a protocol with the above properties for NC 0 circuits, which was recently used in <ref type="bibr" target="#b34">[32]</ref> to obtain constantrate zero-knowledge proofs and in <ref type="bibr" target="#b28">[27]</ref> to obtain constant-rate OT combiners. In the full version we present the (natural) extension of this protocol that can be applied to arbitrary depth-d circuits, at the cost of requiring O(d) rounds.</p><p>Another useful instance of an outer protocol is obtained from the constantround protocol from <ref type="bibr" target="#b15">[16]</ref>, as described in Section 5.2. Unlike the previous constantround MPC protocol from <ref type="bibr" target="#b2">[3]</ref>, this protocol only makes a black-box use of a pseudorandom generator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Instances of the Inner Protocol.</head><p>The main choice of the inner protocol, which suffices for most of our applications, is the simple version of the GMW protocol <ref type="bibr" target="#b21">[21,</ref><ref type="bibr" target="#b22">22]</ref> that provides perfect security against a passive adversary in the OT-hybrid model. The communication complexity is O(m 2 s) where m is the number of clients and s is the size of the boolean circuit being evaluated (excluding XOR gates). The round complexity is proportional to the circuit depth (where here again, XOR gates are given for free). When evaluating functions in NC 1 (which will always be the case in our applications) the inner protocol can be implemented using a single round of OTs in the two-party case, or a constant number of rounds in the general case, without compromising unconditional security. This is done by using a suitable randomized encoding of the function being computed, e.g., one based on an unconditionally secure variant of Yao's garbled circuit technique <ref type="bibr" target="#b31">[30,</ref><ref type="bibr" target="#b42">40]</ref>. In the two-party case, the protocol needs to use only as many OTs as the length of the shorter input. This will be useful for some applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Applications</head><p>In this section we describe the main applications of our general compiler. These are mostly obtained by applying the compiler to variants of efficient MPC protocols and two-party protocols from the literature.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Constant-Rate Secure Computation in the OT-Hybrid Model</head><p>Our first application is obtained by instantiating the general compiler with the following ingredients. The outer protocol is the constant-rate MPC protocol described in Section 4. The inner protocol can be taken to be the "passive-secure GMW" protocol in the OT-hybrid model. The OTs required by the above protocol can be generated during a preprocessing stage at no additional cost. The above theorem extends to the case of a nonconstant number of parties m, in which case the communication complexity grows by a multiplicative factor of poly(m). The theorem applies also to reactive functionalities, by naturally extending the outer protocol to this case, and to randomized functionalities, provided that they are adaptively well-formed <ref type="bibr" target="#b9">[10]</ref> or alternatively if honest parties are trusted to erase data.</p><p>Finally, it can be extended to the case of arithmetic circuits (at the cost of settling for computational security) by using an inner protocol based on homomorphic encryption. We defer further details to the full version.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Black-Box Constructions for Constant-Round MPC with No Honest Majority</head><p>Traditional MPC protocols for the case of no honest majority followed the socalled GMW paradigm <ref type="bibr" target="#b21">[21,</ref><ref type="bibr" target="#b22">22]</ref>, converting protocols for the semi-honest model into protocols for the malicious model using zero-knowledge proofs. Since such proofs are typically expensive and in particular make a non-black-box use of the underlying cryptographic primitives, it is desirable to obtain alternative constructions that avoid the general GMW paradigm and only make a black-box use of standard cryptographic primitives. The protocols of <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b35">33]</ref> (as well as the more efficient constructions from Section 5.1) achieve this goal, but at the cost of round complexity that depends on the depth of the circuit. The question of obtaining constant-round protocols with the same features remained open.</p><p>In the case of MPC with honest majority, this problem was solved by Damgård and Ishai <ref type="bibr" target="#b15">[16]</ref>, providing a black-box alternative to a previous protocol of Beaver, Micali, and Rogaway <ref type="bibr" target="#b2">[3]</ref> that made a non-black-box use of a pseudorandom generator. The case of two-party computation was recently resolved by Lindell and Pinkas <ref type="bibr" target="#b37">[35]</ref> (see also <ref type="bibr" target="#b36">[34,</ref><ref type="bibr" target="#b38">36]</ref>), who presented a constant-round two-party protocol that makes a black-box use of (parallel) OT as well as a statistically hiding commitment. The question of extending this result to three or more parties remained open, as the technique of <ref type="bibr" target="#b37">[35]</ref> does not seem to easily extend to more than two parties. Partial progress in this direction was recently made in <ref type="bibr" target="#b26">[25]</ref>.</p><p>By applying our compiler to a variant of the MPC protocol from <ref type="bibr" target="#b15">[16]</ref>, we obtain the following theorem: Theorem 3. For any m ≥ 2 there exists an m-party constant-round MPC protocol in the OT-hybrid model which makes a black-box use of a pseudorandom generator and achieves computational UC-security against an active adversary which may adaptively corrupt at most m -1 parties.</p><p>Note that unlike the protocol of <ref type="bibr" target="#b37">[35]</ref> our protocol is UC-secure and does not rely on statistically hiding commitments. On the down side, it requires a larger number of OTs which is comparable to the circuit size rather than the input size, though the latter cost may be amortized using efficient methods for extending OTs (see Section 5.3) and moved to a preprocessing phase. We defer further optimizations of the protocol to the full version.</p><p>Proof sketch: The protocol from <ref type="bibr" target="#b15">[16]</ref> is a general constant-round protocol involving n servers and m clients. It is adaptively, computationally UC-secure against an adversary that may corrupt an arbitrary strict subset of the clients and a constant fraction of the servers. Furthermore, players in this protocol only make a blackbox use of a PRG, or alternatively a one-time symmetric encryption scheme. If all the invocations of the encryption scheme were done by clients, the claimed result would follow by directly applying our compiler with this protocol as the outer protocol (since local computations performed by clients remain unmodified by the compiler). While the protocol from <ref type="bibr" target="#b15">[16]</ref> inherently requires servers to perform encryptions, it can be easily modified to meet the form required by our compiler. This is done by making the servers only perform encryptions where both the key and the message to be encrypted are known to one of the clients. Using the watchlist approach, the protocol produced by the compiler will make the corresponding client perform the encryption instead of the server.</p><p>For simplicity, we describe this modification for the case of two clients, Alice and Bob. This easily generalizes to any number of clients m. In any case where a server in the protocol of <ref type="bibr" target="#b15">[16]</ref> needs to broadcast an encryption of the form E k (m), it will instead do the following. The server parses the key k as a pair of keys k = (k A , k B ) and additively secret-shares the message m as m = m A + m B . Now it sends k A , m A to Alice and k B , m B to Bob (this is a dummy operation that is only used to argue security). Finally, the server broadcasts E kA (m A ) and E kB (m B ). Note that each of these two computations is of Type I, namely it is done on values already known to one of the clients. Moreover, it is easy to see that the above distributed encryption scheme is still semantically secure from the point of view of an adversary that corrupts just one of the clients. Thus, the simulation argument from <ref type="bibr" target="#b15">[16]</ref> (that only relies on the semantic security of E) applies as is.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">OT Extension in the Malicious Model</head><p>Beaver <ref type="bibr" target="#b1">[2]</ref> suggested a technique for extending OTs using a one-way function. Specifically, by invoking k instances of OT one can implement a much larger number n of OTs by making use of an arbitrary one-way function. A disadvantage of Beaver's approach is that it makes a non-black-box use of the one-way function, which typically makes his protocol inefficient. A black-box approach for extending OTs was suggested by Ishai, Kilian, Nissim, and Petrank <ref type="bibr" target="#b30">[29]</ref>. In the semi-honest model their protocol has the following features. Following an initial seed of k string OTs (where k is a computational security parameter), each additional string OT only requires to make a couple of invocations of a cryptographic hash function (that satisfies a certain property of "correlation robustness"<ref type="foot" target="#foot_10">11</ref> as well as a PRG. The amortized communication complexity of this protocol is optimal up to a constant factor, assuming that each of the sender's strings is (at least) of the size of the input to the hash function. To obtain a similar result for the malicious model, <ref type="bibr" target="#b30">[29]</ref> employed a cut-and-choose approach which multiplies the complexity by a statistical security parameter. A partial improvement was recently given in <ref type="bibr" target="#b28">[27]</ref>, where the overhead in terms of the use of the hash function was reduced to a constant, but the overhead to the communication remained the same. This result was obtained via the use of efficient OT combiners <ref type="bibr" target="#b29">[28]</ref>. We improve the (amortized) communication overhead to be constant as well. While our result could be obtained via an improvement to the construction of OT combiners in <ref type="bibr" target="#b28">[27]</ref> (see Section 5.4), we sketch here a simple derivation of the result by applying our compiler to the protocol for the semi-honest model in <ref type="bibr" target="#b30">[29]</ref>. In the full version we will show an alternative, and self-contained, approach for obtaining a similar result by applying our general secure two-party protocol to an appropriate NC 0 functionality.</p><p>The efficient OT extension protocol is obtained as follows. The outer protocol will be the MPC protocol from Section 4 with two clients, called a sender and a receiver, and k servers. The protocol will be applied to the following multi-OT functionality. The sender's input is an n-tuple of pairs of k-bit strings, and the receiver's input is an n-tuple of choice bits. The receiver's output is the n-tuple of chosen k-bit strings. This outer protocol can be implemented so that each of the k servers performs just a single Type II computation, consisting of an NC 0 function with one input of length O(n) originating from the sender and another input of length O(n/k) originating from the receiver. Using a suitable randomized encoding (see Section 4), each of these inner computations can be securely implemented (in the semi-honest model) using O(n/k) OTs on k-bit strings. However, instead of directly invoking the OT oracle for producing the required OTs, we use the OT extension protocol for the semi-honest model from <ref type="bibr" target="#b30">[29]</ref>. The two-party protocol obtained in this way realizes the multi-OT functionality with computational UC-security, and only makes a black-box use of a correlation-robust hash function as well as a seed of O(k 2 ) OTs (which also includes the OTs for initializing the watchlists). Its constant communication overhead (for n k) is inherited from the outer and inner components. We defer further optimizations to the full version.</p><p>Black-Box Constructions of OT. Note that the above construction (before plugging in the protocol from <ref type="bibr" target="#b30">[29]</ref>) has the feature that the inner protocol can make a black-box use of any OT protocol for the semi-honest model. This implies the following black-box approach for converting "semi-honest OTs" into "malicious OTs". First, make O(k) black-box invocations of an arbitrary malicious OT to generate the watchlists. (Here and in the following, we allow a free black-box use of a PRG to extend a single OT on short strings, or few bit OTs, into OT on a long strings.) Then, make O(n) black-box calls to any OT protocol for the semi-honest model to generate n instances of OT in the malicious model. The above black-box approach applies both to the UC and to the standalone model. Together with the black-box constructions of OT of Ishai, Kushilevitz, Lindell, and Petrank <ref type="bibr" target="#b33">[31]</ref> and Haitner <ref type="bibr" target="#b27">[26]</ref>, we get a black-box construction of malicious OT in the standalone model from semi-honest OT with a constant amortized OT production rate. The constant rate applies both to the cases of bit-OT and string-OT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">OT Combiners</head><p>An OT combiner <ref type="bibr" target="#b29">[28]</ref> allows one to obtain a secure implementation of OT from n OT candidates, up to t of which may be faulty. The efficiency of OT combiners was recently studied by Harnik, Ishai, Kushilevitz, and Nielsen <ref type="bibr" target="#b28">[27]</ref>, who obtained a construction for the semi-honest model that tolerates t = Ω(n) bad candidates and has a constant production rate, namely produces m good instances of OT using a total of O(m) calls to the candidates. They also present a similar variant for the malicious model, but this variant has two weaknesses. First, the OTs being produced are only computationally secure (even if the good OT candidates have unconditional security, say by using semi-trusted parties or physical assumptions). Second, the communication complexity of the combiner protocol has a multiplicative overhead that grows polynomially with a cryptographic security parameter. Our approach can be used to eliminate both of these weaknesses, obtaining unconditionally secure OT combiners in the malicious model that tolerate t = Ω(n) bad candidates and have a constant production rate and a constant communication overhead.</p><p>We achieve the above by applying the protocol of Theorem 2 such that each OT which is associated with server i (both during the actual protocol and during the watchlist initialization) is implemented by invoking the i-th OT candidate. Unlike Theorem 2, here we need to rely on the robustness of the outer protocol (rather than settle for the weaker notion of "security with abort"). Another modification to the protocol of Theorem 2 is that the protocol is not aborted as soon as the first inconsistency is detected, but rather only aborts when there are inconsistencies involving at least, say, t/10 servers. This is necessary to tolerate incorrect outputs provided by faulty OT candidates. Since the faulty candidates can be emulated by an adversary corrupting the corresponding servers, we can afford to tolerate a constant fraction faulty candidates.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Theorem 2 .</head><label>2</label><figDesc>Let C be a boolean circuit of size s, depth d and constant fan-in representing an m-party deterministic functionality f for some constant m ≥ 2.Then there is a statistically UC-secure m-party protocol realizing f in the OThybrid model whose total communication complexity (including communication with the OT oracle) is O(s)+poly(k, d, log s),where k is a statistical security parameter, and whose round complexity is O(d). Security holds against an adaptive adversary corrupting an arbitrary number of parties.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Concretely, in this type of protocols it is generally impossible to guarantee output delivery or even fairness, and one has to settle for allowing the adversary to abort the protocol after learning the output.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Our results still imply efficient unconditionally secure protocols under physical assumptions, such as off-line communication with a trusted dealer, secure hardware, or noisy channels.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>Furthermore, the functionality g Π realized by ρ is also defined in a black-box way using the next-message function of Π. This rules out the option of allowing the compiler access to the code of f by, say, incorporating it in the output of g Π .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>This idea is also reminiscent of the player virtualization technique of Bracha<ref type="bibr" target="#b5">[6]</ref> and the notion of concatenated codes from coding theory.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>Note that the sender can "cheat" by using arbitrary inputs to the p q string-OT and declaring an arbitrary set as the p-sized subset containing the message. But this simply corresponds to picking one of the messages in the declared p-sized subset (considered as a multi-set) uniformly at random, and using it as the input to the p/q-Rabin-string-OT.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>For the sake of brevity we have omitted the round number, server number, and number of servers as explicit inputs to π. We shall implicitly use the convention that these are part of each component in the input.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>By default, this additive sharing uses bitwise XOR. However, it is sometimes beneficial to use a different finite abelian group for this purpose. This allows to implement group additions performed by the outer protocol non-interactively, by having clients directly add their shares.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_7"><p>Efficiency aside, by using UC-secure outer protocols, our compiled protocols are also UC-secure.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_8"><p>While we do not attempt here to optimize the additive term, we note that a careful implementation of the protocol seems to make this term small enough for practical purposes. In particular, the dependence of this term on d can be eliminated for most natural instances of large circuits.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_9"><p>Using Franklin and Yung's variant of Shamir's secret sharing scheme<ref type="bibr" target="#b20">[20,</ref><ref type="bibr" target="#b41">39]</ref>, as originally done in<ref type="bibr" target="#b16">[17]</ref>, would result in logarithmic overhead to the communication complexity of the protocol, and a polylogarithmic overhead in the complexity of the applications.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_10"><p>The correlation robustness property defined in<ref type="bibr" target="#b30">[29]</ref> is satisfied by a random function. Arguably, it is sufficiently natural to render practical hash functions insecure if they are demonstrated not to have this property.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Supported in part by ISF grant 1310/06, BSF grant 2004361, and NSF grants 0205594, 0430254, 0456717, 0627781, 0716389. Supported in part by NSF grants CNS 07-16626 and CNS 07-47027. Research supported in part from NSF grants 0627781, 0716389, 0456717, and 0205594, a subgrant from SRI as part of the Army Cyber-TA program, an equipment grant from Intel, an Alfred P. Sloan Foundation Fellowship, and an Okawa Foundation Research Grant.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Precomputing oblivious transfer</title>
		<author>
			<persName><forename type="first">D</forename><surname>Beaver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 1995</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Coppersmith</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">963</biblScope>
			<biblScope unit="page" from="97" to="109" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Correlated pseudorandomness and the complexity of private computations</title>
		<author>
			<persName><forename type="first">D</forename><surname>Beaver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 28th STOC</title>
		<meeting>28th STOC<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="479" to="488" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">The round complexity of secure protocols (extended abstract)</title>
		<author>
			<persName><forename type="first">D</forename><surname>Beaver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>ACM</publisher>
			<biblScope unit="page" from="503" to="513" />
			<pubPlace>New York</pubPlace>
		</imprint>
		<respStmt>
			<orgName>STOC</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Completeness theorems for noncryptographic fault-tolerant distributed computation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ben-Or</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 20th STOC</title>
		<meeting>20th STOC<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Multiparty computation goes live</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bogetoft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Christensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Geisler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Jakobsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krøigaard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Nielsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Nielsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nielsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pagter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schwartzbach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Toft</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2008">2008/068. 2008</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An o(log n) expected rounds randomized byzantine generals protocol</title>
		<author>
			<persName><forename type="first">G</forename><surname>Bracha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="910" to="920" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Oblivious transfers and intersecting codes</title>
		<author>
			<persName><forename type="first">G</forename><surname>Brassard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Crépeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Santha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1769" to="1780" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Security and composition of multiparty cryptographic protocols</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology: the journal of the International Association for Cryptologic Research</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="143" to="202" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Previous version A unified framework for analyzing security of protocols availabe at the ECCC archive TR01-016</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<idno>TR01- 016</idno>
		<imprint>
			<date type="published" when="2001">2001. 2001</date>
		</imprint>
	</monogr>
	<note>Universally composable security: A new paradigm for cryptographic protocols. Extended abstract in FOCS 2001</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Universally composable twoparty computation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 34th STOC</title>
		<meeting>34th STOC<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="494" to="503" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Multiparty unconditionally secure protocols</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Crépeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 20th STOC</title>
		<meeting>20th STOC<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="11" to="19" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Algebraic geometric secret sharing schemes and secure multi-party computations over small fields</title>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2006</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Dwork</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4117</biblScope>
			<biblScope unit="page" from="521" to="536" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Equivalence between two flavours of oblivious transfers</title>
		<author>
			<persName><forename type="first">C</forename><surname>Crépeau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 1987</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Pomerance</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="volume">293</biblScope>
			<biblScope unit="page" from="350" to="354" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Optimal reductions between oblivious transfers using interactive hashing</title>
		<author>
			<persName><forename type="first">C</forename><surname>Crépeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Savvides</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2006</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Vaudenay</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4004</biblScope>
			<biblScope unit="page" from="201" to="221" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Committed oblivious transfer and private multi-party computation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Crépeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van De Graaf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tapp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 1995</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Coppersmith</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">963</biblScope>
			<biblScope unit="page" from="110" to="123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Constant-round multiparty computation using a black-box pseudorandom generator</title>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2005</title>
		<editor>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3621</biblScope>
			<biblScope unit="page" from="378" to="394" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Scalable secure multiparty computation</title>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2006</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Dwork</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4117</biblScope>
			<biblScope unit="page" from="501" to="520" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Parallel reducibility for information-theoretically secure computation</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2000</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1880</biblScope>
			<biblScope unit="page" from="74" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A randomized protocol for signing contracts</title>
		<author>
			<persName><forename type="first">S</forename><surname>Even</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lempel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="637" to="647" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Communication complexity of secure computation (extended abstract)</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>ACM</publisher>
			<biblScope unit="page" from="699" to="710" />
			<pubPlace>New York</pubPlace>
		</imprint>
		<respStmt>
			<orgName>STOC</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Foundations of Cryptography: Basic Applications</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>Cambridge University Press</publisher>
			<pubPlace>Cambridge</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">How to play ANY mental game</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 19th STOC</title>
		<meeting>19th STOC<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="218" to="229" />
		</imprint>
	</monogr>
	<note>See [21, Chap. 7] for more details</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">How to solve any protocol problem -an efficiency improvement</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Vainish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 1987</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Pomerance</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">293</biblScope>
			<biblScope unit="page" from="73" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Secure computation without agreement</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DISC 2002</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Malkhi</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2508</biblScope>
			<biblScope unit="page" from="17" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Efficient two party and multi party computation against covert adversaries</title>
		<author>
			<persName><forename type="first">V</forename><surname>Goyal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mohassel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2008</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Smart</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">4965</biblScope>
			<biblScope unit="page" from="289" to="306" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Semi-honest to malicious oblivious transfer -the black-box way</title>
		<author>
			<persName><forename type="first">I</forename><surname>Haitner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2008</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">4948</biblScope>
			<biblScope unit="page" from="412" to="426" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">OT-combiners via secure computation</title>
		<author>
			<persName><forename type="first">D</forename><surname>Harnik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Nielsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2008</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">4948</biblScope>
			<biblScope unit="page" from="393" to="411" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">On robust combiners for oblivious transfer and other primitives</title>
		<author>
			<persName><forename type="first">D</forename><surname>Harnik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rosen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2005</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3494</biblScope>
			<biblScope unit="page" from="96" to="113" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Extending oblivious transfers efficiently</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nissim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Petrank</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2003</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2729</biblScope>
			<biblScope unit="page" from="145" to="161" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Perfect constant-round secure computation via perfect randomizing polynomials</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP 2002</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Widmayer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Triguero</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Morales</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Hennessy</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Eidenbenz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Conejo</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2380</biblScope>
			<biblScope unit="page" from="244" to="256" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Black-box constructions for secure computation</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Petrank</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Zero-knowledge from secure multiparty computation</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="21" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Founding cryptography on oblivious transfer</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="20" to="31" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A protocol issue for the malicious case of Yao&apos;s garbled circuit construction</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kiraz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schoenmakers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC 2006</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Kiayias</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Malkin</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">3958</biblScope>
			<biblScope unit="page" from="283" to="290" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">An efficient protocol for secure two-party computation in the presence of malicious adversaries</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2007</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4515</biblScope>
			<biblScope unit="page" from="52" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Efficiency tradeoffs for malicious two-party computation</title>
		<author>
			<persName><forename type="first">P</forename><surname>Mohassel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Franklin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC 2006</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Kiayias</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Malkin</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">3958</biblScope>
			<biblScope unit="page" from="458" to="473" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">A framework for efficient and composable oblivious transfer</title>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="m">These proceedings available from Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2007">2007. 2008</date>
			<biblScope unit="volume">348</biblScope>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">How to exchange secrets by oblivious transfer</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rabin</surname></persName>
		</author>
		<idno>TR-81</idno>
		<imprint>
			<date type="published" when="1981">1981</date>
		</imprint>
		<respStmt>
			<orgName>Harvard Aiken Computation Laboratory</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">How to share a secret</title>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<date type="published" when="1979-11">November 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">How to generate and exchange secrets</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 27th FOCS</title>
		<meeting>27th FOCS<address><addrLine>Los Alamitos</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="162" to="167" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
