<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Glow: Graph Lowering Compiler Techniques for Neural Networks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2019-04-03">3 Apr 2019</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Nadav</forename><surname>Rotem</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jordan</forename><surname>Fix</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Saleem</forename><surname>Abdulrasool</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Garret</forename><surname>Catron</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Summer</forename><surname>Deng</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Roman</forename><surname>Dzhabarov</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Nick</forename><surname>Gibson</surname></persName>
						</author>
						<author>
							<persName><forename type="first">James</forename><surname>Hegeman</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Meghan</forename><surname>Lele</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Roman</forename><surname>Levenstein</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jack</forename><surname>Montgomery</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Bert</forename><surname>Maher</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Satish</forename><surname>Nadathur</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jakob</forename><surname>Olesen</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jongsoo</forename><surname>Park</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Artem</forename><surname>Rakhov</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Misha</forename><surname>Smelyanskiy</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Man</forename><forename type="middle">Wang</forename><surname>Facebook</surname></persName>
						</author>
						<title level="a" type="main">Glow: Graph Lowering Compiler Techniques for Neural Networks</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2019-04-03">3 Apr 2019</date>
						</imprint>
					</monogr>
					<idno type="arXiv">arXiv:1805.00907v3[cs.PL]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T09:31+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper presents the design of Glow, a machine learning compiler for heterogeneous hardware. It is a pragmatic approach to compilation that enables the generation of highly optimized code for multiple targets. Glow lowers the traditional neural network dataflow graph into a two-phase strongly-typed intermediate representation. The high-level intermediate representation allows the optimizer to perform domain-specific optimizations. The lower-level instruction-based address-only intermediate representation allows the compiler to perform memory-related optimizations, such as instruction scheduling, static memory allocation and copy elimination. At the lowest level, the optimizer performs machine-specific code generation to take advantage of specialized hardware features. Glow features a lowering phase which enables the compiler to support a high number of input operators as well as a large number of hardware targets by eliminating the need to implement all operators on all targets. The lowering phase is designed to reduce the input space and allow new hardware backends to focus on a small number of linear algebra primitives.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The end of power saving due to Moore's Law, combined with the increased demand for compute power driven by machine learning, has led to a wave of innovation in computer architecture. Hennessy and Patterson <ref type="bibr" target="#b0">[1]</ref> present five principles that guide the design of machine-learning domain specific architectures (DSA): dedicated local memories, large numbers of arithmetic units, simple forms of parallelism, reduced bit-widths, and domain-specific programming models. Compilers need to perform advance whole-graph optimizations in order to execute neural networks efficiently on DSAs. This paper describes some of these techniques as implemented in Glow, an open-source machine learning compiler framework for heterogeneous hardware.</p><p>Traditional machine learning frameworks iterate over the nodes in the graph and execute them one by one. Unfortunately this node-visitor method of execution is inefficient, even on traditional processors. As a result, machine learning frameworks have started to hand over the graph to compilers <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref> that execute code more efficiently. Based on the increasing importance of neural networks, the need for energy efficiency in data centers and mobile devices, and the design principles of domain-specific architectures, we believe that the machine learning frameworks of the future will focus on providing attractive programming models on top of a layer that integrates compilers for many different targets.</p><p>In Glow, we focus on the lower parts of the software stack. We work to provide PyTorch <ref type="bibr" target="#b3">[4]</ref> and other frameworks with a low-level graph and a code generator for neural networks. The name Glow is an abbreviation for Graph-Lowering, which is the main technique that the compiler uses for generating efficient code. The Glow low-level graph will not replace the machine learning high-level graph, in the same way that the low-level intermediate representation in compilers does not replace the abstract syntax tree.</p><p>We aim to provide a useful compiler toolkit that will allow hardware developers to focus on implementing efficient acceleration hardware, each of which likely differ in capabilities, and use Glow for automating compilation tasks such as instruction selection, memory allocation and graph scheduling. The full compiler toolkit is open-source and publicly available 1 .</p><p>Frameworks such as PyTorch <ref type="bibr" target="#b3">[4]</ref>, Caffe <ref type="bibr" target="#b4">[5]</ref>, and Ten-sorFlow <ref type="bibr" target="#b5">[6]</ref> have found success by providing a useful way for developers to create neural network models, and executing them on specific architectures. However, supporting new architectures and operators is not scalable, because adding a new operator requires it to be implemented on each supported architecture, and adding a new architecture requires all operators be implemented for it. Glow is designed to consume a neural network compute graph, optimize it, and code generate for it for a diverse set of backends in a more scalable way. This includes target-independent optimizations and analysis prior to efficiently targeting a specific backend.</p><p>ONNX <ref type="bibr" target="#b6">[7]</ref> is an open-source format for representing and serializing AI models. It allows for interoperability between different AI frameworks, allowing compute graphs from one framework such as PyTorch to be converted to or from another framework such as Cognitive Toolkit (CNTK) <ref type="bibr" target="#b7">[8]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Compiler-Related Projects</head><p>Several prior systems use a compiler-oriented approach to optimizing neural networks. TensorFlow's XLA <ref type="bibr" target="#b1">[2]</ref> compiles neural networks for CPUs, GPUs and accelerators. It is a practical compiler that solves actual problems. XLA is used in production to drive a massive fleet of accelerators at Google. It lowers nodes into primitive linear algebra operations, and then calls into a backend-specific library for different backend (such as Eigen <ref type="bibr" target="#b8">[9]</ref> for CPUs, or cuDNN <ref type="bibr" target="#b9">[10]</ref> for GPUs) to perform the bulk of computation. We point out that XLA emits vectorized LLVM intermediate representation (IR) <ref type="bibr" target="#b10">[11]</ref> for some nodes (such as dot), and relies on the LLVM vectorizer <ref type="bibr" target="#b11">[12]</ref> for other nodes. It aims to provide a backend flexibility for (...) A [ i ] = 3; for (...) A [ i ] = 4; return A [0]; for TensorFlow, in a similar way that Glow is working toward providing for PyTorch and other neural network frameworks.</p><p>TVM/NNVM <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b12">13]</ref> lowers nodes into a low-level Halide-based IR wherein loop-based optimizations can be performed. Halide <ref type="bibr" target="#b13">[14]</ref> is then used to generate LLVM or CUDA/Metal/OpenCL source code. On the other hand, DLVM <ref type="bibr" target="#b14">[15]</ref> lowers DLVM IR into LLVM IR, benefiting from the LLVM's mature optimizer and code generator.</p><p>Yet another approach is taken by nGraph <ref type="bibr" target="#b15">[16]</ref>, which consumes a framework's (such as Tensorflow) compute graph to represent internally in a single level IR, and then lowers that to different backends such as cuDNN and MKL-DNN <ref type="bibr" target="#b16">[17]</ref>.</p><p>Finally, Tensor Comprehensions <ref type="bibr" target="#b17">[18]</ref> provides a language for neural network developers to specify their networks such that a JIT compiler can algorithmically search for the most efficient execution plan possible. This execution plan is then generated in a language suited for a specific backend, such as CUDA for a GPU, and compiled by a compiler for that language. Tensor Comprehensions is a good solution for programmers that seek to create new operators that do not exist today and execute them efficiently.</p><p>Similar to Glow, these systems include one or more levels of IR (Section 3) which represent the compute graph of some neural network model. Additionally, like Glow, many represent tensors as first-class members with a shape and an element type. Glow uses multiple levels of its own IR in the entire stack, and leaves it up to each backend to implement further lowering if desired. For example, Glow's CPU backend executes low-level Glow instructions and calls into its own libjit standard library kernels implemented in C ++ and compiled with LLVM (Section 5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Intermediate Representation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Motivation</head><p>In this section we describe the motivation for having a high-level intermediate representation (IR). Neu-ral networks are dataflow graphs where each operation represents some mathematical operation, such as element-wise add or matrix multiplication. One way to compile this graph into an executable would be to translate each mathematical operation directly into some low-level compiler IR that contains loops and other low-level instructions. However, we believe that the high-level domain specific intermediate representation is necessary for optimizing the graph.</p><p>Consider the code in Figure <ref type="figure" target="#fig_0">1</ref>. Two for-loops write into some memory region, and later the returnstatement reads from some element in the array. Neither GCC nor LLVM were able to remove the first loop, which is redundant, or replace the load operation with the constant value '4'. The reason is that analyzing loops and memory is difficult. The compiler needs to prove that the indices in the loops do not overflow, and that pointers in the program do not alias, and that the result of the computation is accurate and conform with the specification of the C programming language.</p><p>Thus, trusting a sufficiently good C ++ compiler to optimize neural networks is not a viable strategy, because for example it is difficult to reverse engineer a sequence of 7 loops into a convolution. Instead we have implemented a high-level intermediate representation that allows a compiler to reason about and optimize high-level constructs such as tensors and operations.</p><p>Glow is a retargetable compiler that supports a number of different backends. This means that the first few phases of the compiler are target-independent, but as you get closer to instruction selection the IR becomes more target-specific. This design is not unique to Glow. Many compilers and virtual machines use similar techniques to gradually canonicalize, optimize and lower programs into instruction streams. The first two levels of IR are shared between all compilation targets. Compiler backends may implement additional levels of intermediate representations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">High-Level IR</head><p>The high-level IR is a dataflow node-based graph representation that is similar to the graph that you may find inside Caffe. When we load a neural network model we construct this graph with a direct translation of one operator to one or more nodes. The high-level IR is a simple graph that allows basic transformations, such as replacing all uses of some node with another node, or modifying the content of in-put tensors known at compile time (e.g. pre-trained weights). The graph is strongly typed, which means that inputs and output have a known tensor type (consisting of the tensor's shape and element type), and that the types of nodes are verified by the compiler. For example, the element-wise add instruction must operate on operands of the same type. Some strongly-typed programming languages represent dynamic types at runtime in a safe way. Swift <ref type="bibr" target="#b18">[19]</ref> generics are an example for such type system that allows compilation for unknown yet constrained types. We have considered the idea of developing some kind of parametric tensor types to support features such as varying batch sizes. However, we have decided to implement a simple strict type system instead and let the high-level machine learning framework specialize the computation before constructing the Glow graph. We evaluated the mechanisms that the modern programming languages use to implement generics and concluded that most hardware accelerators do not support some of these mechanisms. Production systems that use Glow may generate multiple Glow graphs for different batch sizes, or recompute the graph just-in-time.</p><p>The Glow graph is structured as a module that contains multiple functions that contain multiple nodes. Storage nodes, which are similar to global variables in C programs, are owned by the module and accessible to all functions of the same module. All other nodes are owned by functions and represent the different operations of a neural network. For example, Convolution, MaxPool, MatrixMultiply, and so on are represented as nodes. These nodes are able to reference and access storage nodes that are owned by their containing module.</p><p>Storage nodes are the base class for, and are implemented as, Constant and Placeholder nodes. Constant nodes are backed by a concrete, known tensor at compilation time. Thus, the optimizer can inspect and optimize them as it sees fit. For example, the optimizer is able to delete unused Constant nodes, transpose them, quantize them (Section 4), perform constant propagation, etc. An example of a Constant node is the pre-trained weight input to a Convolution node during inference.</p><p>Placeholder nodes are symbolic nodes that may have backing tensors assigned or changed after compilation. This means that unlike Constant nodes, the optimizer cannot inspect or optimize the contents of Placeholder nodes. If the same function is compiled using different backing tensors bound to the Placeholder nodes, the semantics of the program are unchanged. Inputs and outputs of Glow programs should be modeled using Placeholder nodes. An example of a Placeholder node is the input image data tensor for image classification in a convolutional neural network; this input image data tensor can be changed without recompiling the function.</p><p>As an end-to-end example, one module could contain both an inference function and the gradient of that inference function. The weights (to be trained by the gradient function) would be created as Placeholder nodes, as they are not constant during training. Executing the gradient function would update the tensors backing the weight Placeholder nodes. The nodes in the inference function could then reference and access the weight Placeholder nodes (backed by the nowtrained weights tensors). Thus, the Placeholder nodes can be converted to Constant nodes, and the inference function can be better optimized during compilation, knowing these nodes are Constant.</p><p>The compiler has a debug method for dumping textual and graphical representations of the graph. Figure <ref type="figure">2</ref> depicts the compute graph of a regression of A automatically differentiated by Glow, with the value of Placeholder node A updated with the gradient of the expression. Glow lowers the nodes that compute the gradient of the expression and the stochastic gradient descent (SGD) node into a sequence of low-level operators (Sub, Mul, Add, and Save). The different compiler backends do not need to implement support for the DivGrad or SGD nodes.</p><p>By contrast, classic machine learning frameworks that are not able to automatically generate fused kernels (Section 5.2) need to implement hundreds of CUDA and CPU compute kernels that represent the un-lowered operators. This limits their ability to support new kinds of hardware and ties them to one or two major hardware vendors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Predication</head><p>Predication is a well-known technique to control the execution of some node or instruction by means of a boolean flag. If the value of the flag at runtime is set to 'false' then the predicated node or instructions may return any value. A correct program should know to ignore the output of the predicated instruction because it could be zeros or uninitialized memory. The type of the flag must be a boolean value or a vector of booleans that matches the batch size. Predicates could accelerate the performance of some networks by avoiding some computation. It can particularly be useful when applied to Recurrent Neural Networks <ref type="bibr" target="#b19">[20]</ref>, because different elements of the batch may have different lengths and do not need to perform the same amount of computation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Node Lowering</head><p>The Glow compilation pipeline solves the problem of targeting a large number of opcodes to many different targets. Modern machine learning frameworks support hundreds of operators on many different hardware backends. The approach that is taken by classic machine learning frameworks is to implement each opcode for each hardware target. In such frameworks, ReLU would be implemented once for the GPU, once for the CPU, once for some mobile DSP accelerator, and so on. This approach does not scale as the number of opcodes and the number of hardware targets increase.</p><p>Instead, Glow takes a different approach. Instead of compiling the high-level operators directly, Glow performs "node lowering". In this phase, the compiler breaks the high-level operator nodes into low-level linear algebra operator nodes. For example, the Fully-Connected layer is represented as a matrix multiplication followed by broadcasted add. Different compiler backends do not have to implement the FullyConnected layer and a dozen other high-level opcodes, just the low-level matrix multiplication.</p><p>This lowering phase drives many of the design decisions of the compiler. In Glow, lowering is performed as part of the high-level graph as described above, prior to moving to low-level IR (Section 3.5). This is due to a number of reasons. First, the new lowered graph may allow for additional graph-level optimizations. Second, the new graph structure may affect the decisions of the instruction scheduler. And third, after lowering we allow the backends to perform additional target-specific optimizations on the lowered graph.</p><p>The lowering phase comes after the graph is differentiated. Because the lowering transformation does not preserve the semantics of the graph, it is not possible to differentiate the graph for certain operators. For example, the Regression node (which produces gradient when optimizing total squared error) becomes a no-op for the inference case, but is translated into an element-wise subtract for the training case. Performing the lowering before differentiation would prevent us from performing the correct lowering of the Regression node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Low-Level IR</head><p>After optimizing the graph with target-independent optimizations, and lowering from high-level operator nodes to linear algebra operator nodes, the code is further lowered into the low-level IR in a phase that is called "IRGen" (which stands for IR generation) <ref type="foot" target="#foot_0">2</ref> . This is a one-to-many translation where each highlevel node is translated into one or more instructions.</p><p>The low-level IR enables a different kind of target independent optimizations that are not possible with the high-level graph format. This is an instructionbased representation that operates on tensors that are referenced by address. This gives the compiler the ability to perform low-level memory optimizations that are not possible at the high-level, because memory is not represented directly. An example of such a transformation is the optimization that allows certain operations to transform some buffers in-place, such as element-wise arithmetic.</p><p>In the context of hardware acceleration, the lowlevel instruction-based representation allows the compiler to represent device-specific operations such as asynchronous DMA operations. Hiding the latency of memory operations is important for utilizing the execution units of the hardware effectively, and the instruction-based representation allows the compiler to create a schedule that hides the latency of the memory operations.</p><p>The IR is strongly typed and each instruction operand kind has known parameter types. It is designed to be used as an in-memory form, though can be dumped to human readable assembly-like format.</p><p>A function in IR form contains two sections: 'declare' and 'program'. In the first section of the IR we declare a number of memory regions that live throughout the lifetime of the program. This is similar to global variables in C. The second part of the IR is a list of instructions. Each variable is annotated with the kind of initialization that the program should do.</p><p>There are two kinds of memory regions which correspond to these two sections: global memory regions (found in 'declare') and locally allocated regions (found in 'program'). The locally allocated memory regions are similar to 'alloca' in LLVM IR <ref type="foot" target="#foot_1">3</ref> . Memory regions are strongly typed, which means that the kind of type of tensor that the region represents is known.</p><p>Instructions operate on either these global memory regions or locally allocated regions. Each operand is annotated with one of the qualifiers '@in'/'@out'/'@inout'. '@in' means that the buffer is read from. '@out' means that the buffer is written into. And '@inout' means that the instruction may read and write into the buffer. These operand qualifiers help the optimizer decide when it is legal to perform certain optimizations, such as copy elimination or buffer sharing. Instructions may have other attributes that specify the legality of some optimizations. For example, some instructions require that the data from the forward pass would be kept around for the backward pass, so if the program is not optimized for inference-only mode then certain memory optimizations cannot happen. ] @out %allo , @in %input , @in %filter3 , @in %bias0 %allo0 = alloc float &lt;8 x 28 x 28 x 16 &gt; %relu = max0 @out %allo0 , @in %allo %allo1 = alloc index &lt;8 x 9 x 9 x 16 x 2 &gt; %allo2 = alloc float &lt;8 x 9 x 9 x 16 &gt; %pool = pool max [3 3 0] @out %allo2 , @in %allo0 , @inout %allo1 ... %deal6 = dealloc @out %allo6 %deal7 = dealloc @out %allo7 %deal8 = dealloc @out %allo8 %deal9 = dealloc @out %allo9 }  The low-level memory allocator is responsible for allocating all of the buffers into a single coalesced region.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Summary: The Lifetime of a Glow Instruction</head><p>This section summarizes how instructions travel from the beginning of the compilation pipeline, and through the different levels of IR and to the backends. This is a high-level overview of the compilation process:</p><p>1. The graph is either loaded via the graph loader (from ONNX or Caffe2 format), or constructed via the C ++ interface.</p><p>2. The graph is differentiated if needed.</p><p>3. The graph is optimized.</p><p>4. Linear algebra node lowering takes place.</p><p>5. Additional rounds of optimizations occur, both target independent and target specific.</p><p>BB . newInstr ( " AvgPool " ) . addOperand ( " Dest " , OperandKind :: Out ) . addOperand ( " Src " , OperandKind :: In ) . addMember ( MemberType :: VectorUnsigned , " Kernels " ) . addMember ( MemberType :: VectorUnsigned , " Strides " ) . addMember ( MemberType :: VectorUnsigned , " Pads " ) . autoIRGen () . autoVerify ( VerifyKind :: SameElementType , { " Dest " , " Src " }) . a d d G r a d i e n t I n s t r ({ " Dest " } , { " Dest " , " Src " }) ; 6. The graph is scheduled into a linear sequence of nodes that minimizes memory usage.</p><p>7. IRGen converts the low-level graph into instructions.</p><p>8. Low-level IR optimizations are performed. 9. Backend-specific optimizations and code generation are performed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">ClassGen</head><p>Glow uses automatic code generation techniques (class-gen) for defining instructions and nodes. The purpose of the automatic code generation tools in Glow is similar to the motivation behind LLVM's TableGen, which is to help a human develop and maintain records of domain-specific information.</p><p>The current system is capable of generating two kinds of classes: Nodes for the high-level IR and Instructions for the low-level IR. Figure <ref type="figure" target="#fig_4">4</ref> shows an example of the code for generating the AvgPool instruction. ClassGen generates most of the methods that instructions need to have, such as instruction equality and hashing, cloning, printing, verification, etc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Quantization</head><p>In the context of machine learning, quantization is the process of converting a neural network from floatingpoint to integer arithmetic. Arithmetic using small integers is more efficient than the computation of full-width floating-point numbers, and additionally decreases memory usage.</p><p>Glow is able to convert floating-point-based networks into signed 8-bit integer networks. The canonical quantization representation is using signed integers, though it is possible to support other quantization formats. Glow uses profile-guided quantization,  Activations, weights, and storage nodes all use the same type-system and represent information in a uniform way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Profile-Guided Quantization</head><p>Different parts of the network contain floating-point values in different ranges. In some parts, the typical range of the numbers is between zero and one, while in other parts of the network the possible range is in the hundreds. Choosing a single conversion scale for the whole network would not work, because a single scale value could be imprecise for small values and truncate large values.</p><p>We use profile-guided information to estimate the possible numeric range for each stage of the neural network. Our quantization conversion works using a two-phase process. First, we statically instrument the network with special profiling nodes that record the ranges of activations that flow in the network, optimize the network including these profiling nodes, and then run inference. Then, we recompile the network using this profile information to convert the network into a quantized form, allowing for static optimization of the quantized graph. We convert portions of the network into islands of integer computation and aim to generate outputs in the range that the original floating-point network produces. Figure <ref type="figure" target="#fig_7">5</ref> shows a quantized subgraph from Resnet50. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Compiler Optimizations For Quantization</head><p>Glow features a number of compiler optimizations that transform the compute graph and make it more efficient. There are a few classes of optimizations and parameters to optimize.</p><p>First, we attempt to minimize the number of conversions between floating-point tensors and integer tensors, in both directions. Some operations, such as 'transpose' and 'concat' operate on both types, and changing the representation can minimize conversions.</p><p>Second, the neural network contains 'rescale' nodes that change the range of the integers. These nodes are required to convert between numeric ranges that mimic the original floating-point network. However, in many cases, it is possible to fold the rescale operations into numeric-producing operations, and eliminate them. Third, it's possible to rescale the values in the network in order to allow fast hardware implementations of the quantized operations. For example, consider the 'max' operations. By converting both sides of the 'max' into the same scale we allow the hardware to perform a simple comparison. By normalizing both sides of the 'max' operation to the same scale we enable this efficient optimization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CPU Backend</head><p>This section describes the implementation of the CPU backend. The Glow CPU backend compiles the lowlevel intermediate representation into an optimized stream of instructions. It uses LLVM to optimize and emit machine code and was tested on x86 and ARM64. The backend can emit a stand-alone object file to disk or execute code in just-in-time mode. The backend emits debug information, which makes it possible to debug Glow in a debugger and place a breakpoint in specific operator, or understand the performance of networks using a profiler.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Standard Library</head><p>One interesting aspect of the Glow CPU backend is the use of a small target independent standard library. The CPU backend needs to generate code for machine learning operators such as Convolution and SoftMax. One possibility is to call into some external library such as Eigen. This is easy to do, and many machine learning frameworks use this technique. The disadvantage of this technique is that the external binary library has no information about the specific operation that is being compiled. Some of the parameters that an optimized implementation may care about are the specific tensor sizes, the exact addresses of buffers in memory, and whether some pointer aliases another pointer.</p><p>Glow compiles a small standard library that ships with the compiler into LLVM bitcode. During compilation, Glow loads the bitcode from disk and specializes the operator implementations for the specific context. Glow replaces function arguments that represent the dimensions of some tensor or buffer addresses with constants that LLVM can optimize to generate efficient code. The compiler can decide on the kind and level of operator specialization to perform, trading compile time and binary size for performance.</p><p>Most operators are very simple and the LLVM vectorizer <ref type="bibr" target="#b11">[12]</ref> is able to generate very efficient code. Notice that by providing the exact tensor dimensions and loop trip count the vectorizer is able to generate efficient code that does not contain pre-header legality check and scalar loop to handle the remainder odd iterations. The convolution and matrix multiplication operations are hand-optimized in C ++ using the clang extended OpenCL vector syntax, and LLVM does a good job allocating registers and encoding the instructions, removing the need to use inline assembly.</p><p>Filter layout before transf ormati on :</p><p>[ depth , filter_x , filter_y , channel ] Filter layout after t ransfo rmatio n :</p><p>[ depth /N , filter_x , filter_y , channel , N ]</p><p>Figure <ref type="figure">6</ref>: Transformation of a convolution's filter's memory layout to optimize for SIMD memory accesses. Depth refers to the output depth of the filter, and channel refers to the input channel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Operator Stacking</head><p>One important optimization that the CPU backend implements is stacking of data-parallel operators. Consider a sequence of operators that operate one element at a time, for example a ReLU, Add, Sub. Iterating over a large buffer multiple times is inefficient because it requires the CPU to load the memory multiple times, each time invalidating the whole cache. Instead, Glow stacks operators and performs a few data-parallel operators one after the other on the same memory location. Notice that as described above, this is not an optimization that LLVM can perform by itself and it requires a special high-level data structure.</p><p>Operator stacking is similar to operator fusion. However, when fusing multiple operators (e.g. Conv and ReLU fused together), all backends that want to support this fused operator must implement a specific kernel for each permutation of operators. In contrast, Glow's stacking automatically creates such kernels; all of the possible permutations of data-parallel nodes are automatically fused into a fast kernel.</p><p>The approach of stacking multiple operations has many advantages. First, there is an immediate performance gain for places in the graph where data-parallel operators are placed one on top of the other. Second, backends do not need to implement kernels for all possible permutations of consecutive data-parallel nodes. And lastly, it allows Glow to lower high-level operators knowing that the backend can fuse them and recover the performance.</p><p>For example, Glow lowers the SGD (stochastic gradient descent) operator into a sequence of low-level primitives that include addition, subtraction, and multiplication. Lowering the SGD node into low-level primitives simplifies the design of the compiler by reducing the operator-space that the backend needs to handle. Operator stacking can also accelerate computation on GPUs by reducing the kernel launch overhead. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Use Case: Optimizing Resnet50</head><p>for the CPU</p><p>Here we describe the way that Glow optimizes Resnet50 to generate an efficient stream of x86 instructions. Resnet50 is a residual convolutional neural network containing 54 convolutions as well as other operators such as element-wise addition, ReLU, batch normalization, max and average pooling, fullyconnected, and softmax. Glow optimizes Resnet50 by performing high-level and low-level optimizations.</p><p>First, high-level transformations eliminate redundant transpose operations and merge the batch normalization operation with a convolution node. Next, the CPU backend transforms the graph into a targetspecific graph that allows device-specific optimization. The CPU backend identifies three kinds of convolutions: convolutions with a small number of channels, convolutions where the size of the input activation buffer is large, and convolutions where the filter weight buffer is large. Each one of these convolutions requires a different compilation strategy. Next, the targetspecific optimizer mutates the graph and generates code that matches the selected convolution. Each convolution kind uses a different filter memory layout and tile size. Figure <ref type="figure">6</ref>   This 5-dimensional tensor layout allows for consecutive SIMD memory access. The N parameter is selected based on the iteration order and the blocking strategy for the convolution. The CPU backend traverses the graph and replaces any convolutions it would like to optimize in this way with this specialized convolution. This can be seen in Figure <ref type="figure" target="#fig_8">7</ref>.</p><p>The second parameter that the compiler controls is the size of the convolution tile. Glow selects a processing tile that depends on the size of the first level cache of the processor.</p><p>Next, the low-level optimizer optimizes the instruction stream by shrinking the lifetime of memory allocations for the activations, and then performs static memory allocation for the whole network into a single buffer. This reduces the mutable memory footprint of the network. From this point in the compilation pipeline the compiled code can refer to pointers in memory.</p><p>Finally, the compiler performs efficient code generation for the non-convolution parts of the network. For example, Figure <ref type="figure" target="#fig_9">8</ref> depicts the generated assembly for some part of the network. The compiler fused two unrelated element-wise operations into a single loop. The Add and Max operations are performed on the same memory buffer without reading the memory twice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Glow Runtime</head><p>After compiling a model, Glow provides a runtime that is capable of partitioning models, queueing re- quests, and executing models across multiple devices.</p><p>It provides a host level abstraction for compiling and loading models and handling concurrent inference requests on all those models. The runtime allows users of Glow to target one interface without needing to worry about the underlying hardware changing, and since it manages the host's accelerator cards, it can take advantage of its intimate knowledge of the hardware to do the best partitioning job possible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Glow Runtime Components</head><p>The Partitioner splits a network into sub-networks that can be run on multiple devices. Depending on each accelerator's available memory and the size of the weights of a model, we may want or need to partition an input network into sub-graphs across multiple accelerators in order to saturate each accelerator. A network is divided into sub-networks based on different criteria: memory constraints, estimated time cost, and communication cost between devices. The Provisioner assigns partitioned sub-graphs to specific devices and calls into the backend and Device Manager to compile and load each sub-graph onto a device. An example can be seen in Figure <ref type="figure" target="#fig_6">10</ref>.</p><p>The Device Manager serves as an abstraction for the physical device. It handles network loading, memory transfers, execution on the device, and tracks hardware state. Just like we have a different backend per device type, there is a DeviceManager class per device type and an instance of DeviceManager per physical accelerator on the host.</p><p>The Executor handles the execution of a network. It tracks each sub-network's execution state and propagates sub-network inputs and outputs. The Executor is responsible for asynchronously handing incoming inference requests for a network and returning the collated results. Figure <ref type="figure">9</ref> shows a simple example of a partitioned, directed graph converted into a schedule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Execution Flow</head><p>Adding a network:</p><p>1. The Partitioner splits the network into one or more sub-networks.</p><p>2. The Provisioner compiles each sub-network and assigns them to one or more Devices.</p><p>3. One or more DeviceManagers load the subnetworks and their weights onto its associated Device.</p><p>Handling an inference request:</p><p>1. The HostManager creates a new Execution graph with intermediate storage.</p><p>2. The Executor kicks off the first sub-network execution.</p><p>3. The DeviceManager loads inputs onto the card and begins execution. When done, it reads outputs and signals completion.</p><p>4. The Executor triggers any sub-networks with satisfied dependencies.</p><p>5. When complete, the HostManager returns outputs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Evaluation</head><p>We compare the performance of Glow vs. TensorFlow-1.7 and TVM. The experiments were run on a Kaby Lake Intel R Core i7-7600U (which does not support AVX-512) running on a single CPU core at 2.80 GHz. All three frameworks were compiled to support the native architecture. We used the Keras library <ref type="bibr" target="#b20">[21]</ref> to supply and run pre-trained models for TensorFlow and TVM. Two popular convolutional neural networks, Resnet50 <ref type="bibr" target="#b21">[22]</ref> and VGG19 <ref type="bibr" target="#b22">[23]</ref>, are evaluated as seen in Figure <ref type="figure" target="#fig_11">11</ref>. TensorFlow was compiled with XLA enabled. TVM was compiled with LLVM 6.0, but without auto-tuning enabled or any specialized schedules. Presented results used a batch size of 8 on all three frameworks. Each framework's performance (in frames per second) did not vary significantly across batch sizes of 2, 4, and 8.</p><p>As seen in Figure <ref type="figure" target="#fig_11">11</ref>, Glow is up to 2.7x faster than TensorFlow. This is due to the fact that TensorFlow calls into Eigen which implements convolution using the classic im2col followed by matrix multiplication, while Glow compiles direct convolution (Section 5.2) and thus avoids im2col overhead. In addition, Glow performs shape-aware code-generation.</p><p>Additionally, Glow is up to 1.3x faster than TVM. Note that we did not use autotuning and improved schedules with TVM; we expect this would improve TVM's performance. TVM does not use im2col like TensorFlow; similar to Glow, TVM lowers nodes into a low-level IR. This IR is Halide-based, which generates LLVM IR that is compiled for the native architecture. TVM and Glow also both generate code with efficient memory access patterns such as tiling.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>This paper presented the design of Glow, a machine learning compiler for heterogeneous hardware. Glow lowers the compute graph of neural networks to multilevel strongly-typed intermediate representations, enabling analyses and optimizations appropriate for each level to efficiently and scalably target many backends. We hope our efforts will enable research in the area of machine learning acceleration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Acknowledgements</head><p>In addition to the core Glow team, many fellow people at Facebook have made contributions to the project, including Andrew Adams, Michel Aoun, William Arnold, Sarah Bird, Brad Cottel, Stephen Chen, Evan Cheng, Soumith Chintala, Sy Choudhury, Chris Dewan, Utku Diril, Marat Dukhan, Oniel Duncan,</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Compilers struggle to analyze and optimize this code when the two loops come from two different nodes in the dataflow graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>declare { %input = weight float &lt;8 x 28 x 28 x 1 &gt; , broadcast , 0.0 %filter = weight float &lt;16 x 5 x 5 x 1 &gt; , xavier , 25.0 %filter0 = weight float &lt;16 &gt; , broadcast , 0.100 %weights = weight float &lt;10 x 144 &gt; , xavier , 144.0 %bias = weight float &lt;10 &gt; , broadcast , 0.100 %selected = weight index &lt;8 x 1 &gt; ... %result = weight float &lt;8 x 10 &gt; } program { %allo = alloc float &lt;8 x 28 x 28 x 16 &gt; %conv = convolution [5 1 2 16</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Unoptimized low-level Glow IR.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3</head><label>3</label><figDesc>Figure 3  shows an example of unoptimized Glow IR. Note that the 'alloc' instruction does not allocate memory; it just marks the lifetime of the activation. The low-level memory allocator is responsible for allocating all of the buffers into a single coalesced region.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Example class-gen for the Average Pool instruction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>observing execution during inference to estimate the possible numeric range for each stage of the neural network. Training-based quantization is considered future work.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>4. 1</head><label>1</label><figDesc>Tensor Representation In Glow, tensors are typed and can represent floats, quantized non-floating-point values such as currently supported Int8 (8-bit signed integers), and index types. A quantized tensor's type is made up of the underlying element type (Int8), as well as the possible range of the values in the tensor using 'scale' and 'offset' fields. To convert from the 8-bit integer range of [-128..127] to the floating-point number that they represent, Glow uses the conversion formula: value = ( input -offset ) * scale</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: A quantized subgraph from Resnet50.</figDesc><graphic url="image-1.png" coords="7,318.43,63.24,227.35,216.63" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: A subgraph from Resnet50 optimized for the CPU backend. The CPUConvDKKC8 node requires weights with a modified memory layout for efficient SIMD access (Figure 6).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: A loop in x86 assembly as generated by the Glow CPU Backend, with a fused element-wise addition and ReLU (max) operation.</figDesc><graphic url="image-3.png" coords="9,65.75,62.76,228.30,230.35" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 9 :Figure 10 :</head><label>910</label><figDesc>Figure 9: A simple example showing a graph partitioned into multiple sub-graphs, themselves making up a directed graph, and then converted into a schedule by the executor.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Glow vs. TensorFlow-1.7 and TVM on an Intel R Core i7-7600U; frames per second on a single thread.</figDesc><graphic url="image-4.png" coords="11,317.96,62.77,228.29,163.10" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>depicts the transformed filter memory layout.</figDesc><table><row><cell>LBB14_1 :</cell></row><row><cell>vmovaps 3211264( % rcx , % rax ,4) , % ymm1</cell></row><row><cell>vmovaps 3211296( % rcx , % rax ,4) , % ymm2</cell></row><row><cell>vmovaps 3211328( % rcx , % rax ,4) , % ymm3</cell></row><row><cell>vaddps 6422528( % rcx , % rax ,4) , % ymm1 , % ymm1</cell></row><row><cell>vaddps 6422560( % rcx , % rax ,4) , % ymm2 , % ymm2</cell></row><row><cell>vmovaps 3211360( % rcx , % rax ,4) , % ymm4</cell></row><row><cell>vaddps 6422592( % rcx , % rax ,4) , % ymm3 , % ymm3</cell></row><row><cell>vaddps 6422624( % rcx , % rax ,4) , % ymm4 , % ymm4</cell></row><row><cell>vmaxps % ymm0 , % ymm1 , % ymm1</cell></row><row><cell>vmaxps % ymm0 , % ymm2 , % ymm2</cell></row><row><cell>vmaxps % ymm0 , % ymm3 , % ymm3</cell></row><row><cell>vmovaps % ymm1 , 6422528( % rcx , % rax ,4)</cell></row><row><cell>vmovaps % ymm2 , 6422560( % rcx , % rax ,4)</cell></row><row><cell>vmaxps % ymm0 , % ymm4 , % ymm1</cell></row><row><cell>vmovaps % ymm3 , 6422592( % rcx , % rax ,4)</cell></row><row><cell>vmovaps % ymm1 , 6422624( % rcx , % rax ,4)</cell></row><row><cell>addq $32 , % rax</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>IRGen is optional; backends can it if they have their own software stack that prefers to consume the Node representation of the program.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>http://llvm.org/docs/LangRef.html# alloca-instruction</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><p><rs type="person">Dmytro Dzhulgakov</rs>, <rs type="person">Peter Goldsborough</rs>, <rs type="person">Chris Gottbrath</rs>, <rs type="person">Kim Hazelwood</rs>, <rs type="person">Yangqing Jia</rs>, <rs type="person">Aravind Kalaiah</rs>, <rs type="person">Daya S Khudia</rs>, <rs type="person">Changkyu Kim</rs>, <rs type="person">Bruce Lin</rs>, <rs type="person">Howard Mansell</rs>, <rs type="person">Erik Meijer</rs>, <rs type="person">Arun Moorthy</rs>, <rs type="person">Sam Naghshineh</rs>, <rs type="person">Maxim Naumov</rs>, <rs type="person">Avinash Nayak</rs>, <rs type="person">Pieter Noordhuis</rs>, <rs type="person">Joe Pamer</rs>, <rs type="person">Joel Pobar</rs>, <rs type="person">Yuri Putivsky</rs>, <rs type="person">Lin Qiao</rs>, <rs type="person">Vijay Rao</rs>, <rs type="person">Martin Schatz</rs>, <rs type="person">Alexander Sidorov</rs>, <rs type="person">Joe Spisak</rs>, <rs type="person">Narayanan Sundaram</rs>, <rs type="person">Andrew Tulloch</rs>, <rs type="person">Mor Tzur</rs>, <rs type="person">Nicolas Vasilache</rs>, <rs type="person">Adam Weis</rs>, and <rs type="person">Hector Yuen</rs>.</p><p>We also would like to thank <rs type="person">Eli Bendersky</rs>, <rs type="person">Chris Leary</rs>, <rs type="person">Richard Wei</rs>, and <rs type="person">Tianqi Chen</rs> for the development and release of their work to the open source.</p></div>
			</div>			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">L</forename><surname>Hennessy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">A</forename><surname>Patterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Architecture</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note>Sixth Edition: A Quantitative Approach, chapter 7.2. 6th edition</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">XLA: Domain-specific compiler for linear algebra to optimizes tensorflow computations</title>
		<ptr target="https://www.tensorflow.org/performance/xla" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">TVM: End-to-End Optimization Stack for Deep Learning</title>
		<author>
			<persName><forename type="first">T</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Moreau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Guestrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018-02">February 2018</date>
		</imprint>
	</monogr>
	<note>ArXiv e-prints</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Automatic differentiation in PyTorch</title>
		<author>
			<persName><forename type="first">Adam</forename><surname>Paszke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sam</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Soumith</forename><surname>Chintala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gregory</forename><surname>Chanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edward</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zachary</forename><surname>Devito</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zeming</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alban</forename><surname>Desmaison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luca</forename><surname>Antiga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adam</forename><surname>Lerer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Caffe: Convolutional Architecture for Fast Feature Embedding</title>
		<author>
			<persName><forename type="first">Yangqing</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Evan</forename><surname>Shelhamer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeff</forename><surname>Donahue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sergey</forename><surname>Karayev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ross</forename><surname>Girshick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sergio</forename><surname>Guadarrama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Trevor</forename><surname>Darrell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ACM International Conference on Multimedia, MM &apos;14</title>
		<meeting>the 22nd ACM International Conference on Multimedia, MM &apos;14<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="675" to="678" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">TensorFlow: A System for Large-scale Machine Learning</title>
		<author>
			<persName><forename type="first">Mart?n</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Barham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jianmin</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhifeng</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andy</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthieu</forename><surname>Devin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sanjay</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geoffrey</forename><surname>Irving</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Isard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manjunath</forename><surname>Kudlur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Josh</forename><surname>Levenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajat</forename><surname>Monga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sherry</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Derek</forename><forename type="middle">G</forename><surname>Murray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benoit</forename><surname>Steiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Tucker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vijay</forename><surname>Vasudevan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pete</forename><surname>Warden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Wicke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuan</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaoqiang</forename><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th USENIX Conference on Operating Systems Design and Implementation, OSDI&apos;16</title>
		<meeting>the 12th USENIX Conference on Operating Systems Design and Implementation, OSDI&apos;16<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="265" to="283" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName><surname>Onnx</surname></persName>
		</author>
		<ptr target="https://onnx.ai/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Cntk: Microsoft&apos;s opensource deep-learning toolkit</title>
		<author>
			<persName><forename type="first">Frank</forename><surname>Seide</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amit</forename><surname>Agarwal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22Nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, KDD &apos;16</title>
		<meeting>the 22Nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, KDD &apos;16<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="2135" to="2135" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName><surname>Eigen</surname></persName>
		</author>
		<ptr target="http://eigen.tuxfamily.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title/>
		<author>
			<persName><surname>Nvidia Cudnn</surname></persName>
		</author>
		<ptr target="https://developer.nvidia.com/cudnn" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">LLVM: A Compilation Framework for Lifelong Program Analysis &amp; Transformation</title>
		<author>
			<persName><forename type="first">Chris</forename><surname>Lattner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vikram</forename><surname>Adve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Code Generation and Optimization: Feedback-directed and Runtime Optimization, CGO &apos;04</title>
		<meeting>the International Symposium on Code Generation and Optimization: Feedback-directed and Runtime Optimization, CGO &apos;04<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page">75</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">Nadav</forename><surname>Rotem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arnold</forename><surname>Schwaighofer</surname></persName>
		</author>
		<ptr target="https://llvm.org/devmtg/2013-11/#talk10" />
		<title level="m">LLVM Developers&apos; Meeting</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>Vectorization in LLVM</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<ptr target="http://tvmlang.org/2017/10/06/nnvm-compiler-announcement.html" />
		<title level="m">Amazon Web Service AI team, and DMLC open-source community. NNVM Compiler: Open Compiler for AI Frameworks</title>
		<imprint/>
		<respStmt>
			<orgName>University of Washington Paul G. Allen School of Computer Science &amp; Engineering</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Halide: A Language and Compiler for Optimizing Parallelism, Locality, and Recomputation in Image Processing Pipelines</title>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Ragan-Kelley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Connelly</forename><surname>Barnes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sylvain</forename><surname>Paris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fr?do</forename><surname>Durand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Saman</forename><surname>Amarasinghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;13</title>
		<meeting>the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;13<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="519" to="530" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">DLVM: A modern compiler infrastructure for deep learning systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Schwartz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Adve</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017-11">November 2017</date>
		</imprint>
	</monogr>
	<note>ArXiv e-prints</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Intel nGraph: An Intermediate Representation, Compiler, and Executor for Deep Learning</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cyphers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Bansal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bhiwandiwalla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bobba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Brookhart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chakraborty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Constable</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Convey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Kanawi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kimball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Knight</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Korovaiko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Lishka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Menon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Narayana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Procter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Webb</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018-01">January 2018</date>
		</imprint>
	</monogr>
	<note>ArXiv e-prints</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Mkl</forename><surname>Intel</surname></persName>
		</author>
		<ptr target="https://software.intel.com/en-us/mkl" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">N</forename><surname>Vasilache</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Zinenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Theodoridis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Goyal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>De-Vito</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">S</forename><surname>Moses</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Verdoolaege</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cohen</surname></persName>
		</author>
		<title level="m">Tensor Comprehensions: Framework-Agnostic High-Performance Machine Learning Abstractions</title>
		<imprint>
			<date type="published" when="2018-02">February 2018</date>
		</imprint>
	</monogr>
	<note>ArXiv eprints</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title/>
		<author>
			<persName><surname>Swift</surname></persName>
		</author>
		<ptr target="https://developer.apple.com/swift/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Deep Learning</title>
		<author>
			<persName><forename type="first">Ian</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aaron</forename><surname>Courville</surname></persName>
		</author>
		<ptr target="http://www.deeplearningbook.org" />
		<imprint>
			<date type="published" when="2016">2016</date>
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<ptr target="https://keras.io/" />
		<title level="m">Keras: The Python Deep Learning library</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Deep residual learning for image recognition</title>
		<author>
			<persName><forename type="first">Kaiming</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiangyu</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shaoqing</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jian</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2016 IEEE Conference on Computer Vision and Pattern Recognition</title>
		<meeting><address><addrLine>Las Vegas, NV, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-06-27">2016. June 27-30, 2016. 2016</date>
			<biblScope unit="page" from="770" to="778" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Very deep convolutional networks for large-scale image recognition</title>
		<author>
			<persName><forename type="first">K</forename><surname>Simonyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zisserman</surname></persName>
		</author>
		<idno>CoRR, abs/1409.1556</idno>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
