<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Rosemary: A Robust, Secure, and High-Performance Network Operating System</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Seungwon</forename><surname>Shin</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Atto-Research SRI International</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yongjoo</forename><surname>Song</surname></persName>
							<email>yongjoo.song@atto-research.com</email>
							<affiliation key="aff0">
								<orgName type="department">Atto-Research SRI International</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Taekyung</forename><surname>Lee</surname></persName>
							<email>taekyung.lee@atto-research.com</email>
							<affiliation key="aff0">
								<orgName type="department">Atto-Research SRI International</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sangho</forename><surname>Lee</surname></persName>
							<email>sangho.lee@atto-research.com</email>
							<affiliation key="aff0">
								<orgName type="department">Atto-Research SRI International</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jaewoong</forename><surname>Chung</surname></persName>
							<email>jaewoong.chung@atto-research.com</email>
							<affiliation key="aff0">
								<orgName type="department">Atto-Research SRI International</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Phillip</forename><surname>Porras</surname></persName>
							<email>porras@csl.sri.com</email>
							<affiliation key="aff0">
								<orgName type="department">Atto-Research SRI International</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Vinod</forename><surname>Yegneswaran</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Atto-Research SRI International</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jiseong</forename><surname>Noh</surname></persName>
							<email>jiseong.noh@kaist.ac.kr</email>
							<affiliation key="aff0">
								<orgName type="department">Atto-Research SRI International</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Brent</forename><forename type="middle">Byunghoon</forename><surname>Kang</surname></persName>
							<email>brentkang@kaist.ac.kr</email>
							<affiliation key="aff0">
								<orgName type="department">Atto-Research SRI International</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">†</forename><surname>Kaist</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Atto-Research SRI International</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Rosemary: A Robust, Secure, and High-Performance Network Operating System</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">F2524D66BA04BAE7CBC82FE7C4B53D25</idno>
					<idno type="DOI">10.1145/2660267.2660353</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:28+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C.2.4 [Computer-Communication Networks]: Network Operating Systems Software-Defined Network (SDN)</term>
					<term>OpenFlow</term>
					<term>Controller Robustness</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Within the hierarchy of the Software Defined Network (SDN) network stack, the control layer operates as the critical middleware facilitator of interactions between the data plane and the network applications, which govern flow routing decisions. In the OpenFlow implementation of the SDN model, the control layer, commonly referred to as a network operating system (NOS), has been realized by a range of competing implementations that offer various performance and functionality advantages: Floodlight [11], POX [30], NOX <ref type="bibr" target="#b13">[14],</ref> and ONIX [18]. In this paper we focus on the question of control layer resilience, when rapidly developed prototype network applications go awry, or third-party network applications incorporate unexpected vulnerabilities, fatal instabilities, or even malicious logic. We demonstrate how simple and common failures in a network application may lead to loss of the control layer, and in effect, loss of network control.</p><p>To address these concerns we present the ROSEMARY controller, which implements a network application containment and resilience strategy based around the notion of spawning applications independently within a micro-NOS. ROSEMARY distinguishes itself by its blend of process containment, resource utilization monitoring, and an application permission structure, all designed to prevent common failures of network applications from halting operation of the SDN Stack. We present our design and implementation of ROSE-MARY, along with an extensive evaluation of its performance relative to several of the mostly well-known and widely used controllers. Rather than imposing significant performance costs, we find that with the integration of two optimization features, ROSE-MARY offers a competitive performance advantage over the majority of other controllers.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>At the center of the growing emergence of the SDN paradigm is the notion of giving control of network flow routing decisions to a globally intelligent view, hosted above the data plane, that is able to coordinate across network components. SDNs enable this intelligence to be written in software, as network applications, using open APIs that better facilitate agile development and perhaps faster network innovations.</p><p>The OpenFlow stack is an embodiment of this notion. It offers a dramatic shift from the proprietary closed control layer of traditional network switches, to one in which the control layer exports both the API and the data plane abstractions necessary to facilitate a wide range of network applications. The introduction of the term network operating system (NOS) was born from the recognition of how the OpenFlow control layer provides network application developers with programming abstractions necessary to control the network data-plane hardware. The control layer provides interface and abstraction in a role analogous to that of operating systems, which provide software developers an appropriate abstraction for interacting with a host computer. Here, we will follow and extend this analogy, and will use the term network operating systems (NOSs) and OpenFlow controllers interchangeably.</p><p>Unfortunately, the myriad of parallel efforts to design NOSs (e.g., POX <ref type="bibr">[30]</ref>, NOX <ref type="bibr" target="#b13">[14]</ref>, Beacon <ref type="bibr" target="#b9">[10]</ref>, Floodlight <ref type="bibr" target="#b10">[11]</ref>), have largely assumed the role of the NOS as the facilitator between benign Open-Flow applications and the data plane. The problems that may arise when an OpenFlow application contains flaws, vulnerabilities, or malicious logic that may interfere with control layer operations have remained largely unaddressed by existing OpenFlow controller implementations. Indeed, we will show examples of various Open-Flow applications that, when implemented with the basic flaws commonly found in prototype applications, lead to the crash of the control plane and effective loss of the network itself. These examples serve to both establish the importance of solid network application development and illustrate an important need for robust control layer safeguards to ensure network applications remain within bounds that protect the OpenFlow stack.</p><p>We introduce ROSEMARY as a NOS that integrates key safeguards that extend the control layer to not just facilitate OpenFlow applications, but also to impose an independent sandbox around each network application. ROSEMARY's objective is to prevent applications from performing operations that will otherwise corrupt other widely used OpenFlow controllers. We refer to ROSEMARY's  containment strategy as a micro-NOS architecture, in which each OpenFlow application is spawned within an independent instance of ROSEMARY, wherein it is monitored and constrained with resource utilization controls that prevent it from interfering with the broader operations of the OpenFlow stack.</p><p>A micro-NOS implements several key functional design requirements that combine to provide application containment. First, it provides process context separation from the control layer by spawning a network application in a separate process context, with the NOS interface libraries and data abstractions necessary for the application to operate. Second, the micro-NOS incorporates resource monitoring services that track and recognize consumption patterns that may violate resource utilization policies imposed upon the application. Third, each micro-NOS instance operates within a permission structure of the ROSEMARY NOS, that limits which libraries are incorporated into the micro-NOS, thereby constraining the ability of the network application to access interfaces or resources of the NOS kernel. Finally, ROSEMARY's design pays careful attention to the performance considerations that are imposed with its micro-NOS compartmentalization.</p><p>We present two optimization mechanisms that can be utilized in ROSEMARY deployments to enable a balance between the need for strict robustness controls and the need for network application performance. Request pipelining represents a series of task, IPC, and task-to-CPU core-pinning optimizations that enable substantial performance optimization in ROSEMARY's packet processing pipeline. We further introduce a trusted execution mode for network applications, which can be employed with well-vetted applications to remove the micro-NOS IPC overhead. With or without trusted execution services, ROSEMARY's performance is substantially superior to many leading OpenFlow controllers.</p><p>To summarize, the paper's contributions include the following:</p><p>1. We survey a range of critical robustness issues found in several existing OpenFlow controllers. We identify the underlying vulnerabilities in the controller operations that enable the network application layer to destabilize the control plane.</p><p>2. We present the design of ROSEMARY, which introduces the use of a micro-NOS sandboxing strategy to safeguard the control layer from errant operation performed by the network application. ROSEMARY's resilience in the presence of malicious or faulty network applications that would otherwise crash other OpenFlow controllers is derived from three key services: context separation, resource utilization monitoring, and the micro-NOS permissions structure that limits the network application's access to library functionality.</p><p>3. We design and implement a prototype of ROSEMARY, which we argue offers a robust application execution environment, while also enabling execution modes that can run vetted network applications with very high performance metrics relative to existing OpenFlow controllers. We have evaluated the prototype system under a range of diverse test cases to measure its performance, finding that ROSEMARY can sustain more than 10 million flow requests per second.</p><p>Roadmap. The remainder of this paper is organized as follows. In Section 2, we provide a few motivating examples and discuss some open research problems. In Sections 3 and 4, we present the design and implementation of our system, respectively. Next, we provide evaluation results demonstrating the robustness and scalability of our system in Section 5. We also discuss system limitations (Section 6) and related work (Section 7). Finally, we conclude with a brief summary in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">MOTIVATING EXAMPLES AND RESEARCH QUESTIONS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Few Motivating Examples</head><p>We have witnessed the emergence of several open-source and commercial efforts to develop NOSs including POX [30], Floodlight <ref type="bibr" target="#b10">[11]</ref>, OpenDaylight <ref type="bibr" target="#b22">[23]</ref>, and NOX <ref type="bibr" target="#b13">[14]</ref>. These controller designs have formed the basis of many commercial SDN network deployments and academic research efforts. Additional results with Beacon and POX are provided in the appendix. Until recently, most of these designs (from industry and academia) have been primarily focused on efficiently handling data plane requests. Security and robustness of OpenFlow controllers has arguably been an understudied area with some recent notable exceptions <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b34">36]</ref>. However, these unfledged research efforts are still very much in flux and require validation through large scale deployments. Furthermore, they have largely ignored controller robustness, i.e., the threat vector of malicious OpenFlow applications directly attacking the controller.</p><p>In this section, we motivate the need for both network controller robustness and ROSEMARY through tangible examples that underscore the vulnerability of contemporary OpenFlow controllers to malicious OpenFlow applications.</p><p>Test Environment. To test the robustness and the security of a NOS, we have set up a simple test environment, as shown in Figure <ref type="figure" target="#fig_0">1</ref>. We choose Floodlight and OpenDaylight as our main target OpenFlow controllers, because they are two of the most popular and emerging network operating systems. Two hosts (Host A and Host B) are connected to each other through an OpenFlow switch (i.e., data plane), and this switch is controlled by the OpenFlow controller. Here, we run four network applications on the Open-Flow controller: (i) a simple routing application, (ii) a network monitoring application, (iii) a firewall application, and (iv) a test application. We modify this test application to evaluate the robustness and the security of the NOS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.1">Floodlight Case Study</head><p>We describe results from three different evaluations, including two misbehaving applications for testing robustness and another rogue application that affects security The objective of the first application is to silently crash a Floodlight instance. This application simply calls an exit function, when it is invoked by Floodlight. The next application, whose code is illustrated below, creates multiple memory objects. We will test how this application consumes memory resources allocated to a Floodlight instance. The final application, illustrated through source code on the right, modifies the internal data structure of a Floodlight instance. In this case, we assume that this application is installed by an attacker, and that it deletes some network links in an attempt to confuse other applications.</p><p>Testing Floodlight Robustness. In this case, we let the test application conduct two unintended operations: (i) exit a program suddenly and (ii) continuously allocate memory space. These operations, when performed in the wrong context, result in a crash of the Floodlight controller.</p><p>In the first of these examples, the developer inadvertently calls a system exit or return (with exit) function. Figure <ref type="figure">2</ref> (in next page) shows the result: when a buggy application accidentally calls an exit function, we observe that the Floodlight instance is also killed.</p><p>For the second case, a memory leakage is presented in Figure <ref type="figure">3</ref> (in next page). Here, the developer creates a linked list without bounds checking and allows the list to grow without limit. The Floodlight instance does not limit memory allocations by its applications, finally resulting in the controller (technically, the JVM) crashing with an out of memory error.</p><p>As both of these errors result from programming errors, we consider these to be misbehaving, and not necessarily malicious, applications.</p><p>Testing Floodlight Security. We modify the test application to access an internal data structure in Floodlight, which contains network link information, and change certain values representing network links. To show the effect of this test, we let the monitoring application (shown in Figure <ref type="figure" target="#fig_0">1</ref>) periodically access a Floodlight data structure (i.e., network link table) and display network link information. When our test application modifies values in the data structure (i.e., network link information), the monitoring application presents the wrong information. To perform this test, we simply create a network environment with Mininet <ref type="bibr" target="#b19">[20]</ref>, which consists of two switches connected to each other. The network link information before and after the attack is presented in Figure <ref type="figure" target="#fig_1">4</ref> (top and bottom) to illustrate how a simple rogue application can easily confuse other network applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2">OpenDaylight Case Study</head><p>Next, we evaluate the recently announced OpenDaylight controller <ref type="bibr" target="#b22">[23]</ref>, and check if it the problems that are similar to the Floodlight controller. Due to space we simply present the case of crashing a NOS instance by calling a system exit function, and the test result is shown in Figure <ref type="figure" target="#fig_2">5</ref>. We find that OpenDaylight has similar robustness issues, despite its recent release (i.e., early 2014).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.3">POX Case Study</head><p>Next, we conduct an experiment that results in the POX controller [30] being killed. In this test, we run a monitoring application and a test applications which we crash simultaneously using Mininet <ref type="bibr" target="#b19">[20]</ref>). Here, our test application (shown in Figure <ref type="figure">6</ref>) simply calls a system exit function (i.e., sys.exit(0) function), when it is launched, and the monitoring application periodically collects network statistics information. The result shown in Figure <ref type="figure">7</ref>, illustrates how a crash of the test application causes both the monitoring application and the controller to terminate. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.4">Beacon Case Study</head><p>Finally, we conduct the same robustness tests (i.e., crash and memory leak) with Beacon <ref type="bibr" target="#b9">[10]</ref>, and the results are presented in Figure <ref type="figure">8</ref> and Figure <ref type="figure">9</ref>. This second set of studies illustrate that these problems are not only problems of a specific NOS (i.e., Floodlight), but also prevalent in other NOSs. These examples illustrate how simple applications (in under 10 lines of code) can crash an Open-Flow controller rather easily.</p><p>We do not include exemplar security attacks on OpenDaylight, Beacon, and POX due to space limitations, but similar vulnerabilities exist. While we assume and hope that trusted network experts design and implement network applications, our objective here is to motivate the need to incorporate safeguards into the control layer   2.2 Why Are NOSs NOT Robust?</p><p>R1. No Separation of Applications from Network OS. Perhaps the most critical problem affecting existing NOSs is that they run applications in the same privilege zone where a NOS resides. For example, in the case of NOX, it runs a network application as a function invoked from the main module of NOX <ref type="bibr" target="#b13">[14]</ref>. We assume that the reasoning behind this design choice is to improve performance by reducing potential overhead due to increased interprocess communication (IPC) and additional I/O between the main module and the application. However, this design choice poses serious problems when coupled with misbehaving applications. If a network application crashes, it will also kill a NOS. Of course, one could pass the burden to skilled programmers and static program analysis methods to ensure correctness. In practice, it is very hard to guarantee that an application is flawless across all inputs and execution scenarios.</p><p>Runtime enforcement of application robustness and security constraints, simplifies SDN application development and fosters greater SDN adoption through third-party SDN application stores <ref type="bibr" target="#b15">[16]</ref> that are modeled after popular mobile application stores. This motivates the need for rethinking NOS design with a critical eye toward protection from buggy and untrusted network applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R2. No Application Resource Control. SDN applications can in-</head><p>terfere with NOS and other co-resident applications in other ways besides crashing the controller. For example, they may consume more than their fair share of system resources (memory or CPU) such that other applications and the network controller cannot conduct necessary operations.</p><p>This problem stems from the lack of resource controls for each application. Traditional operating systems have mechanisms to limit the resource usage and provide fairness across applications (e.g., schedulers, ulimit, etc.) However, most existing NOSs do not provide such capabilities and allow a network application to obtain resources without constraints, thereby undermining the robustness of the NOS.</p><p>R3. Monolithic NOSs-A Case for micro-NOS. If we consider the main module of a NOS as the kernel of operating system, we can then view the design of most NOSs as monolithic architectures that contain the most important services running as an agglomerated kernel with all privileges. Most NOSs provide diverse services, such as internal storage and event handling <ref type="bibr" target="#b16">[17]</ref>, to help developers easily implement network applications. Usually, these services are integrated as functions into the main module of a NOS.</p><p>This sort of monolithic architecture can support high-performance at the cost of added complexity. However, as NOSs evolve, they become burdened with more and more functionality for legacy application support and to ease development of new network applications. For example, the latest version of Floodlight provides much more functionality than first generation of the NOX controller. We make the case that the design of NOSs need to be fundamentally reconsidered with first principles from the operating systems community. Specifically, we argue for efficient containment of applications, improved monitoring of resource utilization for policy enforcement and an effective permission structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Why Are NOSs NOT Secure?</head><p>R1. No Authentication. Most contemporary NOSs assume that network applications are trustworthy and do not implement any mechanisms to validate the authenticity of their authorship. For example, in the case of commodity operating systems applications have the ability to be signed, and digital certificate validation is used to notify users when they attempt to run applications that fail validation. Similarly, ROSEMARY incorporates a process for authenticating application developers. Here, we rely on recent research efforts on a new secure NOS that supports digital application authentication <ref type="bibr" target="#b26">[27]</ref>.</p><p>R2. No Access Control. Traditional operating systems (OSs), such as Linux and Windows, do not allow an application to directly access resources managed by the OS. When an application needs access to an OS resource, it requests permission from the operating system (i.e., kernel layer). However, in the case of a NOS, as shown in the example above, a network application can easily access a resource managed by a NOS. This problem stems from the lack of access control methods for system resources.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">What About Performance?</head><p>Since a NOS needs to handle many network requests from multiple data planes, most NOSs are designed to treat as many network requests as possible <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b13">14]</ref>. In our design, to implement a more robust and secure NOS, we must ensure that the added costs of these extensions do not introduce overheads that are prohibitive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">SYSTEM DESIGN</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Design Considerations and Philosophy</head><p>Considering the issues described in Section 2, we summarize the guiding principles that inform the design of ROSEMARY as follows.</p><p>• network applications must be separated from the trusted computing base of the NOS</p><p>• resources for each network application needs to be monitored and controlled</p><p>• shared modules of NOSs need to be compartmentalized</p><p>• network applications must explicitly possess capabilities to access resource of a NOS</p><p>• the system must be adjustable to balance the need for robustness safeguards and the need for higher performance.</p><p>In this section, we present the design of a new NOS, ROSE-MARY, that follows from these principles. The overall architecture of ROSEMARY is illustrated in Figure <ref type="figure" target="#fig_6">10</ref>. Technically, ROSEMARY is an application program running on a generic operating system (e.g., Linux), much like other NOSs.</p><p>ROSEMARY employs a specialized application containment architecture that is inspired by prior work on microkernels <ref type="bibr" target="#b0">[1]</ref>, and exokernels <ref type="bibr" target="#b8">[9]</ref>. These architectures sought to enable increased security and stability by reducing the amount of code running in kernel mode <ref type="foot" target="#foot_0">1</ref> . Exokernels seek to separate protection from management and they do so by using "secure bindings" that reduce the shared portions of OS kernels and implementing "resource revocation" protocols. This approach minimizes the running overhead of an application and reduces hardware abstraction by moving abstractions into untrusted user-space libraries, allowing application visibility into low-level resource information.</p><p>We believe that a robust and secure SDN controller can benefit from several of these ideas. First, a NOS needs to provide a clear view of the data planes to applications: the abstraction of a NOS should be minimal. Second, applications and libraries can be buggy. Hence, important modules for a NOS should be compartmentalized to maximize the reliability of a network operating system. Third, each application has its own purpose, and thus each application requires specialized functions and libraries. Finally, a NOS needs to be minimal and lightweight to guarantee that it can handle large numbers of network requests with low latency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">System Architecture</head><p>As illustrated in Figure <ref type="figure" target="#fig_6">10</ref>, ROSEMARY consists of four main components: (i) a data abstraction layer (DAL), (ii) the ROSE-MARY kernel, (iii) system libraries, and (iv) a resource monitor. DAL encapsulates underlying hardware devices (i.e., network devices) and forwards their requests to the upper layer (i.e., ROSE-MARY kernel). A key objective of DAL is to marshal requests from diverse network devices. For example, while OpenFlow is the dominant SDN interface between the data plane and the control plane, it is conceivable that future controllers would want to support a diverse set of SDN protocols (e.g., XMPP <ref type="bibr" target="#b27">[28]</ref>, DevoFlow <ref type="bibr" target="#b6">[7]</ref>) in an application-agnostic manner.</p><p>The ROSEMARY kernel provides basic necessary services for network applications, such as resource control, security management, and system logging. They are basic services to operate network applications, and we design this component as thinly as possible to expose a clear view of the data plane to an application. ROSEMARY provides diverse libraries for applications, and each application can choose necessary libraries for its operations. When it selects libraries, each application is required to solicit permission from ROSEMARY kernel. The resource monitor (RM) is used to track the respective resource utilization of running applications and terminate misbehaving applications.</p><p>The components described here will be used in addressing the aforementioned design issues. Below, we discuss in detail how each issue is addressed with specific component(s).</p><p>1) Separating Applications from a Network OS Kernel. As we presented in Section 2, one of the primary reasons behind the fragility of NOSs is their tight coupling with applications. To address this issue, we need to have a clear separation between applications and the NOS. A simple means to ensure such isolation is to spawn applications as independent processes. In ROSEMARY, each new network application will be invoked as a new process, which connects to the ROSEMARY kernel process instance through a generic IPC method.</p><p>Imagine a scenario where an application periodically requests several services from ROSEMARY (e.g., network topology information, switch statistics). If we provide each of these services only through an IPC channel, the overhead caused by such communication could be considerable. To mitigate such overhead, we let an application use libraries provided by ROSEMARY to directly communicate over the network. This design is inspired by the Exokernel <ref type="bibr" target="#b8">[9]</ref>. For example, if an application wants to access a data structure, it can attach itself to the storage library as shown in Figure <ref type="figure" target="#fig_6">10</ref>. Of course, each application is required to obtain the specific capabilities prior to using the library.</p><p>2) Compartmentalizing Network OS Kernel Modules. The notion of privilege separation needs to be considered not only between the application and a NOS instance, but also in the design of the NOS itself. To the best of our knowledge, leading NOSs (e.g., Floodlight, NOX, and POX) have all implemented necessary functions in a single protection zone. We refer to such a singleprotection-zone NOS as a monolithic kernel architecture.</p><p>While a case could be made that the monolithic architecture improves performance by minimizing communications across protection zones (IPC), the inherent complexity of such architectures can make reasoning about its security and isolation challenging. The first generation of NOSs (e.g., NOX classic version <ref type="bibr" target="#b13">[14]</ref>) only supported elemental functionality -receive flow requests from the data plane, deliver them to applications, and enforce flow rules to the data planes -to make their design lightweight and simple. However, this is not so true anymore. Current NOSs are bundled with many component libraries to simplify application development. For example, Floodlight provides network status information, and an application developer can simply query this information from Floodlight instead of reimplementing this logic.</p><p>Adding complexity to any system inherently increases its vulnerability to failures and misbehavior. A NOS that conducts the  mission-critical operation of managing networks should be designed to be unsusceptible to such calamities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>U-App : User Application K-App: Kernel Application Lib: Library</head><note type="other">App Zone App Zone</note><p>To improve controller resilience, we separate services in the ROSE-MARY kernel into different pieces (i.e., processes), making it analogous to a microkernel architecture. We call this design a micro-NOS. A NOS with this architecture has several advantages over a NOS using the monolithic architecture. First, it makes a network operating system lightweight by enabling on-demand invocation of services. For example, if a NOS only needs to support an application for simple network switching, it simply needs to distribute data plane events to the application; thus it is not necessary to run other network services.</p><p>This design increases the robustness of a NOS, because it only runs necessary services. Second, services in the ROSEMARY kernel communicate each other through an IPC channel, and the implication is that if a service crashes, other services are immune to this crash.</p><p>3) Controlling Application Resource Utilization. Although network applications are detached from the core of the ROSEMARY network operating system and cannot crash it, it is possible that a buggy or a malicious network application can interfere with the operation of co-resident applications. As shown in Section 2, an application that keeps allocating memory can consume all of the available memory in a host, thereby affecting other applications.</p><p>To mitigate this effect, we need to differentiate each application's working space and limit resources that each network application can use, much like a generic operating system does. ROSEMARY also provides similar functionality to control the resource usage of each network application through its resource manager (RM) component. The vantage point of the RM provides unique ability to control diverse resources used by SDN applications, but here we focus on critical system resources that are tightly coupled with the robustness of a network operating system and co-resident applications. The resources that ROSEMARY currently considers include the following: (i) CPU, (ii) memory, and (iii) file descriptor.</p><p>The algorithm to control the resources is presented in Figure <ref type="figure" target="#fig_8">11</ref> (right). The maximum resources assigned to each application are managed by a table. This table, illustrated through the resource table in Figure <ref type="figure" target="#fig_8">11</ref>, maintains two values for each resource item: (i) a hard limit and (ii) a soft limit. The hard limit specifies that an application cannot obtain more resource than this value. For example, if a hard limit value for the memory item is 2 GB, then the application is terminated if it attempts to allocate more than 2 GB of memory. The soft limit defines a value that each application may pass but is not recommended. Violations of the soft limit result in an alert that is passed back to the application and reported to the network operator.</p><p>Resource manager -resource table -Memory: hard limit (2G), soft limit (1G) CPU: hard limit (100%), soft limit (80%) File Descriptor: hard limit (1024), soft limit (512) Network Usage: hard limit (1G/s), soft limit (800M/s)  The aforementioned design choices are primarily intended to improve system robustness; however, we still need to address the security concerns described in Section 2. For example, a malicious application may access internal data structures and modify them without restriction, thereby confusing other network applications.</p><p>We address this issue by employing a sandbox approach, which we have named App Zone. Its detailed architecture is presented in Figure <ref type="figure" target="#fig_9">12</ref>, and it essentially runs an application within a confined environment to monitor and control the application's operations. When an application makes privileged system calls (e.g., spawns processes or accesses internal storage modules), such operations are interposed by our management module which we call the system call access check module. This enables the operator to control the set of operations that may be performed by applications.</p><p>In addition, App Zone examines whether this application is authorized or not by investigating its signed key (application authorization module). ROSEMARY provides a public key, and all application developers are required to sign their applications with this key. Such an approach has also been adopted by other related work . Besides these issues, App Zone monitors flow rule enforcement operations initiated by an application to investigate whether there is any abnormal behavior. For example, if an application tries to enforce too many flow rules that cannot be inserted into the data plane, its operation is considered abnormal. In this case, the flow rule enforcement module monitors this operation, and reports if it finds these abnormal behaviors. In the current state, we have a threshold-based detector, which generates an alert when it finds an application that tries to deliver more flow rules than a predefined threshold value. This threshold value will be determined based on the capability of the data plane at boot time. Specifically, this module checks the maximum number of flow rule entries for each data plane, and it sets the corresponding threshold value to be a certain percentage of this number (currently, we use 90%). 5) Monitoring the Network OS. When ROSEMARY is invoked, its core services are monitored by an external monitoring process (Resource Monitor in Figure <ref type="figure" target="#fig_6">10</ref>). If this monitor process detects any anomalous behaviors in ROSEMARY (e.g., service crash or memory leakage), it will react to them are summarized in Table <ref type="table" target="#tab_1">1</ref>. When the monitor process detects any anomalous behaviors, it also records them into a logging system. This record is useful for further analysis of anomalous behaviors as well as for improving and hardening ROSEMARY.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6) Safely</head><p>Restarting the Network OS. When the Resource Monitor process detects serious problems (e.g., crash of critical services) it immediately restarts ROSEMARY services. At this time, ROSEMARY decides whether or not it must restarts all services and network applications. Since sometimes it is not easy to discover why ROSEMARY crashed (i.e., which service or application caused ROSEMARY to crash), we need to carefully restart each service. In-spired by the Safe Mode booting of the Windows operating system that boots up only the basic and necessary services of Windows, we have designed a safe mode booting process for ROSEMARY that is similar in spirit.</p><p>When the Resource Monitor decides to boot up ROSEMARY in Safe Mode, it only runs the basic services and network applications that are defined by the administrator. At first, it invokes basic ROSEMARY kernel services: resource manager, system log manager, and security manager. Then, it runs network applications in the order specified by the administrator. Since it is very possible that a single misbehaving application is the main cause of the crash, we need to run only necessary network applications at the boot stage. Once this initial boot is complete, if there are any kernel-applications running, it changes their modes to be user-level applications in order to guarantee robustness. After booting up necessary services and applications, the Resource Monitor analyzes log files to investigate the reason behind the problem. If the cause of the crash can be attributed to a single application, it reports this log indicator to the administrator. 7) Performance Considerations. Separation of applications from a NOS instance is good for robustness and security, but it imposes additional latency overhead due to added IPC. To minimize the overhead and guarantee required performance, we employ two mechanisms: (i) request pipelining and (ii) trusted execution.</p><p>Request Pipelining -Pipelining is a well-known technique that splits a task into multiple subtasks and executes them with as many execution units as subtasks. Though it adds latency overhead to pass data between subtasks, it can greatly improve throughput. ROSE-MARY overlaps the subtask split for pipelining with the kernel or application separation for robustness, named request pipelining, as shown in Figure <ref type="figure" target="#fig_0">13</ref>. As such, from the perspective of pipelining, the kernel and applications are pipelined subtasks and their communication is data transfer between subtasks. When ROSE-MARY receives packets from switches and routers, the kernel thread processes the controller protocol (e.g., OpenFlow), prioritizes the packets, passes them to applications through an IPC (inter-process communication) primitive, and completes the first stage of request pipelining. The IPC primitive, a domain socket in the case of the current implementation, works both as a pipelining latch for throughput improvement and as a boundary of separated execution between the kernel and application for robustness. Receiving the packets through the IPC primitive, the application that will process the packets starts the second stage of request pipelining. In Section 5, we show how request pipelining yields high packet processing throughput while also providing robustness in ROSEMARY.</p><p>For further performance improvement, ROSEMARY carefully pins down the kernel process and application processes onto CPU cores so that communication between pipelined stages is assigned to adjacent CPU cores for lower CPU interconnect overhead. In addition, interrupt signals from network cards are configured to be routed to the CPU cores that are running the kernel process in order to eliminate possible interrupt rerouting among cores. Lockfree data structures, such as a lock-free FIFO for queuing packets, are heavily used to avoid locking overhead as well.</p><p>Trusted Execution -While request pipelining provides high throughput and robustness, ROSEMARY offers another application execution mode for latency-critical applications, named trusted execution. At the discretion of system operators, an application can be integrated with the kernel and run in the kernel process; we call this a Kernel-application). The application should be seriously sanitized, because this execution mode compromises robustness for latency  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">IMPLEMENTATION</head><p>We have implemented a prototype of ROSEMARY to evaluate its robustness, security, and performance. We implement the prototype as a C application consisting of approximately 20,000 lines of code. ROSEMARY libraries are also written in C. The system currently supports both the OpenFlow 1.0 specification <ref type="bibr" target="#b11">[12]</ref> and the OpenFlow 1.3 specification <ref type="bibr" target="#b12">[13]</ref> in the data abstraction layer (DAL), and we are planning to support the XMPP protocol <ref type="bibr" target="#b35">[37]</ref> in the near future.</p><p>We employ standard pthread libraries (i.e., POSIX pthread <ref type="bibr" target="#b3">[4]</ref>) to implement the basic kernel services and applications to increase the portability. In addition, each network application can run multiple working threads at the same time to increase its performance, and the thread package (i.e., pthread) has also been used in this case.</p><p>In its current stage, APIs for developing an application (both user application and kernel application) are written in C, and thus network applications are also written in C. We are currently developing APIs in additional languages, such as Python and Java, which will provide developers with additional options. We have also implemented a tool to generate both types of applications automatically. Note that a network application developer need only implement an application once, and it can be instantiated as either a user or kernel application. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Evaluation Environment</head><p>Robustness and Security Testing Environment. Figure <ref type="figure" target="#fig_1">14</ref> presents the evaluation environment used to test the robustness and the security of ROSEMARY. In this environment, we run three applications that we have tested in Section 2. The first application -Crash App -will simply call an exit function to kill itself. The second application -Memory Leak App -will allocate memory objects continuously. The third application -Data Access App -will try to access an internal data structure, which is not allowed. In addition, we run a normal network security application -Firewall App, which simply blocks malicious packets from Host A -to investigate whether this application is affected by other applications. Performance Testing Environment. To measure and compare the throughput of each NOS, we use the test environment shown in Figure <ref type="figure" target="#fig_11">15</ref>. Here, we have two independent hosts: (i) a client generating data plane requests and (ii) a server operating each NOS. The hardware specifications of each host are illustrated in Figure <ref type="figure" target="#fig_11">15</ref>.</p><p>Note that each host is connected with two network interfaces: (i) 1 Gbps and (ii) 10 Gbps NICs, respectively. We turn on each network interface one at a time to test four different NOSs -Floodlight <ref type="bibr" target="#b10">[11]</ref>, NOX <ref type="bibr" target="#b13">[14]</ref>, Beacon <ref type="bibr" target="#b9">[10]</ref>, and ROSEMARY). For each software, we have installed their most recent version<ref type="foot" target="#foot_1">2</ref> .</p><p>In addition, to minimize any unintended overhead, we run a single NOS at a time, and turn off any functions that may cause additional overhead (e.g., system logging) for each application. A simple learning switch application is used for this test, because all NOSs provide a similar application by default. For generating data plane requests, we use the cbench tool <ref type="bibr" target="#b24">[25]</ref>, because it is widely used in measuring the throughput of NOSs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Robustness Test</head><p>We first present the test result for ROSEMARY, when it runs an application that simply calls an exit function (i.e., Crash App in Figure <ref type="figure" target="#fig_1">14</ref>)). As shown in Section 2, Floodlight, POX and Beacon are terminated along with similar test applications. However, since core parts of ROSEMARY are clearly separated from applications, they are not affected by this crash and other applications continue to run. This result is presented in Figure <ref type="figure" target="#fig_12">16</ref>, which shows that a firewall app can block attack trials from Host A whose IP is 10.0.0.1 (Figure <ref type="figure" target="#fig_12">16</ref> (red rectangle in left bottom)), even if the Crash App has been terminated (Figure <ref type="figure" target="#fig_12">16</ref> (right bottom)). In addition, we can see  that Host B (a benign user whose IP address is 10.0.0.2) is able to contact Host C without any problem (Figure <ref type="figure" target="#fig_12">16</ref> top-right).</p><p>In addition, we run an application that keeps allocating memory objects (i.e., our Memory-Leak App) to verify how ROSEMARY handles this condition. We also run the same application on Floodlight to clearly compare the reaction of each NOS, and the result is shown in Figure <ref type="figure" target="#fig_13">17</ref>. When an application starts its operation (at time 14), we can easily observe that the memory footprint of each NOS is increasing. Here, since we set a hard limit of the memory usage for the ROSEMARY application at 1.2 GB, the test application running on ROSEMARY cannot allocate more than 1.2 GB of memory (at time 19). However, the memory footprint of the application running on Floodlight keeps continuously increasing until it reaches its maximum allocation size (at time 21) at which point Floodlight issues an out-of-memory error alert.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Security Test</head><p>We repeat the security experiment from Section 2 to test the security of ROSEMARY. We created an application (i.e., Data-Access App) that accesses and modifies an internal data structure. Unlike the case of Floodlight, ROSEMARY checks whether an application has a right to access or modify a data structure; thus this application fails in accessing the data structure, as it cannot obtain the necessary capability. Figure18 shows a screen shot in which the Data-Access App tries to modify a data structure inside ROSEMARY, which is not allowed. We can clearly see that the access attempt has been rejected by ROSEMARY. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Performance Test</head><p>Throughput. We measure the overall throughput of ROSEMARY, and compare it with other NOSs -NOX <ref type="bibr" target="#b13">[14]</ref>, Beacon <ref type="bibr" target="#b9">[10]</ref>, and Floodlight. Here, we have optimized each NOS based on its recommendations. In the case of Beacon <ref type="bibr" target="#b9">[10]</ref>, we have followed the instructions described in a recent work <ref type="bibr" target="#b9">[10]</ref>. Floodlight also provides instructions for benchmark <ref type="bibr" target="#b23">[24]</ref>. Although NOX does not provide such an instruction, we use all recommended libraries (e.g., boost library <ref type="bibr" target="#b2">[3]</ref>) to improve its performance. In addition, in the case of ROSEMARY, we separately measure two cases: a test application is implemented as (i) User-Application (denoted as ROSEMARY U-App) and (ii) Kernel-Application (denoted as ROSEMARY K-App). Figure <ref type="figure" target="#fig_0">19</ref> and Figure <ref type="figure">20</ref> show that the overall throughput of each NOS when the data plane (i.e., Host A in Figure <ref type="figure" target="#fig_11">15</ref>) and the control plane (Host B in Figure <ref type="figure" target="#fig_11">15</ref>) are connected through a 1G network interface. Figure <ref type="figure" target="#fig_0">19</ref> presents a case in which we vary the number of connected switches (i.e., data planes) when the number of working threads for each network operating system is fixed at 8. In this case we can clearly observe that ROSEMARY (both U-App and K-App) and Beacon nearly saturate the hardware limitation of network bandwidth (i.e., 1 GB). In the case of NOX, it also saturates the hardware limitation when it is connected to more than 4 switches. However, the throughput of Floodlight is relatively low compared with others.</p><p>Next, we vary the number of working threads from 1 to 16 to understand how the performance of each NOS depends on the number of working threads, and the results are presented in Figure <ref type="figure">20</ref>. In this case, we set the number of the connected switches as 64. Similar to the result of Figure <ref type="figure" target="#fig_0">19</ref>, ROSEMARY (both U-App and K-App) and Beacon nearly hit the hardware limitation, even if they only have a small number of working threads. NOX also saturates the hardware limitation, but it requires more than 5 working threads. Floodlight shows much worse performance than other NOSs, and it reaches the saturation value when it has more than 15 working threads.</p><p>We changed the network interface between the data plane and the control plane to a 10G interface, and we repeated the same tests in order to discover the maximum throughput of each NOS. Figure <ref type="figure" target="#fig_0">21</ref> presents the results of throughput when we vary the number of switches while fixing the number of working threads at 8. In this case, we can clearly find that ROSEMARY outperforms most of the the other NOSs. For example, ROSEMARY (K-App) shows 8 to 25 times better performance than Floodlight, and 3 to 14 times better performance than NOX. Although we only consider ROSE-MARY (U-App), it also shows 5 to 22 times better performance than Floodlight, and from 2 to 12 times better than NOX.</p><p>When we vary the number of working threads with the 10G interface, the test results (in Figure <ref type="figure" target="#fig_16">22</ref>) still show that ROSEMARY outperforms most of the other network operating systems. At this time, ROSEMARY (K-App) can handle more than 10 million network requests from the data planes. We believe these results show that ROSEMARY can support a large scale network environment. For example, recent work in <ref type="bibr" target="#b1">[2]</ref> surveys how many new flows will hit a centralized controller, and its estimation result shows that around 10 million new flows can be issued by a data center in the worst case. In this case, ROSEMARY can handle this large number of requests and provides capabilities for robustness and the security at the same time. Beacon outperforms ROSEMARY in some caseswhen there more than 11 working threads-we suspect this is due --2,000,000 4,000,000 6,000,000 8,000,000 10,000,000 12,000,000 14,000,000 16,000,000 to of ROSEMARY's CPU pinning overhead. However, in our test, we find that CPU pinning overhead is nearly ignorable, and thus we think that the performance difference between ROSEMARY and Beacon is caused by the scheduling method of each application. We plan to investigate this issue more deeply in future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">LIMITATIONS AND DISCUSSION</head><p>Although our work considers diverse issues concerning the security and robustness of NOSs, there remain lingering challenges that are attractive avenues for future research.</p><p>First, ROSEMARY primarily focuses on potential threats from a buggy or malicious application, but does not address threats from vulnerabilities in the host operating system. For example, if a malware infects the host running a NOS, it can abuse the NOS quite easily. We believe that such threats would be addressed through the use of auxiliary host and network intrusion monitoring systems, as well as by following best practices in host and network management, e.g., regular patch management and isolating the management interface of the network controller to selected trusted internal hosts.</p><p>Second, if a remote attacker mounts a control flow saturation attack against ROSEMARY <ref type="bibr" target="#b31">[33]</ref>, the impact of flow request floods may degrade the SDN controller and application performance. Here, the adversary attacks the SDN stack by crafting packet streams to saturate the data plane to control plane communications. This kind of attack is beyond the scope of our current work, but is addressed by systems such as <ref type="bibr" target="#b32">[34]</ref>. These SDN extensions are complementary and could be integrated into ROSEMARY in future work.</p><p>Third, ROSEMARY kernel-mode applications provide improved performance at the cost of robustness and security. If an operator strictly requires robustness and security from the NOS, he or she may run all SDN applications as user applications. Although the user application gives up some performance (around 20 -30% in 10G, but interestingly close to 0% in 1G) for security, we believe such trade-offs may well be worth the cost of resilience. We will investigate opportunities to further narrow this gap in future work, such as reducing the application scheduling overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">RELATED WORK</head><p>Our work builds on a rich body of prior work on designing network operating systems <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr">30,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b33">35,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b7">8]</ref>. These systems have largely focused on improving the scalability of the control plane <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr">30,</ref><ref type="bibr" target="#b9">10]</ref> or efficiently distributing control plane functionality across different nodes and locations <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b33">35,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b14">15]</ref> and provide many useful insights on devising more advanced network operating systems. While the contributions of these efforts in evangelizing SDN technology cannot be understated, we believe that robustness and security issues for NOSs have been overlooked. Our work aims to fill this hole by exploring complementary methods that improve the robustness and security of NOSs while providing performance that is comparable to leading controllers.</p><p>The problem of malicious contoller applications attacking the data plane was first raised by Porras et al. <ref type="bibr" target="#b28">[29]</ref>. They address this problem by designing a security enforcement kernel for SDN controllers whose primary objective is to perform rule conflict detection and resolution. An extended version of the system <ref type="bibr" target="#b25">[26]</ref> provides support for digital certificate validation of applications much like ROSEMARY. While these efforts have focused on protecting the data plane from malicious applications, our central objective is to improve the resilience of the control plane to both buggy and malicious applications.</p><p>Several recent studies have investigated security issues in SDNs <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b31">33,</ref><ref type="bibr" target="#b30">32]</ref>. Shin et al., discuss techniques to protect the control plane against control flow saturation attacks <ref type="bibr" target="#b31">[33]</ref>. Kreutz et al. <ref type="bibr" target="#b18">[19]</ref> and Scott-Hayward et al. <ref type="bibr" target="#b30">[32]</ref> survey possible SDN security issues. These efforts inform and motivate the development of ROSEMARY. In addition, there have been parallel research efforts that have explored applying generic operating system design principles toward the design of network operating systems. Matthew et al. have proposed a new network operating system that borrows several ideas from generic operating system design <ref type="bibr" target="#b20">[21]</ref>. Specifically, they introduce a file system concept to the network operating system which they implemented through a prototype system. However, their work does not consider robustness and security issues in NOS design. Wen et al., discuss a secure controller platform <ref type="bibr" target="#b34">[36]</ref> that is primarily focused on implementing access control methods in NOS. ROSEMARY differs from their system in that it tackles diverse challenges (i.e., robustness, security, and performance) and illustrates how these challenges could be addressed in tandem.</p><p>Finally, another approach to addressing robustness issues is through formal methods. Canini et al. <ref type="bibr" target="#b5">[6]</ref> use model-checking to holistically explore the state space of SDN networks and detect when they reach inconsistent network states. While model checking works well for small control programs, it is vulnerable to state explosion on large systems. Scott et al. <ref type="bibr" target="#b29">[31]</ref>, describe a new technique called restrospective causal inference for post-facto analysis of failures. We believe that both of these techniques are complementary to our design of a robust and secure micro-controller.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSION</head><p>Balancing the seemingly irreconciliable goals of robustness, security, and performance represents a fundamental challenge in contemporary network controller design. We view this as an opportunity to advance network security research and realize our vision through the design of a new NOS called ROSEMARY.</p><p>ROSEMARY adopts a practical and timely approach to addressing this challenge through careful redesign of a NOS comprising three integral features: (i) context separation, (ii) resource utilization monitoring, and (iii) the micro-NOS permissions structure which limits the library functionality that a network application is allowed to access. In addition, ROSEMARY also provides competitive performance, while supporting its robustness and security features. Through our in-depth evaluation, we confirm that our system can effectively handle a large volume of network requests (nearly saturating hardware limitation in some cases) while ensuring the robustness of the OpenFlow stack in the presence of faulty or malicious network applications.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: NOS evaluation environment</figDesc><graphic coords="2,131.54,58.06,157.91,68.20" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Network link information from Floodlight before (top) and after (bottom) attack. Only 1 link remains after the attack.</figDesc><graphic coords="3,322.47,248.58,233.96,87.84" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: OpenDaylight crash result</figDesc><graphic coords="3,322.24,574.30,239.09,120.77" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :Figure 3 :</head><label>23</label><figDesc>Figure 2: Floodlight crash result</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :Figure 7 :Figure 8 :Figure 9 :</head><label>6789</label><figDesc>Figure 6: POX crash source code</figDesc><graphic coords="4,306.34,184.44,230.77,60.19" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 10 :</head><label>10</label><figDesc>Figure10: Overall architecture of ROSEMARY comprising of four key components: (i) a data abstraction layer (DAL), (ii) the ROSEMARY kernel, (iii) system libraries, and (iv) a resource monitor. ROSEMARY provides diverse libraries for applications, and each application can choose necessary applications for its operations. Applications may be run in user-mode for robustness or kernel-mode for maximal performance.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Application resource monitoring and control 4) Providing Access Control and Authentication.The aforementioned design choices are primarily intended to improve system robustness; however, we still need to address the security concerns described in Section 2. For example, a malicious application may access internal data structures and modify them without restriction, thereby confusing other network applications.We address this issue by employing a sandbox approach, which we have named App Zone. Its detailed architecture is presented in Figure12, and it essentially runs an application within a confined environment to monitor and control the application's operations. When an application makes privileged system calls (e.g., spawns processes or accesses internal storage modules), such operations are interposed by our management module which we call the system call access check module. This enables the operator to control the set of operations that may be performed by applications.In addition, App Zone examines whether this application is authorized or not by investigating its signed key (application authorization module). ROSEMARY provides a public key, and all application developers are required to sign their applications with this key. Such an approach has also been adopted by other related work</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: Internal architecture of Application Zone</figDesc><graphic coords="7,84.06,59.55,176.76,144.07" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 13 :Figure 14 :</head><label>1314</label><figDesc>Figure 13: Overall approach of request pipelining. IPC is used as a pipelining latch for throughput improvement and as a boundary of separated execution between the kernel and application.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 15 :</head><label>15</label><figDesc>Figure 15: Test environment for measuring throughput of each NOS</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 16 :</head><label>16</label><figDesc>Figure 16: Application crash test for ROSEMARY. A firewall app will block attack trials (left) although the Crash App terminates with a System.exit() (right).</figDesc><graphic coords="9,59.23,56.99,239.09,104.80" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 17 :</head><label>17</label><figDesc>Figure 17: Memory leakage test for Floodlight and ROSEMARY. Floodlight crashes with an out-of-memory error while ROSE-MARY limits memory allocation to 1.2 GB.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 18 :Figure 19 :</head><label>1819</label><figDesc>Figure 18: Data-Access App tries to modify a privileged data structure inside ROSEMARY, which is not allowed. This access attempt is rejected by ROSEMARY.</figDesc><graphic coords="9,322.79,57.46,241.14,51.74" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 20 :Figure 21 :</head><label>2021</label><figDesc>Figure 20: Throughput comparison between ROSEMARY and other NOSs (1G interface, varying the number of threads, and the number of switches is 64)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 22 :</head><label>22</label><figDesc>Figure 22: Throughput comparison between ROSEMARY and other NOSs (10G interface, varying the number of threads, and the number of switches is 64)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Reaction strategies against anomalous behaviors of ROSEMARY</figDesc><table><row><cell>Behavior</cell><cell></cell><cell>Reaction</cell></row><row><cell>Service crash</cell><cell></cell><cell>restart the crashed service</cell></row><row><cell>Multiple</cell><cell>services</cell><cell>restart ROSEMARY</cell></row><row><cell>crash</cell><cell></cell><cell></cell></row><row><cell cols="2">Memory leakage of a</cell><cell>restart a service causing memory leakage</cell></row><row><cell cols="2">ROSEMARY service is</cell><cell></cell></row><row><cell>detected</cell><cell></cell><cell></cell></row><row><cell cols="2">Kernel App crash</cell><cell>restart ROSEMARY services (if necessary),</cell></row><row><cell></cell><cell></cell><cell>and restart the app as a user app</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Original Task Kernel + Application Subtask 1 Pipeline Latch Subtask 2 Kernel Interface Application Kernel Task Pipelining Interface Application Task Request Pipelining Pipelining Kernel/App Separation</head><label></label><figDesc></figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>A concept is tolerated inside the microkernel only if moving it outside the kernel, i.e., permitting competing implementations, would prevent the implementation of the system's required functionality. -Liedtke's minimality principle</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Specifically, in the case of NOX, we have used the newly developed multi-threaded NOX and NOT the classic version.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">ACKNOWLEDGMENTS</head><p>We thank the anonymous reviewers for their helpful and insightful comments. In this work, Seungwon Shin was supported by the ICT R&amp;D program of MSIP/IITP, Korea (2014-044-072-003, Development of Cyber Quarantine System using SDN Techniques) project, and researchers at Atto Research Korea were supported by the ICT R&amp;D program of MSIP/IITP, Korea (10045253, The development of SDN/OpenFlow-based Enterprise Network Controller Technology) project. Additional funding for researchers at SRI was provided by the MRC2 Project that is sponsored by the Defense Advanced Research Projects Agency (DARPA) and the Air Force Research Laboratory (AFRL), under contract FA8750-11-C-0249. The views, opinions, and/or findings contained in this paper are those of the authors and should not be interpreted as representing the official views or policies, either expressed or implied, of the Defense Advanced Research Projects Agency or the Department of Defense. It is approved for public release, distribution unlimited.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A new kernel foundation for unix development</title>
		<author>
			<persName><forename type="first">M</forename><surname>Accetta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Baron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Bolosky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Golub</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rashid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tevanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Young</surname></persName>
		</author>
		<author>
			<persName><surname>Mach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Conference</title>
		<imprint>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Network traffic characteristics of data centers in the wild</title>
		<author>
			<persName><forename type="first">T</forename><surname>Benson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Akella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Maltz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th ACM SIGCOMM Conference on Internet Measurement</title>
		<meeting>the 10th ACM SIGCOMM Conference on Internet Measurement</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><surname>Boost</surname></persName>
		</author>
		<author>
			<persName><surname>Org</surname></persName>
		</author>
		<ptr target="http://www.boost.org/" />
		<title level="m">Boost c++ libraries</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Butenhof</surname></persName>
		</author>
		<author>
			<persName><surname>Addison-Wesley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">Z</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">S E</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><surname>Maestro</surname></persName>
		</author>
		<title level="m">A system for scalable openflow control</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
		<respStmt>
			<orgName>Rice University Technical Document</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A NICE Way to Test OpenFlow Applications</title>
		<author>
			<persName><forename type="first">M</forename><surname>Canini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Venzano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pere Ŝíni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kosti Ć</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Usenix Symposium on Networked Systems Design and Implementation</title>
		<imprint>
			<date type="published" when="2012-04">April 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Scaling flow management for high-performance networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Curtis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mogul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tourrilhes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Yalagandula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName><surname>Devoflow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Towards an elastic distributed sdn controller</title>
		<author>
			<persName><forename type="first">A</forename><surname>Dixit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mukherjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lakshman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kompella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second ACM SIGCOMM Workshop on Hot Topics in Software Defined Networking</title>
		<meeting>the Second ACM SIGCOMM Workshop on Hot Topics in Software Defined Networking</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Exokernel: An operating system architecture for application-level resource management</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Engler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Toole</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles</title>
		<meeting>the Fifteenth ACM Symposium on Operating Systems Principles</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The beacon openflow controller</title>
		<author>
			<persName><forename type="first">D</forename><surname>Erickson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second ACM SIGCOMM Workshop on Hot Topics in Software Defined Networking</title>
		<meeting>the Second ACM SIGCOMM Workshop on Hot Topics in Software Defined Networking</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Open sdn controller</title>
		<author>
			<persName><surname>Floodlight</surname></persName>
		</author>
		<ptr target="http://floodlight.openflowhub.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Openflow specification 1</title>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">N</forename><surname>Foundation</surname></persName>
		</author>
		<ptr target="https://www.opennetworking.org/images/stories/downloads/sdn-resources/onf-specifications/openflow/openflow-spec-v1.0.0.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">N</forename><surname>Foundation</surname></persName>
		</author>
		<ptr target="https://www.opennetworking.org/images/stories/downloads/sdn-resources/onf-specifications/openflow/openflow-spec-v1.3.0.pdf" />
		<title level="m">Openflow specification 1.3</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">NOX: Towards an Operating System for Networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Gude</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Koponen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pettit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pfaff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Casado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGCOMM Computer Communication Review</title>
		<meeting>ACM SIGCOMM Computer Communication Review</meeting>
		<imprint>
			<date type="published" when="2008-07">July 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Kandoo: A framework for efficient and scalable offloading of control applications</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hassas Yeganeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ganjali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First Workshop on Hot Topics in Software Defined Networks</title>
		<meeting>the First Workshop on Hot Topics in Software Defined Networks</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Hp opens sdn ecosystem</title>
		<author>
			<persName><surname>Hp</surname></persName>
		</author>
		<ptr target="http://h17007.www1.hp.com/us/en/events/interop/index" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Floodlight architecture</title>
		<author>
			<persName><forename type="first">O</forename><surname>Hub</surname></persName>
		</author>
		<ptr target="http://www.openflowhub.org/display/floodlightcontroller/Architecture" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A Distributed Control Platform for Large-scale Production Networks</title>
		<author>
			<persName><forename type="first">T</forename><surname>Koponen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Casado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Gude</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stribling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Poutievski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ramanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Iwata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Inoue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName><surname>Onix</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Symposium on Operating Systems Design and Implementation (OSDI)</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Towards secure and dependable software-defined networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kreutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">M</forename><surname>Ramos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Verissimo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second ACM SIGCOMM Workshop on Hot Topics in Software Defined Networking</title>
		<meeting>the Second ACM SIGCOMM Workshop on Hot Topics in Software Defined Networking</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">An instant virtual network on your laptop (or other pc)</title>
		<author>
			<persName><surname>Mininet</surname></persName>
		</author>
		<ptr target="http://mininet.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Applying operating system principles to sdn controller design</title>
		<author>
			<persName><forename type="first">M</forename><surname>Monaco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Michel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Keller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twelfth ACM Workshop on Hot Topics in Networks</title>
		<meeting>the Twelfth ACM Workshop on Hot Topics in Networks</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><surname>Onlab</surname></persName>
		</author>
		<author>
			<persName><surname>Us</surname></persName>
		</author>
		<ptr target="http://onlab.us/tools.html#os" />
		<title level="m">Network os</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Open source network controller</title>
		<author>
			<persName><surname>Opendaylight</surname></persName>
		</author>
		<ptr target="http://www.opendaylight.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><surname>Openflowhub</surname></persName>
		</author>
		<author>
			<persName><surname>Org</surname></persName>
		</author>
		<ptr target="http://www.openflowhub.org/display/floodlightcontroller/Benchmarking+Configuration" />
		<title level="m">Benchmark configuraion</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title/>
		<author>
			<persName><forename type="middle">Org</forename><surname>Openflowhub</surname></persName>
		</author>
		<author>
			<persName><surname>Cbench</surname></persName>
		</author>
		<ptr target="http://www.openflowhub.org/display/floodlightcontroller/Cbench+" />
		<imprint>
			<pubPlace>New)</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><surname>Openflowsec</surname></persName>
		</author>
		<author>
			<persName><surname>Org</surname></persName>
		</author>
		<ptr target="http://www.openflowsec.org/Technologies.html" />
		<title level="m">Se-floodlight</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName><surname>Openflowsec</surname></persName>
		</author>
		<author>
			<persName><surname>Org</surname></persName>
		</author>
		<ptr target="http://www.openflowsec.org" />
		<title level="m">Secuirng sdn environment</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">N</forename><surname>Planet</surname></persName>
		</author>
		<ptr target="http://www.enterprisenetworkingplanet.com/datacenter/juniper-builds-sdn-controller-with-xmpp.html" />
		<title level="m">Juniper builds sdn controller with xmpp</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A security enforcement kernel for openflow networks</title>
		<author>
			<persName><forename type="first">P</forename><surname>Porras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Yegneswaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tyson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First ACM SIGCOMM Workshop on Hot Topics in Software Defined Networking</title>
		<meeting>the First ACM SIGCOMM Workshop on Hot Topics in Software Defined Networking</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">How did we get into this mess? isolating fault-inducing inputs to sdn control software</title>
		<author>
			<persName><forename type="first">C</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wundsam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Whitlock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Or</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Zarifis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<idno>UCB/EECS-2013-8</idno>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
		<respStmt>
			<orgName>EECS Department, University of California, Berkeley</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Sdn security: A survey</title>
		<author>
			<persName><forename type="first">Scott-Hayward</forename></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>O'callaghan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sezer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Future Networks and Services (SDN4FNS)</title>
		<imprint>
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Attacking software-defined networks: A first feasibility study</title>
		<author>
			<persName><forename type="first">S</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second ACM SIGCOMM Workshop on Hot Topics in Software Defined Networking</title>
		<meeting>the Second ACM SIGCOMM Workshop on Hot Topics in Software Defined Networking</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Avant-guard: Scalable and vigilant switch flow management in software-defined networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Yegneswaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Porras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 ACM SIGSAC Conference on Computer and Communications Security</title>
		<meeting>the 2013 ACM SIGSAC Conference on Computer and Communications Security</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Hyperflow: A distributed control plane for openflow</title>
		<author>
			<persName><forename type="first">A</forename><surname>Tootoonchian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ganjali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Internet Network Management Workshop/Workshop on Research on Enterprise Networking</title>
		<meeting>the Internet Network Management Workshop/Workshop on Research on Enterprise Networking</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Towards a secure controller platform for openflow applications</title>
		<author>
			<persName><forename type="first">X</forename><surname>Wen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second ACM SIGCOMM Workshop on Hot Topics in Software Defined Networking</title>
		<meeting>the Second ACM SIGCOMM Workshop on Hot Topics in Software Defined Networking</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Extensible messaging and presence protocol</title>
		<author>
			<persName><surname>Xmpp</surname></persName>
		</author>
		<author>
			<persName><surname>Org</surname></persName>
		</author>
		<ptr target="http://xmpp.org" />
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
