<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Pervasive and Mobile Computing</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Yanjiang</forename><surname>Yang</surname></persName>
							<email>yyang@i2r.a-star.edu.sg</email>
							<affiliation key="aff0">
								<orgName type="department">Institute for Infocomm Research</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Haiyan</forename><surname>Zhu</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">School of Electronic and Information Engineering</orgName>
								<orgName type="institution">Beihang University</orgName>
								<address>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Haibing</forename><surname>Lu</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">The Leavey School of Business</orgName>
								<orgName type="institution">Santa Clara University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jian</forename><surname>Weng</surname></persName>
							<affiliation key="aff3">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Jinan University</orgName>
								<address>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Youcheng</forename><surname>Zhang</surname></persName>
							<affiliation key="aff4">
								<orgName type="institution">Nanjing Unary Information Technology Co</orgName>
								<address>
									<settlement>Ltd</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kim-Kwang</forename><forename type="middle">Raymond</forename><surname>Choo</surname></persName>
							<affiliation key="aff5">
								<orgName type="laboratory">Information Assurance Research Lab</orgName>
								<orgName type="institution">University of South Australia</orgName>
								<address>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Pervasive and Mobile Computing</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">02C2A4E8EE4FABFCA3DB0D911C29E01B</idno>
					<idno type="DOI">10.1016/j.pmcj.2015.06.017</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:14+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Cloud computing Conditional proxy re-encryption User revocation Fine-grained encryption</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Conditional proxy re-encryption (CPRE) enables fine-grained delegation of decryption rights, and has many real-world applications. In this paper, we present a ciphertext-policy attribute based CPRE scheme, together with a formalization of the primitive and its security analysis. We demonstrate the utility of the scheme in a cloud deployment, which achieves fine-grained data sharing. This application implements cloud server-enabled user revocation, offering an alternative yet more efficient solution to the user revocation problem in the context of fine-grained encryption of cloud data. High user-side efficiency is another prominent feature of the application, which makes it possible for users to use resource constrained devices, e.g., mobile phones, to access cloud data. Our evaluations show promising results on the performance of the proposed scheme.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>The notion of proxy re-encryption (PRE) was first introduced by Blaze, Bleumer and Strauss <ref type="bibr" target="#b0">[1]</ref>. In a PRE scheme, a semitrusted proxy is given a re-encryption key and, thus, is able to convert ciphertexts under Alice's public key into ciphertexts under Bob's public key. The proxy, however, is unable to learn any useful information about the messages encrypted under either key. This re-encryption procedure can be intuitively depicted as E(pk A , •) rk A→B ---→ E(pk B , •), where rk A→B denotes the re-encryption key from Alice to Bob, and E(pk, •) denotes a ciphertext under public key pk. 1 In this setting, Alice is the delegator and Bob is the delegatee, and PRE is said to enable Alice to delegate her decryption right to Bob.</p><p>A weakness of traditional PRE is that the proxy can transform all of Alice's ciphertexts, disallowing Alice to choose a subset of her ciphertexts to be converted. This is not satisfactory in many applications where fine-grained delegations of decryption right are required. This has led to the emergence of the concept of conditional proxy re-encryption (CPRE) <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref>,</p><p>which strengthens PRE such that transformation of ciphertexts by the proxy is conditional: a ciphertext under Alice's public key is generated by embedding in the ciphertext a value w, and the re-encryption key from Alice to Bob is associated with another value w ′ ; the ciphertext can be converted to a ciphertext for Bob if and only if w = w ′ . Intuitively, the procedure is depicted as E(pk A , •, w) rk A w ′ -→B ----→ E(pk B , •). CPRE turns out to be a useful primitive, and can be used in many real-world applications. In this paper, we show one such example: applying CPRE to achieve revocable fine-grained data sharing over cloud storage services.</p><p>Ensuring the security and privacy of data stored in external cloud storage services is of paramount importance to organizational and individual users, and one typical means of achieving this is using encryption (by the data owner) <ref type="bibr" target="#b3">[4]</ref><ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref>. However, encryption of cloud data poses various challenges. First of all, cloud storage services are an effective platform to share data among a number of stakeholders and users. In practice, fine-grained access control policies are often deployed to ensure that different users have different access privileges. This leads to the first challenge that encryption of cloud data must support fine-grained cryptographic access control such that users with different privileges possess different decryption capabilities. The second challenge for data sharing in the multi-user setting is user revocation, where one or more users would need to be deprived of their access rights in certain circumstances, e.g., they resign from the organization. The typical solution to user revocation is to invalidate the existing key (used in data encryption) by re-generating the encrypted data with a new key, which is then re-distributed to the remaining valid users. This is a prohibitively costly task, especially in the case of encryption of cloud data due to the large amount of data stored in the particular cloud account.</p><p>In this paper, we demonstrate how these two challenges can be addressed using CPRE that also allows us to implement cloud server-enabled user revocation. In other words, the cloud server plays the role of the proxy, and thus is given a set of re-encryption keys, each being from the data owner (who is the delegator) to an authorized user (who is the delegatee). When an authorized user requests some data from the cloud storage account, the cloud server transforms the data using the corresponding re-encryption key. User revocation is attained by deleting the revoked user's re-encryption key from the cloud server, requiring neither update of the encryption key and re-distribution of the key, nor re-generation of the cloud data.</p><p>While the above idea is promising, the majority of existing CPRE schemes (e.g. <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b6">7]</ref>) can only cope with simple, keyword-based conditions, i.e., both w and w ′ are a keyword or an ''AND'' concatenation of keywords. This limits the usefulness of such schemes, and is not an effective solution for enforcing fine-grained cryptographic access control required for cloud data. We are, thus, motivated to propose a new CPRE scheme that is capable of handling more fine-grained conditions. In particular, our CPRE scheme can be intuitively denoted as E(pk A , •, P)</p><formula xml:id="formula_0">rk A A -→B ----→ E(pk B , •)</formula><p>, where P is an access policy and A is a set of attributes. Transformation of the ciphertext can be accomplished if, and only if, P is satisfied by A. Access policies P in our scheme are expressive and can be any monotonic access structures, comparable to those considered in attribute-based encryption (ABE) <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9]</ref>. Following the naming convention of ABE <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9]</ref>, our proposal is a ciphertext-policy attribute based CPRE scheme.</p><p>Contributions. This is an extended version of <ref type="bibr" target="#b9">[10]</ref>. We remark that the CPRE scheme presented in this paper is different from <ref type="bibr" target="#b9">[10]</ref>, as the scheme in <ref type="bibr" target="#b9">[10]</ref> is unable to meet the security definition described in Section 3 (see the remark in Section 4.1). However, the previous scheme is still secure for secure cloud based data sharing. We then prove the proposed scheme secure, and present our experimental evaluations that demonstrate the effectiveness of the proposed scheme.</p><p>Organization. The rest of the paper is organized as follows. In Section 2, we review related work on PRE/CPRE. Formulation of the ciphertext-policy attribute based CPRE is presented in Section 3 and a concrete scheme is given in Section 4, together with its security analysis. In Section 5 we deploy our scheme to provide fine-grained encryption of cloud data, based on the cloud-enabled user revocation approach. Section 6 presents the experimental results, and Section 7 concludes this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related work</head><p>In this section, we review related work on PRE/CPRE, and defer the background information on encryption and sharing of cloud data to Section 5.2.</p><p>Blaze, Bleumer and Strauss <ref type="bibr" target="#b0">[1]</ref> formalized the concept of PRE, and proposed the first bidirectional PRE scheme (in which the delegation from Alice to Bob also allows for re-encryption from Bob to Alice). The first unidirectional PRE scheme, due to Ateniese et al. <ref type="bibr" target="#b10">[11]</ref>, is based on bilinear pairings.</p><p>The schemes by Blaze, Bleumer and Strauss <ref type="bibr" target="#b0">[1]</ref> and Ateniese et al. <ref type="bibr" target="#b10">[11]</ref> are only secure against chosen-plaintext attacks (CPA). Canetti and Hohenberger <ref type="bibr" target="#b11">[12]</ref> presented the first chosen-ciphertext attack (CCA)-secure PRE scheme based on bilinear pairings, which is a bidirectional scheme. A year later, Libert and Vergnaud <ref type="bibr" target="#b12">[13]</ref> presented a unidirectional PRE scheme with a weaker form of CCA security, namely, security under replayable chosen-ciphertext attacks (RCCA) <ref type="bibr" target="#b13">[14]</ref>.</p><p>Earlier PRE schemes rely on costly bilinear pairings. This motivates researchers to construct PRE schemes without using bilinear pairings. Deng et al. <ref type="bibr" target="#b14">[15]</ref> was, probably, the first to publish a bidirectional PRE scheme not based on bilinear pairings, and is CCA-secure bidirectional scheme. The first two unidirectional PRE schemes without bilinear pairings were due to Shao and Cao <ref type="bibr" target="#b15">[16]</ref>, and Weng et al. <ref type="bibr" target="#b16">[17]</ref>.</p><p>Attribute based PRE <ref type="bibr" target="#b17">[18]</ref><ref type="bibr" target="#b18">[19]</ref><ref type="bibr" target="#b19">[20]</ref><ref type="bibr" target="#b20">[21]</ref><ref type="bibr" target="#b21">[22]</ref> implements attribute-set to attribute-set transformation (rather than individual to individual transformation), and can be viewed as an extension to the conventional PRE, with each of the delegator and</p><formula xml:id="formula_1">) - 3</formula><p>the delegatee being represented by a set of attributes. Dynamic credential and ciphertext delegation for ABE <ref type="bibr" target="#b22">[23]</ref> also uses the attribute-set to attribute-set transformation. Conditional proxy re-encryption (CPRE) aims at restricting the transformation capability of the proxy, such that a transformation by the proxy can succeed only if the prescribed conditions are met. Earlier CPRE schemes <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b6">7]</ref> can only accommodate simple, keyword-based conditions, where both values embedded with the delegator's ciphertext and with the re-encryption keys are either a keyword or a ''AND'' concatenation of several keywords. As a result, these CPRE schemes are not capable in enforcing of finer-grained delegations of decryption rights.</p><p>In 2010, Zhao et al. <ref type="bibr" target="#b23">[24]</ref> proposed an attribute-based CPRE scheme, which is the first to support fine-grained conditions more than keywords. Their scheme can be described as E(pk A , •, A)</p><formula xml:id="formula_2">rk A P -→B ----→ E(pk B , •)</formula><p>, where A is a set of attributes and P is an access policy. Following the naming convention of key-policy ABE <ref type="bibr" target="#b8">[9]</ref> and ciphertext-policy ABE <ref type="bibr" target="#b7">[8]</ref>, their scheme is key-policy attribute based CPRE (as opposed to our proposed ciphertext-policy attribute based CPRE).</p><p>However, existing key-policy attribute based schemes (e.g. <ref type="bibr" target="#b23">[24]</ref>) suffer from two key weaknesses. (1) These schemes require one to pre-define the total number N of attributes admitted by the system (this is not practical in a cloud deployment), and the size of the system's public key is linear to N. In contrast, our scheme does not have this limitation, and any subsequent update of N does not affect the system setting. (2) Inheriting the advantages of ciphertext-policy ABE (over key-policy ABE), ciphertext-policy attribute based CPRE is more natural and flexible than its key-policy counterpart when used to encrypt cloud data, as the former allows the data owner to directly specify the access control policy associated with a ciphertext, under which the ciphertext can be decrypted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Model of ciphertext-policy attribute based CPRE</head><p>In this section, we formalize the ciphertext-policy attribute based conditional proxy re-encryption model and its security notions. We achieve the same expressiveness of access policies as in ABE schemes <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9]</ref> and, thus, we adopt the same definitions for ''policy'' and ''attribute''.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Preliminaries</head><p>Access tree. In ciphertext-policy attribute based CPRE, a re-encryption key is generated with a set of descriptive attributes A. An encryptor wishing to encrypt a message specifies an access policy P and generates the ciphertext under P. For a reencryption key to be able to transform the ciphertext, its associated attributes A must satisfy the access policy P. An access policy is expressed by an access tree, where each leaf node represents an attribute and we use att(ℓ) to denote the attribute associated with leaf node ℓ. Each non-leaf node of the tree represents a threshold gate, described by its children and a threshold value. Let num n be the number of children of a non-leaf node n, and t n be its threshold value, where 1 ≤ t n ≤ num n . When t n = 1, the threshold gate is an OR gate and when t n = num n , it is an AND gate. The parent of a node n in the tree is denoted by parent(n). The tree also defines an ordering among the children of a node, i.e., the child nodes of a node n are numbered from 1 to num n . The function index(n) calculates such a unique number associated with a node n. Access tree can express any access policy in the form of a monotonic formulae.</p><p>Satisfying an access tree. Let T be an access tree with root rt. T n denotes the subtree of T rooted at node n. Hence T = T rt . When a set A of attributes satisfy the access tree T n , it is denoted as T n (A) = 1. T n (A) is computed in a recursive way as follows: if n is a non-leaf node, compute T n ′ (A) for all child nodes n ′ ; T n (A) returns 1 if and only if at least t n children return 1; if n is a leaf node, then T n (A) returns 1 if and only if att(n) ∈ A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Model</head><p>A ciphertext-policy attribute based CPRE scheme consists of the following algorithms.</p><p>Setup(1 κ ) → params: On input a security parameter 1 κ , the setup algorithm outputs public parameter params. For conciseness, below we assume that params is implicitly included in the input of the rest algorithms. KeyGen(u) → (pk u , sk u ): On input a user identity U, the key generation algorithm outputs a public/private key pair pk u /sk u for user u.    cA under public key pk A and an access policy P, the re-encryption algorithm outputs a first-level ciphertext c B under public key pk B if A satisfies P; otherwise, it outputs ⊥. Dec 1 (sk, c) → m: On input a private key sk and a first-level ciphertext c under pk, the first-level decryption algorithm outputs a plaintext m if pk/sk is a valid key pair. Dec 2 (sk, c) → m: On input a private key sk and a second-level ciphertext c under pk and a certain access policy, the secondlevel decryption algorithm outputs a plaintext m if pk/sk is a valid key pair.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ReKeyGen(sk A , A, pk B ) → rk</head><p>Correctness. The correctness of a cipher-text attribute based CPRE scheme asserts that, for any m ∈ M, any P, A, any key pairs pk A /sk A and pk B /sk B , the following holds if A satisfies P</p><formula xml:id="formula_3">Dec 1 (sk A , Enc 1 (pk A , m)) = m Dec 2 (sk A , Enc 2 (pk A , m, P)) = m Dec 1 (sk B , ReEnc(ReKenGen(sk A , A, pk B ), Enc 2 (pk A , m, P))) = m.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Security notion</head><p>Security of ciphertext-policy attribute based CPRE is defined through the following security game between a challenger and an adversary A.</p><p>Setup. The challenger runs the Setup algorithm to generate public parameter params, and then executes KeyGen with a random user identity O to get a key pair pk O /sk O . Finally, the challenger passes params and pk O to the adversary A. Phase 1. The adversary A makes a number of re-encryption key generation queries on sets of attributes A 1 , A 2 , . . . , A q 1 to the challenger. For each query (which is on A j ), the challenger responds as follows. First, execute the KenGen algorithm with a random user identity to obtain a public/private key pair pk j /sk j . Then execute</p><formula xml:id="formula_4">ReKeyGen(sk O , A j , pk j ) = rk O A j -→j</formula><p>. Finally, return pk j /sk j and rk</p><formula xml:id="formula_5">O A j -→j to A.</formula><p>Challenge. The adversary A submits two equal length messages m 0 and m 1 , together with a challenge access policy P * such that none of A 1 , A 2 , . . . , A q 1 from Phase 1 satisfies P * . The challenger flips a random coin b, executes Enc 2 (pk O , m b , P * ) = c * , and returns the ciphertext c * to A. Phase 2. A again makes a number of re-encryption key generation queries on sets of attributes A q 1 +1 , A q 1 +2 , . . . , A q 2 to the challenger. For each query on A j , the challenger responds as follows. First, execute the KenGen algorithm with a random user identity to obtain a public/private key pair pk j /sk j . Then execute ReKeyGen(sk</p><formula xml:id="formula_6">O , A j , pk j ) = rk O A j -→j .</formula><p>Finally, if A j satisfies P * , then return pk j and rk It appears to be a common practice to separately define first-level encryption security and second-level encryption security in existing PRE/CPRE literature, e.g., <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b6">7]</ref>. Our formalization simultaneously captures both notations. More specifically, the challenge ciphertext c * is a second-level ciphertext; thus, second-level encryption security is trivially captured.</p><p>In addition, the adversary is allowed to obtain re-encryption keys whose associated attributes satisfy the challenge access policy P * (in which case, A does not get the private keys of delegatees). Therefore, the adversary can transform the challenge ciphertext into first-level ciphertexts using these re-encryption keys, and this captures first-level encryption security.</p><p>We remark that the CPA security notion is sufficient in meeting the needs for encryption of cloud data-the intended application of CPRE in this paper. Therefore, we design our scheme to achieve only CPA security. It is also relatively straightforward to extend the scheme to achieve CCA security using generic techniques for constructing CCA secure schemes (e.g. <ref type="bibr" target="#b24">[25]</ref><ref type="bibr" target="#b25">[26]</ref><ref type="bibr" target="#b26">[27]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Our scheme</head><p>In this section, we present our construction of the ciphertext-policy attribute based CPRE scheme, as well as its security analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">The construction</head><p>Our construction is inspired by the ciphertext-policy ABE scheme <ref type="bibr" target="#b7">[8]</ref>, but there remains a big gap between the ABE scheme and our ciphertext-policy attribute based CPRE scheme (consider the gap between public key encryption and PRE).</p><formula xml:id="formula_7">) - 5</formula><p>Let s ∈ R S denote an element s randomly drawn from a set S. The details of our scheme are as follows.</p><p>Setup(1 κ ): Determine a bilinear map e : G 0 × G 0 → G T , where G 0 and G T are cyclic groups of κ-bit prime order p; select g which is a generators of G 0 , a cryptographic hash function H : {0, 1} * → G 0 . Then set params = (g, G = e(g, g), H(•)).</p><p>KeyGen(u): Pick x u , α u , β u ∈ R Z p , and set (pk</p><formula xml:id="formula_8">u = ⟨y u = g x u , h u = g β u , w u = G α u ⟩, sk u = ⟨x u , α u , β u ⟩). ReKeyGen(sk A , A, pk B ): Let sk A = ⟨x A , α A , β A ⟩ and pk B = ⟨y B = g x B , h B = g β B , w B = G α B ⟩. Pick r, r i ∈ R Z p , ∀i ∈ A,</formula><p>and set the re-encryption key as</p><formula xml:id="formula_9">rk A A -→B = (k = (y α A B g r ) 1 β A , ∀i ∈ A : {k i1 = g r H(i) r i , k i2 = g r i }). Enc 1 (pk, m): Let pk = ⟨y = g x , h = g β , w = G α ⟩. Pick s ∈ R Z p and w ′ ∈ R G 0 ; then compute c = (m • e(w ′ , g) s , e(w ′ , y) s = e(w ′ , g) s.x ).</formula><p>Enc 2 (pk, m, P): Let pk = ⟨y = g x , h = g β , w = G α ⟩ and P be an access tree T . The second-level encryption algorithm proceeds as follows. It first selects a polynomial q n for each node n (including the leaf nodes) in T . These polynomials are chosen in a top-down manner, starting from the root node rt: for each node n, set the degree d n of the polynomial q n to be d n = t n -1, where t n is the threshold value of node n. Starting with the root node rt the algorithm selects a random s ∈ R Z p and sets q rt (0) = s. It then selects d rt other random points to define q rt . For any other node n, it sets q n (0) = q parent(n) (index(n)) and chooses d n other points to define q n . Let L be the set of leaf nodes in T . Sets the second level ciphertext c as</p><formula xml:id="formula_10">c = (T , C = m • w s , C ′ = h s , ∀l ∈ L : {C l1 = g q l (0) , C l2 = H(att(l)) q l (0) }).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ReEnc(rk</head><formula xml:id="formula_11">A A -→B , cA ): Let cA = (T , C , C ′ , ∀l ∈ L : {C l1 , C l2 }) and rk A A -→B = (k, ∀i ∈ A : {k i1 , k i2 }).</formula><p>The re-encryption algorithm is a recursive procedure. We first define an algorithm</p><formula xml:id="formula_12">ReEncNd n (c A , rk A A -→B</formula><p>) on a node n of T . If node n is a leaf node, then we let z = att(n) and define as follows:</p><formula xml:id="formula_13">z ̸ ∈ A, then ReEncNd n (c A , rk A A -→B ) = ⊥; otherwise ReEncNd n (c A , rk A A -→B ) = F n ,</formula><p>where</p><formula xml:id="formula_14">F n = e(k z1 , C n1 ) e(k z2 , C n2 ) = e(g r H(z) r z , g q n (0) ) e(g r z , H(z) q n (0) )</formula><p>= e(g, g) r.q n (0) .</p><p>(</p><p>Let us now consider the recursive case when n is a non-leaf node. The algorithm</p><formula xml:id="formula_16">ReEncNd n (c A , rk A A -→B ) proceeds as follows. For each child node v of n, it calls ReEncNd v (c A , rk A A -→B</formula><p>) and stores the output as F v . Let S n be an arbitrary t n -sized set of child nodes v such that F v ̸ = ⊥. If such a set does not exist, then the node is not satisfied and</p><formula xml:id="formula_17">ReEncNd n (c A , rk A A -→B ) = F n = ⊥.</formula><p>Otherwise, let the Lagrange coefficient △ i,S for i ∈ Z p and a set S of elements in</p><formula xml:id="formula_18">Z p be △ i,S (x) =  j∈S,j̸ =i</formula><p>x-j i-j , and we compute</p><formula xml:id="formula_19">F n =  v∈S n F △ i,S ′ n (0) v , where i=index(v), S ′ n ={index(v):v∈S n } =  v∈S n (e(g, g) r.q v (0) ) △ i,S ′ n (0) =  v∈S n (e(g, g) r.q parent(v) (index(v)) ) △ i,S ′ n (0) =  v∈S n (e(g, g) r.q n (i) ) △ i,S ′ n (0)</formula><p>= e(g, g) r.q n (0) .</p><p>(2)</p><p>In this way,</p><formula xml:id="formula_20">ReEncNd rt (c A , rk A A -→B</formula><p>) for the root node rt can be computed. If T rt (A) = 1, then we get</p><formula xml:id="formula_21">ReEncNd rt (c A , rk A A -→B ) = e(g, g) r.q rt (0) = e(g, g) r.s = F rt .</formula><p>Next, the re-encryption algorithm continues to compute e(k, C ′ )/F rt = e((y</p><formula xml:id="formula_22">α A B g r ) 1 β A , h s A )/e(g, g) r.s = e(y B , g) s.α A = w s.x B A , where w A = G α A . Finally, sets c B = (c 1 = C = m • w s A , c 2 = w s.x B A ). 2 Dec 1 (sk, c): Let sk = ⟨x, α, β⟩, c = (c 1 , c 2 ), then decryption of the first level ciphertext is m = c 1 /c x -1 2 . Dec 2 (sk, c): Let sk = ⟨x, α, β⟩, c = (T , C , C ′ , . . .), decryption of the second level ciphertext is m = C /e(g, C ′ ) α/β -1 .</formula><p>Remark. We remark that this scheme differs from our previous scheme <ref type="bibr" target="#b9">[10]</ref>, as the latter does not satisfy the CPA definition (see Definition 1). In the previous scheme <ref type="bibr" target="#b9">[10]</ref>, F n in the ReEnc algorithm (which corresponds to the above Eq. ( <ref type="formula" target="#formula_15">1</ref>)) is of the form F n = e(g, g) x B •q n (0) , where x B is the private key of the delegatee. As such the delegatee is able to cancel out the x B element from F n by computing</p><formula xml:id="formula_23">F ′ n = F x -1 B n</formula><p>. As a result, delegatees can pool their F ′ n 's by Lagrange interpolation as in Eq. ( <ref type="formula">2</ref>). However, it seems still safe to apply the scheme in <ref type="bibr" target="#b9">[10]</ref> to the encryption of cloud data, as the cloud server in the Data Access algorithm simply returns ⊥ if a requesting user's re-encryption key does not satisfy the requested ciphertext's access policy, and users are not able to pool their transformed ciphertexts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Security analysis</head><p>The security of our proposed scheme is defined in Theorem 4.1.</p><p>Theorem 4.1. The above scheme is CPA secure (in the sense of Definition 1) in the generic group model <ref type="bibr" target="#b27">[28]</ref>.</p><p>Proof. The proof considers two separate two cases: the first case is that A does not make a re-encryption key generation query with an attribute set A i satisfying the challenge access policy P * , and the second is that A makes at least one reencryption key generation query whose attribute set A i satisfies P * . Note that for each of the first type re-encryption key generation queries, A will obtain the delegatee's private key, together with the re-encryption key; while for the second type, A will not obtain the delegatees' private keys.</p><p>For the first case, we prove that A for the above scheme is directly reduced to an adversary B for the ciphertext-policy ABE scheme <ref type="bibr" target="#b7">[8]</ref>, which is proven secure in the generic group model. To this end, A needs to simulate a game to B with respect to the ciphertext-policy ABE scheme. In particular, A has to answer B's decryption key generation queries (for each query, B submits an attribute set). We show that within the context of the CPA game between A and its challenger, A can answer B's decryption key generation queries. Specifically, receiving an attribute set A from B, A makes a re-encryption key query on A to its challenger, and subsequently obtains the re-encryption key (k, {k i1 , k i2 } i∈A ) as well as the delegatee's public/private key pk/sk (by assumption, A will obtain the delegatee's private key sk = (x, α, β)). Then A computes and returns (k x -1 , {k x -1 i1 , k x -1 i2 } i∈A ) to B as the reply. Note that (k x -1 , {k x -1 i1 , k x -1 i2 } i∈A ) is, indeed, a valid decryption key for the ciphertext-policy ABE scheme in <ref type="bibr" target="#b7">[8]</ref>, with r/x and r i /x acting as random numbers. It is trivial to observe that the simulation by A is perfect.</p><p>In the second case, for simplicity we assume that the attributes A i in every re-encryption key generation query of A satisfy the challenge access policy P * . We prove that under the generic group model, no efficient adversary A can guess b ′ = b in the security game defined in Definition 1 noticeably better than a random guess. Note that a random guess b ′ by A equals b with probability 1/2, and the advantage of A is denoted as ϵ.</p><p>In the generic group model, elements of groups G 0 , G T are encoded as unique random strings and, thus, the adversary can directly test no property other than equality. The opaque encoding of the elements in G 0 is defined as the function ξ 0 : Z p → {0, 1} * , which maps all a ∈ Z p to the string representation ξ 0 (a) of g a ∈ G. Likewise, ξ T : Z p → {0, 1} * maps a ∈ Z p to the string representation ξ T (a) of e(g, g) a ∈ G T . The adversary A communicates with oracles to compute group action on G 0 , G T and bilinear map e : G 0 × G 0 → G T , through the ξ 0 -representation and ξ T -representation only.</p><p>For simplicity, we modify the game slightly: in the challenge phase of the security game, A is given a challenge ciphertext whose C component is either m 0 • e(g, g) α•s or m 1 • e(g, g) α•s . We modify C to be either e(g, g) α•s or e(g, g) ϑ , for a random ϑ in Z p . Indeed, any adversary A that has advantage ϵ in the original security game can be transformed into an adversary having an advantage of ϵ/2 in the modified game (consider two hybrids: one in which the adversary is to distinguish between m 0 • e(g, g) α•s , e(g, g) ϑ , and the other in which the adversary is to distinguish between m 1 • e(g, g) α•s , e(g, g) ϑ ).</p><p>Hereafter, we consider A in a modified game. In the Setup phase, the challenger sends the public parameters ξ 0 (1), ξ T <ref type="bibr" target="#b0">(1)</ref> to A. To simulate the hash function H, the challenger maintains a table, which is initially empty. Whenever A asks a query i on H, if i has never been asked before, the challenger selects a random value t i ∈ R G T , and adds an entry (i, t i , ξ 0 (t i )) to the table and returns ξ 0 (t i ) to A; otherwise, returns the already defined ξ 0 (t i ) to A.</p><p>In Phase 1, for a jth re-encryption key generation query A, the challenger first picks x A , α A , β A and sets pk A = ⟨y A = ξ 0 (x A ), h A = ξ 0 (β A ), w A = ξ 0 (α A )⟩, sk A = ⟨x A , α A , β A ⟩, and picks x B , α B , β B and sets pk B = ⟨y</p><formula xml:id="formula_24">B = ξ 0 (x B ), h B = ξ 0 (β B ), w B = Table 1 Rational functions in G 0 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Re-encryption key queries x</head><formula xml:id="formula_25">A β A x B β B x B α A +r [j] β B r [j] + t i r [j] i r [j] i Challenge ciphertext β B • s s t i ′ s ξ 0 (α B )⟩, sk B = ⟨x B , α B , β B ⟩.</formula><p>Then selects r [j] , r [j]  i ∈ R Z p , i ∈ A, and returns pk A , pk B , rk = ⟨k = ξ 0 ( x B α A +r [j]   β B</p><p>), ∀i ∈ A : {k i1 = ξ 0 (r [j]  + t i r [j]  i ), k i2 = ξ 0 (r [j]  i )}⟩ to A. In the Challenge phase, A submits two equal-length challenge messages m 0 , m 1 and a challenge access policy P * . The challenger responds as follows. Selects s ∈ R Z p , and computes shares ς i of s for all attributes i contained in P * according to the secret sharing as described in the Enc 2 algorithm. Note that ς i 's are random values subject to the underlying secret sharing scheme induced by P * . Finally, the challenger chooses ϑ ∈ R Z p , and returns to A the challenged ciphertext as C = ξ T (ϑ) and</p><formula xml:id="formula_26">C ′ = ξ 0 (β • s), C i1 = ξ 0 (ς i ), C i2 = ξ 0 (t i ς i ) for each relevant attribute i in P * .</formula><p>In Phase 2, the challenger continues to respond to re-encryption key generation queries from A, just as in Phase 1. Analysis of the simulated game. Let q bound the total number of group elements A receives during the game from the queries it makes to the oracles for G 0 , G T , the bilinear map, and the hash function (including the hash function queries implicitly invoked by re-encryption key generation and challenge ciphertext generation). We will show that with probability 1-O(q 2 /p), the adversary's view in this simulated game is identically distributed to its view if it has been given C = ξ T (α •s) in the game. Note that in the current game, the adversary's advantage is 0, as ξ T (ϑ) is independent of the encryption of the challenge messages. We, thus, conclude that the advantage of the adversary, when given C = ξ T (α • s), is at most O(q 2 /p), which proves the theorem if q 2 /p is negligible.</p><p>We assume that A communicates with group oracles, only with values it has already received from the oracles. Note that each query A makes is of the form of a rational function π = χ /γ in the variables of x A , x B , α A , α B , β A , β B , t i , r [j] , r [j]  i , and ς i .</p><p>We now condition on the event that no ''unexpected collisions'' occur in either G 0 and G T . An unexpected collision would be when two queries of two distinct rational functions χ /γ ̸ = χ ′ /γ ′ , due to the random choices of the values of the involved variables, coincide in value. For any pair of queries corresponding to χ /γ and χ ′ /γ ′ , a collision occurs only if the non-zero polynomial χ /γχ ′ /γ ′ evaluates to be zero. In our case the total degree of χ /γχ ′ /γ ′ is at most 5; thus the probability of a collision is O(1/p) <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b29">30]</ref>. By a union bound, the probability of any unexpected collision happens is at most O(q 2 /p) for q queries. As a result, we have probability 1 -O(q 2 /p) that no unexpected collisions happen.</p><p>Subject to the condition of no unexpected collisions, we need to show that A's view is identically distributed if the challenger has set ϑ = α • s. To this end, note that the only way that the view of A can differ in the case of ϑ = α • s is if there are two queries π , π ′ into G T such that π ̸ = π ′ but π | ϑ=α•s = π ′ | ϑ=α•s . We will now show that this will not happen. Recall that ϑ only occurs as ξ T (ϑ) which is an element of G T ; thus, the only difference that π and π ′ can have on ϑ is such that ππ ′ = ηϑηα • s, for a constant η. It suffices to show that A can never construct a query for ξ T (ηα</p><formula xml:id="formula_27">• s = π -π ′ + ηϑ),</formula><p>given that no unexpected collisions occur. This arrives at a contradiction and, therefore, proves the theorem.</p><p>This follows from the following analysis, based on the information given to A during the game. For ease of reference, Table 1 enumerates all rational functions in G 0 known to A by means of re-encryption key generation queries and the challenge ciphertext query (i, i ′ are possible attribute strings, and j, j ′ are the indices of the re-encryption key generation queries).</p><p>Note that since we assume that the attributes in A's re-encryption key generation queries satisfy the challenge access policy, we directly use s to replace ς i 's for the challenge ciphertext, because compared to ς i 's, s clearly helps A more in terms of gaining advantage in the game.</p><p>In addition, A knows rational function t i through the hash function queries. Any query in G T is a linear combination of these rational functions. Observe from the table that the only rational function containing α A is x B α A +r [j]   β B</p><p>. In order for A to produce a rational function containing ηα A • s while canceling out other elements as much as possible is by pairing x B α A +r [j]   β B and β B • s. This will create a polynomial of the form x B α A s + r [j] s. It can be seen that the element x B cannot be canceled out by pairing any rational functions in Table <ref type="table">1</ref>, as A does not know x B and x -1 B (note that we are working under the condition of no unexpected collisions). This completes the proof for the second case, and in turn the entire proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">An application: revocable fine-grained data sharing over cloud</head><p>In this section, we present an application of our scheme: fine-grained data sharing over cloud storage services. We begin with a discussion of the application scenario.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Application scenario</head><p>We consider the following application scenario. To enjoy the advantages of cloud storage services, a Data Owner (DO) establishes a cloud-based data sharing platform, where the DO outsources her data to the cloud storage, and authorizes a group of users to access the data, as shown in Fig. <ref type="figure" target="#fig_1">1</ref>. In particular, users are distinguished by their functional roles (a func- tional role can be defined by a set of attributes), and are granted access right according to their respective roles. The DO is to enforce fine-grained control over the cloud data, such that data are accessed by roles on a need-to-know basis (i.e., different roles have different access rights). However, the DO does not fully trust the cloud, and wants to ensure the privacy of the data stored in the cloud. Thus, the data uploaded to the cloud are encrypted by the DO. Each authorized user is granted appropriate decryption capability by the DO as per the role. The system must support user revocation. Therefore, once an authorized user is revoked, the user's decryption capability will also be removed in real-time.</p><p>Example. An example of DO and authorized users are a company and its employees, respectively. The company stores the corporate data in the cloud, and allows employees to access data on a need-to-know basis. In such a context, the company often needs to specify data access control policies based on the roles that employees assume (rather than on the identities of the employees). For example, an access control policy would be ''this data can only be accessed by the executive manager from the purchasing department''. As a result, the employees are distinguished by their roles, i.e., each user should be issued a role certificate, rather than identity certificate. The need for user revocation occurs, when, e.g., an employee leaves the company. In such a case, the role of the employee remains, but the rights of the individual employee are revoked. Thus, we are concerned about user revocation, rather than attribute revocation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Encryption of cloud data with ABE, and user revocation</head><p>Attribute-based encryption (ABE) (e.g. <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b30">31]</ref>) can potentially satisfy the needs of enforcing fine-grained cryptographic access control over cloud data in the above application scenario. A number of proposals in the literature have, for example, suggested applying ABE to encrypting cloud data. Compared to conventional public-key encryption, where a message encrypted under a public key can only be decrypted by a single corresponding private key, ABE offers much finer-grained encryption/decryption capabilities. More specifically, ABE is a one-to-many encryption primitive, whereby data are encrypted with a system-wide public key under certain access policy/attributes and each decryption key is attached to certain attributes/access policy, such that the ciphertext can be decrypted only if the attributes satisfy the access policy.</p><p>Although ABE appears promising to be used in the encryption of cloud data, user revocation remains a limiting factor. The challenge is due to the fact that ABE is essentially ''group encryption''; thus, ABE does not differentiate individual users. The ABE schemes proposed by <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b30">31</ref>] include an ''expiry time'' attribute in the attribute set, such that a decryption key can work only up to its associated expiry time. However, such a mechanism cannot implement real-time revocation of decryption capabilities. The ABE scheme in <ref type="bibr" target="#b31">[32]</ref> supports negative constrains in the access policy, which provides a means for attribute revocation by negating the attributes to be revoked. Such a ''negation'' mechanism is not scalable for user revocation in encryption of cloud data, as each revoked user must be explicitly treated as a distinct attribute and included in the ciphertext. Therefore, the scheme is not practical when the number of revoked users grows large. Other variants of ABE, such as predicate encryption (e.g., <ref type="bibr" target="#b32">[33]</ref>) and functional encryption (e.g., <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b34">35]</ref>) are also restricted to these two revocation mechanisms.</p><p>There also exist ''stateful'' user revocation mechanisms, which involve updating of the decryption keys (e.g. <ref type="bibr" target="#b35">[36]</ref><ref type="bibr" target="#b36">[37]</ref><ref type="bibr" target="#b37">[38]</ref>) that would allow re-generation of cloud data and key re-distribution. For example, <ref type="bibr" target="#b37">[38]</ref> proposed applying KP-ABE <ref type="bibr" target="#b8">[9]</ref> to be used in the encryption of cloud data, which also adopts the specific technique of PRE scheme <ref type="bibr" target="#b0">[1]</ref> to update users' decryption keys for user revocation. The advantage of such an user revocation approach is that the majority of re-generation of cloud data and re-distribution of new key activities are moved to the cloud. While such an approach is a significant improvement over the trivial solution (i.e. in schemes where encryptor is entirely responsible for data re-generation and key re-distribution), it would be preferable to move the entire re-generation of cloud data and re-distribution of new key activities to the cloud. The user revocation method described in <ref type="bibr" target="#b22">[23]</ref> is one such example, where the cloud is responsible for re-generating encrypted cloud data for user revocation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>) -9</head><p>Table <ref type="table">2</ref> A comparison of user revocation approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Immediate revocation</head><p>No key update &amp; data re-gen. Scalability Expiry time</p><formula xml:id="formula_28">× ✓ ✓ Negation ✓ ✓ × [36-38] ✓ × ✓ Our approach ✓ ✓ ✓</formula><p>✓: Can be achieved; ×: Unable to be achieved.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Cloud-enabled user revocation</head><p>It is clear from the above discussions that it is not yet practical to deploy ABE for encryption and sharing of cloud data, until a more satisfactory user revocation solution is available. Based on our ciphertext-policy attribute based CPRE scheme, we propose a cloud-enabled user revocation approach. The basic idea of our approach is as follows. The cloud is enlisted as the proxy in CPRE, and holds the re-encryption keys of all authorized users. As such, the cloud is enabled to transform encrypted data records into those under a user's public key. If the user is authorized and, therefore, will have a re-encryption key held by the cloud. To revoke a user, we would simply erase the user's re-encryption key from the cloud and, thus, the cloud will not be able to transform encrypted data for the user. Note that re-encryption key erasure could either be undertaken by the data owner (DO) through an administration interface or by the cloud under the DO's instruction. Using this approach, user revocation incurs little cost, and requires no key update, no re-generation of cloud data, and no re-distribution of keys.</p><p>A comparative summary is outlined in Table <ref type="table">2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.">Application details</head><p>We now explain how our proposed CPRE scheme can be deployed for encryption of cloud data. System Setup. The DO runs CPRE.Setup to establish and publish the public parameter of the CPRE scheme.</p><p>The DO runs CPRE.KeyGen to generate his/her own key pair pk O /sk O . Similarly, users u generate their own key pairs pk u /sk u . All public keys are part of the public system parameters.</p><p>User Authorization. To authorize a user u, the DO decides a set of attributes A according to u's role; executes rk ) to this re-encryption key table.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>User identity Re-encryption key</head><p>Alice rk</p><formula xml:id="formula_29">O A A -→A Bob rk O A B -→B John rk O A J -→J Mary rk O A M -→M • • • • • •</formula><p>The cloud manages a RKT, which contains the re-encryption keys of all authorized users. User revocation. To revoke an authorized user u, the re-encryption key of u is simply erased from the cloud's reencryption key table. Depending on the specific application, either the cloud updates the re-encryption key table (as instructed by the DO), or a management interface is provided to the DO so that the DO can manage the deletion.</p><p>In short, the DO encrypts cloud data using the Enc 2 algorithm, and decryption by the user is performed using the Dec 1 algorithm. Enc 1 and Dec 2 are not used in the application.</p><p>In this application, we assume that the cloud is semi-trusted (i.e. the cloud is not to be trusted in ensuring the secrecy of the stored data, but it can be trusted to manage the cloud data, and process user access requests and other administrative activities). This is a similar assumption on the trust invested in the proxy in the CPRE setting. We also assume that when a user requests data from the cloud, the user needs to include the identity in the request. This will facilitate the cloud in determining the corresponding re-encryption key to use from the Re-encryption Key the authenticity of the request. In other words, the cloud is not concerned about a legitimate user impersonating another. This is because each user's re-encryption key is part of a unique key pair. The novelty of our proposal is that we utilize PRE/CPRE for user revocation, and the CPRE scheme we proposed attains fine-grained cryptographic access control, with granularity comparable to ABE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.">Security considerations</head><p>The primary security concern in the above application is to ensure the privacy of data against the (semi-trusted) cloud, which is the key motivation for the encryption of cloud data (see Section 1). In our context, the cloud plays the role of proxy in the CPRE scheme, and as we have shown in Section 4.2, the proxy in our CPRE scheme is not able to learn any useful information about the plaintext message. Hence, the application is secure in the sense of ensuring the privacy of the data against the (semi-trusted) cloud.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6.">Benefits</head><p>A key benefit of the application of our CPRE scheme for encryption and sharing of cloud data is user-side efficiency. Recall that our CPRE scheme is based on bilinear map and achieves fine-grained cryptographic access control, which is comparable to ABE. At the user side, however, the user only needs to receive and decrypt a first-level ciphertext in G T . Note that G T is an ordinary Abelian group (compared to bilinear groups). This results in high user-side efficiency in terms of both communication and computation. Specifically, let |G T | denotes the bit length of an element in G T . Then the size of a first-level ciphertext is 2|G T |, and Dec 1 involves only one exponentiation in G T , and both are constant. In other words, user-side computation is lightweight and does not involve pairing operation (despite the fact that our scheme is built on bilinear map). This is a key difference between our proposal and existing proposals (that apply ABE for encryption of cloud data), which require pairing operations to be performed by the user. The high efficiency and no pairing requirement for users make it possible to access cloud data using resource-constrained devices, such as smart mobile phones, tablets, and potentially in the near future, Internet-of-Things (IOT) devices.</p><p>The second key benefit of our proposal is the efficiency of cloud-enabled user revocation. In the case of user revocation, our proposal only requires the removal of the revoked user's re-encryption key from the cloud, without the need for key update, re-generation of cloud data, and re-distribution of keys (as required in other existing schemes).</p><p>In our proposal, cloud-enabled user revocation by CPRE is realized via the split of decryption capability, where decryption of a ciphertext requires the cooperation between the cloud and a delegatee. Such a feature differs from that of the decryption key split feature in <ref type="bibr" target="#b38">[39]</ref>. The entity performing the decryption split (i.e. the DO in our application context) does not necessarily know the secret of a delegatee, while the entity for decryption key split in <ref type="bibr" target="#b38">[39]</ref> needs to know the delegatee's secret. We regard this as the third key benefit of our proposal-the decryption capability split mechanism in our proposal allows the delegatee to maintain the secrecy of his/her secret, without the need to reveal it to the entity performing the decryption split. We remark that the method for delegating the workload of ABE decryption in <ref type="bibr" target="#b39">[40,</ref><ref type="bibr" target="#b40">41]</ref> could also be applied to realize cloud-enabled user revocation, but this will result in decryption key split.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7.">Disadvantages</head><p>We stress that our application of CPRE for implementing cloud server-enabled user revocation does not come at no cost. This approach requires the cloud platform to perform the ReEnc operation upon every data access request, which can be computationally expensive. Indeed, such online computations at the cloud side are inevitable, but the costs could be lowered using the following approach.</p><p>The actual deployment of the CPRE scheme should follow the common practice for public-key encryption, namely, the payload data is encrypted with a random key under symmetric encryption and the encryption key is encapsulated with the public-key encryption (i.e. the Enc 2 algorithm in our case). This allows us to amortize the overhead incurred by the key encapsulation. Specifically, all data sharing the same access policy are encrypted using a common symmetric encryption key. Consequently, a ReEnc operation by the cloud may allow a user to access many data records (rather than a ReEnc operation per data record). We stress that this does not necessarily require the data owner to manage the symmetric encryption keys. Instead, the data owner can obtain the encryption key corresponding to an access policy by retrieving and decrypting (i.e. Enc 2 ) the related key encapsulation ciphertext from the cloud, if the access policy in question has already been used.</p><p>The overhead-amortization mechanism must support user revocation. Therefore, once a user is revoked, the data owner will use a new key for every access policy when encrypting new data records (but leave the old encrypted data records intact). This guarantees that the newly generated cloud records cannot be decrypted by the revoked user. In principle, it is not a concern that a revoked user can decrypt the data the user had been entitled to before his revocation (e.g. the user would likely have saved a copy of the data in another location).</p><p>Caveat. It may appear that the schemes in <ref type="bibr" target="#b35">[36]</ref><ref type="bibr" target="#b36">[37]</ref><ref type="bibr" target="#b37">[38]</ref> implementing ''stateful'' user revocation mechanisms have an advantage over our application, in terms of the online computations by the cloud platform. In those schemes, few online computations are required by the cloud platform to respond to users' data accesses. While it seems that the high workload entrusted to the cloud due to user revocation in those schemes could be performed offline; in practice, it would be hard to arrange for the re-generation of cloud data to be offline without affecting user online data requests (consider that a user requests data while re-generation of cloud data is in progress).</p><p>More importantly, the disadvantage of online computation in our application can be understood to be a tradeoff for the unique feature of user-side efficiency and the no-requirement of pairing support at the user side.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Evaluation</head><p>We implemented the proposed scheme to evaluate its performance. The implementation is coded in Java, and the cryptographic algorithms are implemented using the Bouncy Castle Java Crypto Library. <ref type="foot" target="#foot_1">3</ref> We instantiated the bilinear map in the scheme with a 512-bit supersingular curve with embedding degree 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Experimental results</head><p>In our scheme, the computation costs for Enc 2 and ReEnc are dependent on the complexity of the access control policy, and are linear to the number of leaf nodes of the access tree (more precisely, the cost for ReEnc also depends on the attributes associated with the re-encryption key).</p><p>To empirically evaluate the computational overhead of the Enc 2 and ReEnc algorithms, we run them on a PC with 2.66 GHz Intel Core2Duo and 3.25 GB RAM, while trying to avoid compounding factors such as network latency, instability of ondemand computing. We experimented with a set of access conditions whose access trees are constructed with all nonleaf nodes being AND gates, and re-encryption keys contain all attributes. Access conditions in such a form ensure that all attributes in an access tree are used in the ReEnc algorithm; thus, imposing the heaviest workload on the algorithm (i.e. the worse-case scenario). The experimental results are depicted in Fig. <ref type="figure" target="#fig_2">2</ref>, which shows, respectively, the timing of Enc 2 and ReEnc varying with the number of attributes. The timing averages over 100 runs of each experiment.</p><p>As illustrated in Fig. <ref type="figure" target="#fig_2">2</ref>, the results corroborate the fact that both algorithms perform linear computations with the number of attributes. The computational costs of ReEnc with 60 attributes are about 1.5 s. This performance is realistic for real-world applications, and it should suffice to specify functional role based access control policies with 50-60 attributes.</p><p>We also implemented and tested the Dec 1 algorithm of our scheme on a smartphone, which has a 1.2 GHz CPU and 2 GB RAM. The experimental results indicate that on average, it takes about 10 ms to decrypt a ciphertext. In addition, the communication overhead for the user is 2|G T |, about 1.2 Kb in our implementation. These results suggest that it is practical for a smartphone user to access the cloud storage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion</head><p>Encryption of cloud data by the data owner is now commonly accepted as necessary to achieve data privacy against a third-party (semi-honest) cloud provider. ABE is a viable solution, as it allows fine-grained cryptographic access control, only if there is a satisfactory solution to the user revocation issue. Therefore, to address the user revocation challenge, we proposed a ciphertext-policy attribute based CPRE scheme, which was utilized in the implementing of the cloud-enabled user revocation approach. This application achieves access control over cloud data with granularity comparable to ABE, yet without incurring any cost for user revocation. Our proposal has applications in many real-world situations.</p><p>Another benefit of our proposal is the efficiency in terms of low computation and communication overheads required at the user side, which makes it possible for users to use resource constrained devices to access cloud data. This is demonstrated by our experimental results.</p><p>Future work includes evaluating our proposal in a real-world cloud deployment.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>:</head><label></label><figDesc>On input a private key sk A of the delegator, a set of attributes A and a public key pk B of the delegatee, the re-encryption key generation algorithm outputs a re-encryption key rk A A -→B from A to B issued upon A.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Enc 1 (</head><label>1</label><figDesc>pk, m) → c: On input a public key pk and a plaintext m ∈ M (M is an appropriate message space), the first-level encryption algorithm outputs a first-level ciphertext c.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Enc 2 (</head><label>2</label><figDesc>pk, m, P) → c: On input a public key pk, a message m ∈ M and an access policy P, the second-level encryption algorithm outputs a second-level ciphertext c. Note that in the setting of PRE, it distinguishes between first-level encryption and second-level encryption, and only second-level ciphertexts could be transformed (into first-level ciphertexts).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>the adversary; otherwise, return pk j /sk j and rk O A j -→j to A. Guess. The adversary A outputs a bit b ′ , which is a guess on b. Definition 1 (CPA Security). A ciphertext-policy attribute based CPRE scheme is CPA (chosen plaintext attack) secure if for any PPT adversary A, it holds that Pr[b ′ = b] = 1/2 + ϵ(κ), where ϵ is a negligible function.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>YFig. 1 .</head><label>1</label><figDesc>Fig. 1. Application scenario of data sharing over cloud.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>(sk O , A, pk u ), and sends rk O A -→u to the cloud in a secure manner. Note that rk O A -→u is denoted as the role certificate for u. The cloud maintains a Re-encryption Key Table (RKT) with each entry being a user identity along with his re-encryption key, as shown below. As a result, the cloud adds a new entry (u, rk O A -→u</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Data outsourcing . To outsource a data record m to the cloud, the DO determines the access policy P of the record, and then computes c = CPRE.Enc 2 (pk O , m, P). Finally, the DO uploads c to the cloud. Data access. Suppose a user u wishes to retrieve an encrypted data record c from the cloud, the cloud first obtains u's re-encryption key rk O Au -→u from the RKT (Re-encryption Key Table), and then computes c u = CPRE.ReEnc(rk O Au -→u , c) before sending it to user u. At the user side, u obtains m by computing m = CPRE.Dec 1 (sk u , c u ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Experimental results on the performance of Enc 2 and ReEnc.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Table. However, the cloud is not required to check</figDesc><table><row><cell>Y. Yang et al. / Pervasive and Mobile Computing (</cell><cell>)</cell><cell>-</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>If we see w A as an ordinary element in G T (i.e., not a part of the delegator's public key), the format of the transformed ciphertext conforms exactly to that of the first-level ciphertext.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>http://www.bouncycastle.org/java.html.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>Jian Weng was supported by National Science Foundation of China under Grant No 61272413 and the Invitation Programs for Foreign-based Researchers provided by NICT.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Divertible protocols and atomic proxy cryptography</title>
		<author>
			<persName><forename type="first">M</forename><surname>Blaze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Bleumer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Strauss</surname></persName>
		</author>
		<idno type="DOI">10.1007/BFb0054122</idno>
		<ptr target="http://dx.doi.org/10.1007/BFb0054122" />
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology-Eurocrypt&apos;98</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1403</biblScope>
			<biblScope unit="page" from="127" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Type-based proxy re-encryption and its construction</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Tang</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-540-89754-5_11</idno>
		<ptr target="http://dx.doi.org/10.1007/978-3-540-89754-5_11" />
	</analytic>
	<monogr>
		<title level="m">Indocrypt&apos;08</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="130" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Conditional proxy re-encryption secure against chosen-ciphertext attack</title>
		<author>
			<persName><forename type="first">J</forename><surname>Weng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-K</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lai</surname></persName>
		</author>
		<idno type="DOI">10.1145/1533057.1533100</idno>
		<idno>ASIACCS&apos;09</idno>
		<ptr target="http://dx.doi.org/10.1145/1533057.1533100" />
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="322" to="332" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Cloud security alliance: Security guidance for critical areas of focus in cloud computing</title>
		<ptr target="http://www.cloudsecurityalliance.org" />
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<ptr target="http://www.enisa.europa.eu/act/rm/_les/deliverables/cloud-computing-risk-assessment" />
		<title level="m">European network and information security agency: Cloud computing risk assessment</title>
		<imprint>
			<date type="published" when="2009-11">November 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Gartner: don&apos;t trust cloud provider to protect your corporate assets</title>
		<ptr target="http://www.mis-asia.com/resource/cloud-computing/gartner-dont-trust-cloud-provider-to-protect-your-corporate-assets" />
		<imprint>
			<date type="published" when="2012-05-28">May 28, 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Efficient conditional proxy re-encryption with chosen-ciphertext security</title>
		<author>
			<persName><forename type="first">J</forename><surname>Weng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Bao</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-04474-8_13</idno>
		<ptr target="http://dx.doi.org/10.1007/978-3-642-04474-8_13" />
	</analytic>
	<monogr>
		<title level="m">12th International Conference on Information Security, ISC&apos;09</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5735</biblScope>
			<biblScope unit="page" from="151" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Ciphertext-policy attribute-based encryption</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bethencourt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
		<idno type="DOI">10.1109/SP.2007.11</idno>
		<ptr target="http://dx.doi.org/10.1109/SP.2007.11" />
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security &amp; Privacy, S&amp;P&apos;07</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="321" to="334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Attribute-based encryption for fine-grained access control of encrypted data</title>
		<author>
			<persName><forename type="first">V</forename><surname>Goyal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Pandy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
		<idno type="DOI">10.1145/1180405.1180418</idno>
		<ptr target="http://dx.doi.org/10.1145/1180405.1180418" />
	</analytic>
	<monogr>
		<title level="m">ACM Computer and Communications Security Conference, CCS&apos;06</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="89" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Fine-grained conditional proxy re-encryption and application</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Weng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sakurai</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-12475-9_15</idno>
		<ptr target="http://dx.doi.org/10.1007/978-3-319-12475-9_15" />
	</analytic>
	<monogr>
		<title level="m">th International Conference on Provable Security, ProvSec&apos;14</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8782</biblScope>
			<biblScope unit="page" from="206" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Improved proxy re-encryption schemes with applications to secure distributed storage</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ateniese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hohenberger</surname></persName>
		</author>
		<idno type="DOI">10.1145/1127345.1127346</idno>
		<ptr target="http://dx.doi.org/10.1145/1127345.1127346" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Inf. Syst. Secur. (TISSEC)</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="30" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Chosen-ciphertext secure proxy re-encryption</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hohenberger</surname></persName>
		</author>
		<idno type="DOI">10.1145/1315245.1315269</idno>
		<ptr target="http://dx.doi.org/10.1145/1315245.1315269" />
	</analytic>
	<monogr>
		<title level="m">ACM CCS 2007</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="185" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Unidirectional chosen-ciphertext secure proxy re-encryption</title>
		<author>
			<persName><forename type="first">B</forename><surname>Libert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vergnaud</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-540-78440-1_21</idno>
		<ptr target="http://dx.doi.org/10.1007/978-3-540-78440-1_21" />
	</analytic>
	<monogr>
		<title level="m">PKC&apos;08</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">4929</biblScope>
			<biblScope unit="page" from="360" to="379" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Relaxing chosen-ciphertext security</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Nielsen</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-540-45146-4_33</idno>
		<ptr target="http://dx.doi.org/10.1007/978-3-540-45146-4_33" />
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology-Crypto&apos;03</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2729</biblScope>
			<biblScope unit="page" from="565" to="582" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Chosen-ciphertext secure proxy re-encryption without pairings</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Weng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chen</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-540-89641-8_1</idno>
		<ptr target="http://dx.doi.org/10.1007/978-3-540-89641-8_1" />
		<imprint>
			<date type="published" when="2008">2008. 2008</date>
			<biblScope unit="page" from="1" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<author>
			<persName><forename type="first">J</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Cao</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-00468-1_20</idno>
		<ptr target="http://dx.doi.org/10.1007/978-3-642-00468-1_20" />
	</analytic>
	<monogr>
		<title level="m">Cca-secure proxy re-encryption without pairings, in: PKC&apos;09</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5443</biblScope>
			<biblScope unit="page" from="357" to="376" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Efficient unidirectional proxy re-encryption</title>
		<author>
			<persName><forename type="first">J</forename><surname>Weng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S M</forename><surname>Chow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Deng</surname></persName>
		</author>
		<ptr target="eprint.iacr.org/2009/189.pdf" />
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Attribute-based proxy ee-encrytpion with delegating capabilities</title>
		<author>
			<persName><forename type="first">X</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shao</surname></persName>
		</author>
		<idno type="DOI">10.1145/1533057.1533094</idno>
		<ptr target="http://dx.doi.org/10.1145/1533057.1533094" />
	</analytic>
	<monogr>
		<title level="m">ACM ASIACCS&apos;09</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="276" to="286" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Ciphertext policy attribute-based proxy re-encryption</title>
		<author>
			<persName><forename type="first">S</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Chen</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-17650-0_28</idno>
		<ptr target="http://dx.doi.org/10.1007/978-3-642-17650-0_28" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Information and Communications Security, ICICS&apos;10</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="401" to="415" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A secure and efficient ciphertext-policy attribute-based proxy re-encryption for cloud data sharing</title>
		<author>
			<persName><forename type="first">K</forename><surname>Liang</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.future.2014.11.016</idno>
		<ptr target="http://dx.doi.org/10.1016/j.future.2014.11.016" />
	</analytic>
	<monogr>
		<title level="j">Future Gener. Comput. Syst</title>
		<imprint/>
	</monogr>
	<note>in press</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A ciphertext-policy attribute-based proxy re-encryption scheme for data sharing in public clouds</title>
		<author>
			<persName><forename type="first">K</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Susilo</surname></persName>
		</author>
		<idno type="DOI">10.1002/cpe.3397</idno>
		<ptr target="http://dx.doi.org/10.1002/cpe.3397" />
	</analytic>
	<monogr>
		<title level="j">Concurr. Comput.: Pract. Exper</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">8</biblScope>
			<date type="published" when="2004">2015. 2004-2027</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Outsourcing the re-encryption key generation: Flexible ciphertext-policy attribute-based proxy re-encryption</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kawai</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-17533-1_21</idno>
		<ptr target="http://dx.doi.org/10.1007/978-3-319-17533-1_21" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Information Security Practice and Experience, ISPEC&apos;15</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="301" to="315" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Dynamic credentials and ciphertext delegation for attribute-based encryption, in: Crypto&apos;12</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Seyalioglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-32009-5_13</idno>
		<ptr target="http://dx.doi.org/10.1007/978-3-642-32009-5_13" />
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">7417</biblScope>
			<biblScope unit="page" from="199" to="217" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Attribute-based conditional proxy re-encryption with chosen-ciphertext security</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhang</surname></persName>
		</author>
		<idno type="DOI">10.1109/GLOCOM.2010.5684045</idno>
		<ptr target="http://dx.doi.org/10.1109/GLOCOM.2010.5684045" />
	</analytic>
	<monogr>
		<title level="m">GLOBECOM 2010</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Chosen-ciphertext security from identity-based encryption</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-540-24676-3_13</idno>
		<ptr target="http://dx.doi.org/10.1007/978-3-540-24676-3_13" />
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology-Eurocrypt&apos;04</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3027</biblScope>
			<biblScope unit="page" from="207" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Secure integration of asymmetric and symmetric encryption schemes</title>
		<author>
			<persName><forename type="first">E</forename><surname>Fujisaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</author>
		<idno type="DOI">10.1007/s00145-011-9114-1</idno>
		<ptr target="http://dx.doi.org/10.1007/s00145-011-9114-1" />
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology-Crypto&apos;09</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1666</biblScope>
			<biblScope unit="page" from="80" to="101" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Generic construction of chosen ciphertext secure proxy re-encryption, in: CT-RSA&apos;12</title>
		<author>
			<persName><forename type="first">G</forename><surname>Hanaoka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Kawai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kunihiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Matsuda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Weng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhao</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-27954-6_22</idno>
		<ptr target="http://dx.doi.org/10.1007/978-3-642-27954-6_22" />
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="349" to="364" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Lower bounds for discrete logarithms and related problems</title>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-69053-0_18</idno>
		<ptr target="http://dx.doi.org/10.1007/3-540-69053-0_18" />
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology-Eurocrypt&apos;97</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="256" to="266" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Fast probabilistic algorithms for verification of polynomial identities</title>
		<author>
			<persName><forename type="first">J</forename><surname>Schwartz</surname></persName>
		</author>
		<idno type="DOI">10.1145/322217.322225</idno>
		<ptr target="http://dx.doi.org/10.1145/322217.322225" />
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="701" to="717" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Probabilistic algorithms for sparse polynomials</title>
		<author>
			<persName><forename type="first">R</forename><surname>Zippel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposiumon on Symbolic and Algebraic Computation</title>
		<imprint>
			<date type="published" when="1979">1979</date>
			<biblScope unit="volume">72</biblScope>
			<biblScope unit="page" from="216" to="226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Ciphertext-policy attribute-based encryption: An expressive, efficient, and provably secure realization</title>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-19379-8_4</idno>
		<ptr target="http://dx.doi.org/10.1007/978-3-642-19379-8_4" />
	</analytic>
	<monogr>
		<title level="m">PKC&apos;11</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="53" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Attribute-based encryption with non-monotonic access structures</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
		<idno type="DOI">10.1145/1315245.1315270</idno>
		<ptr target="http://dx.doi.org/10.1145/1315245.1315270" />
	</analytic>
	<monogr>
		<title level="m">ACM CCS&apos;07</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="195" to="203" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Predicate encryption supporting disjunctions, polynomial equations, and inner products</title>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
		<idno type="DOI">10.1007/s00145-012-9119-4</idno>
		<ptr target="http://dx.doi.org/10.1007/s00145-012-9119-4" />
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology-Eurocrypt&apos;08</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">4965</biblScope>
			<biblScope unit="page" from="146" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Functional encryption: Definitions and challenges</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-19571-6_16</idno>
		<ptr target="http://dx.doi.org/10.1007/978-3-642-19571-6_16" />
	</analytic>
	<monogr>
		<title level="m">Theory of Cryptography Conference, TCC&apos;11</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="253" to="273" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Fully secure funtional encryption: Attibute-based encryption and (hierarchial) inner product encryption</title>
		<author>
			<persName><forename type="first">A</forename><surname>Lewko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Takashima</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-13190-5_4</idno>
		<ptr target="http://dx.doi.org/10.1007/978-3-642-13190-5_4" />
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology-Eurocrypt&apos;10</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6110</biblScope>
			<biblScope unit="page" from="62" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Attribute-based encryption supporting direct/indirect revocation modes</title>
		<author>
			<persName><forename type="first">N</forename><surname>Attrapadung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Imai</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-10868-6_17</idno>
		<ptr target="http://dx.doi.org/10.1007/978-3-642-10868-6_17" />
	</analytic>
	<monogr>
		<title level="m">IMA International Conference on Cryptography and Coding</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="278" to="300" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Hierarhical attribute-based encryption for fine-grained access control in cloud storage services</title>
		<author>
			<persName><forename type="first">G</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wu</surname></persName>
		</author>
		<idno type="DOI">10.1145/1866307.1866414</idno>
		<ptr target="http://dx.doi.org/10.1145/1866307.1866414" />
	</analytic>
	<monogr>
		<title level="m">ACM CCS&apos;10</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="735" to="737" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Achieving secure, scalable, and fine-grained data access control in cloud computing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Lou</surname></persName>
		</author>
		<idno type="DOI">10.1109/INFCOM.2010.5462174</idno>
		<ptr target="http://dx.doi.org/10.1109/INFCOM.2010.5462174" />
	</analytic>
	<monogr>
		<title level="m">IEEE INFOCOM&apos;10</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="1" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">A method for fast revocation of public key certificates and security capabilities</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Tsudik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wong</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>USENIX Security</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Outsourcing the decryption of abe ciphertexts</title>
		<author>
			<persName><forename type="first">M</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hohenberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security&apos;11</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Fully-rcca-cca-secure ciphertext-policy attribute based encryption with security mediator</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Au</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">16th International Conference on Information and Communications Security, ICICS&apos;14</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note>in press</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
