<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Dynamic Credentials and Ciphertext Delegation for Attribute-Based Encryption</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Amit</forename><surname>Sahai</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<address>
									<country>UCLA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Hakan</forename><surname>Seyalioglu</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Mathematics</orgName>
								<orgName type="institution">UCLA</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Texas at Austin</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Dynamic Credentials and Ciphertext Delegation for Attribute-Based Encryption</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8DD669C859E52CE4697C37F0B96F1699</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:11+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Motivated by the question of access control in cloud storage, we consider the problem using Attribute-Based Encryption (ABE) in a setting where users' credentials may change and ciphertexts may be stored by a third party. Our main result is obtained by pairing two contributions:</p><p>-We first ask how a third party who is not trusted with secret key information can process a ciphertext to disqualify revoked users from decrypting data encrypted in the past. Our core tool is a new procedure called ciphertext delegation that allows a ciphertext to be 're-encrypted' to a more restrictive policy using only public information.</p><p>-Second, we study the problem of revocable attribute-based encryption. We provide the first fully secure construction by modifying an attribute-based encryption scheme due to Lewko et al. [9]  and prove security in the standard model. We then combine these two results for a new approach for revocation on stored data. Our scheme allows a storage server to update stored ciphertexts to disqualify revoked users from accessing data that was encrypted before the user's access was revoked while key update broadcasts can dynamically revoke selected users.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The need to store information externally has never been higher: With users and organizations expecting to access and modify information across multiple platforms and geographic locations, there are numerous advantages to storing data in the cloud. However, there is a natural resistance to the idea of handing over sensitive information to external storage. Since these databases are often filled with valuable data, they are high value targets for attackers and security breaches in such systems are not uncommon, especially by insiders. In addition, organizations with access to extremely sensitive data might not want to give an outside server any access to their information at all. Similar problems can easily arise when dealing with centralized storage within a single organization, where users in different departments have access to varying levels of sensitive data.</p><p>A first step in addressing this problem of trust is to only store information in encrypted form. However, data access is not static -as employees are hired, fired or promoted, it will be necessary to change who can access certain data. A natural solution to this problem is to have users authenticate their credentials before giving them access to data; but such an approach requires a great deal of trust in the server: a malicious party may be able to penetrate the server and bypass authentication by exploiting software vulnerabilities. A solution that avoids this problem is to use cryptographically enforced access control such as attribute-based encryption (ABE) <ref type="bibr" target="#b19">[18]</ref>. However, this fails to address the problem that the credentials of a user may change with time. This problem motivated the study of revocation <ref type="bibr" target="#b3">[3]</ref> where a nightly key update would only allow non-revoked users to update their keys to decrypt newly encrypted data. Dynamic credentials in the context of stored data, however, present novel challenges that have not been considered in previous study on revocation. Take the following example.</p><p>A Motivating Story. Consider an employee with access to sensitive documents necessary for his work <ref type="foot" target="#foot_0">1</ref> . One day, this employee is terminated and has his access revoked. Now, this employee with insider knowledge of the organization's systems, and who has retained his old key, may attempt to penetrate the database server and decrypt all the files that he once had access to. How can we deal with this type of attack? At first glance, there appears to be an inherent intractability to this problem. Any encrypted file that the user could decrypt with his old key will still be decryptable, after all.</p><p>Despite these problems, we believe this situation presents a very real security threat to the organization and is important to address. One method to handle this problem is to decrypt and re-encrypt all stored data every time some employee's credentials are revoked. However, the involvement of secret key information in this process both makes this process cumbersome and opens up the overall system to problematic new vulnerabilities. In general, we want to limit the use of secret key information to only key generation and not to database upkeep as the database is handling constant two way communication in our system and is therefore modeled as the most vulnerable party.</p><p>We propose a novel method to deal with this problem: We devise a revocable ABE system where the database, using only publicly available information, can periodically update the ciphertexts stored on the system, so that as soon as access is revoked for a user, all stored files (no matter how old) immediately become inaccessible to this user after the update process. The database does not even need to know the identities of users whose access was revoked. We emphasize that this is a significant security improvement over decrypting and re-encrypting (which cannot be done with only public information) since in our solution, the database server never needs access to any secret keys. Furthermore, secret key holders do not have to interact with the database for the purpose of maintaining access control.</p><p>We also note in passing that while re-encrypting each ciphertext after every revocation (in a repeated nesting fashion) can also be applied to solve the problem of access control, this solution is inefficient when a ciphertext needs to be updated many times. In such a solution, decryption time will increase linearly and the ciphertext may grow significantly upon each invocation (Even using hybrid encryption, this would add a potentially large ABE header each time).</p><p>Our Results. In this work, we provide the first Revocable ABE scheme that deals with the problem of efficiently revoking stored data. This result is obtained through two main technical contributions:</p><p>Revocable Storage Attribute-Based Encryption. We provide ABE encryption schemes with a new property we call revocable storage. Revocable storage allows a third party storing ciphertexts to revoke access on previously encrypted data. Additionally, our scheme satisfies strong efficiency guarantees with regard to the lifetime of the database.</p><p>We realize revocable storage by introducing a notion of ciphertext delegation. In ABE, ciphertext delegation is the ability to restrict a ciphertext with access policy P to a more restrictive policy P using only publicly available information, but without causing the ciphertext size to increase. We initiate the first systematic study of ciphertext delegation for both Key-Policy ABE (KP-ABE) and Ciphertext-Policy ABE (CP-ABE) by analyzing the type of delegation possible in a variety of existing schemes <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b19">18,</ref><ref type="bibr" target="#b20">19,</ref><ref type="bibr" target="#b9">9]</ref>.</p><p>Protecing Newly Encrypted Data. To utilize revocable storage we need a method for efficiently revoking users' credentials such that newly encrypted data will not be decryptable by a user's key if that user's access has been revoked. This topic of revoking credentials was considered by Boldyreva et al. <ref type="bibr" target="#b3">[3]</ref> in the context of Identity-Based Encryption (and to restricted notions of security for ABE); however was not paired with the revocation of ciphertexts. In addition, ours is the first fully (vs. selectively ) secure system<ref type="foot" target="#foot_1">2</ref> .</p><p>While the Boldyreva et al. system needed to be proven "from scratch", we provide a methodology to obtain a simple construction and proof. We propose a natural modification to standard ABE which we call Piecewise Key Generation. This requirement is similar to the standard ABE requirement but allows for an adversary to build his key 'piece by piece'. Many existing proof methods extend with only minor modifications to prove piecewise security of existing schemes. We show that variants of the transformation method of Boldyreva et al. <ref type="bibr" target="#b3">[3]</ref> succeed in converting any ABE scheme with piecewise key generation to a revocable ABE scheme. We give a modification of Lewko et al.'s fully secure ABE scheme <ref type="bibr" target="#b9">[9]</ref> that satisfies our requirement and prove its security. Combined with our new techniques for dealing with revocable storage, this yields our Revocable Storage KP-ABE and CP-ABE schemes.</p><p>Related Work. Originally proposed by Sahai and Waters <ref type="bibr" target="#b19">[18]</ref>, attribute-based encryption <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b17">16,</ref><ref type="bibr" target="#b20">19,</ref><ref type="bibr" target="#b9">9,</ref><ref type="bibr" target="#b16">15]</ref> has been an active research area in cryptography in part since it is a primitive with interesting functional applications <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b3">3]</ref> and can be implemented efficiently <ref type="bibr" target="#b2">[2]</ref>. In a key-policy attribute-based encryption (KP-ABE) scheme every secret key is generated with a policy P and ciphertexts are generated with a set of attributes U and decryption is only possible if P (U ) = True. While the problem of delegating a key to a more restrictive key has been considered <ref type="bibr" target="#b8">[8]</ref>, it is analyzed only in the context of the scheme proposed in the paper. The problem of revocation is also a well studied problem, both for general PKI <ref type="bibr" target="#b12">[11,</ref><ref type="bibr" target="#b15">14,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b13">12,</ref><ref type="bibr" target="#b14">13,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b6">6]</ref>, identity based encryption <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b11">10]</ref> and attributebased encryption <ref type="bibr" target="#b18">[17]</ref>. At a high level, our revocable storage results can be seen as taking methods from forward secure encryption <ref type="bibr" target="#b4">[4]</ref> which were introduced for key management and applying them to ciphertext management by noticing that the key delegation infrastructure can be replicated for the ciphertext through the delegation mechanism we introduce.</p><p>Roadmap. We briefly give an organizational outline to the paper. We begin with an introduction to preliminary notions and notation including formally defining attribute-based encryption and revocable ABE in Section 2. In Section 3 we define the piecewise key generation requirement that implies a revocable ABE scheme in a black-box fashion. In Section 4 we define revocable storage. Ciphertext delegation is defined and studied in Section 5. We give a technical lemma to efficiently handle time in our final construction in Section 6. We combine all our previously introduced tools to give our main construction of a revocable storage ABE scheme from an ABE scheme with piecewise key generation and ciphertext delegation in Section 7. We finally give a construction of an ABE scheme with piecewise key generation and ciphertext delegation in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries and Notation</head><p>We will assume e : G × G → G T is a non-degenerate bilinear pairing whenever it is used. We use [i, j] to denote the set of all integers from i to j inclusive or [i] as shorthand for <ref type="bibr">[1, i]</ref>. Throughout this paper, log(x) will denote the logarithm of x to the base 2. The notation V (T ) for a tree T will denote the set of nodes of this tree. The notation x ← X for X a randomized algorithm may denote by context either that x is a possible output of that algorithm with positive probability or that x is drawn from the distribution X. We now briefly give the syntax for the two central notions for this chapter.</p><p>Attribute-Based Encryption. Attribute-based encryption schemes are generally divided into two types depending on if the access policy is embedded in the keys or ciphertexts. The security game requires that an adversary queries keys corresponding to policies, and in the challenge phase requests the encryption of one of two adaptively chosen messages with an attribute set of its choice (generated during the challenge phase). The adversary succeeds if it correctly outputs the encrypted message without ever querying a key for a policy that is satisfied by the attribute set of the challenge ciphertext (we defer a formal security guarantee until we also introduce revocability). In a Ciphertext-Policy ABE (CP-ABE) scheme the placement of the policy is reversed, the key generation algorithm takes a set of attributes as input while encryption takes a policy. In these conference proceedings, we only detail the KP-ABE version of our results and delay the definition of revocable storage CP-ABE and our construction to the full version.</p><p>Revocable Attribute-Based Encryption. A revocable attribute-based encryption scheme <ref type="bibr" target="#b3">[3]</ref> has the added functionality that a user may be placed on a revocation list that will make him unable to decrypt any message encrypted after he was revoked. Such a scheme has a periodic broadcast by a trusted key generation authority that allows the un-revoked users to update their keys and continue decryption. In such a scheme we assume that the total number of users and the number of key updates the scheme can survive are both very large and therefore the scheme's parameters should only depend polylogarithmically on the total number of non-revoked users and time bound. As in previous work, we will assume the key generation procedure is stateful for these constructions (it can store information used to create other keys in internal state denoted by σ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2. (Revocable KP-ABE)</head><p>A Revocable KP-ABE scheme with attribute set Ω that supports policies P with message space M, time bound T and identity length I consists of the following algorithms:</p><p>-Setup(1 λ ) → (P K, MSK, σ): Setup takes as input the security parameter and outputs the public key, master secret key and initializes σ = ∅. -KeyGen(M SK, P, ID, σ) → (SK P,ID , σ): Key generation outputs a secret key with policy P ∈ P for the user ID ∈ {0, 1} I and updates the state σ. Note that for both oracles σ is not sent to the adversary but is used to update the current σ value of the scheme. For a p.p.t. adversary A define the following experiment (some additional constraints on the adversary's actions will be enumerated after the experiment's definition). We use the term challenger for an internal agent in the security game who participates in the experiment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RKP-Security</head><formula xml:id="formula_0">A (1 λ ):</formula><p>1. The challenger runs Setup(1 λ ) → (P K, MSK, σ) and sends P K to A; 2. A is given oracle access to SK(•, •), K(•, •) until it signals the query phase is over; 3. After the query phase, A returns (M 0 , M 1 , S * , t * ) to the challenger; 4. The challenger picks b a random bit and returns to A: The conditions placed on the adversary's queries are as follows: For any query, SK(P, ID) such that P (S * ) = 1, ID ∈ rl for every query K(t, rl) with t ≥ t * .</p><formula xml:id="formula_1">C S * ,t * ← Encrypt(P K, M b , S * , t * );</formula><p>Informally this corresponds to the fact that every user with sufficient credentials to decrypt the challenge ciphertext should be revoked by time t * for the message to remain hidden.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3. A Revocable KP-ABE scheme is secure if for any polynomial time adversary</head><p>A the advantage of this adversary in the RKP-Security game:</p><formula xml:id="formula_2">2 Pr RKP-Security A (1 λ ) = 1 -1 is negligible in λ.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Revocable Attribute-Based Encryption</head><p>The Revocable ABE and IBE constructions given by Boldyreva et al. <ref type="bibr" target="#b3">[3]</ref> are built from an underlying ABE scheme through a new transformation they introduce. However, security of the underlying ABE scheme does not imply security of the transformation, and their resulting scheme was proven secure (in the ABE case, in the restricted selective security model) from scratch. In this work we aim to both extend and simplify previous work by investigating the additional properties an ABE scheme needs to satisfy to imply a Revocable ABE scheme following their transformation. Using our result, we modify the fully secure scheme due to Lewko et al. <ref type="bibr" target="#b9">[9]</ref> to satisfy our requirement in both the KP-ABE and CP-ABE setting. This yields the first fully secure Revocable KP-ABE and CP-ABE schemes.</p><p>The Requirement: Piecewise Key Generation. We find that the necessary condition an ABE scheme should satisfy in order to imply a revocable ABE scheme is that key generation can be done in a dual componentwise fashion. In the KP-ABE setting keys will have two separate policies P 0 and P 1 such that decryption succeeds for an encryption with attribute set S if and only if P 0 (S) = 1 and P 1 (S) = 1. The adversary in the security game is allowed to query these components separately with access to two oracles KeyGen 0 and KeyGen 1 which take as input a policy and an identifier U such that a key KeyGen 0 (M SK, P 0 , U) and KeyGen 1 (M SK, P 1 , U ) can only be combined if U = U (in our applications this U value will be related to, but will not exactly be a user's identity.</p><p>For this reason, we switch notation from identities ID to identifiers U at this point). This security definition is stronger than the standard ABE definition because these components may be queried in an adaptive manner, allowing the adversary to build his key piece by piece. Note the actual notation we use in our scheme is slightly different than the way it is presented above. For the rest of this section we will assume key generation is allowed to be stateful (as captured with σ in the Revocable ABE definition) but will omit the state being updated as part of the syntax of the key generation algorithm from this point on for notational simplicity. -Decrypt(C S , K 0 , K 1 ) → M.</p><p>We now define correctness of the scheme: Definition 5. (Correctness) A KP-ABE scheme with piecewise key generation is correct if for any S ⊆ Ω and:</p><formula xml:id="formula_3">-(P K, MSK) ← Setup(1 λ ), -C S ← Encrypt(P K, M, S), -P 0 , P 1 ∈ P such that P 0 (S) = P 1 (S) = 1: If KeyGen(M SK, 0, P 0 , U) → K (0) P0,U , KeyGen(M SK, 1, P 1 , U) → K (1) P1,U , then, Decrypt(C S , K (0) P0,U , K (1) P1,U ) = M.</formula><p>The definition for security for a scheme with piecewise key generation is now as one would expect: Unless the adversary has queried a single identifier U to KeyGen(M SK, 0, P 0 , U) and KeyGen(M SK, 1, P 1 , U) such that P 0 (S) = P 1 (S) = 1, he should not be able to distinguish which message has been encrypted. We formalize this through the following game: </p><formula xml:id="formula_4">Piecewise KPABE Security A (1 λ ):</formula><formula xml:id="formula_5">2 Pr Piecewise KPABE Security A (1 λ ) = 1 -1 is negligible in λ.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Revocability from Piecewise KP-ABE</head><p>To apply our results to revocability we will need to make a requirement on exactly what types of policies we are assuming our piecewise KP-ABE scheme can support. Since our ultimate goal is to apply our result to the construction of <ref type="bibr" target="#b9">[9]</ref>, we will state our result if the KP-ABE scheme supports access policy formatted as LSSS matrices (as in <ref type="bibr" target="#b9">[9]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>LSSS Matrices.</head><p>We begin with a brief overview of LSSS matrices. A LSSS (linear secret sharing scheme) policy is of the type (A, ρ) where A is an n × l matrix over the base field F (whose dimensions may be chosen at the time of encryption) and ρ is a map from [n] to Ω, the universe of attributes in the scheme. A policy (A, ρ) satisfies an attribute set S ⊆ Ω if and only if 1 = (1, 0, 0, . . . , 0) ∈ F l is contained in Span F (A i : ρ(i) ∈ S) where A i is the i th row of A. An LSSS policy (A, ρ) is called injective if ρ is injective. We now state our result on a black-box reduction between KP-ABE schemes with piecewise key generation supporting LSSS policies to Revocable KP-ABE supporting LSSS policies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1. Let E be a KP-ABE scheme with piecewise key generation supporting injective LSSS matrices with attribute set of size ω. Then there exists a Revocable KP-ABE scheme F supporting injective LSSS matrices with time bound T with an attribute set of size ω -2 log(T ).</head><p>In Section 7 we prove a stronger statement: In language that will be introduced shortly, we will prove that a KP-ABE scheme with piecewise key generation and cipertext delegation implies a Revocable-Storage KP-ABE scheme. The construction presented in Section 5 when the underlying scheme does not have ciphertext delegation fulfills the requirement of being a Revocable KP-ABE scheme and therefore we defer the construction to that section. In Section 8 we give a modification of the fully secure ABE scheme due to Lewko et al. <ref type="bibr" target="#b9">[9]</ref> that has piecewise key generation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Revocable-Storage Attribute Based Encryption</head><p>Motivated by settings in which a third party is managing access on encrypted data, we now present a new direction for revocability. We call the property we achieve revocable storage -the ability for a ciphertext to be updated using only the public key so that revoked users can no longer decrypt the refreshed ciphertext. This is an additional functionality that is added onto standard revocability, allowing an untrusted third party storing ciphertexts to update them in a way to make revoked users unable to decrypt messages they were once authorized to access. This can be thought of as an adaptation of forward security <ref type="bibr" target="#b4">[4]</ref> which is used to manage keys, to managing ciphertexts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 7. (Revocable Storage) A Revocable KP-ABE scheme has Revocable Storage if it has the following additional algorithm:</head><p>-CTUpdate(C S,t , P K) → C S,t+1 : Ciphertext updating transforms a ciphertext encrypted at time t to an independent encryption of the same message under the same set S at time t + 1.</p><p>Formally Note that this is a very strong distributional requirement as we are insisting that starting from any ciphertext allows complete resampling from the output of the encryption algorithm. This strong requirement is motivated further in the following section.</p><p>We will call a Revocable KP-ABE scheme with Revocable Storage, a Revocable Storage KP-ABE scheme for brevity. Notice that the above procedure allows us to accomplish our motivating applications; it allows a third party storing ciphertexts to update the ciphertexts after revocation has been done at time t so that only the non-revoked users can continue decrypting. We will impose the restriction that all parameters should only depend polylogarithmically on T , the upper bound for the time component and n, the total number of users in the scheme. It is worth observing that there are trivial inefficient ways to satisfy this requirement assuming a standard KP-ABE scheme (i.e. by having C S,t = {Encrypt(P K, M, S, t ) : t ≥ t} and having the update procedure simply delete the lowest indexed ciphertext) that depend polynomially on T .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Ciphertext Delegation</head><p>Revocable storage centers around allowing an untrusted third party to manage access on ciphertexts by incrementing the time component. To accomplish this, we need a process by which a ciphertext can be made harder to decrypt using only public operations in a more efficient way than simply re-encrypting under the more restrictive policy.</p><p>We call this problem ciphertext delegation -where a user who has access to only the ciphertext and public key may process this information into a completely new encryption under a more restrictive access policy. We consider this problem for attribute based encryption and show a simple method to classify delegation made possible in existing ABE schemes. We say that a ciphertext with a given access policy can be delegated to a more restrictive policy if there is a procedure that given any valid encryption of a message under the first policy produces a independent and uniformly chosen encryption of the same message under the new access policy. Note delegation is required to produce a new encryption of the same message that is independent of the randomness and access policy of the original ciphertext being delegated from. This requirement is crucial if multiple delegations from the same base ciphertext are ever used in a scheme. Without this guarantee, multiple delegations may have correlated randomness and the security of the underlying scheme would not imply any security in these applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">KP-ABE Ciphertext Delegation</head><p>For monotone access policies (as are generally considered in the literature <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b9">9,</ref><ref type="bibr" target="#b19">18]</ref>), the natural way to restrict access is by removing attributes from the ciphertext's attribute set. Note that for non-monotone access policies, delegation is not achievable without severely limiting the key policies permitted as any change in attribute set will make the ciphertext decryptable to certain simple policies not previously authorized, implying that delegation would violate security if these policies are supported.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 8. (KP Delegation) A KP-ABE scheme E with message space</head><p>M and attribute space Ω is said to have ciphertext delegation if there is an algorithm Delegate with the following guarantee: For any S ⊆ S ⊆ Ω and any</p><formula xml:id="formula_6">(P K, MSK) ← E.Setup(1 λ ), M ∈ M and C S ← E.Encrypt(P K, M, S): E.Delegate(P K, C S , S ) ≡ E.Encrypt(P K, M, S ).</formula><p>We show briefly how delegation is possible in the KP-ABE scheme due to Goyal et al. <ref type="bibr" target="#b8">[8]</ref> as the delegation procedures in the other listed schemes follow similarly. In this scheme, a ciphertext C S with attribute set S is encrypted as:</p><formula xml:id="formula_7">C S = (S, M Y s , {T s i : i ∈ S})</formula><p>where s is chosen uniformly in Z p and {T i : i ∈ S}, Y are part of the public key. To delegate this to an encryption under attribute set S ⊆ S, we first modify the ciphertext to be (S , MY s , {T s i : i ∈ S }) by replacing S with S and deleting elements in the third component. While this is a valid ciphertext under attribute set S notice that it is not a valid delegation since we require the delegated ciphertext to be a completely independent encryption. By generating Y s , {T s i : i ∈ S } with s uniformly chosen from Z p , the ciphertext can be modified to (S , MY s+s , {T s+s i : i ∈ S }) which is a fresh uniform encryption of M with attribute set S . A similar simple analysis also holds for <ref type="bibr" target="#b9">[9,</ref><ref type="bibr" target="#b19">18]</ref> which allows us to conclude: Theorem 2. The KP-ABE schemes in <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b9">9,</ref><ref type="bibr" target="#b19">18]</ref> have ciphertext delegation.</p><p>In the full version of this paper we also give full delegation procedures for a variety of existing CP-ABE schemes whose access structures are either built on threshold trees <ref type="bibr" target="#b19">[18,</ref><ref type="bibr" target="#b2">2]</ref> or LSSS matrices <ref type="bibr" target="#b20">[19,</ref><ref type="bibr" target="#b9">9]</ref>. For this analysis we define certain operations that we call elementary ciphertext manipulations that can be performed on ciphertexts which all the schemes we mentioned above allow and show how any CP-ABE scheme that allows elementary ciphertext manipulations actually allows robust delegation operations on the underlying ciphertext. We cite one of our results which follows as a special case of our more general analysis. A formal definition of threshold trees is present either in the full version of this paper or in either of the cited works 3 . Theorem 3. The CP-ABE schemes <ref type="bibr" target="#b19">[18,</ref><ref type="bibr" target="#b2">2]</ref>) allow the following delegation: A ciphertext C T encrypted under threshold tree T can be delegated to a ciphertext C T if T can be derived from T by any sequence of the following operations:</p><p>1. Inserting a node x along an edge with threshold n x = 1 (In other words, splitting an edge into two, connected by a node x). 2. Increasing a threshold n x → n x + 1 while optionally adding another descendent leaf y to x assigned to an arbitrary attribute. 3. Deleting a subtree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Managing the Time Structure Efficiently</head><p>In this section we will give the main technical lemma needed to achieve efficient delegation. We use a binary tree Q of depth log(T ) = r (from now on we will assume T is a perfect power of 2 for notational convenience, if not then the r will just be taken to log(T ) rounded up to the next integer), in a method similar to that used by Canetti et al. <ref type="bibr" target="#b4">[4]</ref> in the context of forward secure encryption. Nodes of this tree will correspond to different attribute sets, while a single encryption of the delegatable scheme, interestingly, will be comprised of multiple encryptions from the underlying KP-ABE scheme, each one corresponding to an attribute set from a different node of the tree. While only one of these ciphertext components may be necessary for a secret key holder to decrypt, the ciphertexts include multiple components for delegation purposes.</p><p>Labeling Nodes of the Tree. Associate with each leaf of Q a string corresponding to its path from the root with 0's denoting that the path traverses the left child of the previous node and 1's indicating traversing through the right child. As an example, the string 0 r corresponds to the leftmost leaf of the tree while 0 r-1 • 1 corresponds to its right sibling. Associate non-leaf nodes to strings by the path from the root by using * values to pad the string to r bits. For example, the root node will be referred to by the string * r while 0 • * r-1 refers 3 Informally, a threshold tree is an access structure represented by a tree where leaves are labeled with attributes and each internal node is labeled with an integer threshold. To see if the tree evaluates to true on a set of attributes, first the leaves corresponding to these attributes are labeled true and all others are labeled false. Then an internal node on the second level is labeled true only if a number of its descendents equal to or exceeding its threshold are labeled true. After this process is recursed through all of the tree, if the root evaluates to true, the threshold tree is satisfied.</p><p>to its left child. The string associated with a node v will be labeled b(v). We refer to the node associated with a string x as v x ; notice this gives a bijection between the time components t ∈ {0, 1} r , and the leaves of the tree Q.</p><p>Managing the access structure will require associating each time t ∈ [T ] with a set of nodes in the tree through a process we describe below. The following theorem will be the main method through which we will handle the time component of our final revocable storage construction. This theorem is also implicit in the work of <ref type="bibr" target="#b4">[4]</ref> but we provide a proof in the full version for containment. For the theorem statement we will replace the time bound T with q to avoid confusing it with the trees, that will be called T . The value r is now log(q). Below the term 'efficiently computable' means in time linear in r.</p><p>Theorem 4. There are (efficiently computable) subsets of V (Q) (the node set of Q where Q is a tree of depth r), {T i : i ∈ [q]} such that for all t ∈ {0, 1} r :</p><p>-Property 1. T t contains an ancestor of v t if and only if t ≤ t ; -Property 2. If u ∈ T t+1 then there is an ancestor of u in T t ; -Property 3. |T t | ≤ r.</p><p>We first give an informal intuition of how this sequence of trees will be used in the scheme. A secret key for time t will be associated with the leaf v t of Q while a ciphertext at time t will be associated with the set of nodes T t . A key for time t will succeed in decryption (by using the underlying KP-ABE scheme) if and only if v t is a descendant of some node of the ciphertext (Property 1. above will then imply that a key at time t will only succeed in decrypting ciphertexts from earlier times).</p><p>Additionally, in our implementation delegation will be possible by traversing down the tree -a ciphertext associated with a set of nodes will be delegatable to a ciphertext associated with another set if and only if for every node in the target set (for the ciphertext being delegated to), one of its ancestors is in the first set (the set associated with the ciphertext being delegated from). Property 2. allows us to update ciphertexts. Property 3. guarantees that this process can be done efficiently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Revocable Storage KP-ABE</head><p>By combining the method above for achieving linear delegation with our fully secure KP-ABE scheme with piecewise key generation and ciphertext delegation (given in Section 8), we will now show the following theorem. We defer the construction of our KP-ABE scheme with the required guarantees until after this section as the specific construction and security proof is involved and unnecessary for understanding the connection between piecewise key generation, delegation and revocable storage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 5. Let E be KP-ABE scheme with ciphertext delegation and piecewise key generation that supports injective LSSS matrices with attribute set size ω.</head><p>Then there exists a Revocable Storage KP-ABE scheme F that supports injective LSSS matrices with time bound T with attribute set size ω -2 log(T ).</p><p>To prove the above theorem, we will use a second tree U for revocation management (as in <ref type="bibr" target="#b3">[3]</ref>) with the identities {0, 1} I labeling the leaves. For a set of leaves V , the function U(V ) returns a (deterministically chosen) collection of nodes of U such that some ancestor of a leaf v is included in U(V ) if and only if v ∈ V . That such a function exists and can be computed in polynomial time in the size of V and I is shown in <ref type="bibr" target="#b3">[3]</ref>. Define Path(ID) for a string ID (where the name of the node identifies the path from the root to this node, as in Section 6) as the set of nodes from the root of U to the leaf v ID (including the root and leaf).</p><p>We separate the attribute set of E, reserving some attributes to only be used to manage the time component. Write the attribute set of E as Ω ∪ Ω where |Ω | = 2 log(T ) and label the components of Ω as:</p><formula xml:id="formula_8">Ω = {ω i,b : i ∈ [log(T )], b ∈ {0, 1}}</formula><p>and for each node y define (where the string b(y) is comprised of 0, 1 and * 's defined in Section 6 corresponding to the path from the root to this node with * 's padding the string to length log(T )) the set s y as follows. For all i ∈ [log(T )]:</p><formula xml:id="formula_9">-If b(y)[i] = 0, ω i,0 ∈ s y and if b(y)[i] = 1, ω i,1 ∈ s y , -If b(y)[i] = * , then ω i,0</formula><p>and ω i,1 are both included in s y .</p><p>we will shortly explain the significance of defining this set. Next let P t be the policy defined by:</p><formula xml:id="formula_10">P t (S) = 1 if and only if ω i,t[i] ∈ S ∀ i ∈ [log(T )]</formula><p>where t[i] is the i th bit of t. The important observation about P t and s y is that P t (s y ) = 1 if and only if y is an ancestor of the leaf corresponding to t and that injective LSSS matrices suffice to express the policies P t . The encryption and key generation procedures of F operate over Ω (which removes 2 log(T ) attributes from the scheme). We now describe how to construct our Revocable Storage KP-ABE scheme F from E defined above. We use T t as defined in Theorem 4.</p><p>- </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Return:</head><p>C S,t = {C S,x : x ∈ T t }.</p><p>(M 0 , M 1 ) and the tuple S * ∪ s x for al x ∈ T t * . Notice that by responding to the queries in this fashion we have perfectly simulated the expected distribution for A. It remains only to show that as long as A does not submit an invalid query that causes the experiment to automatically output 0 our A has not submitted an invalid query to the Piecewise KP-ABE oracle in the modified game. Take any S * ∪ s x in the challenge query that A makes as described above. Take any y ∈ U we now claim that either for either b = 0 or b = 1 all queries of the type (b, P, y) that A makes while simulating the queries of A, P (S * ∪s x ) = 0.</p><p>First consider the case where for some descendent leaf ID of y (which is a I bit string) that A makes a query to SK(P, ID) with P (S * ) = 1. In this case by the guarantee on the queries of A for all K(t, rl) queries with t ≥ t * , ID ∈ rl. This implies that for all queries of the type (1, P t , z) that A makes, either t &lt; t * (in which case P t (S * ∪ s x ) = 0 since P t does not depend on S * and P t (s x ) = 0 since x is not an ancestor of t because x ∈ T t * ) or ID ∈ rl which implies no ancestor of ID is contained in U(rl) and therefore, z is not an ancestor of ID and therefore z = y. So we have established that in this case, all (1, P, y) queries have the property that P (S * ∪ s x ) = 0 as desired.</p><p>Next, consider the case where A does not make a query to a descendent leaf ID of y with SK(P, ID) = 1. Then, in simulating A only makes (0, P, y) queries where P (S * ) = 0 which implies P (S * ∪ s x ) = 0 (since the policies for the Revocable scheme are only over Ω). This shows the desired statement in both cases, proving the theorem. Using the construction given in Section 8 we conclude: Theorem 6. Under Assumptions 1. 2. and 3. (defined below), when E is set to be the scheme given in Section 8 the above F is a secure Revocable Storage KP-ABE scheme supporting injective LSSS Matrices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Piecewise KP-ABE Construction</head><p>We now introduce the assumptions we will be using to build our scheme. These are the same assumptions from the fully secure ABE construction due to Lewko et al. <ref type="bibr" target="#b9">[9]</ref>: Assumption 1.Let G be a cyclic group of size N = p 1 p 2 p 3 with bilinear map e selected according to the group generator G(1 λ ). Consider the event that we generate g ← G p1 , X 3 ← G p3 , T 1 ← G p1,p2 , T 2 ← G p1 uniformly at random. Assumption 1. states that for any probabilistic polynomial time A:</p><p>| Pr[A(G, g, X 3 , T 1 ) = 0] -Pr[A(G, g, X 3 , T 2 ) = 0] is negligible in λ. Assumption 2. Let G be a cyclic group of size N = p 1 p 2 p 3 with bilinear map e selected according to the group generator G(1 λ ). Consider the event that we generate g, X 1 ← G p1 , X 2 , Y 2 ← G p2 , X 3 , Y 3 ← G p3 , T 1 ← G and T 2 ← G p1p3 uniformly at random. Assumption 2. states that for any probabilistic polynomial time A (if we let D = (G, g, X 1 X 2 , X 3 , Y 2 Y 3 ):</p><formula xml:id="formula_11">ρ(i)∈S e(C 0 , K (1) i ) ωi e(C ρ(i) , K (2) i ) ωi = ρ(i)∈S</formula><p>e(g, g) sωiAi•u e(g, T sriωi ρ(i) ) e(g, T ρ(i) ) sriωi = e(g, g) sαU And using the identical procedure with SK</p><p>(1)</p><p>U,(B,β) recovers e(g, g) s(α-αU ) allowing recovery of e(g, g) sα and M as C/e(g, g) sα .</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Definition 1 .</head><label>1</label><figDesc>(Key-Policy ABE) A KP-ABE scheme with attribute set Ω that supports policies P with message space M is defined by the following polynomial time algorithms:-Setup(1 λ ) → (P K,MSK): Setup takes as input the security parameter and outputs the public key and master secret key. -KeyGen(M SK, P ) → SK P : Key generation outputs a secret key with policy P ∈ P. -Encrypt(P K, M, S) → C S : Encrypts a message M ∈ M under the attribute set S ⊆ Ω. -Decrypt(SK P , C S ) → M : Decryption successfully recovers the encrypted message if and only if P (S) = 1 (i.e. the attribute set satisfies the policy).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>5 .</head><label>5</label><figDesc>A is once again given oracle access to the two oracles; 6. A returns a bit b . The experiment returns 1 if and only if b = band the conditions below concerning A's query history are satisfied.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Definition 4 .</head><label>4</label><figDesc>(Piecewise Key Generation)A KP-ABE scheme is said to have piecewise key generation with attribute set Ω supporting policies in P, message space M and identifier length I if key generation and encryption are modified to the following syntax:KeyGen takes as input the master key M SK, a bit b a policy P ∈ P and an identifier U ∈ {0, 1} I :-KeyGen(M SK, b, P, U ) → K (b) P,U . Decrypt takes two outputs of KeyGen as the key input instead of one:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>1 .</head><label>1</label><figDesc>The challenger runs Setup(1 λ ) → (P K, MSK) and sends P K to A; 2. A makes queries of the type (b, P, U ) for b ∈ {0, 1}, P ∈ P and U ∈ {0, 1} I . The challenger runs KeyGen(M SK, b, P, U ) and returns the key to A; 3. A signals the query phase is over and returns (M 0 , M 1 , S * ); 4. Challenger picks b a random bit, sends Encrypt(P K, M b , S * ) to A; 5. A has another query phase as previously; 6. A sends a bit b to the challenger; 7. If for any U , A has queried KeyGen(M SK, 0, P 0 , U) and KeyGen(M SK, 1, P 1 , U) such that P 0 (S * ) = P 1 (S * ) = 1 return 0; 8. If b = b return 1, otherwise return 0. Definition 6. A KP-ABE scheme with piecewise key generation is secure if for any polynomial time adversary A the advantage of this adversary in the Piecewise KPABE Security game:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Setup( 1 λ</head><label>1</label><figDesc>) : Return E. Setup(1 λ ) = (P K, MSK) -KeyGen(M SK, P, ID): For all x ∈ Path(ID) set SK (0) P,x = E.KeyGen(M SK, 0, P, x). : x ∈ Path(ID)}. -Encrypt(P K, M, S, t) where S ⊆ Ω: For all x ∈ T t set: C S,x = E.Encrypt(P K, M, S ∪ s x ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>-Encrypt(P K, M, S, t) → C S,t : Encrypts M ∈ M with attribute set S ⊆ Ω at time t ≤ T .-KeyUpdate(MSK, rl, t, σ) → (K t , σ): The update phase takes as input a revocation list rl (a set of strings in {0, 1} I ) and the master secret key, outputs the key update information for time t and updates the state σ. -Decrypt(SK P,ID , K t , C S,t ) → M : Decryption successfully recovers the encrypted message if and only if P (S) = 1, t ≥ t and ID was not revoked at time t (it was not present on rl when K t was generated). Define the following oracles to use in the security game. These oracles are given access to (P K, MSK, σ) that are generated at the beginning of the security game, and may have been modified since, at the time of the oracle's invocation.</figDesc><table><row><cell>Security Game Oracles.</cell></row></table><note><p>1. The Secret Key Generation oracle SK(•, •) takes as input (P, ID) and returns SK P,ID generated from: (SK P,ID , σ) ← KeyGen(M SK, P, ID, σ). 2. The Key Update Generation oracle K(•, •) takes as input t and a revocation list rl and returns K t generated from: (K t , σ) ← KeyUpdate(M SK, t, rl, σ).</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>While gainfully employed, the worker may have incentives to exercise discretion by only accessing the files necessary for his work and not download all files he has access to. Such discretion may be enforced, for example, through access logs.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>A related work<ref type="bibr" target="#b18">[17]</ref> proposes a 'fully secure Revocable ABE scheme' under a significantly different model than the one presented here.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. We gratefully thank Thomas King and Daniel Manchala of Xerox for stimulating discussions regarding ABE with dynamic credentials. In particular, Thomas King and Daniel Manchala suggested to us that the problem of revoking access to stored data that had not yet been accessed could be of significant interest in practice, and their suggestion inspired us to consider this problem. We also thank the anonymous reviewers for their helpful comments on our writeup.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Research supported in part from a DARPA/ONR PROCEED award, NSF grants 1136174, 1118096, 1065276, 0916574 and 0830803, a Xerox Faculty Research Award, a Google Faculty Research Award, an equipment grant from Intel, and an Okawa Foundation Research Grant. This material is based upon work supported by the Defense Advanced Research Projects Agency through the U.S. Office of Naval Research under Contract N00014-11-1-0389. The views expressed are those of the author and do not reflect the official policy or position of the Department of Defense or the U.S. Government. Research supported by a NSF Graduate Research Fellowship. Supported by NSF CNS-0915361 and CNS-0952692, AFOSR Grant No: FA9550-08-1-0352, DARPA through the U.S. Office of Naval Research under Contract N00014-11-1-0382, DARPA N11AP20006, Google Faculty Research award, the Alfred P. Sloan Fellowship, and Microsoft Faculty Fellowship, and Packard Foundation Fellowship. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the Department of Defense or the U.S. Government.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>-KeyUpdate(M SK, rl, t): For all x ∈ U(rl) set:</p><p>Pt,x = E. KeyGen(M SK, 1, P t , x).</p><p>Return:</p><p>Pt,x : x ∈ U(rl)}. -Decrypt(SK P,ID , K t , C S,t ): If ID ∈ rl when K t was generated, there is some x ∈ U(rl) ∩ Path(ID) (by the definition of U(V )). For this x there is:</p><p>P,x ∈ SK P,ID and SK</p><p>(1)</p><p>Additionally, if t ≥ t there is some y ∈ T t such that y is an ancestor of the leaf v t , which implies P t (s y ) = 1. For this y, take C S,y ∈ C S,t and return:</p><p>P t ,x , C S,y ).</p><p>If P (S) = 1 then P (S ∪ s y ) = P t (S ∪ s y ) = 1 implying decryption succeeds. -CTUpdate(P K, C S,t ): For all x ∈ T t+1 find y ∈ T t such that y is an ancestor of x. Then there is a C S,y component in C S,t . For all such x set:</p><p>Which is possible since y being an ancestor of x implies s x ⊂ s y . Return:</p><p>We now describe how security of the underlying E implies security of F in the Revocable KP-ABE security game. That CTUpdate is correct can be observed simply and it therefore only remains to argue that the above is a secure Revocable KP-ABE scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of RKP-ABE Security.</head><p>Let A be such that RKP-Security A is nonnegligible, we will construct an A such that Piecewise KP-ABE A is nonnegligible. We will modify the Piecewise security game slightly and give an A with non-negligible advantage when instead of a single challenge query, the adversary gives a pair of messages (M 0 , M 1 ) as well as a tuple of sets (S * 1 , S * 2 , . . . , S * ρ ) and is returned the tuple:</p><p>} by the challenger with the restriction that all S * i obey the restriction placed on S * in the standard game. This implies security in the standard Piecewise KP-ABE security game by a standard hybrid argument.</p><p>A begins by initializing the Piecewise KP-ABE security game and forwarding P K to A. To respond to an SK(P, ID) query A sends a query (0, P, x) to its key generation oracle for all x ∈ Path(ID) which drawn from the same distribution as the construction above. Similarly, for all queries K(t, rl), A sends a query (1, P t , x) for all x ∈ U(rl) to its key generation oracle to simulate the key update information.</p><p>When A makes a challenge query (M 0 , M 1 , S * , t * ) in order the simulate this, A in the modified game we described above will send as its challenge query</p><p>Let G be a cyclic group of size N = p 1 p 2 p 3 with bilinear map e selected according to the group generator G(1 λ ) with target group G T . Consider the event that we generate g ← G, α, s ← Z N , X 2 , Y 2 , Z 2 ← G p2 , X 3 ← G p3 uniformly at random. Finally select T 1 = e(g, g) αs and T 2 ← G T . Assumption 3. states that for any probabilistic polynomial time A, if we let</p><p>We now provide the construction that fulfils the requirements put forth in the body of the paper. We prove this theorem in the full version of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 7. The KP-ABE scheme given below has piecewise key generation, supports LSSS policies and has ciphertext delegation if Assumptions 1, 2, 3. hold.</head><p>Since G is cyclic, it has unique subgroups of size p 1 , p 2 and p 3 which we call G p1 , G p2 and G p3 respectively. We let the vector 1 stand as shorthand for 1 • 0 • 0 . . . 0 when the dimension is specified by context. Below we will give the decryption algorithm the public key as input, which was not part of our original definition, but can be easily adapted to our definition by including the public key as part of the secret key.</p><p>Setup(1 λ ) → (P K, MSK): Choose a bilinear group of order N = p 1 p 2 p 3 (three distinct primes) according to G(1 λ ). Then choose α ← Z N and g ← G p1 uniformly. For each i ∈ Ω, s i ← Z N uniformly at random. Pick X 3 ∈ G p3 uniformly with X 3 = 1 and set: P K = (N, g, e(g, g) α , X 3 , T i = g si for all i ∈ Ω) , MSK = (α, P K).</p><p>KeyGen(M SK, b, (A, ρ), U, P K). If α U has not been generated yet, generate it and store it. For each row </p><p>U,(B,β) , P K). Take ω i with i ω i A i = 1.</p><p>Label the components of SK </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Fast Digital Identity Revocation (Extended Abstract)</title>
		<author>
			<persName><forename type="first">W</forename><surname>Aiello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Lodha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 1998</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1462</biblScope>
			<biblScope unit="page" from="137" to="152" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Ciphertext-policy attribute-based encryption</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bethencourt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="321" to="334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Identity-based encryption with efficient revocation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Boldyreva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Goyal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>ACM CCS</publisher>
			<biblScope unit="page" from="417" to="426" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A Forward-Secure Public-Key Encryption Scheme</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2003</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Biham</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2656</biblScope>
			<biblScope unit="page" from="255" to="271" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Certificate-Based Encryption and the Certificate Revocation Problem</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2003</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Biham</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2656</biblScope>
			<biblScope unit="page" from="272" to="293" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Certificate Revocation Using Fine Grained Certificate Space Partitioning</title>
		<author>
			<persName><forename type="first">V</forename><surname>Goyal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FC 2007 and USEC 2007</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Dietrich</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Dhamija</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4886</biblScope>
			<biblScope unit="page" from="247" to="259" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Black-box accountable authority identitybased encryption</title>
		<author>
			<persName><forename type="first">V</forename><surname>Goyal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="427" to="436" />
		</imprint>
		<respStmt>
			<orgName>CCS</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Attribute-based encryption for finegrained access control of encrypted data</title>
		<author>
			<persName><forename type="first">V</forename><surname>Goyal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Pandey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="89" to="98" />
		</imprint>
		<respStmt>
			<orgName>CCS</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Fully Secure Functional Encryption: Attribute-Based Encryption and (Hierarchical) Inner Product Encryption</title>
		<author>
			<persName><forename type="first">A</forename><surname>Lewko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Takashima</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2010</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Gilbert</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">6110</biblScope>
			<biblScope unit="page" from="62" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Adaptive-ID Secure Revocable Identity-Based Encryption</title>
		<author>
			<persName><forename type="first">B</forename><surname>Libert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vergnaud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Fischlin</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">5473</biblScope>
			<biblScope unit="page" from="1" to="15" />
			<date type="published" when="2009">2009. 2009</date>
			<publisher>Springer</publisher>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
	<note>CT-RSA</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Efficient certificate revocation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LCS/TM</title>
		<imprint>
			<biblScope unit="volume">542</biblScope>
			<date type="published" when="1996">1996</date>
			<publisher>Massachusetts Institute of Technology</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">NOVOMODO: Scalable certificate validation and simplified PKI management</title>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 1st Annual PKI Research Workshop</title>
		<meeting>of 1st Annual PKI Research Workshop</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Revocation and tracing schemes for stateless receivers</title>
		<author>
			<persName><forename type="first">D</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lotspiech</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ECCC</title>
		<imprint>
			<biblScope unit="issue">043</biblScope>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Certificate revocation and certificate update</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nissim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in Communications</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="561" to="570" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Fully Secure Functional Encryption with General Relations from the Decisional Linear Assumption</title>
		<author>
			<persName><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Takashima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2010</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Rabin</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6223</biblScope>
			<biblScope unit="page" from="191" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Attribute-based encryption with nonmonotonic access structures</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CCS</title>
		<imprint>
			<biblScope unit="page">203</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Fully secure revocable attribute-based encryption</title>
		<author>
			<persName><forename type="first">J</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Dong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Shanghai Jiaotong University (Science)</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="490" to="496" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Fuzzy Identity-Based Encryption</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2005</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3494</biblScope>
			<biblScope unit="page" from="457" to="473" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Ciphertext-Policy Attribute-Based Encryption: An Expressive, Efficient, and Provably Secure Realization</title>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC 2011</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Catalano</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><surname>Fazio</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Nicolosi</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6571</biblScope>
			<biblScope unit="page" from="53" to="70" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
